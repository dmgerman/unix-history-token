begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Rpc op calls, generally called from the vnode op calls or through the  * buffer cache, for NFS v2, 3 and 4.  * These do not normally make any changes to vnode arguments or use  * structures that might change between the VFS variants. The returned  * arguments are all at the end, after the NFSPROC_T *p one.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|APPLEKEXT
end_ifndef

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nfs_numnfscbd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|timeval
name|nfsboottime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_int32_t
name|newnfs_false
decl_stmt|,
name|newnfs_true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|nfstype
name|nfsv34_type
index|[
literal|9
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_useacl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|nfsv4_callbackaddr
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NFSCLSTATEMUTEX
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|nfstest_outofseq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfscl_assumeposixlocks
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfscl_enablecallb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|nfsv4_cbport
init|=
name|NFSV4_CBPORT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfstest_openallsetattr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APPLEKEXT */
end_comment

begin_define
define|#
directive|define
name|DIRHDSIZ
value|(sizeof (struct dirent) - (MAXNAMLEN + 1))
end_define

begin_function_decl
specifier|static
name|int
name|nfsrpc_setattrrpc
parameter_list|(
name|vnode_t
parameter_list|,
name|struct
name|vattr
modifier|*
parameter_list|,
name|nfsv4stateid_t
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_readrpc
parameter_list|(
name|vnode_t
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|nfsv4stateid_t
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_writerpc
parameter_list|(
name|vnode_t
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|nfsv4stateid_t
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_createv23
parameter_list|(
name|vnode_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|vattr
modifier|*
parameter_list|,
name|nfsquad_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_createv4
parameter_list|(
name|vnode_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|vattr
modifier|*
parameter_list|,
name|nfsquad_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|nfsclowner
modifier|*
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_locku
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
parameter_list|,
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
parameter_list|,
name|u_int64_t
parameter_list|,
name|u_int64_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_setaclrpc
parameter_list|(
name|vnode_t
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|struct
name|acl
modifier|*
parameter_list|,
name|nfsv4stateid_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * nfs null call from vfs.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_null
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_NULL
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs access rpc op.  * For nfs version 3 and 4, use the access rpc to check accessibility. If file  * modes are changed on the server, accesses might still fail later.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_access
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|int
name|acmode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int32_t
name|mode
decl_stmt|,
name|rmode
decl_stmt|;
if|if
condition|(
name|acmode
operator|&
name|VREAD
condition|)
name|mode
operator|=
name|NFSACCESS_READ
expr_stmt|;
else|else
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
name|acmode
operator|&
name|VWRITE
condition|)
name|mode
operator||=
operator|(
name|NFSACCESS_MODIFY
operator||
name|NFSACCESS_EXTEND
operator||
name|NFSACCESS_DELETE
operator|)
expr_stmt|;
if|if
condition|(
name|acmode
operator|&
name|VEXEC
condition|)
name|mode
operator||=
name|NFSACCESS_LOOKUP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|acmode
operator|&
name|VWRITE
condition|)
name|mode
operator||=
operator|(
name|NFSACCESS_MODIFY
operator||
name|NFSACCESS_EXTEND
operator|)
expr_stmt|;
if|if
condition|(
name|acmode
operator|&
name|VEXEC
condition|)
name|mode
operator||=
name|NFSACCESS_EXECUTE
expr_stmt|;
block|}
comment|/* 	 * Now, just call nfsrpc_accessrpc() to do the actual RPC. 	 */
name|error
operator|=
name|nfsrpc_accessrpc
argument_list|(
name|vp
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
operator|&
name|rmode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * The NFS V3 spec does not clarify whether or not 	 * the returned access bits can be a superset of 	 * the ones requested, so... 	 */
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|rmode
operator|&
name|mode
operator|)
operator|!=
name|mode
condition|)
name|error
operator|=
name|EACCES
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The actual rpc, separated out for Darwin.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_accessrpc
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|u_int32_t
modifier|*
name|rmodep
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|u_int32_t
name|supported
decl_stmt|,
name|rmode
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|supported
operator|=
name|mode
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_ACCESS
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
comment|/* 		 * And do a Getattr op. 		 */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|supported
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
block|}
name|rmode
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
comment|/* 		 * It's not obvious what should be done about 		 * unsupported access modes. For now, be paranoid 		 * and clear the unsupported ones. 		 */
name|rmode
operator|&=
name|supported
expr_stmt|;
operator|*
name|rmodep
operator|=
name|rmode
expr_stmt|;
block|}
else|else
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs open rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_open
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|int
name|amode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|u_int32_t
name|mode
decl_stmt|,
name|clidrev
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|newone
decl_stmt|,
name|error
decl_stmt|,
name|expireret
init|=
literal|0
decl_stmt|,
name|retrycnt
decl_stmt|;
comment|/* 	 * For NFSv4, Open Ops are only done on Regular Files. 	 */
if|if
condition|(
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|!=
name|VREG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|amode
operator|&
name|FREAD
condition|)
name|mode
operator||=
name|NFSV4OPEN_ACCESSREAD
expr_stmt|;
if|if
condition|(
name|amode
operator|&
name|FWRITE
condition|)
name|mode
operator||=
name|NFSV4OPEN_ACCESSWRITE
expr_stmt|;
name|nfhp
operator|=
name|np
operator|->
name|n_fhp
expr_stmt|;
name|retrycnt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
block|{
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
name|int
name|namel
decl_stmt|;
name|namel
operator|=
operator|(
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
operator|<
literal|100
operator|)
condition|?
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
else|:
literal|99
expr_stmt|;
name|bcopy
argument_list|(
name|NFS4NODENAME
argument_list|(
name|np
operator|->
name|n_v4
argument_list|)
argument_list|,
name|name
argument_list|,
name|namel
argument_list|)
expr_stmt|;
name|name
index|[
name|namel
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"rpcopen p=0x%x name=%s"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfhp
operator|->
name|nfh_len
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" fh=0x%x\n"
argument_list|,
name|nfhp
operator|->
name|nfh_fh
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" fhl=0\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
do|do
block|{
name|dp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|nfscl_open
argument_list|(
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
operator|&
name|op
argument_list|,
operator|&
name|newone
argument_list|,
operator|&
name|ret
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
else|else
name|clidrev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSCLOPEN_DOOPEN
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_v4
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|nfsrpc_openrpc
argument_list|(
name|nmp
argument_list|,
name|vp
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_data
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_fhlen
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|mode
argument_list|,
name|op
argument_list|,
name|NFS4NODENAME
argument_list|(
name|np
operator|->
name|n_v4
argument_list|)
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
argument_list|,
operator|&
name|dp
argument_list|,
literal|0
argument_list|,
literal|0x0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|APPLE
name|OSBitAndAtomic
argument_list|(
operator|(
name|int32_t
operator|)
operator|~
name|NDELEGMOD
argument_list|,
operator|(
name|UInt32
operator|*
operator|)
operator|&
name|np
operator|->
name|n_flag
argument_list|)
expr_stmt|;
else|#
directive|else
name|NFSLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NDELEGMOD
expr_stmt|;
name|NFSUNLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|nfscl_deleg
argument_list|(
name|nmp
operator|->
name|nm_mountp
argument_list|,
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|newnfs_copyincred
argument_list|(
name|cred
argument_list|,
operator|&
name|op
operator|->
name|nfso_cred
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * nfso_opencnt is the count of how many VOP_OPEN()s have 	     * been done on this Open successfully and a VOP_CLOSE() 	     * is expected for each of these. 	     * If error is non-zero, don't increment it, since the Open 	     * hasn't succeeded yet. 	     */
if|if
condition|(
operator|!
name|error
condition|)
name|op
operator|->
name|nfso_opencnt
operator|++
expr_stmt|;
name|nfscl_openrelease
argument_list|(
name|op
argument_list|,
name|error
argument_list|,
name|newone
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
condition|)
block|{
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfs_open"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|clidrev
operator|!=
literal|0
condition|)
block|{
name|expireret
operator|=
name|nfscl_hasexpired
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|clidrev
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|retrycnt
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|expireret
operator|==
literal|0
operator|&&
name|clidrev
operator|!=
literal|0
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
condition|)
do|;
if|if
condition|(
name|error
operator|&&
name|retrycnt
operator|>=
literal|4
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * the actual open rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_openrpc
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|u_int8_t
modifier|*
name|nfhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|u_int8_t
modifier|*
name|newfhp
parameter_list|,
name|int
name|newfhlen
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|u_int8_t
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
modifier|*
name|dpp
parameter_list|,
name|int
name|reclaim
parameter_list|,
name|u_int32_t
name|delegtype
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|syscred
parameter_list|,
name|int
name|recursed
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ndp
init|=
name|NULL
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|u_int32_t
name|rflags
decl_stmt|,
name|deleg
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ret
decl_stmt|,
name|acesize
decl_stmt|,
name|limitby
decl_stmt|;
name|dp
operator|=
operator|*
name|dpp
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_OPEN
argument_list|,
name|nmp
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|mode
operator|&
name|NFSV4OPEN_ACCESSBOTH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
operator|(
name|mode
operator|>>
name|NFSLCK_SHIFT
operator|)
operator|&
name|NFSV4OPEN_DENYBOTH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclaim
condition|)
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_CLAIMPREVIOUS
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|delegtype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_CLAIMDELEGATECUR
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_CLAIMNULL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_CHANGE
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_TIMEMODIFY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|syscred
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NFSCL_INCRSEQID
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
literal|6
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
expr_stmt|;
name|rflags
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|6
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|deleg
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleg
operator|==
name|NFSV4OPEN_DELEGATEREAD
operator|||
name|deleg
operator|==
name|NFSV4OPEN_DELEGATEWRITE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_FIRSTDELEG
operator|)
condition|)
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
operator|->
name|nfsc_flags
operator||=
operator|(
name|NFSCLFLAGS_FIRSTDELEG
operator||
name|NFSCLFLAGS_GOTDELEG
operator|)
expr_stmt|;
name|MALLOC
argument_list|(
name|ndp
argument_list|,
expr|struct
name|nfscldeleg
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfscldeleg
argument_list|)
operator|+
name|newfhlen
argument_list|,
name|M_NFSCLDELEG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ndp
operator|->
name|nfsdl_owner
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ndp
operator|->
name|nfsdl_lock
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|nfsdl_clp
operator|=
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
expr_stmt|;
name|ndp
operator|->
name|nfsdl_fhlen
operator|=
name|newfhlen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|newfhp
argument_list|,
name|ndp
operator|->
name|nfsdl_fh
argument_list|,
name|newfhlen
argument_list|)
expr_stmt|;
name|newnfs_copyincred
argument_list|(
name|cred
argument_list|,
operator|&
name|ndp
operator|->
name|nfsdl_cred
argument_list|)
expr_stmt|;
name|nfscl_lockinit
argument_list|(
operator|&
name|ndp
operator|->
name|nfsdl_rwlock
argument_list|)
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|nfsdl_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ndp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ndp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ndp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ret
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleg
operator|==
name|NFSV4OPEN_DELEGATEWRITE
condition|)
block|{
name|ndp
operator|->
name|nfsdl_flags
operator|=
name|NFSCLDL_WRITE
expr_stmt|;
comment|/* 				 * Indicates how much the file can grow. 				 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|limitby
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|limitby
condition|)
block|{
case|case
name|NFSV4OPEN_LIMITSIZE
case|:
name|ndp
operator|->
name|nfsdl_sizelimit
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFSV4OPEN_LIMITBLOCKS
case|:
name|ndp
operator|->
name|nfsdl_sizelimit
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int64_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|nfsdl_sizelimit
operator|*=
name|fxdr_unsigned
argument_list|(
name|u_int64_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
empty_stmt|;
block|}
else|else
block|{
name|ndp
operator|->
name|nfsdl_flags
operator|=
name|NFSCLDL_READ
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
name|ndp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_RECALL
expr_stmt|;
name|error
operator|=
name|nfsrv_dissectace
argument_list|(
name|nd
argument_list|,
operator|&
name|ndp
operator|->
name|nfsdl_ace
argument_list|,
operator|&
name|ret
argument_list|,
operator|&
name|acesize
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
elseif|else
if|if
condition|(
name|deleg
operator|!=
name|NFSV4OPEN_DELEGATENONE
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
if|if
condition|(
name|ndp
operator|!=
name|NULL
condition|)
block|{
name|ndp
operator|->
name|nfsdl_change
operator|=
name|nfsva
operator|.
name|na_filerev
expr_stmt|;
name|ndp
operator|->
name|nfsdl_modtime
operator|=
name|nfsva
operator|.
name|na_mtime
expr_stmt|;
name|ndp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_MODTIMESET
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reclaim
operator|&&
operator|(
name|rflags
operator|&
name|NFSV4OPEN_RESULTCONFIRM
operator|)
condition|)
block|{
do|do
block|{
name|ret
operator|=
name|nfsrpc_openconfirm
argument_list|(
name|vp
argument_list|,
name|newfhp
argument_list|,
name|newfhlen
argument_list|,
name|op
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfs_open"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
do|;
name|error
operator|=
name|ret
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rflags
operator|&
name|NFSV4OPEN_LOCKTYPEPOSIX
operator|)
operator|||
name|nfscl_assumeposixlocks
condition|)
name|op
operator|->
name|nfso_posixlock
operator|=
literal|1
expr_stmt|;
else|else
name|op
operator|->
name|nfso_posixlock
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If the server is handing out delegations, but we didn't 		 * get one because an OpenConfirm was required, try the 		 * Open again, to get a delegation. This is a harmless no-op, 		 * from a server's point of view. 		 */
if|if
condition|(
operator|!
name|reclaim
operator|&&
operator|(
name|rflags
operator|&
name|NFSV4OPEN_RESULTCONFIRM
operator|)
operator|&&
operator|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_GOTDELEG
operator|)
operator|&&
operator|!
name|error
operator|&&
name|dp
operator|==
name|NULL
operator|&&
name|ndp
operator|==
name|NULL
operator|&&
operator|!
name|recursed
condition|)
block|{
do|do
block|{
name|ret
operator|=
name|nfsrpc_openrpc
argument_list|(
name|nmp
argument_list|,
name|vp
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|,
name|newfhp
argument_list|,
name|newfhlen
argument_list|,
name|mode
argument_list|,
name|op
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
operator|&
name|ndp
argument_list|,
literal|0
argument_list|,
literal|0x0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|syscred
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfs_open2"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
do|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|ndp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|ndp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|ret
operator|==
name|NFSERR_STALEDONTRECOVER
condition|)
name|error
operator|=
name|ret
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALECLIENTID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|dpp
operator|=
name|ndp
expr_stmt|;
elseif|else
if|if
condition|(
name|ndp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|ndp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * open downgrade rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_opendowngrade
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_OPENDOWNGRADE
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|mode
operator|&
name|NFSV4OPEN_ACCESSBOTH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
operator|(
name|mode
operator|>>
name|NFSLCK_SHIFT
operator|)
operator|&
name|NFSV4OPEN_DENYBOTH
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NFSCL_INCRSEQID
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * V4 Close operation.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_close
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|int
name|doclose
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|!=
name|VREG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|doclose
condition|)
name|error
operator|=
name|nfscl_doclose
argument_list|(
name|vp
argument_list|,
operator|&
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nfscl_getclose
argument_list|(
name|vp
argument_list|,
operator|&
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nfscl_clientrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the open.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrpc_doclose
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfscllock
modifier|*
name|lop
decl_stmt|,
modifier|*
name|nlop
decl_stmt|;
name|struct
name|ucred
modifier|*
name|tcred
decl_stmt|;
name|u_int64_t
name|off
init|=
literal|0
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|type
init|=
name|NFSV4LOCKT_READ
decl_stmt|;
name|int
name|error
decl_stmt|,
name|do_unlock
decl_stmt|,
name|trycnt
decl_stmt|;
name|tcred
operator|=
name|newnfs_getcred
argument_list|()
expr_stmt|;
name|newnfs_copycred
argument_list|(
operator|&
name|op
operator|->
name|nfso_cred
argument_list|,
name|tcred
argument_list|)
expr_stmt|;
comment|/* 	 * (Theoretically this could be done in the same 	 *  compound as the close, but having multiple 	 *  sequenced Ops in the same compound might be 	 *  too scary for some servers.) 	 */
if|if
condition|(
name|op
operator|->
name|nfso_posixlock
condition|)
block|{
name|off
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|NFS64BITSSET
expr_stmt|;
name|type
operator|=
name|NFSV4LOCKT_READ
expr_stmt|;
block|}
comment|/* 	 * Since this function is only called from VOP_INACTIVE(), no 	 * other thread will be manipulating this Open. As such, the 	 * lock lists are not being changed by other threads, so it should 	 * be safe to do this without locking. 	 */
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&op->nfso_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
name|do_unlock
operator|=
literal|1
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|lop
argument_list|,
argument|&lp->nfsl_lock
argument_list|,
argument|nfslo_list
argument_list|,
argument|nlop
argument_list|)
block|{
if|if
condition|(
name|op
operator|->
name|nfso_posixlock
operator|==
literal|0
condition|)
block|{
name|off
operator|=
name|lop
operator|->
name|nfslo_first
expr_stmt|;
name|len
operator|=
name|lop
operator|->
name|nfslo_end
operator|-
name|lop
operator|->
name|nfslo_first
expr_stmt|;
if|if
condition|(
name|lop
operator|->
name|nfslo_type
operator|==
name|F_WRLCK
condition|)
name|type
operator|=
name|NFSV4LOCKT_WRITE
expr_stmt|;
else|else
name|type
operator|=
name|NFSV4LOCKT_READ
expr_stmt|;
block|}
if|if
condition|(
name|do_unlock
condition|)
block|{
name|trycnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrpc_locku
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|lp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
name|tcred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_GRACE
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
operator|)
operator|&&
name|error
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfs_close"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_GRACE
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
operator|)
operator|&&
name|error
operator|==
literal|0
operator|&&
name|trycnt
operator|++
operator|<
literal|5
condition|)
do|;
if|if
condition|(
name|op
operator|->
name|nfso_posixlock
condition|)
name|do_unlock
operator|=
literal|0
expr_stmt|;
block|}
name|nfscl_freelock
argument_list|(
name|lop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * There could be other Opens for different files on the same 	 * OpenOwner, so locking is required. 	 */
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|nfscl_lockexcl
argument_list|(
operator|&
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_rwlock
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
do|do
block|{
name|error
operator|=
name|nfscl_tryclose
argument_list|(
name|op
argument_list|,
name|tcred
argument_list|,
name|nmp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfs_close"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
condition|)
do|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|nfscl_lockunlock
argument_list|(
operator|&
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_rwlock
argument_list|)
expr_stmt|;
comment|/* 	 * Move the lockowner to nfsc_defunctlockowner, 	 * so the Renew thread will do the ReleaseLockOwner 	 * Op on it later. There might still be other 	 * opens using the same lockowner name. 	 */
name|lp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|op
operator|->
name|nfso_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|LIST_NEXT
argument_list|(
name|lp
argument_list|,
name|nfsl_list
argument_list|)
operator|!=
name|NULL
condition|)
name|lp
operator|=
name|LIST_NEXT
argument_list|(
name|lp
argument_list|,
name|nfsl_list
argument_list|)
expr_stmt|;
name|LIST_PREPEND
argument_list|(
operator|&
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_defunctlockowner
argument_list|,
operator|&
name|op
operator|->
name|nfso_lock
argument_list|,
name|lp
argument_list|,
name|nfsl_list
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|op
operator|->
name|nfso_lock
argument_list|)
expr_stmt|;
block|}
name|nfscl_freeopen
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|NFSFREECRED
argument_list|(
name|tcred
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The actual Close RPC.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_closerpc
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|syscred
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_CLOSE
argument_list|,
name|nmp
argument_list|,
name|op
operator|->
name|nfso_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
operator|+
name|NFSX_STATEID
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|syscred
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NFSCL_INCRSEQID
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * V4 Open Confirm RPC.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_openconfirm
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_int8_t
modifier|*
name|nfhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_OPENCONFIRM
argument_list|,
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
operator|+
name|NFSX_STATEID
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NFSCL_INCRSEQID
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
expr_stmt|;
block|}
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the setclientid and setclientid confirm RPCs. Called from nfs_statfs()  * when a mount has just occurred and when the server replies NFSERR_EXPIRED.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_setclient
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|u_int8_t
modifier|*
name|cp
init|=
name|NULL
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
name|addr
index|[
name|INET6_ADDRSTRLEN
operator|+
literal|9
index|]
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|int
name|error
decl_stmt|,
name|isinet6
init|=
literal|0
decl_stmt|,
name|callblen
decl_stmt|;
name|nfsquad_t
name|confirm
decl_stmt|;
name|u_int32_t
name|lease
decl_stmt|;
specifier|static
name|u_int32_t
name|rev
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nfsboottime
operator|.
name|tv_sec
operator|==
literal|0
condition|)
name|NFSSETBOOTTIME
argument_list|(
name|nfsboottime
argument_list|)
expr_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_SETCLIENTID
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nfsboottime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|rev
operator|++
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|clp
operator|->
name|nfsc_id
argument_list|,
name|clp
operator|->
name|nfsc_idlen
argument_list|)
expr_stmt|;
comment|/* 	 * set up the callback address 	 */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFS_CALLBCKPROG
argument_list|)
expr_stmt|;
name|callblen
operator|=
name|strlen
argument_list|(
name|nfsv4_callbackaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|callblen
operator|==
literal|0
condition|)
name|cp
operator|=
name|nfscl_getmyip
argument_list|(
name|nmp
argument_list|,
operator|&
name|isinet6
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfscl_enablecallb
operator|&&
name|nfs_numnfscbd
operator|>
literal|0
operator|&&
operator|(
name|callblen
operator|>
literal|0
operator|||
name|cp
operator|!=
name|NULL
operator|)
condition|)
block|{
name|port
operator|=
name|htons
argument_list|(
name|nfsv4_cbport
argument_list|)
expr_stmt|;
name|cp2
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|port
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|callblen
operator|>
literal|0
operator|&&
name|strchr
argument_list|(
name|nfsv4_callbackaddr
argument_list|,
literal|':'
argument_list|)
operator|)
operator|||
name|isinet6
condition|)
block|{
name|char
name|ip6buf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|,
modifier|*
name|ip6add
decl_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
literal|"tcp6"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|callblen
operator|==
literal|0
condition|)
block|{
name|ip6_sprintf
argument_list|(
name|ip6buf
argument_list|,
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
name|ip6add
operator|=
name|ip6buf
expr_stmt|;
block|}
else|else
block|{
name|ip6add
operator|=
name|nfsv4_callbackaddr
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|addr
argument_list|,
name|INET6_ADDRSTRLEN
operator|+
literal|9
argument_list|,
literal|"%s.%d.%d"
argument_list|,
name|ip6add
argument_list|,
name|cp2
index|[
literal|0
index|]
argument_list|,
name|cp2
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
literal|"tcp"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|callblen
operator|==
literal|0
condition|)
name|snprintf
argument_list|(
name|addr
argument_list|,
name|INET6_ADDRSTRLEN
operator|+
literal|9
argument_list|,
literal|"%d.%d.%d.%d.%d.%d"
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|,
name|cp
index|[
literal|2
index|]
argument_list|,
name|cp
index|[
literal|3
index|]
argument_list|,
name|cp2
index|[
literal|0
index|]
argument_list|,
name|cp2
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|addr
argument_list|,
name|INET6_ADDRSTRLEN
operator|+
literal|9
argument_list|,
literal|"%s.%d.%d"
argument_list|,
name|nfsv4_callbackaddr
argument_list|,
name|cp2
index|[
literal|0
index|]
argument_list|,
name|cp2
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|addr
argument_list|,
name|strlen
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
literal|"tcp"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
literal|"0.0.0.0.0.0"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
block|}
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|clp
operator|->
name|nfsc_cbident
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|confirm
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|confirm
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
comment|/* 	     * and confirm it. 	     */
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_SETCLIENTIDCFRM
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|confirm
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|confirm
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_GETATTR
argument_list|,
name|nmp
argument_list|,
name|nmp
operator|->
name|nm_fh
argument_list|,
name|nmp
operator|->
name|nm_fhsize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_LEASETIME
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|lease
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|clp
operator|->
name|nfsc_renew
operator|=
name|NFSCL_RENEW
argument_list|(
name|lease
argument_list|)
expr_stmt|;
name|clp
operator|->
name|nfsc_expire
operator|=
name|NFSD_MONOSEC
operator|+
name|clp
operator|->
name|nfsc_renew
expr_stmt|;
name|clp
operator|->
name|nfsc_clientidrev
operator|++
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|nfsc_clientidrev
operator|==
literal|0
condition|)
name|clp
operator|->
name|nfsc_clientidrev
operator|++
expr_stmt|;
block|}
block|}
block|}
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs getattr call.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_getattr
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_GETATTR
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs getattr call with non-vnode arguemnts.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_getattrnovp
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|u_int8_t
modifier|*
name|fhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|int
name|syscred
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|u_int64_t
modifier|*
name|xidp
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|vers
init|=
name|NFS_VER2
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_GETATTR
argument_list|,
name|nmp
argument_list|,
name|fhp
argument_list|,
name|fhlen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|vers
operator|=
name|NFS_VER4
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|vers
operator|=
name|NFS_VER3
expr_stmt|;
block|}
if|if
condition|(
name|syscred
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|vers
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|xidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do an nfs setattr operation.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_setattr
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|NFSACL_T
modifier|*
name|aclp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|rnap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|expireret
init|=
literal|0
decl_stmt|,
name|openerr
decl_stmt|,
name|retrycnt
decl_stmt|;
name|u_int32_t
name|clidrev
init|=
literal|0
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|nfsv4stateid_t
name|stateid
decl_stmt|;
name|void
modifier|*
name|lckp
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
operator|&&
name|NFSATTRISSET
argument_list|(
name|u_quad_t
argument_list|,
name|vap
argument_list|,
name|va_size
argument_list|)
condition|)
name|mode
operator|=
name|NFSV4OPEN_ACCESSWRITE
expr_stmt|;
else|else
name|mode
operator|=
name|NFSV4OPEN_ACCESSREAD
expr_stmt|;
name|retrycnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|lckp
operator|=
name|NULL
expr_stmt|;
name|openerr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|nfhp
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_fhp
expr_stmt|;
name|error
operator|=
name|nfscl_getstateid
argument_list|(
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|stateid
argument_list|,
operator|&
name|lckp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|==
name|VREG
operator|&&
operator|(
name|mode
operator|==
name|NFSV4OPEN_ACCESSWRITE
operator|||
name|nfstest_openallsetattr
operator|)
condition|)
block|{
comment|/* 				 * No Open stateid, so try and open the file 				 * now. 				 */
if|if
condition|(
name|mode
operator|==
name|NFSV4OPEN_ACCESSWRITE
condition|)
name|openerr
operator|=
name|nfsrpc_open
argument_list|(
name|vp
argument_list|,
name|FWRITE
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|openerr
operator|=
name|nfsrpc_open
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|openerr
condition|)
operator|(
name|void
operator|)
name|nfscl_getstateid
argument_list|(
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|stateid
argument_list|,
operator|&
name|lckp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
name|error
operator|=
name|nfsrpc_setattrrpc
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
operator|&
name|stateid
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|rnap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nfsrpc_setaclrpc
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|aclp
argument_list|,
operator|&
name|stateid
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lckp
operator|!=
name|NULL
condition|)
name|nfscl_lockderef
argument_list|(
name|lckp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|openerr
condition|)
operator|(
name|void
operator|)
name|nfsrpc_close
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_OLDSTATEID
condition|)
block|{
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfs_setattr"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|clidrev
operator|!=
literal|0
condition|)
block|{
name|expireret
operator|=
name|nfscl_hasexpired
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|clidrev
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|retrycnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
operator|(
name|error
operator|==
name|NFSERR_OLDSTATEID
operator|&&
name|retrycnt
operator|<
literal|20
operator|)
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|expireret
operator|==
literal|0
operator|&&
name|clidrev
operator|!=
literal|0
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
condition|)
do|;
if|if
condition|(
name|error
operator|&&
name|retrycnt
operator|>=
literal|4
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfsrpc_setattrrpc
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|rnap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_SETATTR
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|nfsm_stateidtom
argument_list|(
name|nd
argument_list|,
name|stateidp
argument_list|,
name|NFSSTATEID_PUTSTATEID
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|vp
argument_list|,
name|NFSSATTR_FULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|rnap
argument_list|,
name|attrflagp
argument_list|,
name|NULL
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|&&
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|rnap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs lookup rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_lookup
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|lookupp
init|=
literal|0
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vnode_vtype
argument_list|(
name|dvp
argument_list|)
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|&&
name|len
operator|==
literal|1
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* 		 * Just return the current dir's fh. 		 */
name|np
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|nfhp
argument_list|,
expr|struct
name|nfsfh
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsfh
argument_list|)
operator|+
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|M_NFSFH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nfhp
operator|->
name|nfh_len
operator|=
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
operator|*
name|nfhpp
operator|=
name|nfhp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|&&
name|len
operator|==
literal|2
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|lookupp
operator|=
literal|1
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOOKUPP
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOOKUP
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
comment|/* 		 * When an NFSv4 Lookupp returns ENOENT, it means that 		 * the lookup is at the root of an fs, so return this dir. 		 */
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_NOENT
operator|&&
name|lookupp
condition|)
block|{
name|np
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|nfhp
argument_list|,
expr|struct
name|nfsfh
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsfh
argument_list|)
operator|+
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|M_NFSFH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nfhp
operator|->
name|nfh_len
operator|=
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
operator|*
name|nfhpp
operator|=
name|nfhp
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
condition|)
block|{
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
block|}
name|error
operator|=
name|nfsm_getfh
argument_list|(
name|nd
argument_list|,
name|nfhpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do a readlink rpc.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_readlink
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|,
name|cangetattr
init|=
literal|1
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_READLINK
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
comment|/* 		 * And do a Getattr op. 		 */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
block|{
name|NFSM_STRSIZ
argument_list|(
name|len
argument_list|,
name|NFS_MAXPATHLEN
argument_list|)
expr_stmt|;
comment|/* 		 * This seems weird to me, but must have been added to 		 * FreeBSD for some reason. The only thing I can think of 		 * is that there was/is some server that replies with 		 * more link data than it should? 		 */
if|if
condition|(
name|len
operator|==
name|NFS_MAXPATHLEN
condition|)
block|{
name|NFSLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_size
operator|>
literal|0
operator|&&
name|np
operator|->
name|n_size
operator|<
name|NFS_MAXPATHLEN
condition|)
block|{
name|len
operator|=
name|np
operator|->
name|n_size
expr_stmt|;
name|cangetattr
operator|=
literal|0
expr_stmt|;
block|}
name|NFSUNLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfsm_mbufuio
argument_list|(
name|nd
argument_list|,
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|&&
operator|!
name|error
operator|&&
name|cangetattr
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read operation.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_read
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|expireret
init|=
literal|0
decl_stmt|,
name|retrycnt
decl_stmt|;
name|u_int32_t
name|clidrev
init|=
literal|0
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
init|=
name|NULL
decl_stmt|;
name|nfsv4stateid_t
name|stateid
decl_stmt|;
name|void
modifier|*
name|lckp
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
name|newcred
operator|=
name|cred
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|nfhp
operator|=
name|np
operator|->
name|n_fhp
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|newcred
operator|=
name|NFSNEWCRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
block|}
name|retrycnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|lckp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|nfscl_getstateid
argument_list|(
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|NFSV4OPEN_ACCESSREAD
argument_list|,
name|newcred
argument_list|,
name|p
argument_list|,
operator|&
name|stateid
argument_list|,
operator|&
name|lckp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrpc_readrpc
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|newcred
argument_list|,
operator|&
name|stateid
argument_list|,
name|p
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lckp
operator|!=
name|NULL
condition|)
name|nfscl_lockderef
argument_list|(
name|lckp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_OLDSTATEID
condition|)
block|{
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfs_read"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|clidrev
operator|!=
literal|0
condition|)
block|{
name|expireret
operator|=
name|nfscl_hasexpired
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|clidrev
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|retrycnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
operator|(
name|error
operator|==
name|NFSERR_OLDSTATEID
operator|&&
name|retrycnt
operator|<
literal|20
operator|)
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|expireret
operator|==
literal|0
operator|&&
name|clidrev
operator|!=
literal|0
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
condition|)
do|;
if|if
condition|(
name|error
operator|&&
name|retrycnt
operator|>=
literal|4
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|&&
name|p
operator|==
name|NULL
condition|)
name|NFSFREECRED
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The actual read RPC.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_readrpc
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|retlen
decl_stmt|,
name|tsiz
decl_stmt|,
name|eof
init|=
literal|0
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|tsiz
operator|=
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
name|uiop
operator|->
name|uio_offset
operator|+
name|tsiz
operator|>
literal|0xffffffff
operator|&&
operator|!
name|NFSHASNFSV3OR4
argument_list|(
name|nmp
argument_list|)
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|tsiz
operator|>
literal|0
condition|)
block|{
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|len
operator|=
operator|(
name|tsiz
operator|>
name|nmp
operator|->
name|nm_rsize
operator|)
condition|?
name|nmp
operator|->
name|nm_rsize
else|:
name|tsiz
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_READ
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|nfsm_stateidtom
argument_list|(
name|nd
argument_list|,
name|stateidp
argument_list|,
name|NFSSTATEID_PUTSTATEID
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
operator|*
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
condition|)
block|{
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|uiop
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|txdr_hyper
argument_list|(
name|uiop
operator|->
name|uio_offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
operator|*
operator|(
name|tl
operator|+
literal|2
operator|)
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Since I can't do a Getattr for NFSv4 for Write, there 		 * doesn't seem any point in doing one here, either. 		 * (See the comment in nfsrpc_writerpc() for more info.) 		 */
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
operator|)
condition|)
block|{
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|attrflagp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|||
name|error
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|eof
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|eof
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|NFSM_STRSIZ
argument_list|(
name|retlen
argument_list|,
name|nmp
operator|->
name|nm_rsize
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsm_mbufuio
argument_list|(
name|nd
argument_list|,
name|uiop
argument_list|,
name|retlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
name|tsiz
operator|-=
name|retlen
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
operator|)
condition|)
block|{
if|if
condition|(
name|eof
operator|||
name|retlen
operator|==
literal|0
condition|)
name|tsiz
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retlen
operator|<
name|len
condition|)
name|tsiz
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|nfsmout
label|:
if|if
condition|(
name|nd
operator|->
name|nd_mrep
operator|!=
name|NULL
condition|)
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs write operation  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_write
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
modifier|*
name|iomode
parameter_list|,
name|u_char
modifier|*
name|verfp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|expireret
init|=
literal|0
decl_stmt|,
name|retrycnt
decl_stmt|,
name|nostateid
decl_stmt|;
name|u_int32_t
name|clidrev
init|=
literal|0
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
init|=
name|NULL
decl_stmt|;
name|nfsv4stateid_t
name|stateid
decl_stmt|;
name|void
modifier|*
name|lckp
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
name|newcred
operator|=
name|cred
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|newcred
operator|=
name|NFSNEWCRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|nfhp
operator|=
name|np
operator|->
name|n_fhp
expr_stmt|;
block|}
name|retrycnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|lckp
operator|=
name|NULL
expr_stmt|;
name|nostateid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|nfscl_getstateid
argument_list|(
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|NFSV4OPEN_ACCESSWRITE
argument_list|,
name|newcred
argument_list|,
name|p
argument_list|,
operator|&
name|stateid
argument_list|,
operator|&
name|lckp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stateid
operator|.
name|other
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|stateid
operator|.
name|other
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|stateid
operator|.
name|other
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|nostateid
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"stateid0 in write\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * If there is no stateid for NFSv4, it means this is an 		 * extraneous write after close. Basically a poorly 		 * implemented buffer cache. Just don't do the write. 		 */
if|if
condition|(
name|nostateid
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
name|error
operator|=
name|nfsrpc_writerpc
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|iomode
argument_list|,
name|verfp
argument_list|,
name|newcred
argument_list|,
operator|&
name|stateid
argument_list|,
name|p
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_BADSTATEID
condition|)
block|{
name|printf
argument_list|(
literal|"st=0x%x 0x%x 0x%x\n"
argument_list|,
name|stateid
operator|.
name|other
index|[
literal|0
index|]
argument_list|,
name|stateid
operator|.
name|other
index|[
literal|1
index|]
argument_list|,
name|stateid
operator|.
name|other
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|nfscl_dumpstate
argument_list|(
name|nmp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lckp
operator|!=
name|NULL
condition|)
name|nfscl_lockderef
argument_list|(
name|lckp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_OLDSTATEID
condition|)
block|{
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfs_write"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|clidrev
operator|!=
literal|0
condition|)
block|{
name|expireret
operator|=
name|nfscl_hasexpired
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|clidrev
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|retrycnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
operator|(
name|error
operator|==
name|NFSERR_OLDSTATEID
operator|&&
name|retrycnt
operator|<
literal|20
operator|)
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|expireret
operator|==
literal|0
operator|&&
name|clidrev
operator|!=
literal|0
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
condition|)
do|;
if|if
condition|(
name|error
operator|&&
name|retrycnt
operator|>=
literal|4
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|&&
name|p
operator|==
name|NULL
condition|)
name|NFSFREECRED
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The actual write RPC.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_writerpc
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
modifier|*
name|iomode
parameter_list|,
name|u_char
modifier|*
name|verfp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|tsiz
decl_stmt|,
name|rlen
decl_stmt|,
name|commit
decl_stmt|,
name|committed
init|=
name|NFSWRITE_FILESYNC
decl_stmt|;
name|int
name|wccflag
init|=
literal|0
decl_stmt|,
name|wsize
decl_stmt|;
name|int32_t
name|backup
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|uiop
operator|->
name|uio_iovcnt
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"nfs: writerpc iovcnt> 1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|tsiz
operator|=
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uiop
operator|->
name|uio_offset
operator|+
name|tsiz
operator|>
literal|0xffffffff
operator|&&
operator|!
name|NFSHASNFSV3OR4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFBIG
operator|)
return|;
block|}
name|wsize
operator|=
name|nmp
operator|->
name|nm_wsize
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
comment|/* NFSv2 sometimes does a write with */
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
comment|/* uio_resid == 0, so the while is not done */
while|while
condition|(
name|tsiz
operator|>
literal|0
condition|)
block|{
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|len
operator|=
operator|(
name|tsiz
operator|>
name|wsize
operator|)
condition|?
name|wsize
else|:
name|tsiz
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_WRITE
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|nfsm_stateidtom
argument_list|(
name|nd
argument_list|,
name|stateidp
argument_list|,
name|NFSSTATEID_PUTSTATEID
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
operator|+
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|uiop
operator|->
name|uio_offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
operator|*
name|iomode
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
operator|+
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|uiop
operator|->
name|uio_offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
operator|*
name|iomode
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|x
decl_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
comment|/* 			 * Not sure why someone changed this, since the 			 * RFC clearly states that "beginoffset" and 			 * "totalcount" are ignored, but it wouldn't 			 * surprise me if there's a busted server out there. 			 */
comment|/* Set both "begin" and "current" to non-garbage. */
name|x
operator|=
name|txdr_unsigned
argument_list|(
operator|(
name|u_int32_t
operator|)
name|uiop
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|x
expr_stmt|;
comment|/* "begin offset" */
operator|*
name|tl
operator|++
operator|=
name|x
expr_stmt|;
comment|/* "current offset" */
name|x
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|x
expr_stmt|;
comment|/* total to this offset */
operator|*
name|tl
operator|=
name|x
expr_stmt|;
comment|/* size of this write */
block|}
name|nfsm_uiombuf
argument_list|(
name|nd
argument_list|,
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 		 * Although it is tempting to do a normal Getattr Op in the 		 * NFSv4 compound, the result can be a nearly hung client 		 * system if the Getattr asks for Owner and/or OwnerGroup. 		 * It occurs when the client can't map either the Owner or 		 * Owner_group name in the Getattr reply to a uid/gid. When 		 * there is a cache miss, the kernel does an upcall to the 		 * nfsuserd. Then, it can try and read the local /etc/passwd 		 * or /etc/group file. It can then block in getnewbuf(), 		 * waiting for dirty writes to be pushed to the NFS server. 		 * The only reason this doesn't result in a complete 		 * deadlock, is that the upcall times out and allows 		 * the write to complete. However, progress is so slow 		 * that it might just as well be deadlocked. 		 * So, we just get the attributes that change with each 		 * write Op. 		 * nb: nfscl_loadattrcache() needs to be told that these 		 *     partial attributes from a write rpc are being 		 *     passed in, via a argument flag. 		 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSWRITEGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
comment|/* 			 * In case the rpc gets retried, roll 			 * the uio fileds changed by nfsm_uiombuf() 			 * back. 			 */
name|uiop
operator|->
name|uio_offset
operator|-=
name|len
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
operator|-
name|len
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
operator|&
name|wccflag
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
operator|+
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|NFSERR_IO
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
elseif|else
if|if
condition|(
name|rlen
operator|<
name|len
condition|)
block|{
name|backup
operator|=
name|len
operator|-
name|rlen
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|backup
operator|)
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|-=
name|backup
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|len
operator|=
name|rlen
expr_stmt|;
block|}
name|commit
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
comment|/* 				 * Return the lowest committment level 				 * obtained by any of the RPCs. 				 */
if|if
condition|(
name|committed
operator|==
name|NFSWRITE_FILESYNC
condition|)
name|committed
operator|=
name|commit
expr_stmt|;
elseif|else
if|if
condition|(
name|committed
operator|==
name|NFSWRITE_DATASYNC
operator|&&
name|commit
operator|==
name|NFSWRITE_UNSTABLE
condition|)
name|committed
operator|=
name|commit
expr_stmt|;
if|if
condition|(
name|verfp
operator|!=
name|NULL
condition|)
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
name|tl
argument_list|,
name|verfp
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSHASWRITEVERF
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
name|tl
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_verf
index|[
literal|0
index|]
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|NFSSETWRITEVERF
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV2
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|attrflagp
operator|=
name|NFS_LATTR_NOSHRINK
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|NFSWRITERPC_SETTIME
argument_list|(
name|wccflag
argument_list|,
name|np
argument_list|,
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
name|tsiz
operator|-=
name|len
expr_stmt|;
block|}
name|nfsmout
label|:
if|if
condition|(
name|nd
operator|->
name|nd_mrep
operator|!=
name|NULL
condition|)
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
operator|*
name|iomode
operator|=
name|committed
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs mknod rpc  * For NFS v2 this is a kludge. Use a create rpc but with the IFMT bits of the  * mode set to specify the file type and the size field for rdev.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_mknod
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|u_int32_t
name|rdev
parameter_list|,
name|enum
name|vtype
name|vtyp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nnap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
operator|*
name|nfhpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_MKNOD
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|vtonfsv34_type
argument_list|(
name|vtyp
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSMAJOR
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSMINOR
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|vtonfsv34_type
argument_list|(
name|vtyp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|&&
operator|(
name|vtyp
operator|==
name|VCHR
operator|||
name|vtyp
operator|==
name|VBLK
operator|)
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSMAJOR
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSMINOR
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
condition|)
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
name|NFSSATTR_SIZERDEV
argument_list|,
name|rdev
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
name|error
operator|=
name|nfscl_mtofh
argument_list|(
name|nd
argument_list|,
name|nfhpp
argument_list|,
name|nnap
argument_list|,
name|attrflagp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs file create call  * Mostly just call the approriate routine. (I separated out v4, so that  * error recovery wouldn't be as difficult.)  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_create
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|nfsquad_t
name|cverf
parameter_list|,
name|int
name|fmode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nnap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|,
name|newone
decl_stmt|,
name|expireret
init|=
literal|0
decl_stmt|,
name|retrycnt
decl_stmt|,
name|unlocked
decl_stmt|;
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|)
decl_stmt|;
name|u_int32_t
name|clidrev
decl_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|retrycnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|dp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|nfscl_open
argument_list|(
name|dvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|NFSV4OPEN_ACCESSWRITE
operator||
name|NFSV4OPEN_ACCESSREAD
operator|)
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|owp
argument_list|,
name|NULL
argument_list|,
operator|&
name|newone
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
else|else
name|clidrev
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|nfsrpc_createv4
argument_list|(
name|dvp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|vap
argument_list|,
name|cverf
argument_list|,
name|fmode
argument_list|,
name|owp
argument_list|,
operator|&
name|dp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|dnap
argument_list|,
name|nnap
argument_list|,
name|nfhpp
argument_list|,
name|attrflagp
argument_list|,
name|dattrflagp
argument_list|,
name|dstuff
argument_list|,
operator|&
name|unlocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|nfscl_deleg
argument_list|(
name|nmp
operator|->
name|nm_mountp
argument_list|,
name|owp
operator|->
name|nfsow_clp
argument_list|,
operator|(
operator|*
name|nfhpp
operator|)
operator|->
name|nfh_fh
argument_list|,
operator|(
operator|*
name|nfhpp
operator|)
operator|->
name|nfh_len
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|dp
argument_list|)
expr_stmt|;
name|nfscl_ownerrelease
argument_list|(
name|owp
argument_list|,
name|error
argument_list|,
name|newone
argument_list|,
name|unlocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
condition|)
block|{
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfs_open"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|clidrev
operator|!=
literal|0
condition|)
block|{
name|expireret
operator|=
name|nfscl_hasexpired
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|clidrev
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|retrycnt
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|expireret
operator|==
literal|0
operator|&&
name|clidrev
operator|!=
literal|0
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
condition|)
do|;
if|if
condition|(
name|error
operator|&&
name|retrycnt
operator|>=
literal|4
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfsrpc_createv23
argument_list|(
name|dvp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|vap
argument_list|,
name|cverf
argument_list|,
name|fmode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|dnap
argument_list|,
name|nnap
argument_list|,
name|nfhpp
argument_list|,
name|attrflagp
argument_list|,
name|dattrflagp
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The create rpc for v2 and 3.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_createv23
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|nfsquad_t
name|cverf
parameter_list|,
name|int
name|fmode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nnap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
operator|*
name|nfhpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_CREATE
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmode
operator|&
name|O_EXCL
condition|)
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSCREATE_EXCLUSIVE
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cverf
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|cverf
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSCREATE_UNCHECKED
argument_list|)
expr_stmt|;
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
name|NFSSATTR_SIZE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|nfscl_mtofh
argument_list|(
name|nd
argument_list|,
name|nfhpp
argument_list|,
name|nnap
argument_list|,
name|attrflagp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfsrpc_createv4
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|nfsquad_t
name|cverf
parameter_list|,
name|int
name|fmode
parameter_list|,
name|struct
name|nfsclowner
modifier|*
name|owp
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
modifier|*
name|dpp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nnap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|,
name|int
modifier|*
name|unlockedp
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|deleg
decl_stmt|,
name|newone
decl_stmt|,
name|ret
decl_stmt|,
name|acesize
decl_stmt|,
name|limitby
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|nfsv4stateid_t
name|stateid
decl_stmt|;
name|u_int32_t
name|rflags
decl_stmt|;
operator|*
name|unlockedp
operator|=
literal|0
expr_stmt|;
operator|*
name|nfhpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_CREATE
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
comment|/* 	 * For V4, this is actually an Open op. 	 */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|owp
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_ACCESSWRITE
operator||
name|NFSV4OPEN_ACCESSREAD
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_DENYNONE
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|owp
operator|->
name|nfsow_clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|owp
operator|->
name|nfsow_clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|owp
operator|->
name|nfsow_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmode
operator|&
name|O_EXCL
condition|)
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSCREATE_EXCLUSIVE
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cverf
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|cverf
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSCREATE_UNCHECKED
argument_list|)
expr_stmt|;
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_CLAIMNULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|NFSCL_INCRSEQID
argument_list|(
name|owp
operator|->
name|nfsow_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
literal|6
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
expr_stmt|;
name|rflags
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|6
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|deleg
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleg
operator|==
name|NFSV4OPEN_DELEGATEREAD
operator|||
name|deleg
operator|==
name|NFSV4OPEN_DELEGATEWRITE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|owp
operator|->
name|nfsow_clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_FIRSTDELEG
operator|)
condition|)
name|owp
operator|->
name|nfsow_clp
operator|->
name|nfsc_flags
operator||=
operator|(
name|NFSCLFLAGS_FIRSTDELEG
operator||
name|NFSCLFLAGS_GOTDELEG
operator|)
expr_stmt|;
name|MALLOC
argument_list|(
name|dp
argument_list|,
expr|struct
name|nfscldeleg
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfscldeleg
argument_list|)
operator|+
name|NFSX_V4FHMAX
argument_list|,
name|M_NFSCLDELEG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_owner
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_lock
argument_list|)
expr_stmt|;
name|dp
operator|->
name|nfsdl_clp
operator|=
name|owp
operator|->
name|nfsow_clp
expr_stmt|;
name|newnfs_copyincred
argument_list|(
name|cred
argument_list|,
operator|&
name|dp
operator|->
name|nfsdl_cred
argument_list|)
expr_stmt|;
name|nfscl_lockinit
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_rwlock
argument_list|)
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ret
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleg
operator|==
name|NFSV4OPEN_DELEGATEWRITE
condition|)
block|{
name|dp
operator|->
name|nfsdl_flags
operator|=
name|NFSCLDL_WRITE
expr_stmt|;
comment|/* 				 * Indicates how much the file can grow. 				 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|limitby
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|limitby
condition|)
block|{
case|case
name|NFSV4OPEN_LIMITSIZE
case|:
name|dp
operator|->
name|nfsdl_sizelimit
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFSV4OPEN_LIMITBLOCKS
case|:
name|dp
operator|->
name|nfsdl_sizelimit
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int64_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|dp
operator|->
name|nfsdl_sizelimit
operator|*=
name|fxdr_unsigned
argument_list|(
name|u_int64_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
empty_stmt|;
block|}
else|else
block|{
name|dp
operator|->
name|nfsdl_flags
operator|=
name|NFSCLDL_READ
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
name|dp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_RECALL
expr_stmt|;
name|error
operator|=
name|nfsrv_dissectace
argument_list|(
name|nd
argument_list|,
operator|&
name|dp
operator|->
name|nfsdl_ace
argument_list|,
operator|&
name|ret
argument_list|,
operator|&
name|acesize
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
elseif|else
if|if
condition|(
name|deleg
operator|!=
name|NFSV4OPEN_DELEGATENONE
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|error
operator|=
name|nfscl_mtofh
argument_list|(
name|nd
argument_list|,
name|nfhpp
argument_list|,
name|nnap
argument_list|,
name|attrflagp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|&&
operator|*
name|attrflagp
condition|)
block|{
name|dp
operator|->
name|nfsdl_change
operator|=
name|nnap
operator|->
name|na_filerev
expr_stmt|;
name|dp
operator|->
name|nfsdl_modtime
operator|=
name|nnap
operator|->
name|na_mtime
expr_stmt|;
name|dp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_MODTIMESET
expr_stmt|;
block|}
comment|/* 		 * We can now complete the Open state. 		 */
name|nfhp
operator|=
operator|*
name|nfhpp
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|dp
operator|->
name|nfsdl_fhlen
operator|=
name|nfhp
operator|->
name|nfh_len
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|dp
operator|->
name|nfsdl_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Get an Open structure that will be 		 * attached to the OpenOwner, acquired already. 		 */
name|error
operator|=
name|nfscl_open
argument_list|(
name|dvp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
operator|(
name|NFSV4OPEN_ACCESSWRITE
operator||
name|NFSV4OPEN_ACCESSREAD
operator|)
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
operator|&
name|op
argument_list|,
operator|&
name|newone
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|op
operator|->
name|nfso_stateid
operator|=
name|stateid
expr_stmt|;
name|newnfs_copyincred
argument_list|(
name|cred
argument_list|,
operator|&
name|op
operator|->
name|nfso_cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rflags
operator|&
name|NFSV4OPEN_RESULTCONFIRM
operator|)
condition|)
block|{
do|do
block|{
name|ret
operator|=
name|nfsrpc_openconfirm
argument_list|(
name|dvp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|op
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfs_create"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
do|;
name|error
operator|=
name|ret
expr_stmt|;
block|}
comment|/* 		 * If the server is handing out delegations, but we didn't 		 * get one because an OpenConfirm was required, try the 		 * Open again, to get a delegation. This is a harmless no-op, 		 * from a server's point of view. 		 */
if|if
condition|(
operator|(
name|rflags
operator|&
name|NFSV4OPEN_RESULTCONFIRM
operator|)
operator|&&
operator|(
name|owp
operator|->
name|nfsow_clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_GOTDELEG
operator|)
operator|&&
operator|!
name|error
operator|&&
name|dp
operator|==
name|NULL
condition|)
block|{
name|np
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
do|do
block|{
name|ret
operator|=
name|nfsrpc_openrpc
argument_list|(
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|)
argument_list|,
name|dvp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
operator|(
name|NFSV4OPEN_ACCESSWRITE
operator||
name|NFSV4OPEN_ACCESSREAD
operator|)
argument_list|,
name|op
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
operator|&
name|dp
argument_list|,
literal|0
argument_list|,
literal|0x0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfs_crt2"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
do|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|ret
operator|==
name|NFSERR_STALEDONTRECOVER
condition|)
name|error
operator|=
name|ret
expr_stmt|;
block|}
block|}
name|nfscl_openrelease
argument_list|(
name|op
argument_list|,
name|error
argument_list|,
name|newone
argument_list|)
expr_stmt|;
operator|*
name|unlockedp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALECLIENTID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|owp
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|dpp
operator|=
name|dp
expr_stmt|;
elseif|else
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Nfs remove rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_remove
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|nfsv4stateid_t
name|dstateid
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|)
expr_stmt|;
name|tryagain
label|:
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|nfscl_removedeleg
argument_list|(
name|vp
argument_list|,
name|p
argument_list|,
operator|&
name|dstateid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RETDELEGREMOVE
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dstateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dstateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dstateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dstateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_PUTFH
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_REMOVE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_REMOVE
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
comment|/* For NFSv4, parse out any Delereturn replies. */
if|if
condition|(
name|ret
operator|>
literal|0
operator|&&
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NOMOREDATA
operator|)
condition|)
block|{
comment|/* 			 * If the Delegreturn failed, try again without 			 * it. The server will Recall, as required. 			 */
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|ret
operator|*
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
block|}
block|}
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do an nfs rename rpc.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_rename
parameter_list|(
name|vnode_t
name|fdvp
parameter_list|,
name|vnode_t
name|fvp
parameter_list|,
name|char
modifier|*
name|fnameptr
parameter_list|,
name|int
name|fnamelen
parameter_list|,
name|vnode_t
name|tdvp
parameter_list|,
name|vnode_t
name|tvp
parameter_list|,
name|char
modifier|*
name|tnameptr
parameter_list|,
name|int
name|tnamelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|fnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|tnap
parameter_list|,
name|int
modifier|*
name|fattrflagp
parameter_list|,
name|int
modifier|*
name|tattrflagp
parameter_list|,
name|void
modifier|*
name|fstuff
parameter_list|,
name|void
modifier|*
name|tstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|nfsv4stateid_t
name|fdstateid
decl_stmt|,
name|tdstateid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|gottd
init|=
literal|0
decl_stmt|,
name|gotfd
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
operator|*
name|fattrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|tattrflagp
operator|=
literal|0
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|fdvp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnamelen
operator|>
name|NFS_MAXNAMLEN
operator|||
name|tnamelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|tryagain
label|:
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|nfscl_renamedeleg
argument_list|(
name|fvp
argument_list|,
operator|&
name|fdstateid
argument_list|,
operator|&
name|gotfd
argument_list|,
name|tvp
argument_list|,
operator|&
name|tdstateid
argument_list|,
operator|&
name|gottd
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotfd
operator|&&
name|gottd
condition|)
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RETDELEGRENAME2
argument_list|,
name|fvp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gotfd
condition|)
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RETDELEGRENAME1
argument_list|,
name|fvp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gottd
condition|)
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RETDELEGRENAME1
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gotfd
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|fdstateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|fdstateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|fdstateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|fdstateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|gottd
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_PUTFH
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_DELEGRETURN
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gottd
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tdstateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tdstateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tdstateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|tdstateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_PUTFH
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_SAVEFH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RENAME
argument_list|,
name|fdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSWCCATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_PUTFH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_V4WCCATTR
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_RENAME
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|fnameptr
argument_list|,
name|fnamelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
condition|)
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|tnameptr
argument_list|,
name|tnamelen
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|fdvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|fstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
comment|/* For NFSv4, parse out any Delereturn replies. */
if|if
condition|(
name|ret
operator|>
literal|0
operator|&&
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NOMOREDATA
operator|)
condition|)
block|{
comment|/* 			 * If the Delegreturn failed, try again without 			 * it. The server will Recall, as required. 			 */
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|ret
operator|*
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|ret
operator|>
literal|1
condition|)
block|{
comment|/* 				     * If the Delegreturn failed, try again 				     * without it. The server will Recall, as 				     * required. 				     * If ret> 1, the first iteration of this 				     * loop is the second DelegReturn result. 				     */
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
else|else
block|{
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Now, the first wcc attribute reply. */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|fdvp
argument_list|,
name|fnap
argument_list|,
name|fattrflagp
argument_list|,
name|NULL
argument_list|,
name|fstuff
argument_list|)
expr_stmt|;
comment|/* and the second wcc attribute reply. */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
operator|&&
operator|!
name|error
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|tdvp
argument_list|,
name|tnap
argument_list|,
name|tattrflagp
argument_list|,
name|NULL
argument_list|,
name|tstuff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs hard link create rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_link
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LINK
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_PUTFH
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSWCCATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_V4WCCATTR
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_LINK
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
condition|)
block|{
comment|/* 		 * First, parse out the PutFH and Getattr result. 		 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
operator|)
condition|)
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
comment|/* 		 * Get the pre-op attributes. 		 */
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs symbolic link create rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_symlink
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nnap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|int
name|slen
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
operator|*
name|nfhpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|)
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|>
name|NFS_MAXPATHLEN
operator|||
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_SYMLINK
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFLNK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|target
argument_list|,
name|slen
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
condition|)
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|target
argument_list|,
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
condition|)
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
name|NFSSATTR_SIZENEG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|&&
operator|!
name|error
condition|)
block|{
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nfscl_mtofh
argument_list|(
name|nd
argument_list|,
name|nfhpp
argument_list|,
name|nnap
argument_list|,
name|attrflagp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
comment|/* 	 * Kludge: Map EEXIST => 0 assuming that it is a reply to a retry. 	 */
if|if
condition|(
name|error
operator|==
name|EEXIST
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs make dir rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_mkdir
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nnap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
operator|*
name|nfhpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_MKDIR
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFDIR
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
name|NFSSATTR_SIZENEG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_mtofh
argument_list|(
name|nd
argument_list|,
name|nfhpp
argument_list|,
name|nnap
argument_list|,
name|attrflagp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
comment|/* 	 * Kludge: Map EEXIST => 0 assuming that you have a reply to a retry. 	 */
if|if
condition|(
name|error
operator|==
name|EEXIST
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs remove directory call  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_rmdir
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RMDIR
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
comment|/* 	 * Kludge: Map ENOENT => 0 assuming that you have a reply to a retry. 	 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Readdir rpc.  * Always returns with either uio_resid unchanged, if you are at the  * end of the directory, or uio_resid == 0, with all DIRBLKSIZ chunks  * filled in.  * I felt this would allow caching of directory blocks more easily  * than returning a pertially filled block.  * Directory offset cookies:  * Oh my, what to do with them...  * I can think of three ways to deal with them:  * 1 - have the layer above these RPCs maintain a map between logical  *     directory byte offsets and the NFS directory offset cookies  * 2 - pass the opaque directory offset cookies up into userland  *     and let the libc functions deal with them, via the system call  * 3 - return them to userland in the "struct dirent", so future versions  *     of libc can use them and do whatever is necessary to amke things work  *     above these rpc calls, in the meantime  * For now, I do #3 by "hiding" the directory offset cookies after the  * d_name field in struct dirent. This is space inside d_reclen that  * will be ignored by anything that doesn't know about them.  * The directory offset cookies are filled in as the last 8 bytes of  * each directory entry, after d_name. Someday, the userland libc  * functions may be able to use these. In the meantime, it satisfies  * OpenBSD's requirements for cookies being returned.  * If expects the directory offset cookie for the read to be in uio_offset  * and returns the one for the next entry after this directory block in  * there, as well.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_readdir
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|nfsuint64
modifier|*
name|cookiep
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|left
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|nfsquad_t
name|cookie
decl_stmt|,
name|ncookie
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|dnp
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|tlen
decl_stmt|,
name|more_dirs
init|=
literal|1
decl_stmt|,
name|blksiz
init|=
literal|0
decl_stmt|,
name|bigenough
init|=
literal|1
decl_stmt|;
name|int
name|reqsize
decl_stmt|,
name|tryformoredirs
init|=
literal|1
decl_stmt|,
name|readsize
decl_stmt|,
name|eof
init|=
literal|0
decl_stmt|,
name|gotmnton
init|=
literal|0
decl_stmt|;
name|long
name|dotfileid
decl_stmt|,
name|dotdotfileid
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|fakefileno
init|=
literal|0xffffffff
decl_stmt|,
name|rderr
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|,
name|dattrbits
decl_stmt|;
name|u_int32_t
modifier|*
name|tl2
init|=
name|NULL
decl_stmt|;
name|size_t
name|tresid
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|uiop
operator|->
name|uio_iovcnt
operator|!=
literal|1
operator|||
operator|(
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"nfs readdirrpc bad uio"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * There is no point in reading a lot more than uio_resid, however 	 * adding one additional DIRBLKSIZ makes sense. Since uio_resid 	 * and nm_readdirsize are both exact multiples of DIRBLKSIZ, this 	 * will never make readsize> nm_readdirsize. 	 */
name|readsize
operator|=
name|nmp
operator|->
name|nm_readdirsize
expr_stmt|;
if|if
condition|(
name|readsize
operator|>
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
condition|)
name|readsize
operator|=
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
operator|+
name|DIRBLKSIZ
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|0
expr_stmt|;
name|tresid
operator|=
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|0
index|]
expr_stmt|;
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|1
index|]
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * For NFSv4, first create the "." and ".." entries. 	 */
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|reqsize
operator|=
literal|6
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|dattrbits
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_FILEID
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
operator|&
name|dnp
operator|->
name|n_vattr
operator|.
name|na_suppattr
argument_list|,
name|NFSATTRBIT_MOUNTEDONFILEID
argument_list|)
condition|)
block|{
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_MOUNTEDONFILEID
argument_list|)
expr_stmt|;
name|gotmnton
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Must fake it. Use the fileno, except when the 			 * fsid is != to that of the directory. For that 			 * case, generate a fake fileno that is not the same. 			 */
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_FSID
argument_list|)
expr_stmt|;
name|gotmnton
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Joy, oh joy. For V4 we get to hand craft '.' and '..'. 		 */
if|if
condition|(
name|uiop
operator|->
name|uio_offset
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|800000
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|nfsva
operator|.
name|na_vattr
argument_list|,
name|cred
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|nfsva
operator|.
name|na_vattr
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dotfileid
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOOKUPP
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<=
name|NFSX_V4FHMAX
condition|)
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EPERM
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfsva
operator|.
name|na_mntonfileno
operator|=
literal|0xffffffff
expr_stmt|;
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dotdotfileid
operator|=
name|dotfileid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gotmnton
condition|)
block|{
if|if
condition|(
name|nfsva
operator|.
name|na_mntonfileno
operator|!=
literal|0xffffffff
condition|)
name|dotdotfileid
operator|=
name|nfsva
operator|.
name|na_mntonfileno
expr_stmt|;
else|else
name|dotdotfileid
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfsva
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|&&
name|nfsva
operator|.
name|na_filesid
index|[
literal|1
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|1
index|]
condition|)
block|{
name|dotdotfileid
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|fakefileno
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|fakefileno
operator|==
name|nfsva
operator|.
name|na_fileid
condition|)
do|;
name|dotdotfileid
operator|=
name|fakefileno
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_NOENT
condition|)
block|{
comment|/* 			     * Lookupp returns NFSERR_NOENT when we are 			     * at the root, so just use the current dir. 			     */
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
name|dotdotfileid
operator|=
name|dotfileid
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
block|}
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|CAST_DOWN
argument_list|(
name|caddr_t
argument_list|,
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
name|dotfileid
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
literal|1
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRENT_SIZE
argument_list|(
name|dp
argument_list|)
operator|+
name|NFSX_HYPER
expr_stmt|;
comment|/* 			 * Just make these offset cookie 0. 			 */
name|tl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|d_name
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|dp
operator|->
name|d_reclen
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|CAST_DOWN
argument_list|(
name|caddr_t
argument_list|,
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
name|dotdotfileid
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
literal|2
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRENT_SIZE
argument_list|(
name|dp
argument_list|)
operator|+
name|NFSX_HYPER
expr_stmt|;
comment|/* 			 * Just make these offset cookie 0. 			 */
name|tl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|d_name
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|dp
operator|->
name|d_reclen
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
block|}
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_RDATTRERROR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reqsize
operator|=
literal|5
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
block|}
comment|/* 	 * Loop around doing readdir rpc's of size readsize. 	 * The stopping criteria is EOF or buffer full. 	 */
while|while
condition|(
name|more_dirs
operator|&&
name|bigenough
condition|)
block|{
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_READDIR
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|readsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|reqsize
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|qval
operator|==
literal|0
condition|)
block|{
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|NFSLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|1
index|]
expr_stmt|;
name|NFSUNLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|readsize
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|readsize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|dattrbits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|readsize
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
operator|)
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|NFSLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|1
index|]
operator|=
operator|*
name|tl
expr_stmt|;
name|NFSUNLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|||
name|error
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|more_dirs
condition|)
name|tryformoredirs
operator|=
literal|0
expr_stmt|;
comment|/* loop thru the dir entries, doctoring them to 4bsd form */
while|while
condition|(
name|more_dirs
operator|&&
name|bigenough
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfsva
operator|.
name|na_fileid
operator|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
operator|*
operator|++
name|tl
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|++
name|tl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfsva
operator|.
name|na_fileid
operator|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|tlen
operator|=
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|==
name|len
condition|)
name|tlen
operator|+=
literal|4
expr_stmt|;
comment|/* To ensure null termination */
name|left
operator|=
name|DIRBLKSIZ
operator|-
name|blksiz
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|tlen
operator|+
name|DIRHDSIZ
operator|+
name|NFSX_HYPER
argument_list|)
operator|>
name|left
condition|)
block|{
name|dp
operator|->
name|d_reclen
operator|+=
name|left
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|left
expr_stmt|;
name|blksiz
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|tlen
operator|+
name|DIRHDSIZ
operator|+
name|NFSX_HYPER
argument_list|)
operator|>
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
condition|)
name|bigenough
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bigenough
condition|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|CAST_DOWN
argument_list|(
name|caddr_t
argument_list|,
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
name|len
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|tlen
operator|+
name|DIRHDSIZ
operator|+
name|NFSX_HYPER
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|blksiz
operator|==
name|DIRBLKSIZ
condition|)
name|blksiz
operator|=
literal|0
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRHDSIZ
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|DIRHDSIZ
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|DIRHDSIZ
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRHDSIZ
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsm_mbufuio
argument_list|(
name|nd
argument_list|,
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|cp
operator|=
name|CAST_DOWN
argument_list|(
name|caddr_t
argument_list|,
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
argument_list|)
expr_stmt|;
name|tlen
operator|-=
name|len
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate */
name|cp
operator|+=
name|tlen
expr_stmt|;
comment|/* points to cookie storage */
name|tl2
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|cp
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|rderr
operator|=
literal|0
expr_stmt|;
name|nfsva
operator|.
name|na_mntonfileno
operator|=
literal|0xffffffff
expr_stmt|;
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rderr
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
block|}
else|else
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bigenough
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
if|if
condition|(
name|rderr
condition|)
block|{
name|dp
operator|->
name|d_fileno
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gotmnton
condition|)
block|{
if|if
condition|(
name|nfsva
operator|.
name|na_mntonfileno
operator|!=
literal|0xffffffff
condition|)
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_mntonfileno
expr_stmt|;
else|else
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfsva
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|&&
name|nfsva
operator|.
name|na_filesid
index|[
literal|1
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|1
index|]
condition|)
block|{
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|fakefileno
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|fakefileno
operator|==
name|nfsva
operator|.
name|na_fileid
condition|)
do|;
name|dp
operator|->
name|d_fileno
operator|=
name|fakefileno
expr_stmt|;
block|}
name|dp
operator|->
name|d_type
operator|=
name|vtonfs_dtype
argument_list|(
name|nfsva
operator|.
name|na_type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
operator|*
name|tl2
operator|++
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|0
index|]
operator|=
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl2
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|1
index|]
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
block|}
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If at end of rpc data, get the eof boolean 		 */
if|if
condition|(
operator|!
name|more_dirs
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|eof
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tryformoredirs
condition|)
name|more_dirs
operator|=
operator|!
name|eof
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
block|}
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Fill last record, iff any, out to a multiple of DIRBLKSIZ 	 * by increasing d_reclen for the last record. 	 */
if|if
condition|(
name|blksiz
operator|>
literal|0
condition|)
block|{
name|left
operator|=
name|DIRBLKSIZ
operator|-
name|blksiz
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|+=
name|left
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|left
expr_stmt|;
block|}
comment|/* 	 * If returning no data, assume end of file. 	 * If not bigenough, return not end of file, since you aren't 	 *    returning all the data 	 * Otherwise, return the eof flag from the server. 	 */
if|if
condition|(
name|eofp
condition|)
block|{
if|if
condition|(
name|tresid
operator|==
operator|(
call|(
name|size_t
call|)
argument_list|(
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
argument_list|)
operator|)
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|bigenough
condition|)
operator|*
name|eofp
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|eofp
operator|=
name|eof
expr_stmt|;
block|}
comment|/* 	 * Add extra empty records to any remaining DIRBLKSIZ chunks. 	 */
while|while
condition|(
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
operator|>
literal|0
operator|&&
operator|(
call|(
name|size_t
call|)
argument_list|(
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
argument_list|)
operator|)
operator|!=
name|tresid
condition|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|CAST_DOWN
argument_list|(
name|caddr_t
argument_list|,
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|d_name
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRBLKSIZ
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|DIRBLKSIZ
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRBLKSIZ
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRBLKSIZ
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|DIRBLKSIZ
expr_stmt|;
block|}
name|nfsmout
label|:
if|if
condition|(
name|nd
operator|->
name|nd_mrep
operator|!=
name|NULL
condition|)
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|APPLE
end_ifndef

begin_comment
comment|/*  * NFS V3 readdir plus RPC. Used in place of nfsrpc_readdir().  * (Also used for NFS V4 when mount flag set.)  * (ditto above w.r.t. multiple of DIRBLKSIZ, etc.)  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_readdirplus
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|nfsuint64
modifier|*
name|cookiep
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|left
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|vnode_t
name|newvp
init|=
name|NULLVP
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nameidata
name|nami
decl_stmt|,
modifier|*
name|ndp
init|=
operator|&
name|nami
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
operator|&
name|ndp
operator|->
name|ni_cnd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|dnp
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|nfsquad_t
name|cookie
decl_stmt|,
name|ncookie
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|tlen
decl_stmt|,
name|more_dirs
init|=
literal|1
decl_stmt|,
name|blksiz
init|=
literal|0
decl_stmt|,
name|bigenough
init|=
literal|1
decl_stmt|;
name|int
name|attrflag
decl_stmt|,
name|tryformoredirs
init|=
literal|1
decl_stmt|,
name|eof
init|=
literal|0
decl_stmt|,
name|gotmnton
init|=
literal|0
decl_stmt|;
name|int
name|unlocknewvp
init|=
literal|0
decl_stmt|;
name|long
name|dotfileid
decl_stmt|,
name|dotdotfileid
init|=
literal|0
decl_stmt|,
name|fileno
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|,
name|dattrbits
decl_stmt|;
name|size_t
name|tresid
decl_stmt|;
name|u_int32_t
modifier|*
name|tl2
init|=
name|NULL
decl_stmt|,
name|fakefileno
init|=
literal|0xffffffff
decl_stmt|,
name|rderr
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|uiop
operator|->
name|uio_iovcnt
operator|!=
literal|1
operator|||
operator|(
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"nfs readdirplusrpc bad uio"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eofp
operator|!=
name|NULL
condition|)
operator|*
name|eofp
operator|=
literal|0
expr_stmt|;
name|ndp
operator|->
name|ni_dvp
operator|=
name|vp
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|0
index|]
expr_stmt|;
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|1
index|]
expr_stmt|;
name|tresid
operator|=
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
comment|/* 	 * For NFSv4, first create the "." and ".." entries. 	 */
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|dattrbits
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_FILEID
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
operator|&
name|dnp
operator|->
name|n_vattr
operator|.
name|na_suppattr
argument_list|,
name|NFSATTRBIT_MOUNTEDONFILEID
argument_list|)
condition|)
block|{
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_MOUNTEDONFILEID
argument_list|)
expr_stmt|;
name|gotmnton
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Must fake it. Use the fileno, except when the 			 * fsid is != to that of the directory. For that 			 * case, generate a fake fileno that is not the same. 			 */
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_FSID
argument_list|)
expr_stmt|;
name|gotmnton
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Joy, oh joy. For V4 we get to hand craft '.' and '..'. 		 */
if|if
condition|(
name|uiop
operator|->
name|uio_offset
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|800000
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|nfsva
operator|.
name|na_vattr
argument_list|,
name|cred
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|nfsva
operator|.
name|na_vattr
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dotfileid
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOOKUPP
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<=
name|NFSX_V4FHMAX
condition|)
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EPERM
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfsva
operator|.
name|na_mntonfileno
operator|=
literal|0xffffffff
expr_stmt|;
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dotdotfileid
operator|=
name|dotfileid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gotmnton
condition|)
block|{
if|if
condition|(
name|nfsva
operator|.
name|na_mntonfileno
operator|!=
literal|0xffffffff
condition|)
name|dotdotfileid
operator|=
name|nfsva
operator|.
name|na_mntonfileno
expr_stmt|;
else|else
name|dotdotfileid
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfsva
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|&&
name|nfsva
operator|.
name|na_filesid
index|[
literal|1
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|1
index|]
condition|)
block|{
name|dotdotfileid
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|fakefileno
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|fakefileno
operator|==
name|nfsva
operator|.
name|na_fileid
condition|)
do|;
name|dotdotfileid
operator|=
name|fakefileno
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_NOENT
condition|)
block|{
comment|/* 			     * Lookupp returns NFSERR_NOENT when we are 			     * at the root, so just use the current dir. 			     */
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
name|dotdotfileid
operator|=
name|dotfileid
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
block|}
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
name|dotfileid
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
literal|1
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRENT_SIZE
argument_list|(
name|dp
argument_list|)
operator|+
name|NFSX_HYPER
expr_stmt|;
comment|/* 			 * Just make these offset cookie 0. 			 */
name|tl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|d_name
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|dp
operator|->
name|d_reclen
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
name|dotdotfileid
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
literal|2
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRENT_SIZE
argument_list|(
name|dp
argument_list|)
operator|+
name|NFSX_HYPER
expr_stmt|;
comment|/* 			 * Just make these offset cookie 0. 			 */
name|tl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|d_name
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|dp
operator|->
name|d_reclen
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
block|}
name|NFSREADDIRPLUS_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotmnton
condition|)
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_MOUNTEDONFILEID
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Loop around doing readdir rpc's of size nm_readdirsize. 	 * The stopping criteria is EOF or buffer full. 	 */
while|while
condition|(
name|more_dirs
operator|&&
name|bigenough
condition|)
block|{
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_READDIRPLUS
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|6
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|qval
operator|==
literal|0
condition|)
block|{
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|NFSLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|1
index|]
expr_stmt|;
name|NFSUNLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|dattrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|||
name|error
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|NFSLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|NFSUNLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|more_dirs
condition|)
name|tryformoredirs
operator|=
literal|0
expr_stmt|;
comment|/* loop thru the dir entries, doctoring them to 4bsd form */
while|while
condition|(
name|more_dirs
operator|&&
name|bigenough
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fileno
operator|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
operator|*
operator|++
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|++
expr_stmt|;
block|}
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|tlen
operator|=
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|==
name|len
condition|)
name|tlen
operator|+=
literal|4
expr_stmt|;
comment|/* To ensure null termination */
name|left
operator|=
name|DIRBLKSIZ
operator|-
name|blksiz
expr_stmt|;
if|if
condition|(
operator|(
name|tlen
operator|+
name|DIRHDSIZ
operator|+
name|NFSX_HYPER
operator|)
operator|>
name|left
condition|)
block|{
name|dp
operator|->
name|d_reclen
operator|+=
name|left
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|left
expr_stmt|;
name|blksiz
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tlen
operator|+
name|DIRHDSIZ
operator|+
name|NFSX_HYPER
operator|)
operator|>
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
condition|)
name|bigenough
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bigenough
condition|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
name|len
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|tlen
operator|+
name|DIRHDSIZ
operator|+
name|NFSX_HYPER
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|blksiz
operator|==
name|DIRBLKSIZ
condition|)
name|blksiz
operator|=
literal|0
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRHDSIZ
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|DIRHDSIZ
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|DIRHDSIZ
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRHDSIZ
operator|)
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_nameptr
operator|=
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_namelen
operator|=
name|len
expr_stmt|;
name|NFSCNHASHZERO
argument_list|(
name|cnp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsm_mbufuio
argument_list|(
name|nd
argument_list|,
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|cp
operator|=
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|tlen
operator|-=
name|len
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|+=
name|tlen
expr_stmt|;
comment|/* points to cookie storage */
name|tl2
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|cp
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
name|nfhp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|attrflag
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
block|{
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
operator|&
name|nfsva
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
condition|)
block|{
name|error
operator|=
name|nfsm_getfh
argument_list|(
name|nd
argument_list|,
operator|&
name|nfhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
operator|!
name|attrflag
operator|&&
name|nfhp
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
name|nfhp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|rderr
operator|=
literal|0
expr_stmt|;
name|nfsva
operator|.
name|na_mntonfileno
operator|=
literal|0xffffffff
expr_stmt|;
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|nfhp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rderr
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|bigenough
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
if|if
condition|(
name|rderr
condition|)
block|{
name|dp
operator|->
name|d_fileno
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gotmnton
condition|)
block|{
if|if
condition|(
name|nfsva
operator|.
name|na_mntonfileno
operator|!=
literal|0xffffffff
condition|)
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_mntonfileno
expr_stmt|;
else|else
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfsva
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|&&
name|nfsva
operator|.
name|na_filesid
index|[
literal|1
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|1
index|]
condition|)
block|{
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|fakefileno
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|fakefileno
operator|==
name|nfsva
operator|.
name|na_fileid
condition|)
do|;
name|dp
operator|->
name|d_fileno
operator|=
name|fakefileno
expr_stmt|;
block|}
block|}
else|else
block|{
name|dp
operator|->
name|d_fileno
operator|=
name|fileno
expr_stmt|;
block|}
operator|*
name|tl2
operator|++
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|0
index|]
operator|=
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl2
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|1
index|]
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|nfhp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|NFSRV_CMPFH
argument_list|(
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
condition|)
block|{
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|vp
expr_stmt|;
name|unlocknewvp
operator|=
literal|0
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
name|np
operator|=
name|dnp
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfscl_nget
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|,
name|vp
argument_list|,
name|nfhp
argument_list|,
name|cnp
argument_list|,
name|p
argument_list|,
operator|&
name|np
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|unlocknewvp
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|nfhp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|newvp
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|nfscl_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|unlocknewvp
condition|)
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|dp
operator|->
name|d_type
operator|=
name|vtonfs_dtype
argument_list|(
name|np
operator|->
name|n_vattr
operator|.
name|na_type
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_vp
operator|=
name|newvp
expr_stmt|;
name|NFSCNHASH
argument_list|(
name|cnp
argument_list|,
name|HASHINIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_namelen
operator|<=
name|NCHNAMLEN
condition|)
block|{
name|np
operator|->
name|n_ctime
operator|=
name|np
operator|->
name|n_vattr
operator|.
name|na_ctime
operator|.
name|tv_sec
expr_stmt|;
name|cache_enter
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
name|ndp
operator|->
name|ni_vp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlocknewvp
condition|)
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|NULLVP
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|nfhp
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If at end of rpc data, get the eof boolean 		 */
if|if
condition|(
operator|!
name|more_dirs
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|eof
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tryformoredirs
condition|)
name|more_dirs
operator|=
operator|!
name|eof
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
block|}
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Fill last record, iff any, out to a multiple of DIRBLKSIZ 	 * by increasing d_reclen for the last record. 	 */
if|if
condition|(
name|blksiz
operator|>
literal|0
condition|)
block|{
name|left
operator|=
name|DIRBLKSIZ
operator|-
name|blksiz
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|+=
name|left
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|left
expr_stmt|;
block|}
comment|/* 	 * If returning no data, assume end of file. 	 * If not bigenough, return not end of file, since you aren't 	 *    returning all the data 	 * Otherwise, return the eof flag from the server. 	 */
if|if
condition|(
name|eofp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tresid
operator|==
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|bigenough
condition|)
operator|*
name|eofp
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|eofp
operator|=
name|eof
expr_stmt|;
block|}
comment|/* 	 * Add extra empty records to any remaining DIRBLKSIZ chunks. 	 */
while|while
condition|(
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
operator|>
literal|0
operator|&&
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
operator|!=
name|tresid
condition|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|d_name
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRBLKSIZ
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|DIRBLKSIZ
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRBLKSIZ
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRBLKSIZ
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|DIRBLKSIZ
expr_stmt|;
block|}
name|nfsmout
label|:
if|if
condition|(
name|nd
operator|->
name|nd_mrep
operator|!=
name|NULL
condition|)
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APPLE */
end_comment

begin_comment
comment|/*  * Nfs commit rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_commit
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_quad_t
name|offset
parameter_list|,
name|int
name|cnt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|u_char
modifier|*
name|verfp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_COMMIT
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
comment|/* 		 * And do a Getattr op. 		 */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|NULL
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
name|tl
argument_list|,
name|verfp
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
block|}
name|nfsmout
label|:
if|if
condition|(
operator|!
name|error
operator|&&
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NFS byte range lock rpc.  * (Mostly just calls one of the three lower level RPC routines.)  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_advlock
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|off_t
name|size
parameter_list|,
name|int
name|op
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|reclaim
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|u_int64_t
name|off
decl_stmt|,
name|len
decl_stmt|;
name|off_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|u_int32_t
name|clidrev
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|newone
init|=
literal|0
decl_stmt|,
name|expireret
init|=
literal|0
decl_stmt|,
name|retrycnt
decl_stmt|,
name|donelocally
decl_stmt|;
name|int
name|callcnt
decl_stmt|,
name|dorpc
decl_stmt|;
comment|/* 	 * Convert the flock structure into a start and end and do POSIX 	 * bounds checking. 	 */
switch|switch
condition|(
name|fl
operator|->
name|l_whence
condition|)
block|{
case|case
name|SEEK_SET
case|:
case|case
name|SEEK_CUR
case|:
comment|/* 		 * Caller is responsible for adding any necessary offset 		 * when SEEK_CUR is used. 		 */
name|start
operator|=
name|fl
operator|->
name|l_start
expr_stmt|;
name|off
operator|=
name|fl
operator|->
name|l_start
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
name|start
operator|=
name|size
operator|+
name|fl
operator|->
name|l_start
expr_stmt|;
name|off
operator|=
name|size
operator|+
name|fl
operator|->
name|l_start
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
empty_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|fl
operator|->
name|l_len
operator|!=
literal|0
condition|)
block|{
name|end
operator|=
name|start
operator|+
name|fl
operator|->
name|l_len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|end
operator|<
name|start
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|len
operator|=
name|fl
operator|->
name|l_len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|NFS64BITSSET
expr_stmt|;
name|retrycnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|F_GETLK
condition|)
block|{
name|error
operator|=
name|nfscl_getcl
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfscl_lockt
argument_list|(
name|vp
argument_list|,
name|clp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|fl
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|clidrev
operator|=
name|clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
name|error
operator|=
name|nfsrpc_lockt
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|clp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|fl
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|nfscl_clientrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|F_UNLCK
operator|&&
name|fl
operator|->
name|l_type
operator|==
name|F_UNLCK
condition|)
block|{
comment|/* 		 * We must loop around for all lockowner cases. 		 */
name|callcnt
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|nfscl_getcl
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
do|do
block|{
name|error
operator|=
name|nfscl_relbytelock
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|callcnt
argument_list|,
name|clp
argument_list|,
operator|&
name|lp
argument_list|,
operator|&
name|dorpc
argument_list|)
expr_stmt|;
comment|/* 		     * If it returns a NULL lp, we're done. 		     */
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|callcnt
operator|==
literal|0
condition|)
name|nfscl_clientrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
else|else
name|nfscl_releasealllocks
argument_list|(
name|clp
argument_list|,
name|vp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
else|else
name|clidrev
operator|=
literal|0
expr_stmt|;
comment|/* 		     * If the server doesn't support Posix lock semantics, 		     * only allow locks on the entire file, since it won't 		     * handle overlapping byte ranges. 		     * There might still be a problem when a lock 		     * upgrade/downgrade (read<->write) occurs, since the 		     * server "might" expect an unlock first? 		     */
if|if
condition|(
name|dorpc
operator|&&
operator|(
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_posixlock
operator|||
operator|(
name|off
operator|==
literal|0
operator|&&
name|len
operator|==
name|NFS64BITSSET
operator|)
operator|)
condition|)
block|{
comment|/* 			 * Since the lock records will go away, we must 			 * wait for grace and delay here. 			 */
do|do
block|{
name|error
operator|=
name|nfsrpc_locku
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|lp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|NFSV4LOCKT_READ
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_GRACE
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
operator|)
operator|&&
name|error
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfs_advlock"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_GRACE
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
operator|)
operator|&&
name|error
operator|==
literal|0
condition|)
do|;
block|}
name|callcnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
literal|0
operator|&&
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
do|;
name|nfscl_releasealllocks
argument_list|(
name|clp
argument_list|,
name|vp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|F_SETLK
condition|)
block|{
name|error
operator|=
name|nfscl_getbytelock
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|fl
operator|->
name|l_type
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|lp
argument_list|,
operator|&
name|newone
argument_list|,
operator|&
name|donelocally
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|donelocally
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
else|else
name|clidrev
operator|=
literal|0
expr_stmt|;
name|nfhp
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_fhp
expr_stmt|;
if|if
condition|(
operator|!
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_posixlock
operator|&&
operator|(
name|off
operator|!=
literal|0
operator|||
name|len
operator|!=
name|NFS64BITSSET
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfsrpc_lock
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|lp
argument_list|,
name|newone
argument_list|,
name|reclaim
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|fl
operator|->
name|l_type
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfscl_lockrelease
argument_list|(
name|lp
argument_list|,
name|error
argument_list|,
name|newone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_DELAY
condition|)
block|{
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfs_advlock"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|clidrev
operator|!=
literal|0
condition|)
block|{
name|expireret
operator|=
name|nfscl_hasexpired
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|clidrev
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|retrycnt
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|expireret
operator|==
literal|0
operator|&&
name|clidrev
operator|!=
literal|0
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
condition|)
do|;
if|if
condition|(
name|error
operator|&&
name|retrycnt
operator|>=
literal|4
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The lower level routine for the LockT case.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_lockt
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|u_int64_t
name|off
parameter_list|,
name|u_int64_t
name|len
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
decl_stmt|,
name|type
decl_stmt|,
name|size
decl_stmt|;
name|u_int8_t
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
index|]
decl_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOCKT
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|7
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|l_type
operator|==
name|F_RDLCK
condition|)
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4LOCKT_READ
argument_list|)
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4LOCKT_WRITE
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|off
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|txdr_hyper
argument_list|(
name|len
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|nfscl_filllockowner
argument_list|(
name|p
argument_list|,
name|own
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|fl
operator|->
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DENIED
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
name|fl
operator|->
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|8
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|fl
operator|->
name|l_start
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|len
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|NFS64BITSSET
condition|)
name|fl
operator|->
name|l_len
operator|=
literal|0
expr_stmt|;
else|else
name|fl
operator|->
name|l_len
operator|=
name|len
expr_stmt|;
name|type
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NFSV4LOCKT_WRITE
condition|)
name|fl
operator|->
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
else|else
name|fl
operator|->
name|l_type
operator|=
name|F_RDLCK
expr_stmt|;
comment|/* 		 * XXX For now, I have no idea what to do with the 		 * conflicting lock_owner, so I'll just set the pid == 0 		 * and skip over the lock_owner. 		 */
name|fl
operator|->
name|l_pid
operator|=
operator|(
name|pid_t
operator|)
literal|0
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|size
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
operator|||
name|size
operator|>
name|NFSV4_OPAQUELIMIT
condition|)
name|error
operator|=
name|EBADRPC
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|size
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_STALECLIENTID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lower level function that performs the LockU RPC.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_locku
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
name|lp
parameter_list|,
name|u_int64_t
name|off
parameter_list|,
name|u_int64_t
name|len
parameter_list|,
name|u_int32_t
name|type
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|syscred
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOCKU
argument_list|,
name|nmp
argument_list|,
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_fh
argument_list|,
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_fhlen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
literal|6
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|type
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|lp
operator|->
name|nfsl_seqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfstest_outofseq
operator|&&
operator|(
name|arc4random
argument_list|()
operator|%
name|nfstest_outofseq
operator|)
operator|==
literal|0
condition|)
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|lp
operator|->
name|nfsl_seqid
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tl
operator|++
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
name|txdr_hyper
argument_list|(
name|off
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|txdr_hyper
argument_list|(
name|len
argument_list|,
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|syscred
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSCL_INCRSEQID
argument_list|(
name|lp
operator|->
name|nfsl_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The actual Lock RPC.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_lock
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|u_int8_t
modifier|*
name|nfhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
name|lp
parameter_list|,
name|int
name|newone
parameter_list|,
name|int
name|reclaim
parameter_list|,
name|u_int64_t
name|off
parameter_list|,
name|u_int64_t
name|len
parameter_list|,
name|short
name|type
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|syscred
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
decl_stmt|,
name|size
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOCK
argument_list|,
name|nmp
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|7
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|F_RDLCK
condition|)
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4LOCKT_READ
argument_list|)
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4LOCKT_WRITE
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|reclaim
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|off
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|txdr_hyper
argument_list|(
name|len
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|newone
condition|)
block|{
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
literal|2
operator|*
name|NFSX_UNSIGNED
operator|+
name|NFSX_HYPER
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|lp
operator|->
name|nfsl_seqid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_own
operator|->
name|nfsow_clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_own
operator|->
name|nfsow_clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|lp
operator|->
name|nfsl_seqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfstest_outofseq
operator|&&
operator|(
name|arc4random
argument_list|()
operator|%
name|nfstest_outofseq
operator|)
operator|==
literal|0
condition|)
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|lp
operator|->
name|nfsl_seqid
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|syscred
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|newone
condition|)
name|NFSCL_INCRSEQID
argument_list|(
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
name|NFSCL_INCRSEQID
argument_list|(
name|lp
operator|->
name|nfsl_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DENIED
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|8
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|size
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|7
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
operator|||
name|size
operator|>
name|NFSV4_OPAQUELIMIT
condition|)
name|error
operator|=
name|EBADRPC
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|size
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs statfs rpc  * (always called with the vp for the mount point)  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_statfs
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsstatfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|nfsfsinfo
modifier|*
name|fsp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
init|=
name|NULL
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
comment|/* 		 * For V4, you actually do a getattr. 		 */
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_GETATTR
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSSTATFS_GETATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
name|nap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|sbp
argument_list|,
name|fsp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|nmp
operator|->
name|nm_fsid
index|[
literal|0
index|]
operator|=
name|nap
operator|->
name|na_filesid
index|[
literal|0
index|]
expr_stmt|;
name|nmp
operator|->
name|nm_fsid
index|[
literal|1
index|]
operator|=
name|nap
operator|->
name|na_filesid
index|[
literal|1
index|]
expr_stmt|;
name|NFSSETHASSETFSID
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
else|else
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_FSSTAT
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATFS
argument_list|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NFSHASNFSV3
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|sbp
operator|->
name|sf_tbytes
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|sbp
operator|->
name|sf_fbytes
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|sbp
operator|->
name|sf_abytes
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|sbp
operator|->
name|sf_tfiles
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|sbp
operator|->
name|sf_ffiles
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|sbp
operator|->
name|sf_afiles
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|sbp
operator|->
name|sf_invarsec
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sbp
operator|->
name|sf_tsize
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|sf_bsize
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|sf_blocks
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|sf_bfree
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|sf_bavail
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs pathconf rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_pathconf
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsv3_pathconf
modifier|*
name|pc
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
comment|/* 		 * For V4, you actually do a getattr. 		 */
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_GETATTR
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSPATHCONF_GETATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
name|nap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|attrflagp
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
block|}
block|}
else|else
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_PATHCONF
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V3PATHCONF
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_linkmax
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_namemax
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_notrunc
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_chownrestricted
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_caseinsensitive
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_casepreserving
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
block|}
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs version 3 fsinfo rpc call  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_fsinfo
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsfsinfo
modifier|*
name|fsp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_FSINFO
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V3FSINFO
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_rtmax
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_rtpref
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_rtmult
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_wtmax
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_wtpref
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_wtmult
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_dtpref
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_maxfilesize
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|fxdr_nfsv3time
argument_list|(
name|tl
argument_list|,
operator|&
name|fsp
operator|->
name|fs_timedelta
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|fsp
operator|->
name|fs_properties
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function performs the Renew RPC.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_renew
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nmp
operator|=
name|clp
operator|->
name|nfsc_nmp
expr_stmt|;
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RENEW
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function performs the Releaselockowner RPC.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_rellockown
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
name|lp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RELEASELCKOWN
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function performs the Compound to get the mount pt FH.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_getdirpath
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|u_char
modifier|*
name|dirpath
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cnt
decl_stmt|,
name|len
decl_stmt|,
name|setnil
decl_stmt|;
name|u_int32_t
modifier|*
name|opcntp
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_PUTROOTFH
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|opcntp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|dirpath
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|setnil
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|cp
operator|++
expr_stmt|;
name|cp2
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp2
operator|!=
literal|'/'
condition|)
name|cp2
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp2
operator|==
literal|'/'
condition|)
block|{
name|setnil
operator|=
literal|1
expr_stmt|;
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|cp2
operator|!=
name|cp
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_LOOKUP
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|setnil
condition|)
operator|*
name|cp2
operator|++
operator|=
literal|'/'
expr_stmt|;
name|cp
operator|=
name|cp2
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
do|;
operator|*
name|opcntp
operator|=
name|txdr_unsigned
argument_list|(
literal|2
operator|+
name|cnt
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
operator|(
literal|3
operator|+
literal|2
operator|*
name|cnt
operator|)
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|tl
operator|+=
operator|(
literal|2
operator|+
literal|2
operator|*
name|cnt
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|len
operator|>
name|NFSX_FHMAX
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_BADXDR
expr_stmt|;
block|}
else|else
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|nmp
operator|->
name|nm_fh
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
name|nmp
operator|->
name|nm_fhsize
operator|=
name|len
expr_stmt|;
block|}
block|}
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function performs the Delegreturn RPC.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_delegreturn
parameter_list|(
name|struct
name|nfscldeleg
modifier|*
name|dp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|syscred
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_DELEGRETURN
argument_list|,
name|nmp
argument_list|,
name|dp
operator|->
name|nfsdl_fh
argument_list|,
name|dp
operator|->
name|nfsdl_fhlen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|syscred
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs getacl call.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_getacl
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nfsrv_useacl
operator|==
literal|0
operator|||
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_GETACL
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_ACL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|aclp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs setacl call.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_setacl
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nfsrv_useacl
operator|==
literal|0
operator|||
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|error
operator|=
name|nfsrpc_setattr
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|,
name|aclp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs setacl call.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_setaclrpc
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_SETACL
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|nfsm_stateidtom
argument_list|(
name|nd
argument_list|,
name|stateidp
argument_list|,
name|NFSSTATEID_PUTSTATEID
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_ACL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsv4_fillattr
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|aclp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Don't care about the pre/postop attributes */
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|nd
operator|->
name|nd_repstat
operator|)
return|;
block|}
end_function

end_unit

