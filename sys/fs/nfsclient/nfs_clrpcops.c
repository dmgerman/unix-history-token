begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Rpc op calls, generally called from the vnode op calls or through the  * buffer cache, for NFS v2, 3 and 4.  * These do not normally make any changes to vnode arguments or use  * structures that might change between the VFS variants. The returned  * arguments are all at the end, after the NFSPROC_T *p one.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|APPLEKEXT
end_ifndef

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_nfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsignore_eexist
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfs
argument_list|,
name|OID_AUTO
argument_list|,
name|ignore_eexist
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfsignore_eexist
argument_list|,
literal|0
argument_list|,
literal|"NFS ignore EEXIST replies for mkdir/symlink"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Global variables  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nfs_numnfscbd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|timeval
name|nfsboottime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_int32_t
name|newnfs_false
decl_stmt|,
name|newnfs_true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|nfstype
name|nfsv34_type
index|[
literal|9
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_useacl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|nfsv4_callbackaddr
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfscl_debuglevel
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NFSCLSTATEMUTEX
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|nfstest_outofseq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfscl_assumeposixlocks
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfscl_enablecallb
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|nfsv4_cbport
init|=
name|NFSV4_CBPORT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfstest_openallsetattr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APPLEKEXT */
end_comment

begin_define
define|#
directive|define
name|DIRHDSIZ
value|(sizeof (struct dirent) - (MAXNAMLEN + 1))
end_define

begin_comment
comment|/*  * nfscl_getsameserver() can return one of three values:  * NFSDSP_USETHISSESSION - Use this session for the DS.  * NFSDSP_SEQTHISSESSION - Use the nfsclds_sequence field of this dsp for new  *     session.  * NFSDSP_NOTFOUND - No matching server was found.  */
end_comment

begin_enum
enum|enum
name|nfsclds_state
block|{
name|NFSDSP_USETHISSESSION
init|=
literal|0
block|,
name|NFSDSP_SEQTHISSESSION
init|=
literal|1
block|,
name|NFSDSP_NOTFOUND
init|=
literal|2
block|, }
enum|;
end_enum

begin_function_decl
specifier|static
name|int
name|nfsrpc_setattrrpc
parameter_list|(
name|vnode_t
parameter_list|,
name|struct
name|vattr
modifier|*
parameter_list|,
name|nfsv4stateid_t
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_readrpc
parameter_list|(
name|vnode_t
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|nfsv4stateid_t
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_writerpc
parameter_list|(
name|vnode_t
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|nfsv4stateid_t
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_createv23
parameter_list|(
name|vnode_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|vattr
modifier|*
parameter_list|,
name|nfsquad_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_createv4
parameter_list|(
name|vnode_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|vattr
modifier|*
parameter_list|,
name|nfsquad_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|nfsclowner
modifier|*
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|struct
name|nfsvattr
modifier|*
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_locku
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
parameter_list|,
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
parameter_list|,
name|u_int64_t
parameter_list|,
name|u_int64_t
parameter_list|,
name|u_int32_t
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_setaclrpc
parameter_list|(
name|vnode_t
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|,
name|struct
name|acl
modifier|*
parameter_list|,
name|nfsv4stateid_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_getlayout
parameter_list|(
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|vnode_t
parameter_list|,
name|struct
name|nfsfh
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint32_t
modifier|*
parameter_list|,
name|nfsv4stateid_t
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|struct
name|nfscllayout
modifier|*
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_fillsa
parameter_list|(
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
parameter_list|,
name|struct
name|nfsclds
modifier|*
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfscl_initsessionslots
parameter_list|(
name|struct
name|nfsclsession
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfscl_doflayoutio
parameter_list|(
name|vnode_t
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|nfsv4stateid_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|nfscldevinfo
modifier|*
parameter_list|,
name|struct
name|nfscllayout
modifier|*
parameter_list|,
name|struct
name|nfsclflayout
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_readds
parameter_list|(
name|vnode_t
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|nfsv4stateid_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|nfsclds
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|nfsfh
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_writeds
parameter_list|(
name|vnode_t
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|nfsv4stateid_t
modifier|*
parameter_list|,
name|struct
name|nfsclds
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|nfsfh
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|nfsclds_state
name|nfscl_getsameserver
parameter_list|(
name|struct
name|nfsmount
modifier|*
parameter_list|,
name|struct
name|nfsclds
modifier|*
parameter_list|,
name|struct
name|nfsclds
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrpc_commitds
parameter_list|(
name|vnode_t
parameter_list|,
name|uint64_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|nfsclds
modifier|*
parameter_list|,
name|struct
name|nfsfh
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|NFSPROC_T
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * nfs null call from vfs.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_null
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_NULL
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs access rpc op.  * For nfs version 3 and 4, use the access rpc to check accessibility. If file  * modes are changed on the server, accesses might still fail later.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_access
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|int
name|acmode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int32_t
name|mode
decl_stmt|,
name|rmode
decl_stmt|;
if|if
condition|(
name|acmode
operator|&
name|VREAD
condition|)
name|mode
operator|=
name|NFSACCESS_READ
expr_stmt|;
else|else
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
name|acmode
operator|&
name|VWRITE
condition|)
name|mode
operator||=
operator|(
name|NFSACCESS_MODIFY
operator||
name|NFSACCESS_EXTEND
operator||
name|NFSACCESS_DELETE
operator|)
expr_stmt|;
if|if
condition|(
name|acmode
operator|&
name|VEXEC
condition|)
name|mode
operator||=
name|NFSACCESS_LOOKUP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|acmode
operator|&
name|VWRITE
condition|)
name|mode
operator||=
operator|(
name|NFSACCESS_MODIFY
operator||
name|NFSACCESS_EXTEND
operator|)
expr_stmt|;
if|if
condition|(
name|acmode
operator|&
name|VEXEC
condition|)
name|mode
operator||=
name|NFSACCESS_EXECUTE
expr_stmt|;
block|}
comment|/* 	 * Now, just call nfsrpc_accessrpc() to do the actual RPC. 	 */
name|error
operator|=
name|nfsrpc_accessrpc
argument_list|(
name|vp
argument_list|,
name|mode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
operator|&
name|rmode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * The NFS V3 spec does not clarify whether or not 	 * the returned access bits can be a superset of 	 * the ones requested, so... 	 */
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|rmode
operator|&
name|mode
operator|)
operator|!=
name|mode
condition|)
name|error
operator|=
name|EACCES
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The actual rpc, separated out for Darwin.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_accessrpc
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|u_int32_t
modifier|*
name|rmodep
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|u_int32_t
name|supported
decl_stmt|,
name|rmode
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|supported
operator|=
name|mode
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_ACCESS
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
comment|/* 		 * And do a Getattr op. 		 */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|supported
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
block|}
name|rmode
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
comment|/* 		 * It's not obvious what should be done about 		 * unsupported access modes. For now, be paranoid 		 * and clear the unsupported ones. 		 */
name|rmode
operator|&=
name|supported
expr_stmt|;
operator|*
name|rmodep
operator|=
name|rmode
expr_stmt|;
block|}
else|else
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs open rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_open
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|int
name|amode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|u_int32_t
name|mode
decl_stmt|,
name|clidrev
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|newone
decl_stmt|,
name|error
decl_stmt|,
name|expireret
init|=
literal|0
decl_stmt|,
name|retrycnt
decl_stmt|;
comment|/* 	 * For NFSv4, Open Ops are only done on Regular Files. 	 */
if|if
condition|(
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|!=
name|VREG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|amode
operator|&
name|FREAD
condition|)
name|mode
operator||=
name|NFSV4OPEN_ACCESSREAD
expr_stmt|;
if|if
condition|(
name|amode
operator|&
name|FWRITE
condition|)
name|mode
operator||=
name|NFSV4OPEN_ACCESSWRITE
expr_stmt|;
name|nfhp
operator|=
name|np
operator|->
name|n_fhp
expr_stmt|;
name|retrycnt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
block|{
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
name|int
name|namel
decl_stmt|;
name|namel
operator|=
operator|(
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
operator|<
literal|100
operator|)
condition|?
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
else|:
literal|99
expr_stmt|;
name|bcopy
argument_list|(
name|NFS4NODENAME
argument_list|(
name|np
operator|->
name|n_v4
argument_list|)
argument_list|,
name|name
argument_list|,
name|namel
argument_list|)
expr_stmt|;
name|name
index|[
name|namel
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"rpcopen p=0x%x name=%s"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfhp
operator|->
name|nfh_len
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" fh=0x%x\n"
argument_list|,
name|nfhp
operator|->
name|nfh_fh
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" fhl=0\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
do|do
block|{
name|dp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|nfscl_open
argument_list|(
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
operator|&
name|op
argument_list|,
operator|&
name|newone
argument_list|,
operator|&
name|ret
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
else|else
name|clidrev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSCLOPEN_DOOPEN
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_v4
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|nfsrpc_openrpc
argument_list|(
name|nmp
argument_list|,
name|vp
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_data
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_fhlen
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|mode
argument_list|,
name|op
argument_list|,
name|NFS4NODENAME
argument_list|(
name|np
operator|->
name|n_v4
argument_list|)
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
argument_list|,
operator|&
name|dp
argument_list|,
literal|0
argument_list|,
literal|0x0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|APPLE
name|OSBitAndAtomic
argument_list|(
operator|(
name|int32_t
operator|)
operator|~
name|NDELEGMOD
argument_list|,
operator|(
name|UInt32
operator|*
operator|)
operator|&
name|np
operator|->
name|n_flag
argument_list|)
expr_stmt|;
else|#
directive|else
name|NFSLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NDELEGMOD
expr_stmt|;
comment|/* 				 * Invalidate the attribute cache, so that 				 * attributes that pre-date the issue of a 				 * delegation are not cached, since the 				 * cached attributes will remain valid while 				 * the delegation is held. 				 */
name|NFSINVALATTRCACHE
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|NFSUNLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|nfscl_deleg
argument_list|(
name|nmp
operator|->
name|nm_mountp
argument_list|,
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|newnfs_copyincred
argument_list|(
name|cred
argument_list|,
operator|&
name|op
operator|->
name|nfso_cred
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|NFSCLOPEN_SETCRED
condition|)
comment|/* 		 * This is a new local open on a delegation. It needs 		 * to have credentials so that an open can be done 		 * against the server during recovery. 		 */
name|newnfs_copyincred
argument_list|(
name|cred
argument_list|,
operator|&
name|op
operator|->
name|nfso_cred
argument_list|)
expr_stmt|;
comment|/* 	     * nfso_opencnt is the count of how many VOP_OPEN()s have 	     * been done on this Open successfully and a VOP_CLOSE() 	     * is expected for each of these. 	     * If error is non-zero, don't increment it, since the Open 	     * hasn't succeeded yet. 	     */
if|if
condition|(
operator|!
name|error
condition|)
name|op
operator|->
name|nfso_opencnt
operator|++
expr_stmt|;
name|nfscl_openrelease
argument_list|(
name|nmp
argument_list|,
name|op
argument_list|,
name|error
argument_list|,
name|newone
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_BADSESSION
condition|)
block|{
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfs_open"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|clidrev
operator|!=
literal|0
condition|)
block|{
name|expireret
operator|=
name|nfscl_hasexpired
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|clidrev
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|retrycnt
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_BADSESSION
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|expireret
operator|==
literal|0
operator|&&
name|clidrev
operator|!=
literal|0
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
condition|)
do|;
if|if
condition|(
name|error
operator|&&
name|retrycnt
operator|>=
literal|4
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * the actual open rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_openrpc
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|u_int8_t
modifier|*
name|nfhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|u_int8_t
modifier|*
name|newfhp
parameter_list|,
name|int
name|newfhlen
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|u_int8_t
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
modifier|*
name|dpp
parameter_list|,
name|int
name|reclaim
parameter_list|,
name|u_int32_t
name|delegtype
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|syscred
parameter_list|,
name|int
name|recursed
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ndp
init|=
name|NULL
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|u_int32_t
name|rflags
decl_stmt|,
name|deleg
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ret
decl_stmt|,
name|acesize
decl_stmt|,
name|limitby
decl_stmt|;
name|struct
name|nfsclsession
modifier|*
name|tsep
decl_stmt|;
name|dp
operator|=
operator|*
name|dpp
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_OPEN
argument_list|,
name|nmp
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|mode
operator|&
name|NFSV4OPEN_ACCESSBOTH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
operator|(
name|mode
operator|>>
name|NFSLCK_SHIFT
operator|)
operator|&
name|NFSV4OPEN_DENYBOTH
argument_list|)
expr_stmt|;
name|tsep
operator|=
name|nfsmnt_mdssession
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_NOCREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclaim
condition|)
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_CLAIMPREVIOUS
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|delegtype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_CLAIMDELEGATECUR
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_CLAIMNULL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_CHANGE
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_TIMEMODIFY
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|syscred
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NFSCL_INCRSEQID
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
literal|6
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
expr_stmt|;
name|rflags
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|6
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|deleg
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleg
operator|==
name|NFSV4OPEN_DELEGATEREAD
operator|||
name|deleg
operator|==
name|NFSV4OPEN_DELEGATEWRITE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_FIRSTDELEG
operator|)
condition|)
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
operator|->
name|nfsc_flags
operator||=
operator|(
name|NFSCLFLAGS_FIRSTDELEG
operator||
name|NFSCLFLAGS_GOTDELEG
operator|)
expr_stmt|;
name|MALLOC
argument_list|(
name|ndp
argument_list|,
expr|struct
name|nfscldeleg
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfscldeleg
argument_list|)
operator|+
name|newfhlen
argument_list|,
name|M_NFSCLDELEG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ndp
operator|->
name|nfsdl_owner
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ndp
operator|->
name|nfsdl_lock
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|nfsdl_clp
operator|=
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
expr_stmt|;
name|ndp
operator|->
name|nfsdl_fhlen
operator|=
name|newfhlen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|newfhp
argument_list|,
name|ndp
operator|->
name|nfsdl_fh
argument_list|,
name|newfhlen
argument_list|)
expr_stmt|;
name|newnfs_copyincred
argument_list|(
name|cred
argument_list|,
operator|&
name|ndp
operator|->
name|nfsdl_cred
argument_list|)
expr_stmt|;
name|nfscl_lockinit
argument_list|(
operator|&
name|ndp
operator|->
name|nfsdl_rwlock
argument_list|)
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|nfsdl_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ndp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ndp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ndp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ret
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleg
operator|==
name|NFSV4OPEN_DELEGATEWRITE
condition|)
block|{
name|ndp
operator|->
name|nfsdl_flags
operator|=
name|NFSCLDL_WRITE
expr_stmt|;
comment|/* 				 * Indicates how much the file can grow. 				 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|limitby
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|limitby
condition|)
block|{
case|case
name|NFSV4OPEN_LIMITSIZE
case|:
name|ndp
operator|->
name|nfsdl_sizelimit
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFSV4OPEN_LIMITBLOCKS
case|:
name|ndp
operator|->
name|nfsdl_sizelimit
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int64_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|nfsdl_sizelimit
operator|*=
name|fxdr_unsigned
argument_list|(
name|u_int64_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
empty_stmt|;
block|}
else|else
block|{
name|ndp
operator|->
name|nfsdl_flags
operator|=
name|NFSCLDL_READ
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
name|ndp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_RECALL
expr_stmt|;
name|error
operator|=
name|nfsrv_dissectace
argument_list|(
name|nd
argument_list|,
operator|&
name|ndp
operator|->
name|nfsdl_ace
argument_list|,
operator|&
name|ret
argument_list|,
operator|&
name|acesize
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
elseif|else
if|if
condition|(
name|deleg
operator|!=
name|NFSV4OPEN_DELEGATENONE
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
if|if
condition|(
name|ndp
operator|!=
name|NULL
condition|)
block|{
name|ndp
operator|->
name|nfsdl_change
operator|=
name|nfsva
operator|.
name|na_filerev
expr_stmt|;
name|ndp
operator|->
name|nfsdl_modtime
operator|=
name|nfsva
operator|.
name|na_mtime
expr_stmt|;
name|ndp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_MODTIMESET
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reclaim
operator|&&
operator|(
name|rflags
operator|&
name|NFSV4OPEN_RESULTCONFIRM
operator|)
condition|)
block|{
do|do
block|{
name|ret
operator|=
name|nfsrpc_openconfirm
argument_list|(
name|vp
argument_list|,
name|newfhp
argument_list|,
name|newfhlen
argument_list|,
name|op
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|ret
argument_list|,
literal|"nfs_open"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
do|;
name|error
operator|=
name|ret
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|rflags
operator|&
name|NFSV4OPEN_LOCKTYPEPOSIX
operator|)
operator|||
name|nfscl_assumeposixlocks
condition|)
name|op
operator|->
name|nfso_posixlock
operator|=
literal|1
expr_stmt|;
else|else
name|op
operator|->
name|nfso_posixlock
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If the server is handing out delegations, but we didn't 		 * get one because an OpenConfirm was required, try the 		 * Open again, to get a delegation. This is a harmless no-op, 		 * from a server's point of view. 		 */
if|if
condition|(
operator|!
name|reclaim
operator|&&
operator|(
name|rflags
operator|&
name|NFSV4OPEN_RESULTCONFIRM
operator|)
operator|&&
operator|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_GOTDELEG
operator|)
operator|&&
operator|!
name|error
operator|&&
name|dp
operator|==
name|NULL
operator|&&
name|ndp
operator|==
name|NULL
operator|&&
operator|!
name|recursed
condition|)
block|{
do|do
block|{
name|ret
operator|=
name|nfsrpc_openrpc
argument_list|(
name|nmp
argument_list|,
name|vp
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|,
name|newfhp
argument_list|,
name|newfhlen
argument_list|,
name|mode
argument_list|,
name|op
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
operator|&
name|ndp
argument_list|,
literal|0
argument_list|,
literal|0x0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|syscred
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|ret
argument_list|,
literal|"nfs_open2"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
do|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|ndp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|ndp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|ret
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|ret
operator|==
name|NFSERR_BADSESSION
condition|)
name|error
operator|=
name|ret
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALECLIENTID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|dpp
operator|=
name|ndp
expr_stmt|;
elseif|else
if|if
condition|(
name|ndp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|ndp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * open downgrade rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_opendowngrade
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_int32_t
name|mode
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_OPENDOWNGRADE
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
argument_list|)
condition|)
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|mode
operator|&
name|NFSV4OPEN_ACCESSBOTH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
operator|(
name|mode
operator|>>
name|NFSLCK_SHIFT
operator|)
operator|&
name|NFSV4OPEN_DENYBOTH
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NFSCL_INCRSEQID
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * V4 Close operation.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_close
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|int
name|doclose
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|!=
name|VREG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|doclose
condition|)
name|error
operator|=
name|nfscl_doclose
argument_list|(
name|vp
argument_list|,
operator|&
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nfscl_getclose
argument_list|(
name|vp
argument_list|,
operator|&
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nfscl_clientrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the open.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrpc_doclose
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|,
modifier|*
name|nlp
decl_stmt|;
name|struct
name|nfscllock
modifier|*
name|lop
decl_stmt|,
modifier|*
name|nlop
decl_stmt|;
name|struct
name|ucred
modifier|*
name|tcred
decl_stmt|;
name|u_int64_t
name|off
init|=
literal|0
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|type
init|=
name|NFSV4LOCKT_READ
decl_stmt|;
name|int
name|error
decl_stmt|,
name|do_unlock
decl_stmt|,
name|trycnt
decl_stmt|;
name|tcred
operator|=
name|newnfs_getcred
argument_list|()
expr_stmt|;
name|newnfs_copycred
argument_list|(
operator|&
name|op
operator|->
name|nfso_cred
argument_list|,
name|tcred
argument_list|)
expr_stmt|;
comment|/* 	 * (Theoretically this could be done in the same 	 *  compound as the close, but having multiple 	 *  sequenced Ops in the same compound might be 	 *  too scary for some servers.) 	 */
if|if
condition|(
name|op
operator|->
name|nfso_posixlock
condition|)
block|{
name|off
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|NFS64BITSSET
expr_stmt|;
name|type
operator|=
name|NFSV4LOCKT_READ
expr_stmt|;
block|}
comment|/* 	 * Since this function is only called from VOP_INACTIVE(), no 	 * other thread will be manipulating this Open. As such, the 	 * lock lists are not being changed by other threads, so it should 	 * be safe to do this without locking. 	 */
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&op->nfso_lock
argument_list|,
argument|nfsl_list
argument_list|)
block|{
name|do_unlock
operator|=
literal|1
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|lop
argument_list|,
argument|&lp->nfsl_lock
argument_list|,
argument|nfslo_list
argument_list|,
argument|nlop
argument_list|)
block|{
if|if
condition|(
name|op
operator|->
name|nfso_posixlock
operator|==
literal|0
condition|)
block|{
name|off
operator|=
name|lop
operator|->
name|nfslo_first
expr_stmt|;
name|len
operator|=
name|lop
operator|->
name|nfslo_end
operator|-
name|lop
operator|->
name|nfslo_first
expr_stmt|;
if|if
condition|(
name|lop
operator|->
name|nfslo_type
operator|==
name|F_WRLCK
condition|)
name|type
operator|=
name|NFSV4LOCKT_WRITE
expr_stmt|;
else|else
name|type
operator|=
name|NFSV4LOCKT_READ
expr_stmt|;
block|}
if|if
condition|(
name|do_unlock
condition|)
block|{
name|trycnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrpc_locku
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|lp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
name|tcred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_GRACE
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
operator|)
operator|&&
name|error
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
operator|(
name|int
operator|)
name|nd
operator|->
name|nd_repstat
argument_list|,
literal|"nfs_close"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_GRACE
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
operator|)
operator|&&
name|error
operator|==
literal|0
operator|&&
name|trycnt
operator|++
operator|<
literal|5
condition|)
do|;
if|if
condition|(
name|op
operator|->
name|nfso_posixlock
condition|)
name|do_unlock
operator|=
literal|0
expr_stmt|;
block|}
name|nfscl_freelock
argument_list|(
name|lop
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Do a ReleaseLockOwner. 		 * The lock owner name nfsl_owner may be used by other opens for 		 * other files but the lock_owner4 name that nfsrpc_rellockown() 		 * puts on the wire has the file handle for this file appended 		 * to it, so it can be done now. 		 */
operator|(
name|void
operator|)
name|nfsrpc_rellockown
argument_list|(
name|nmp
argument_list|,
name|lp
argument_list|,
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_fh
argument_list|,
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_fhlen
argument_list|,
name|tcred
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * There could be other Opens for different files on the same 	 * OpenOwner, so locking is required. 	 */
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|nfscl_lockexcl
argument_list|(
operator|&
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_rwlock
argument_list|,
name|NFSCLSTATEMUTEXPTR
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
do|do
block|{
name|error
operator|=
name|nfscl_tryclose
argument_list|(
name|op
argument_list|,
name|tcred
argument_list|,
name|nmp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfs_close"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
condition|)
do|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|nfscl_lockunlock
argument_list|(
operator|&
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_rwlock
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|lp
argument_list|,
argument|&op->nfso_lock
argument_list|,
argument|nfsl_list
argument_list|,
argument|nlp
argument_list|)
name|nfscl_freelockowner
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nfscl_freeopen
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
name|NFSFREECRED
argument_list|(
name|tcred
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The actual Close RPC.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_closerpc
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|syscred
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_CLOSE
argument_list|,
name|nmp
argument_list|,
name|op
operator|->
name|nfso_fh
argument_list|,
name|op
operator|->
name|nfso_fhlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
operator|+
name|NFSX_STATEID
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|syscred
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NFSCL_INCRSEQID
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * V4 Open Confirm RPC.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_openconfirm
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_int8_t
modifier|*
name|nfhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|struct
name|nfsclopen
modifier|*
name|op
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* No confirmation for NFSv4.1. */
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_OPENCONFIRM
argument_list|,
name|nmp
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
operator|+
name|NFSX_STATEID
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NFSCL_INCRSEQID
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|op
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
expr_stmt|;
block|}
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|op
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the setclientid and setclientid confirm RPCs. Called from nfs_statfs()  * when a mount has just occurred and when the server replies NFSERR_EXPIRED.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_setclient
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|int
name|reclaim
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|u_int8_t
modifier|*
name|cp
init|=
name|NULL
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
name|addr
index|[
name|INET6_ADDRSTRLEN
operator|+
literal|9
index|]
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|int
name|error
decl_stmt|,
name|isinet6
init|=
literal|0
decl_stmt|,
name|callblen
decl_stmt|;
name|nfsquad_t
name|confirm
decl_stmt|;
name|u_int32_t
name|lease
decl_stmt|;
specifier|static
name|u_int32_t
name|rev
init|=
literal|0
decl_stmt|;
name|struct
name|nfsclds
modifier|*
name|dsp
decl_stmt|;
name|struct
name|nfsclsession
modifier|*
name|tsep
decl_stmt|;
if|if
condition|(
name|nfsboottime
operator|.
name|tv_sec
operator|==
literal|0
condition|)
name|NFSSETBOOTTIME
argument_list|(
name|nfsboottime
argument_list|)
expr_stmt|;
name|clp
operator|->
name|nfsc_rev
operator|=
name|rev
operator|++
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
comment|/* 		 * Either there was no previous session or the 		 * previous session has failed, so... 		 * do an ExchangeID followed by the CreateSession. 		 */
name|error
operator|=
name|nfsrpc_exchangeid
argument_list|(
name|nmp
argument_list|,
name|clp
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NFSV4EXCH_USEPNFSMDS
operator||
name|NFSV4EXCH_USENONPNFS
argument_list|,
operator|&
name|dsp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"aft exch=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nfsrpc_createsession
argument_list|(
name|nmp
argument_list|,
operator|&
name|dsp
operator|->
name|nfsclds_sess
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|dsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_sequenceid
argument_list|,
literal|1
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
comment|/* 			 * The old sessions cannot be safely free'd 			 * here, since they may still be used by 			 * in-progress RPCs. 			 */
name|tsep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|nmp
operator|->
name|nm_sess
argument_list|)
operator|!=
name|NULL
condition|)
name|tsep
operator|=
name|NFSMNT_MDSSESSION
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|nmp
operator|->
name|nm_sess
argument_list|,
name|dsp
argument_list|,
name|nfsclds_list
argument_list|)
expr_stmt|;
comment|/* 			 * Wake up RPCs waiting for a slot on the 			 * old session. These will then fail with 			 * NFSERR_BADSESSION and be retried with the 			 * new session by nfsv4_setsequence(). 			 * Also wakeup() processes waiting for the 			 * new session. 			 */
if|if
condition|(
name|tsep
operator|!=
name|NULL
condition|)
name|wakeup
argument_list|(
operator|&
name|tsep
operator|->
name|nfsess_slots
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|nmp
operator|->
name|nm_sess
argument_list|)
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
else|else
name|nfscl_freenfsclds
argument_list|(
name|dsp
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"aft createsess=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|reclaim
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|nfsrpc_reclaimcomplete
argument_list|(
name|nmp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"aft reclaimcomp=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_COMPLETEALREADY
operator|||
name|error
operator|==
name|NFSERR_NOTSUPP
condition|)
comment|/* Ignore this error. */
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Allocate a single session structure for NFSv4.0, because some of 	 * the fields are used by NFSv4.0 although it doesn't do a session. 	 */
name|dsp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsclds
argument_list|)
argument_list|,
name|M_NFSCLDS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|dsp
operator|->
name|nfsclds_mtx
argument_list|,
literal|"nfsds"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|dsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_mtx
argument_list|,
literal|"nfssession"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|nmp
operator|->
name|nm_sess
argument_list|,
name|dsp
argument_list|,
name|nfsclds_list
argument_list|)
expr_stmt|;
name|tsep
operator|=
name|NFSMNT_MDSSESSION
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_SETCLIENTID
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nfsboottime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|clp
operator|->
name|nfsc_rev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|clp
operator|->
name|nfsc_id
argument_list|,
name|clp
operator|->
name|nfsc_idlen
argument_list|)
expr_stmt|;
comment|/* 	 * set up the callback address 	 */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFS_CALLBCKPROG
argument_list|)
expr_stmt|;
name|callblen
operator|=
name|strlen
argument_list|(
name|nfsv4_callbackaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|callblen
operator|==
literal|0
condition|)
name|cp
operator|=
name|nfscl_getmyip
argument_list|(
name|nmp
argument_list|,
operator|&
name|isinet6
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfscl_enablecallb
operator|&&
name|nfs_numnfscbd
operator|>
literal|0
operator|&&
operator|(
name|callblen
operator|>
literal|0
operator|||
name|cp
operator|!=
name|NULL
operator|)
condition|)
block|{
name|port
operator|=
name|htons
argument_list|(
name|nfsv4_cbport
argument_list|)
expr_stmt|;
name|cp2
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|port
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|callblen
operator|>
literal|0
operator|&&
name|strchr
argument_list|(
name|nfsv4_callbackaddr
argument_list|,
literal|':'
argument_list|)
operator|)
operator|||
name|isinet6
condition|)
block|{
name|char
name|ip6buf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|,
modifier|*
name|ip6add
decl_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
literal|"tcp6"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|callblen
operator|==
literal|0
condition|)
block|{
name|ip6_sprintf
argument_list|(
name|ip6buf
argument_list|,
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
name|ip6add
operator|=
name|ip6buf
expr_stmt|;
block|}
else|else
block|{
name|ip6add
operator|=
name|nfsv4_callbackaddr
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|addr
argument_list|,
name|INET6_ADDRSTRLEN
operator|+
literal|9
argument_list|,
literal|"%s.%d.%d"
argument_list|,
name|ip6add
argument_list|,
name|cp2
index|[
literal|0
index|]
argument_list|,
name|cp2
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
literal|"tcp"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|callblen
operator|==
literal|0
condition|)
name|snprintf
argument_list|(
name|addr
argument_list|,
name|INET6_ADDRSTRLEN
operator|+
literal|9
argument_list|,
literal|"%d.%d.%d.%d.%d.%d"
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|,
name|cp
index|[
literal|2
index|]
argument_list|,
name|cp
index|[
literal|3
index|]
argument_list|,
name|cp2
index|[
literal|0
index|]
argument_list|,
name|cp2
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|addr
argument_list|,
name|INET6_ADDRSTRLEN
operator|+
literal|9
argument_list|,
literal|"%s.%d.%d"
argument_list|,
name|nfsv4_callbackaddr
argument_list|,
name|cp2
index|[
literal|0
index|]
argument_list|,
name|cp2
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|addr
argument_list|,
name|strlen
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
literal|"tcp"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
literal|"0.0.0.0.0.0"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
block|}
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|clp
operator|->
name|nfsc_cbident
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|confirm
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|confirm
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
comment|/* 	     * and confirm it. 	     */
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_SETCLIENTIDCFRM
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|confirm
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|confirm
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_GETATTR
argument_list|,
name|nmp
argument_list|,
name|nmp
operator|->
name|nm_fh
argument_list|,
name|nmp
operator|->
name|nm_fhsize
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_LEASETIME
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|lease
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|clp
operator|->
name|nfsc_renew
operator|=
name|NFSCL_RENEW
argument_list|(
name|lease
argument_list|)
expr_stmt|;
name|clp
operator|->
name|nfsc_expire
operator|=
name|NFSD_MONOSEC
operator|+
name|clp
operator|->
name|nfsc_renew
expr_stmt|;
name|clp
operator|->
name|nfsc_clientidrev
operator|++
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|nfsc_clientidrev
operator|==
literal|0
condition|)
name|clp
operator|->
name|nfsc_clientidrev
operator|++
expr_stmt|;
block|}
block|}
block|}
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs getattr call.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_getattr
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_GETATTR
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs getattr call with non-vnode arguemnts.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_getattrnovp
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|u_int8_t
modifier|*
name|fhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|int
name|syscred
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|u_int64_t
modifier|*
name|xidp
parameter_list|,
name|uint32_t
modifier|*
name|leasep
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|vers
init|=
name|NFS_VER2
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_GETATTR
argument_list|,
name|nmp
argument_list|,
name|fhp
argument_list|,
name|fhlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|vers
operator|=
name|NFS_VER4
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_LEASETIME
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|vers
operator|=
name|NFS_VER3
expr_stmt|;
block|}
if|if
condition|(
name|syscred
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|vers
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|xidp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
name|nap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|leasep
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do an nfs setattr operation.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_setattr
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|NFSACL_T
modifier|*
name|aclp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|rnap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|expireret
init|=
literal|0
decl_stmt|,
name|openerr
decl_stmt|,
name|retrycnt
decl_stmt|;
name|u_int32_t
name|clidrev
init|=
literal|0
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|nfsv4stateid_t
name|stateid
decl_stmt|;
name|void
modifier|*
name|lckp
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
if|if
condition|(
name|vap
operator|!=
name|NULL
operator|&&
name|NFSATTRISSET
argument_list|(
name|u_quad_t
argument_list|,
name|vap
argument_list|,
name|va_size
argument_list|)
condition|)
name|mode
operator|=
name|NFSV4OPEN_ACCESSWRITE
expr_stmt|;
else|else
name|mode
operator|=
name|NFSV4OPEN_ACCESSREAD
expr_stmt|;
name|retrycnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|lckp
operator|=
name|NULL
expr_stmt|;
name|openerr
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|nfhp
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_fhp
expr_stmt|;
name|error
operator|=
name|nfscl_getstateid
argument_list|(
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|stateid
argument_list|,
operator|&
name|lckp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|==
name|VREG
operator|&&
operator|(
name|mode
operator|==
name|NFSV4OPEN_ACCESSWRITE
operator|||
name|nfstest_openallsetattr
operator|)
condition|)
block|{
comment|/* 				 * No Open stateid, so try and open the file 				 * now. 				 */
if|if
condition|(
name|mode
operator|==
name|NFSV4OPEN_ACCESSWRITE
condition|)
name|openerr
operator|=
name|nfsrpc_open
argument_list|(
name|vp
argument_list|,
name|FWRITE
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|openerr
operator|=
name|nfsrpc_open
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|openerr
condition|)
operator|(
name|void
operator|)
name|nfscl_getstateid
argument_list|(
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|stateid
argument_list|,
operator|&
name|lckp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
name|error
operator|=
name|nfsrpc_setattrrpc
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
operator|&
name|stateid
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|rnap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nfsrpc_setaclrpc
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|aclp
argument_list|,
operator|&
name|stateid
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_OPENMODE
operator|&&
name|mode
operator|==
name|NFSV4OPEN_ACCESSREAD
condition|)
block|{
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_OPENMODE
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lckp
operator|!=
name|NULL
condition|)
name|nfscl_lockderef
argument_list|(
name|lckp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|openerr
condition|)
operator|(
name|void
operator|)
name|nfsrpc_close
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_OLDSTATEID
operator|||
name|error
operator|==
name|NFSERR_BADSESSION
condition|)
block|{
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfs_setattr"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|clidrev
operator|!=
literal|0
condition|)
block|{
name|expireret
operator|=
name|nfscl_hasexpired
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|clidrev
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|retrycnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_BADSESSION
operator|||
operator|(
name|error
operator|==
name|NFSERR_OLDSTATEID
operator|&&
name|retrycnt
operator|<
literal|20
operator|)
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|expireret
operator|==
literal|0
operator|&&
name|clidrev
operator|!=
literal|0
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
operator|||
operator|(
name|error
operator|==
name|NFSERR_OPENMODE
operator|&&
name|mode
operator|==
name|NFSV4OPEN_ACCESSREAD
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
condition|)
do|;
if|if
condition|(
name|error
operator|&&
name|retrycnt
operator|>=
literal|4
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfsrpc_setattrrpc
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|rnap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_SETATTR
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|nfsm_stateidtom
argument_list|(
name|nd
argument_list|,
name|stateidp
argument_list|,
name|NFSSTATEID_PUTSTATEID
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|vp
argument_list|,
name|NFSSATTR_FULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|rnap
argument_list|,
name|attrflagp
argument_list|,
name|NULL
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|&&
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|rnap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs lookup rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_lookup
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|lookupp
init|=
literal|0
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vnode_vtype
argument_list|(
name|dvp
argument_list|)
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|&&
name|len
operator|==
literal|1
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* 		 * Just return the current dir's fh. 		 */
name|np
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|nfhp
argument_list|,
expr|struct
name|nfsfh
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsfh
argument_list|)
operator|+
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|M_NFSFH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nfhp
operator|->
name|nfh_len
operator|=
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
operator|*
name|nfhpp
operator|=
name|nfhp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|&&
name|len
operator|==
literal|2
operator|&&
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|lookupp
operator|=
literal|1
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOOKUPP
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOOKUP
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
comment|/* 		 * When an NFSv4 Lookupp returns ENOENT, it means that 		 * the lookup is at the root of an fs, so return this dir. 		 */
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_NOENT
operator|&&
name|lookupp
condition|)
block|{
name|np
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|nfhp
argument_list|,
expr|struct
name|nfsfh
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsfh
argument_list|)
operator|+
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|M_NFSFH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nfhp
operator|->
name|nfh_len
operator|=
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
operator|*
name|nfhpp
operator|=
name|nfhp
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
condition|)
block|{
comment|/* Load the directory attributes. */
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|dnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|dattrflagp
operator|=
literal|1
expr_stmt|;
block|}
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
condition|)
block|{
comment|/* Load the directory attributes. */
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|dnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|nfsmout
goto|;
operator|*
name|dattrflagp
operator|=
literal|1
expr_stmt|;
comment|/* Skip over the Lookup and GetFH operation status values. */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfsm_getfh
argument_list|(
name|nd
argument_list|,
name|nfhpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do a readlink rpc.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_readlink
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|,
name|cangetattr
init|=
literal|1
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_READLINK
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
comment|/* 		 * And do a Getattr op. 		 */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
block|{
name|NFSM_STRSIZ
argument_list|(
name|len
argument_list|,
name|NFS_MAXPATHLEN
argument_list|)
expr_stmt|;
comment|/* 		 * This seems weird to me, but must have been added to 		 * FreeBSD for some reason. The only thing I can think of 		 * is that there was/is some server that replies with 		 * more link data than it should? 		 */
if|if
condition|(
name|len
operator|==
name|NFS_MAXPATHLEN
condition|)
block|{
name|NFSLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_size
operator|>
literal|0
operator|&&
name|np
operator|->
name|n_size
operator|<
name|NFS_MAXPATHLEN
condition|)
block|{
name|len
operator|=
name|np
operator|->
name|n_size
expr_stmt|;
name|cangetattr
operator|=
literal|0
expr_stmt|;
block|}
name|NFSUNLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfsm_mbufuio
argument_list|(
name|nd
argument_list|,
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|&&
operator|!
name|error
operator|&&
name|cangetattr
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read operation.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_read
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|expireret
init|=
literal|0
decl_stmt|,
name|retrycnt
decl_stmt|;
name|u_int32_t
name|clidrev
init|=
literal|0
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
init|=
name|NULL
decl_stmt|;
name|nfsv4stateid_t
name|stateid
decl_stmt|;
name|void
modifier|*
name|lckp
decl_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
name|newcred
operator|=
name|cred
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|nfhp
operator|=
name|np
operator|->
name|n_fhp
expr_stmt|;
name|newcred
operator|=
name|NFSNEWCRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
block|}
name|retrycnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|lckp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|nfscl_getstateid
argument_list|(
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|NFSV4OPEN_ACCESSREAD
argument_list|,
literal|0
argument_list|,
name|newcred
argument_list|,
name|p
argument_list|,
operator|&
name|stateid
argument_list|,
operator|&
name|lckp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrpc_readrpc
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|newcred
argument_list|,
operator|&
name|stateid
argument_list|,
name|p
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_OPENMODE
condition|)
block|{
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_OPENMODE
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lckp
operator|!=
name|NULL
condition|)
name|nfscl_lockderef
argument_list|(
name|lckp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_OLDSTATEID
operator|||
name|error
operator|==
name|NFSERR_BADSESSION
condition|)
block|{
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfs_read"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|clidrev
operator|!=
literal|0
condition|)
block|{
name|expireret
operator|=
name|nfscl_hasexpired
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|clidrev
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|retrycnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_BADSESSION
operator|||
operator|(
name|error
operator|==
name|NFSERR_OLDSTATEID
operator|&&
name|retrycnt
operator|<
literal|20
operator|)
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|expireret
operator|==
literal|0
operator|&&
name|clidrev
operator|!=
literal|0
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
operator|||
operator|(
name|error
operator|==
name|NFSERR_OPENMODE
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
condition|)
do|;
if|if
condition|(
name|error
operator|&&
name|retrycnt
operator|>=
literal|4
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
name|NFSFREECRED
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The actual read RPC.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_readrpc
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|retlen
decl_stmt|,
name|tsiz
decl_stmt|,
name|eof
init|=
literal|0
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|rsize
decl_stmt|;
name|off_t
name|tmp_off
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|tsiz
operator|=
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|tmp_off
operator|=
name|uiop
operator|->
name|uio_offset
operator|+
name|tsiz
expr_stmt|;
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_off
operator|>
name|nmp
operator|->
name|nm_maxfilesize
operator|||
name|tmp_off
operator|<
name|uiop
operator|->
name|uio_offset
condition|)
block|{
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFBIG
operator|)
return|;
block|}
name|rsize
operator|=
name|nmp
operator|->
name|nm_rsize
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|tsiz
operator|>
literal|0
condition|)
block|{
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|len
operator|=
operator|(
name|tsiz
operator|>
name|rsize
operator|)
condition|?
name|rsize
else|:
name|tsiz
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_READ
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|nfsm_stateidtom
argument_list|(
name|nd
argument_list|,
name|stateidp
argument_list|,
name|NFSSTATEID_PUTSTATEID
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
operator|*
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
condition|)
block|{
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|uiop
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|txdr_hyper
argument_list|(
name|uiop
operator|->
name|uio_offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
operator|*
operator|(
name|tl
operator|+
literal|2
operator|)
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Since I can't do a Getattr for NFSv4 for Write, there 		 * doesn't seem any point in doing one here, either. 		 * (See the comment in nfsrpc_writerpc() for more info.) 		 */
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
operator|)
condition|)
block|{
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|attrflagp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|||
name|error
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|eof
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|eof
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|NFSM_STRSIZ
argument_list|(
name|retlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsm_mbufuio
argument_list|(
name|nd
argument_list|,
name|uiop
argument_list|,
name|retlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
name|tsiz
operator|-=
name|retlen
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
operator|)
condition|)
block|{
if|if
condition|(
name|eof
operator|||
name|retlen
operator|==
literal|0
condition|)
name|tsiz
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|retlen
operator|<
name|len
condition|)
name|tsiz
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|nfsmout
label|:
if|if
condition|(
name|nd
operator|->
name|nd_mrep
operator|!=
name|NULL
condition|)
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs write operation  * When called_from_strategy != 0, it should return EIO for an error that  * indicates recovery is in progress, so that the buffer will be left  * dirty and be written back to the server later. If it loops around,  * the recovery thread could get stuck waiting for the buffer and recovery  * will then deadlock.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_write
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
modifier|*
name|iomode
parameter_list|,
name|int
modifier|*
name|must_commit
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|,
name|int
name|called_from_strategy
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|expireret
init|=
literal|0
decl_stmt|,
name|retrycnt
decl_stmt|,
name|nostateid
decl_stmt|;
name|u_int32_t
name|clidrev
init|=
literal|0
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
init|=
name|NULL
decl_stmt|;
name|nfsv4stateid_t
name|stateid
decl_stmt|;
name|void
modifier|*
name|lckp
decl_stmt|;
operator|*
name|must_commit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
name|newcred
operator|=
name|cred
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|newcred
operator|=
name|NFSNEWCRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|nfhp
operator|=
name|np
operator|->
name|n_fhp
expr_stmt|;
block|}
name|retrycnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|lckp
operator|=
name|NULL
expr_stmt|;
name|nostateid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|nfscl_getstateid
argument_list|(
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|NFSV4OPEN_ACCESSWRITE
argument_list|,
literal|0
argument_list|,
name|newcred
argument_list|,
name|p
argument_list|,
operator|&
name|stateid
argument_list|,
operator|&
name|lckp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stateid
operator|.
name|other
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|stateid
operator|.
name|other
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|stateid
operator|.
name|other
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|nostateid
operator|=
literal|1
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"stateid0 in write\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * If there is no stateid for NFSv4, it means this is an 		 * extraneous write after close. Basically a poorly 		 * implemented buffer cache. Just don't do the write. 		 */
if|if
condition|(
name|nostateid
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
name|error
operator|=
name|nfsrpc_writerpc
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|iomode
argument_list|,
name|must_commit
argument_list|,
name|newcred
argument_list|,
operator|&
name|stateid
argument_list|,
name|p
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lckp
operator|!=
name|NULL
condition|)
name|nfscl_lockderef
argument_list|(
name|lckp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_OLDSTATEID
operator|||
name|error
operator|==
name|NFSERR_BADSESSION
condition|)
block|{
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfs_write"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|clidrev
operator|!=
literal|0
condition|)
block|{
name|expireret
operator|=
name|nfscl_hasexpired
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|clidrev
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|retrycnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_BADSESSION
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|)
operator|&&
name|called_from_strategy
operator|==
literal|0
operator|)
operator|||
operator|(
name|error
operator|==
name|NFSERR_OLDSTATEID
operator|&&
name|retrycnt
operator|<
literal|20
operator|)
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|expireret
operator|==
literal|0
operator|&&
name|clidrev
operator|!=
literal|0
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
condition|)
do|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
operator|(
name|retrycnt
operator|>=
literal|4
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_BADSESSION
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|)
operator|&&
name|called_from_strategy
operator|!=
literal|0
operator|)
operator|)
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
name|NFSFREECRED
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The actual write RPC.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_writerpc
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
modifier|*
name|iomode
parameter_list|,
name|int
modifier|*
name|must_commit
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|tsiz
decl_stmt|,
name|rlen
decl_stmt|,
name|commit
decl_stmt|,
name|committed
init|=
name|NFSWRITE_FILESYNC
decl_stmt|;
name|int
name|wccflag
init|=
literal|0
decl_stmt|,
name|wsize
decl_stmt|;
name|int32_t
name|backup
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|off_t
name|tmp_off
decl_stmt|;
name|KASSERT
argument_list|(
name|uiop
operator|->
name|uio_iovcnt
operator|==
literal|1
argument_list|,
operator|(
literal|"nfs: writerpc iovcnt> 1"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|tsiz
operator|=
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|tmp_off
operator|=
name|uiop
operator|->
name|uio_offset
operator|+
name|tsiz
expr_stmt|;
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_off
operator|>
name|nmp
operator|->
name|nm_maxfilesize
operator|||
name|tmp_off
operator|<
name|uiop
operator|->
name|uio_offset
condition|)
block|{
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFBIG
operator|)
return|;
block|}
name|wsize
operator|=
name|nmp
operator|->
name|nm_wsize
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
comment|/* NFSv2 sometimes does a write with */
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
comment|/* uio_resid == 0, so the while is not done */
while|while
condition|(
name|tsiz
operator|>
literal|0
condition|)
block|{
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|len
operator|=
operator|(
name|tsiz
operator|>
name|wsize
operator|)
condition|?
name|wsize
else|:
name|tsiz
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_WRITE
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|nfsm_stateidtom
argument_list|(
name|nd
argument_list|,
name|stateidp
argument_list|,
name|NFSSTATEID_PUTSTATEID
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
operator|+
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|uiop
operator|->
name|uio_offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
operator|*
name|iomode
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
operator|+
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|uiop
operator|->
name|uio_offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
operator|*
name|iomode
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|x
decl_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
comment|/* 			 * Not sure why someone changed this, since the 			 * RFC clearly states that "beginoffset" and 			 * "totalcount" are ignored, but it wouldn't 			 * surprise me if there's a busted server out there. 			 */
comment|/* Set both "begin" and "current" to non-garbage. */
name|x
operator|=
name|txdr_unsigned
argument_list|(
operator|(
name|u_int32_t
operator|)
name|uiop
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|x
expr_stmt|;
comment|/* "begin offset" */
operator|*
name|tl
operator|++
operator|=
name|x
expr_stmt|;
comment|/* "current offset" */
name|x
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|x
expr_stmt|;
comment|/* total to this offset */
operator|*
name|tl
operator|=
name|x
expr_stmt|;
comment|/* size of this write */
block|}
name|nfsm_uiombuf
argument_list|(
name|nd
argument_list|,
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 		 * Although it is tempting to do a normal Getattr Op in the 		 * NFSv4 compound, the result can be a nearly hung client 		 * system if the Getattr asks for Owner and/or OwnerGroup. 		 * It occurs when the client can't map either the Owner or 		 * Owner_group name in the Getattr reply to a uid/gid. When 		 * there is a cache miss, the kernel does an upcall to the 		 * nfsuserd. Then, it can try and read the local /etc/passwd 		 * or /etc/group file. It can then block in getnewbuf(), 		 * waiting for dirty writes to be pushed to the NFS server. 		 * The only reason this doesn't result in a complete 		 * deadlock, is that the upcall times out and allows 		 * the write to complete. However, progress is so slow 		 * that it might just as well be deadlocked. 		 * As such, we get the rest of the attributes, but not 		 * Owner or Owner_group. 		 * nb: nfscl_loadattrcache() needs to be told that these 		 *     partial attributes from a write rpc are being 		 *     passed in, via a argument flag. 		 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSWRITEGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
comment|/* 			 * In case the rpc gets retried, roll 			 * the uio fileds changed by nfsm_uiombuf() 			 * back. 			 */
name|uiop
operator|->
name|uio_offset
operator|-=
name|len
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
operator|-
name|len
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
operator|&
name|wccflag
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
operator|+
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|NFSERR_IO
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
elseif|else
if|if
condition|(
name|rlen
operator|<
name|len
condition|)
block|{
name|backup
operator|=
name|len
operator|-
name|rlen
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|backup
operator|)
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|-=
name|backup
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|len
operator|=
name|rlen
expr_stmt|;
block|}
name|commit
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
comment|/* 				 * Return the lowest committment level 				 * obtained by any of the RPCs. 				 */
if|if
condition|(
name|committed
operator|==
name|NFSWRITE_FILESYNC
condition|)
name|committed
operator|=
name|commit
expr_stmt|;
elseif|else
if|if
condition|(
name|committed
operator|==
name|NFSWRITE_DATASYNC
operator|&&
name|commit
operator|==
name|NFSWRITE_UNSTABLE
condition|)
name|committed
operator|=
name|commit
expr_stmt|;
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSHASWRITEVERF
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
name|tl
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nmp
operator|->
name|nm_verf
index|[
literal|0
index|]
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|NFSSETWRITEVERF
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFSBCMP
argument_list|(
name|tl
argument_list|,
name|nmp
operator|->
name|nm_verf
argument_list|,
name|NFSX_VERF
argument_list|)
condition|)
block|{
operator|*
name|must_commit
operator|=
literal|1
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|tl
argument_list|,
name|nmp
operator|->
name|nm_verf
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
block|}
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV2
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|attrflagp
operator|=
name|NFS_LATTR_NOSHRINK
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|NFSWRITERPC_SETTIME
argument_list|(
name|wccflag
argument_list|,
name|np
argument_list|,
name|nap
argument_list|,
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
name|tsiz
operator|-=
name|len
expr_stmt|;
block|}
name|nfsmout
label|:
if|if
condition|(
name|nd
operator|->
name|nd_mrep
operator|!=
name|NULL
condition|)
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
operator|*
name|iomode
operator|=
name|committed
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs mknod rpc  * For NFS v2 this is a kludge. Use a create rpc but with the IFMT bits of the  * mode set to specify the file type and the size field for rdev.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_mknod
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|u_int32_t
name|rdev
parameter_list|,
name|enum
name|vtype
name|vtyp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nnap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
operator|*
name|nfhpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_MKNOD
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
if|if
condition|(
name|vtyp
operator|==
name|VBLK
operator|||
name|vtyp
operator|==
name|VCHR
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|vtonfsv34_type
argument_list|(
name|vtyp
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSMAJOR
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSMINOR
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|vtonfsv34_type
argument_list|(
name|vtyp
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|vtonfsv34_type
argument_list|(
name|vtyp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|&&
operator|(
name|vtyp
operator|==
name|VCHR
operator|||
name|vtyp
operator|==
name|VBLK
operator|)
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSMAJOR
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSMINOR
argument_list|(
name|rdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
condition|)
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
name|NFSSATTR_SIZERDEV
argument_list|,
name|rdev
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
name|error
operator|=
name|nfscl_mtofh
argument_list|(
name|nd
argument_list|,
name|nfhpp
argument_list|,
name|nnap
argument_list|,
name|attrflagp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs file create call  * Mostly just call the approriate routine. (I separated out v4, so that  * error recovery wouldn't be as difficult.)  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_create
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|nfsquad_t
name|cverf
parameter_list|,
name|int
name|fmode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nnap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|,
name|newone
decl_stmt|,
name|expireret
init|=
literal|0
decl_stmt|,
name|retrycnt
decl_stmt|,
name|unlocked
decl_stmt|;
name|struct
name|nfsclowner
modifier|*
name|owp
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|)
decl_stmt|;
name|u_int32_t
name|clidrev
decl_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|retrycnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|dp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|nfscl_open
argument_list|(
name|dvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|NFSV4OPEN_ACCESSWRITE
operator||
name|NFSV4OPEN_ACCESSREAD
operator|)
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|owp
argument_list|,
name|NULL
argument_list|,
operator|&
name|newone
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
else|else
name|clidrev
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|nfsrpc_createv4
argument_list|(
name|dvp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|vap
argument_list|,
name|cverf
argument_list|,
name|fmode
argument_list|,
name|owp
argument_list|,
operator|&
name|dp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|dnap
argument_list|,
name|nnap
argument_list|,
name|nfhpp
argument_list|,
name|attrflagp
argument_list|,
name|dattrflagp
argument_list|,
name|dstuff
argument_list|,
operator|&
name|unlocked
argument_list|)
expr_stmt|;
comment|/* 		 * There is no need to invalidate cached attributes here, 		 * since new post-delegation issue attributes are always 		 * returned by nfsrpc_createv4() and these will update the 		 * attribute cache. 		 */
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|nfscl_deleg
argument_list|(
name|nmp
operator|->
name|nm_mountp
argument_list|,
name|owp
operator|->
name|nfsow_clp
argument_list|,
operator|(
operator|*
name|nfhpp
operator|)
operator|->
name|nfh_fh
argument_list|,
operator|(
operator|*
name|nfhpp
operator|)
operator|->
name|nfh_len
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
operator|&
name|dp
argument_list|)
expr_stmt|;
name|nfscl_ownerrelease
argument_list|(
name|nmp
argument_list|,
name|owp
argument_list|,
name|error
argument_list|,
name|newone
argument_list|,
name|unlocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_BADSESSION
condition|)
block|{
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfs_open"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|clidrev
operator|!=
literal|0
condition|)
block|{
name|expireret
operator|=
name|nfscl_hasexpired
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|clidrev
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|retrycnt
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_BADSESSION
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|expireret
operator|==
literal|0
operator|&&
name|clidrev
operator|!=
literal|0
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
condition|)
do|;
if|if
condition|(
name|error
operator|&&
name|retrycnt
operator|>=
literal|4
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfsrpc_createv23
argument_list|(
name|dvp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|vap
argument_list|,
name|cverf
argument_list|,
name|fmode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|dnap
argument_list|,
name|nnap
argument_list|,
name|nfhpp
argument_list|,
name|attrflagp
argument_list|,
name|dattrflagp
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The create rpc for v2 and 3.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_createv23
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|nfsquad_t
name|cverf
parameter_list|,
name|int
name|fmode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nnap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
operator|*
name|nfhpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_CREATE
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmode
operator|&
name|O_EXCL
condition|)
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSCREATE_EXCLUSIVE
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cverf
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|cverf
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSCREATE_UNCHECKED
argument_list|)
expr_stmt|;
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
name|NFSSATTR_SIZE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|nfscl_mtofh
argument_list|(
name|nd
argument_list|,
name|nfhpp
argument_list|,
name|nnap
argument_list|,
name|attrflagp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfsrpc_createv4
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|nfsquad_t
name|cverf
parameter_list|,
name|int
name|fmode
parameter_list|,
name|struct
name|nfsclowner
modifier|*
name|owp
parameter_list|,
name|struct
name|nfscldeleg
modifier|*
modifier|*
name|dpp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nnap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|,
name|int
modifier|*
name|unlockedp
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|deleg
decl_stmt|,
name|newone
decl_stmt|,
name|ret
decl_stmt|,
name|acesize
decl_stmt|,
name|limitby
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsclopen
modifier|*
name|op
decl_stmt|;
name|struct
name|nfscldeleg
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|nfsv4stateid_t
name|stateid
decl_stmt|;
name|u_int32_t
name|rflags
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nfsclsession
modifier|*
name|tsep
decl_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|unlockedp
operator|=
literal|0
expr_stmt|;
operator|*
name|nfhpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_CREATE
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
comment|/* 	 * For V4, this is actually an Open op. 	 */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|owp
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_ACCESSWRITE
operator||
name|NFSV4OPEN_ACCESSREAD
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_DENYNONE
argument_list|)
expr_stmt|;
name|tsep
operator|=
name|nfsmnt_mdssession
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|owp
operator|->
name|nfsow_owner
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_CREATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmode
operator|&
name|O_EXCL
condition|)
block|{
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|NFSHASSESSPERSIST
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
comment|/* Use GUARDED for persistent sessions. */
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSCREATE_GUARDED
argument_list|)
expr_stmt|;
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, use EXCLUSIVE4_1. */
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSCREATE_EXCLUSIVE41
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cverf
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|cverf
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* NFSv4.0 */
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSCREATE_EXCLUSIVE
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cverf
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|cverf
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSCREATE_UNCHECKED
argument_list|)
expr_stmt|;
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OPEN_CLAIMNULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
comment|/* Get the new file's handle and attributes. */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
comment|/* Get the directory's post-op attributes. */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_PUTFH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NFSCL_INCRSEQID
argument_list|(
name|owp
operator|->
name|nfsow_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
literal|6
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
expr_stmt|;
name|rflags
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|6
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|deleg
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleg
operator|==
name|NFSV4OPEN_DELEGATEREAD
operator|||
name|deleg
operator|==
name|NFSV4OPEN_DELEGATEWRITE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|owp
operator|->
name|nfsow_clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_FIRSTDELEG
operator|)
condition|)
name|owp
operator|->
name|nfsow_clp
operator|->
name|nfsc_flags
operator||=
operator|(
name|NFSCLFLAGS_FIRSTDELEG
operator||
name|NFSCLFLAGS_GOTDELEG
operator|)
expr_stmt|;
name|MALLOC
argument_list|(
name|dp
argument_list|,
expr|struct
name|nfscldeleg
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfscldeleg
argument_list|)
operator|+
name|NFSX_V4FHMAX
argument_list|,
name|M_NFSCLDELEG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_owner
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_lock
argument_list|)
expr_stmt|;
name|dp
operator|->
name|nfsdl_clp
operator|=
name|owp
operator|->
name|nfsow_clp
expr_stmt|;
name|newnfs_copyincred
argument_list|(
name|cred
argument_list|,
operator|&
name|dp
operator|->
name|nfsdl_cred
argument_list|)
expr_stmt|;
name|nfscl_lockinit
argument_list|(
operator|&
name|dp
operator|->
name|nfsdl_rwlock
argument_list|)
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ret
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleg
operator|==
name|NFSV4OPEN_DELEGATEWRITE
condition|)
block|{
name|dp
operator|->
name|nfsdl_flags
operator|=
name|NFSCLDL_WRITE
expr_stmt|;
comment|/* 				 * Indicates how much the file can grow. 				 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|limitby
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|limitby
condition|)
block|{
case|case
name|NFSV4OPEN_LIMITSIZE
case|:
name|dp
operator|->
name|nfsdl_sizelimit
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
break|break;
case|case
name|NFSV4OPEN_LIMITBLOCKS
case|:
name|dp
operator|->
name|nfsdl_sizelimit
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int64_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|dp
operator|->
name|nfsdl_sizelimit
operator|*=
name|fxdr_unsigned
argument_list|(
name|u_int64_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
empty_stmt|;
block|}
else|else
block|{
name|dp
operator|->
name|nfsdl_flags
operator|=
name|NFSCLDL_READ
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
name|dp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_RECALL
expr_stmt|;
name|error
operator|=
name|nfsrv_dissectace
argument_list|(
name|nd
argument_list|,
operator|&
name|dp
operator|->
name|nfsdl_ace
argument_list|,
operator|&
name|ret
argument_list|,
operator|&
name|acesize
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
elseif|else
if|if
condition|(
name|deleg
operator|!=
name|NFSV4OPEN_DELEGATENONE
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|error
operator|=
name|nfscl_mtofh
argument_list|(
name|nd
argument_list|,
name|nfhpp
argument_list|,
name|nnap
argument_list|,
name|attrflagp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
comment|/* Get rid of the PutFH and Getattr status values. */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
comment|/* Load the directory attributes. */
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|dnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
operator|*
name|dattrflagp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
operator|&&
operator|*
name|attrflagp
condition|)
block|{
name|dp
operator|->
name|nfsdl_change
operator|=
name|nnap
operator|->
name|na_filerev
expr_stmt|;
name|dp
operator|->
name|nfsdl_modtime
operator|=
name|nnap
operator|->
name|na_mtime
expr_stmt|;
name|dp
operator|->
name|nfsdl_flags
operator||=
name|NFSCLDL_MODTIMESET
expr_stmt|;
block|}
comment|/* 		 * We can now complete the Open state. 		 */
name|nfhp
operator|=
operator|*
name|nfhpp
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|dp
operator|->
name|nfsdl_fhlen
operator|=
name|nfhp
operator|->
name|nfh_len
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|dp
operator|->
name|nfsdl_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Get an Open structure that will be 		 * attached to the OpenOwner, acquired already. 		 */
name|error
operator|=
name|nfscl_open
argument_list|(
name|dvp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
operator|(
name|NFSV4OPEN_ACCESSWRITE
operator||
name|NFSV4OPEN_ACCESSREAD
operator|)
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
operator|&
name|op
argument_list|,
operator|&
name|newone
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|op
operator|->
name|nfso_stateid
operator|=
name|stateid
expr_stmt|;
name|newnfs_copyincred
argument_list|(
name|cred
argument_list|,
operator|&
name|op
operator|->
name|nfso_cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rflags
operator|&
name|NFSV4OPEN_RESULTCONFIRM
operator|)
condition|)
block|{
do|do
block|{
name|ret
operator|=
name|nfsrpc_openconfirm
argument_list|(
name|dvp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|op
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|ret
argument_list|,
literal|"nfs_create"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
do|;
name|error
operator|=
name|ret
expr_stmt|;
block|}
comment|/* 		 * If the server is handing out delegations, but we didn't 		 * get one because an OpenConfirm was required, try the 		 * Open again, to get a delegation. This is a harmless no-op, 		 * from a server's point of view. 		 */
if|if
condition|(
operator|(
name|rflags
operator|&
name|NFSV4OPEN_RESULTCONFIRM
operator|)
operator|&&
operator|(
name|owp
operator|->
name|nfsow_clp
operator|->
name|nfsc_flags
operator|&
name|NFSCLFLAGS_GOTDELEG
operator|)
operator|&&
operator|!
name|error
operator|&&
name|dp
operator|==
name|NULL
condition|)
block|{
do|do
block|{
name|ret
operator|=
name|nfsrpc_openrpc
argument_list|(
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|)
argument_list|,
name|dvp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
operator|(
name|NFSV4OPEN_ACCESSWRITE
operator||
name|NFSV4OPEN_ACCESSREAD
operator|)
argument_list|,
name|op
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
operator|&
name|dp
argument_list|,
literal|0
argument_list|,
literal|0x0
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|ret
argument_list|,
literal|"nfs_crt2"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ret
operator|==
name|NFSERR_DELAY
condition|)
do|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|ret
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|ret
operator|==
name|NFSERR_BADSESSION
condition|)
name|error
operator|=
name|ret
expr_stmt|;
block|}
block|}
name|nfscl_openrelease
argument_list|(
name|nmp
argument_list|,
name|op
argument_list|,
name|error
argument_list|,
name|newone
argument_list|)
expr_stmt|;
operator|*
name|unlockedp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALECLIENTID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|owp
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|dpp
operator|=
name|dp
expr_stmt|;
elseif|else
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|dp
argument_list|,
name|M_NFSCLDELEG
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Nfs remove rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_remove
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|nfsv4stateid_t
name|dstateid
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|)
expr_stmt|;
name|tryagain
label|:
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|nfscl_removedeleg
argument_list|(
name|vp
argument_list|,
name|p
argument_list|,
operator|&
name|dstateid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RETDELEGREMOVE
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|dstateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dstateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dstateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dstateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_PUTFH
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_REMOVE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_REMOVE
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
comment|/* For NFSv4, parse out any Delereturn replies. */
if|if
condition|(
name|ret
operator|>
literal|0
operator|&&
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NOMOREDATA
operator|)
condition|)
block|{
comment|/* 			 * If the Delegreturn failed, try again without 			 * it. The server will Recall, as required. 			 */
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|ret
operator|*
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
block|}
block|}
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do an nfs rename rpc.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_rename
parameter_list|(
name|vnode_t
name|fdvp
parameter_list|,
name|vnode_t
name|fvp
parameter_list|,
name|char
modifier|*
name|fnameptr
parameter_list|,
name|int
name|fnamelen
parameter_list|,
name|vnode_t
name|tdvp
parameter_list|,
name|vnode_t
name|tvp
parameter_list|,
name|char
modifier|*
name|tnameptr
parameter_list|,
name|int
name|tnamelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|fnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|tnap
parameter_list|,
name|int
modifier|*
name|fattrflagp
parameter_list|,
name|int
modifier|*
name|tattrflagp
parameter_list|,
name|void
modifier|*
name|fstuff
parameter_list|,
name|void
modifier|*
name|tstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|nfsv4stateid_t
name|fdstateid
decl_stmt|,
name|tdstateid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|gottd
init|=
literal|0
decl_stmt|,
name|gotfd
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
operator|*
name|fattrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|tattrflagp
operator|=
literal|0
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|fdvp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnamelen
operator|>
name|NFS_MAXNAMLEN
operator|||
name|tnamelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|tryagain
label|:
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|&&
name|ret
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|nfscl_renamedeleg
argument_list|(
name|fvp
argument_list|,
operator|&
name|fdstateid
argument_list|,
operator|&
name|gotfd
argument_list|,
name|tvp
argument_list|,
operator|&
name|tdstateid
argument_list|,
operator|&
name|gottd
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotfd
operator|&&
name|gottd
condition|)
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RETDELEGRENAME2
argument_list|,
name|fvp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gotfd
condition|)
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RETDELEGRENAME1
argument_list|,
name|fvp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gottd
condition|)
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RETDELEGRENAME1
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gotfd
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|fdstateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|fdstateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|fdstateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|fdstateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|gottd
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_PUTFH
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_DELEGRETURN
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gottd
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|tdstateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tdstateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tdstateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|tdstateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_PUTFH
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_SAVEFH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RENAME
argument_list|,
name|fdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSWCCATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_PUTFH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_V4WCCATTR
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_RENAME
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|fnameptr
argument_list|,
name|fnamelen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
condition|)
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|tnameptr
argument_list|,
name|tnamelen
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|fdvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|fstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
comment|/* For NFSv4, parse out any Delereturn replies. */
if|if
condition|(
name|ret
operator|>
literal|0
operator|&&
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NOMOREDATA
operator|)
condition|)
block|{
comment|/* 			 * If the Delegreturn failed, try again without 			 * it. The server will Recall, as required. 			 */
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|ret
operator|*
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|ret
operator|>
literal|1
condition|)
block|{
comment|/* 				     * If the Delegreturn failed, try again 				     * without it. The server will Recall, as 				     * required. 				     * If ret> 1, the first iteration of this 				     * loop is the second DelegReturn result. 				     */
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
else|else
block|{
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Now, the first wcc attribute reply. */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|fdvp
argument_list|,
name|fnap
argument_list|,
name|fattrflagp
argument_list|,
name|NULL
argument_list|,
name|fstuff
argument_list|)
expr_stmt|;
comment|/* and the second wcc attribute reply. */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
operator|&&
operator|!
name|error
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|tdvp
argument_list|,
name|tnap
argument_list|,
name|tattrflagp
argument_list|,
name|NULL
argument_list|,
name|tstuff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs hard link create rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_link
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LINK
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_PUTFH
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSWCCATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_V4WCCATTR
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_LINK
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_NOMOREDATA
operator|)
operator|)
operator|==
name|ND_NFSV4
condition|)
block|{
comment|/* 		 * First, parse out the PutFH and Getattr result. 		 */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
operator|)
condition|)
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|tl
operator|+
literal|1
operator|)
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NOMOREDATA
expr_stmt|;
comment|/* 		 * Get the pre-op attributes. 		 */
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs symbolic link create rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_symlink
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nnap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|int
name|slen
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
operator|*
name|nfhpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|)
expr_stmt|;
name|slen
operator|=
name|strlen
argument_list|(
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|>
name|NFS_MAXPATHLEN
operator|||
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_SYMLINK
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFLNK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|target
argument_list|,
name|slen
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
condition|)
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|target
argument_list|,
name|slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
condition|)
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
name|NFSSATTR_SIZENEG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|&&
operator|!
name|error
condition|)
block|{
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nfscl_mtofh
argument_list|(
name|nd
argument_list|,
name|nfhpp
argument_list|,
name|nnap
argument_list|,
name|attrflagp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
comment|/* 	 * Kludge: Map EEXIST => 0 assuming that it is a reply to a retry. 	 * Only do this if vfs.nfs.ignore_eexist is set. 	 * Never do this for NFSv4.1 or later minor versions, since sessions 	 * should guarantee "exactly once" RPC semantics. 	 */
if|if
condition|(
name|error
operator|==
name|EEXIST
operator|&&
name|nfsignore_eexist
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|||
name|nmp
operator|->
name|nm_minorvers
operator|==
literal|0
operator|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs make dir rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_mkdir
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nnap
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|fhp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
operator|*
name|nfhpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|)
expr_stmt|;
name|fhp
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
operator|->
name|n_fhp
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_MKDIR
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFDIR
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|nfscl_fillsattr
argument_list|(
name|nd
argument_list|,
name|vap
argument_list|,
name|dvp
argument_list|,
name|NFSSATTR_SIZENEG1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_PUTFH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|fhp
operator|->
name|nfh_fh
argument_list|,
name|fhp
operator|->
name|nfh_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_mtofh
argument_list|(
name|nd
argument_list|,
name|nfhpp
argument_list|,
name|nnap
argument_list|,
name|attrflagp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Get rid of the PutFH and Getattr status values. */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
comment|/* Load the directory attributes. */
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|dnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|dattrflagp
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
comment|/* 	 * Kludge: Map EEXIST => 0 assuming that it is a reply to a retry. 	 * Only do this if vfs.nfs.ignore_eexist is set. 	 * Never do this for NFSv4.1 or later minor versions, since sessions 	 * should guarantee "exactly once" RPC semantics. 	 */
if|if
condition|(
name|error
operator|==
name|EEXIST
operator|&&
name|nfsignore_eexist
operator|!=
literal|0
operator|&&
operator|(
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|||
name|nmp
operator|->
name|nm_minorvers
operator|==
literal|0
operator|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs remove directory call  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_rmdir
parameter_list|(
name|vnode_t
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|dnap
parameter_list|,
name|int
modifier|*
name|dattrflagp
parameter_list|,
name|void
modifier|*
name|dstuff
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
operator|*
name|dattrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
name|NFS_MAXNAMLEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RMDIR
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|dvp
argument_list|,
name|dnap
argument_list|,
name|dattrflagp
argument_list|,
name|NULL
argument_list|,
name|dstuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
comment|/* 	 * Kludge: Map ENOENT => 0 assuming that you have a reply to a retry. 	 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Readdir rpc.  * Always returns with either uio_resid unchanged, if you are at the  * end of the directory, or uio_resid == 0, with all DIRBLKSIZ chunks  * filled in.  * I felt this would allow caching of directory blocks more easily  * than returning a pertially filled block.  * Directory offset cookies:  * Oh my, what to do with them...  * I can think of three ways to deal with them:  * 1 - have the layer above these RPCs maintain a map between logical  *     directory byte offsets and the NFS directory offset cookies  * 2 - pass the opaque directory offset cookies up into userland  *     and let the libc functions deal with them, via the system call  * 3 - return them to userland in the "struct dirent", so future versions  *     of libc can use them and do whatever is necessary to amke things work  *     above these rpc calls, in the meantime  * For now, I do #3 by "hiding" the directory offset cookies after the  * d_name field in struct dirent. This is space inside d_reclen that  * will be ignored by anything that doesn't know about them.  * The directory offset cookies are filled in as the last 8 bytes of  * each directory entry, after d_name. Someday, the userland libc  * functions may be able to use these. In the meantime, it satisfies  * OpenBSD's requirements for cookies being returned.  * If expects the directory offset cookie for the read to be in uio_offset  * and returns the one for the next entry after this directory block in  * there, as well.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_readdir
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|nfsuint64
modifier|*
name|cookiep
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|left
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|nfsquad_t
name|cookie
decl_stmt|,
name|ncookie
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|dnp
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|tlen
decl_stmt|,
name|more_dirs
init|=
literal|1
decl_stmt|,
name|blksiz
init|=
literal|0
decl_stmt|,
name|bigenough
init|=
literal|1
decl_stmt|;
name|int
name|reqsize
decl_stmt|,
name|tryformoredirs
init|=
literal|1
decl_stmt|,
name|readsize
decl_stmt|,
name|eof
init|=
literal|0
decl_stmt|,
name|gotmnton
init|=
literal|0
decl_stmt|;
name|long
name|dotfileid
decl_stmt|,
name|dotdotfileid
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|fakefileno
init|=
literal|0xffffffff
decl_stmt|,
name|rderr
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|,
name|dattrbits
decl_stmt|;
name|u_int32_t
modifier|*
name|tl2
init|=
name|NULL
decl_stmt|;
name|size_t
name|tresid
decl_stmt|;
name|KASSERT
argument_list|(
name|uiop
operator|->
name|uio_iovcnt
operator|==
literal|1
operator|&&
operator|(
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"nfs readdirrpc bad uio"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * There is no point in reading a lot more than uio_resid, however 	 * adding one additional DIRBLKSIZ makes sense. Since uio_resid 	 * and nm_readdirsize are both exact multiples of DIRBLKSIZ, this 	 * will never make readsize> nm_readdirsize. 	 */
name|readsize
operator|=
name|nmp
operator|->
name|nm_readdirsize
expr_stmt|;
if|if
condition|(
name|readsize
operator|>
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
condition|)
name|readsize
operator|=
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
operator|+
name|DIRBLKSIZ
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|0
expr_stmt|;
name|tresid
operator|=
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|0
index|]
expr_stmt|;
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|1
index|]
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * For NFSv4, first create the "." and ".." entries. 	 */
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|reqsize
operator|=
literal|6
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|dattrbits
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_FILEID
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
operator|&
name|dnp
operator|->
name|n_vattr
operator|.
name|na_suppattr
argument_list|,
name|NFSATTRBIT_MOUNTEDONFILEID
argument_list|)
condition|)
block|{
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_MOUNTEDONFILEID
argument_list|)
expr_stmt|;
name|gotmnton
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Must fake it. Use the fileno, except when the 			 * fsid is != to that of the directory. For that 			 * case, generate a fake fileno that is not the same. 			 */
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_FSID
argument_list|)
expr_stmt|;
name|gotmnton
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Joy, oh joy. For V4 we get to hand craft '.' and '..'. 		 */
if|if
condition|(
name|uiop
operator|->
name|uio_offset
operator|==
literal|0
condition|)
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOOKUPP
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dotfileid
operator|=
literal|0
expr_stmt|;
comment|/* Fake out the compiler. */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NOMOREDATA
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
operator|&
name|nfsva
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|nfsmout
goto|;
name|dotfileid
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<=
name|NFSX_V4FHMAX
condition|)
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EPERM
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfsva
operator|.
name|na_mntonfileno
operator|=
literal|0xffffffff
expr_stmt|;
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dotdotfileid
operator|=
name|dotfileid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gotmnton
condition|)
block|{
if|if
condition|(
name|nfsva
operator|.
name|na_mntonfileno
operator|!=
literal|0xffffffff
condition|)
name|dotdotfileid
operator|=
name|nfsva
operator|.
name|na_mntonfileno
expr_stmt|;
else|else
name|dotdotfileid
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfsva
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|&&
name|nfsva
operator|.
name|na_filesid
index|[
literal|1
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|1
index|]
condition|)
block|{
name|dotdotfileid
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|fakefileno
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|fakefileno
operator|==
name|nfsva
operator|.
name|na_fileid
condition|)
do|;
name|dotdotfileid
operator|=
name|fakefileno
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_NOENT
condition|)
block|{
comment|/* 			     * Lookupp returns NFSERR_NOENT when we are 			     * at the root, so just use the current dir. 			     */
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
name|dotdotfileid
operator|=
name|dotfileid
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
block|}
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|CAST_DOWN
argument_list|(
name|caddr_t
argument_list|,
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
name|dotfileid
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
literal|1
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRENT_SIZE
argument_list|(
name|dp
argument_list|)
operator|+
name|NFSX_HYPER
expr_stmt|;
comment|/* 			 * Just make these offset cookie 0. 			 */
name|tl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|d_name
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|dp
operator|->
name|d_reclen
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|CAST_DOWN
argument_list|(
name|caddr_t
argument_list|,
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
name|dotdotfileid
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
literal|2
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRENT_SIZE
argument_list|(
name|dp
argument_list|)
operator|+
name|NFSX_HYPER
expr_stmt|;
comment|/* 			 * Just make these offset cookie 0. 			 */
name|tl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|d_name
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|dp
operator|->
name|d_reclen
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
block|}
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_RDATTRERROR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reqsize
operator|=
literal|5
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
block|}
comment|/* 	 * Loop around doing readdir rpc's of size readsize. 	 * The stopping criteria is EOF or buffer full. 	 */
while|while
condition|(
name|more_dirs
operator|&&
name|bigenough
condition|)
block|{
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_READDIR
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|readsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|reqsize
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|qval
operator|==
literal|0
condition|)
block|{
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|NFSLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|1
index|]
expr_stmt|;
name|NFSUNLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|readsize
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|readsize
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|dattrbits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|readsize
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
operator|)
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|NFSLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|1
index|]
operator|=
operator|*
name|tl
expr_stmt|;
name|NFSUNLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|||
name|error
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|more_dirs
condition|)
name|tryformoredirs
operator|=
literal|0
expr_stmt|;
comment|/* loop thru the dir entries, doctoring them to 4bsd form */
while|while
condition|(
name|more_dirs
operator|&&
name|bigenough
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfsva
operator|.
name|na_fileid
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfsva
operator|.
name|na_fileid
operator|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|tlen
operator|=
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|==
name|len
condition|)
name|tlen
operator|+=
literal|4
expr_stmt|;
comment|/* To ensure null termination */
name|left
operator|=
name|DIRBLKSIZ
operator|-
name|blksiz
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|tlen
operator|+
name|DIRHDSIZ
operator|+
name|NFSX_HYPER
argument_list|)
operator|>
name|left
condition|)
block|{
name|dp
operator|->
name|d_reclen
operator|+=
name|left
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|left
expr_stmt|;
name|blksiz
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|tlen
operator|+
name|DIRHDSIZ
operator|+
name|NFSX_HYPER
argument_list|)
operator|>
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
condition|)
name|bigenough
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bigenough
condition|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|CAST_DOWN
argument_list|(
name|caddr_t
argument_list|,
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
name|len
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|tlen
operator|+
name|DIRHDSIZ
operator|+
name|NFSX_HYPER
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|blksiz
operator|==
name|DIRBLKSIZ
condition|)
name|blksiz
operator|=
literal|0
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRHDSIZ
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|DIRHDSIZ
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|DIRHDSIZ
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRHDSIZ
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsm_mbufuio
argument_list|(
name|nd
argument_list|,
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|cp
operator|=
name|CAST_DOWN
argument_list|(
name|caddr_t
argument_list|,
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
argument_list|)
expr_stmt|;
name|tlen
operator|-=
name|len
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate */
name|cp
operator|+=
name|tlen
expr_stmt|;
comment|/* points to cookie storage */
name|tl2
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|cp
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|rderr
operator|=
literal|0
expr_stmt|;
name|nfsva
operator|.
name|na_mntonfileno
operator|=
literal|0xffffffff
expr_stmt|;
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rderr
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
block|}
else|else
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bigenough
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
if|if
condition|(
name|rderr
condition|)
block|{
name|dp
operator|->
name|d_fileno
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gotmnton
condition|)
block|{
if|if
condition|(
name|nfsva
operator|.
name|na_mntonfileno
operator|!=
literal|0xffffffff
condition|)
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_mntonfileno
expr_stmt|;
else|else
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfsva
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|&&
name|nfsva
operator|.
name|na_filesid
index|[
literal|1
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|1
index|]
condition|)
block|{
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|fakefileno
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|fakefileno
operator|==
name|nfsva
operator|.
name|na_fileid
condition|)
do|;
name|dp
operator|->
name|d_fileno
operator|=
name|fakefileno
expr_stmt|;
block|}
name|dp
operator|->
name|d_type
operator|=
name|vtonfs_dtype
argument_list|(
name|nfsva
operator|.
name|na_type
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
operator|*
name|tl2
operator|++
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|0
index|]
operator|=
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl2
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|1
index|]
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
block|}
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If at end of rpc data, get the eof boolean 		 */
if|if
condition|(
operator|!
name|more_dirs
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|eof
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tryformoredirs
condition|)
name|more_dirs
operator|=
operator|!
name|eof
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
block|}
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Fill last record, iff any, out to a multiple of DIRBLKSIZ 	 * by increasing d_reclen for the last record. 	 */
if|if
condition|(
name|blksiz
operator|>
literal|0
condition|)
block|{
name|left
operator|=
name|DIRBLKSIZ
operator|-
name|blksiz
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|+=
name|left
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|left
expr_stmt|;
block|}
comment|/* 	 * If returning no data, assume end of file. 	 * If not bigenough, return not end of file, since you aren't 	 *    returning all the data 	 * Otherwise, return the eof flag from the server. 	 */
if|if
condition|(
name|eofp
condition|)
block|{
if|if
condition|(
name|tresid
operator|==
operator|(
call|(
name|size_t
call|)
argument_list|(
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
argument_list|)
operator|)
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|bigenough
condition|)
operator|*
name|eofp
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|eofp
operator|=
name|eof
expr_stmt|;
block|}
comment|/* 	 * Add extra empty records to any remaining DIRBLKSIZ chunks. 	 */
while|while
condition|(
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
operator|>
literal|0
operator|&&
operator|(
call|(
name|size_t
call|)
argument_list|(
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
argument_list|)
operator|)
operator|!=
name|tresid
condition|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|CAST_DOWN
argument_list|(
name|caddr_t
argument_list|,
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|d_name
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRBLKSIZ
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|DIRBLKSIZ
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRBLKSIZ
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRBLKSIZ
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|DIRBLKSIZ
expr_stmt|;
block|}
name|nfsmout
label|:
if|if
condition|(
name|nd
operator|->
name|nd_mrep
operator|!=
name|NULL
condition|)
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|APPLE
end_ifndef

begin_comment
comment|/*  * NFS V3 readdir plus RPC. Used in place of nfsrpc_readdir().  * (Also used for NFS V4 when mount flag set.)  * (ditto above w.r.t. multiple of DIRBLKSIZ, etc.)  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_readdirplus
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|nfsuint64
modifier|*
name|cookiep
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|left
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|vnode_t
name|newvp
init|=
name|NULLVP
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nameidata
name|nami
decl_stmt|,
modifier|*
name|ndp
init|=
operator|&
name|nami
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
operator|&
name|ndp
operator|->
name|ni_cnd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|dnp
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|nfsquad_t
name|cookie
decl_stmt|,
name|ncookie
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|tlen
decl_stmt|,
name|more_dirs
init|=
literal|1
decl_stmt|,
name|blksiz
init|=
literal|0
decl_stmt|,
name|bigenough
init|=
literal|1
decl_stmt|;
name|int
name|attrflag
decl_stmt|,
name|tryformoredirs
init|=
literal|1
decl_stmt|,
name|eof
init|=
literal|0
decl_stmt|,
name|gotmnton
init|=
literal|0
decl_stmt|;
name|int
name|isdotdot
init|=
literal|0
decl_stmt|,
name|unlocknewvp
init|=
literal|0
decl_stmt|;
name|long
name|dotfileid
decl_stmt|,
name|dotdotfileid
init|=
literal|0
decl_stmt|,
name|fileno
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|,
name|dattrbits
decl_stmt|;
name|size_t
name|tresid
decl_stmt|;
name|u_int32_t
modifier|*
name|tl2
init|=
name|NULL
decl_stmt|,
name|fakefileno
init|=
literal|0xffffffff
decl_stmt|,
name|rderr
decl_stmt|;
name|struct
name|timespec
name|dctime
decl_stmt|;
name|KASSERT
argument_list|(
name|uiop
operator|->
name|uio_iovcnt
operator|==
literal|1
operator|&&
operator|(
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"nfs readdirplusrpc bad uio"
operator|)
argument_list|)
expr_stmt|;
name|timespecclear
argument_list|(
operator|&
name|dctime
argument_list|)
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eofp
operator|!=
name|NULL
condition|)
operator|*
name|eofp
operator|=
literal|0
expr_stmt|;
name|ndp
operator|->
name|ni_dvp
operator|=
name|vp
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|0
index|]
expr_stmt|;
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|1
index|]
expr_stmt|;
name|tresid
operator|=
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
comment|/* 	 * For NFSv4, first create the "." and ".." entries. 	 */
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|dattrbits
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_FILEID
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
operator|&
name|dnp
operator|->
name|n_vattr
operator|.
name|na_suppattr
argument_list|,
name|NFSATTRBIT_MOUNTEDONFILEID
argument_list|)
condition|)
block|{
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_MOUNTEDONFILEID
argument_list|)
expr_stmt|;
name|gotmnton
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Must fake it. Use the fileno, except when the 			 * fsid is != to that of the directory. For that 			 * case, generate a fake fileno that is not the same. 			 */
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_FSID
argument_list|)
expr_stmt|;
name|gotmnton
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Joy, oh joy. For V4 we get to hand craft '.' and '..'. 		 */
if|if
condition|(
name|uiop
operator|->
name|uio_offset
operator|==
literal|0
condition|)
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOOKUPP
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dotfileid
operator|=
literal|0
expr_stmt|;
comment|/* Fake out the compiler. */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NOMOREDATA
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
operator|&
name|nfsva
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|nfsmout
goto|;
name|dctime
operator|=
name|nfsva
operator|.
name|na_ctime
expr_stmt|;
name|dotfileid
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<=
name|NFSX_V4FHMAX
condition|)
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EPERM
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfsva
operator|.
name|na_mntonfileno
operator|=
literal|0xffffffff
expr_stmt|;
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dotdotfileid
operator|=
name|dotfileid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gotmnton
condition|)
block|{
if|if
condition|(
name|nfsva
operator|.
name|na_mntonfileno
operator|!=
literal|0xffffffff
condition|)
name|dotdotfileid
operator|=
name|nfsva
operator|.
name|na_mntonfileno
expr_stmt|;
else|else
name|dotdotfileid
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfsva
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|&&
name|nfsva
operator|.
name|na_filesid
index|[
literal|1
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|1
index|]
condition|)
block|{
name|dotdotfileid
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|fakefileno
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|fakefileno
operator|==
name|nfsva
operator|.
name|na_fileid
condition|)
do|;
name|dotdotfileid
operator|=
name|fakefileno
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_NOENT
condition|)
block|{
comment|/* 			     * Lookupp returns NFSERR_NOENT when we are 			     * at the root, so just use the current dir. 			     */
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
name|dotdotfileid
operator|=
name|dotfileid
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
block|}
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
name|dotfileid
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
literal|1
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRENT_SIZE
argument_list|(
name|dp
argument_list|)
operator|+
name|NFSX_HYPER
expr_stmt|;
comment|/* 			 * Just make these offset cookie 0. 			 */
name|tl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|d_name
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|dp
operator|->
name|d_reclen
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
name|dotdotfileid
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
literal|2
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRENT_SIZE
argument_list|(
name|dp
argument_list|)
operator|+
name|NFSX_HYPER
expr_stmt|;
comment|/* 			 * Just make these offset cookie 0. 			 */
name|tl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|d_name
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|dp
operator|->
name|d_reclen
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|dp
operator|->
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
block|}
name|NFSREADDIRPLUS_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotmnton
condition|)
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_MOUNTEDONFILEID
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Loop around doing readdir rpc's of size nm_readdirsize. 	 * The stopping criteria is EOF or buffer full. 	 */
while|while
condition|(
name|more_dirs
operator|&&
name|bigenough
condition|)
block|{
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_READDIRPLUS
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|6
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cookie
operator|.
name|qval
operator|==
literal|0
condition|)
block|{
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|NFSLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|1
index|]
expr_stmt|;
name|NFSUNLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|nmp
operator|->
name|nm_readdirsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|dattrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|||
name|error
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|!=
literal|0
operator|&&
operator|*
name|attrflagp
operator|!=
literal|0
condition|)
name|dctime
operator|=
name|nap
operator|->
name|na_ctime
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|NFSLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dnp
operator|->
name|n_cookieverf
operator|.
name|nfsuquad
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|NFSUNLOCKNODE
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|more_dirs
condition|)
name|tryformoredirs
operator|=
literal|0
expr_stmt|;
comment|/* loop thru the dir entries, doctoring them to 4bsd form */
while|while
condition|(
name|more_dirs
operator|&&
name|bigenough
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
block|}
else|else
block|{
name|fileno
operator|=
name|fxdr_unsigned
argument_list|(
name|long
argument_list|,
operator|*
operator|++
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|++
expr_stmt|;
block|}
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|tlen
operator|=
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|==
name|len
condition|)
name|tlen
operator|+=
literal|4
expr_stmt|;
comment|/* To ensure null termination */
name|left
operator|=
name|DIRBLKSIZ
operator|-
name|blksiz
expr_stmt|;
if|if
condition|(
operator|(
name|tlen
operator|+
name|DIRHDSIZ
operator|+
name|NFSX_HYPER
operator|)
operator|>
name|left
condition|)
block|{
name|dp
operator|->
name|d_reclen
operator|+=
name|left
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|left
expr_stmt|;
name|blksiz
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tlen
operator|+
name|DIRHDSIZ
operator|+
name|NFSX_HYPER
operator|)
operator|>
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
condition|)
name|bigenough
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bigenough
condition|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
name|len
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|tlen
operator|+
name|DIRHDSIZ
operator|+
name|NFSX_HYPER
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|blksiz
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|blksiz
operator|==
name|DIRBLKSIZ
condition|)
name|blksiz
operator|=
literal|0
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRHDSIZ
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|DIRHDSIZ
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|DIRHDSIZ
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRHDSIZ
operator|)
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_nameptr
operator|=
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_namelen
operator|=
name|len
expr_stmt|;
name|NFSCNHASHZERO
argument_list|(
name|cnp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsm_mbufuio
argument_list|(
name|nd
argument_list|,
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|cp
operator|=
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|tlen
operator|-=
name|len
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|+=
name|tlen
expr_stmt|;
comment|/* points to cookie storage */
name|tl2
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|cnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|cnp
operator|->
name|cn_nameptr
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
name|isdotdot
operator|=
literal|1
expr_stmt|;
else|else
name|isdotdot
operator|=
literal|0
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
operator|(
name|tlen
operator|+
name|NFSX_HYPER
operator|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
name|nfhp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|attrflag
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
block|{
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
operator|&
name|nfsva
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
condition|)
block|{
name|error
operator|=
name|nfsm_getfh
argument_list|(
name|nd
argument_list|,
operator|&
name|nfhp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
operator|!
name|attrflag
operator|&&
name|nfhp
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
name|nfhp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|rderr
operator|=
literal|0
expr_stmt|;
name|nfsva
operator|.
name|na_mntonfileno
operator|=
literal|0xffffffff
expr_stmt|;
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|nfhp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rderr
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|bigenough
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
if|if
condition|(
name|rderr
condition|)
block|{
name|dp
operator|->
name|d_fileno
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gotmnton
condition|)
block|{
if|if
condition|(
name|nfsva
operator|.
name|na_mntonfileno
operator|!=
literal|0xffffffff
condition|)
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_mntonfileno
expr_stmt|;
else|else
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfsva
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|0
index|]
operator|&&
name|nfsva
operator|.
name|na_filesid
index|[
literal|1
index|]
operator|==
name|dnp
operator|->
name|n_vattr
operator|.
name|na_filesid
index|[
literal|1
index|]
condition|)
block|{
name|dp
operator|->
name|d_fileno
operator|=
name|nfsva
operator|.
name|na_fileid
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|fakefileno
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|fakefileno
operator|==
name|nfsva
operator|.
name|na_fileid
condition|)
do|;
name|dp
operator|->
name|d_fileno
operator|=
name|fakefileno
expr_stmt|;
block|}
block|}
else|else
block|{
name|dp
operator|->
name|d_fileno
operator|=
name|fileno
expr_stmt|;
block|}
operator|*
name|tl2
operator|++
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|0
index|]
operator|=
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|ncookie
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl2
operator|=
name|cookiep
operator|->
name|nfsuquad
index|[
literal|1
index|]
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
operator|=
name|ncookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|nfhp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|NFSRV_CMPFH
argument_list|(
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
condition|)
block|{
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|vp
expr_stmt|;
name|unlocknewvp
operator|=
literal|0
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
name|np
operator|=
name|dnp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdotdot
operator|!=
literal|0
condition|)
block|{
comment|/* 				     * Skip doing a nfscl_nget() call for "..". 				     * There's a race between acquiring the nfs 				     * node here and lookups that look for the 				     * directory being read (in the parent). 				     * It would try to get a lock on ".." here, 				     * owning the lock on the directory being 				     * read. Lookup will hold the lock on ".." 				     * and try to acquire the lock on the 				     * directory being read. 				     * If the directory is unlocked/relocked, 				     * then there is a LOR with the buflock 				     * vp is relocked. 				     */
name|free
argument_list|(
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfscl_nget
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|,
name|vp
argument_list|,
name|nfhp
argument_list|,
name|cnp
argument_list|,
name|p
argument_list|,
operator|&
name|np
argument_list|,
name|NULL
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|unlocknewvp
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|nfhp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|newvp
operator|!=
name|NULLVP
condition|)
block|{
name|error
operator|=
name|nfscl_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|unlocknewvp
condition|)
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|dp
operator|->
name|d_type
operator|=
name|vtonfs_dtype
argument_list|(
name|np
operator|->
name|n_vattr
operator|.
name|na_type
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_vp
operator|=
name|newvp
expr_stmt|;
name|NFSCNHASH
argument_list|(
name|cnp
argument_list|,
name|HASHINIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_namelen
operator|<=
name|NCHNAMLEN
operator|&&
operator|(
name|newvp
operator|->
name|v_type
operator|!=
name|VDIR
operator|||
name|dctime
operator|.
name|tv_sec
operator|!=
literal|0
operator|)
condition|)
block|{
name|cache_enter_time
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
name|ndp
operator|->
name|ni_vp
argument_list|,
name|cnp
argument_list|,
operator|&
name|nfsva
operator|.
name|na_ctime
argument_list|,
name|newvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|?
name|NULL
else|:
operator|&
name|dctime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unlocknewvp
condition|)
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|NULLVP
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|nfhp
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|more_dirs
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If at end of rpc data, get the eof boolean 		 */
if|if
condition|(
operator|!
name|more_dirs
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|eof
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tryformoredirs
condition|)
name|more_dirs
operator|=
operator|!
name|eof
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
block|}
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Fill last record, iff any, out to a multiple of DIRBLKSIZ 	 * by increasing d_reclen for the last record. 	 */
if|if
condition|(
name|blksiz
operator|>
literal|0
condition|)
block|{
name|left
operator|=
name|DIRBLKSIZ
operator|-
name|blksiz
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|+=
name|left
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|left
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|left
expr_stmt|;
block|}
comment|/* 	 * If returning no data, assume end of file. 	 * If not bigenough, return not end of file, since you aren't 	 *    returning all the data 	 * Otherwise, return the eof flag from the server. 	 */
if|if
condition|(
name|eofp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tresid
operator|==
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|bigenough
condition|)
operator|*
name|eofp
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|eofp
operator|=
name|eof
expr_stmt|;
block|}
comment|/* 	 * Add extra empty records to any remaining DIRBLKSIZ chunks. 	 */
while|while
condition|(
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
operator|>
literal|0
operator|&&
name|uio_uio_resid
argument_list|(
name|uiop
argument_list|)
operator|!=
name|tresid
condition|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|uio_iov_base
argument_list|(
name|uiop
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|dp
operator|->
name|d_fileno
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_namlen
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tl
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|dp
operator|->
name|d_name
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|cookie
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|cookie
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
name|DIRBLKSIZ
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
name|DIRBLKSIZ
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRBLKSIZ
operator|)
argument_list|)
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|DIRBLKSIZ
operator|)
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|DIRBLKSIZ
expr_stmt|;
block|}
name|nfsmout
label|:
if|if
condition|(
name|nd
operator|->
name|nd_mrep
operator|!=
name|NULL
condition|)
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APPLE */
end_comment

begin_comment
comment|/*  * Nfs commit rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_commit
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_quad_t
name|offset
parameter_list|,
name|int
name|cnt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_COMMIT
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
comment|/* 		 * And do a Getattr op. 		 */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfscl_wcc_data
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|NULL
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSBCMP
argument_list|(
name|nmp
operator|->
name|nm_verf
argument_list|,
name|tl
argument_list|,
name|NFSX_VERF
argument_list|)
condition|)
block|{
name|NFSBCOPY
argument_list|(
name|tl
argument_list|,
name|nmp
operator|->
name|nm_verf
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_STALEWRITEVERF
expr_stmt|;
block|}
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
block|}
name|nfsmout
label|:
if|if
condition|(
operator|!
name|error
operator|&&
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NFS byte range lock rpc.  * (Mostly just calls one of the three lower level RPC routines.)  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_advlock
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|off_t
name|size
parameter_list|,
name|int
name|op
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|reclaim
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|id
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|nfscllockowner
modifier|*
name|lp
decl_stmt|;
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|u_int64_t
name|off
decl_stmt|,
name|len
decl_stmt|;
name|off_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|u_int32_t
name|clidrev
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|newone
init|=
literal|0
decl_stmt|,
name|expireret
init|=
literal|0
decl_stmt|,
name|retrycnt
decl_stmt|,
name|donelocally
decl_stmt|;
name|int
name|callcnt
decl_stmt|,
name|dorpc
decl_stmt|;
comment|/* 	 * Convert the flock structure into a start and end and do POSIX 	 * bounds checking. 	 */
switch|switch
condition|(
name|fl
operator|->
name|l_whence
condition|)
block|{
case|case
name|SEEK_SET
case|:
case|case
name|SEEK_CUR
case|:
comment|/* 		 * Caller is responsible for adding any necessary offset 		 * when SEEK_CUR is used. 		 */
name|start
operator|=
name|fl
operator|->
name|l_start
expr_stmt|;
name|off
operator|=
name|fl
operator|->
name|l_start
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
name|start
operator|=
name|size
operator|+
name|fl
operator|->
name|l_start
expr_stmt|;
name|off
operator|=
name|size
operator|+
name|fl
operator|->
name|l_start
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
empty_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|fl
operator|->
name|l_len
operator|!=
literal|0
condition|)
block|{
name|end
operator|=
name|start
operator|+
name|fl
operator|->
name|l_len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|end
operator|<
name|start
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|len
operator|=
name|fl
operator|->
name|l_len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|NFS64BITSSET
expr_stmt|;
name|retrycnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|F_GETLK
condition|)
block|{
name|error
operator|=
name|nfscl_getcl
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
operator|&
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfscl_lockt
argument_list|(
name|vp
argument_list|,
name|clp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|fl
argument_list|,
name|p
argument_list|,
name|id
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|clidrev
operator|=
name|clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
name|error
operator|=
name|nfsrpc_lockt
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|clp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|fl
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|id
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|nfscl_clientrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|F_UNLCK
operator|&&
name|fl
operator|->
name|l_type
operator|==
name|F_UNLCK
condition|)
block|{
comment|/* 		 * We must loop around for all lockowner cases. 		 */
name|callcnt
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|nfscl_getcl
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|1
argument_list|,
operator|&
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
do|do
block|{
name|error
operator|=
name|nfscl_relbytelock
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|callcnt
argument_list|,
name|clp
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
operator|&
name|lp
argument_list|,
operator|&
name|dorpc
argument_list|)
expr_stmt|;
comment|/* 		     * If it returns a NULL lp, we're done. 		     */
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|callcnt
operator|==
literal|0
condition|)
name|nfscl_clientrelease
argument_list|(
name|clp
argument_list|)
expr_stmt|;
else|else
name|nfscl_releasealllocks
argument_list|(
name|clp
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|id
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
else|else
name|clidrev
operator|=
literal|0
expr_stmt|;
comment|/* 		     * If the server doesn't support Posix lock semantics, 		     * only allow locks on the entire file, since it won't 		     * handle overlapping byte ranges. 		     * There might still be a problem when a lock 		     * upgrade/downgrade (read<->write) occurs, since the 		     * server "might" expect an unlock first? 		     */
if|if
condition|(
name|dorpc
operator|&&
operator|(
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_posixlock
operator|||
operator|(
name|off
operator|==
literal|0
operator|&&
name|len
operator|==
name|NFS64BITSSET
operator|)
operator|)
condition|)
block|{
comment|/* 			 * Since the lock records will go away, we must 			 * wait for grace and delay here. 			 */
do|do
block|{
name|error
operator|=
name|nfsrpc_locku
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|lp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|NFSV4LOCKT_READ
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_GRACE
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
operator|)
operator|&&
name|error
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
operator|(
name|int
operator|)
name|nd
operator|->
name|nd_repstat
argument_list|,
literal|"nfs_advlock"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_GRACE
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DELAY
operator|)
operator|&&
name|error
operator|==
literal|0
condition|)
do|;
block|}
name|callcnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
literal|0
operator|&&
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
do|;
name|nfscl_releasealllocks
argument_list|(
name|clp
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|id
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|F_SETLK
condition|)
block|{
name|error
operator|=
name|nfscl_getbytelock
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|fl
operator|->
name|l_type
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|id
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|lp
argument_list|,
operator|&
name|newone
argument_list|,
operator|&
name|donelocally
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|donelocally
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|nmp
operator|->
name|nm_clp
operator|!=
name|NULL
condition|)
name|clidrev
operator|=
name|nmp
operator|->
name|nm_clp
operator|->
name|nfsc_clientidrev
expr_stmt|;
else|else
name|clidrev
operator|=
literal|0
expr_stmt|;
name|nfhp
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_fhp
expr_stmt|;
if|if
condition|(
operator|!
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_posixlock
operator|&&
operator|(
name|off
operator|!=
literal|0
operator|||
name|len
operator|!=
name|NFS64BITSSET
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfsrpc_lock
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|lp
argument_list|,
name|newone
argument_list|,
name|reclaim
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|fl
operator|->
name|l_type
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfscl_lockrelease
argument_list|(
name|lp
argument_list|,
name|error
argument_list|,
name|newone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_BADSESSION
condition|)
block|{
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
name|error
argument_list|,
literal|"nfs_advlock"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|clidrev
operator|!=
literal|0
condition|)
block|{
name|expireret
operator|=
name|nfscl_hasexpired
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|clidrev
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|retrycnt
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_GRACE
operator|||
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|||
name|error
operator|==
name|NFSERR_DELAY
operator|||
name|error
operator|==
name|NFSERR_STALEDONTRECOVER
operator|||
name|error
operator|==
name|NFSERR_STALESTATEID
operator|||
name|error
operator|==
name|NFSERR_BADSESSION
operator|||
operator|(
operator|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_BADSTATEID
operator|)
operator|&&
name|expireret
operator|==
literal|0
operator|&&
name|clidrev
operator|!=
literal|0
operator|&&
name|retrycnt
operator|<
literal|4
operator|)
condition|)
do|;
if|if
condition|(
name|error
operator|&&
name|retrycnt
operator|>=
literal|4
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The lower level routine for the LockT case.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_lockt
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|u_int64_t
name|off
parameter_list|,
name|u_int64_t
name|len
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|id
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
decl_stmt|,
name|type
decl_stmt|,
name|size
decl_stmt|;
name|uint8_t
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
operator|+
name|NFSX_V4FHMAX
index|]
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nfsclsession
modifier|*
name|tsep
decl_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOCKT
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|7
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|l_type
operator|==
name|F_RDLCK
condition|)
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4LOCKT_READ
argument_list|)
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4LOCKT_WRITE
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|off
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|txdr_hyper
argument_list|(
name|len
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|tsep
operator|=
name|nfsmnt_mdssession
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|nfscl_filllockowner
argument_list|(
name|id
argument_list|,
name|own
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
operator|&
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
index|]
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
operator|+
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|fl
operator|->
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DENIED
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
name|fl
operator|->
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|8
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|fl
operator|->
name|l_start
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|len
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|NFS64BITSSET
condition|)
name|fl
operator|->
name|l_len
operator|=
literal|0
expr_stmt|;
else|else
name|fl
operator|->
name|l_len
operator|=
name|len
expr_stmt|;
name|type
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NFSV4LOCKT_WRITE
condition|)
name|fl
operator|->
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
else|else
name|fl
operator|->
name|l_type
operator|=
name|F_RDLCK
expr_stmt|;
comment|/* 		 * XXX For now, I have no idea what to do with the 		 * conflicting lock_owner, so I'll just set the pid == 0 		 * and skip over the lock_owner. 		 */
name|fl
operator|->
name|l_pid
operator|=
operator|(
name|pid_t
operator|)
literal|0
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|size
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
operator|||
name|size
operator|>
name|NFSV4_OPAQUELIMIT
condition|)
name|error
operator|=
name|EBADRPC
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|size
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_STALECLIENTID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lower level function that performs the LockU RPC.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_locku
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
name|lp
parameter_list|,
name|u_int64_t
name|off
parameter_list|,
name|u_int64_t
name|len
parameter_list|,
name|u_int32_t
name|type
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|syscred
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOCKU
argument_list|,
name|nmp
argument_list|,
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_fh
argument_list|,
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_fhlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
literal|6
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|type
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|lp
operator|->
name|nfsl_seqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfstest_outofseq
operator|&&
operator|(
name|arc4random
argument_list|()
operator|%
name|nfstest_outofseq
operator|)
operator|==
literal|0
condition|)
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|lp
operator|->
name|nfsl_seqid
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tl
operator|++
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
name|txdr_hyper
argument_list|(
name|off
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|txdr_hyper
argument_list|(
name|len
argument_list|,
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|syscred
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSCL_INCRSEQID
argument_list|(
name|lp
operator|->
name|nfsl_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The actual Lock RPC.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_lock
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|u_int8_t
modifier|*
name|nfhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
name|lp
parameter_list|,
name|int
name|newone
parameter_list|,
name|int
name|reclaim
parameter_list|,
name|u_int64_t
name|off
parameter_list|,
name|u_int64_t
name|len
parameter_list|,
name|short
name|type
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|syscred
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
decl_stmt|,
name|size
decl_stmt|;
name|uint8_t
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
operator|+
name|NFSX_V4FHMAX
index|]
decl_stmt|;
name|struct
name|nfsclsession
modifier|*
name|tsep
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LOCK
argument_list|,
name|nmp
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|7
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|F_RDLCK
condition|)
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4LOCKT_READ
argument_list|)
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4LOCKT_WRITE
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|reclaim
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|off
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|txdr_hyper
argument_list|(
name|len
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|newone
condition|)
block|{
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
literal|2
operator|*
name|NFSX_UNSIGNED
operator|+
name|NFSX_HYPER
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|lp
operator|->
name|nfsl_seqid
argument_list|)
expr_stmt|;
name|tsep
operator|=
name|nfsmnt_mdssession
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|nfhp
argument_list|,
operator|&
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
index|]
argument_list|,
name|fhlen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
operator|+
name|fhlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|lp
operator|->
name|nfsl_seqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfstest_outofseq
operator|&&
operator|(
name|arc4random
argument_list|()
operator|%
name|nfstest_outofseq
operator|)
operator|==
literal|0
condition|)
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|lp
operator|->
name|nfsl_seqid
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|syscred
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|newone
condition|)
name|NFSCL_INCRSEQID
argument_list|(
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_own
operator|->
name|nfsow_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
name|NFSCL_INCRSEQID
argument_list|(
name|lp
operator|->
name|nfsl_seqid
argument_list|,
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|seqid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|lp
operator|->
name|nfsl_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DENIED
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|8
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|size
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|7
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
operator|||
name|size
operator|>
name|NFSV4_OPAQUELIMIT
condition|)
name|error
operator|=
name|EBADRPC
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|size
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_STALESTATEID
condition|)
name|nfscl_initiate_recovery
argument_list|(
name|lp
operator|->
name|nfsl_open
operator|->
name|nfso_own
operator|->
name|nfsow_clp
argument_list|)
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs statfs rpc  * (always called with the vp for the mount point)  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_statfs
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsstatfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|nfsfsinfo
modifier|*
name|fsp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
init|=
name|NULL
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
comment|/* 		 * For V4, you actually do a getattr. 		 */
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_GETATTR
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSSTATFS_GETATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
name|nap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|sbp
argument_list|,
name|fsp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|nmp
operator|->
name|nm_fsid
index|[
literal|0
index|]
operator|=
name|nap
operator|->
name|na_filesid
index|[
literal|0
index|]
expr_stmt|;
name|nmp
operator|->
name|nm_fsid
index|[
literal|1
index|]
operator|=
name|nap
operator|->
name|na_filesid
index|[
literal|1
index|]
expr_stmt|;
name|NFSSETHASSETFSID
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
else|else
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_FSSTAT
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATFS
argument_list|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NFSHASNFSV3
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|sbp
operator|->
name|sf_tbytes
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|sbp
operator|->
name|sf_fbytes
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|sbp
operator|->
name|sf_abytes
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|sbp
operator|->
name|sf_tfiles
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|sbp
operator|->
name|sf_ffiles
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|sbp
operator|->
name|sf_afiles
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|sbp
operator|->
name|sf_invarsec
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sbp
operator|->
name|sf_tsize
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|sf_bsize
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|sf_blocks
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|sf_bfree
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|sf_bavail
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs pathconf rpc  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_pathconf
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsv3_pathconf
modifier|*
name|pc
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
comment|/* 		 * For V4, you actually do a getattr. 		 */
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_GETATTR
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSPATHCONF_GETATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
name|nap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|pc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|attrflagp
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
block|}
block|}
else|else
block|{
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_PATHCONF
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V3PATHCONF
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_linkmax
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_namemax
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_notrunc
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_chownrestricted
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_caseinsensitive
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_casepreserving
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
block|}
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs version 3 fsinfo rpc call  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_fsinfo
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsfsinfo
modifier|*
name|fsp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_FSINFO
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfscl_postop_attr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|,
name|attrflagp
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V3FSINFO
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_rtmax
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_rtpref
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_rtmult
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_wtmax
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_wtpref
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_wtmult
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_dtpref
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|fsp
operator|->
name|fs_maxfilesize
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|fxdr_nfsv3time
argument_list|(
name|tl
argument_list|,
operator|&
name|fsp
operator|->
name|fs_timedelta
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|fsp
operator|->
name|fs_properties
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function performs the Renew RPC.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_renew
parameter_list|(
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|nfsclds
modifier|*
name|dsp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|nfssockreq
modifier|*
name|nrp
decl_stmt|;
name|struct
name|nfsclsession
modifier|*
name|tsep
decl_stmt|;
name|nmp
operator|=
name|clp
operator|->
name|nfsc_nmp
expr_stmt|;
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dsp
operator|==
name|NULL
condition|)
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RENEW
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RENEW
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|dsp
operator|->
name|nfsclds_sess
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
comment|/* NFSv4.1 just uses a Sequence Op and not a Renew. */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|tsep
operator|=
name|nfsmnt_mdssession
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
block|}
name|nrp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dsp
operator|!=
name|NULL
condition|)
name|nrp
operator|=
name|dsp
operator|->
name|nfsclds_sockp
expr_stmt|;
if|if
condition|(
name|nrp
operator|==
name|NULL
condition|)
comment|/* If NULL, use the MDS socket. */
name|nrp
operator|=
operator|&
name|nmp
operator|->
name|nm_sockreq
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
if|if
condition|(
name|dsp
operator|==
name|NULL
condition|)
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
name|nrp
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
name|nrp
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|dsp
operator|->
name|nfsclds_sess
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function performs the Releaselockowner RPC.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_rellockown
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfscllockowner
modifier|*
name|lp
parameter_list|,
name|uint8_t
modifier|*
name|fh
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
operator|+
name|NFSX_V4FHMAX
index|]
decl_stmt|;
name|struct
name|nfsclsession
modifier|*
name|tsep
decl_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
comment|/* For NFSv4.1, do a FreeStateID. */
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_FREESTATEID
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nfsm_stateidtom
argument_list|(
name|nd
argument_list|,
operator|&
name|lp
operator|->
name|nfsl_stateid
argument_list|,
name|NFSSTATEID_PUTSTATEID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RELEASELCKOWN
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|tsep
operator|=
name|nfsmnt_mdssession
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|lp
operator|->
name|nfsl_owner
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|fh
argument_list|,
operator|&
name|own
index|[
name|NFSV4CL_LOCKNAMELEN
index|]
argument_list|,
name|fhlen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|own
argument_list|,
name|NFSV4CL_LOCKNAMELEN
operator|+
name|fhlen
argument_list|)
expr_stmt|;
block|}
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function performs the Compound to get the mount pt FH.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_getdirpath
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|u_char
modifier|*
name|dirpath
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cnt
decl_stmt|,
name|len
decl_stmt|,
name|setnil
decl_stmt|;
name|u_int32_t
modifier|*
name|opcntp
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_PUTROOTFH
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|opcntp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|dirpath
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|setnil
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|cp
operator|++
expr_stmt|;
name|cp2
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|!=
literal|'\0'
operator|&&
operator|*
name|cp2
operator|!=
literal|'/'
condition|)
name|cp2
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp2
operator|==
literal|'/'
condition|)
block|{
name|setnil
operator|=
literal|1
expr_stmt|;
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|cp2
operator|!=
name|cp
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_LOOKUP
argument_list|)
expr_stmt|;
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|strlen
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|setnil
condition|)
operator|*
name|cp2
operator|++
operator|=
literal|'/'
expr_stmt|;
name|cp
operator|=
name|cp2
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
comment|/* Has a Sequence Op done by nfscl_reqstart(). */
operator|*
name|opcntp
operator|=
name|txdr_unsigned
argument_list|(
literal|3
operator|+
name|cnt
argument_list|)
expr_stmt|;
else|else
operator|*
name|opcntp
operator|=
name|txdr_unsigned
argument_list|(
literal|2
operator|+
name|cnt
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETFH
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
operator|(
literal|3
operator|+
literal|2
operator|*
name|cnt
operator|)
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|tl
operator|+=
operator|(
literal|2
operator|+
literal|2
operator|*
name|cnt
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|)
operator|<=
literal|0
operator|||
name|len
operator|>
name|NFSX_FHMAX
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_BADXDR
expr_stmt|;
block|}
else|else
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|nmp
operator|->
name|nm_fh
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
name|nmp
operator|->
name|nm_fhsize
operator|=
name|len
expr_stmt|;
block|}
block|}
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function performs the Delegreturn RPC.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_delegreturn
parameter_list|(
name|struct
name|nfscldeleg
modifier|*
name|dp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|syscred
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_DELEGRETURN
argument_list|,
name|nmp
argument_list|,
name|dp
operator|->
name|nfsdl_fh
argument_list|,
name|dp
operator|->
name|nfsdl_fhlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|seqid
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|dp
operator|->
name|nfsdl_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|syscred
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs getacl call.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_getacl
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nfsrv_useacl
operator|==
literal|0
operator|||
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_GETACL
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_ACL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|aclp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs setacl call.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrpc_setacl
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nfsrv_useacl
operator|==
literal|0
operator|||
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|error
operator|=
name|nfsrpc_setattr
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|,
name|aclp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs setacl call.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_setaclrpc
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|NFSCL_REQSTART
argument_list|(
name|nd
argument_list|,
name|NFSPROC_SETACL
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|nfsm_stateidtom
argument_list|(
name|nd
argument_list|,
name|stateidp
argument_list|,
name|NFSSTATEID_PUTSTATEID
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_ACL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsv4_fillattr
argument_list|(
name|nd
argument_list|,
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|,
name|vp
argument_list|,
name|aclp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|uint64_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_request
argument_list|(
name|nd
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Don't care about the pre/postop attributes */
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|nd
operator|->
name|nd_repstat
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the NFSv4.1 Exchange ID.  */
end_comment

begin_function
name|int
name|nfsrpc_exchangeid
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|nfssockreq
modifier|*
name|nrp
parameter_list|,
name|uint32_t
name|exchflags
parameter_list|,
name|struct
name|nfsclds
modifier|*
modifier|*
name|dspp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tl
decl_stmt|,
name|v41flags
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsclds
modifier|*
name|dsp
decl_stmt|;
name|struct
name|timespec
name|verstime
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
operator|*
name|dspp
operator|=
name|NULL
expr_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_EXCHANGEID
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nfsboottime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
comment|/* Client owner */
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|clp
operator|->
name|nfsc_rev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|clp
operator|->
name|nfsc_id
argument_list|,
name|clp
operator|->
name|nfsc_idlen
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|exchflags
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4EXCH_SP4NONE
argument_list|)
expr_stmt|;
comment|/* Set the implementation id4 */
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
literal|"freebsd.org"
argument_list|,
name|strlen
argument_list|(
literal|"freebsd.org"
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|version
argument_list|,
name|strlen
argument_list|(
name|version
argument_list|)
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
name|verstime
operator|.
name|tv_sec
operator|=
literal|1293840000
expr_stmt|;
comment|/* Jan 1, 2011 */
name|verstime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|txdr_nfsv4time
argument_list|(
operator|&
name|verstime
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
name|nrp
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"exchangeid err=%d reps=%d\n"
argument_list|,
name|error
argument_list|,
operator|(
name|int
operator|)
name|nd
operator|->
name|nd_repstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|6
operator|*
name|NFSX_UNSIGNED
operator|+
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|7
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|NFSV4_OPAQUELIMIT
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|dsp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsclds
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|,
name|M_NFSCLDS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|dsp
operator|->
name|nfsclds_expire
operator|=
name|NFSD_MONOSEC
operator|+
name|clp
operator|->
name|nfsc_renew
expr_stmt|;
name|dsp
operator|->
name|nfsclds_servownlen
operator|=
name|len
expr_stmt|;
name|dsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_clientid
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_clientid
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|dsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_sequenceid
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|v41flags
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|v41flags
operator|&
name|NFSV4EXCH_USEPNFSMDS
operator|)
operator|!=
literal|0
operator|&&
name|NFSHASPNFSOPT
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|NFSCL_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"set PNFS\n"
argument_list|)
expr_stmt|;
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_PNFS
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|dsp
operator|->
name|nfsclds_flags
operator||=
name|NFSCLDS_MDS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|v41flags
operator|&
name|NFSV4EXCH_USEPNFSDS
operator|)
operator|!=
literal|0
condition|)
name|dsp
operator|->
name|nfsclds_flags
operator||=
name|NFSCLDS_DS
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|dsp
operator|->
name|nfsclds_serverown
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|mtx_init
argument_list|(
operator|&
name|dsp
operator|->
name|nfsclds_mtx
argument_list|,
literal|"nfsds"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|dsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_mtx
argument_list|,
literal|"nfssession"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|nfscl_initsessionslots
argument_list|(
operator|&
name|dsp
operator|->
name|nfsclds_sess
argument_list|)
expr_stmt|;
operator|*
name|dspp
operator|=
name|dsp
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|dsp
argument_list|,
name|M_NFSCLDS
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the NFSv4.1 Create Session.  */
end_comment

begin_function
name|int
name|nfsrpc_createsession
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclsession
modifier|*
name|sep
parameter_list|,
name|struct
name|nfssockreq
modifier|*
name|nrp
parameter_list|,
name|uint32_t
name|sequenceid
parameter_list|,
name|int
name|mds
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
name|crflags
decl_stmt|,
name|maxval
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|irdcnt
decl_stmt|;
comment|/* Make sure nm_rsize, nm_wsize is set. */
if|if
condition|(
name|nmp
operator|->
name|nm_rsize
operator|>
name|NFS_MAXBSIZE
operator|||
name|nmp
operator|->
name|nm_rsize
operator|==
literal|0
condition|)
name|nmp
operator|->
name|nm_rsize
operator|=
name|NFS_MAXBSIZE
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_wsize
operator|>
name|NFS_MAXBSIZE
operator|||
name|nmp
operator|->
name|nm_wsize
operator|==
literal|0
condition|)
name|nmp
operator|->
name|nm_wsize
operator|=
name|NFS_MAXBSIZE
expr_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_CREATESESSION
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|sep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|sep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|sequenceid
argument_list|)
expr_stmt|;
name|crflags
operator|=
operator|(
name|NFSMNT_RDONLY
argument_list|(
name|nmp
operator|->
name|nm_mountp
argument_list|)
condition|?
literal|0
else|:
name|NFSV4CRSESS_PERSIST
operator|)
expr_stmt|;
if|if
condition|(
name|nfscl_enablecallb
operator|!=
literal|0
operator|&&
name|nfs_numnfscbd
operator|>
literal|0
operator|&&
name|mds
operator|!=
literal|0
condition|)
name|crflags
operator||=
name|NFSV4CRSESS_CONNBACKCHAN
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|crflags
argument_list|)
expr_stmt|;
comment|/* Fill in fore channel attributes. */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|7
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Header pad size */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXXDR
argument_list|)
expr_stmt|;
comment|/* Max request size */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nmp
operator|->
name|nm_rsize
operator|+
name|NFS_MAXXDR
argument_list|)
expr_stmt|;
comment|/* Max reply size */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|4096
argument_list|)
expr_stmt|;
comment|/* Max response size cached */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* Max operations */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|64
argument_list|)
expr_stmt|;
comment|/* Max slots */
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
comment|/* No rdma ird */
comment|/* Fill in back channel attributes. */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|7
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Header pad size */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Max request size */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* Max response size */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|4096
argument_list|)
expr_stmt|;
comment|/* Max response size cached */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* Max operations */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4_CBSLOTS
argument_list|)
expr_stmt|;
comment|/* Max slots */
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
comment|/* No rdma ird */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|8
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFS_CALLBCKPROG
argument_list|)
expr_stmt|;
comment|/* Call back prog # */
comment|/* Allow AUTH_SYS callbacks as uid, gid == 0. */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Auth_sys only */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|AUTH_SYS
argument_list|)
expr_stmt|;
comment|/* AUTH_SYS type */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|nfsboottime
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
comment|/* time stamp */
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Null machine name */
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Uid == 0 */
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Gid == 0 */
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
comment|/* No additional gids */
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
name|nrp
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_V4SESSIONID
operator|+
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tl
argument_list|,
name|sep
operator|->
name|nfsess_sessionid
argument_list|,
name|NFSX_V4SESSIONID
argument_list|)
expr_stmt|;
name|tl
operator|+=
name|NFSX_V4SESSIONID
operator|/
name|NFSX_UNSIGNED
expr_stmt|;
name|sep
operator|->
name|nfsess_sequenceid
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|crflags
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|crflags
operator|&
name|NFSV4CRSESS_PERSIST
operator|)
operator|!=
literal|0
operator|&&
name|mds
operator|!=
literal|0
condition|)
block|{
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_SESSPERSIST
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
comment|/* Get the fore channel slot count. */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|7
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|tl
operator|++
expr_stmt|;
comment|/* Skip the header pad size. */
comment|/* Make sure nm_wsize is small enough. */
name|maxval
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
name|maxval
operator|<
name|nmp
operator|->
name|nm_wsize
operator|+
name|NFS_MAXXDR
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_wsize
operator|>
literal|8096
condition|)
name|nmp
operator|->
name|nm_wsize
operator|/=
literal|2
expr_stmt|;
else|else
break|break;
block|}
comment|/* Make sure nm_rsize is small enough. */
name|maxval
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
name|maxval
operator|<
name|nmp
operator|->
name|nm_rsize
operator|+
name|NFS_MAXXDR
condition|)
block|{
if|if
condition|(
name|nmp
operator|->
name|nm_rsize
operator|>
literal|8096
condition|)
name|nmp
operator|->
name|nm_rsize
operator|/=
literal|2
expr_stmt|;
else|else
break|break;
block|}
name|sep
operator|->
name|nfsess_maxcache
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|tl
operator|++
expr_stmt|;
name|sep
operator|->
name|nfsess_foreslots
operator|=
name|fxdr_unsigned
argument_list|(
name|uint16_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"fore slots=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|sep
operator|->
name|nfsess_foreslots
argument_list|)
expr_stmt|;
name|irdcnt
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|irdcnt
operator|>
literal|0
condition|)
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|irdcnt
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
comment|/* and the back channel slot count. */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|7
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|5
expr_stmt|;
name|sep
operator|->
name|nfsess_backslots
operator|=
name|fxdr_unsigned
argument_list|(
name|uint16_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"back slots=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|sep
operator|->
name|nfsess_backslots
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the NFSv4.1 Destroy Session.  */
end_comment

begin_function
name|int
name|nfsrpc_destroysession
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|nfsclsession
modifier|*
name|tsep
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_DESTROYSESSION
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_V4SESSIONID
argument_list|)
expr_stmt|;
name|tsep
operator|=
name|nfsmnt_mdssession
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tsep
operator|->
name|nfsess_sessionid
argument_list|,
name|tl
argument_list|,
name|NFSX_V4SESSIONID
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the NFSv4.1 Destroy Client.  */
end_comment

begin_function
name|int
name|nfsrpc_destroyclient
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclclient
modifier|*
name|clp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|nfsclsession
modifier|*
name|tsep
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_DESTROYCLIENT
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|tsep
operator|=
name|nfsmnt_mdssession
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|tsep
operator|->
name|nfsess_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the NFSv4.1 LayoutGet.  */
end_comment

begin_function
name|int
name|nfsrpc_layoutget
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|uint8_t
modifier|*
name|fhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|int
name|iomode
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|uint64_t
name|minlen
parameter_list|,
name|int
name|layoutlen
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|int
modifier|*
name|retonclosep
parameter_list|,
name|struct
name|nfsclflayouthead
modifier|*
name|flhp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|struct
name|nfsclflayout
modifier|*
name|flp
decl_stmt|,
modifier|*
name|prevflp
decl_stmt|,
modifier|*
name|tflp
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|error
decl_stmt|,
name|gotiomode
decl_stmt|,
name|fhcnt
decl_stmt|,
name|nfhlen
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint8_t
modifier|*
name|cp
decl_stmt|;
name|uint64_t
name|retlen
decl_stmt|;
name|flp
operator|=
name|NULL
expr_stmt|;
name|gotiomode
operator|=
operator|-
literal|1
expr_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LAYOUTGET
argument_list|,
name|nmp
argument_list|,
name|fhp
argument_list|,
name|fhlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
operator|+
literal|3
operator|*
name|NFSX_HYPER
operator|+
name|NFSX_STATEID
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_false
expr_stmt|;
comment|/* Don't signal availability. */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSLAYOUT_NFSV4_1_FILES
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|iomode
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|txdr_hyper
argument_list|(
name|len
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|txdr_hyper
argument_list|(
name|minlen
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|stateidp
operator|->
name|seqid
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"layget seq=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|stateidp
operator|->
name|seqid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|layoutlen
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
operator|+
name|NFSX_STATEID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|++
operator|!=
literal|0
condition|)
operator|*
name|retonclosep
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|retonclosep
operator|=
literal|0
expr_stmt|;
name|stateidp
operator|->
name|seqid
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"retoncls=%d stseq=%d\n"
argument_list|,
operator|*
name|retonclosep
argument_list|,
operator|(
name|int
operator|)
name|stateidp
operator|->
name|seqid
argument_list|)
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|cnt
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"layg cnt=%d\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<=
literal|0
operator|||
name|cnt
operator|>
literal|10000
condition|)
block|{
comment|/* Don't accept more than 10000 layouts in reply. */
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
comment|/* Dissect all the way to the file handle cnt. */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_HYPER
operator|+
literal|6
operator|*
name|NFSX_UNSIGNED
operator|+
name|NFSX_V4DEVICEID
argument_list|)
expr_stmt|;
name|fhcnt
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
literal|11
operator|+
name|NFSX_V4DEVICEID
operator|/
name|NFSX_UNSIGNED
operator|)
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"fhcnt=%d\n"
argument_list|,
name|fhcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fhcnt
operator|<
literal|0
operator|||
name|fhcnt
operator|>
literal|100
condition|)
block|{
comment|/* Don't accept more than 100 file handles. */
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|fhcnt
operator|>
literal|1
condition|)
name|flp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|flp
argument_list|)
operator|+
operator|(
name|fhcnt
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nfsfh
operator|*
argument_list|)
argument_list|,
name|M_NFSFLAYOUT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|flp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|flp
argument_list|)
argument_list|,
name|M_NFSFLAYOUT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|flp
operator|->
name|nfsfl_flags
operator|=
literal|0
expr_stmt|;
name|flp
operator|->
name|nfsfl_fhcnt
operator|=
literal|0
expr_stmt|;
name|flp
operator|->
name|nfsfl_devp
operator|=
name|NULL
expr_stmt|;
name|flp
operator|->
name|nfsfl_off
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|retlen
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|flp
operator|->
name|nfsfl_off
operator|+
name|retlen
operator|<
name|flp
operator|->
name|nfsfl_off
condition|)
name|flp
operator|->
name|nfsfl_end
operator|=
name|UINT64_MAX
operator|-
name|flp
operator|->
name|nfsfl_off
expr_stmt|;
else|else
name|flp
operator|->
name|nfsfl_end
operator|=
name|flp
operator|->
name|nfsfl_off
operator|+
name|retlen
expr_stmt|;
name|flp
operator|->
name|nfsfl_iomode
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotiomode
operator|==
operator|-
literal|1
condition|)
name|gotiomode
operator|=
name|flp
operator|->
name|nfsfl_iomode
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"layg reqiom=%d retiom=%d\n"
argument_list|,
name|iomode
argument_list|,
operator|(
name|int
operator|)
name|flp
operator|->
name|nfsfl_iomode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
operator|!=
name|NFSLAYOUT_NFSV4_1_FILES
condition|)
block|{
name|printf
argument_list|(
literal|"NFSv4.1: got non-files layout\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|NFSBCOPY
argument_list|(
operator|++
name|tl
argument_list|,
name|flp
operator|->
name|nfsfl_dev
argument_list|,
name|NFSX_V4DEVICEID
argument_list|)
expr_stmt|;
name|tl
operator|+=
operator|(
name|NFSX_V4DEVICEID
operator|/
name|NFSX_UNSIGNED
operator|)
expr_stmt|;
name|flp
operator|->
name|nfsfl_util
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"flutil=0x%x\n"
argument_list|,
name|flp
operator|->
name|nfsfl_util
argument_list|)
expr_stmt|;
name|flp
operator|->
name|nfsfl_stripe1
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|flp
operator|->
name|nfsfl_patoff
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|!=
name|fhcnt
condition|)
block|{
name|printf
argument_list|(
literal|"EEK! bad fhcnt\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|fhcnt
condition|;
name|j
operator|++
control|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nfhlen
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfhlen
operator|<=
literal|0
operator|||
name|nfhlen
operator|>
name|NFSX_V4FHMAX
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|nfhp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nfhp
argument_list|)
operator|+
name|nfhlen
operator|-
literal|1
argument_list|,
name|M_NFSFH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|flp
operator|->
name|nfsfl_fh
index|[
name|j
index|]
operator|=
name|nfhp
expr_stmt|;
name|flp
operator|->
name|nfsfl_fhcnt
operator|++
expr_stmt|;
name|nfhp
operator|->
name|nfh_len
operator|=
name|nfhlen
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|cp
argument_list|,
name|uint8_t
operator|*
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|nfhlen
argument_list|)
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|cp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flp
operator|->
name|nfsfl_iomode
operator|==
name|gotiomode
condition|)
block|{
comment|/* Keep the list in increasing offset order. */
name|tflp
operator|=
name|LIST_FIRST
argument_list|(
name|flhp
argument_list|)
expr_stmt|;
name|prevflp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|tflp
operator|!=
name|NULL
operator|&&
name|tflp
operator|->
name|nfsfl_off
operator|<
name|flp
operator|->
name|nfsfl_off
condition|)
block|{
name|prevflp
operator|=
name|tflp
expr_stmt|;
name|tflp
operator|=
name|LIST_NEXT
argument_list|(
name|tflp
argument_list|,
name|nfsfl_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prevflp
operator|==
name|NULL
condition|)
name|LIST_INSERT_HEAD
argument_list|(
name|flhp
argument_list|,
name|flp
argument_list|,
name|nfsfl_list
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_AFTER
argument_list|(
name|prevflp
argument_list|,
name|flp
argument_list|,
name|nfsfl_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"nfscl_layoutget(): got wrong iomode\n"
argument_list|)
expr_stmt|;
name|nfscl_freeflayout
argument_list|(
name|flp
argument_list|)
expr_stmt|;
block|}
name|flp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|flp
operator|!=
name|NULL
condition|)
name|nfscl_freeflayout
argument_list|(
name|flp
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the NFSv4.1 Get Device Info.  */
end_comment

begin_function
name|int
name|nfsrpc_getdeviceinfo
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|uint8_t
modifier|*
name|deviceid
parameter_list|,
name|int
name|layouttype
parameter_list|,
name|uint32_t
modifier|*
name|notifybitsp
parameter_list|,
name|struct
name|nfscldevinfo
modifier|*
modifier|*
name|ndip
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
name|cnt
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|struct
name|nfsclds
modifier|*
name|dsp
init|=
name|NULL
decl_stmt|,
modifier|*
modifier|*
name|dspp
decl_stmt|;
name|struct
name|nfscldevinfo
modifier|*
name|ndi
decl_stmt|;
name|int
name|addrcnt
decl_stmt|,
name|bitcnt
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|isudp
decl_stmt|,
name|j
decl_stmt|,
name|pos
decl_stmt|,
name|safilled
decl_stmt|,
name|stripecnt
decl_stmt|;
name|uint8_t
name|stripeindex
decl_stmt|;
operator|*
name|ndip
operator|=
name|NULL
expr_stmt|;
name|ndi
operator|=
name|NULL
expr_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_GETDEVICEINFO
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_V4DEVICEID
operator|+
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|deviceid
argument_list|,
name|tl
argument_list|,
name|NFSX_V4DEVICEID
argument_list|)
expr_stmt|;
name|tl
operator|+=
operator|(
name|NFSX_V4DEVICEID
operator|/
name|NFSX_UNSIGNED
operator|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|layouttype
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
if|if
condition|(
name|notifybitsp
operator|!=
name|NULL
operator|&&
operator|*
name|notifybitsp
operator|!=
literal|0
condition|)
block|{
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* One word of bits. */
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
operator|*
name|notifybitsp
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|layouttype
operator|!=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
condition|)
name|printf
argument_list|(
literal|"EEK! devinfo layout type not same!\n"
argument_list|)
expr_stmt|;
name|stripecnt
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|++
name|tl
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"stripecnt=%d\n"
argument_list|,
name|stripecnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|stripecnt
operator|<
literal|1
operator|||
name|stripecnt
operator|>
literal|4096
condition|)
block|{
name|printf
argument_list|(
literal|"NFS devinfo stripecnt %d: out of range\n"
argument_list|,
name|stripecnt
argument_list|)
expr_stmt|;
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
operator|(
name|stripecnt
operator|+
literal|1
operator|)
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|addrcnt
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
operator|(
name|tl
operator|+
name|stripecnt
operator|)
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"addrcnt=%d\n"
argument_list|,
name|addrcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrcnt
operator|<
literal|1
operator|||
name|addrcnt
operator|>
literal|128
condition|)
block|{
name|printf
argument_list|(
literal|"NFS devinfo addrcnt %d: out of range\n"
argument_list|,
name|addrcnt
argument_list|)
expr_stmt|;
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
comment|/* 		 * Now we know how many stripe indices and addresses, so 		 * we can allocate the structure the correct size. 		 */
name|i
operator|=
operator|(
name|stripecnt
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|nfsclds
operator|*
argument_list|)
operator|+
literal|1
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"stripeindices=%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ndi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ndi
argument_list|)
operator|+
operator|(
name|addrcnt
operator|+
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nfsclds
operator|*
argument_list|)
argument_list|,
name|M_NFSDEVINFO
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|deviceid
argument_list|,
name|ndi
operator|->
name|nfsdi_deviceid
argument_list|,
name|NFSX_V4DEVICEID
argument_list|)
expr_stmt|;
name|ndi
operator|->
name|nfsdi_refcnt
operator|=
literal|0
expr_stmt|;
name|ndi
operator|->
name|nfsdi_stripecnt
operator|=
name|stripecnt
expr_stmt|;
name|ndi
operator|->
name|nfsdi_addrcnt
operator|=
name|addrcnt
expr_stmt|;
comment|/* Fill in the stripe indices. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stripecnt
condition|;
name|i
operator|++
control|)
block|{
name|stripeindex
operator|=
name|fxdr_unsigned
argument_list|(
name|uint8_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"stripeind=%d\n"
argument_list|,
name|stripeindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|stripeindex
operator|>=
name|addrcnt
condition|)
block|{
name|printf
argument_list|(
literal|"NFS devinfo stripeindex %d: too big\n"
argument_list|,
operator|(
name|int
operator|)
name|stripeindex
argument_list|)
expr_stmt|;
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|nfsfldi_setstripeindex
argument_list|(
name|ndi
argument_list|,
name|i
argument_list|,
name|stripeindex
argument_list|)
expr_stmt|;
block|}
comment|/* Now, dissect the server address(es). */
name|safilled
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|addrcnt
condition|;
name|i
operator|++
control|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"NFS devinfo 0 len addrlist\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|dspp
operator|=
name|nfsfldi_addr
argument_list|(
name|ndi
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pos
operator|=
name|arc4random
argument_list|()
operator|%
name|cnt
expr_stmt|;
comment|/* Choose one. */
name|safilled
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cnt
condition|;
name|j
operator|++
control|)
block|{
name|error
operator|=
name|nfsv4_getipaddr
argument_list|(
name|nd
argument_list|,
operator|&
name|ss
argument_list|,
operator|&
name|isudp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EPERM
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|isudp
operator|==
literal|0
condition|)
block|{
comment|/* 					 * The algorithm is: 					 * - use "pos" entry if it is of the 					 *   same af_family or none of them 					 *   is of the same af_family 					 * else 					 * - use the first one of the same 					 *   af_family. 					 */
if|if
condition|(
operator|(
name|safilled
operator|==
literal|0
operator|&&
name|ss
operator|.
name|ss_family
operator|==
name|nmp
operator|->
name|nm_nam
operator|->
name|sa_family
operator|)
operator|||
operator|(
name|j
operator|==
name|pos
operator|&&
operator|(
name|safilled
operator|==
literal|0
operator|||
name|ss
operator|.
name|ss_family
operator|==
name|nmp
operator|->
name|nm_nam
operator|->
name|sa_family
operator|)
operator|)
operator|||
operator|(
name|safilled
operator|==
literal|1
operator|&&
name|ss
operator|.
name|ss_family
operator|==
name|nmp
operator|->
name|nm_nam
operator|->
name|sa_family
operator|)
condition|)
block|{
name|error
operator|=
name|nfsrpc_fillsa
argument_list|(
name|nmp
argument_list|,
operator|&
name|ss
argument_list|,
operator|&
name|dsp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|dspp
operator|=
name|dsp
expr_stmt|;
if|if
condition|(
name|ss
operator|.
name|ss_family
operator|==
name|nmp
operator|->
name|nm_nam
operator|->
name|sa_family
condition|)
name|safilled
operator|=
literal|2
expr_stmt|;
else|else
name|safilled
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|safilled
operator|==
literal|0
condition|)
break|break;
block|}
comment|/* And the notify bits. */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|safilled
operator|!=
literal|0
condition|)
block|{
name|bitcnt
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitcnt
operator|>
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|notifybitsp
operator|!=
name|NULL
condition|)
operator|*
name|notifybitsp
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
operator|*
name|ndip
operator|=
name|ndi
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|ndi
operator|!=
name|NULL
condition|)
name|nfscl_freedevinfo
argument_list|(
name|ndi
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the NFSv4.1 LayoutCommit.  */
end_comment

begin_function
name|int
name|nfsrpc_layoutcommit
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|uint8_t
modifier|*
name|fh
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|int
name|reclaim
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|uint64_t
name|lastbyte
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|int
name|layouttype
parameter_list|,
name|int
name|layoutupdatecnt
parameter_list|,
name|uint8_t
modifier|*
name|layp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|outcnt
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|cp
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LAYOUTCOMMIT
argument_list|,
name|nmp
argument_list|,
name|fh
argument_list|,
name|fhlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
operator|+
literal|3
operator|*
name|NFSX_HYPER
operator|+
name|NFSX_STATEID
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|off
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|txdr_hyper
argument_list|(
name|len
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|reclaim
operator|!=
literal|0
condition|)
operator|*
name|tl
operator|++
operator|=
name|newnfs_true
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|newnfs_false
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|stateidp
operator|->
name|seqid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_true
expr_stmt|;
if|if
condition|(
name|lastbyte
operator|<
name|off
condition|)
name|lastbyte
operator|=
name|off
expr_stmt|;
elseif|else
if|if
condition|(
name|lastbyte
operator|>=
operator|(
name|off
operator|+
name|len
operator|)
condition|)
name|lastbyte
operator|=
name|off
operator|+
name|len
operator|-
literal|1
expr_stmt|;
name|txdr_hyper
argument_list|(
name|lastbyte
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_false
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|layouttype
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|layoutupdatecnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|layoutupdatecnt
operator|>
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|layouttype
operator|!=
name|NFSLAYOUT_NFSV4_1_FILES
argument_list|,
operator|(
literal|"Must be nil for Files Layout"
operator|)
argument_list|)
expr_stmt|;
name|outcnt
operator|=
name|NFSM_RNDUP
argument_list|(
name|layoutupdatecnt
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|cp
argument_list|,
name|uint8_t
operator|*
argument_list|,
name|outcnt
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|layp
argument_list|,
name|cp
argument_list|,
name|layoutupdatecnt
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|layoutupdatecnt
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|outcnt
operator|-
name|layoutupdatecnt
operator|)
condition|;
name|i
operator|++
control|)
operator|*
name|cp
operator|++
operator|=
literal|0x0
expr_stmt|;
block|}
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the NFSv4.1 LayoutReturn.  */
end_comment

begin_function
name|int
name|nfsrpc_layoutreturn
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|uint8_t
modifier|*
name|fh
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|int
name|reclaim
parameter_list|,
name|int
name|layouttype
parameter_list|,
name|uint32_t
name|iomode
parameter_list|,
name|int
name|layoutreturn
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|int
name|layoutcnt
parameter_list|,
name|uint32_t
modifier|*
name|layp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|stuff
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|,
name|outcnt
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|cp
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_LAYOUTRETURN
argument_list|,
name|nmp
argument_list|,
name|fh
argument_list|,
name|fhlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclaim
operator|!=
literal|0
condition|)
operator|*
name|tl
operator|++
operator|=
name|newnfs_true
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|newnfs_false
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|layouttype
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|iomode
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|layoutreturn
argument_list|)
expr_stmt|;
if|if
condition|(
name|layoutreturn
operator|==
name|NFSLAYOUTRETURN_FILE
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_HYPER
operator|+
name|NFSX_STATEID
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|txdr_hyper
argument_list|(
name|len
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"layoutret stseq=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|stateidp
operator|->
name|seqid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|stateidp
operator|->
name|seqid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|layoutcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|layoutcnt
operator|>
literal|0
condition|)
block|{
name|outcnt
operator|=
name|NFSM_RNDUP
argument_list|(
name|layoutcnt
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|cp
argument_list|,
name|uint8_t
operator|*
argument_list|,
name|outcnt
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|layp
argument_list|,
name|cp
argument_list|,
name|layoutcnt
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|layoutcnt
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|outcnt
operator|-
name|layoutcnt
operator|)
condition|;
name|i
operator|++
control|)
operator|*
name|cp
operator|++
operator|=
literal|0x0
expr_stmt|;
block|}
block|}
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|!=
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
name|stateidp
operator|->
name|seqid
operator|=
name|fxdr_unsigned
argument_list|(
name|uint32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
operator|*
name|tl
expr_stmt|;
block|}
block|}
else|else
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|nfsmout
label|:
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Acquire a layout and devinfo, if possible. The caller must have acquired  * a reference count on the nfsclclient structure before calling this.  * Return the layout in lypp with a reference count on it, if successful.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_getlayout
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsfh
modifier|*
name|nfhp
parameter_list|,
name|int
name|iomode
parameter_list|,
name|uint32_t
modifier|*
name|notifybitsp
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|struct
name|nfscllayout
modifier|*
modifier|*
name|lypp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfscllayout
modifier|*
name|lyp
decl_stmt|;
name|struct
name|nfsclflayout
modifier|*
name|flp
decl_stmt|,
modifier|*
name|tflp
decl_stmt|;
name|struct
name|nfscldevinfo
modifier|*
name|dip
decl_stmt|;
name|struct
name|nfsclflayouthead
name|flh
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|islocked
decl_stmt|,
name|layoutlen
decl_stmt|,
name|recalled
decl_stmt|,
name|retonclose
decl_stmt|;
name|nfsv4stateid_t
name|stateid
decl_stmt|;
name|struct
name|nfsclsession
modifier|*
name|tsep
decl_stmt|;
operator|*
name|lypp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If lyp is returned non-NULL, there will be a refcnt (shared lock) 	 * on it, iff flp != NULL or a lock (exclusive lock) on it iff 	 * flp == NULL. 	 */
name|lyp
operator|=
name|nfscl_getlayout
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|off
argument_list|,
operator|&
name|flp
argument_list|,
operator|&
name|recalled
argument_list|)
expr_stmt|;
name|islocked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lyp
operator|==
name|NULL
operator|||
name|flp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|recalled
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|LIST_INIT
argument_list|(
operator|&
name|flh
argument_list|)
expr_stmt|;
name|tsep
operator|=
name|nfsmnt_mdssession
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|layoutlen
operator|=
name|tsep
operator|->
name|nfsess_maxcache
operator|-
operator|(
name|NFSX_STATEID
operator|+
literal|3
operator|*
name|NFSX_UNSIGNED
operator|)
expr_stmt|;
if|if
condition|(
name|lyp
operator|==
name|NULL
condition|)
block|{
name|stateid
operator|.
name|seqid
operator|=
literal|0
expr_stmt|;
name|stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
expr_stmt|;
name|stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
expr_stmt|;
name|stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
expr_stmt|;
name|error
operator|=
name|nfsrpc_layoutget
argument_list|(
name|nmp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|iomode
argument_list|,
operator|(
name|uint64_t
operator|)
literal|0
argument_list|,
name|UINT64_MAX
argument_list|,
operator|(
name|uint64_t
operator|)
literal|0
argument_list|,
name|layoutlen
argument_list|,
operator|&
name|stateid
argument_list|,
operator|&
name|retonclose
argument_list|,
operator|&
name|flh
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|islocked
operator|=
literal|1
expr_stmt|;
name|stateid
operator|.
name|seqid
operator|=
name|lyp
operator|->
name|nfsly_stateid
operator|.
name|seqid
expr_stmt|;
name|stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|lyp
operator|->
name|nfsly_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
name|stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|lyp
operator|->
name|nfsly_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
name|stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|lyp
operator|->
name|nfsly_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
name|error
operator|=
name|nfsrpc_layoutget
argument_list|(
name|nmp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|iomode
argument_list|,
name|off
argument_list|,
name|UINT64_MAX
argument_list|,
operator|(
name|uint64_t
operator|)
literal|0
argument_list|,
name|layoutlen
argument_list|,
operator|&
name|stateid
argument_list|,
operator|&
name|retonclose
argument_list|,
operator|&
name|flh
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|LIST_FOREACH
argument_list|(
argument|tflp
argument_list|,
argument|&flh
argument_list|,
argument|nfsfl_list
argument_list|)
block|{
name|error
operator|=
name|nfscl_adddevinfo
argument_list|(
name|nmp
argument_list|,
name|NULL
argument_list|,
name|tflp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|nfsrpc_getdeviceinfo
argument_list|(
name|nmp
argument_list|,
name|tflp
operator|->
name|nfsfl_dev
argument_list|,
name|NFSLAYOUT_NFSV4_1_FILES
argument_list|,
name|notifybitsp
argument_list|,
operator|&
name|dip
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|nfscl_adddevinfo
argument_list|(
name|nmp
argument_list|,
name|dip
argument_list|,
name|tflp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"getlayout: cannot add\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 			 * nfscl_layout() always returns with the nfsly_lock 			 * set to a refcnt (shared lock). 			 */
name|error
operator|=
name|nfscl_layout
argument_list|(
name|nmp
argument_list|,
name|vp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
operator|&
name|stateid
argument_list|,
name|retonclose
argument_list|,
operator|&
name|flh
argument_list|,
operator|&
name|lyp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|lypp
operator|=
name|lyp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|islocked
operator|!=
literal|0
condition|)
name|nfsv4_unlock
argument_list|(
operator|&
name|lyp
operator|->
name|nfsly_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|lypp
operator|=
name|lyp
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do a TCP connection plus exchange id and create session.  * If successful, a "struct nfsclds" is linked into the list for the  * mount point and a pointer to it is returned.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_fillsa
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|ssp
parameter_list|,
name|struct
name|nfsclds
modifier|*
modifier|*
name|dspp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|msad
decl_stmt|,
modifier|*
name|sad
decl_stmt|,
modifier|*
name|ssd
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|msad6
decl_stmt|,
modifier|*
name|sad6
decl_stmt|,
modifier|*
name|ssd6
decl_stmt|;
name|struct
name|nfsclclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfssockreq
modifier|*
name|nrp
decl_stmt|;
name|struct
name|nfsclds
modifier|*
name|dsp
decl_stmt|,
modifier|*
name|tdsp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|enum
name|nfsclds_state
name|retv
decl_stmt|;
name|uint32_t
name|sequenceid
decl_stmt|;
name|KASSERT
argument_list|(
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_cred
operator|!=
name|NULL
argument_list|,
operator|(
literal|"nfsrpc_fillsa: NULL nr_cred"
operator|)
argument_list|)
expr_stmt|;
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|clp
operator|=
name|nmp
operator|->
name|nm_clp
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|clp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|ssp
operator|->
name|ss_family
operator|==
name|AF_INET
condition|)
block|{
name|ssd
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ssp
expr_stmt|;
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
comment|/* 		 * Check to see if we already have a session for this 		 * address that is usable for a DS. 		 * Note that the MDS's address is in a different place 		 * than the sessions already acquired for DS's. 		 */
name|msad
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_nam
expr_stmt|;
name|tdsp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|nmp
operator|->
name|nm_sess
argument_list|)
expr_stmt|;
while|while
condition|(
name|tdsp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|msad
operator|!=
name|NULL
operator|&&
name|msad
operator|->
name|sin_family
operator|==
name|AF_INET
operator|&&
name|ssd
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|msad
operator|->
name|sin_addr
operator|.
name|s_addr
operator|&&
name|ssd
operator|->
name|sin_port
operator|==
name|msad
operator|->
name|sin_port
operator|&&
operator|(
name|tdsp
operator|->
name|nfsclds_flags
operator|&
name|NFSCLDS_DS
operator|)
operator|!=
literal|0
operator|&&
name|tdsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_defunct
operator|==
literal|0
condition|)
block|{
operator|*
name|dspp
operator|=
name|tdsp
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"fnd same addr\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tdsp
operator|=
name|TAILQ_NEXT
argument_list|(
name|tdsp
argument_list|,
name|nfsclds_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdsp
operator|!=
name|NULL
operator|&&
name|tdsp
operator|->
name|nfsclds_sockp
operator|!=
name|NULL
condition|)
name|msad
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|tdsp
operator|->
name|nfsclds_sockp
operator|->
name|nr_nam
expr_stmt|;
else|else
name|msad
operator|=
name|NULL
expr_stmt|;
block|}
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
comment|/* No IP address match, so look for new/trunked one. */
name|sad
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sad
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sad
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sad
argument_list|)
expr_stmt|;
name|sad
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sad
operator|->
name|sin_port
operator|=
name|ssd
operator|->
name|sin_port
expr_stmt|;
name|sad
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|ssd
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|nrp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nrp
argument_list|)
argument_list|,
name|M_NFSSOCKREQ
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|nrp
operator|->
name|nr_nam
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sad
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ssp
operator|->
name|ss_family
operator|==
name|AF_INET6
condition|)
block|{
name|ssd6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ssp
expr_stmt|;
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
comment|/* 		 * Check to see if we already have a session for this 		 * address that is usable for a DS. 		 * Note that the MDS's address is in a different place 		 * than the sessions already acquired for DS's. 		 */
name|msad6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_nam
expr_stmt|;
name|tdsp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|nmp
operator|->
name|nm_sess
argument_list|)
expr_stmt|;
while|while
condition|(
name|tdsp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|msad6
operator|!=
name|NULL
operator|&&
name|msad6
operator|->
name|sin6_family
operator|==
name|AF_INET6
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ssd6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|msad6
operator|->
name|sin6_addr
argument_list|)
operator|&&
name|ssd6
operator|->
name|sin6_port
operator|==
name|msad6
operator|->
name|sin6_port
operator|&&
operator|(
name|tdsp
operator|->
name|nfsclds_flags
operator|&
name|NFSCLDS_DS
operator|)
operator|!=
literal|0
operator|&&
name|tdsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_defunct
operator|==
literal|0
condition|)
block|{
operator|*
name|dspp
operator|=
name|tdsp
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tdsp
operator|=
name|TAILQ_NEXT
argument_list|(
name|tdsp
argument_list|,
name|nfsclds_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdsp
operator|!=
name|NULL
operator|&&
name|tdsp
operator|->
name|nfsclds_sockp
operator|!=
name|NULL
condition|)
name|msad6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|tdsp
operator|->
name|nfsclds_sockp
operator|->
name|nr_nam
expr_stmt|;
else|else
name|msad6
operator|=
name|NULL
expr_stmt|;
block|}
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
comment|/* No IP address match, so look for new/trunked one. */
name|sad6
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sad6
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sad6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sad6
argument_list|)
expr_stmt|;
name|sad6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sad6
operator|->
name|sin6_port
operator|=
name|ssd6
operator|->
name|sin6_port
expr_stmt|;
name|NFSBCOPY
argument_list|(
operator|&
name|ssd6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|sad6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|nrp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nrp
argument_list|)
argument_list|,
name|M_NFSSOCKREQ
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|nrp
operator|->
name|nr_nam
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sad6
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EPERM
operator|)
return|;
name|nrp
operator|->
name|nr_sotype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nrp
operator|->
name|nr_mtx
argument_list|,
literal|"nfssock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|nrp
operator|->
name|nr_prog
operator|=
name|NFS_PROG
expr_stmt|;
name|nrp
operator|->
name|nr_vers
operator|=
name|NFS_VER4
expr_stmt|;
comment|/* 	 * Use the credentials that were used for the mount, which are 	 * in nmp->nm_sockreq.nr_cred for newnfs_connect() etc. 	 * Ref. counting the credentials with crhold() is probably not 	 * necessary, since nm_sockreq.nr_cred won't be crfree()'d until 	 * unmount, but I did it anyhow. 	 */
name|nrp
operator|->
name|nr_cred
operator|=
name|crhold
argument_list|(
name|nmp
operator|->
name|nm_sockreq
operator|.
name|nr_cred
argument_list|)
expr_stmt|;
name|error
operator|=
name|newnfs_connect
argument_list|(
name|nmp
argument_list|,
name|nrp
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"DS connect=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Now, do the exchangeid and create session. */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|nfsrpc_exchangeid
argument_list|(
name|nmp
argument_list|,
name|clp
argument_list|,
name|nrp
argument_list|,
name|NFSV4EXCH_USEPNFSDS
argument_list|,
operator|&
name|dsp
argument_list|,
name|nrp
operator|->
name|nr_cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"DS exchangeid=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|newnfs_disconnect
argument_list|(
name|nrp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dsp
operator|->
name|nfsclds_sockp
operator|=
name|nrp
expr_stmt|;
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|retv
operator|=
name|nfscl_getsameserver
argument_list|(
name|nmp
argument_list|,
name|dsp
argument_list|,
operator|&
name|tdsp
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"getsame ret=%d\n"
argument_list|,
name|retv
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
operator|==
name|NFSDSP_USETHISSESSION
condition|)
block|{
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
comment|/* 			 * If there is already a session for this server, 			 * use it. 			 */
operator|(
name|void
operator|)
name|newnfs_disconnect
argument_list|(
name|nrp
argument_list|)
expr_stmt|;
name|nfscl_freenfsclds
argument_list|(
name|dsp
argument_list|)
expr_stmt|;
operator|*
name|dspp
operator|=
name|tdsp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|retv
operator|==
name|NFSDSP_SEQTHISSESSION
condition|)
name|sequenceid
operator|=
name|tdsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_sequenceid
expr_stmt|;
else|else
name|sequenceid
operator|=
name|dsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_sequenceid
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrpc_createsession
argument_list|(
name|nmp
argument_list|,
operator|&
name|dsp
operator|->
name|nfsclds_sess
argument_list|,
name|nrp
argument_list|,
name|sequenceid
argument_list|,
literal|0
argument_list|,
name|nrp
operator|->
name|nr_cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSCL_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"DS createsess=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSFREECRED
argument_list|(
name|nrp
operator|->
name|nr_cred
argument_list|)
expr_stmt|;
name|NFSFREEMUTEX
argument_list|(
operator|&
name|nrp
operator|->
name|nr_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nrp
operator|->
name|nr_nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nrp
argument_list|,
name|M_NFSSOCKREQ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|NFSCL_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"add DS session\n"
argument_list|)
expr_stmt|;
comment|/* 		 * Put it at the end of the list. That way the list 		 * is ordered by when the entry was added. This matters 		 * since the one done first is the one that should be 		 * used for sequencid'ing any subsequent create sessions. 		 */
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nmp
operator|->
name|nm_sess
argument_list|,
name|dsp
argument_list|,
name|nfsclds_list
argument_list|)
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
operator|*
name|dspp
operator|=
name|dsp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsp
operator|!=
name|NULL
condition|)
block|{
name|newnfs_disconnect
argument_list|(
name|nrp
argument_list|)
expr_stmt|;
name|nfscl_freenfsclds
argument_list|(
name|dsp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the NFSv4.1 Reclaim Complete.  */
end_comment

begin_function
name|int
name|nfsrpc_reclaimcomplete
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_RECLAIMCOMPL
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_USEGSSNAME
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nmp
operator|->
name|nm_sockreq
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the slot tables for a session.  */
end_comment

begin_function
specifier|static
name|void
name|nfscl_initsessionslots
parameter_list|(
name|struct
name|nfsclsession
modifier|*
name|sep
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSV4_CBSLOTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sep
operator|->
name|nfsess_cbslots
index|[
name|i
index|]
operator|.
name|nfssl_reply
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|sep
operator|->
name|nfsess_cbslots
index|[
name|i
index|]
operator|.
name|nfssl_reply
argument_list|)
expr_stmt|;
name|NFSBZERO
argument_list|(
operator|&
name|sep
operator|->
name|nfsess_cbslots
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsslot
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|sep
operator|->
name|nfsess_slotseq
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|sep
operator|->
name|nfsess_slots
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to try and do an I/O operation via an NFSv4.1 Data Server (DS).  */
end_comment

begin_function
name|int
name|nfscl_doiods
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
modifier|*
name|iomode
parameter_list|,
name|int
modifier|*
name|must_commit
parameter_list|,
name|uint32_t
name|rwaccess
parameter_list|,
name|int
name|docommit
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfscllayout
modifier|*
name|layp
decl_stmt|;
name|struct
name|nfscldevinfo
modifier|*
name|dip
decl_stmt|;
name|struct
name|nfsclflayout
modifier|*
name|rflp
decl_stmt|;
name|nfsv4stateid_t
name|stateid
decl_stmt|;
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|;
name|uint64_t
name|lastbyte
decl_stmt|,
name|len
decl_stmt|,
name|off
decl_stmt|,
name|oresid
decl_stmt|,
name|xfer
decl_stmt|;
name|int
name|eof
decl_stmt|,
name|error
decl_stmt|,
name|iolaymode
decl_stmt|,
name|recalled
decl_stmt|;
name|void
modifier|*
name|lckp
decl_stmt|;
if|if
condition|(
operator|!
name|NFSHASPNFS
argument_list|(
name|nmp
argument_list|)
operator|||
name|nfscl_enablecallb
operator|==
literal|0
operator|||
name|nfs_numnfscbd
operator|==
literal|0
operator|||
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NNOLAYOUT
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Now, get a reference cnt on the clientid for this mount. */
if|if
condition|(
name|nfscl_getref
argument_list|(
name|nmp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Find an appropriate stateid. */
name|newcred
operator|=
name|NFSNEWCRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_getstateid
argument_list|(
name|vp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|rwaccess
argument_list|,
literal|1
argument_list|,
name|newcred
argument_list|,
name|p
argument_list|,
operator|&
name|stateid
argument_list|,
operator|&
name|lckp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|NFSFREECRED
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
name|nfscl_relref
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Search for a layout for this file. */
name|off
operator|=
name|uiop
operator|->
name|uio_offset
expr_stmt|;
name|layp
operator|=
name|nfscl_getlayout
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|,
name|off
argument_list|,
operator|&
name|rflp
argument_list|,
operator|&
name|recalled
argument_list|)
expr_stmt|;
if|if
condition|(
name|layp
operator|==
name|NULL
operator|||
name|rflp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|recalled
operator|!=
literal|0
condition|)
block|{
name|NFSFREECRED
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
name|nfscl_relref
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|layp
operator|!=
name|NULL
condition|)
block|{
name|nfscl_rellayout
argument_list|(
name|layp
argument_list|,
operator|(
name|rflp
operator|==
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|layp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Try and get a Layout, if it is supported. */
if|if
condition|(
name|rwaccess
operator|==
name|NFSV4OPEN_ACCESSWRITE
operator|||
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NWRITEOPENED
operator|)
operator|!=
literal|0
condition|)
name|iolaymode
operator|=
name|NFSLAYOUTIOMODE_RW
expr_stmt|;
else|else
name|iolaymode
operator|=
name|NFSLAYOUTIOMODE_READ
expr_stmt|;
name|error
operator|=
name|nfsrpc_getlayout
argument_list|(
name|nmp
argument_list|,
name|vp
argument_list|,
name|np
operator|->
name|n_fhp
argument_list|,
name|iolaymode
argument_list|,
name|NULL
argument_list|,
operator|&
name|stateid
argument_list|,
name|off
argument_list|,
operator|&
name|layp
argument_list|,
name|newcred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|NFSLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_flag
operator||=
name|NNOLAYOUT
expr_stmt|;
name|NFSUNLOCKNODE
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|lckp
operator|!=
name|NULL
condition|)
name|nfscl_lockderef
argument_list|(
name|lckp
argument_list|)
expr_stmt|;
name|NFSFREECRED
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|layp
operator|!=
name|NULL
condition|)
name|nfscl_rellayout
argument_list|(
name|layp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nfscl_relref
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Loop around finding a layout that works for the first part of 	 * this I/O operation, and then call the function that actually 	 * does the RPC. 	 */
name|eof
operator|=
literal|0
expr_stmt|;
name|len
operator|=
operator|(
name|uint64_t
operator|)
name|uiop
operator|->
name|uio_resid
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|error
operator|==
literal|0
operator|&&
name|eof
operator|==
literal|0
condition|)
block|{
name|off
operator|=
name|uiop
operator|->
name|uio_offset
expr_stmt|;
name|error
operator|=
name|nfscl_findlayoutforio
argument_list|(
name|layp
argument_list|,
name|off
argument_list|,
name|rwaccess
argument_list|,
operator|&
name|rflp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|oresid
operator|=
name|xfer
operator|=
operator|(
name|uint64_t
operator|)
name|uiop
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|xfer
operator|>
operator|(
name|rflp
operator|->
name|nfsfl_end
operator|-
name|rflp
operator|->
name|nfsfl_off
operator|)
condition|)
name|xfer
operator|=
name|rflp
operator|->
name|nfsfl_end
operator|-
name|rflp
operator|->
name|nfsfl_off
expr_stmt|;
name|dip
operator|=
name|nfscl_getdevinfo
argument_list|(
name|nmp
operator|->
name|nm_clp
argument_list|,
name|rflp
operator|->
name|nfsfl_dev
argument_list|,
name|rflp
operator|->
name|nfsfl_devp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dip
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|nfscl_doflayoutio
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|iomode
argument_list|,
name|must_commit
argument_list|,
operator|&
name|eof
argument_list|,
operator|&
name|stateid
argument_list|,
name|rwaccess
argument_list|,
name|dip
argument_list|,
name|layp
argument_list|,
name|rflp
argument_list|,
name|off
argument_list|,
name|xfer
argument_list|,
name|docommit
argument_list|,
name|newcred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfscl_reldevinfo
argument_list|(
name|dip
argument_list|)
expr_stmt|;
name|lastbyte
operator|=
name|off
operator|+
name|xfer
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|lastbyte
operator|>
name|layp
operator|->
name|nfsly_lastbyte
condition|)
name|layp
operator|->
name|nfsly_lastbyte
operator|=
name|lastbyte
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|NFSERR_OPENMODE
operator|&&
name|rwaccess
operator|==
name|NFSV4OPEN_ACCESSREAD
condition|)
block|{
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_OPENMODE
expr_stmt|;
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|error
operator|=
name|EIO
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|len
operator|-=
operator|(
name|oresid
operator|-
operator|(
name|uint64_t
operator|)
name|uiop
operator|->
name|uio_resid
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lckp
operator|!=
name|NULL
condition|)
name|nfscl_lockderef
argument_list|(
name|lckp
argument_list|)
expr_stmt|;
name|NFSFREECRED
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
name|nfscl_rellayout
argument_list|(
name|layp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nfscl_relref
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a file layout that will handle the first bytes of the requested  * range and return the information from it needed to to the I/O operation.  */
end_comment

begin_function
name|int
name|nfscl_findlayoutforio
parameter_list|(
name|struct
name|nfscllayout
modifier|*
name|lyp
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint32_t
name|rwaccess
parameter_list|,
name|struct
name|nfsclflayout
modifier|*
modifier|*
name|retflpp
parameter_list|)
block|{
name|struct
name|nfsclflayout
modifier|*
name|flp
decl_stmt|,
modifier|*
name|nflp
decl_stmt|,
modifier|*
name|rflp
decl_stmt|;
name|uint32_t
name|rw
decl_stmt|;
name|rflp
operator|=
name|NULL
expr_stmt|;
name|rw
operator|=
name|rwaccess
expr_stmt|;
comment|/* For reading, do the Read list first and then the Write list. */
do|do
block|{
if|if
condition|(
name|rw
operator|==
name|NFSV4OPEN_ACCESSREAD
condition|)
name|flp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lyp
operator|->
name|nfsly_flayread
argument_list|)
expr_stmt|;
else|else
name|flp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lyp
operator|->
name|nfsly_flayrw
argument_list|)
expr_stmt|;
while|while
condition|(
name|flp
operator|!=
name|NULL
condition|)
block|{
name|nflp
operator|=
name|LIST_NEXT
argument_list|(
name|flp
argument_list|,
name|nfsfl_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|flp
operator|->
name|nfsfl_off
operator|>
name|off
condition|)
break|break;
if|if
condition|(
name|flp
operator|->
name|nfsfl_end
operator|>
name|off
operator|&&
operator|(
name|rflp
operator|==
name|NULL
operator|||
name|rflp
operator|->
name|nfsfl_end
operator|<
name|flp
operator|->
name|nfsfl_end
operator|)
condition|)
name|rflp
operator|=
name|flp
expr_stmt|;
name|flp
operator|=
name|nflp
expr_stmt|;
block|}
if|if
condition|(
name|rw
operator|==
name|NFSV4OPEN_ACCESSREAD
condition|)
name|rw
operator|=
name|NFSV4OPEN_ACCESSWRITE
expr_stmt|;
else|else
name|rw
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
name|rw
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|rflp
operator|!=
name|NULL
condition|)
block|{
comment|/* This one covers the most bytes starting at off. */
operator|*
name|retflpp
operator|=
name|rflp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do I/O using an NFSv4.1 file layout.  */
end_comment

begin_function
specifier|static
name|int
name|nfscl_doflayoutio
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
modifier|*
name|iomode
parameter_list|,
name|int
modifier|*
name|must_commit
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|int
name|rwflag
parameter_list|,
name|struct
name|nfscldevinfo
modifier|*
name|dp
parameter_list|,
name|struct
name|nfscllayout
modifier|*
name|lyp
parameter_list|,
name|struct
name|nfsclflayout
modifier|*
name|flp
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|int
name|docommit
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|uint64_t
name|io_off
decl_stmt|,
name|rel_off
decl_stmt|,
name|stripe_unit_size
decl_stmt|,
name|transfer
decl_stmt|,
name|xfer
decl_stmt|;
name|int
name|commit_thru_mds
decl_stmt|,
name|error
decl_stmt|,
name|stripe_index
decl_stmt|,
name|stripe_pos
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|fhp
decl_stmt|;
name|struct
name|nfsclds
modifier|*
modifier|*
name|dspp
decl_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|rel_off
operator|=
name|off
operator|-
name|flp
operator|->
name|nfsfl_patoff
expr_stmt|;
name|stripe_unit_size
operator|=
operator|(
name|flp
operator|->
name|nfsfl_util
operator|>>
literal|6
operator|)
operator|&
literal|0x3ffffff
expr_stmt|;
name|stripe_pos
operator|=
operator|(
name|rel_off
operator|/
name|stripe_unit_size
operator|+
name|flp
operator|->
name|nfsfl_stripe1
operator|)
operator|%
name|dp
operator|->
name|nfsdi_stripecnt
expr_stmt|;
name|transfer
operator|=
name|stripe_unit_size
operator|-
operator|(
name|rel_off
operator|%
name|stripe_unit_size
operator|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Loop around, doing I/O for each stripe unit. */
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|stripe_index
operator|=
name|nfsfldi_stripeindex
argument_list|(
name|dp
argument_list|,
name|stripe_pos
argument_list|)
expr_stmt|;
name|dspp
operator|=
name|nfsfldi_addr
argument_list|(
name|dp
argument_list|,
name|stripe_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|transfer
operator|&&
name|docommit
operator|==
literal|0
condition|)
name|xfer
operator|=
name|transfer
expr_stmt|;
else|else
name|xfer
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|flp
operator|->
name|nfsfl_util
operator|&
name|NFSFLAYUTIL_DENSE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Dense layout. */
if|if
condition|(
name|stripe_pos
operator|>=
name|flp
operator|->
name|nfsfl_fhcnt
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|fhp
operator|=
name|flp
operator|->
name|nfsfl_fh
index|[
name|stripe_pos
index|]
expr_stmt|;
name|io_off
operator|=
operator|(
name|rel_off
operator|/
operator|(
name|stripe_unit_size
operator|*
name|dp
operator|->
name|nfsdi_stripecnt
operator|)
operator|)
operator|*
name|stripe_unit_size
operator|+
name|rel_off
operator|%
name|stripe_unit_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Sparse layout. */
if|if
condition|(
name|flp
operator|->
name|nfsfl_fhcnt
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|stripe_index
operator|>=
name|flp
operator|->
name|nfsfl_fhcnt
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|fhp
operator|=
name|flp
operator|->
name|nfsfl_fh
index|[
name|stripe_index
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flp
operator|->
name|nfsfl_fhcnt
operator|==
literal|1
condition|)
name|fhp
operator|=
name|flp
operator|->
name|nfsfl_fh
index|[
literal|0
index|]
expr_stmt|;
else|else
name|fhp
operator|=
name|np
operator|->
name|n_fhp
expr_stmt|;
name|io_off
operator|=
name|off
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flp
operator|->
name|nfsfl_util
operator|&
name|NFSFLAYUTIL_COMMIT_THRU_MDS
operator|)
operator|!=
literal|0
condition|)
block|{
name|commit_thru_mds
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|docommit
operator|!=
literal|0
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
block|}
else|else
block|{
name|commit_thru_mds
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_flag
operator||=
name|NDSCOMMIT
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|docommit
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nfsrpc_commitds
argument_list|(
name|vp
argument_list|,
name|io_off
argument_list|,
name|xfer
argument_list|,
operator|*
name|dspp
argument_list|,
name|fhp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Set both eof and uio_resid = 0 to end any 				 * loops. 				 */
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NDSCOMMIT
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rwflag
operator|==
name|FREAD
condition|)
name|error
operator|=
name|nfsrpc_readds
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|stateidp
argument_list|,
name|eofp
argument_list|,
operator|*
name|dspp
argument_list|,
name|io_off
argument_list|,
name|xfer
argument_list|,
name|fhp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
block|{
name|error
operator|=
name|nfsrpc_writeds
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|iomode
argument_list|,
name|must_commit
argument_list|,
name|stateidp
argument_list|,
operator|*
name|dspp
argument_list|,
name|io_off
argument_list|,
name|xfer
argument_list|,
name|fhp
argument_list|,
name|commit_thru_mds
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|lyp
operator|->
name|nfsly_flags
operator||=
name|NFSLY_WRITTEN
expr_stmt|;
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|transfer
operator|=
name|stripe_unit_size
expr_stmt|;
name|stripe_pos
operator|=
operator|(
name|stripe_pos
operator|+
literal|1
operator|)
operator|%
name|dp
operator|->
name|nfsdi_stripecnt
expr_stmt|;
name|len
operator|-=
name|xfer
expr_stmt|;
name|off
operator|+=
name|xfer
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The actual read RPC done to a DS.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_readds
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|struct
name|nfsclds
modifier|*
name|dsp
parameter_list|,
name|uint64_t
name|io_off
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|nfsfh
modifier|*
name|fhp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
decl_stmt|,
name|retlen
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfssockreq
modifier|*
name|nrp
decl_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_READDS
argument_list|,
name|nmp
argument_list|,
name|fhp
operator|->
name|nfh_fh
argument_list|,
name|fhp
operator|->
name|nfh_len
argument_list|,
name|NULL
argument_list|,
operator|&
name|dsp
operator|->
name|nfsclds_sess
argument_list|)
expr_stmt|;
name|nfsm_stateidtom
argument_list|(
name|nd
argument_list|,
name|stateidp
argument_list|,
name|NFSSTATEID_PUTSEQIDZERO
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
operator|*
literal|3
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|io_off
argument_list|,
name|tl
argument_list|)
expr_stmt|;
operator|*
operator|(
name|tl
operator|+
literal|2
operator|)
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|nrp
operator|=
name|dsp
operator|->
name|nfsclds_sockp
expr_stmt|;
if|if
condition|(
name|nrp
operator|==
name|NULL
condition|)
comment|/* If NULL, use the MDS socket. */
name|nrp
operator|=
operator|&
name|nmp
operator|->
name|nm_sockreq
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
name|nrp
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|dsp
operator|->
name|nfsclds_sess
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|eofp
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|NFSM_STRSIZ
argument_list|(
name|retlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsm_mbufuio
argument_list|(
name|nd
argument_list|,
name|uiop
argument_list|,
name|retlen
argument_list|)
expr_stmt|;
name|nfsmout
label|:
if|if
condition|(
name|nd
operator|->
name|nd_mrep
operator|!=
name|NULL
condition|)
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The actual write RPC done to a DS.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_writeds
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
modifier|*
name|iomode
parameter_list|,
name|int
modifier|*
name|must_commit
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|struct
name|nfsclds
modifier|*
name|dsp
parameter_list|,
name|uint64_t
name|io_off
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|nfsfh
modifier|*
name|fhp
parameter_list|,
name|int
name|commit_thru_mds
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rlen
decl_stmt|,
name|commit
decl_stmt|,
name|committed
init|=
name|NFSWRITE_FILESYNC
decl_stmt|;
name|int32_t
name|backup
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|;
name|struct
name|nfsrv_descript
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfssockreq
modifier|*
name|nrp
decl_stmt|;
name|KASSERT
argument_list|(
name|uiop
operator|->
name|uio_iovcnt
operator|==
literal|1
argument_list|,
operator|(
literal|"nfs: writerpc iovcnt> 1"
operator|)
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_WRITEDS
argument_list|,
name|nmp
argument_list|,
name|fhp
operator|->
name|nfh_fh
argument_list|,
name|fhp
operator|->
name|nfh_len
argument_list|,
name|NULL
argument_list|,
operator|&
name|dsp
operator|->
name|nfsclds_sess
argument_list|)
expr_stmt|;
name|nfsm_stateidtom
argument_list|(
name|nd
argument_list|,
name|stateidp
argument_list|,
name|NFSSTATEID_PUTSEQIDZERO
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_HYPER
operator|+
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|io_off
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
operator|*
name|iomode
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|nfsm_uiombuf
argument_list|(
name|nd
argument_list|,
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nrp
operator|=
name|dsp
operator|->
name|nfsclds_sockp
expr_stmt|;
if|if
condition|(
name|nrp
operator|==
name|NULL
condition|)
comment|/* If NULL, use the MDS socket. */
name|nrp
operator|=
operator|&
name|nmp
operator|->
name|nm_sockreq
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
name|nrp
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|dsp
operator|->
name|nfsclds_sess
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * In case the rpc gets retried, roll 		 * the uio fileds changed by nfsm_uiombuf() 		 * back. 		 */
name|uiop
operator|->
name|uio_offset
operator|-=
name|len
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
operator|-
name|len
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
block|}
else|else
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
operator|+
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlen
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|NFSERR_IO
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
elseif|else
if|if
condition|(
name|rlen
operator|<
name|len
condition|)
block|{
name|backup
operator|=
name|len
operator|-
name|rlen
expr_stmt|;
name|uio_iov_base_add
argument_list|(
name|uiop
argument_list|,
operator|-
operator|(
name|backup
operator|)
argument_list|)
expr_stmt|;
name|uio_iov_len_add
argument_list|(
name|uiop
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|-=
name|backup
expr_stmt|;
name|uio_uio_resid_add
argument_list|(
name|uiop
argument_list|,
name|backup
argument_list|)
expr_stmt|;
name|len
operator|=
name|rlen
expr_stmt|;
block|}
name|commit
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
comment|/* 		 * Return the lowest committment level 		 * obtained by any of the RPCs. 		 */
if|if
condition|(
name|committed
operator|==
name|NFSWRITE_FILESYNC
condition|)
name|committed
operator|=
name|commit
expr_stmt|;
elseif|else
if|if
condition|(
name|committed
operator|==
name|NFSWRITE_DATASYNC
operator|&&
name|commit
operator|==
name|NFSWRITE_UNSTABLE
condition|)
name|committed
operator|=
name|commit
expr_stmt|;
if|if
condition|(
name|commit_thru_mds
operator|!=
literal|0
condition|)
block|{
name|NFSLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSHASWRITEVERF
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|NFSBCOPY
argument_list|(
name|tl
argument_list|,
name|nmp
operator|->
name|nm_verf
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|NFSSETWRITEVERF
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFSBCMP
argument_list|(
name|tl
argument_list|,
name|nmp
operator|->
name|nm_verf
argument_list|,
name|NFSX_VERF
argument_list|)
condition|)
block|{
operator|*
name|must_commit
operator|=
literal|1
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|tl
argument_list|,
name|nmp
operator|->
name|nm_verf
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
block|}
name|NFSUNLOCKMNT
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSLOCKDS
argument_list|(
name|dsp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dsp
operator|->
name|nfsclds_flags
operator|&
name|NFSCLDS_HASWRITEVERF
operator|)
operator|==
literal|0
condition|)
block|{
name|NFSBCOPY
argument_list|(
name|tl
argument_list|,
name|dsp
operator|->
name|nfsclds_verf
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|dsp
operator|->
name|nfsclds_flags
operator||=
name|NFSCLDS_HASWRITEVERF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFSBCMP
argument_list|(
name|tl
argument_list|,
name|dsp
operator|->
name|nfsclds_verf
argument_list|,
name|NFSX_VERF
argument_list|)
condition|)
block|{
operator|*
name|must_commit
operator|=
literal|1
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|tl
argument_list|,
name|dsp
operator|->
name|nfsclds_verf
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
block|}
name|NFSUNLOCKDS
argument_list|(
name|dsp
argument_list|)
expr_stmt|;
block|}
block|}
name|nfsmout
label|:
if|if
condition|(
name|nd
operator|->
name|nd_mrep
operator|!=
name|NULL
condition|)
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
operator|*
name|iomode
operator|=
name|committed
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free up the nfsclds structure.  */
end_comment

begin_function
name|void
name|nfscl_freenfsclds
parameter_list|(
name|struct
name|nfsclds
modifier|*
name|dsp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dsp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dsp
operator|->
name|nfsclds_sockp
operator|!=
name|NULL
condition|)
block|{
name|NFSFREECRED
argument_list|(
name|dsp
operator|->
name|nfsclds_sockp
operator|->
name|nr_cred
argument_list|)
expr_stmt|;
name|NFSFREEMUTEX
argument_list|(
operator|&
name|dsp
operator|->
name|nfsclds_sockp
operator|->
name|nr_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dsp
operator|->
name|nfsclds_sockp
operator|->
name|nr_nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dsp
operator|->
name|nfsclds_sockp
argument_list|,
name|M_NFSSOCKREQ
argument_list|)
expr_stmt|;
block|}
name|NFSFREEMUTEX
argument_list|(
operator|&
name|dsp
operator|->
name|nfsclds_mtx
argument_list|)
expr_stmt|;
name|NFSFREEMUTEX
argument_list|(
operator|&
name|dsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSV4_CBSLOTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_cbslots
index|[
name|i
index|]
operator|.
name|nfssl_reply
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|dsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_cbslots
index|[
name|i
index|]
operator|.
name|nfssl_reply
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dsp
argument_list|,
name|M_NFSCLDS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|nfsclds_state
name|nfscl_getsameserver
parameter_list|(
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|struct
name|nfsclds
modifier|*
name|newdsp
parameter_list|,
name|struct
name|nfsclds
modifier|*
modifier|*
name|retdspp
parameter_list|)
block|{
name|struct
name|nfsclds
modifier|*
name|dsp
decl_stmt|,
modifier|*
name|cur_dsp
decl_stmt|;
comment|/* 	 * Search the list of nfsclds structures for one with the same 	 * server. 	 */
name|cur_dsp
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|dsp
argument_list|,
argument|&nmp->nm_sess
argument_list|,
argument|nfsclds_list
argument_list|)
block|{
if|if
condition|(
name|dsp
operator|->
name|nfsclds_servownlen
operator|==
name|newdsp
operator|->
name|nfsclds_servownlen
operator|&&
name|dsp
operator|->
name|nfsclds_servownlen
operator|!=
literal|0
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|dsp
operator|->
name|nfsclds_serverown
argument_list|,
name|newdsp
operator|->
name|nfsclds_serverown
argument_list|,
name|dsp
operator|->
name|nfsclds_servownlen
argument_list|)
operator|&&
name|dsp
operator|->
name|nfsclds_sess
operator|.
name|nfsess_defunct
operator|==
literal|0
condition|)
block|{
name|NFSCL_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"fnd same fdsp=%p dsp=%p flg=0x%x\n"
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|nmp
operator|->
name|nm_sess
argument_list|)
argument_list|,
name|dsp
argument_list|,
name|dsp
operator|->
name|nfsclds_flags
argument_list|)
expr_stmt|;
comment|/* Server major id matches. */
if|if
condition|(
operator|(
name|dsp
operator|->
name|nfsclds_flags
operator|&
name|NFSCLDS_DS
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|retdspp
operator|=
name|dsp
expr_stmt|;
return|return
operator|(
name|NFSDSP_USETHISSESSION
operator|)
return|;
block|}
comment|/* 			 * Note the first match, so it can be used for 			 * sequence'ing new sessions. 			 */
if|if
condition|(
name|cur_dsp
operator|==
name|NULL
condition|)
name|cur_dsp
operator|=
name|dsp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur_dsp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|retdspp
operator|=
name|cur_dsp
expr_stmt|;
return|return
operator|(
name|NFSDSP_SEQTHISSESSION
operator|)
return|;
block|}
return|return
operator|(
name|NFSDSP_NOTFOUND
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NFS commit rpc to a NFSv4.1 DS.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrpc_commitds
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|cnt
parameter_list|,
name|struct
name|nfsclds
modifier|*
name|dsp
parameter_list|,
name|struct
name|nfsfh
modifier|*
name|fhp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|vp
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|nfssockreq
modifier|*
name|nrp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nd
operator|->
name|nd_mrep
operator|=
name|NULL
expr_stmt|;
name|nfscl_reqstart
argument_list|(
name|nd
argument_list|,
name|NFSPROC_COMMITDS
argument_list|,
name|nmp
argument_list|,
name|fhp
operator|->
name|nfh_fh
argument_list|,
name|fhp
operator|->
name|nfh_len
argument_list|,
name|NULL
argument_list|,
operator|&
name|dsp
operator|->
name|nfsclds_sess
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_HYPER
operator|+
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|offset
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
name|nrp
operator|=
name|dsp
operator|->
name|nfsclds_sockp
expr_stmt|;
if|if
condition|(
name|nrp
operator|==
name|NULL
condition|)
comment|/* If NULL, use the MDS socket. */
name|nrp
operator|=
operator|&
name|nmp
operator|->
name|nm_sockreq
expr_stmt|;
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|nmp
argument_list|,
name|NULL
argument_list|,
name|nrp
argument_list|,
name|vp
argument_list|,
name|p
argument_list|,
name|cred
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|dsp
operator|->
name|nfsclds_sess
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|NFSLOCKDS
argument_list|(
name|dsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSBCMP
argument_list|(
name|tl
argument_list|,
name|dsp
operator|->
name|nfsclds_verf
argument_list|,
name|NFSX_VERF
argument_list|)
condition|)
block|{
name|NFSBCOPY
argument_list|(
name|tl
argument_list|,
name|dsp
operator|->
name|nfsclds_verf
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|error
operator|=
name|NFSERR_STALEWRITEVERF
expr_stmt|;
block|}
name|NFSUNLOCKDS
argument_list|(
name|dsp
argument_list|)
expr_stmt|;
block|}
name|nfsmout
label|:
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

