begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * These functions support the macros and help fiddle mbuf chains for  * the nfs op functions. They do things like create the rpc header and  * copy data between mbuf chains and uio lists.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|APPLEKEXT
end_ifndef

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|nfsstats
name|newnfsstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsv4_opflag
name|nfsv4_opflag
index|[
name|NFSV41_NOPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ncl_mbuf_mlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|enum
name|vtype
name|newnv2tov_type
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|enum
name|vtype
name|nv34tov_type
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfs_bigreply
index|[
name|NFSV41_NPROCS
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NFSCLSTATEMUTEX
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APPLEKEXT */
end_comment

begin_decl_stmt
specifier|static
name|nfsuint64
name|nfs_nullcookie
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|int
name|op
decl_stmt|;
name|int
name|opcnt
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|tag
decl_stmt|;
name|int
name|taglen
decl_stmt|;
block|}
name|nfsv4_opmap
index|[
name|NFSV41_NPROCS
index|]
init|=
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|"Null"
block|,
literal|4
block|}
block|,
block|{
name|NFSV4OP_GETATTR
block|,
literal|1
block|,
literal|"Getattr"
block|,
literal|7
block|, }
block|,
block|{
name|NFSV4OP_SETATTR
block|,
literal|2
block|,
literal|"Setattr"
block|,
literal|7
block|, }
block|,
block|{
name|NFSV4OP_LOOKUP
block|,
literal|3
block|,
literal|"Lookup"
block|,
literal|6
block|, }
block|,
block|{
name|NFSV4OP_ACCESS
block|,
literal|2
block|,
literal|"Access"
block|,
literal|6
block|, }
block|,
block|{
name|NFSV4OP_READLINK
block|,
literal|2
block|,
literal|"Readlink"
block|,
literal|8
block|, }
block|,
block|{
name|NFSV4OP_READ
block|,
literal|1
block|,
literal|"Read"
block|,
literal|4
block|, }
block|,
block|{
name|NFSV4OP_WRITE
block|,
literal|2
block|,
literal|"Write"
block|,
literal|5
block|, }
block|,
block|{
name|NFSV4OP_OPEN
block|,
literal|5
block|,
literal|"Open"
block|,
literal|4
block|, }
block|,
block|{
name|NFSV4OP_CREATE
block|,
literal|5
block|,
literal|"Create"
block|,
literal|6
block|, }
block|,
block|{
name|NFSV4OP_CREATE
block|,
literal|1
block|,
literal|"Create"
block|,
literal|6
block|, }
block|,
block|{
name|NFSV4OP_CREATE
block|,
literal|3
block|,
literal|"Create"
block|,
literal|6
block|, }
block|,
block|{
name|NFSV4OP_REMOVE
block|,
literal|1
block|,
literal|"Remove"
block|,
literal|6
block|, }
block|,
block|{
name|NFSV4OP_REMOVE
block|,
literal|1
block|,
literal|"Remove"
block|,
literal|6
block|, }
block|,
block|{
name|NFSV4OP_SAVEFH
block|,
literal|5
block|,
literal|"Rename"
block|,
literal|6
block|, }
block|,
block|{
name|NFSV4OP_SAVEFH
block|,
literal|4
block|,
literal|"Link"
block|,
literal|4
block|, }
block|,
block|{
name|NFSV4OP_READDIR
block|,
literal|2
block|,
literal|"Readdir"
block|,
literal|7
block|, }
block|,
block|{
name|NFSV4OP_READDIR
block|,
literal|2
block|,
literal|"Readdir"
block|,
literal|7
block|, }
block|,
block|{
name|NFSV4OP_GETATTR
block|,
literal|1
block|,
literal|"Getattr"
block|,
literal|7
block|, }
block|,
block|{
name|NFSV4OP_GETATTR
block|,
literal|1
block|,
literal|"Getattr"
block|,
literal|7
block|, }
block|,
block|{
name|NFSV4OP_GETATTR
block|,
literal|1
block|,
literal|"Getattr"
block|,
literal|7
block|, }
block|,
block|{
name|NFSV4OP_COMMIT
block|,
literal|2
block|,
literal|"Commit"
block|,
literal|6
block|, }
block|,
block|{
name|NFSV4OP_LOOKUPP
block|,
literal|3
block|,
literal|"Lookupp"
block|,
literal|7
block|, }
block|,
block|{
name|NFSV4OP_SETCLIENTID
block|,
literal|1
block|,
literal|"SetClientID"
block|,
literal|11
block|, }
block|,
block|{
name|NFSV4OP_SETCLIENTIDCFRM
block|,
literal|1
block|,
literal|"SetClientIDConfirm"
block|,
literal|18
block|, }
block|,
block|{
name|NFSV4OP_LOCK
block|,
literal|1
block|,
literal|"Lock"
block|,
literal|4
block|, }
block|,
block|{
name|NFSV4OP_LOCKU
block|,
literal|1
block|,
literal|"LockU"
block|,
literal|5
block|, }
block|,
block|{
name|NFSV4OP_OPEN
block|,
literal|2
block|,
literal|"Open"
block|,
literal|4
block|, }
block|,
block|{
name|NFSV4OP_CLOSE
block|,
literal|1
block|,
literal|"Close"
block|,
literal|5
block|, }
block|,
block|{
name|NFSV4OP_OPENCONFIRM
block|,
literal|1
block|,
literal|"Openconfirm"
block|,
literal|11
block|, }
block|,
block|{
name|NFSV4OP_LOCKT
block|,
literal|1
block|,
literal|"LockT"
block|,
literal|5
block|, }
block|,
block|{
name|NFSV4OP_OPENDOWNGRADE
block|,
literal|1
block|,
literal|"Opendowngrade"
block|,
literal|13
block|, }
block|,
block|{
name|NFSV4OP_RENEW
block|,
literal|1
block|,
literal|"Renew"
block|,
literal|5
block|, }
block|,
block|{
name|NFSV4OP_PUTROOTFH
block|,
literal|1
block|,
literal|"Dirpath"
block|,
literal|7
block|, }
block|,
block|{
name|NFSV4OP_RELEASELCKOWN
block|,
literal|1
block|,
literal|"Rellckown"
block|,
literal|9
block|, }
block|,
block|{
name|NFSV4OP_DELEGRETURN
block|,
literal|1
block|,
literal|"Delegret"
block|,
literal|8
block|, }
block|,
block|{
name|NFSV4OP_DELEGRETURN
block|,
literal|3
block|,
literal|"DelegRemove"
block|,
literal|11
block|, }
block|,
block|{
name|NFSV4OP_DELEGRETURN
block|,
literal|7
block|,
literal|"DelegRename1"
block|,
literal|12
block|, }
block|,
block|{
name|NFSV4OP_DELEGRETURN
block|,
literal|9
block|,
literal|"DelegRename2"
block|,
literal|12
block|, }
block|,
block|{
name|NFSV4OP_GETATTR
block|,
literal|1
block|,
literal|"Getacl"
block|,
literal|6
block|, }
block|,
block|{
name|NFSV4OP_SETATTR
block|,
literal|1
block|,
literal|"Setacl"
block|,
literal|6
block|, }
block|,
block|{
name|NFSV4OP_EXCHANGEID
block|,
literal|1
block|,
literal|"ExchangeID"
block|,
literal|10
block|, }
block|,
block|{
name|NFSV4OP_CREATESESSION
block|,
literal|1
block|,
literal|"CreateSession"
block|,
literal|13
block|, }
block|,
block|{
name|NFSV4OP_DESTROYSESSION
block|,
literal|1
block|,
literal|"DestroySession"
block|,
literal|14
block|, }
block|,
block|{
name|NFSV4OP_DESTROYCLIENTID
block|,
literal|1
block|,
literal|"DestroyClient"
block|,
literal|13
block|, }
block|,
block|{
name|NFSV4OP_FREESTATEID
block|,
literal|1
block|,
literal|"FreeStateID"
block|,
literal|11
block|, }
block|,
block|{
name|NFSV4OP_LAYOUTGET
block|,
literal|1
block|,
literal|"LayoutGet"
block|,
literal|9
block|, }
block|,
block|{
name|NFSV4OP_GETDEVINFO
block|,
literal|1
block|,
literal|"GetDeviceInfo"
block|,
literal|13
block|, }
block|,
block|{
name|NFSV4OP_LAYOUTCOMMIT
block|,
literal|1
block|,
literal|"LayoutCommit"
block|,
literal|12
block|, }
block|,
block|{
name|NFSV4OP_LAYOUTRETURN
block|,
literal|1
block|,
literal|"LayoutReturn"
block|,
literal|12
block|, }
block|,
block|{
name|NFSV4OP_RECLAIMCOMPL
block|,
literal|1
block|,
literal|"ReclaimComplete"
block|,
literal|15
block|, }
block|,
block|{
name|NFSV4OP_WRITE
block|,
literal|1
block|,
literal|"WriteDS"
block|,
literal|7
block|, }
block|,
block|{
name|NFSV4OP_READ
block|,
literal|1
block|,
literal|"ReadDS"
block|,
literal|6
block|, }
block|,
block|{
name|NFSV4OP_COMMIT
block|,
literal|1
block|,
literal|"CommitDS"
block|,
literal|8
block|, }
block|, }
struct|;
end_struct

begin_comment
comment|/*  * NFS RPCS that have large request message size.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nfs_bigrequest
index|[
name|NFSV41_NPROCS
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Start building a request. Mostly just put the first file handle in  * place.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_reqstart
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|int
name|procnum
parameter_list|,
name|struct
name|nfsmount
modifier|*
name|nmp
parameter_list|,
name|u_int8_t
modifier|*
name|nfhp
parameter_list|,
name|int
name|fhlen
parameter_list|,
name|u_int32_t
modifier|*
modifier|*
name|opcntpp
parameter_list|,
name|struct
name|nfsclsession
modifier|*
name|sep
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|opcnt
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|;
comment|/* 	 * First, fill in some of the fields of nd. 	 */
name|nd
operator|->
name|nd_slotseq
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
condition|)
block|{
name|nd
operator|->
name|nd_flag
operator|=
name|ND_NFSV4
operator||
name|ND_NFSCL
expr_stmt|;
if|if
condition|(
name|NFSHASNFSV4N
argument_list|(
name|nmp
argument_list|)
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NFSV41
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFSHASNFSV3
argument_list|(
name|nmp
argument_list|)
condition|)
name|nd
operator|->
name|nd_flag
operator|=
name|ND_NFSV3
operator||
name|ND_NFSCL
expr_stmt|;
else|else
name|nd
operator|->
name|nd_flag
operator|=
name|ND_NFSV2
operator||
name|ND_NFSCL
expr_stmt|;
name|nd
operator|->
name|nd_procnum
operator|=
name|procnum
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get the first mbuf for the request. 	 */
if|if
condition|(
name|nfs_bigrequest
index|[
name|procnum
index|]
condition|)
name|NFSMCLGET
argument_list|(
name|mb
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|NFSMGET
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|mbuf_setlen
argument_list|(
name|mb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mreq
operator|=
name|nd
operator|->
name|nd_mb
operator|=
name|mb
expr_stmt|;
name|nd
operator|->
name|nd_bpos
operator|=
name|NFSMTOD
argument_list|(
name|mb
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* 	 * And fill the first file handle into the request. 	 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|opcnt
operator|=
name|nfsv4_opmap
index|[
name|procnum
index|]
operator|.
name|opcnt
operator|+
name|nfsv4_opflag
index|[
name|nfsv4_opmap
index|[
name|procnum
index|]
operator|.
name|op
index|]
operator|.
name|needscfh
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV41
operator|)
operator|!=
literal|0
condition|)
block|{
name|opcnt
operator|+=
name|nfsv4_opflag
index|[
name|nfsv4_opmap
index|[
name|procnum
index|]
operator|.
name|op
index|]
operator|.
name|needsseq
expr_stmt|;
if|if
condition|(
name|procnum
operator|==
name|NFSPROC_RENEW
condition|)
comment|/* 				 * For the special case of Renew, just do a 				 * Sequence Op. 				 */
name|opcnt
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|procnum
operator|==
name|NFSPROC_WRITEDS
operator|||
name|procnum
operator|==
name|NFSPROC_COMMITDS
condition|)
comment|/* 				 * For the special case of a Writeor Commit to 				 * a DS, the opcnt == 3, for Sequence, PutFH, 				 * Write/Commit. 				 */
name|opcnt
operator|=
literal|3
expr_stmt|;
block|}
comment|/* 		 * What should the tag really be? 		 */
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|nfsv4_opmap
index|[
name|procnum
index|]
operator|.
name|tag
argument_list|,
name|nfsv4_opmap
index|[
name|procnum
index|]
operator|.
name|taglen
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV41
operator|)
operator|!=
literal|0
condition|)
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV41_MINORVERSION
argument_list|)
expr_stmt|;
else|else
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4_MINORVERSION
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcntpp
operator|!=
name|NULL
condition|)
operator|*
name|opcntpp
operator|=
name|tl
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|opcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV41
operator|)
operator|!=
literal|0
operator|&&
name|nfsv4_opflag
index|[
name|nfsv4_opmap
index|[
name|procnum
index|]
operator|.
name|op
index|]
operator|.
name|needsseq
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nfsv4_opflag
index|[
name|nfsv4_opmap
index|[
name|procnum
index|]
operator|.
name|op
index|]
operator|.
name|loopbadsess
operator|>
literal|0
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_LOOPBADSESS
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_SEQUENCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|==
name|NULL
condition|)
block|{
name|sep
operator|=
name|nfsmnt_mdssession
argument_list|(
name|nmp
argument_list|)
expr_stmt|;
name|nfsv4_setsequence
argument_list|(
name|nmp
argument_list|,
name|nd
argument_list|,
name|sep
argument_list|,
name|nfs_bigreply
index|[
name|procnum
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|nfsv4_setsequence
argument_list|(
name|nmp
argument_list|,
name|nd
argument_list|,
name|sep
argument_list|,
name|nfs_bigreply
index|[
name|procnum
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfsv4_opflag
index|[
name|nfsv4_opmap
index|[
name|procnum
index|]
operator|.
name|op
index|]
operator|.
name|needscfh
operator|>
literal|0
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_PUTFH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfsv4_opflag
index|[
name|nfsv4_opmap
index|[
name|procnum
index|]
operator|.
name|op
index|]
operator|.
name|needscfh
operator|==
literal|2
operator|&&
name|procnum
operator|!=
name|NFSPROC_WRITEDS
operator|&&
name|procnum
operator|!=
name|NFSPROC_COMMITDS
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_GETATTR
argument_list|)
expr_stmt|;
comment|/* 				 * For Lookup Ops, we want all the directory 				 * attributes, so we can load the name cache. 				 */
if|if
condition|(
name|procnum
operator|==
name|NFSPROC_LOOKUP
operator|||
name|procnum
operator|==
name|NFSPROC_LOOKUPP
condition|)
name|NFSGETATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
else|else
block|{
name|NFSWCCATTR_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_flag
operator||=
name|ND_V4WCCATTR
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|procnum
operator|!=
name|NFSPROC_RENEW
operator|||
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV41
operator|)
operator|==
literal|0
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|nfsv4_opmap
index|[
name|procnum
index|]
operator|.
name|op
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
name|nfhp
argument_list|,
name|fhlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|procnum
operator|<
name|NFSV4_NPROCS
condition|)
name|NFSINCRGLOBAL
argument_list|(
name|newnfsstats
operator|.
name|rpccnt
index|[
name|procnum
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|APPLE
end_ifndef

begin_comment
comment|/*  * copies a uio scatter/gather list to an mbuf chain.  * NOTE: can ony handle iovcnt == 1  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsm_uiombuf
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
name|siz
parameter_list|)
block|{
name|char
modifier|*
name|uiocp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|,
modifier|*
name|mp2
decl_stmt|;
name|int
name|xfer
decl_stmt|,
name|left
decl_stmt|,
name|mlen
decl_stmt|;
name|int
name|uiosiz
decl_stmt|,
name|clflg
decl_stmt|,
name|rem
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tcp
decl_stmt|;
name|KASSERT
argument_list|(
name|uiop
operator|->
name|uio_iovcnt
operator|==
literal|1
argument_list|,
operator|(
literal|"nfsm_uiotombuf: iovcnt != 1"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|siz
operator|>
name|ncl_mbuf_mlen
condition|)
comment|/* or should it>= MCLBYTES ?? */
name|clflg
operator|=
literal|1
expr_stmt|;
else|else
name|clflg
operator|=
literal|0
expr_stmt|;
name|rem
operator|=
name|NFSM_RNDUP
argument_list|(
name|siz
argument_list|)
operator|-
name|siz
expr_stmt|;
name|mp
operator|=
name|mp2
operator|=
name|nd
operator|->
name|nd_mb
expr_stmt|;
while|while
condition|(
name|siz
operator|>
literal|0
condition|)
block|{
name|left
operator|=
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
expr_stmt|;
name|uiocp
operator|=
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
expr_stmt|;
if|if
condition|(
name|left
operator|>
name|siz
condition|)
name|left
operator|=
name|siz
expr_stmt|;
name|uiosiz
operator|=
name|left
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|mlen
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|clflg
condition|)
name|NFSMCLGET
argument_list|(
name|mp
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|NFSMGET
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mbuf_setlen
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mbuf_setnext
argument_list|(
name|mp2
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|mp2
operator|=
name|mp
expr_stmt|;
name|mlen
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|=
operator|(
name|left
operator|>
name|mlen
operator|)
condition|?
name|mlen
else|:
name|left
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* Not Yet.. */
if|if
condition|(
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_op
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_op
operator|)
operator|)
operator|(
name|uiocp
operator|,
name|NFSMTOD
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mbuf_len
argument_list|(
name|mp
argument_list|)
operator|,
name|xfer
operator|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|uiop
operator|->
name|uio_segflg
operator|==
name|UIO_SYSSPACE
condition|)
name|NFSBCOPY
argument_list|(
name|uiocp
argument_list|,
name|NFSMTOD
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mbuf_len
argument_list|(
name|mp
argument_list|)
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
else|else
name|copyin
argument_list|(
name|CAST_USER_ADDR_T
argument_list|(
name|uiocp
argument_list|)
argument_list|,
name|NFSMTOD
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mbuf_len
argument_list|(
name|mp
argument_list|)
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|mbuf_setlen
argument_list|(
name|mp
argument_list|,
name|mbuf_len
argument_list|(
name|mp
argument_list|)
operator|+
name|xfer
argument_list|)
expr_stmt|;
name|left
operator|-=
name|xfer
expr_stmt|;
name|uiocp
operator|+=
name|xfer
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|xfer
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|xfer
expr_stmt|;
block|}
name|tcp
operator|=
operator|(
name|char
operator|*
operator|)
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
expr_stmt|;
name|tcp
operator|+=
name|uiosiz
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
name|tcp
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|uiosiz
expr_stmt|;
name|siz
operator|-=
name|uiosiz
expr_stmt|;
block|}
if|if
condition|(
name|rem
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rem
operator|>
name|M_TRAILINGSPACE
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|NFSMGET
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mbuf_setlen
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mbuf_setnext
argument_list|(
name|mp2
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|NFSMTOD
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mbuf_len
argument_list|(
name|mp
argument_list|)
expr_stmt|;
for|for
control|(
name|left
operator|=
literal|0
init|;
name|left
operator|<
name|rem
condition|;
name|left
operator|++
control|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|mbuf_setlen
argument_list|(
name|mp
argument_list|,
name|mbuf_len
argument_list|(
name|mp
argument_list|)
operator|+
name|rem
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_bpos
operator|=
name|cp
expr_stmt|;
block|}
else|else
name|nd
operator|->
name|nd_bpos
operator|=
name|NFSMTOD
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mbuf_len
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mb
operator|=
name|mp
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APPLE */
end_comment

begin_comment
comment|/*  * Load vnode attributes from the xdr file attributes.  * Returns EBADRPC if they can't be parsed, 0 otherwise.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsm_loadattr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|)
block|{
name|struct
name|nfs_fattr
modifier|*
name|fp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
name|nap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|fp
argument_list|,
expr|struct
name|nfs_fattr
operator|*
argument_list|,
name|NFSX_V3FATTR
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_type
operator|=
name|nfsv34tov_type
argument_list|(
name|fp
operator|->
name|fa_type
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_mode
operator|=
name|fxdr_unsigned
argument_list|(
name|u_short
argument_list|,
name|fp
operator|->
name|fa_mode
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_rdev
operator|=
name|makedev
argument_list|(
name|fxdr_unsigned
argument_list|(
name|u_char
argument_list|,
name|fp
operator|->
name|fa3_rdev
operator|.
name|specdata1
argument_list|)
argument_list|,
name|fxdr_unsigned
argument_list|(
name|u_char
argument_list|,
name|fp
operator|->
name|fa3_rdev
operator|.
name|specdata2
argument_list|)
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_nlink
operator|=
name|fxdr_unsigned
argument_list|(
name|u_short
argument_list|,
name|fp
operator|->
name|fa_nlink
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_uid
operator|=
name|fxdr_unsigned
argument_list|(
name|uid_t
argument_list|,
name|fp
operator|->
name|fa_uid
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_gid
operator|=
name|fxdr_unsigned
argument_list|(
name|gid_t
argument_list|,
name|fp
operator|->
name|fa_gid
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_size
operator|=
name|fxdr_hyper
argument_list|(
operator|&
name|fp
operator|->
name|fa3_size
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_blocksize
operator|=
name|NFS_FABLKSIZE
expr_stmt|;
name|nap
operator|->
name|na_bytes
operator|=
name|fxdr_hyper
argument_list|(
operator|&
name|fp
operator|->
name|fa3_used
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_fileid
operator|=
name|fxdr_hyper
argument_list|(
operator|&
name|fp
operator|->
name|fa3_fileid
argument_list|)
expr_stmt|;
name|fxdr_nfsv3time
argument_list|(
operator|&
name|fp
operator|->
name|fa3_atime
argument_list|,
operator|&
name|nap
operator|->
name|na_atime
argument_list|)
expr_stmt|;
name|fxdr_nfsv3time
argument_list|(
operator|&
name|fp
operator|->
name|fa3_ctime
argument_list|,
operator|&
name|nap
operator|->
name|na_ctime
argument_list|)
expr_stmt|;
name|fxdr_nfsv3time
argument_list|(
operator|&
name|fp
operator|->
name|fa3_mtime
argument_list|,
operator|&
name|nap
operator|->
name|na_mtime
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_flags
operator|=
literal|0
expr_stmt|;
name|nap
operator|->
name|na_filerev
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|NFSM_DISSECT
argument_list|(
name|fp
argument_list|,
expr|struct
name|nfs_fattr
operator|*
argument_list|,
name|NFSX_V2FATTR
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_type
operator|=
name|nfsv2tov_type
argument_list|(
name|fp
operator|->
name|fa_type
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_mode
operator|=
name|fxdr_unsigned
argument_list|(
name|u_short
argument_list|,
name|fp
operator|->
name|fa_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|nap
operator|->
name|na_type
operator|==
name|VNON
operator|||
name|nap
operator|->
name|na_type
operator|==
name|VREG
condition|)
name|nap
operator|->
name|na_type
operator|=
name|IFTOVT
argument_list|(
name|nap
operator|->
name|na_mode
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_rdev
operator|=
name|fxdr_unsigned
argument_list|(
name|dev_t
argument_list|,
name|fp
operator|->
name|fa2_rdev
argument_list|)
expr_stmt|;
comment|/* 		 * Really ugly NFSv2 kludge. 		 */
if|if
condition|(
name|nap
operator|->
name|na_type
operator|==
name|VCHR
operator|&&
name|nap
operator|->
name|na_rdev
operator|==
operator|(
operator|(
name|dev_t
operator|)
operator|-
literal|1
operator|)
condition|)
name|nap
operator|->
name|na_type
operator|=
name|VFIFO
expr_stmt|;
name|nap
operator|->
name|na_nlink
operator|=
name|fxdr_unsigned
argument_list|(
name|u_short
argument_list|,
name|fp
operator|->
name|fa_nlink
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_uid
operator|=
name|fxdr_unsigned
argument_list|(
name|uid_t
argument_list|,
name|fp
operator|->
name|fa_uid
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_gid
operator|=
name|fxdr_unsigned
argument_list|(
name|gid_t
argument_list|,
name|fp
operator|->
name|fa_gid
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_size
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
name|fp
operator|->
name|fa2_size
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_blocksize
operator|=
name|fxdr_unsigned
argument_list|(
name|int32_t
argument_list|,
name|fp
operator|->
name|fa2_blocksize
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_bytes
operator|=
operator|(
name|u_quad_t
operator|)
name|fxdr_unsigned
argument_list|(
name|int32_t
argument_list|,
name|fp
operator|->
name|fa2_blocks
argument_list|)
operator|*
name|NFS_FABLKSIZE
expr_stmt|;
name|nap
operator|->
name|na_fileid
operator|=
name|fxdr_unsigned
argument_list|(
name|uint64_t
argument_list|,
name|fp
operator|->
name|fa2_fileid
argument_list|)
expr_stmt|;
name|fxdr_nfsv2time
argument_list|(
operator|&
name|fp
operator|->
name|fa2_atime
argument_list|,
operator|&
name|nap
operator|->
name|na_atime
argument_list|)
expr_stmt|;
name|fxdr_nfsv2time
argument_list|(
operator|&
name|fp
operator|->
name|fa2_mtime
argument_list|,
operator|&
name|nap
operator|->
name|na_mtime
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_flags
operator|=
literal|0
expr_stmt|;
name|nap
operator|->
name|na_ctime
operator|.
name|tv_sec
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
name|fp
operator|->
name|fa2_ctime
operator|.
name|nfsv2_sec
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_ctime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|nap
operator|->
name|na_gen
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
name|fp
operator|->
name|fa2_ctime
operator|.
name|nfsv2_usec
argument_list|)
expr_stmt|;
name|nap
operator|->
name|na_filerev
operator|=
literal|0
expr_stmt|;
block|}
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function finds the directory cookie that corresponds to the  * logical byte offset given.  */
end_comment

begin_function
name|APPLESTATIC
name|nfsuint64
modifier|*
name|nfscl_getcookie
parameter_list|(
name|struct
name|nfsnode
modifier|*
name|np
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
name|add
parameter_list|)
block|{
name|struct
name|nfsdmap
modifier|*
name|dp
decl_stmt|,
modifier|*
name|dp2
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|pos
operator|=
name|off
operator|/
name|NFS_DIRBLKSIZ
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|add
argument_list|,
operator|(
literal|"nfs getcookie add at 0"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|nfs_nullcookie
operator|)
return|;
block|}
name|pos
operator|--
expr_stmt|;
name|dp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|np
operator|->
name|n_cookies
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
block|{
if|if
condition|(
name|add
condition|)
block|{
name|MALLOC
argument_list|(
name|dp
argument_list|,
expr|struct
name|nfsdmap
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsdmap
argument_list|)
argument_list|,
name|M_NFSDIROFF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|dp
operator|->
name|ndm_eocookie
operator|=
literal|0
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|np
operator|->
name|n_cookies
argument_list|,
name|dp
argument_list|,
name|ndm_list
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
while|while
condition|(
name|pos
operator|>=
name|NFSNUMCOOKIES
condition|)
block|{
name|pos
operator|-=
name|NFSNUMCOOKIES
expr_stmt|;
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|dp
argument_list|,
name|ndm_list
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|add
operator|&&
name|dp
operator|->
name|ndm_eocookie
operator|<
name|NFSNUMCOOKIES
operator|&&
name|pos
operator|>=
name|dp
operator|->
name|ndm_eocookie
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dp
operator|=
name|LIST_NEXT
argument_list|(
name|dp
argument_list|,
name|ndm_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|add
condition|)
block|{
name|MALLOC
argument_list|(
name|dp2
argument_list|,
expr|struct
name|nfsdmap
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsdmap
argument_list|)
argument_list|,
name|M_NFSDIROFF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|dp2
operator|->
name|ndm_eocookie
operator|=
literal|0
expr_stmt|;
name|LIST_INSERT_AFTER
argument_list|(
name|dp
argument_list|,
name|dp2
argument_list|,
name|ndm_list
argument_list|)
expr_stmt|;
name|dp
operator|=
name|dp2
expr_stmt|;
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|pos
operator|>=
name|dp
operator|->
name|ndm_eocookie
condition|)
block|{
if|if
condition|(
name|add
condition|)
name|dp
operator|->
name|ndm_eocookie
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
operator|&
name|dp
operator|->
name|ndm_cookies
index|[
name|pos
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Gets a file handle out of an nfs reply sent to the client and returns  * the file handle and the file's attributes.  * For V4, it assumes that Getfh and Getattr Op's results are here.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfscl_mtofh
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsfh
modifier|*
modifier|*
name|nfhpp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|int
modifier|*
name|attrflagp
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|flag
init|=
literal|1
decl_stmt|;
operator|*
name|nfhpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|attrflagp
operator|=
literal|0
expr_stmt|;
comment|/* 	 * First get the file handle and vnode. 	 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|flag
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
condition|)
block|{
name|error
operator|=
name|nfsm_getfh
argument_list|(
name|nd
argument_list|,
name|nfhpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Now, get the attributes. 	 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|flag
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
condition|)
block|{
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSX_V3FATTR
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|flag
condition|)
block|{
name|error
operator|=
name|nfsm_loadattr
argument_list|(
name|nd
argument_list|,
name|nap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|*
name|attrflagp
operator|=
literal|1
expr_stmt|;
block|}
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put a state Id in the mbuf list.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsm_stateidtom
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|nfsv4stateid_t
modifier|*
name|st
decl_stmt|;
name|NFSM_BUILD
argument_list|(
name|st
argument_list|,
name|nfsv4stateid_t
operator|*
argument_list|,
name|NFSX_STATEID
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|NFSSTATEID_PUTALLZERO
condition|)
block|{
name|st
operator|->
name|seqid
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|other
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|other
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|other
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|==
name|NFSSTATEID_PUTALLONE
condition|)
block|{
name|st
operator|->
name|seqid
operator|=
literal|0xffffffff
expr_stmt|;
name|st
operator|->
name|other
index|[
literal|0
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|st
operator|->
name|other
index|[
literal|1
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|st
operator|->
name|other
index|[
literal|2
index|]
operator|=
literal|0xffffffff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flag
operator|==
name|NFSSTATEID_PUTSEQIDZERO
condition|)
block|{
name|st
operator|->
name|seqid
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
expr_stmt|;
name|st
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
expr_stmt|;
name|st
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|seqid
operator|=
name|stateidp
operator|->
name|seqid
expr_stmt|;
name|st
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
expr_stmt|;
name|st
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
expr_stmt|;
name|st
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize the owner/delegation sleep lock.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_lockinit
parameter_list|(
name|struct
name|nfsv4lock
modifier|*
name|lckp
parameter_list|)
block|{
name|lckp
operator|->
name|nfslock_usecnt
operator|=
literal|0
expr_stmt|;
name|lckp
operator|->
name|nfslock_lock
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get an exclusive lock. (Not needed for OpenBSD4, since there is only one  * thread for each posix process in the kernel.)  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_lockexcl
parameter_list|(
name|struct
name|nfsv4lock
modifier|*
name|lckp
parameter_list|,
name|void
modifier|*
name|mutex
parameter_list|)
block|{
name|int
name|igotlock
decl_stmt|;
do|do
block|{
name|igotlock
operator|=
name|nfsv4_lock
argument_list|(
name|lckp
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|igotlock
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Release an exclusive lock.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_lockunlock
parameter_list|(
name|struct
name|nfsv4lock
modifier|*
name|lckp
parameter_list|)
block|{
name|nfsv4_unlock
argument_list|(
name|lckp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called to derefernce a lock on a stateid (delegation or open owner).  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfscl_lockderef
parameter_list|(
name|struct
name|nfsv4lock
modifier|*
name|lckp
parameter_list|)
block|{
name|NFSLOCKCLSTATE
argument_list|()
expr_stmt|;
name|lckp
operator|->
name|nfslock_usecnt
operator|--
expr_stmt|;
if|if
condition|(
name|lckp
operator|->
name|nfslock_usecnt
operator|==
literal|0
operator|&&
operator|(
name|lckp
operator|->
name|nfslock_lock
operator|&
name|NFSV4LOCK_WANTED
operator|)
condition|)
block|{
name|lckp
operator|->
name|nfslock_lock
operator|&=
operator|~
name|NFSV4LOCK_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|lckp
argument_list|)
expr_stmt|;
block|}
name|NFSUNLOCKCLSTATE
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

