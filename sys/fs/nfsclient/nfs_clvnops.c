begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from nfs_vnops.c	8.16 (Berkeley) 5/27/95  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * vnode op calls for Sun NFS version 2, 3 and 4  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockf.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_include
include|#
directive|include
file|<fs/nfsclient/nfsnode.h>
end_include

begin_include
include|#
directive|include
file|<fs/nfsclient/nfsmount.h>
end_include

begin_include
include|#
directive|include
file|<fs/nfsclient/nfs.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfs_lock.h>
end_include

begin_comment
comment|/* Defs */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_decl_stmt
specifier|extern
name|struct
name|nfsstats
name|newnfsstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_useacl
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DECLARE
argument_list|(
name|M_NEWNFSREQ
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Ifdef for FreeBSD-current merged buffer cache. It is unfortunate that these  * calls are not in getblk() and brelse() so that they would not be necessary  * here.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|B_VMIO
end_ifndef

begin_define
define|#
directive|define
name|vfs_busy_pages
parameter_list|(
name|bp
parameter_list|,
name|f
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|vop_read_t
name|nfsfifo_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_write_t
name|nfsfifo_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_close_t
name|nfsfifo_close
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|nfs_setattrrpc
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|vattr
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|vop_lookup_t
name|nfs_lookup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_create_t
name|nfs_create
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_mknod_t
name|nfs_mknod
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_open_t
name|nfs_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_pathconf_t
name|nfs_pathconf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_close_t
name|nfs_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_access_t
name|nfs_access
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_getattr_t
name|nfs_getattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_setattr_t
name|nfs_setattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_read_t
name|nfs_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_fsync_t
name|nfs_fsync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_remove_t
name|nfs_remove
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_link_t
name|nfs_link
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_rename_t
name|nfs_rename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_mkdir_t
name|nfs_mkdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_rmdir_t
name|nfs_rmdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_symlink_t
name|nfs_symlink
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_readdir_t
name|nfs_readdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_strategy_t
name|nfs_strategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_lock1_t
name|nfs_lock1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|nfs_lookitup
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|nfsnode
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_sillyrename
parameter_list|(
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|componentname
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|vop_access_t
name|nfsspec_access
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_readlink_t
name|nfs_readlink
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_print_t
name|nfs_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_advlock_t
name|nfs_advlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_advlockasync_t
name|nfs_advlockasync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_getacl_t
name|nfs_getacl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vop_setacl_t
name|nfs_setacl
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Global vfs data structures for nfs  */
end_comment

begin_decl_stmt
name|struct
name|vop_vector
name|newnfs_vnodeops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|default_vnodeops
block|,
operator|.
name|vop_access
operator|=
name|nfs_access
block|,
operator|.
name|vop_advlock
operator|=
name|nfs_advlock
block|,
operator|.
name|vop_advlockasync
operator|=
name|nfs_advlockasync
block|,
operator|.
name|vop_close
operator|=
name|nfs_close
block|,
operator|.
name|vop_create
operator|=
name|nfs_create
block|,
operator|.
name|vop_fsync
operator|=
name|nfs_fsync
block|,
operator|.
name|vop_getattr
operator|=
name|nfs_getattr
block|,
operator|.
name|vop_getpages
operator|=
name|ncl_getpages
block|,
operator|.
name|vop_putpages
operator|=
name|ncl_putpages
block|,
operator|.
name|vop_inactive
operator|=
name|ncl_inactive
block|,
operator|.
name|vop_link
operator|=
name|nfs_link
block|,
operator|.
name|vop_lock1
operator|=
name|nfs_lock1
block|,
operator|.
name|vop_lookup
operator|=
name|nfs_lookup
block|,
operator|.
name|vop_mkdir
operator|=
name|nfs_mkdir
block|,
operator|.
name|vop_mknod
operator|=
name|nfs_mknod
block|,
operator|.
name|vop_open
operator|=
name|nfs_open
block|,
operator|.
name|vop_pathconf
operator|=
name|nfs_pathconf
block|,
operator|.
name|vop_print
operator|=
name|nfs_print
block|,
operator|.
name|vop_read
operator|=
name|nfs_read
block|,
operator|.
name|vop_readdir
operator|=
name|nfs_readdir
block|,
operator|.
name|vop_readlink
operator|=
name|nfs_readlink
block|,
operator|.
name|vop_reclaim
operator|=
name|ncl_reclaim
block|,
operator|.
name|vop_remove
operator|=
name|nfs_remove
block|,
operator|.
name|vop_rename
operator|=
name|nfs_rename
block|,
operator|.
name|vop_rmdir
operator|=
name|nfs_rmdir
block|,
operator|.
name|vop_setattr
operator|=
name|nfs_setattr
block|,
operator|.
name|vop_strategy
operator|=
name|nfs_strategy
block|,
operator|.
name|vop_symlink
operator|=
name|nfs_symlink
block|,
operator|.
name|vop_write
operator|=
name|ncl_write
block|,
operator|.
name|vop_getacl
operator|=
name|nfs_getacl
block|,
operator|.
name|vop_setacl
operator|=
name|nfs_setacl
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vop_vector
name|newnfs_fifoops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|fifo_specops
block|,
operator|.
name|vop_access
operator|=
name|nfsspec_access
block|,
operator|.
name|vop_close
operator|=
name|nfsfifo_close
block|,
operator|.
name|vop_fsync
operator|=
name|nfs_fsync
block|,
operator|.
name|vop_getattr
operator|=
name|nfs_getattr
block|,
operator|.
name|vop_inactive
operator|=
name|ncl_inactive
block|,
operator|.
name|vop_print
operator|=
name|nfs_print
block|,
operator|.
name|vop_read
operator|=
name|nfsfifo_read
block|,
operator|.
name|vop_reclaim
operator|=
name|ncl_reclaim
block|,
operator|.
name|vop_setattr
operator|=
name|nfs_setattr
block|,
operator|.
name|vop_write
operator|=
name|nfsfifo_write
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|nfs_mknodrpc
parameter_list|(
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_removerpc
parameter_list|(
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_renamerpc
parameter_list|(
name|struct
name|vnode
modifier|*
name|fdvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|fvp
parameter_list|,
name|char
modifier|*
name|fnameptr
parameter_list|,
name|int
name|fnamelen
parameter_list|,
name|struct
name|vnode
modifier|*
name|tdvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|tvp
parameter_list|,
name|char
modifier|*
name|tnameptr
parameter_list|,
name|int
name|tnamelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfs_renameit
parameter_list|(
name|struct
name|vnode
modifier|*
name|sdvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|svp
parameter_list|,
name|struct
name|componentname
modifier|*
name|scnp
parameter_list|,
name|struct
name|sillyrename
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Global variables  */
end_comment

begin_define
define|#
directive|define
name|DIRHDSIZ
value|(sizeof (struct dirent) - (MAXNAMLEN + 1))
end_define

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_newnfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsaccess_cache_timeout
init|=
name|NFS_MAXATTRTIMO
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_newnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|access_cache_timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfsaccess_cache_timeout
argument_list|,
literal|0
argument_list|,
literal|"NFS ACCESS cache timeout"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_prime_access_cache
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_newnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|prime_access_cache
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_prime_access_cache
argument_list|,
literal|0
argument_list|,
literal|"Prime NFS ACCESS cache when fetching attributes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|newnfs_commit_on_close
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_newnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|commit_on_close
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|newnfs_commit_on_close
argument_list|,
literal|0
argument_list|,
literal|"write+commit on close, else only write"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_clean_pages_on_close
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_newnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|clean_pages_on_close
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_clean_pages_on_close
argument_list|,
literal|0
argument_list|,
literal|"NFS clean dirty pages on close"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|newnfs_directio_enable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_newnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|nfs_directio_enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|newnfs_directio_enable
argument_list|,
literal|0
argument_list|,
literal|"Enable NFS directio"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This sysctl allows other processes to mmap a file that has been opened  * O_DIRECT by a process.  In general, having processes mmap the file while  * Direct IO is in progress can lead to Data Inconsistencies.  But, we allow  * this by default to prevent DoS attacks - to prevent a malicious user from  * opening up files O_DIRECT preventing other users from mmap'ing these  * files.  "Protected" environments where stricter consistency guarantees are  * required can disable this knob.  The process that opened the file O_DIRECT  * cannot mmap() the file, because mmap'ed IO on an O_DIRECT open() is not  * meaningful.  */
end_comment

begin_decl_stmt
name|int
name|newnfs_directio_allow_mmap
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_newnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|nfs_directio_allow_mmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|newnfs_directio_allow_mmap
argument_list|,
literal|0
argument_list|,
literal|"Enable mmaped IO on file with O_DIRECT opens"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|SYSCTL_INT(_vfs_newnfs, OID_AUTO, access_cache_hits, CTLFLAG_RD,&newnfsstats.accesscache_hits, 0, "NFS ACCESS cache hit count");  SYSCTL_INT(_vfs_newnfs, OID_AUTO, access_cache_misses, CTLFLAG_RD,&newnfsstats.accesscache_misses, 0, "NFS ACCESS cache miss count");
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NFSACCESS_ALL
value|(NFSACCESS_READ | NFSACCESS_MODIFY		\ 			 | NFSACCESS_EXTEND | NFSACCESS_EXECUTE	\ 			 | NFSACCESS_DELETE | NFSACCESS_LOOKUP)
end_define

begin_comment
comment|/*  * SMP Locking Note :  * The list of locks after the description of the lock is the ordering  * of other locks acquired with the lock held.  * np->n_mtx : Protects the fields in the nfsnode.        VM Object Lock        VI_MTX (acquired indirectly)  * nmp->nm_mtx : Protects the fields in the nfsmount.        rep->r_mtx  * ncl_iod_mutex : Global lock, protects shared nfsiod state.  * nfs_reqq_mtx : Global lock, protects the nfs_reqq list.        nmp->nm_mtx        rep->r_mtx  * rep->r_mtx : Protects the fields in an nfsreq.  */
end_comment

begin_function
specifier|static
name|int
name|nfs34_access_otw
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|wmode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|u_int32_t
modifier|*
name|retmode
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|,
name|attrflag
decl_stmt|,
name|i
decl_stmt|,
name|lrupos
decl_stmt|;
name|u_int32_t
name|rmode
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|error
operator|=
name|nfsrpc_accessrpc
argument_list|(
name|vp
argument_list|,
name|wmode
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|attrflag
argument_list|,
operator|&
name|rmode
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|lrupos
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFS_ACCESSCACHESIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|np
operator|->
name|n_accesscache
index|[
name|i
index|]
operator|.
name|uid
operator|==
name|cred
operator|->
name|cr_uid
condition|)
block|{
name|np
operator|->
name|n_accesscache
index|[
name|i
index|]
operator|.
name|mode
operator|=
name|rmode
expr_stmt|;
name|np
operator|->
name|n_accesscache
index|[
name|i
index|]
operator|.
name|stamp
operator|=
name|time_second
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|np
operator|->
name|n_accesscache
index|[
name|i
index|]
operator|.
name|stamp
operator|<
name|np
operator|->
name|n_accesscache
index|[
name|lrupos
index|]
operator|.
name|stamp
condition|)
name|lrupos
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|NFS_ACCESSCACHESIZE
condition|)
block|{
name|np
operator|->
name|n_accesscache
index|[
name|lrupos
index|]
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|np
operator|->
name|n_accesscache
index|[
name|lrupos
index|]
operator|.
name|mode
operator|=
name|rmode
expr_stmt|;
name|np
operator|->
name|n_accesscache
index|[
name|lrupos
index|]
operator|.
name|stamp
operator|=
name|time_second
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|retmode
operator|!=
name|NULL
condition|)
operator|*
name|retmode
operator|=
name|rmode
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs access vnode op.  * For nfs version 2, just return ok. File accesses may fail later.  * For nfs version 3, use the access rpc to check accessibility. If file modes  * are changed on the server, accesses might still fail later.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_access
parameter_list|(
name|struct
name|vop_access_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|gotahit
decl_stmt|;
name|u_int32_t
name|mode
decl_stmt|,
name|wmode
decl_stmt|,
name|rmode
decl_stmt|;
name|int
name|v34
init|=
name|NFS_ISV34
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
comment|/* 	 * Disallow write attempts on filesystems mounted read-only; 	 * unless the file is a socket, fifo, or a block or character 	 * device resident on the filesystem. 	 */
if|if
condition|(
operator|(
name|ap
operator|->
name|a_accmode
operator|&
operator|(
name|VWRITE
operator||
name|VAPPEND
operator||
name|VWRITE_NAMED_ATTRS
operator||
name|VDELETE_CHILD
operator||
name|VWRITE_ATTRIBUTES
operator||
name|VDELETE
operator||
name|VWRITE_ACL
operator||
name|VWRITE_OWNER
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
return|return
operator|(
name|EROFS
operator|)
return|;
default|default:
break|break;
block|}
block|}
comment|/* 	 * For nfs v3 or v4, check to see if we have done this recently, and if 	 * so return our cached result instead of making an ACCESS call. 	 * If not, do an access rpc, otherwise you are stuck emulating 	 * ufs_access() locally using the vattr. This may not be correct, 	 * since the server may apply other access criteria such as 	 * client uid-->server uid mapping that we do not know about. 	 */
if|if
condition|(
name|v34
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|a_accmode
operator|&
name|VREAD
condition|)
name|mode
operator|=
name|NFSACCESS_READ
expr_stmt|;
else|else
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|a_accmode
operator|&
name|VWRITE
condition|)
name|mode
operator||=
operator|(
name|NFSACCESS_MODIFY
operator||
name|NFSACCESS_EXTEND
operator|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_accmode
operator|&
name|VAPPEND
condition|)
name|mode
operator||=
name|NFSACCESS_EXTEND
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_accmode
operator|&
name|VEXEC
condition|)
name|mode
operator||=
name|NFSACCESS_EXECUTE
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_accmode
operator|&
name|VDELETE
condition|)
name|mode
operator||=
name|NFSACCESS_DELETE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ap
operator|->
name|a_accmode
operator|&
name|VWRITE
condition|)
name|mode
operator||=
operator|(
name|NFSACCESS_MODIFY
operator||
name|NFSACCESS_EXTEND
operator|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_accmode
operator|&
name|VAPPEND
condition|)
name|mode
operator||=
name|NFSACCESS_EXTEND
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_accmode
operator|&
name|VEXEC
condition|)
name|mode
operator||=
name|NFSACCESS_LOOKUP
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_accmode
operator|&
name|VDELETE
condition|)
name|mode
operator||=
name|NFSACCESS_DELETE
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_accmode
operator|&
name|VDELETE_CHILD
condition|)
name|mode
operator||=
name|NFSACCESS_MODIFY
expr_stmt|;
block|}
comment|/* XXX safety belt, only make blanket request if caching */
if|if
condition|(
name|nfsaccess_cache_timeout
operator|>
literal|0
condition|)
block|{
name|wmode
operator|=
name|NFSACCESS_READ
operator||
name|NFSACCESS_MODIFY
operator||
name|NFSACCESS_EXTEND
operator||
name|NFSACCESS_EXECUTE
operator||
name|NFSACCESS_DELETE
operator||
name|NFSACCESS_LOOKUP
expr_stmt|;
block|}
else|else
block|{
name|wmode
operator|=
name|mode
expr_stmt|;
block|}
comment|/* 		 * Does our cached result allow us to give a definite yes to 		 * this request? 		 */
name|gotahit
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFS_ACCESSCACHESIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|a_cred
operator|->
name|cr_uid
operator|==
name|np
operator|->
name|n_accesscache
index|[
name|i
index|]
operator|.
name|uid
condition|)
block|{
if|if
condition|(
name|time_second
operator|<
operator|(
name|np
operator|->
name|n_accesscache
index|[
name|i
index|]
operator|.
name|stamp
operator|+
name|nfsaccess_cache_timeout
operator|)
operator|&&
operator|(
name|np
operator|->
name|n_accesscache
index|[
name|i
index|]
operator|.
name|mode
operator|&
name|mode
operator|)
operator|==
name|mode
condition|)
block|{
name|NFSINCRGLOBAL
argument_list|(
name|newnfsstats
operator|.
name|accesscache_hits
argument_list|)
expr_stmt|;
name|gotahit
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|gotahit
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Either a no, or a don't know.  Go to the wire. 			 */
name|NFSINCRGLOBAL
argument_list|(
name|newnfsstats
operator|.
name|accesscache_misses
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs34_access_otw
argument_list|(
name|vp
argument_list|,
name|wmode
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
operator|&
name|rmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|rmode
operator|&
name|mode
operator|)
operator|!=
name|mode
condition|)
name|error
operator|=
name|EACCES
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|nfsspec_access
argument_list|(
name|ap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Attempt to prevent a mapped root from accessing a file 		 * which it shouldn't.  We try to read a byte from the file 		 * if the user is root and the file is not zero length. 		 * After calling nfsspec_access, we should have the correct 		 * file size cached. 		 */
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_cred
operator|->
name|cr_uid
operator|==
literal|0
operator|&&
operator|(
name|ap
operator|->
name|a_accmode
operator|&
name|VREAD
operator|)
operator|&&
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_size
operator|>
literal|0
condition|)
block|{
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|ap
operator|->
name|a_td
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
name|error
operator|=
name|ncl_readrpc
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|char
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|malloc
argument_list|(
name|NFS_DIRBLKSIZ
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|bp
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|auio
operator|.
name|uio_resid
operator|=
name|NFS_DIRBLKSIZ
expr_stmt|;
name|error
operator|=
name|ncl_readdirrpc
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VLNK
condition|)
name|error
operator|=
name|ncl_readlinkrpc
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EACCES
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * nfs open vnode op  * Check to see if the type is ok  * and that deletion is not in progress.  * For paged in text files, you will need to flush the page cache  * if consistency is lost.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nfs_open
parameter_list|(
name|struct
name|vop_open_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|fmode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VLNK
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* 	 * For NFSv4, we need to do the Open Op before cache validation, 	 * so that we conform to RFC3530 Sec. 9.3.1. 	 */
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|error
operator|=
name|nfsrpc_open
argument_list|(
name|vp
argument_list|,
name|fmode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|ap
operator|->
name|a_td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Now, if this Open will be doing reading, re-validate/flush the 	 * cache, so that Close/Open coherency is maintained. 	 */
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ncl_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EIO
condition|)
block|{
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|nfsrpc_close
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|np
operator|->
name|n_direofoffset
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|nfsrpc_close
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_mtime
operator|=
name|vattr
operator|.
name|va_mtime
expr_stmt|;
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
name|np
operator|->
name|n_change
operator|=
name|vattr
operator|.
name|va_filerev
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|nfsrpc_close
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
operator|&&
name|np
operator|->
name|n_change
operator|!=
name|vattr
operator|.
name|va_filerev
operator|)
operator|||
name|NFS_TIMESPEC_COMPARE
argument_list|(
operator|&
name|np
operator|->
name|n_mtime
argument_list|,
operator|&
name|vattr
operator|.
name|va_mtime
argument_list|)
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|np
operator|->
name|n_direofoffset
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ncl_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EIO
condition|)
block|{
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|nfsrpc_close
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_mtime
operator|=
name|vattr
operator|.
name|va_mtime
expr_stmt|;
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
name|np
operator|->
name|n_change
operator|=
name|vattr
operator|.
name|va_filerev
expr_stmt|;
block|}
block|}
comment|/* 	 * If the object has>= 1 O_DIRECT active opens, we disable caching. 	 */
if|if
condition|(
name|newnfs_directio_enable
operator|&&
operator|(
name|fmode
operator|&
name|O_DIRECT
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|n_directio_opens
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ncl_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|nfsrpc_close
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_flag
operator||=
name|NNONCACHE
expr_stmt|;
block|}
name|np
operator|->
name|n_directio_opens
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|vnode_create_vobject
argument_list|(
name|vp
argument_list|,
name|vattr
operator|.
name|va_size
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs close vnode op  * What an NFS client should do upon close after writing is a debatable issue.  * Most NFS clients push delayed writes to the server upon close, basically for  * two reasons:  * 1 - So that any write errors may be reported back to the client process  *     doing the close system call. By far the two most likely errors are  *     NFSERR_NOSPC and NFSERR_DQUOT to indicate space allocation failure.  * 2 - To put a worst case upper bound on cache inconsistency between  *     multiple clients for the file.  * There is also a consistency problem for Version 2 of the protocol w.r.t.  * not being able to tell if other clients are writing a file concurrently,  * since there is no way of knowing if the changed modify time in the reply  * is only due to the write for this client.  * (NFS Version 3 provides weak cache consistency data in the reply that  *  should be sufficient to detect and handle this case.)  *  * The current code does the following:  * for NFS Version 2 - play it safe and flush/invalidate all dirty buffers  * for NFS Version 3 - flush dirty buffers to the server but don't invalidate  *                     or commit them (this satisfies 1 and 2 except for the  *                     case where the server crashes after this close but  *                     before the commit RPC, which is felt to be "good  *                     enough". Changing the last argument to ncl_flush() to  *                     a 1 would force a commit operation, if it is felt a  *                     commit is necessary now.  * for NFS Version 4 - flush the dirty buffers and commit them, if  *		       nfscl_mustflush() says this is necessary.  *                     It is necessary if there is no write delegation held,  *                     in order to satisfy open/close coherency.  *                     If the file isn't cached on local stable storage,  *                     it may be necessary in order to detect "out of space"  *                     errors from the server, if the write delegation  *                     issued by the server doesn't allow the file to grow.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nfs_close
parameter_list|(
name|struct
name|vop_close_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|,
name|localcred
init|=
literal|0
decl_stmt|;
name|int
name|fmode
init|=
name|ap
operator|->
name|a_fflag
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_kern_flag
operator|&
name|MNTK_UNMOUNTF
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * During shutdown, a_cred isn't valid, so just use root. 	 */
if|if
condition|(
name|ap
operator|->
name|a_cred
operator|==
name|NOCRED
condition|)
block|{
name|cred
operator|=
name|newnfs_getcred
argument_list|()
expr_stmt|;
name|localcred
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cred
operator|=
name|ap
operator|->
name|a_cred
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
comment|/* 	     * Examine and clean dirty pages, regardless of NMODIFIED. 	     * This closes a major hole in close-to-open consistency. 	     * We want to push out all dirty pages (and buffers) on 	     * close, regardless of whether they were dirtied by 	     * mmap'ed writes or via write(). 	     */
if|if
condition|(
name|nfs_clean_pages_on_close
operator|&&
name|vp
operator|->
name|v_object
condition|)
block|{
name|VM_OBJECT_LOCK
argument_list|(
name|vp
operator|->
name|v_object
argument_list|)
expr_stmt|;
name|vm_object_page_clean
argument_list|(
name|vp
operator|->
name|v_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|vp
operator|->
name|v_object
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFS_ISV3
argument_list|(
name|vp
argument_list|)
condition|)
block|{
comment|/* 		     * Under NFSv3 we have dirty buffers to dispose of.  We 		     * must flush them to the NFS server.  We have the option 		     * of waiting all the way through the commit rpc or just 		     * waiting for the initial write.  The default is to only 		     * wait through the initial write so the data is in the 		     * server's cache, which is roughly similar to the state 		     * a standard disk subsystem leaves the file in on close(). 		     * 		     * We cannot clear the NMODIFIED bit in np->n_flag due to 		     * potential races with other processes, and certainly 		     * cannot clear it if we don't commit. 		     * These races occur when there is no longer the old 		     * traditional vnode locking implemented for Vnode Ops. 		     */
name|int
name|cm
init|=
name|newnfs_commit_on_close
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|error
operator|=
name|ncl_flush
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|,
name|cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* np->n_flag&= ~NMODIFIED; */
block|}
elseif|else
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
block|{
if|if
condition|(
name|nfscl_mustflush
argument_list|(
name|vp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|cm
init|=
name|newnfs_commit_on_close
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|error
operator|=
name|ncl_flush
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|,
name|cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|cm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * as above w.r.t races when clearing 				 * NMODIFIED. 				 * np->n_flag&= ~NMODIFIED; 				 */
block|}
block|}
else|else
name|error
operator|=
name|ncl_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
comment|/*   	     * Invalidate the attribute cache in all cases.  	     * An open is going to fetch fresh attrs any way, other procs  	     * on this node that have file open will be forced to do an   	     * otw attr fetch, but this is safe. 	     * --> A user found that their RPC count dropped by 20% when 	     *     this was commented out and I can't see any requirement 	     *     for it, so I've disabled it when negative lookups are 	     *     enabled. (What does this have to do with negative lookup 	     *     caching? Well nothing, except it was reported by the 	     *     same user that needed negative lookup caching and I wanted 	     *     there to be a way to disable it to see if it 	     *     is the cause of some caching/coherency issue that might 	     *     crop up.)  	     */
if|if
condition|(
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|->
name|nm_negnametimeo
operator|==
literal|0
condition|)
name|np
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NWRITEERR
condition|)
block|{
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NWRITEERR
expr_stmt|;
name|error
operator|=
name|np
operator|->
name|n_error
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
block|{
comment|/* 		 * Get attributes so "change" is up to date. 		 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|nfscl_mustflush
argument_list|(
name|vp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|nfsrpc_getattr
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|np
operator|->
name|n_change
operator|=
name|nfsva
operator|.
name|na_filerev
expr_stmt|;
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * and do the close. 		 */
name|ret
operator|=
name|nfsrpc_close
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|ret
condition|)
name|error
operator|=
name|ret
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|ap
operator|->
name|a_td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newnfs_directio_enable
condition|)
name|KASSERT
argument_list|(
operator|(
name|np
operator|->
name|n_directio_asyncwr
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"nfs_close: dirty unflushed (%d) directio buffers\n"
operator|,
name|np
operator|->
name|n_directio_asyncwr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newnfs_directio_enable
operator|&&
operator|(
name|fmode
operator|&
name|O_DIRECT
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|np
operator|->
name|n_directio_opens
operator|>
literal|0
operator|)
argument_list|,
operator|(
literal|"nfs_close: unexpectedly value (0) of n_directio_opens\n"
operator|)
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_directio_opens
operator|--
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_directio_opens
operator|==
literal|0
condition|)
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NNONCACHE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|localcred
condition|)
name|NFSFREECRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs getattr call from vfs.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_getattr
parameter_list|(
name|struct
name|vop_getattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* XXX */
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
comment|/* 	 * Update local times for special files. 	 */
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
operator|(
name|NACC
operator||
name|NUPD
operator|)
condition|)
name|np
operator|->
name|n_flag
operator||=
name|NCHG
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * First look in the cache. 	 */
if|if
condition|(
name|ncl_getattrcache
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vap
operator|->
name|va_type
operator|=
name|vattr
operator|.
name|va_type
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|vattr
operator|.
name|va_mode
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
name|vattr
operator|.
name|va_nlink
expr_stmt|;
name|vap
operator|->
name|va_uid
operator|=
name|vattr
operator|.
name|va_uid
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
name|vattr
operator|.
name|va_gid
expr_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|vattr
operator|.
name|va_fsid
expr_stmt|;
name|vap
operator|->
name|va_fileid
operator|=
name|vattr
operator|.
name|va_fileid
expr_stmt|;
name|vap
operator|->
name|va_size
operator|=
name|vattr
operator|.
name|va_size
expr_stmt|;
name|vap
operator|->
name|va_blocksize
operator|=
name|vattr
operator|.
name|va_blocksize
expr_stmt|;
name|vap
operator|->
name|va_atime
operator|=
name|vattr
operator|.
name|va_atime
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|=
name|vattr
operator|.
name|va_mtime
expr_stmt|;
name|vap
operator|->
name|va_ctime
operator|=
name|vattr
operator|.
name|va_ctime
expr_stmt|;
name|vap
operator|->
name|va_gen
operator|=
name|vattr
operator|.
name|va_gen
expr_stmt|;
name|vap
operator|->
name|va_flags
operator|=
name|vattr
operator|.
name|va_flags
expr_stmt|;
name|vap
operator|->
name|va_rdev
operator|=
name|vattr
operator|.
name|va_rdev
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
name|vattr
operator|.
name|va_bytes
expr_stmt|;
name|vap
operator|->
name|va_filerev
operator|=
name|vattr
operator|.
name|va_filerev
expr_stmt|;
comment|/* 		 * Get the local modify time for the case of a write 		 * delegation. 		 */
name|nfscl_deleggetmodtime
argument_list|(
name|vp
argument_list|,
operator|&
name|vap
operator|->
name|va_mtime
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|NFS_ISV34
argument_list|(
name|vp
argument_list|)
operator|&&
name|nfs_prime_access_cache
operator|&&
name|nfsaccess_cache_timeout
operator|>
literal|0
condition|)
block|{
name|NFSINCRGLOBAL
argument_list|(
name|newnfsstats
operator|.
name|accesscache_misses
argument_list|)
expr_stmt|;
name|nfs34_access_otw
argument_list|(
name|vp
argument_list|,
name|NFSACCESS_ALL
argument_list|,
name|td
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncl_getattrcache
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nfscl_deleggetmodtime
argument_list|(
name|vp
argument_list|,
operator|&
name|ap
operator|->
name|a_vap
operator|->
name|va_mtime
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|error
operator|=
name|nfsrpc_getattr
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfscl_loadattrcache
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|vap
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 		 * Get the local modify time for the case of a write 		 * delegation. 		 */
name|nfscl_deleggetmodtime
argument_list|(
name|vp
argument_list|,
operator|&
name|vap
operator|->
name|va_mtime
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs setattr call.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_setattr
parameter_list|(
name|struct
name|vop_setattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* XXX */
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_quad_t
name|tsize
decl_stmt|;
ifndef|#
directive|ifndef
name|nolint
name|tsize
operator|=
operator|(
name|u_quad_t
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Setting of flags and marking of atimes are not supported. 	 */
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* 	 * Disallow write attempts if the filesystem is mounted read-only. 	 */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VDIR
case|:
return|return
operator|(
name|EISDIR
operator|)
return|;
case|case
name|VCHR
case|:
case|case
name|VBLK
case|:
case|case
name|VSOCK
case|:
case|case
name|VFIFO
case|:
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|==
name|VNOVAL
operator|&&
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|==
name|VNOVAL
operator|&&
name|vap
operator|->
name|va_mode
operator|==
operator|(
name|mode_t
operator|)
name|VNOVAL
operator|&&
name|vap
operator|->
name|va_uid
operator|==
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|&&
name|vap
operator|->
name|va_gid
operator|==
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vap
operator|->
name|va_size
operator|=
name|VNOVAL
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Disallow write attempts if the filesystem is 			 * mounted read-only. 			 */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
comment|/* 			 *  We run vnode_pager_setsize() early (why?), 			 * we must set np->n_size now to avoid vinvalbuf 			 * V_SAVE races that might setsize a lower 			 * value. 			 */
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|tsize
operator|=
name|np
operator|->
name|n_size
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ncl_meta_setsize
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|,
name|vap
operator|->
name|va_size
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
condition|)
block|{
name|tsize
operator|=
name|np
operator|->
name|n_size
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_size
operator|==
literal|0
condition|)
name|error
operator|=
name|ncl_vinvalbuf
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ncl_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 			     * Call nfscl_delegmodtime() to set the modify time 			     * locally, as required. 			     */
name|nfscl_delegmodtime
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
comment|/* 			 * np->n_size has already been set to vap->va_size 			 * in ncl_meta_setsize(). We must set it again since 			 * nfs_loadattrcache() could be called through 			 * ncl_meta_setsize() and could modify np->n_size. 			 */
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_vattr
operator|.
name|na_size
operator|=
name|np
operator|->
name|n_size
operator|=
name|vap
operator|->
name|va_size
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
block|{
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|)
operator|&&
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
operator|)
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ncl_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|td
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EIO
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfs_setattrrpc
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_size
operator|=
name|np
operator|->
name|n_vattr
operator|.
name|na_size
operator|=
name|tsize
expr_stmt|;
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do an nfs setattr rpc.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_setattrrpc
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ret
decl_stmt|,
name|attrflag
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
if|if
condition|(
name|NFS_ISV34
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFS_ACCESSCACHESIZE
condition|;
name|i
operator|++
control|)
name|np
operator|->
name|n_accesscache
index|[
name|i
index|]
operator|.
name|stamp
operator|=
literal|0
expr_stmt|;
name|np
operator|->
name|n_flag
operator||=
name|NDELEGMOD
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfsrpc_setattr
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|NULL
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|attrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
block|{
name|ret
operator|=
name|nfscl_loadattrcache
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|td
argument_list|,
name|error
argument_list|,
name|vap
operator|->
name|va_uid
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs lookup call, one step at a time...  * First look in cache  * If not found, unlock the directory nfsnode and do the rpc  */
end_comment

begin_function
specifier|static
name|int
name|nfs_lookup
parameter_list|(
name|struct
name|vop_lookup_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
init|=
name|ap
operator|->
name|a_vpp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
init|=
name|dvp
operator|->
name|v_mount
decl_stmt|;
name|int
name|flags
init|=
name|cnp
operator|->
name|cn_flags
decl_stmt|;
name|struct
name|vnode
modifier|*
name|newvp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|,
modifier|*
name|newnp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|attrflag
decl_stmt|,
name|dattrflag
decl_stmt|,
name|ltype
decl_stmt|,
name|ncticks
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|cnp
operator|->
name|cn_thread
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|struct
name|nfsvattr
name|dnfsva
decl_stmt|,
name|nfsva
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|struct
name|timespec
name|nctime
decl_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|DELETE
operator|||
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|dvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
comment|/* For NFSv4, wait until any remove is done. */
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|&&
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NREMOVEINPROG
operator|)
condition|)
block|{
name|np
operator|->
name|n_flag
operator||=
name|NREMOVEWANT
expr_stmt|;
operator|(
name|void
operator|)
name|msleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|np
argument_list|,
operator|&
name|np
operator|->
name|n_mtx
argument_list|,
name|PZERO
argument_list|,
literal|"nfslkup"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VEXEC
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|cache_lookup_times
argument_list|(
name|dvp
argument_list|,
name|vpp
argument_list|,
name|cnp
argument_list|,
operator|&
name|nctime
argument_list|,
operator|&
name|ncticks
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Lookups of "." are special and always return the 		 * current directory.  cache_lookup() already handles 		 * associated locking bookkeeping, etc. 		 */
if|if
condition|(
name|cnp
operator|->
name|cn_namelen
operator|==
literal|1
operator|&&
name|cnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* XXX: Is this really correct? */
if|if
condition|(
name|cnp
operator|->
name|cn_nameiop
operator|!=
name|LOOKUP
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * We only accept a positive hit in the cache if the 		 * change time of the file matches our cached copy. 		 * Otherwise, we discard the cache entry and fallback 		 * to doing a lookup RPC. 		 * 		 * To better handle stale file handles and attributes, 		 * clear the attribute cache of this node if it is a 		 * leaf component, part of an open() call, and not 		 * locally modified before fetching the attributes. 		 * This should allow stale file handles to be detected 		 * here where we can fall back to a LOOKUP RPC to 		 * recover rather than having nfs_open() detect the 		 * stale file handle and failing open(2) with ESTALE. 		 */
name|newvp
operator|=
operator|*
name|vpp
expr_stmt|;
name|newnp
operator|=
name|VTONFS
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_NOCTO
operator|)
operator|&&
operator|(
name|flags
operator|&
operator|(
name|ISLASTCN
operator||
name|ISOPEN
operator|)
operator|)
operator|==
operator|(
name|ISLASTCN
operator||
name|ISOPEN
operator|)
operator|&&
operator|!
operator|(
name|newnp
operator|->
name|n_flag
operator|&
name|NMODIFIED
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|newnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|newnp
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|newnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfscl_nodeleg
argument_list|(
name|newvp
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|VOP_GETATTR
argument_list|(
name|newvp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
operator|==
literal|0
operator|&&
name|timespeccmp
argument_list|(
operator|&
name|vattr
operator|.
name|va_ctime
argument_list|,
operator|&
name|nctime
argument_list|,
operator|==
argument_list|)
operator|)
condition|)
block|{
name|NFSINCRGLOBAL
argument_list|(
name|newnfsstats
operator|.
name|lookupcache_hits
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_nameiop
operator|!=
name|LOOKUP
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cache_purge
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|!=
name|newvp
condition|)
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
if|if
condition|(
name|dvp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* 		 * We only accept a negative hit in the cache if the 		 * modification time of the parent directory matches 		 * the cached copy in the name cache entry. 		 * Otherwise, we discard all of the negative cache 		 * entries for this directory.  We also only trust 		 * negative cache entries for up to nm_negnametimeo 		 * seconds. 		 */
if|if
condition|(
call|(
name|u_int
call|)
argument_list|(
name|ticks
operator|-
name|ncticks
argument_list|)
operator|<
operator|(
name|nmp
operator|->
name|nm_negnametimeo
operator|*
name|hz
operator|)
operator|&&
name|VOP_GETATTR
argument_list|(
name|dvp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
operator|==
literal|0
operator|&&
name|timespeccmp
argument_list|(
operator|&
name|vattr
operator|.
name|va_mtime
argument_list|,
operator|&
name|nctime
argument_list|,
operator|==
argument_list|)
condition|)
block|{
name|NFSINCRGLOBAL
argument_list|(
name|newnfsstats
operator|.
name|lookupcache_hits
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|cache_purge_negative
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|newvp
operator|=
name|NULLVP
expr_stmt|;
name|NFSINCRGLOBAL
argument_list|(
name|newnfsstats
operator|.
name|lookupcache_misses
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrpc_lookup
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|td
argument_list|,
operator|&
name|dnfsva
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|nfhp
argument_list|,
operator|&
name|attrflag
argument_list|,
operator|&
name|dattrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dattrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|dvp
argument_list|,
operator|&
name|dnfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|newvp
operator|!=
name|NULLVP
condition|)
block|{
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
block|{
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|dvp
argument_list|)
condition|)
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* The requested file was not found. */
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|CREATE
operator|||
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|)
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
block|{
comment|/* 			 * XXX: UFS does a full VOP_ACCESS(dvp, 			 * VWRITE) here instead of just checking 			 * MNT_RDONLY. 			 */
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
operator|&&
name|cnp
operator|->
name|cn_nameiop
operator|!=
name|CREATE
operator|&&
name|dattrflag
condition|)
block|{
comment|/* 			 * Cache the modification time of the parent 			 * directory from the post-op attributes in 			 * the name cache entry.  The negative cache 			 * entry will be ignored once the directory 			 * has changed.  Don't bother adding the entry 			 * if the directory has already changed. 			 */
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|timespeccmp
argument_list|(
operator|&
name|np
operator|->
name|n_vattr
operator|.
name|na_mtime
argument_list|,
operator|&
name|dnfsva
operator|.
name|na_mtime
argument_list|,
operator|==
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|cache_enter_time
argument_list|(
name|dvp
argument_list|,
name|NULL
argument_list|,
name|cnp
argument_list|,
operator|&
name|dnfsva
operator|.
name|na_mtime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * Handle RENAME case... 	 */
if|if
condition|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
block|{
if|if
condition|(
name|NFS_CMPFH
argument_list|(
name|np
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
return|return
operator|(
name|EISDIR
operator|)
return|;
block|}
name|error
operator|=
name|nfscl_nget
argument_list|(
name|mp
argument_list|,
name|dvp
argument_list|,
name|nfhp
argument_list|,
name|cnp
argument_list|,
name|td
argument_list|,
operator|&
name|np
argument_list|,
name|NULL
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|newvp
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|ISDOTDOT
condition|)
block|{
name|ltype
operator|=
name|NFSVOPISLOCKED
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|vfs_busy
argument_list|(
name|mp
argument_list|,
name|MBF_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|vfs_ref
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|NFSVOPUNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|vfs_busy
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSVOPLOCK
argument_list|(
name|dvp
argument_list|,
name|ltype
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|vfs_rel
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|dvp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
operator|)
condition|)
block|{
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|NFSVOPUNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfscl_nget
argument_list|(
name|mp
argument_list|,
name|dvp
argument_list|,
name|nfhp
argument_list|,
name|cnp
argument_list|,
name|td
argument_list|,
operator|&
name|np
argument_list|,
name|NULL
argument_list|,
name|cnp
operator|->
name|cn_lkflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvp
operator|!=
name|dvp
condition|)
name|NFSVOPLOCK
argument_list|(
name|dvp
argument_list|,
name|ltype
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|newvp
operator|==
name|dvp
condition|)
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|attrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFS_CMPFH
argument_list|(
name|np
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|dvp
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfscl_nget
argument_list|(
name|mp
argument_list|,
name|dvp
argument_list|,
name|nfhp
argument_list|,
name|cnp
argument_list|,
name|td
argument_list|,
operator|&
name|np
argument_list|,
name|NULL
argument_list|,
name|cnp
operator|->
name|cn_lkflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|ISLASTCN
operator||
name|ISOPEN
operator|)
operator|)
operator|==
operator|(
name|ISLASTCN
operator||
name|ISOPEN
operator|)
operator|&&
operator|!
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
operator|)
condition|)
block|{
comment|/* 			 * Flush the attribute cache when opening a 			 * leaf node to ensure that fresh attributes 			 * are fetched in nfs_open() since we did not 			 * fetch attributes from the LOOKUP reply. 			 */
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnp
operator|->
name|cn_nameiop
operator|!=
name|LOOKUP
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|!=
name|DELETE
operator|||
operator|!
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|)
operator|&&
name|attrflag
operator|!=
literal|0
operator|&&
operator|(
name|newvp
operator|->
name|v_type
operator|!=
name|VDIR
operator|||
name|dattrflag
operator|!=
literal|0
operator|)
condition|)
name|cache_enter_time
argument_list|(
name|dvp
argument_list|,
name|newvp
argument_list|,
name|cnp
argument_list|,
operator|&
name|nfsva
operator|.
name|na_ctime
argument_list|,
name|newvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|?
name|NULL
else|:
operator|&
name|dnfsva
operator|.
name|na_ctime
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|newvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs read call.  * Just call ncl_bioread() to do the work.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_read
parameter_list|(
name|struct
name|vop_read_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
return|return
operator|(
name|ncl_bioread
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|)
return|;
case|case
name|VDIR
case|:
return|return
operator|(
name|EISDIR
operator|)
return|;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * nfs readlink call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_readlink
parameter_list|(
name|struct
name|vop_readlink_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VLNK
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|ncl_bioread
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do a readlink rpc.  * Called by ncl_doio() from below the buffer cache.  */
end_comment

begin_function
name|int
name|ncl_readlinkrpc
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|ret
decl_stmt|,
name|attrflag
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|error
operator|=
name|nfsrpc_readlink
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|cred
argument_list|,
name|uiop
operator|->
name|uio_td
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|attrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
block|{
name|ret
operator|=
name|nfscl_loadattrcache
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|uiop
operator|->
name|uio_td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs read rpc call  * Ditto above  */
end_comment

begin_function
name|int
name|ncl_readrpc
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|ret
decl_stmt|,
name|attrflag
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|error
operator|=
name|nfsrpc_read
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|cred
argument_list|,
name|uiop
operator|->
name|uio_td
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|attrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
block|{
name|ret
operator|=
name|nfscl_loadattrcache
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|uiop
operator|->
name|uio_td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs write call  */
end_comment

begin_function
name|int
name|ncl_writerpc
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
modifier|*
name|iomode
parameter_list|,
name|int
modifier|*
name|must_commit
parameter_list|,
name|int
name|called_from_strategy
parameter_list|)
block|{
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|attrflag
decl_stmt|,
name|ret
decl_stmt|;
name|error
operator|=
name|nfsrpc_write
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|iomode
argument_list|,
name|must_commit
argument_list|,
name|cred
argument_list|,
name|uiop
operator|->
name|uio_td
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|attrflag
argument_list|,
name|NULL
argument_list|,
name|called_from_strategy
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
block|{
if|if
condition|(
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_flag
operator|&
name|ND_NFSV4
condition|)
name|ret
operator|=
name|nfscl_loadattrcache
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|nfscl_loadattrcache
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|DOINGASYNC
argument_list|(
name|vp
argument_list|)
condition|)
operator|*
name|iomode
operator|=
name|NFSWRITE_FILESYNC
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|uiop
operator|->
name|uio_td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs mknod rpc  * For NFS v2 this is a kludge. Use a create rpc but with the IFMT bits of the  * mode set to specify the file type and the size field for rdev.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_mknodrpc
parameter_list|(
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|nfsvattr
name|nfsva
decl_stmt|,
name|dnfsva
decl_stmt|;
name|struct
name|vnode
modifier|*
name|newvp
init|=
name|NULL
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|NULL
decl_stmt|,
modifier|*
name|dnp
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|attrflag
decl_stmt|,
name|dattrflag
decl_stmt|;
name|u_int32_t
name|rdev
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_type
operator|==
name|VCHR
operator|||
name|vap
operator|->
name|va_type
operator|==
name|VBLK
condition|)
name|rdev
operator|=
name|vap
operator|->
name|va_rdev
expr_stmt|;
elseif|else
if|if
condition|(
name|vap
operator|->
name|va_type
operator|==
name|VFIFO
operator|||
name|vap
operator|->
name|va_type
operator|==
name|VSOCK
condition|)
name|rdev
operator|=
literal|0xffffffff
expr_stmt|;
else|else
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|dvp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfsrpc_mknod
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|vap
argument_list|,
name|rdev
argument_list|,
name|vap
operator|->
name|va_type
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|dnfsva
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|nfhp
argument_list|,
operator|&
name|attrflag
argument_list|,
operator|&
name|dattrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
operator|!
name|nfhp
condition|)
operator|(
name|void
operator|)
name|nfsrpc_lookup
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|dnfsva
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|nfhp
argument_list|,
operator|&
name|attrflag
argument_list|,
operator|&
name|dattrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfhp
condition|)
name|error
operator|=
name|nfscl_nget
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|dvp
argument_list|,
name|nfhp
argument_list|,
name|cnp
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|np
argument_list|,
name|NULL
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dattrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|dvp
argument_list|,
operator|&
name|dnfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|nfscl_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
name|vpp
operator|=
name|newvp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|cnp
operator|->
name|cn_thread
argument_list|,
name|error
argument_list|,
name|vap
operator|->
name|va_uid
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
block|}
name|dnp
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
operator|!
name|dattrflag
condition|)
name|dnp
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs mknod vop  * just call nfs_mknodrpc() to do the work.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nfs_mknod
parameter_list|(
name|struct
name|vop_mknod_args
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|nfs_mknodrpc
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|u_long
name|create_verf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * nfs file create call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_create
parameter_list|(
name|struct
name|vop_create_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|NULL
decl_stmt|,
modifier|*
name|dnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|newvp
init|=
name|NULL
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|struct
name|nfsvattr
name|dnfsva
decl_stmt|,
name|nfsva
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|nfsquad_t
name|cverf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|attrflag
decl_stmt|,
name|dattrflag
decl_stmt|,
name|fmode
init|=
literal|0
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
comment|/* 	 * Oops, not for me.. 	 */
if|if
condition|(
name|vap
operator|->
name|va_type
operator|==
name|VSOCK
condition|)
return|return
operator|(
name|nfs_mknodrpc
argument_list|(
name|dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
argument_list|,
name|vap
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|dvp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|vap
operator|->
name|va_vaflags
operator|&
name|VA_EXCLUSIVE
condition|)
name|fmode
operator||=
name|O_EXCL
expr_stmt|;
name|dnp
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vnode_mount
argument_list|(
name|dvp
argument_list|)
argument_list|)
expr_stmt|;
name|again
label|:
comment|/* For NFSv4, wait until any remove is done. */
name|mtx_lock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|NFSHASNFSV4
argument_list|(
name|nmp
argument_list|)
operator|&&
operator|(
name|dnp
operator|->
name|n_flag
operator|&
name|NREMOVEINPROG
operator|)
condition|)
block|{
name|dnp
operator|->
name|n_flag
operator||=
name|NREMOVEWANT
expr_stmt|;
operator|(
name|void
operator|)
name|msleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dnp
argument_list|,
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|,
name|PZERO
argument_list|,
literal|"nfscrt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|CURVNET_SET
argument_list|(
name|CRED_TO_VNET
argument_list|(
name|cnp
operator|->
name|cn_cred
argument_list|)
argument_list|)
expr_stmt|;
name|IN_IFADDR_RLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|V_in_ifaddrhead
argument_list|)
condition|)
name|cverf
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|IA_SIN
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|V_in_ifaddrhead
argument_list|)
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
else|else
endif|#
directive|endif
name|cverf
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|create_verf
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|IN_IFADDR_RUNLOCK
argument_list|()
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|cverf
operator|.
name|lval
index|[
literal|1
index|]
operator|=
operator|++
name|create_verf
expr_stmt|;
name|error
operator|=
name|nfsrpc_create
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|vap
argument_list|,
name|cverf
argument_list|,
name|fmode
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|dnfsva
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|nfhp
argument_list|,
operator|&
name|attrflag
argument_list|,
operator|&
name|dattrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|nfhp
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|nfsrpc_lookup
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|dnfsva
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|nfhp
argument_list|,
operator|&
name|attrflag
argument_list|,
operator|&
name|dattrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfhp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|nfscl_nget
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|dvp
argument_list|,
name|nfhp
argument_list|,
name|cnp
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|np
argument_list|,
name|NULL
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dattrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|dvp
argument_list|,
operator|&
name|dnfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
name|error
operator|=
name|nfscl_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|newvp
operator|!=
name|NULL
condition|)
block|{
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|NFS_ISV34
argument_list|(
name|dvp
argument_list|)
operator|&&
operator|(
name|fmode
operator|&
name|O_EXCL
operator|)
operator|&&
name|error
operator|==
name|NFSERR_NOTSUPP
condition|)
block|{
name|fmode
operator|&=
operator|~
name|O_EXCL
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|NFS_ISV34
argument_list|(
name|dvp
argument_list|)
operator|&&
operator|(
name|fmode
operator|&
name|O_EXCL
operator|)
condition|)
block|{
if|if
condition|(
name|nfscl_checksattr
argument_list|(
name|vap
argument_list|,
operator|&
name|nfsva
argument_list|)
condition|)
block|{
comment|/* 			 * We are normally called with only a partially 			 * initialized VAP. Since the NFSv3 spec says that 			 * the server may use the file attributes to 			 * store the verifier, the spec requires us to do a 			 * SETATTR RPC. FreeBSD servers store the verifier in 			 * atime, but we can't really assume that all servers 			 * will so we ensure that our SETATTR sets both atime 			 * and mtime. 			 */
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|==
name|VNOVAL
condition|)
name|vfs_timestamp
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|==
name|VNOVAL
condition|)
name|vap
operator|->
name|va_atime
operator|=
name|vap
operator|->
name|va_mtime
expr_stmt|;
name|error
operator|=
name|nfsrpc_setattr
argument_list|(
name|newvp
argument_list|,
name|vap
argument_list|,
name|NULL
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|attrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|(
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
operator|)
condition|)
block|{
comment|/* try again without setting uid/gid */
name|vap
operator|->
name|va_uid
operator|=
operator|(
name|uid_t
operator|)
name|VNOVAL
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
operator|(
name|uid_t
operator|)
name|VNOVAL
expr_stmt|;
name|error
operator|=
name|nfsrpc_setattr
argument_list|(
name|newvp
argument_list|,
name|vap
argument_list|,
name|NULL
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|attrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
operator|&&
name|attrflag
condition|)
name|cache_enter_time
argument_list|(
name|dvp
argument_list|,
name|newvp
argument_list|,
name|cnp
argument_list|,
operator|&
name|nfsva
operator|.
name|na_ctime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|newvp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|cnp
operator|->
name|cn_thread
argument_list|,
name|error
argument_list|,
name|vap
operator|->
name|va_uid
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
operator|!
name|dattrflag
condition|)
name|dnp
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs file remove call  * To try and make nfs semantics closer to ufs semantics, a file that has  * other processes using the vnode is renamed instead of removed and then  * removed later on the last close.  * - If v_usecount> 1  *	  If a rename is not already in the works  *	     call nfs_sillyrename() to set it up  *     else  *	  do the remove rpc  */
end_comment

begin_function
specifier|static
name|int
name|nfs_remove
parameter_list|(
name|struct
name|vop_remove_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"nfs_remove: no name"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vrefcnt
argument_list|(
name|vp
argument_list|)
operator|>
literal|0
argument_list|,
operator|(
literal|"nfs_remove: bad v_usecount"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
elseif|else
if|if
condition|(
name|vrefcnt
argument_list|(
name|vp
argument_list|)
operator|==
literal|1
operator|||
operator|(
name|np
operator|->
name|n_sillyrename
operator|&&
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
operator|==
literal|0
operator|&&
name|vattr
operator|.
name|va_nlink
operator|>
literal|1
operator|)
condition|)
block|{
comment|/* 		 * Purge the name cache so that the chance of a lookup for 		 * the name succeeding while the remove is in progress is 		 * minimized. Without node locking it can still happen, such 		 * that an I/O op returns ESTALE, but since you get this if 		 * another host removes the file.. 		 */
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 		 * throw away biocache buffers, mainly to avoid 		 * unnecessary delayed writes later. 		 */
name|error
operator|=
name|ncl_vinvalbuf
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Do the rpc */
if|if
condition|(
name|error
operator|!=
name|EINTR
operator|&&
name|error
operator|!=
name|EIO
condition|)
name|error
operator|=
name|nfs_removerpc
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
comment|/* 		 * Kludge City: If the first reply to the remove rpc is lost.. 		 *   the reply to the retransmitted request will be ENOENT 		 *   since the file was in fact removed 		 *   Therefore, we cheat and return success. 		 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|np
operator|->
name|n_sillyrename
condition|)
name|error
operator|=
name|nfs_sillyrename
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs file remove rpc called from nfs_inactive  */
end_comment

begin_function
name|int
name|ncl_removeit
parameter_list|(
name|struct
name|sillyrename
modifier|*
name|sp
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
comment|/* 	 * Make sure that the directory vnode is still valid. 	 * XXX we should lock sp->s_dvp here. 	 */
if|if
condition|(
name|sp
operator|->
name|s_dvp
operator|->
name|v_type
operator|==
name|VBAD
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|nfs_removerpc
argument_list|(
name|sp
operator|->
name|s_dvp
argument_list|,
name|vp
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|sp
operator|->
name|s_namlen
argument_list|,
name|sp
operator|->
name|s_cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Nfs remove rpc, called from nfs_remove() and ncl_removeit().  */
end_comment

begin_function
specifier|static
name|int
name|nfs_removerpc
parameter_list|(
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|nfsvattr
name|dnfsva
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|dnp
init|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|dattrflag
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_flag
operator||=
name|NREMOVEINPROG
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrpc_remove
argument_list|(
name|dvp
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|,
name|vp
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
operator|&
name|dnfsva
argument_list|,
operator|&
name|dattrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dnp
operator|->
name|n_flag
operator|&
name|NREMOVEWANT
operator|)
condition|)
block|{
name|dnp
operator|->
name|n_flag
operator|&=
operator|~
operator|(
name|NREMOVEWANT
operator||
name|NREMOVEINPROG
operator|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|dnp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dnp
operator|->
name|n_flag
operator|&=
operator|~
name|NREMOVEINPROG
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dattrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|dvp
argument_list|,
operator|&
name|dnfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
operator|!
name|dattrflag
condition|)
name|dnp
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|NFS_ISV4
argument_list|(
name|dvp
argument_list|)
condition|)
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs file rename call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_rename
parameter_list|(
name|struct
name|vop_rename_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|tcnp
init|=
name|ap
operator|->
name|a_tcnp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|fcnp
init|=
name|ap
operator|->
name|a_fcnp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|fnp
init|=
name|VTONFS
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|tdnp
init|=
name|VTONFS
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
decl_stmt|;
name|struct
name|nfsv4node
modifier|*
name|newv4
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|tcnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|fcnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"nfs_rename: no name"
operator|)
argument_list|)
expr_stmt|;
comment|/* Check for cross-device rename */
if|if
condition|(
operator|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tdvp
operator|->
name|v_mount
operator|)
operator|||
operator|(
name|tvp
operator|&&
operator|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tvp
operator|->
name|v_mount
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fvp
operator|==
name|tvp
condition|)
block|{
name|ncl_printf
argument_list|(
literal|"nfs_rename: fvp == tvp (can't happen)\n"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|NFSVOPLOCK
argument_list|(
name|fvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * We have to flush B_DELWRI data prior to renaming 	 * the file.  If we don't, the delayed-write buffers 	 * can be flushed out later after the file has gone stale 	 * under NFSV3.  NFSV2 does not have this problem because 	 * ( as far as I can tell ) it flushes dirty buffers more 	 * often. 	 *  	 * Skip the rename operation if the fsync fails, this can happen 	 * due to the server's volume being full, when we pushed out data 	 * that was written back to our cache earlier. Not checking for 	 * this condition can result in potential (silent) data loss. 	 */
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|fvp
argument_list|,
name|MNT_WAIT
argument_list|,
name|fcnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
name|NFSVOPUNLOCK
argument_list|(
name|fvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|tvp
condition|)
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|tvp
argument_list|,
name|MNT_WAIT
argument_list|,
name|tcnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * If the tvp exists and is in use, sillyrename it before doing the 	 * rename of the new file over it. 	 * XXX Can't sillyrename a directory. 	 */
if|if
condition|(
name|tvp
operator|&&
name|vrefcnt
argument_list|(
name|tvp
argument_list|)
operator|>
literal|1
operator|&&
operator|!
name|VTONFS
argument_list|(
name|tvp
argument_list|)
operator|->
name|n_sillyrename
operator|&&
name|tvp
operator|->
name|v_type
operator|!=
name|VDIR
operator|&&
operator|!
name|nfs_sillyrename
argument_list|(
name|tdvp
argument_list|,
name|tvp
argument_list|,
name|tcnp
argument_list|)
condition|)
block|{
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|tvp
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
name|nfs_renamerpc
argument_list|(
name|fdvp
argument_list|,
name|fvp
argument_list|,
name|fcnp
operator|->
name|cn_nameptr
argument_list|,
name|fcnp
operator|->
name|cn_namelen
argument_list|,
name|tdvp
argument_list|,
name|tvp
argument_list|,
name|tcnp
operator|->
name|cn_nameptr
argument_list|,
name|tcnp
operator|->
name|cn_namelen
argument_list|,
name|tcnp
operator|->
name|cn_cred
argument_list|,
name|tcnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|NFS_ISV4
argument_list|(
name|tdvp
argument_list|)
condition|)
block|{
comment|/* 		 * For NFSv4, check to see if it is the same name and 		 * replace the name, if it is different. 		 */
name|MALLOC
argument_list|(
name|newv4
argument_list|,
expr|struct
name|nfsv4node
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsv4node
argument_list|)
operator|+
name|tdnp
operator|->
name|n_fhp
operator|->
name|nfh_len
operator|+
name|tcnp
operator|->
name|cn_namelen
operator|-
literal|1
argument_list|,
name|M_NFSV4NODE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tdnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|fnp
operator|->
name|n_v4
operator|!=
name|NULL
operator|&&
name|fvp
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|(
name|fnp
operator|->
name|n_v4
operator|->
name|n4_namelen
operator|!=
name|tcnp
operator|->
name|cn_namelen
operator|||
name|NFSBCMP
argument_list|(
name|tcnp
operator|->
name|cn_nameptr
argument_list|,
name|NFS4NODENAME
argument_list|(
name|fnp
operator|->
name|n_v4
argument_list|)
argument_list|,
name|tcnp
operator|->
name|cn_namelen
argument_list|)
operator|||
name|tdnp
operator|->
name|n_fhp
operator|->
name|nfh_len
operator|!=
name|fnp
operator|->
name|n_v4
operator|->
name|n4_fhlen
operator|||
name|NFSBCMP
argument_list|(
name|tdnp
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|fnp
operator|->
name|n_v4
operator|->
name|n4_data
argument_list|,
name|tdnp
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
block|{
name|char
name|nnn
index|[
literal|100
index|]
decl_stmt|;
name|int
name|nnnl
decl_stmt|;
name|nnnl
operator|=
operator|(
name|tcnp
operator|->
name|cn_namelen
operator|<
literal|100
operator|)
condition|?
name|tcnp
operator|->
name|cn_namelen
else|:
literal|99
expr_stmt|;
name|bcopy
argument_list|(
name|tcnp
operator|->
name|cn_nameptr
argument_list|,
name|nnn
argument_list|,
name|nnnl
argument_list|)
expr_stmt|;
name|nnn
index|[
name|nnnl
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"ren replace=%s\n"
argument_list|,
name|nnn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|fnp
operator|->
name|n_v4
argument_list|,
name|M_NFSV4NODE
argument_list|)
expr_stmt|;
name|fnp
operator|->
name|n_v4
operator|=
name|newv4
expr_stmt|;
name|newv4
operator|=
name|NULL
expr_stmt|;
name|fnp
operator|->
name|n_v4
operator|->
name|n4_fhlen
operator|=
name|tdnp
operator|->
name|n_fhp
operator|->
name|nfh_len
expr_stmt|;
name|fnp
operator|->
name|n_v4
operator|->
name|n4_namelen
operator|=
name|tcnp
operator|->
name|cn_namelen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|tdnp
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|fnp
operator|->
name|n_v4
operator|->
name|n4_data
argument_list|,
name|tdnp
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|tcnp
operator|->
name|cn_nameptr
argument_list|,
name|NFS4NODENAME
argument_list|(
name|fnp
operator|->
name|n_v4
argument_list|)
argument_list|,
name|tcnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|tdnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|newv4
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|newv4
argument_list|,
name|M_NFSV4NODE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
name|tvp
operator|!=
name|NULL
operator|&&
name|tvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|cache_purge
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|tdvp
operator|==
name|tvp
condition|)
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
comment|/* 	 * Kludge: Map ENOENT => 0 assuming that it is a reply to a retry. 	 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs file rename rpc called from nfs_remove() above  */
end_comment

begin_function
specifier|static
name|int
name|nfs_renameit
parameter_list|(
name|struct
name|vnode
modifier|*
name|sdvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|svp
parameter_list|,
name|struct
name|componentname
modifier|*
name|scnp
parameter_list|,
name|struct
name|sillyrename
modifier|*
name|sp
parameter_list|)
block|{
return|return
operator|(
name|nfs_renamerpc
argument_list|(
name|sdvp
argument_list|,
name|svp
argument_list|,
name|scnp
operator|->
name|cn_nameptr
argument_list|,
name|scnp
operator|->
name|cn_namelen
argument_list|,
name|sdvp
argument_list|,
name|NULL
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|sp
operator|->
name|s_namlen
argument_list|,
name|scnp
operator|->
name|cn_cred
argument_list|,
name|scnp
operator|->
name|cn_thread
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do an nfs rename rpc. Called from nfs_rename() and nfs_renameit().  */
end_comment

begin_function
specifier|static
name|int
name|nfs_renamerpc
parameter_list|(
name|struct
name|vnode
modifier|*
name|fdvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|fvp
parameter_list|,
name|char
modifier|*
name|fnameptr
parameter_list|,
name|int
name|fnamelen
parameter_list|,
name|struct
name|vnode
modifier|*
name|tdvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|tvp
parameter_list|,
name|char
modifier|*
name|tnameptr
parameter_list|,
name|int
name|tnamelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|nfsvattr
name|fnfsva
decl_stmt|,
name|tnfsva
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|fdnp
init|=
name|VTONFS
argument_list|(
name|fdvp
argument_list|)
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|tdnp
init|=
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|fattrflag
decl_stmt|,
name|tattrflag
decl_stmt|;
name|error
operator|=
name|nfsrpc_rename
argument_list|(
name|fdvp
argument_list|,
name|fvp
argument_list|,
name|fnameptr
argument_list|,
name|fnamelen
argument_list|,
name|tdvp
argument_list|,
name|tvp
argument_list|,
name|tnameptr
argument_list|,
name|tnamelen
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
operator|&
name|fnfsva
argument_list|,
operator|&
name|tnfsva
argument_list|,
operator|&
name|fattrflag
argument_list|,
operator|&
name|tattrflag
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|fdnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|fdnp
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
name|fattrflag
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|fdnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|fdvp
argument_list|,
operator|&
name|fnfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fdnp
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|fdnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|tdnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|tdnp
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
name|tattrflag
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|tdnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|tdvp
argument_list|,
operator|&
name|tnfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tdnp
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tdnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
name|NFS_ISV4
argument_list|(
name|fdvp
argument_list|)
condition|)
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs hard link create call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_link
parameter_list|(
name|struct
name|vop_link_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|,
modifier|*
name|tdnp
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|,
name|dnfsva
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|attrflag
decl_stmt|,
name|dattrflag
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|tdvp
operator|->
name|v_mount
condition|)
block|{
return|return
operator|(
name|EXDEV
operator|)
return|;
block|}
comment|/* 	 * Push all writes to the server, so that the attribute cache 	 * doesn't get "out of sync" with the server. 	 * XXX There should be a better way! 	 */
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrpc_link
argument_list|(
name|tdvp
argument_list|,
name|vp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|dnfsva
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|attrflag
argument_list|,
operator|&
name|dattrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tdnp
operator|=
name|VTONFS
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|tdnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|tdnp
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
name|dattrflag
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|tdnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|tdvp
argument_list|,
operator|&
name|dnfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tdnp
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|tdnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If negative lookup caching is enabled, I might as well 	 * add an entry for this node. Not necessary for correctness, 	 * but if negative caching is enabled, then the system 	 * must care about lookup caching hit rate, so... 	 */
if|if
condition|(
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|->
name|nm_negnametimeo
operator|!=
literal|0
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
operator|&&
name|attrflag
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|cache_enter_time
argument_list|(
name|tdvp
argument_list|,
name|vp
argument_list|,
name|cnp
argument_list|,
operator|&
name|nfsva
operator|.
name|na_ctime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|cnp
operator|->
name|cn_thread
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs symbolic link create call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_symlink
parameter_list|(
name|struct
name|vop_symlink_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|,
name|dnfsva
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|NULL
decl_stmt|,
modifier|*
name|dnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|newvp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|attrflag
decl_stmt|,
name|dattrflag
decl_stmt|,
name|ret
decl_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|VLNK
expr_stmt|;
name|error
operator|=
name|nfsrpc_symlink
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|ap
operator|->
name|a_target
argument_list|,
name|vap
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|dnfsva
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|nfhp
argument_list|,
operator|&
name|attrflag
argument_list|,
operator|&
name|dattrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfhp
condition|)
block|{
name|ret
operator|=
name|nfscl_nget
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|dvp
argument_list|,
name|nfhp
argument_list|,
name|cnp
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|np
argument_list|,
name|NULL
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|ret
expr_stmt|;
block|}
if|if
condition|(
name|newvp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|attrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 		 * If we do not have an error and we could not extract the 		 * newvp from the response due to the request being NFSv2, we 		 * have to do a lookup in order to obtain a newvp to return. 		 */
name|error
operator|=
name|nfs_lookitup
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|newvp
condition|)
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|dvp
argument_list|)
condition|)
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|cnp
operator|->
name|cn_thread
argument_list|,
name|error
argument_list|,
name|vap
operator|->
name|va_uid
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|newvp
expr_stmt|;
block|}
name|dnp
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
name|dattrflag
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|dvp
argument_list|,
operator|&
name|dnfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dnp
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If negative lookup caching is enabled, I might as well 	 * add an entry for this node. Not necessary for correctness, 	 * but if negative caching is enabled, then the system 	 * must care about lookup caching hit rate, so... 	 */
if|if
condition|(
name|VFSTONFS
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|)
operator|->
name|nm_negnametimeo
operator|!=
literal|0
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
operator|&&
name|attrflag
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|cache_enter_time
argument_list|(
name|dvp
argument_list|,
name|newvp
argument_list|,
name|cnp
argument_list|,
operator|&
name|nfsva
operator|.
name|na_ctime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs make dir call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_mkdir
parameter_list|(
name|struct
name|vop_mkdir_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|NULL
decl_stmt|,
modifier|*
name|dnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|newvp
init|=
name|NULL
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|,
name|dnfsva
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|attrflag
decl_stmt|,
name|dattrflag
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|dvp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vap
operator|->
name|va_type
operator|=
name|VDIR
expr_stmt|;
name|error
operator|=
name|nfsrpc_mkdir
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|vap
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|dnfsva
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|nfhp
argument_list|,
operator|&
name|attrflag
argument_list|,
operator|&
name|dattrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dnp
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
name|dattrflag
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|dvp
argument_list|,
operator|&
name|dnfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dnp
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfhp
condition|)
block|{
name|ret
operator|=
name|nfscl_nget
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|dvp
argument_list|,
name|nfhp
argument_list|,
name|cnp
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|np
argument_list|,
name|NULL
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|ret
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
name|newvp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|nfs_lookitup
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
name|error
operator|=
name|EEXIST
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|newvp
condition|)
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|dvp
argument_list|)
condition|)
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|cnp
operator|->
name|cn_thread
argument_list|,
name|error
argument_list|,
name|vap
operator|->
name|va_uid
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If negative lookup caching is enabled, I might as well 		 * add an entry for this node. Not necessary for correctness, 		 * but if negative caching is enabled, then the system 		 * must care about lookup caching hit rate, so... 		 */
if|if
condition|(
name|VFSTONFS
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|)
operator|->
name|nm_negnametimeo
operator|!=
literal|0
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
operator|&&
name|attrflag
operator|!=
literal|0
operator|&&
name|dattrflag
operator|!=
literal|0
condition|)
name|cache_enter_time
argument_list|(
name|dvp
argument_list|,
name|newvp
argument_list|,
name|cnp
argument_list|,
operator|&
name|nfsva
operator|.
name|na_ctime
argument_list|,
operator|&
name|dnfsva
operator|.
name|na_ctime
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|newvp
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs remove directory call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_rmdir
parameter_list|(
name|struct
name|vop_rmdir_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|dnp
decl_stmt|;
name|struct
name|nfsvattr
name|dnfsva
decl_stmt|;
name|int
name|error
decl_stmt|,
name|dattrflag
decl_stmt|;
if|if
condition|(
name|dvp
operator|==
name|vp
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|nfsrpc_rmdir
argument_list|(
name|dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|dnfsva
argument_list|,
operator|&
name|dattrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dnp
operator|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|n_flag
operator||=
name|NMODIFIED
expr_stmt|;
if|if
condition|(
name|dattrflag
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|dvp
argument_list|,
operator|&
name|dnfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dnp
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|dnp
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
name|cache_purge
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|NFS_ISV4
argument_list|(
name|dvp
argument_list|)
condition|)
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|cnp
operator|->
name|cn_thread
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Kludge: Map ENOENT => 0 assuming that you have a reply to a retry. 	 */
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs readdir call  */
end_comment

begin_function
specifier|static
name|int
name|nfs_readdir
parameter_list|(
name|struct
name|vop_readdir_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|int
name|tresid
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * First, check for hit on the EOF offset cache 	 */
if|if
condition|(
name|np
operator|->
name|n_direofoffset
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_offset
operator|>=
name|np
operator|->
name|n_direofoffset
operator|&&
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
operator|&&
name|np
operator|->
name|n_change
operator|==
name|vattr
operator|.
name|va_filerev
operator|)
operator|||
operator|!
name|NFS_TIMESPEC_COMPARE
argument_list|(
operator|&
name|np
operator|->
name|n_mtime
argument_list|,
operator|&
name|vattr
operator|.
name|va_mtime
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|NFSINCRGLOBAL
argument_list|(
name|newnfsstats
operator|.
name|direofcache_hits
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Call ncl_bioread() to do the real work. 	 */
name|tresid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|error
operator|=
name|ncl_bioread
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|uio
operator|->
name|uio_resid
operator|==
name|tresid
condition|)
name|NFSINCRGLOBAL
argument_list|(
name|newnfsstats
operator|.
name|direofcache_misses
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Readdir rpc call.  * Called from below the buffer cache by ncl_doio().  */
end_comment

begin_function
name|int
name|ncl_readdirrpc
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|nfsuint64
modifier|*
name|cookiep
decl_stmt|,
name|cookie
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|dnp
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|eof
decl_stmt|,
name|attrflag
decl_stmt|;
name|KASSERT
argument_list|(
name|uiop
operator|->
name|uio_iovcnt
operator|==
literal|1
operator|&&
operator|(
name|uiop
operator|->
name|uio_offset
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|uiop
operator|->
name|uio_resid
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"nfs readdirrpc bad uio"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If there is no cookie, assume directory was stale. 	 */
name|ncl_dircookie_lock
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|cookiep
operator|=
name|ncl_getcookie
argument_list|(
name|dnp
argument_list|,
name|uiop
operator|->
name|uio_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiep
condition|)
block|{
name|cookie
operator|=
operator|*
name|cookiep
expr_stmt|;
name|ncl_dircookie_unlock
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ncl_dircookie_unlock
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NFSERR_BAD_COOKIE
operator|)
return|;
block|}
if|if
condition|(
name|NFSHASNFSV3
argument_list|(
name|nmp
argument_list|)
operator|&&
operator|!
name|NFSHASGOTFSINFO
argument_list|(
name|nmp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ncl_fsinfo
argument_list|(
name|nmp
argument_list|,
name|vp
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrpc_readdir
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
operator|&
name|cookie
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|attrflag
argument_list|,
operator|&
name|eof
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 		 * We are now either at the end of the directory or have filled 		 * the block. 		 */
if|if
condition|(
name|eof
condition|)
name|dnp
operator|->
name|n_direofoffset
operator|=
name|uiop
operator|->
name|uio_offset
expr_stmt|;
else|else
block|{
if|if
condition|(
name|uiop
operator|->
name|uio_resid
operator|>
literal|0
condition|)
name|ncl_printf
argument_list|(
literal|"EEK! readdirrpc resid> 0\n"
argument_list|)
expr_stmt|;
name|ncl_dircookie_lock
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|cookiep
operator|=
name|ncl_getcookie
argument_list|(
name|dnp
argument_list|,
name|uiop
operator|->
name|uio_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|cookiep
operator|=
name|cookie
expr_stmt|;
name|ncl_dircookie_unlock
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NFS V3 readdir plus RPC. Used in place of ncl_readdirrpc().  */
end_comment

begin_function
name|int
name|ncl_readdirplusrpc
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|nfsuint64
modifier|*
name|cookiep
decl_stmt|,
name|cookie
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|dnp
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|attrflag
decl_stmt|,
name|eof
decl_stmt|;
name|KASSERT
argument_list|(
name|uiop
operator|->
name|uio_iovcnt
operator|==
literal|1
operator|&&
operator|(
name|uiop
operator|->
name|uio_offset
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|uiop
operator|->
name|uio_resid
operator|&
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"nfs readdirplusrpc bad uio"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If there is no cookie, assume directory was stale. 	 */
name|ncl_dircookie_lock
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|cookiep
operator|=
name|ncl_getcookie
argument_list|(
name|dnp
argument_list|,
name|uiop
operator|->
name|uio_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiep
condition|)
block|{
name|cookie
operator|=
operator|*
name|cookiep
expr_stmt|;
name|ncl_dircookie_unlock
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ncl_dircookie_unlock
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NFSERR_BAD_COOKIE
operator|)
return|;
block|}
if|if
condition|(
name|NFSHASNFSV3
argument_list|(
name|nmp
argument_list|)
operator|&&
operator|!
name|NFSHASGOTFSINFO
argument_list|(
name|nmp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ncl_fsinfo
argument_list|(
name|nmp
argument_list|,
name|vp
argument_list|,
name|cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrpc_readdirplus
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
operator|&
name|cookie
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|attrflag
argument_list|,
operator|&
name|eof
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 		 * We are now either at end of the directory or have filled the 		 * the block. 		 */
if|if
condition|(
name|eof
condition|)
name|dnp
operator|->
name|n_direofoffset
operator|=
name|uiop
operator|->
name|uio_offset
expr_stmt|;
else|else
block|{
if|if
condition|(
name|uiop
operator|->
name|uio_resid
operator|>
literal|0
condition|)
name|ncl_printf
argument_list|(
literal|"EEK! readdirplusrpc resid> 0\n"
argument_list|)
expr_stmt|;
name|ncl_dircookie_lock
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
name|cookiep
operator|=
name|ncl_getcookie
argument_list|(
name|dnp
argument_list|,
name|uiop
operator|->
name|uio_offset
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|*
name|cookiep
operator|=
name|cookie
expr_stmt|;
name|ncl_dircookie_unlock
argument_list|(
name|dnp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Silly rename. To make the NFS filesystem that is stateless look a little  * more like the "ufs" a remove of an active vnode is translated to a rename  * to a funny looking filename that is removed by nfs_inactive on the  * nfsnode. There is the potential for another process on a different client  * to create the same funny name between the nfs_lookitup() fails and the  * nfs_rename() completes, but...  */
end_comment

begin_function
specifier|static
name|int
name|nfs_sillyrename
parameter_list|(
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|)
block|{
name|struct
name|sillyrename
modifier|*
name|sp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|;
name|int
name|error
decl_stmt|;
name|short
name|pid
decl_stmt|;
name|unsigned
name|int
name|lticks
decl_stmt|;
name|cache_purge
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|np
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
argument_list|,
operator|(
literal|"nfs: sillyrename dir"
operator|)
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|sp
argument_list|,
expr|struct
name|sillyrename
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sillyrename
argument_list|)
argument_list|,
name|M_NEWNFSREQ
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_cred
operator|=
name|crhold
argument_list|(
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_dvp
operator|=
name|dvp
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
comment|/*  	 * Fudge together a funny name. 	 * Changing the format of the funny name to accomodate more  	 * sillynames per directory. 	 * The name is now changed to .nfs.<ticks>.<pid>.4, where ticks is  	 * CPU ticks since boot. 	 */
name|pid
operator|=
name|cnp
operator|->
name|cn_thread
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
name|lticks
operator|=
operator|(
name|unsigned
name|int
operator|)
name|ticks
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sp
operator|->
name|s_namlen
operator|=
name|sprintf
argument_list|(
name|sp
operator|->
name|s_name
argument_list|,
literal|".nfs.%08x.%04x4.4"
argument_list|,
name|lticks
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfs_lookitup
argument_list|(
name|dvp
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|sp
operator|->
name|s_namlen
argument_list|,
name|sp
operator|->
name|s_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
name|NULL
argument_list|)
condition|)
break|break;
name|lticks
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|nfs_renameit
argument_list|(
name|dvp
argument_list|,
name|vp
argument_list|,
name|cnp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
name|nfs_lookitup
argument_list|(
name|dvp
argument_list|,
name|sp
operator|->
name|s_name
argument_list|,
name|sp
operator|->
name|s_namlen
argument_list|,
name|sp
operator|->
name|s_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
operator|&
name|np
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_sillyrename
operator|=
name|sp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|vrele
argument_list|(
name|sp
operator|->
name|s_dvp
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|sp
operator|->
name|s_cred
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sp
argument_list|,
name|M_NEWNFSREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a file name and optionally either update the file handle or  * allocate an nfsnode, depending on the value of npp.  * npp == NULL	--> just do the lookup  * *npp == NULL --> allocate a new nfsnode and make sure attributes are  *			handled too  * *npp != NULL --> update the file handle in the vnode  */
end_comment

begin_function
specifier|static
name|int
name|nfs_lookitup
parameter_list|(
name|struct
name|vnode
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|nfsnode
modifier|*
modifier|*
name|npp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|newvp
init|=
name|NULL
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
decl_stmt|,
modifier|*
name|dnp
init|=
name|VTONFS
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|nfsfh
modifier|*
name|nfhp
decl_stmt|,
modifier|*
name|onfhp
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|,
name|dnfsva
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|attrflag
decl_stmt|,
name|dattrflag
decl_stmt|;
name|u_int
name|hash
decl_stmt|;
name|error
operator|=
name|nfsrpc_lookup
argument_list|(
name|dvp
argument_list|,
name|name
argument_list|,
name|len
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
operator|&
name|dnfsva
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|nfhp
argument_list|,
operator|&
name|attrflag
argument_list|,
operator|&
name|dattrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dattrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|dvp
argument_list|,
operator|&
name|dnfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|npp
operator|&&
operator|!
name|error
condition|)
block|{
if|if
condition|(
operator|*
name|npp
operator|!=
name|NULL
condition|)
block|{
name|np
operator|=
operator|*
name|npp
expr_stmt|;
name|vp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* 		     * For NFSv4, check to see if it is the same name and 		     * replace the name, if it is different. 		     */
if|if
condition|(
name|np
operator|->
name|n_v4
operator|!=
name|NULL
operator|&&
name|nfsva
operator|.
name|na_type
operator|==
name|VREG
operator|&&
operator|(
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
operator|!=
name|len
operator|||
name|NFSBCMP
argument_list|(
name|name
argument_list|,
name|NFS4NODENAME
argument_list|(
name|np
operator|->
name|n_v4
argument_list|)
argument_list|,
name|len
argument_list|)
operator|||
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
operator|!=
name|np
operator|->
name|n_v4
operator|->
name|n4_fhlen
operator|||
name|NFSBCMP
argument_list|(
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_data
argument_list|,
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
block|{
name|char
name|nnn
index|[
literal|100
index|]
decl_stmt|;
name|int
name|nnnl
decl_stmt|;
name|nnnl
operator|=
operator|(
name|len
operator|<
literal|100
operator|)
condition|?
name|len
else|:
literal|99
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|nnn
argument_list|,
name|nnnl
argument_list|)
expr_stmt|;
name|nnn
index|[
name|nnnl
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"replace=%s\n"
argument_list|,
name|nnn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|np
operator|->
name|n_v4
argument_list|,
name|M_NFSV4NODE
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|np
operator|->
name|n_v4
argument_list|,
expr|struct
name|nfsv4node
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsv4node
argument_list|)
operator|+
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
operator|+
name|len
operator|-
literal|1
argument_list|,
name|M_NFSV4NODE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_v4
operator|->
name|n4_fhlen
operator|=
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
expr_stmt|;
name|np
operator|->
name|n_v4
operator|->
name|n4_namelen
operator|=
name|len
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_fh
argument_list|,
name|np
operator|->
name|n_v4
operator|->
name|n4_data
argument_list|,
name|dnp
operator|->
name|n_fhp
operator|->
name|nfh_len
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|name
argument_list|,
name|NFS4NODENAME
argument_list|(
name|np
operator|->
name|n_v4
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|hash
operator|=
name|fnv_32_buf
argument_list|(
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|,
name|FNV1_32_INIT
argument_list|)
expr_stmt|;
name|onfhp
operator|=
name|np
operator|->
name|n_fhp
expr_stmt|;
comment|/* 		     * Rehash node for new file handle. 		     */
name|vfs_hash_rehash
argument_list|(
name|vp
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_fhp
operator|=
name|nfhp
expr_stmt|;
if|if
condition|(
name|onfhp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|onfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFS_CMPFH
argument_list|(
name|dnp
argument_list|,
name|nfhp
operator|->
name|nfh_fh
argument_list|,
name|nfhp
operator|->
name|nfh_len
argument_list|)
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|nfhp
argument_list|,
name|M_NFSFH
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|newvp
operator|=
name|dvp
expr_stmt|;
block|}
else|else
block|{
name|cn
operator|.
name|cn_nameptr
operator|=
name|name
expr_stmt|;
name|cn
operator|.
name|cn_namelen
operator|=
name|len
expr_stmt|;
name|error
operator|=
name|nfscl_nget
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|dvp
argument_list|,
name|nfhp
argument_list|,
operator|&
name|cn
argument_list|,
name|td
argument_list|,
operator|&
name|np
argument_list|,
name|NULL
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|newvp
operator|=
name|NFSTOV
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|attrflag
operator|&&
operator|*
name|npp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|newvp
operator|==
name|dvp
condition|)
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|attrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|newvp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|npp
operator|&&
operator|*
name|npp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|newvp
condition|)
block|{
if|if
condition|(
name|newvp
operator|==
name|dvp
condition|)
name|vrele
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|newvp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|*
name|npp
operator|=
name|np
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|&&
name|NFS_ISV4
argument_list|(
name|dvp
argument_list|)
condition|)
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Nfs Version 3 and 4 commit rpc  */
end_comment

begin_function
name|int
name|ncl_commit
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|u_quad_t
name|offset
parameter_list|,
name|int
name|cnt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|attrflag
decl_stmt|;
name|u_char
name|verf
index|[
name|NFSX_VERF
index|]
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_HASWRITEVERF
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrpc_commit
argument_list|(
name|vp
argument_list|,
name|offset
argument_list|,
name|cnt
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
name|verf
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|attrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSBCMP
argument_list|(
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|nm_verf
argument_list|,
name|verf
argument_list|,
name|NFSX_VERF
argument_list|)
condition|)
block|{
name|NFSBCOPY
argument_list|(
name|verf
argument_list|,
operator|(
name|caddr_t
operator|)
name|nmp
operator|->
name|nm_verf
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|error
operator|=
name|NFSERR_STALEWRITEVERF
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|attrflag
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|error
operator|=
name|nfscl_maperr
argument_list|(
name|td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Strategy routine.  * For async requests when nfsiod(s) are running, queue the request by  * calling ncl_asyncio(), otherwise just all ncl_doio() to do the  * request.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_strategy
parameter_list|(
name|struct
name|vop_strategy_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cr
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
argument_list|,
operator|(
literal|"nfs_strategy: buffer %p unexpectedly marked B_DONE"
operator|,
name|bp
operator|)
argument_list|)
expr_stmt|;
name|BUF_ASSERT_HELD
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_iocmd
operator|==
name|BIO_READ
condition|)
name|cr
operator|=
name|bp
operator|->
name|b_rcred
expr_stmt|;
else|else
name|cr
operator|=
name|bp
operator|->
name|b_wcred
expr_stmt|;
comment|/* 	 * If the op is asynchronous and an i/o daemon is waiting 	 * queue the request, wake it up and wait for completion 	 * otherwise just do it ourselves. 	 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
operator|||
name|ncl_asyncio
argument_list|(
name|VFSTONFS
argument_list|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
argument_list|)
argument_list|,
name|bp
argument_list|,
name|NOCRED
argument_list|,
name|curthread
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ncl_doio
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|bp
argument_list|,
name|cr
argument_list|,
name|curthread
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * fsync vnode op. Just call ncl_flush() with commit == 1.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nfs_fsync
parameter_list|(
name|struct
name|vop_fsync_args
modifier|*
name|ap
parameter_list|)
block|{
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
block|{
comment|/* 		 * For NFS, metadata is changed synchronously on the server, 		 * so there is nothing to flush. Also, ncl_flush() clears 		 * the NMODIFIED flag and that shouldn't be done here for 		 * directories. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ncl_flush
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_waitfor
argument_list|,
name|NULL
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush all the blocks associated with a vnode.  * 	Walk through the buffer pool and push any dirty pages  *	associated with the vnode.  * If the called_from_renewthread argument is TRUE, it has been called  * from the NFSv4 renew thread and, as such, cannot block indefinitely  * waiting for a buffer write to complete.  */
end_comment

begin_function
name|int
name|ncl_flush
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|waitfor
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|commit
parameter_list|,
name|int
name|called_from_renewthread
parameter_list|)
block|{
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|slptimeo
init|=
literal|0
decl_stmt|,
name|slpflag
init|=
literal|0
decl_stmt|,
name|retv
decl_stmt|,
name|bvecpos
decl_stmt|;
name|int
name|passone
init|=
literal|1
decl_stmt|,
name|trycnt
init|=
literal|0
decl_stmt|;
name|u_quad_t
name|off
decl_stmt|,
name|endoff
decl_stmt|,
name|toff
decl_stmt|;
name|struct
name|ucred
modifier|*
name|wcred
init|=
name|NULL
decl_stmt|;
name|struct
name|buf
modifier|*
modifier|*
name|bvec
init|=
name|NULL
decl_stmt|;
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
ifndef|#
directive|ifndef
name|NFS_COMMITBVECSIZ
define|#
directive|define
name|NFS_COMMITBVECSIZ
value|20
endif|#
directive|endif
name|struct
name|buf
modifier|*
name|bvec_on_stack
index|[
name|NFS_COMMITBVECSIZ
index|]
decl_stmt|;
name|int
name|bvecsize
init|=
literal|0
decl_stmt|,
name|bveccount
decl_stmt|;
if|if
condition|(
name|called_from_renewthread
operator|!=
literal|0
condition|)
name|slptimeo
operator|=
name|hz
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_INT
condition|)
name|slpflag
operator|=
name|NFS_PCATCH
expr_stmt|;
if|if
condition|(
operator|!
name|commit
condition|)
name|passone
operator|=
literal|0
expr_stmt|;
name|bo
operator|=
operator|&
name|vp
operator|->
name|v_bufobj
expr_stmt|;
comment|/* 	 * A b_flags == (B_DELWRI | B_NEEDCOMMIT) block has been written to the 	 * server, but has not been committed to stable storage on the server 	 * yet. On the first pass, the byte range is worked out and the commit 	 * rpc is done. On the second pass, ncl_writebp() is called to do the 	 * job. 	 */
name|again
label|:
name|off
operator|=
operator|(
name|u_quad_t
operator|)
operator|-
literal|1
expr_stmt|;
name|endoff
operator|=
literal|0
expr_stmt|;
name|bvecpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NFS_ISV34
argument_list|(
name|vp
argument_list|)
operator|&&
name|commit
condition|)
block|{
if|if
condition|(
name|bvec
operator|!=
name|NULL
operator|&&
name|bvec
operator|!=
name|bvec_on_stack
condition|)
name|free
argument_list|(
name|bvec
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
comment|/* 		 * Count up how many buffers waiting for a commit. 		 */
name|bveccount
operator|=
literal|0
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&bo->bo_dirty.bv_hd
argument_list|,
argument|b_bobufs
argument_list|,
argument|nbp
argument_list|)
block|{
if|if
condition|(
operator|!
name|BUF_ISLOCKED
argument_list|(
name|bp
argument_list|)
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_DELWRI
operator||
name|B_NEEDCOMMIT
operator|)
operator|)
operator|==
operator|(
name|B_DELWRI
operator||
name|B_NEEDCOMMIT
operator|)
condition|)
name|bveccount
operator|++
expr_stmt|;
block|}
comment|/* 		 * Allocate space to remember the list of bufs to commit.  It is 		 * important to use M_NOWAIT here to avoid a race with nfs_write. 		 * If we can't get memory (for whatever reason), we will end up 		 * committing the buffers one-by-one in the loop below. 		 */
if|if
condition|(
name|bveccount
operator|>
name|NFS_COMMITBVECSIZ
condition|)
block|{
comment|/* 			 * Release the vnode interlock to avoid a lock 			 * order reversal. 			 */
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|bvec
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|bveccount
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|buf
operator|*
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|bvec
operator|==
name|NULL
condition|)
block|{
name|bvec
operator|=
name|bvec_on_stack
expr_stmt|;
name|bvecsize
operator|=
name|NFS_COMMITBVECSIZ
expr_stmt|;
block|}
else|else
name|bvecsize
operator|=
name|bveccount
expr_stmt|;
block|}
else|else
block|{
name|bvec
operator|=
name|bvec_on_stack
expr_stmt|;
name|bvecsize
operator|=
name|NFS_COMMITBVECSIZ
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&bo->bo_dirty.bv_hd
argument_list|,
argument|b_bobufs
argument_list|,
argument|nbp
argument_list|)
block|{
if|if
condition|(
name|bvecpos
operator|>=
name|bvecsize
condition|)
break|break;
if|if
condition|(
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|nbp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_bobufs
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_DELWRI
operator||
name|B_NEEDCOMMIT
operator|)
operator|)
operator|!=
operator|(
name|B_DELWRI
operator||
name|B_NEEDCOMMIT
operator|)
condition|)
block|{
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|nbp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_bobufs
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 			 * Work out if all buffers are using the same cred 			 * so we can deal with them all with one commit. 			 * 			 * NOTE: we are not clearing B_DONE here, so we have 			 * to do it later on in this routine if we intend to 			 * initiate I/O on the bp. 			 * 			 * Note: to avoid loopback deadlocks, we do not 			 * assign b_runningbufspace. 			 */
if|if
condition|(
name|wcred
operator|==
name|NULL
condition|)
name|wcred
operator|=
name|bp
operator|->
name|b_wcred
expr_stmt|;
elseif|else
if|if
condition|(
name|wcred
operator|!=
name|bp
operator|->
name|b_wcred
condition|)
name|wcred
operator|=
name|NOCRED
expr_stmt|;
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
comment|/* 			 * bp is protected by being locked, but nbp is not 			 * and vfs_busy_pages() may sleep.  We have to 			 * recalculate nbp. 			 */
name|nbp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_bobufs
argument_list|)
expr_stmt|;
comment|/* 			 * A list of these buffers is kept so that the 			 * second loop knows which buffers have actually 			 * been committed. This is necessary, since there 			 * may be a race between the commit rpc and new 			 * uncommitted writes on the file. 			 */
name|bvec
index|[
name|bvecpos
operator|++
index|]
operator|=
name|bp
expr_stmt|;
name|toff
operator|=
operator|(
operator|(
name|u_quad_t
operator|)
name|bp
operator|->
name|b_blkno
operator|)
operator|*
name|DEV_BSIZE
operator|+
name|bp
operator|->
name|b_dirtyoff
expr_stmt|;
if|if
condition|(
name|toff
operator|<
name|off
condition|)
name|off
operator|=
name|toff
expr_stmt|;
name|toff
operator|+=
call|(
name|u_quad_t
call|)
argument_list|(
name|bp
operator|->
name|b_dirtyend
operator|-
name|bp
operator|->
name|b_dirtyoff
argument_list|)
expr_stmt|;
if|if
condition|(
name|toff
operator|>
name|endoff
condition|)
name|endoff
operator|=
name|toff
expr_stmt|;
block|}
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bvecpos
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Commit data on the server, as required. 		 * If all bufs are using the same wcred, then use that with 		 * one call for all of them, otherwise commit each one 		 * separately. 		 */
if|if
condition|(
name|wcred
operator|!=
name|NOCRED
condition|)
name|retv
operator|=
name|ncl_commit
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
call|(
name|int
call|)
argument_list|(
name|endoff
operator|-
name|off
argument_list|)
argument_list|,
name|wcred
argument_list|,
name|td
argument_list|)
expr_stmt|;
else|else
block|{
name|retv
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bvecpos
condition|;
name|i
operator|++
control|)
block|{
name|off_t
name|off
decl_stmt|,
name|size
decl_stmt|;
name|bp
operator|=
name|bvec
index|[
name|i
index|]
expr_stmt|;
name|off
operator|=
operator|(
operator|(
name|u_quad_t
operator|)
name|bp
operator|->
name|b_blkno
operator|)
operator|*
name|DEV_BSIZE
operator|+
name|bp
operator|->
name|b_dirtyoff
expr_stmt|;
name|size
operator|=
call|(
name|u_quad_t
call|)
argument_list|(
name|bp
operator|->
name|b_dirtyend
operator|-
name|bp
operator|->
name|b_dirtyoff
argument_list|)
expr_stmt|;
name|retv
operator|=
name|ncl_commit
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
name|bp
operator|->
name|b_wcred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|retv
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|retv
operator|==
name|NFSERR_STALEWRITEVERF
condition|)
name|ncl_clearcommit
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
comment|/* 		 * Now, either mark the blocks I/O done or mark the 		 * blocks dirty, depending on whether the commit 		 * succeeded. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bvecpos
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
name|bvec
index|[
name|i
index|]
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_NEEDCOMMIT
operator||
name|B_CLUSTEROK
operator|)
expr_stmt|;
if|if
condition|(
name|retv
condition|)
block|{
comment|/* 				 * Error, leave B_DELWRI intact 				 */
name|vfs_unbusy_pages
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Success, remove B_DELWRI ( bundirty() ). 				 * 				 * b_dirtyoff/b_dirtyend seem to be NFS 				 * specific.  We should probably move that 				 * into bundirty(). XXX 				 */
name|bufobj_wref
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ASYNC
expr_stmt|;
name|bundirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_DONE
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator|&=
operator|~
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|b_dirtyoff
operator|=
name|bp
operator|->
name|b_dirtyend
operator|=
literal|0
expr_stmt|;
name|bufdone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Start/do any write(s) that are required. 	 */
name|loop
label|:
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&bo->bo_dirty.bv_hd
argument_list|,
argument|b_bobufs
argument_list|,
argument|nbp
argument_list|)
block|{
if|if
condition|(
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|waitfor
operator|!=
name|MNT_WAIT
operator|||
name|passone
condition|)
continue|continue;
name|error
operator|=
name|BUF_TIMELOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_SLEEPFAIL
operator||
name|LK_INTERLOCK
argument_list|,
name|BO_MTX
argument_list|(
name|bo
argument_list|)
argument_list|,
literal|"nfsfsync"
argument_list|,
name|slpflag
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|error
operator|==
name|ENOLCK
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|called_from_renewthread
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Return EIO so the flush will be retried 				 * later. 				 */
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|newnfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|td
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|slpflag
operator|&
name|PCATCH
condition|)
block|{
name|slpflag
operator|=
literal|0
expr_stmt|;
name|slptimeo
operator|=
literal|2
operator|*
name|hz
expr_stmt|;
block|}
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs_fsync: not dirty"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|passone
operator|||
operator|!
name|commit
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_NEEDCOMMIT
operator|)
condition|)
block|{
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|passone
operator|||
operator|!
name|commit
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_ASYNC
expr_stmt|;
else|else
name|bp
operator|->
name|b_flags
operator||=
name|B_ASYNC
expr_stmt|;
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newnfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|td
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|passone
condition|)
block|{
name|passone
operator|=
literal|0
expr_stmt|;
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|waitfor
operator|==
name|MNT_WAIT
condition|)
block|{
while|while
condition|(
name|bo
operator|->
name|bo_numoutput
condition|)
block|{
name|error
operator|=
name|bufobj_wwait
argument_list|(
name|bo
argument_list|,
name|slpflag
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
if|if
condition|(
name|called_from_renewthread
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Return EIO so that the flush will be 				 * retried later. 				 */
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|error
operator|=
name|newnfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|slpflag
operator|&
name|PCATCH
condition|)
block|{
name|slpflag
operator|=
literal|0
expr_stmt|;
name|slptimeo
operator|=
literal|2
operator|*
name|hz
expr_stmt|;
block|}
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bo
operator|->
name|bo_dirty
operator|.
name|bv_cnt
operator|!=
literal|0
operator|&&
name|commit
condition|)
block|{
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* 		 * Wait for all the async IO requests to drain 		 */
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|np
operator|->
name|n_directio_asyncwr
operator|>
literal|0
condition|)
block|{
name|np
operator|->
name|n_flag
operator||=
name|NFSYNCWAIT
expr_stmt|;
name|error
operator|=
name|newnfs_msleep
argument_list|(
name|td
argument_list|,
operator|&
name|np
operator|->
name|n_directio_asyncwr
argument_list|,
operator|&
name|np
operator|->
name|n_mtx
argument_list|,
name|slpflag
operator||
operator|(
name|PRIBIO
operator|+
literal|1
operator|)
argument_list|,
literal|"nfsfsync"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|newnfs_sigintr
argument_list|(
name|nmp
argument_list|,
name|td
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
block|}
else|else
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NWRITEERR
condition|)
block|{
name|error
operator|=
name|np
operator|->
name|n_error
expr_stmt|;
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NWRITEERR
expr_stmt|;
block|}
if|if
condition|(
name|commit
operator|&&
name|bo
operator|->
name|bo_dirty
operator|.
name|bv_cnt
operator|==
literal|0
operator|&&
name|bo
operator|->
name|bo_numoutput
operator|==
literal|0
operator|&&
name|np
operator|->
name|n_directio_asyncwr
operator|==
literal|0
condition|)
name|np
operator|->
name|n_flag
operator|&=
operator|~
name|NMODIFIED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|bvec
operator|!=
name|NULL
operator|&&
name|bvec
operator|!=
name|bvec_on_stack
condition|)
name|free
argument_list|(
name|bvec
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|commit
operator|!=
literal|0
operator|&&
name|waitfor
operator|==
name|MNT_WAIT
operator|&&
operator|(
name|bo
operator|->
name|bo_dirty
operator|.
name|bv_cnt
operator|!=
literal|0
operator|||
name|bo
operator|->
name|bo_numoutput
operator|!=
literal|0
operator|||
name|np
operator|->
name|n_directio_asyncwr
operator|!=
literal|0
operator|)
operator|&&
name|trycnt
operator|++
operator|<
literal|5
condition|)
block|{
comment|/* try, try again... */
name|passone
operator|=
literal|1
expr_stmt|;
name|wcred
operator|=
name|NULL
expr_stmt|;
name|bvec
operator|=
name|NULL
expr_stmt|;
name|bvecsize
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"try%d\n"
argument_list|,
name|trycnt
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NFS advisory byte-level locks.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_advlock
parameter_list|(
name|struct
name|vop_advlock_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|ap
operator|->
name|a_id
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* XXX */
name|struct
name|vattr
name|va
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|error
init|=
name|EOPNOTSUPP
decl_stmt|;
name|u_quad_t
name|size
decl_stmt|;
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
operator|&&
operator|(
name|ap
operator|->
name|a_flags
operator|&
operator|(
name|F_POSIX
operator||
name|F_FLOCK
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|ap
operator|->
name|a_flags
operator|&
name|F_POSIX
operator|)
operator|!=
literal|0
condition|)
name|cred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
else|else
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|NFSVOPLOCK
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
block|{
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
comment|/* 		 * If this is unlocking a write locked region, flush and 		 * commit them before unlocking. This is required by 		 * RFC3530 Sec. 9.3.2. 		 */
if|if
condition|(
name|ap
operator|->
name|a_op
operator|==
name|F_UNLCK
operator|&&
name|nfscl_checkwritelocked
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_fl
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
name|ap
operator|->
name|a_id
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
condition|)
operator|(
name|void
operator|)
name|ncl_flush
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Loop around doing the lock op, while a blocking lock 		 * must wait for the lock op to succeed. 		 */
do|do
block|{
name|ret
operator|=
name|nfsrpc_advlock
argument_list|(
name|vp
argument_list|,
name|np
operator|->
name|n_size
argument_list|,
name|ap
operator|->
name|a_op
argument_list|,
name|ap
operator|->
name|a_fl
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|td
argument_list|,
name|ap
operator|->
name|a_id
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_DENIED
operator|&&
operator|(
name|ap
operator|->
name|a_flags
operator|&
name|F_WAIT
operator|)
operator|&&
name|ap
operator|->
name|a_op
operator|==
name|F_SETLK
condition|)
block|{
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfs_catnap
argument_list|(
name|PZERO
operator||
name|PCATCH
argument_list|,
name|ret
argument_list|,
literal|"ncladvl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
name|NFSVOPLOCK
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
block|{
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
block|}
block|}
do|while
condition|(
name|ret
operator|==
name|NFSERR_DENIED
operator|&&
operator|(
name|ap
operator|->
name|a_flags
operator|&
name|F_WAIT
operator|)
operator|&&
name|ap
operator|->
name|a_op
operator|==
name|F_SETLK
condition|)
do|;
if|if
condition|(
name|ret
operator|==
name|NFSERR_DENIED
condition|)
block|{
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
name|EINVAL
operator|||
name|ret
operator|==
name|EBADF
operator|||
name|ret
operator|==
name|EINTR
condition|)
block|{
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
comment|/* 		 * Now, if we just got a lock, invalidate data in the buffer 		 * cache, as required, so that the coherency conforms with 		 * RFC3530 Sec. 9.3.2. 		 */
if|if
condition|(
name|ap
operator|->
name|a_op
operator|==
name|F_SETLK
condition|)
block|{
if|if
condition|(
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
operator|)
operator|==
literal|0
condition|)
block|{
name|np
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|np
operator|->
name|n_flag
operator|&
name|NMODIFIED
operator|)
operator|||
name|ret
operator|||
name|np
operator|->
name|n_change
operator|!=
name|va
operator|.
name|va_filerev
condition|)
block|{
operator|(
name|void
operator|)
name|ncl_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_attrstamp
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|np
operator|->
name|n_mtime
operator|=
name|va
operator|.
name|va_mtime
expr_stmt|;
name|np
operator|->
name|n_change
operator|=
name|va
operator|.
name|va_filerev
expr_stmt|;
block|}
block|}
block|}
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|error
operator|=
name|NFSVOPLOCK
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|->
name|nm_flag
operator|&
name|NFSMNT_NOLOCKD
operator|)
operator|!=
literal|0
condition|)
block|{
name|size
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_size
expr_stmt|;
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|lf_advlock
argument_list|(
name|ap
argument_list|,
operator|&
operator|(
name|vp
operator|->
name|v_lockf
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nfs_advlock_p
operator|!=
name|NULL
condition|)
name|error
operator|=
name|nfs_advlock_p
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|else
block|{
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOLCK
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NFS advisory byte-level locks.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_advlockasync
parameter_list|(
name|struct
name|vop_advlockasync_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|u_quad_t
name|size
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|error
operator|=
name|NFSVOPLOCK
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
operator|->
name|nm_flag
operator|&
name|NFSMNT_NOLOCKD
operator|)
operator|!=
literal|0
condition|)
block|{
name|size
operator|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
operator|->
name|n_size
expr_stmt|;
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|lf_advlockasync
argument_list|(
name|ap
argument_list|,
operator|&
operator|(
name|vp
operator|->
name|v_lockf
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print out the contents of an nfsnode.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_print
parameter_list|(
name|struct
name|vop_print_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|ncl_printf
argument_list|(
literal|"\tfileid %ld fsid 0x%x"
argument_list|,
name|np
operator|->
name|n_vattr
operator|.
name|na_fileid
argument_list|,
name|np
operator|->
name|n_vattr
operator|.
name|na_fsid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VFIFO
condition|)
name|fifo_printinfo
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the "real" nfs::bwrite(struct buf*).  * We set B_CACHE if this is a VMIO buffer.  */
end_comment

begin_function
name|int
name|ncl_writebp
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|force
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|oldflags
init|=
name|bp
operator|->
name|b_flags
decl_stmt|;
if|#
directive|if
literal|0
block|int retv = 1; 	off_t off;
endif|#
directive|endif
name|BUF_ASSERT_HELD
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_CACHE
expr_stmt|;
comment|/* 	 * Undirty the bp.  We will redirty it later if the I/O fails. 	 */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bundirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_DONE
expr_stmt|;
name|bp
operator|->
name|b_ioflags
operator|&=
operator|~
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|b_iocmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|bufobj_wref
argument_list|(
name|bp
operator|->
name|b_bufobj
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|td_ru
operator|.
name|ru_oublock
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Note: to avoid loopback deadlocks, we do not 	 * assign b_runningbufspace. 	 */
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BUF_KERNPROC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_iooffset
operator|=
name|dbtob
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|bstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldflags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|rtval
init|=
name|bufwait
argument_list|(
name|bp
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldflags
operator|&
name|B_DELWRI
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|reassignbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtval
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfs special file access vnode op.  * Essentially just get vattr and then imitate iaccess() since the device is  * local to the client.  */
end_comment

begin_function
specifier|static
name|int
name|nfsspec_access
parameter_list|(
name|struct
name|vop_access_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|accmode_t
name|accmode
init|=
name|ap
operator|->
name|a_accmode
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Disallow write attempts on filesystems mounted read-only; 	 * unless the file is a socket, fifo, or a block or character 	 * device resident on the filesystem. 	 */
if|if
condition|(
operator|(
name|accmode
operator|&
name|VWRITE
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
return|return
operator|(
name|EROFS
operator|)
return|;
default|default:
break|break;
block|}
block|}
name|vap
operator|=
operator|&
name|vattr
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|vaccess
argument_list|(
name|vp
operator|->
name|v_type
argument_list|,
name|vap
operator|->
name|va_mode
argument_list|,
name|vap
operator|->
name|va_uid
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|,
name|accmode
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Read wrapper for fifos.  */
end_comment

begin_function
specifier|static
name|int
name|nfsfifo_read
parameter_list|(
name|struct
name|vop_read_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Set access flag. 	 */
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_flag
operator||=
name|NACC
expr_stmt|;
name|getnanotime
argument_list|(
operator|&
name|np
operator|->
name|n_atim
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|fifo_specops
operator|.
name|vop_read
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Write wrapper for fifos.  */
end_comment

begin_function
specifier|static
name|int
name|nfsfifo_write
parameter_list|(
name|struct
name|vop_write_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
comment|/* 	 * Set update flag. 	 */
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_flag
operator||=
name|NUPD
expr_stmt|;
name|getnanotime
argument_list|(
operator|&
name|np
operator|->
name|n_mtim
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|fifo_specops
operator|.
name|vop_write
argument_list|(
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close wrapper for fifos.  *  * Update the times on the nfsnode then do fifo close.  */
end_comment

begin_function
specifier|static
name|int
name|nfsfifo_close
parameter_list|(
name|struct
name|vop_close_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|nfsnode
modifier|*
name|np
init|=
name|VTONFS
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
operator|(
name|NACC
operator||
name|NUPD
operator|)
condition|)
block|{
name|getnanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NACC
condition|)
name|np
operator|->
name|n_atim
operator|=
name|ts
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NUPD
condition|)
name|np
operator|->
name|n_mtim
operator|=
name|ts
expr_stmt|;
name|np
operator|->
name|n_flag
operator||=
name|NCHG
expr_stmt|;
if|if
condition|(
name|vrefcnt
argument_list|(
name|vp
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|VATTR_NULL
argument_list|(
operator|&
name|vattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NACC
condition|)
name|vattr
operator|.
name|va_atime
operator|=
name|np
operator|->
name|n_atim
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_flag
operator|&
name|NUPD
condition|)
name|vattr
operator|.
name|va_mtime
operator|=
name|np
operator|->
name|n_mtim
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|np
operator|->
name|n_mtx
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|fifo_specops
operator|.
name|vop_close
argument_list|(
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Just call ncl_writebp() with the force argument set to 1.  *  * NOTE: B_DONE may or may not be set in a_bp on call.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_bwrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
return|return
operator|(
name|ncl_writebp
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|,
name|curthread
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|buf_ops
name|buf_ops_newnfs
init|=
block|{
operator|.
name|bop_name
operator|=
literal|"buf_ops_nfs"
block|,
operator|.
name|bop_write
operator|=
name|nfs_bwrite
block|,
operator|.
name|bop_strategy
operator|=
name|bufstrategy
block|,
operator|.
name|bop_sync
operator|=
name|bufsync
block|,
operator|.
name|bop_bdflush
operator|=
name|bufbdflush
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Cloned from vop_stdlock(), and then the ugly hack added.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_lock1
parameter_list|(
name|struct
name|vop_lock1_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Since vfs_hash_get() calls vget() and it will no longer work 	 * for FreeBSD8 with flags == 0, I can only think of this horrible 	 * hack to work around it. I call vfs_hash_get() with LK_EXCLOTHER 	 * and then handle it here. All I want for this case is a v_usecount 	 * on the vnode to use for recovery, while another thread might 	 * hold a lock on the vnode. I have the other threads blocked, so 	 * there isn't any race problem. 	 */
if|if
condition|(
operator|(
name|ap
operator|->
name|a_flags
operator|&
name|LK_TYPE_MASK
operator|)
operator|==
name|LK_EXCLOTHER
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|a_flags
operator|&
name|LK_INTERLOCK
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ncllock1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
operator|)
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|_lockmgr_args
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|,
name|VI_MTX
argument_list|(
name|vp
argument_list|)
argument_list|,
name|LK_WMESG_DEFAULT
argument_list|,
name|LK_PRIO_DEFAULT
argument_list|,
name|LK_TIMO_DEFAULT
argument_list|,
name|ap
operator|->
name|a_file
argument_list|,
name|ap
operator|->
name|a_line
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfs_getacl
parameter_list|(
name|struct
name|vop_getacl_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_type
operator|!=
name|ACL_TYPE_NFS4
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|error
operator|=
name|nfsrpc_getacl
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|ap
operator|->
name|a_aclp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
name|NFSERR_STALE
condition|)
block|{
operator|(
name|void
operator|)
name|nfscl_maperr
argument_list|(
name|ap
operator|->
name|a_td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfs_setacl
parameter_list|(
name|struct
name|vop_setacl_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_type
operator|!=
name|ACL_TYPE_NFS4
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|error
operator|=
name|nfsrpc_setacl
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|ap
operator|->
name|a_aclp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
name|NFSERR_STALE
condition|)
block|{
operator|(
name|void
operator|)
name|nfscl_maperr
argument_list|(
name|ap
operator|->
name|a_td
argument_list|,
name|error
argument_list|,
operator|(
name|uid_t
operator|)
literal|0
argument_list|,
operator|(
name|gid_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return POSIX pathconf information applicable to nfs filesystems.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_pathconf
parameter_list|(
name|struct
name|vop_pathconf_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|nfsv3_pathconf
name|pc
decl_stmt|;
name|struct
name|nfsvattr
name|nfsva
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|int
name|attrflag
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
operator|||
operator|(
name|NFS_ISV3
argument_list|(
name|vp
argument_list|)
operator|&&
operator|(
name|ap
operator|->
name|a_name
operator|==
name|_PC_LINK_MAX
operator|||
name|ap
operator|->
name|a_name
operator|==
name|_PC_NAME_MAX
operator|||
name|ap
operator|->
name|a_name
operator|==
name|_PC_CHOWN_RESTRICTED
operator|||
name|ap
operator|->
name|a_name
operator|==
name|_PC_NO_TRUNC
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Since only the above 4 a_names are returned by the NFSv3 		 * Pathconf RPC, there is no point in doing it for others. 		 */
name|error
operator|=
name|nfsrpc_pathconf
argument_list|(
name|vp
argument_list|,
operator|&
name|pc
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|,
operator|&
name|nfsva
argument_list|,
operator|&
name|attrflag
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrflag
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|nfscl_loadattrcache
argument_list|(
operator|&
name|vp
argument_list|,
operator|&
name|nfsva
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * For NFSv2 (or NFSv3 when not one of the above 4 a_names), 		 * just fake them. 		 */
name|pc
operator|.
name|pc_linkmax
operator|=
name|LINK_MAX
expr_stmt|;
name|pc
operator|.
name|pc_namemax
operator|=
name|NFS_MAXNAMLEN
expr_stmt|;
name|pc
operator|.
name|pc_notrunc
operator|=
literal|1
expr_stmt|;
name|pc
operator|.
name|pc_chownrestricted
operator|=
literal|1
expr_stmt|;
name|pc
operator|.
name|pc_caseinsensitive
operator|=
literal|0
expr_stmt|;
name|pc
operator|.
name|pc_casepreserving
operator|=
literal|1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|ap
operator|->
name|a_name
condition|)
block|{
case|case
name|_PC_LINK_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|pc
operator|.
name|pc_linkmax
expr_stmt|;
break|break;
case|case
name|_PC_NAME_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|pc
operator|.
name|pc_namemax
expr_stmt|;
break|break;
case|case
name|_PC_PATH_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|PATH_MAX
expr_stmt|;
break|break;
case|case
name|_PC_PIPE_BUF
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|PIPE_BUF
expr_stmt|;
break|break;
case|case
name|_PC_CHOWN_RESTRICTED
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|pc
operator|.
name|pc_chownrestricted
expr_stmt|;
break|break;
case|case
name|_PC_NO_TRUNC
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|pc
operator|.
name|pc_notrunc
expr_stmt|;
break|break;
case|case
name|_PC_ACL_EXTENDED
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|_PC_ACL_NFS4
case|:
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
operator|&&
name|nfsrv_useacl
operator|!=
literal|0
operator|&&
name|attrflag
operator|!=
literal|0
operator|&&
name|NFSISSET_ATTRBIT
argument_list|(
operator|&
name|nfsva
operator|.
name|na_suppattr
argument_list|,
name|NFSATTRBIT_ACL
argument_list|)
condition|)
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|_PC_ACL_PATH_MAX
case|:
if|if
condition|(
name|NFS_ISV4
argument_list|(
name|vp
argument_list|)
condition|)
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|ACL_MAX_ENTRIES
expr_stmt|;
else|else
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|_PC_MAC_PRESENT
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|_PC_ASYNC_IO
case|:
comment|/* _PC_ASYNC_IO should have been handled by upper layers. */
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"_PC_ASYNC_IO should not get here"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|_PC_PRIO_IO
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|_PC_SYNC_IO
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|_PC_ALLOC_SIZE_MIN
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_bsize
expr_stmt|;
break|break;
case|case
name|_PC_FILESIZEBITS
case|:
if|if
condition|(
name|NFS_ISV34
argument_list|(
name|vp
argument_list|)
condition|)
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|64
expr_stmt|;
else|else
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|_PC_REC_INCR_XFER_SIZE
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
break|break;
case|case
name|_PC_REC_MAX_XFER_SIZE
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* means ``unlimited'' */
break|break;
case|case
name|_PC_REC_MIN_XFER_SIZE
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
break|break;
case|case
name|_PC_REC_XFER_ALIGN
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|PAGE_SIZE
expr_stmt|;
break|break;
case|case
name|_PC_SYMLINK_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|NFS_MAXPATHLEN
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

