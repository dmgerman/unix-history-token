begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software donated to Berkeley by  * the UCLA Ficus project.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)umap_vnops.c	8.6 (Berkeley) 5/22/95  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Umap Layer  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<fs/umapfs/umap.h>
end_include

begin_include
include|#
directive|include
file|<fs/nullfs/null.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|umap_bug_bypass
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for debugging: enables bypass printf'ing */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|umapfs_bug_bypass
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|umap_bug_bypass
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|umap_bypass
name|__P
argument_list|(
operator|(
expr|struct
name|vop_generic_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|umap_getattr
name|__P
argument_list|(
operator|(
expr|struct
name|vop_getattr_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|umap_inactive
name|__P
argument_list|(
operator|(
expr|struct
name|vop_inactive_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|umap_lock
name|__P
argument_list|(
operator|(
expr|struct
name|vop_lock_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|umap_print
name|__P
argument_list|(
operator|(
expr|struct
name|vop_print_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|umap_reclaim
name|__P
argument_list|(
operator|(
expr|struct
name|vop_reclaim_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|umap_rename
name|__P
argument_list|(
operator|(
expr|struct
name|vop_rename_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|umap_unlock
name|__P
argument_list|(
operator|(
expr|struct
name|vop_unlock_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the 10-Apr-92 bypass routine.  * See null_vnops.c:null_bypass for more details.  */
end_comment

begin_function
specifier|static
name|int
name|umap_bypass
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_generic_args
comment|/* { 		struct vnodeop_desc *a_desc;<other random data follows, presumably> 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|ucred
modifier|*
modifier|*
name|credpp
init|=
literal|0
decl_stmt|,
modifier|*
name|credp
init|=
literal|0
decl_stmt|;
name|struct
name|ucred
modifier|*
name|savecredp
init|=
literal|0
decl_stmt|,
modifier|*
name|savecompcredp
init|=
literal|0
decl_stmt|;
name|struct
name|ucred
modifier|*
name|compcredp
init|=
literal|0
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|this_vp_p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|old_vps
index|[
name|VDESC_MAX_VPS
index|]
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp1
init|=
literal|0
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vps_p
index|[
name|VDESC_MAX_VPS
index|]
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
modifier|*
name|vppp
decl_stmt|;
name|struct
name|vnodeop_desc
modifier|*
name|descp
init|=
name|ap
operator|->
name|a_desc
decl_stmt|;
name|int
name|reles
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|componentname
modifier|*
modifier|*
name|compnamepp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|umap_bug_bypass
condition|)
name|printf
argument_list|(
literal|"umap_bypass: %s\n"
argument_list|,
name|descp
operator|->
name|vdesc_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* 	 * We require at least one vp. 	 */
if|if
condition|(
name|descp
operator|->
name|vdesc_vp_offsets
operator|==
name|NULL
operator|||
name|descp
operator|->
name|vdesc_vp_offsets
index|[
literal|0
index|]
operator|==
name|VDESC_NO_OFFSET
condition|)
name|panic
argument_list|(
literal|"umap_bypass: no vp's in map"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Map the vnodes going in. 	 * Later, we'll invoke the operation based on 	 * the first mapped vnode's operation vector. 	 */
name|reles
operator|=
name|descp
operator|->
name|vdesc_flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VDESC_MAX_VPS
condition|;
name|reles
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|descp
operator|->
name|vdesc_vp_offsets
index|[
name|i
index|]
operator|==
name|VDESC_NO_OFFSET
condition|)
break|break;
comment|/* bail out at end of list */
name|vps_p
index|[
name|i
index|]
operator|=
name|this_vp_p
operator|=
name|VOPARG_OFFSETTO
argument_list|(
expr|struct
name|vnode
operator|*
operator|*
argument_list|,
name|descp
operator|->
name|vdesc_vp_offsets
index|[
name|i
index|]
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|vp1
operator|=
operator|*
name|vps_p
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* 		 * We're not guaranteed that any but the first vnode 		 * are of our type.  Check for and don't map any 		 * that aren't.  (Must map first vp or vclean fails.) 		 */
if|if
condition|(
name|i
operator|&&
operator|(
operator|*
name|this_vp_p
operator|)
operator|->
name|v_op
operator|!=
name|umap_vnodeop_p
condition|)
block|{
name|old_vps
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|old_vps
index|[
name|i
index|]
operator|=
operator|*
name|this_vp_p
expr_stmt|;
operator|*
operator|(
name|vps_p
index|[
name|i
index|]
operator|)
operator|=
name|UMAPVPTOLOWERVP
argument_list|(
operator|*
name|this_vp_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|reles
operator|&
literal|1
condition|)
name|VREF
argument_list|(
operator|*
name|this_vp_p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Fix the credentials.  (That's the purpose of this layer.) 	 */
if|if
condition|(
name|descp
operator|->
name|vdesc_cred_offset
operator|!=
name|VDESC_NO_OFFSET
condition|)
block|{
name|credpp
operator|=
name|VOPARG_OFFSETTO
argument_list|(
expr|struct
name|ucred
operator|*
operator|*
argument_list|,
name|descp
operator|->
name|vdesc_cred_offset
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/* Save old values */
name|savecredp
operator|=
operator|(
operator|*
name|credpp
operator|)
expr_stmt|;
if|if
condition|(
name|savecredp
operator|!=
name|NOCRED
condition|)
operator|(
operator|*
name|credpp
operator|)
operator|=
name|crdup
argument_list|(
name|savecredp
argument_list|)
expr_stmt|;
name|credp
operator|=
operator|*
name|credpp
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|credp
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_bypass: user was %lu, group %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|credp
operator|->
name|cr_uid
argument_list|,
operator|(
name|u_long
operator|)
name|credp
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
comment|/* Map all ids in the credential structure. */
name|umap_mapids
argument_list|(
name|vp1
operator|->
name|v_mount
argument_list|,
name|credp
argument_list|)
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|credp
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_bypass: user now %lu, group %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|credp
operator|->
name|cr_uid
argument_list|,
operator|(
name|u_long
operator|)
name|credp
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
block|}
comment|/* BSD often keeps a credential in the componentname structure 	 * for speed.  If there is one, it better get mapped, too. 	 */
if|if
condition|(
name|descp
operator|->
name|vdesc_componentname_offset
operator|!=
name|VDESC_NO_OFFSET
condition|)
block|{
name|compnamepp
operator|=
name|VOPARG_OFFSETTO
argument_list|(
expr|struct
name|componentname
operator|*
operator|*
argument_list|,
name|descp
operator|->
name|vdesc_componentname_offset
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|compcredp
operator|=
operator|(
operator|*
name|compnamepp
operator|)
operator|->
name|cn_cred
expr_stmt|;
name|savecompcredp
operator|=
name|compcredp
expr_stmt|;
if|if
condition|(
name|savecompcredp
operator|!=
name|NOCRED
condition|)
operator|(
operator|*
name|compnamepp
operator|)
operator|->
name|cn_cred
operator|=
name|crdup
argument_list|(
name|savecompcredp
argument_list|)
expr_stmt|;
name|compcredp
operator|=
operator|(
operator|*
name|compnamepp
operator|)
operator|->
name|cn_cred
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|compcredp
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_bypass: component credit user was %lu, group %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|compcredp
operator|->
name|cr_uid
argument_list|,
operator|(
name|u_long
operator|)
name|compcredp
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
comment|/* Map all ids in the credential structure. */
name|umap_mapids
argument_list|(
name|vp1
operator|->
name|v_mount
argument_list|,
name|compcredp
argument_list|)
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|compcredp
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_bypass: component credit user now %lu, group %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|compcredp
operator|->
name|cr_uid
argument_list|,
operator|(
name|u_long
operator|)
name|compcredp
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Call the operation on the lower layer 	 * with the modified argument structure. 	 */
name|error
operator|=
name|VCALL
argument_list|(
operator|*
operator|(
name|vps_p
index|[
literal|0
index|]
operator|)
argument_list|,
name|descp
operator|->
name|vdesc_offset
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/* 	 * Maintain the illusion of call-by-value 	 * by restoring vnodes in the argument structure 	 * to their original value. 	 */
name|reles
operator|=
name|descp
operator|->
name|vdesc_flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VDESC_MAX_VPS
condition|;
name|reles
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|descp
operator|->
name|vdesc_vp_offsets
index|[
name|i
index|]
operator|==
name|VDESC_NO_OFFSET
condition|)
break|break;
comment|/* bail out at end of list */
if|if
condition|(
name|old_vps
index|[
name|i
index|]
condition|)
block|{
operator|*
operator|(
name|vps_p
index|[
name|i
index|]
operator|)
operator|=
name|old_vps
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|reles
operator|&
literal|1
condition|)
name|vrele
argument_list|(
operator|*
operator|(
name|vps_p
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* 	 * Map the possible out-going vpp 	 * (Assumes that the lower layer always returns 	 * a VREF'ed vpp unless it gets an error.) 	 */
if|if
condition|(
name|descp
operator|->
name|vdesc_vpp_offset
operator|!=
name|VDESC_NO_OFFSET
operator|&&
operator|!
operator|(
name|descp
operator|->
name|vdesc_flags
operator|&
name|VDESC_NOMAP_VPP
operator|)
operator|&&
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|descp
operator|->
name|vdesc_flags
operator|&
name|VDESC_VPP_WILLRELE
condition|)
goto|goto
name|out
goto|;
name|vppp
operator|=
name|VOPARG_OFFSETTO
argument_list|(
expr|struct
name|vnode
operator|*
operator|*
operator|*
argument_list|,
name|descp
operator|->
name|vdesc_vpp_offset
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|vppp
condition|)
name|error
operator|=
name|umap_node_create
argument_list|(
name|old_vps
index|[
literal|0
index|]
operator|->
name|v_mount
argument_list|,
operator|*
operator|*
name|vppp
argument_list|,
operator|*
name|vppp
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|out
label|:
comment|/* 	 * Free duplicate cred structure and restore old one. 	 */
if|if
condition|(
name|descp
operator|->
name|vdesc_cred_offset
operator|!=
name|VDESC_NO_OFFSET
condition|)
block|{
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|credp
operator|&&
name|credp
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_bypass: returning-user was %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|credp
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|savecredp
operator|!=
name|NOCRED
condition|)
block|{
name|crfree
argument_list|(
name|credp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|credpp
operator|)
operator|=
name|savecredp
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|credpp
operator|&&
operator|(
operator|*
name|credpp
operator|)
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_bypass: returning-user now %lu\n\n"
argument_list|,
call|(
name|u_long
call|)
argument_list|(
operator|*
name|credpp
argument_list|)
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|descp
operator|->
name|vdesc_componentname_offset
operator|!=
name|VDESC_NO_OFFSET
condition|)
block|{
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|compcredp
operator|&&
name|compcredp
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_bypass: returning-component-user was %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|compcredp
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|savecompcredp
operator|!=
name|NOCRED
condition|)
block|{
name|crfree
argument_list|(
name|compcredp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|compnamepp
operator|)
operator|->
name|cn_cred
operator|=
name|savecompcredp
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|credpp
operator|&&
operator|(
operator|*
name|credpp
operator|)
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_bypass: returning-component-user now %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|compcredp
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  We handle getattr to change the fsid.  */
end_comment

begin_function
specifier|static
name|int
name|umap_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|short
name|uid
decl_stmt|,
name|gid
decl_stmt|;
name|int
name|error
decl_stmt|,
name|tmpid
decl_stmt|,
name|nentries
decl_stmt|,
name|gnentries
decl_stmt|;
name|u_long
argument_list|(
operator|*
name|mapdata
argument_list|)
index|[
literal|2
index|]
operator|,
operator|(
operator|*
name|gmapdata
operator|)
index|[
literal|2
index|]
expr_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vp1p
decl_stmt|;
name|struct
name|vnodeop_desc
modifier|*
name|descp
init|=
name|ap
operator|->
name|a_desc
decl_stmt|;
name|error
operator|=
name|umap_bypass
argument_list|(
operator|(
expr|struct
name|vop_generic_args
operator|*
operator|)
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Umap needs to map the uid and gid returned by a stat 	 * into the proper values for this site.  This involves 	 * finding the returned uid in the mapping information, 	 * translating it into the uid on the other end, 	 * and filling in the proper field in the vattr 	 * structure pointed to by ap->a_vap.  The group 	 * is easier, since currently all groups will be 	 * translate to the NULLGROUP. 	 */
comment|/* Find entry in map */
name|uid
operator|=
name|ap
operator|->
name|a_vap
operator|->
name|va_uid
expr_stmt|;
name|gid
operator|=
name|ap
operator|->
name|a_vap
operator|->
name|va_gid
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
condition|)
name|printf
argument_list|(
literal|"umap_getattr: mapped uid = %d, mapped gid = %d\n"
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
expr_stmt|;
name|vp1p
operator|=
name|VOPARG_OFFSETTO
argument_list|(
expr|struct
name|vnode
operator|*
operator|*
argument_list|,
name|descp
operator|->
name|vdesc_vp_offsets
index|[
literal|0
index|]
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|nentries
operator|=
name|MOUNTTOUMAPMOUNT
argument_list|(
operator|(
operator|*
name|vp1p
operator|)
operator|->
name|v_mount
argument_list|)
operator|->
name|info_nentries
expr_stmt|;
name|mapdata
operator|=
operator|(
name|MOUNTTOUMAPMOUNT
argument_list|(
operator|(
operator|*
name|vp1p
operator|)
operator|->
name|v_mount
argument_list|)
operator|->
name|info_mapdata
operator|)
expr_stmt|;
name|gnentries
operator|=
name|MOUNTTOUMAPMOUNT
argument_list|(
operator|(
operator|*
name|vp1p
operator|)
operator|->
name|v_mount
argument_list|)
operator|->
name|info_gnentries
expr_stmt|;
name|gmapdata
operator|=
operator|(
name|MOUNTTOUMAPMOUNT
argument_list|(
operator|(
operator|*
name|vp1p
operator|)
operator|->
name|v_mount
argument_list|)
operator|->
name|info_gmapdata
operator|)
expr_stmt|;
comment|/* Reverse map the uid for the vnode.  Since it's a reverse 		map, we can't use umap_mapids() to do it. */
name|tmpid
operator|=
name|umap_reverse_findid
argument_list|(
name|uid
argument_list|,
name|mapdata
argument_list|,
name|nentries
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpid
operator|!=
operator|-
literal|1
condition|)
block|{
name|ap
operator|->
name|a_vap
operator|->
name|va_uid
operator|=
operator|(
name|uid_t
operator|)
name|tmpid
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
condition|)
name|printf
argument_list|(
literal|"umap_getattr: original uid = %d\n"
argument_list|,
name|uid
argument_list|)
expr_stmt|;
block|}
else|else
name|ap
operator|->
name|a_vap
operator|->
name|va_uid
operator|=
operator|(
name|uid_t
operator|)
name|NOBODY
expr_stmt|;
comment|/* Reverse map the gid for the vnode. */
name|tmpid
operator|=
name|umap_reverse_findid
argument_list|(
name|gid
argument_list|,
name|gmapdata
argument_list|,
name|gnentries
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpid
operator|!=
operator|-
literal|1
condition|)
block|{
name|ap
operator|->
name|a_vap
operator|->
name|va_gid
operator|=
operator|(
name|gid_t
operator|)
name|tmpid
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
condition|)
name|printf
argument_list|(
literal|"umap_getattr: original gid = %d\n"
argument_list|,
name|gid
argument_list|)
expr_stmt|;
block|}
else|else
name|ap
operator|->
name|a_vap
operator|->
name|va_gid
operator|=
operator|(
name|gid_t
operator|)
name|NULLGROUP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need to process our own vnode lock and then clear the  * interlock flag as it applies only to our vnode, not the  * vnodes below us on the stack.  */
end_comment

begin_function
specifier|static
name|int
name|umap_lock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lock_args
comment|/* { 		struct vnode *a_vp; 		int a_flags; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vop_nolock
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ap
operator|->
name|a_flags
operator|&
name|LK_TYPE_MASK
operator|)
operator|==
name|LK_DRAIN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ap
operator|->
name|a_flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
return|return
operator|(
name|null_bypass
argument_list|(
operator|(
expr|struct
name|vop_generic_args
operator|*
operator|)
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need to process our own vnode unlock and then clear the  * interlock flag as it applies only to our vnode, not the  * vnodes below us on the stack.  */
end_comment

begin_function
name|int
name|umap_unlock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_unlock_args
comment|/* { 		struct vnode *a_vp; 		int a_flags; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vop_nounlock
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
return|return
operator|(
name|null_bypass
argument_list|(
operator|(
expr|struct
name|vop_generic_args
operator|*
operator|)
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|umap_inactive
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_inactive_args
comment|/* { 		struct vnode *a_vp; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|umap_node
modifier|*
name|xp
init|=
name|VTOUMAP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lowervp
init|=
name|xp
operator|->
name|umap_lowervp
decl_stmt|;
comment|/* 	 * Do nothing (and _don't_ bypass). 	 * Wait to vrele lowervp until reclaim, 	 * so that until then our umap_node is in the 	 * cache and reusable. 	 * 	 */
name|VOP_INACTIVE
argument_list|(
name|lowervp
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|umap_reclaim
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_reclaim_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|umap_node
modifier|*
name|xp
init|=
name|VTOUMAP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lowervp
init|=
name|xp
operator|->
name|umap_lowervp
decl_stmt|;
comment|/* After this assignment, this node will not be re-used. */
name|xp
operator|->
name|umap_lowervp
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|xp
argument_list|,
name|umap_hash
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|vp
operator|->
name|v_data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
name|vrele
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|umap_print
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_print_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|printf
argument_list|(
literal|"\ttag VT_UMAPFS, vp=%p, lowervp=%p\n"
argument_list|,
name|vp
argument_list|,
name|UMAPVPTOLOWERVP
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|umap_rename
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rename_args
comment|/* { 		struct vnode *a_fdvp; 		struct vnode *a_fvp; 		struct componentname *a_fcnp; 		struct vnode *a_tdvp; 		struct vnode *a_tvp; 		struct componentname *a_tcnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|componentname
modifier|*
name|compnamep
decl_stmt|;
name|struct
name|ucred
modifier|*
name|compcredp
decl_stmt|,
modifier|*
name|savecompcredp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
comment|/* 	 * Rename is irregular, having two componentname structures. 	 * We need to map the cre in the second structure, 	 * and then bypass takes care of the rest. 	 */
name|vp
operator|=
name|ap
operator|->
name|a_fdvp
expr_stmt|;
name|compnamep
operator|=
name|ap
operator|->
name|a_tcnp
expr_stmt|;
name|compcredp
operator|=
name|compnamep
operator|->
name|cn_cred
expr_stmt|;
name|savecompcredp
operator|=
name|compcredp
expr_stmt|;
name|compcredp
operator|=
name|compnamep
operator|->
name|cn_cred
operator|=
name|crdup
argument_list|(
name|savecompcredp
argument_list|)
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|compcredp
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_rename: rename component credit user was %lu, group %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|compcredp
operator|->
name|cr_uid
argument_list|,
operator|(
name|u_long
operator|)
name|compcredp
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
comment|/* Map all ids in the credential structure. */
name|umap_mapids
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|,
name|compcredp
argument_list|)
expr_stmt|;
if|if
condition|(
name|umap_bug_bypass
operator|&&
name|compcredp
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"umap_rename: rename component credit user now %lu, group %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|compcredp
operator|->
name|cr_uid
argument_list|,
operator|(
name|u_long
operator|)
name|compcredp
operator|->
name|cr_gid
argument_list|)
expr_stmt|;
name|error
operator|=
name|umap_bypass
argument_list|(
operator|(
expr|struct
name|vop_generic_args
operator|*
operator|)
name|ap
argument_list|)
expr_stmt|;
comment|/* Restore the additional mapped componentname cred structure. */
name|crfree
argument_list|(
name|compcredp
argument_list|)
expr_stmt|;
name|compnamep
operator|->
name|cn_cred
operator|=
name|savecompcredp
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Global vfs data structures  */
end_comment

begin_comment
comment|/*  * XXX - strategy, bwrite are hand coded currently.  They should  * go away with a merged buffer/block cache.  *  */
end_comment

begin_decl_stmt
name|vop_t
modifier|*
modifier|*
name|umap_vnodeop_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_entry_desc
name|umap_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|umap_bypass
block|}
block|,
block|{
operator|&
name|vop_getattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|umap_getattr
block|}
block|,
block|{
operator|&
name|vop_inactive_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|umap_inactive
block|}
block|,
block|{
operator|&
name|vop_lock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|umap_lock
block|}
block|,
block|{
operator|&
name|vop_print_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|umap_print
block|}
block|,
block|{
operator|&
name|vop_reclaim_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|umap_reclaim
block|}
block|,
block|{
operator|&
name|vop_rename_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|umap_rename
block|}
block|,
block|{
operator|&
name|vop_unlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|umap_unlock
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|umap_vnodeop_opv_desc
init|=
block|{
operator|&
name|umap_vnodeop_p
block|,
name|umap_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|umap_vnodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

