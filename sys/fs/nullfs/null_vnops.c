begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * John Heidemann of the UCLA Ficus project.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)null_vnops.c	8.6 (Berkeley) 5/27/95  *  * Ancestors:  *	@(#)lofs_vnops.c	1.2 (Berkeley) 6/18/92  *	...and...  *	@(#)null_vnodeops.c 1.20 92/07/07 UCLA Ficus project  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Null Layer  *  * (See mount_nullfs(8) for more information.)  *  * The null layer duplicates a portion of the filesystem  * name space under a new name.  In this respect, it is  * similar to the loopback filesystem.  It differs from  * the loopback fs in two respects:  it is implemented using  * a stackable layers techniques, and its "null-node"s stack above  * all lower-layer vnodes, not just over directory vnodes.  *  * The null layer has two purposes.  First, it serves as a demonstration  * of layering by proving a layer which does nothing.  (It actually  * does everything the loopback filesystem does, which is slightly  * more than nothing.)  Second, the null layer can serve as a prototype  * layer.  Since it provides all necessary layer framework,  * new filesystem layers can be created very easily be starting  * with a null layer.  *  * The remainder of this man page examines the null layer as a basis  * for constructing new layers.  *  *  * INSTANTIATING NEW NULL LAYERS  *  * New null layers are created with mount_nullfs(8).  * Mount_nullfs(8) takes two arguments, the pathname  * of the lower vfs (target-pn) and the pathname where the null  * layer will appear in the namespace (alias-pn).  After  * the null layer is put into place, the contents  * of target-pn subtree will be aliased under alias-pn.  *  *  * OPERATION OF A NULL LAYER  *  * The null layer is the minimum filesystem layer,  * simply bypassing all possible operations to the lower layer  * for processing there.  The majority of its activity centers  * on the bypass routine, through which nearly all vnode operations  * pass.  *  * The bypass routine accepts arbitrary vnode operations for  * handling by the lower layer.  It begins by examing vnode  * operation arguments and replacing any null-nodes by their  * lower-layer equivlants.  It then invokes the operation  * on the lower layer.  Finally, it replaces the null-nodes  * in the arguments and, if a vnode is return by the operation,  * stacks a null-node on top of the returned vnode.  *  * Although bypass handles most operations, vop_getattr, vop_lock,  * vop_unlock, vop_inactive, vop_reclaim, and vop_print are not  * bypassed. Vop_getattr must change the fsid being returned.  * Vop_lock and vop_unlock must handle any locking for the  * current vnode as well as pass the lock request down.  * Vop_inactive and vop_reclaim are not bypassed so that  * they can handle freeing null-layer specific data. Vop_print  * is not bypassed to avoid excessive debugging information.  * Also, certain vnode operations change the locking state within  * the operation (create, mknod, remove, link, rename, mkdir, rmdir,  * and symlink). Ideally these operations should not change the  * lock state, but should be changed to let the caller of the  * function unlock them. Otherwise all intermediate vnode layers  * (such as union, umapfs, etc) must catch these functions to do  * the necessary locking at their layer.  *  *  * INSTANTIATING VNODE STACKS  *  * Mounting associates the null layer with a lower layer,  * effect stacking two VFSes.  Vnode stacks are instead  * created on demand as files are accessed.  *  * The initial mount creates a single vnode stack for the  * root of the new null layer.  All other vnode stacks  * are created as a result of vnode operations on  * this or other null vnode stacks.  *  * New vnode stacks come into existance as a result of  * an operation which returns a vnode.  * The bypass routine stacks a null-node above the new  * vnode before returning it to the caller.  *  * For example, imagine mounting a null layer with  * "mount_nullfs /usr/include /dev/layer/null".  * Changing directory to /dev/layer/null will assign  * the root null-node (which was created when the null layer was mounted).  * Now consider opening "sys".  A vop_lookup would be  * done on the root null-node.  This operation would bypass through  * to the lower layer which would return a vnode representing  * the UFS "sys".  Null_bypass then builds a null-node  * aliasing the UFS "sys" and returns this to the caller.  * Later operations on the null-node "sys" will repeat this  * process when constructing other vnode stacks.  *  *  * CREATING OTHER FILE SYSTEM LAYERS  *  * One of the easiest ways to construct new filesystem layers is to make  * a copy of the null layer, rename all files and variables, and  * then begin modifing the copy.  Sed can be used to easily rename  * all variables.  *  * The umap layer is an example of a layer descended from the  * null layer.  *  *  * INVOKING OPERATIONS ON LOWER LAYERS  *  * There are two techniques to invoke operations on a lower layer  * when the operation cannot be completely bypassed.  Each method  * is appropriate in different situations.  In both cases,  * it is the responsibility of the aliasing layer to make  * the operation arguments "correct" for the lower layer  * by mapping a vnode arguments to the lower layer.  *  * The first approach is to call the aliasing layer's bypass routine.  * This method is most suitable when you wish to invoke the operation  * currently being handled on the lower layer.  It has the advantage  * that the bypass routine already must do argument mapping.  * An example of this is null_getattrs in the null layer.  *  * A second approach is to directly invoke vnode operations on  * the lower layer with the VOP_OPERATIONNAME interface.  * The advantage of this method is that it is easy to invoke  * arbitrary operations on the lower layer.  The disadvantage  * is that vnode arguments must be manualy mapped.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<fs/nullfs/null.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vnode_pager.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|null_bug_bypass
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for debugging: enables bypass printf'ing */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|nullfs_bug_bypass
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|null_bug_bypass
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This is the 10-Apr-92 bypass routine.  *    This version has been optimized for speed, throwing away some  * safety checks.  It should still always work, but it's not as  * robust to programmer errors.  *  * In general, we map all vnodes going down and unmap them on the way back.  * As an exception to this, vnodes can be marked "unmapped" by setting  * the Nth bit in operation's vdesc_flags.  *  * Also, some BSD vnode operations have the side effect of vrele'ing  * their arguments.  With stacking, the reference counts are held  * by the upper node, not the lower one, so we must handle these  * side-effects here.  This is not of concern in Sun-derived systems  * since there are no such side-effects.  *  * This makes the following assumptions:  * - only one returned vpp  * - no INOUT vpp's (Sun's vop_open has one of these)  * - the vnode operation vector of the first vnode should be used  *   to determine what implementation of the op should be invoked  * - all mapped vnodes are of our vnode-type (NEEDSWORK:  *   problems on rmdir'ing mount points and renaming?)  */
end_comment

begin_function
name|int
name|null_bypass
parameter_list|(
name|struct
name|vop_generic_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
modifier|*
name|this_vp_p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|old_vps
index|[
name|VDESC_MAX_VPS
index|]
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vps_p
index|[
name|VDESC_MAX_VPS
index|]
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
modifier|*
name|vppp
decl_stmt|;
name|struct
name|vnodeop_desc
modifier|*
name|descp
init|=
name|ap
operator|->
name|a_desc
decl_stmt|;
name|int
name|reles
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|null_bug_bypass
condition|)
name|printf
argument_list|(
literal|"null_bypass: %s\n"
argument_list|,
name|descp
operator|->
name|vdesc_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* 	 * We require at least one vp. 	 */
if|if
condition|(
name|descp
operator|->
name|vdesc_vp_offsets
operator|==
name|NULL
operator|||
name|descp
operator|->
name|vdesc_vp_offsets
index|[
literal|0
index|]
operator|==
name|VDESC_NO_OFFSET
condition|)
name|panic
argument_list|(
literal|"null_bypass: no vp's in map"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Map the vnodes going in. 	 * Later, we'll invoke the operation based on 	 * the first mapped vnode's operation vector. 	 */
name|reles
operator|=
name|descp
operator|->
name|vdesc_flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VDESC_MAX_VPS
condition|;
name|reles
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|descp
operator|->
name|vdesc_vp_offsets
index|[
name|i
index|]
operator|==
name|VDESC_NO_OFFSET
condition|)
break|break;
comment|/* bail out at end of list */
name|vps_p
index|[
name|i
index|]
operator|=
name|this_vp_p
operator|=
name|VOPARG_OFFSETTO
argument_list|(
expr|struct
name|vnode
operator|*
operator|*
argument_list|,
name|descp
operator|->
name|vdesc_vp_offsets
index|[
name|i
index|]
argument_list|,
name|ap
argument_list|)
expr_stmt|;
comment|/* 		 * We're not guaranteed that any but the first vnode 		 * are of our type.  Check for and don't map any 		 * that aren't.  (We must always map first vp or vclean fails.) 		 */
if|if
condition|(
name|i
operator|&&
operator|(
operator|*
name|this_vp_p
operator|==
name|NULLVP
operator|||
operator|(
operator|*
name|this_vp_p
operator|)
operator|->
name|v_op
operator|!=
operator|&
name|null_vnodeops
operator|)
condition|)
block|{
name|old_vps
index|[
name|i
index|]
operator|=
name|NULLVP
expr_stmt|;
block|}
else|else
block|{
name|old_vps
index|[
name|i
index|]
operator|=
operator|*
name|this_vp_p
expr_stmt|;
operator|*
operator|(
name|vps_p
index|[
name|i
index|]
operator|)
operator|=
name|NULLVPTOLOWERVP
argument_list|(
operator|*
name|this_vp_p
argument_list|)
expr_stmt|;
comment|/* 			 * XXX - Several operations have the side effect 			 * of vrele'ing their vp's.  We must account for 			 * that.  (This should go away in the future.) 			 */
if|if
condition|(
name|reles
operator|&
name|VDESC_VP0_WILLRELE
condition|)
name|VREF
argument_list|(
operator|*
name|this_vp_p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Call the operation on the lower layer 	 * with the modified argument structure. 	 */
if|if
condition|(
name|vps_p
index|[
literal|0
index|]
operator|&&
operator|*
name|vps_p
index|[
literal|0
index|]
condition|)
name|error
operator|=
name|VCALL
argument_list|(
name|ap
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"null_bypass: no map for %s\n"
argument_list|,
name|descp
operator|->
name|vdesc_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* 	 * Maintain the illusion of call-by-value 	 * by restoring vnodes in the argument structure 	 * to their original value. 	 */
name|reles
operator|=
name|descp
operator|->
name|vdesc_flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VDESC_MAX_VPS
condition|;
name|reles
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|descp
operator|->
name|vdesc_vp_offsets
index|[
name|i
index|]
operator|==
name|VDESC_NO_OFFSET
condition|)
break|break;
comment|/* bail out at end of list */
if|if
condition|(
name|old_vps
index|[
name|i
index|]
condition|)
block|{
operator|*
operator|(
name|vps_p
index|[
name|i
index|]
operator|)
operator|=
name|old_vps
index|[
name|i
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|if (reles& VDESC_VP0_WILLUNLOCK) 				VOP_UNLOCK(*(vps_p[i]), 0, curthread);
endif|#
directive|endif
if|if
condition|(
name|reles
operator|&
name|VDESC_VP0_WILLRELE
condition|)
name|vrele
argument_list|(
operator|*
operator|(
name|vps_p
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Map the possible out-going vpp 	 * (Assumes that the lower layer always returns 	 * a VREF'ed vpp unless it gets an error.) 	 */
if|if
condition|(
name|descp
operator|->
name|vdesc_vpp_offset
operator|!=
name|VDESC_NO_OFFSET
operator|&&
operator|!
operator|(
name|descp
operator|->
name|vdesc_flags
operator|&
name|VDESC_NOMAP_VPP
operator|)
operator|&&
operator|!
name|error
condition|)
block|{
comment|/* 		 * XXX - even though some ops have vpp returned vp's, 		 * several ops actually vrele this before returning. 		 * We must avoid these ops. 		 * (This should go away when these ops are regularized.) 		 */
if|if
condition|(
name|descp
operator|->
name|vdesc_flags
operator|&
name|VDESC_VPP_WILLRELE
condition|)
goto|goto
name|out
goto|;
name|vppp
operator|=
name|VOPARG_OFFSETTO
argument_list|(
expr|struct
name|vnode
operator|*
operator|*
operator|*
argument_list|,
name|descp
operator|->
name|vdesc_vpp_offset
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|vppp
condition|)
name|error
operator|=
name|null_nodeget
argument_list|(
name|old_vps
index|[
literal|0
index|]
operator|->
name|v_mount
argument_list|,
operator|*
operator|*
name|vppp
argument_list|,
operator|*
name|vppp
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We have to carry on the locking protocol on the null layer vnodes  * as we progress through the tree. We also have to enforce read-only  * if this layer is mounted read-only.  */
end_comment

begin_function
specifier|static
name|int
name|null_lookup
parameter_list|(
name|struct
name|vop_lookup_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
name|int
name|flags
init|=
name|cnp
operator|->
name|cn_flags
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|ldvp
decl_stmt|,
modifier|*
name|lvp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|dvp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|DELETE
operator|||
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
comment|/* 	 * Although it is possible to call null_bypass(), we'll do 	 * a direct call to reduce overhead 	 */
name|ldvp
operator|=
name|NULLVPTOLOWERVP
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|lvp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|VOP_LOOKUP
argument_list|(
name|ldvp
argument_list|,
operator|&
name|lvp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EJUSTRETURN
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|dvp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|&&
operator|(
name|cnp
operator|->
name|cn_nameiop
operator|==
name|CREATE
operator|||
name|cnp
operator|->
name|cn_nameiop
operator|==
name|RENAME
operator|)
condition|)
name|error
operator|=
name|EROFS
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|EJUSTRETURN
operator|)
operator|&&
name|lvp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ldvp
operator|==
name|lvp
condition|)
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|dvp
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|null_nodeget
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|lvp
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* XXX Cleanup needed... */
name|panic
argument_list|(
literal|"null_nodeget failed"
argument_list|)
expr_stmt|;
block|}
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|vp
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|null_open
parameter_list|(
name|struct
name|vop_open_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|ldvp
decl_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|ldvp
operator|=
name|NULLVPTOLOWERVP
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|retval
operator|=
name|null_bypass
argument_list|(
operator|&
name|ap
operator|->
name|a_gen
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
name|vp
operator|->
name|v_object
operator|=
name|ldvp
operator|->
name|v_object
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setattr call. Disallow write attempts if the layer is mounted read-only.  */
end_comment

begin_function
specifier|static
name|int
name|null_setattr
parameter_list|(
name|struct
name|vop_setattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VDIR
case|:
return|return
operator|(
name|EISDIR
operator|)
return|;
case|case
name|VCHR
case|:
case|case
name|VBLK
case|:
case|case
name|VSOCK
case|:
case|case
name|VFIFO
case|:
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|VREG
case|:
case|case
name|VLNK
case|:
default|default:
comment|/* 			 * Disallow write attempts if the filesystem is 			 * mounted read-only. 			 */
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
block|}
return|return
operator|(
name|null_bypass
argument_list|(
operator|(
expr|struct
name|vop_generic_args
operator|*
operator|)
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  We handle getattr only to change the fsid.  */
end_comment

begin_function
specifier|static
name|int
name|null_getattr
parameter_list|(
name|struct
name|vop_getattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|null_bypass
argument_list|(
operator|(
expr|struct
name|vop_generic_args
operator|*
operator|)
name|ap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ap
operator|->
name|a_vap
operator|->
name|va_fsid
operator|=
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle to disallow write access if mounted read-only.  */
end_comment

begin_function
specifier|static
name|int
name|null_access
parameter_list|(
name|struct
name|vop_access_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|mode_t
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
comment|/* 	 * Disallow write attempts on read-only layers; 	 * unless the file is a socket, fifo, or a block or 	 * character device resident on the filesystem. 	 */
if|if
condition|(
name|mode
operator|&
name|VWRITE
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
case|case
name|VREG
case|:
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
operator|(
name|null_bypass
argument_list|(
operator|(
expr|struct
name|vop_generic_args
operator|*
operator|)
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We handle this to eliminate null FS to lower FS  * file moving. Don't know why we don't allow this,  * possibly we should.  */
end_comment

begin_function
specifier|static
name|int
name|null_rename
parameter_list|(
name|struct
name|vop_rename_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
comment|/* Check for cross-device rename. */
if|if
condition|(
operator|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tdvp
operator|->
name|v_mount
operator|)
operator|||
operator|(
name|tvp
operator|&&
operator|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tvp
operator|->
name|v_mount
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|tdvp
operator|==
name|tvp
condition|)
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXDEV
operator|)
return|;
block|}
return|return
operator|(
name|null_bypass
argument_list|(
operator|(
expr|struct
name|vop_generic_args
operator|*
operator|)
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need to process our own vnode lock and then clear the  * interlock flag as it applies only to our vnode, not the  * vnodes below us on the stack.  */
end_comment

begin_function
specifier|static
name|int
name|null_lock
parameter_list|(
name|struct
name|_vop_lock_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|flags
init|=
name|ap
operator|->
name|a_flags
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|null_node
modifier|*
name|nn
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_INTERLOCK
operator|)
operator|==
literal|0
condition|)
block|{
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_flags
operator|=
name|flags
operator||=
name|LK_INTERLOCK
expr_stmt|;
block|}
name|nn
operator|=
name|VTONULL
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * If we're still active we must ask the lower layer to 	 * lock as ffs has special lock considerations in it's 	 * vop lock. 	 */
if|if
condition|(
name|nn
operator|!=
name|NULL
operator|&&
operator|(
name|lvp
operator|=
name|NULLVPTOLOWERVP
argument_list|(
name|vp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|VI_LOCK_FLAGS
argument_list|(
name|lvp
argument_list|,
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 		 * We have to hold the vnode here to solve a potential 		 * reclaim race.  If we're forcibly vgone'd while we 		 * still have refs, a thread could be sleeping inside 		 * the lowervp's vop_lock routine.  When we vgone we will 		 * drop our last ref to the lowervp, which would allow it 		 * to be reclaimed.  The lowervp could then be recycled, 		 * in which case it is not legal to be sleeping in it's VOP. 		 * We prevent it from being recycled by holding the vnode 		 * here. 		 */
name|vholdl
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_LOCK
argument_list|(
name|lvp
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 		 * We might have slept to get the lock and someone might have 		 * clean our vnode already, switching vnode lock from one in 		 * lowervp to v_lock in our own vnode structure.  Handle this 		 * case by reacquiring correct lock in requested mode. 		 */
if|if
condition|(
name|VTONULL
argument_list|(
name|vp
argument_list|)
operator|==
name|NULL
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|ap
operator|->
name|a_flags
operator|&=
operator|~
operator|(
name|LK_TYPE_MASK
operator||
name|LK_INTERLOCK
operator|)
expr_stmt|;
switch|switch
condition|(
name|flags
operator|&
name|LK_TYPE_MASK
condition|)
block|{
case|case
name|LK_SHARED
case|:
name|ap
operator|->
name|a_flags
operator||=
name|LK_SHARED
expr_stmt|;
break|break;
case|case
name|LK_UPGRADE
case|:
case|case
name|LK_EXCLUSIVE
case|:
name|ap
operator|->
name|a_flags
operator||=
name|LK_EXCLUSIVE
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unsupported lock request %d\n"
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|vop_stdlock
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
name|vdrop
argument_list|(
name|lvp
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|vop_stdlock
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need to process our own vnode unlock and then clear the  * interlock flag as it applies only to our vnode, not the  * vnodes below us on the stack.  */
end_comment

begin_function
specifier|static
name|int
name|null_unlock
parameter_list|(
name|struct
name|vop_unlock_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|flags
init|=
name|ap
operator|->
name|a_flags
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|null_node
modifier|*
name|nn
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_INTERLOCK
operator|)
operator|!=
literal|0
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_flags
operator|=
name|flags
operator|&=
operator|~
name|LK_INTERLOCK
expr_stmt|;
block|}
name|nn
operator|=
name|VTONULL
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nn
operator|!=
name|NULL
operator|&&
operator|(
name|lvp
operator|=
name|NULLVPTOLOWERVP
argument_list|(
name|vp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|error
operator|=
name|VOP_UNLOCK
argument_list|(
name|lvp
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|vop_stdunlock
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|null_islocked
parameter_list|(
name|struct
name|vop_islocked_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
return|return
operator|(
name|lockstatus
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * There is no way to tell that someone issued remove/rmdir operation  * on the underlying filesystem. For now we just have to release lowevrp  * as soon as possible.  *  * Note, we can't release any resources nor remove vnode from hash before   * appropriate VXLOCK stuff is is done because other process can find this  * vnode in hash during inactivation and may be sitting in vget() and waiting  * for null_inactive to unlock vnode. Thus we will do all those in VOP_RECLAIM.  */
end_comment

begin_function
specifier|static
name|int
name|null_inactive
parameter_list|(
name|struct
name|vop_inactive_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|vp
operator|->
name|v_object
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If this is the last reference, then free up the vnode 	 * so as not to tie up the lower vnodes. 	 */
name|vrecycle
argument_list|(
name|vp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Now, the VXLOCK is in force and we're free to destroy the null vnode.  */
end_comment

begin_function
specifier|static
name|int
name|null_reclaim
parameter_list|(
name|struct
name|vop_reclaim_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|null_node
modifier|*
name|xp
init|=
name|VTONULL
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lowervp
init|=
name|xp
operator|->
name|null_lowervp
decl_stmt|;
name|struct
name|lock
modifier|*
name|vnlock
decl_stmt|;
if|if
condition|(
name|lowervp
condition|)
name|null_hashrem
argument_list|(
name|xp
argument_list|)
expr_stmt|;
comment|/* 	 * Use the interlock to protect the clearing of v_data to 	 * prevent faults in null_lock(). 	 */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
name|vp
operator|->
name|v_object
operator|=
name|NULL
expr_stmt|;
name|vnlock
operator|=
name|vp
operator|->
name|v_vnlock
expr_stmt|;
name|vp
operator|->
name|v_vnlock
operator|=
operator|&
name|vp
operator|->
name|v_lock
expr_stmt|;
if|if
condition|(
name|lowervp
condition|)
block|{
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_INTERLOCK
argument_list|,
name|VI_MTX
argument_list|(
name|vp
argument_list|)
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"null_reclaim: reclaiming an node with now lowervp"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|xp
argument_list|,
name|M_NULLFSNODE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|null_print
parameter_list|(
name|struct
name|vop_print_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|printf
argument_list|(
literal|"\tvp=%p, lowervp=%p\n"
argument_list|,
name|vp
argument_list|,
name|NULLVPTOLOWERVP
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|null_getwritemount
parameter_list|(
name|struct
name|vop_getwritemount_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|null_node
modifier|*
name|xp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|lowervp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|xp
operator|=
name|VTONULL
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xp
operator|&&
operator|(
name|lowervp
operator|=
name|xp
operator|->
name|null_lowervp
operator|)
condition|)
block|{
name|VI_LOCK_FLAGS
argument_list|(
name|lowervp
argument_list|,
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vholdl
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
name|VOP_GETWRITEMOUNT
argument_list|(
name|lowervp
argument_list|,
name|ap
operator|->
name|a_mpp
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|lowervp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ap
operator|->
name|a_mpp
operator|)
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|null_vptofh
parameter_list|(
name|struct
name|vop_vptofh_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|lvp
decl_stmt|;
name|lvp
operator|=
name|NULLVPTOLOWERVP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
return|return
name|VOP_VPTOFH
argument_list|(
name|lvp
argument_list|,
name|ap
operator|->
name|a_fhp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Global vfs data structures  */
end_comment

begin_decl_stmt
name|struct
name|vop_vector
name|null_vnodeops
init|=
block|{
operator|.
name|vop_bypass
operator|=
name|null_bypass
block|,
operator|.
name|vop_access
operator|=
name|null_access
block|,
operator|.
name|vop_bmap
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_getattr
operator|=
name|null_getattr
block|,
operator|.
name|vop_getwritemount
operator|=
name|null_getwritemount
block|,
operator|.
name|vop_inactive
operator|=
name|null_inactive
block|,
operator|.
name|vop_islocked
operator|=
name|null_islocked
block|,
operator|.
name|_vop_lock
operator|=
name|null_lock
block|,
operator|.
name|vop_lookup
operator|=
name|null_lookup
block|,
operator|.
name|vop_open
operator|=
name|null_open
block|,
operator|.
name|vop_print
operator|=
name|null_print
block|,
operator|.
name|vop_reclaim
operator|=
name|null_reclaim
block|,
operator|.
name|vop_rename
operator|=
name|null_rename
block|,
operator|.
name|vop_setattr
operator|=
name|null_setattr
block|,
operator|.
name|vop_strategy
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_unlock
operator|=
name|null_unlock
block|,
operator|.
name|vop_vptofh
operator|=
name|null_vptofh
block|, }
decl_stmt|;
end_decl_stmt

end_unit

