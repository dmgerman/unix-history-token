begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998, 1999 Semen Ustimenko (semenu@FreeBSD.org)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<fs/hpfs/hpfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/hpfs/hpfs_subr.h>
end_include

begin_define
define|#
directive|define
name|AE_DONE
value|0
end_define

begin_comment
comment|/* Nothing to change */
end_comment

begin_define
define|#
directive|define
name|AE_SPLIT
value|2
end_define

begin_comment
comment|/* Split was done, ranp is valid */
end_comment

begin_function_decl
name|int
name|hpfs_addextentr
parameter_list|(
name|struct
name|hpfsmount
modifier|*
parameter_list|,
name|lsn_t
parameter_list|,
name|alleaf_t
modifier|*
parameter_list|,
name|alnode_t
modifier|*
parameter_list|,
name|u_long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|hpfs_allocalsec
parameter_list|(
name|struct
name|hpfsmount
modifier|*
parameter_list|,
name|lsn_t
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|hpfs_alblk2alsec
parameter_list|(
name|struct
name|hpfsmount
modifier|*
parameter_list|,
name|alblk_t
modifier|*
parameter_list|,
name|alsec_t
modifier|*
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|hpfs_splitalsec
parameter_list|(
name|struct
name|hpfsmount
modifier|*
parameter_list|,
name|alsec_t
modifier|*
parameter_list|,
name|alsec_t
modifier|*
modifier|*
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|hpfs_concatalsec
parameter_list|(
name|struct
name|hpfsmount
modifier|*
parameter_list|,
name|alsec_t
modifier|*
parameter_list|,
name|alsec_t
modifier|*
parameter_list|,
name|alnode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Map file offset to disk offset. hpfsnode have to be locked.  */
end_comment

begin_function
name|int
name|hpfs_hpbmap
parameter_list|(
name|hp
parameter_list|,
name|bn
parameter_list|,
name|bnp
parameter_list|,
name|runp
parameter_list|)
name|struct
name|hpfsnode
modifier|*
name|hp
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|daddr_t
modifier|*
name|bnp
decl_stmt|;
name|int
modifier|*
name|runp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|alblk_t
modifier|*
name|abp
decl_stmt|;
name|alleaf_t
modifier|*
name|alp
decl_stmt|;
name|alnode_t
modifier|*
name|anp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_hpbmap(0x%x, 0x%x): "
operator|,
name|hp
operator|->
name|h_no
operator|,
name|bn
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|abp
operator|=
operator|&
name|hp
operator|->
name|h_fn
operator|.
name|fn_ab
expr_stmt|;
name|alp
operator|=
operator|(
name|alleaf_t
operator|*
operator|)
operator|&
name|hp
operator|->
name|h_fn
operator|.
name|fn_abd
expr_stmt|;
name|anp
operator|=
operator|(
name|alnode_t
operator|*
operator|)
operator|&
name|hp
operator|->
name|h_fn
operator|.
name|fn_abd
expr_stmt|;
name|dive
label|:
if|if
condition|(
name|abp
operator|->
name|ab_flag
operator|&
name|AB_NODES
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abp
operator|->
name|ab_busycnt
condition|;
name|i
operator|++
operator|,
name|anp
operator|++
control|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"[0x%x,0x%x] "
operator|,
name|anp
operator|->
name|an_nextoff
operator|,
name|anp
operator|->
name|an_lsn
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bn
operator|<
name|anp
operator|->
name|an_nextoff
condition|)
block|{
name|alsec_t
modifier|*
name|asp
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"< found | "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|hp
operator|->
name|h_devvp
argument_list|,
name|anp
operator|->
name|an_lsn
argument_list|,
name|DEV_BSIZE
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_hpbmap: bread error\n"
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|asp
operator|=
operator|(
name|alsec_t
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
name|asp
operator|->
name|as_magic
operator|!=
name|AS_MAGIC
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"hpfs_hpbmap: "
literal|"MAGIC DOESN'T MATCH"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|abp
operator|=
operator|&
name|asp
operator|->
name|as_ab
expr_stmt|;
name|alp
operator|=
operator|(
name|alleaf_t
operator|*
operator|)
operator|&
name|asp
operator|->
name|as_abd
expr_stmt|;
name|anp
operator|=
operator|(
name|alnode_t
operator|*
operator|)
operator|&
name|asp
operator|->
name|as_abd
expr_stmt|;
goto|goto
name|dive
goto|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abp
operator|->
name|ab_busycnt
condition|;
name|i
operator|++
operator|,
name|alp
operator|++
control|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"[0x%x,0x%x,0x%x] "
operator|,
name|alp
operator|->
name|al_off
operator|,
name|alp
operator|->
name|al_len
operator|,
name|alp
operator|->
name|al_lsn
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bn
operator|>=
name|alp
operator|->
name|al_off
operator|)
operator|&&
operator|(
operator|!
name|alp
operator|->
name|al_len
operator|||
operator|(
name|bn
operator|<
name|alp
operator|->
name|al_off
operator|+
name|alp
operator|->
name|al_len
operator|)
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"found, "
operator|)
argument_list|)
expr_stmt|;
operator|*
name|bnp
operator|=
name|bn
operator|-
name|alp
operator|->
name|al_off
operator|+
name|alp
operator|->
name|al_lsn
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|" 0x%x "
operator|,
operator|*
name|bnp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|runp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|alp
operator|->
name|al_len
condition|)
operator|*
name|runp
operator|=
name|alp
operator|->
name|al_off
operator|-
literal|1
operator|+
name|alp
operator|->
name|al_len
operator|-
name|bn
expr_stmt|;
else|else
operator|*
name|runp
operator|=
literal|3
expr_stmt|;
comment|/* XXX */
name|dprintf
argument_list|(
operator|(
literal|" 0x%x cont"
operator|,
operator|*
name|runp
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|dprintf
argument_list|(
operator|(
literal|"END, notfound\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_hpbmap: offset too big\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFBIG
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find place and preinitialize AlSec structure  * AlBlk is initialized to contain AlLeafs.  */
end_comment

begin_function
name|int
name|hpfs_allocalsec
parameter_list|(
name|struct
name|hpfsmount
modifier|*
name|hpmp
parameter_list|,
name|lsn_t
name|parlsn
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|alsec_t
modifier|*
name|asp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|lsn_t
name|lsn
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|bpp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|hpfs_bmfblookup
argument_list|(
name|hpmp
argument_list|,
operator|&
name|lsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_allocalsec: CAN'T ALLOC SPACE FOR AlSec\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|hpfs_bmmarkbusy
argument_list|(
name|hpmp
argument_list|,
name|lsn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bp
operator|=
name|getblk
argument_list|(
name|hpmp
operator|->
name|hpm_devvp
argument_list|,
name|lsn
argument_list|,
name|DEV_BSIZE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Fill AlSec info */
name|asp
operator|=
operator|(
name|alsec_t
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|asp
operator|->
name|as_magic
operator|=
name|AS_MAGIC
expr_stmt|;
name|asp
operator|->
name|as_self
operator|=
name|lsn
expr_stmt|;
name|asp
operator|->
name|as_parent
operator|=
name|parlsn
expr_stmt|;
comment|/* Fill AlBlk */
name|asp
operator|->
name|as_ab
operator|.
name|ab_flag
operator|=
literal|0
expr_stmt|;
name|asp
operator|->
name|as_ab
operator|.
name|ab_busycnt
operator|=
literal|0
expr_stmt|;
name|asp
operator|->
name|as_ab
operator|.
name|ab_freecnt
operator|=
literal|0x28
expr_stmt|;
name|asp
operator|->
name|as_ab
operator|.
name|ab_freeoff
operator|=
sizeof|sizeof
argument_list|(
name|alblk_t
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Split AlSec structure into new allocated:  * allocate new AlSec; then move second half of asp's entries in  * into it; set proper flags.  *  * IF AlSec CONTAINS AlNodes, THEN YOU ALMOST EVERYTIME HAVE TO  * FIX LAST AlNode in OLD AlSec (NEXTOFF TO BE 0xFFFFFFFF).  * TOGETHER WITH FIXING ALL CHILDREN'S AlSecs (THEY HAVE GOT NEW PARENT).  */
end_comment

begin_function
name|int
name|hpfs_splitalsec
parameter_list|(
name|struct
name|hpfsmount
modifier|*
name|hpmp
parameter_list|,
name|alsec_t
modifier|*
name|asp
parameter_list|,
name|alsec_t
modifier|*
modifier|*
name|naspp
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|nbpp
parameter_list|)
block|{
name|alsec_t
modifier|*
name|nasp
decl_stmt|;
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
name|alblk_t
modifier|*
name|abp
decl_stmt|;
name|alblk_t
modifier|*
name|nabp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|n1
decl_stmt|,
name|n2
decl_stmt|,
name|sz
decl_stmt|;
name|error
operator|=
name|hpfs_allocalsec
argument_list|(
name|hpmp
argument_list|,
name|asp
operator|->
name|as_parent
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nasp
operator|=
operator|(
name|alsec_t
operator|*
operator|)
name|nbp
operator|->
name|b_data
expr_stmt|;
name|nabp
operator|=
operator|&
name|nasp
operator|->
name|as_ab
expr_stmt|;
name|abp
operator|=
operator|&
name|asp
operator|->
name|as_ab
expr_stmt|;
name|n1
operator|=
operator|(
name|abp
operator|->
name|ab_busycnt
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|n2
operator|=
operator|(
name|abp
operator|->
name|ab_busycnt
operator|-
name|n1
operator|)
expr_stmt|;
name|sz
operator|=
operator|(
name|abp
operator|->
name|ab_flag
operator|&
name|AB_NODES
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|alnode_t
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|alleaf_t
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|abp
operator|+
sizeof|sizeof
argument_list|(
name|alblk_t
argument_list|)
operator|+
name|n1
operator|*
name|sz
argument_list|,
operator|(
name|caddr_t
operator|)
name|nabp
operator|+
sizeof|sizeof
argument_list|(
name|alblk_t
argument_list|)
argument_list|,
name|n2
operator|*
name|sz
argument_list|)
expr_stmt|;
name|nabp
operator|->
name|ab_flag
operator|=
name|abp
operator|->
name|ab_flag
expr_stmt|;
name|nabp
operator|->
name|ab_busycnt
operator|=
name|n2
expr_stmt|;
name|nabp
operator|->
name|ab_freecnt
operator|=
operator|(
literal|0x1e0
operator|/
name|sz
operator|-
name|n2
operator|)
expr_stmt|;
name|nabp
operator|->
name|ab_freeoff
operator|+=
name|n2
operator|*
name|sz
expr_stmt|;
name|abp
operator|->
name|ab_busycnt
operator|-=
name|n1
expr_stmt|;
name|abp
operator|->
name|ab_freecnt
operator|+=
name|n1
expr_stmt|;
name|abp
operator|->
name|ab_freeoff
operator|-=
name|n1
operator|*
name|sz
expr_stmt|;
operator|*
name|naspp
operator|=
name|nasp
expr_stmt|;
operator|*
name|nbpp
operator|=
name|nbp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to concatenate two AlSec's  *  * Moves all entries from AlSec corresponding (as1p, aanp[1]) into   * corresponding aanp[0] one. If not enought space, then return ENOSPC.  *  * WARNING! YOU HAVE TO FIX aanp VALUES YOURSELF LATER:  * aanp[0].an_nextoff = aanp[1].an_nextoff;  */
end_comment

begin_function
name|int
name|hpfs_concatalsec
parameter_list|(
name|struct
name|hpfsmount
modifier|*
name|hpmp
parameter_list|,
name|alsec_t
modifier|*
name|as0p
parameter_list|,
name|alsec_t
modifier|*
name|as1p
parameter_list|,
name|alnode_t
modifier|*
name|aanp
parameter_list|)
block|{
name|alblk_t
modifier|*
name|ab0p
decl_stmt|;
name|alblk_t
modifier|*
name|ab1p
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_concatalsec: AlSecs at 0x%x and 0x%x \n"
operator|,
name|as0p
operator|->
name|as_self
operator|,
name|as1p
operator|->
name|as_self
operator|)
argument_list|)
expr_stmt|;
name|ab0p
operator|=
operator|&
name|as0p
operator|->
name|as_ab
expr_stmt|;
name|ab1p
operator|=
operator|&
name|as1p
operator|->
name|as_ab
expr_stmt|;
name|sz
operator|=
operator|(
name|ab0p
operator|->
name|ab_flag
operator|&
name|AB_NODES
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|alnode_t
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|alleaf_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|ab0p
operator|->
name|ab_freecnt
operator|>
name|ab1p
operator|->
name|ab_busycnt
condition|)
block|{
comment|/* 		 * Concatenate AlSecs 		 */
if|if
condition|(
name|ab0p
operator|->
name|ab_flag
operator|&
name|AB_NODES
condition|)
name|AB_LASTANP
argument_list|(
name|ab0p
argument_list|)
operator|->
name|an_nextoff
operator|=
name|aanp
index|[
literal|0
index|]
operator|.
name|an_nextoff
expr_stmt|;
name|bcopy
argument_list|(
name|AB_ALNODE
argument_list|(
name|ab1p
argument_list|)
argument_list|,
name|AB_FREEANP
argument_list|(
name|ab0p
argument_list|)
argument_list|,
name|ab1p
operator|->
name|ab_busycnt
operator|*
name|sz
argument_list|)
expr_stmt|;
name|AB_ADDNREC
argument_list|(
name|ab0p
argument_list|,
name|sz
argument_list|,
name|ab1p
operator|->
name|ab_busycnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* Not enought space to concatenate */
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Transform AlBlk structure into new allocated   * AlSec.  *  * DOESN'T SET AlSec'S PARENT LSN.  */
end_comment

begin_function
name|int
name|hpfs_alblk2alsec
parameter_list|(
name|struct
name|hpfsmount
modifier|*
name|hpmp
parameter_list|,
name|alblk_t
modifier|*
name|abp
parameter_list|,
name|alsec_t
modifier|*
modifier|*
name|naspp
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|nbpp
parameter_list|)
block|{
name|alsec_t
modifier|*
name|nasp
decl_stmt|;
name|alblk_t
modifier|*
name|nabp
decl_stmt|;
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sz
decl_stmt|;
name|error
operator|=
name|hpfs_allocalsec
argument_list|(
name|hpmp
argument_list|,
literal|0
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nasp
operator|=
operator|(
name|alsec_t
operator|*
operator|)
name|nbp
operator|->
name|b_data
expr_stmt|;
name|nabp
operator|=
operator|&
name|nasp
operator|->
name|as_ab
expr_stmt|;
name|sz
operator|=
operator|(
name|abp
operator|->
name|ab_flag
operator|&
name|AB_NODES
operator|)
condition|?
sizeof|sizeof
argument_list|(
name|alnode_t
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|alleaf_t
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|abp
argument_list|,
name|nabp
argument_list|,
sizeof|sizeof
argument_list|(
name|alblk_t
argument_list|)
operator|+
name|sz
operator|*
name|abp
operator|->
name|ab_busycnt
argument_list|)
expr_stmt|;
name|nabp
operator|->
name|ab_freecnt
operator|=
literal|0x1e0
operator|/
name|sz
operator|-
name|nabp
operator|->
name|ab_busycnt
expr_stmt|;
operator|*
name|naspp
operator|=
name|nasp
expr_stmt|;
operator|*
name|nbpp
operator|=
name|nbp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate len blocks and concatenate them to file.  * If we hadn't found contignous run of len blocks, concatenate  * as much as we can, and return.  *   */
end_comment

begin_function
name|int
name|hpfs_addextent
parameter_list|(
name|struct
name|hpfsmount
modifier|*
name|hpmp
parameter_list|,
name|struct
name|hpfsnode
modifier|*
name|hp
parameter_list|,
name|u_long
name|len
parameter_list|)
block|{
name|alblk_t
modifier|*
name|rabp
decl_stmt|;
name|alnode_t
name|ranp
index|[
literal|2
index|]
decl_stmt|;
name|alleaf_t
name|al
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_long
name|pf
decl_stmt|;
comment|/* 	 * We don't know for now start lsn of block 	 */
name|al
operator|.
name|al_lsn
operator|=
operator|~
literal|0
expr_stmt|;
name|al
operator|.
name|al_len
operator|=
name|len
expr_stmt|;
name|al
operator|.
name|al_off
operator|=
operator|(
name|hp
operator|->
name|h_fn
operator|.
name|fn_size
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|>>
name|DEV_BSHIFT
expr_stmt|;
name|rabp
operator|=
operator|&
name|hp
operator|->
name|h_fn
operator|.
name|fn_ab
expr_stmt|;
comment|/* Init AlBlk if this is first extent */
if|if
condition|(
name|al
operator|.
name|al_off
operator|==
literal|0
condition|)
block|{
name|lsn_t
name|nlsn
decl_stmt|;
name|u_long
name|nlen
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextent: init AlBlk in root\n"
operator|)
argument_list|)
expr_stmt|;
name|rabp
operator|->
name|ab_busycnt
operator|=
literal|0
expr_stmt|;
name|rabp
operator|->
name|ab_freecnt
operator|=
literal|0x8
expr_stmt|;
name|rabp
operator|->
name|ab_freeoff
operator|=
sizeof|sizeof
argument_list|(
name|alblk_t
argument_list|)
expr_stmt|;
name|rabp
operator|->
name|ab_flag
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|hpfs_bmlookup
argument_list|(
name|hpmp
argument_list|,
literal|0
argument_list|,
name|hp
operator|->
name|h_no
operator|+
literal|1
argument_list|,
name|al
operator|.
name|al_len
argument_list|,
operator|&
name|nlsn
argument_list|,
operator|&
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|hpfs_bmmarkbusy
argument_list|(
name|hpmp
argument_list|,
name|nlsn
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextent: new: 0x%x 0x%lx, "
operator|,
name|nlsn
operator|,
name|nlen
operator|)
argument_list|)
expr_stmt|;
name|AL_SET
argument_list|(
name|AB_FREEALP
argument_list|(
name|rabp
argument_list|)
argument_list|,
name|al
operator|.
name|al_off
argument_list|,
name|nlen
argument_list|,
name|nlsn
argument_list|)
expr_stmt|;
name|AB_ADDAL
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
name|al
operator|.
name|al_off
operator|+=
name|nlen
expr_stmt|;
name|al
operator|.
name|al_len
operator|-=
name|nlen
expr_stmt|;
block|}
name|retry
label|:
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextent: AlBlk: [0x%x, 0x%x, 0x%x] need: 0x%x\n"
operator|,
name|rabp
operator|->
name|ab_freecnt
operator|,
name|rabp
operator|->
name|ab_busycnt
operator|,
name|rabp
operator|->
name|ab_flag
operator|,
name|al
operator|.
name|al_len
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|al
operator|.
name|al_len
operator|)
operator|&&
operator|(
name|rabp
operator|->
name|ab_freecnt
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|rabp
operator|->
name|ab_flag
operator|&
name|AB_NODES
condition|)
block|{
name|alnode_t
modifier|*
name|anp
decl_stmt|;
comment|/* 			 * This is level containing AlNodes, so try to  			 * insert recursively into last entry. 			 */
name|anp
operator|=
name|AB_LASTANP
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextent: AlNode: [0x%x,0x%x] \n"
operator|,
name|anp
operator|->
name|an_nextoff
operator|,
name|anp
operator|->
name|an_lsn
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Try to insert... 			 */
name|error
operator|=
name|hpfs_addextentr
argument_list|(
name|hpmp
argument_list|,
name|anp
operator|->
name|an_lsn
argument_list|,
operator|&
name|al
argument_list|,
name|ranp
argument_list|,
operator|&
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_addextent: FAILED %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|pf
condition|)
block|{
case|case
name|AE_SPLIT
case|:
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextent: successful (split)\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * Then hpfs_addextentr has split tree below, now 				 * we need to fix this level. Particulary: 				 * fix last AlNode and add another one. 				 */
name|bcopy
argument_list|(
name|ranp
argument_list|,
name|AB_LASTANP
argument_list|(
name|rabp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|alnode_t
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|AB_ADDAN
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
name|AE_DONE
case|:
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextent: successful\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|alleaf_t
modifier|*
name|alp
decl_stmt|;
name|alp
operator|=
name|AB_LASTALP
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextent: AlLeaf: [0x%x,0x%x,0x%x] \n"
operator|,
name|alp
operator|->
name|al_off
operator|,
name|alp
operator|->
name|al_len
operator|,
name|alp
operator|->
name|al_lsn
operator|)
argument_list|)
expr_stmt|;
comment|/* Check if we trying to add in right place */
if|if
condition|(
name|alp
operator|->
name|al_off
operator|+
name|alp
operator|->
name|al_len
operator|==
name|al
operator|.
name|al_off
condition|)
block|{
name|lsn_t
name|nlsn
decl_stmt|;
name|u_long
name|nlen
decl_stmt|;
comment|/* 				 * Search bitmap for block begining from 				 * alp->al_lsn + alp->al_len and long of ralp->al_len 				 */
name|error
operator|=
name|hpfs_bmlookup
argument_list|(
name|hpmp
argument_list|,
literal|0
argument_list|,
name|alp
operator|->
name|al_lsn
operator|+
name|alp
operator|->
name|al_len
argument_list|,
name|al
operator|.
name|al_len
argument_list|,
operator|&
name|nlsn
argument_list|,
operator|&
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|hpfs_bmmarkbusy
argument_list|(
name|hpmp
argument_list|,
name|nlsn
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextent: new: 0x%x 0x%lx, "
operator|,
name|nlsn
operator|,
name|nlen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alp
operator|->
name|al_lsn
operator|+
name|alp
operator|->
name|al_len
operator|==
name|nlsn
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"extended existed leaf\n"
operator|)
argument_list|)
expr_stmt|;
name|alp
operator|->
name|al_len
operator|+=
name|nlen
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
operator|(
literal|"created new leaf\n"
operator|)
argument_list|)
expr_stmt|;
name|AL_SET
argument_list|(
name|AB_FREEALP
argument_list|(
name|rabp
argument_list|)
argument_list|,
name|al
operator|.
name|al_off
argument_list|,
name|nlen
argument_list|,
name|nlsn
argument_list|)
expr_stmt|;
name|AB_ADDAL
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
block|}
name|al
operator|.
name|al_off
operator|+=
name|nlen
expr_stmt|;
name|al
operator|.
name|al_len
operator|-=
name|nlen
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"hpfs_addextent: INTERNAL INCONSISTENCE\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * Move AlBlk contain to new AlSec (it will fit more 	 * entries) if overflowed (no more free entries). 	 */
if|if
condition|(
name|rabp
operator|->
name|ab_freecnt
operator|<=
literal|0
condition|)
block|{
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
name|alsec_t
modifier|*
name|nrasp
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextent: overflow, convt\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Convert AlBlk to new AlSec, it will set 		 * AB_FNPARENT also. 		 */
name|rabp
operator|->
name|ab_flag
operator||=
name|AB_FNPARENT
expr_stmt|;
name|error
operator|=
name|hpfs_alblk2alsec
argument_list|(
name|hpmp
argument_list|,
name|rabp
argument_list|,
operator|&
name|nrasp
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_addextent: CAN'T CONVT\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|nrasp
operator|->
name|as_parent
operator|=
name|hp
operator|->
name|h_no
expr_stmt|;
comment|/* 		 * Scan all childrens (if exist), set new parent and 		 * clean their AB_FNPARENT flag. 		 */
if|if
condition|(
name|rabp
operator|->
name|ab_flag
operator|&
name|AB_NODES
condition|)
block|{
name|int
name|i
decl_stmt|;
name|alsec_t
modifier|*
name|asp
decl_stmt|;
name|alnode_t
modifier|*
name|anp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|anp
operator|=
name|AB_ALNODE
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rabp
operator|->
name|ab_busycnt
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|hpfs_breadalsec
argument_list|(
name|hpmp
argument_list|,
name|anp
operator|->
name|an_lsn
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|asp
operator|=
operator|(
name|alsec_t
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|asp
operator|->
name|as_ab
operator|.
name|ab_flag
operator|&=
operator|~
name|AB_FNPARENT
expr_stmt|;
name|asp
operator|->
name|as_parent
operator|=
name|nrasp
operator|->
name|as_self
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|anp
operator|++
expr_stmt|;
block|}
block|}
comment|/* Convert AlBlk to contain AlNodes */
name|rabp
operator|->
name|ab_flag
operator|=
name|AB_NODES
expr_stmt|;
name|rabp
operator|->
name|ab_busycnt
operator|=
literal|0
expr_stmt|;
name|rabp
operator|->
name|ab_freecnt
operator|=
literal|0xC
expr_stmt|;
name|rabp
operator|->
name|ab_freeoff
operator|=
sizeof|sizeof
argument_list|(
name|alblk_t
argument_list|)
expr_stmt|;
comment|/* Add AlNode for new allocated AlSec */
name|AN_SET
argument_list|(
name|AB_FREEANP
argument_list|(
name|rabp
argument_list|)
argument_list|,
operator|~
literal|0
argument_list|,
name|nrasp
operator|->
name|as_self
argument_list|)
expr_stmt|;
name|AB_ADDAN
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|al
operator|.
name|al_len
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextent: root retry\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Descent down to the end of tree, then search for  * ralp->len contignous run begining from last run's end and  * concatenate new block! If we can't find one, then...  */
end_comment

begin_function
name|int
name|hpfs_addextentr
parameter_list|(
name|struct
name|hpfsmount
modifier|*
name|hpmp
parameter_list|,
comment|/* Mix info */
name|lsn_t
name|rlsn
parameter_list|,
comment|/* LSN containing AlSec */
name|alleaf_t
modifier|*
name|ralp
parameter_list|,
comment|/* AlLeaf to insert */
name|alnode_t
modifier|*
name|ranp
parameter_list|,
comment|/* New AlNodes' values */
name|u_long
modifier|*
name|resp
parameter_list|)
comment|/* Mix returning info */
block|{
name|struct
name|buf
modifier|*
name|rbp
decl_stmt|;
name|alsec_t
modifier|*
name|rasp
decl_stmt|;
name|alblk_t
modifier|*
name|rabp
decl_stmt|;
name|alleaf_t
modifier|*
name|alp
decl_stmt|;
name|alnode_t
modifier|*
name|anp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_long
name|pf
decl_stmt|;
name|u_long
name|wb
decl_stmt|;
operator|*
name|resp
operator|=
literal|0
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextentr: AlSec at 0x%x\n"
operator|,
name|rlsn
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hpfs_breadalsec
argument_list|(
name|hpmp
argument_list|,
name|rlsn
argument_list|,
operator|&
name|rbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|rasp
operator|=
operator|(
name|alsec_t
operator|*
operator|)
name|rbp
operator|->
name|b_data
expr_stmt|;
name|rabp
operator|=
operator|&
name|rasp
operator|->
name|as_ab
expr_stmt|;
name|wb
operator|=
literal|0
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextentr: AlBlk: [0x%x, 0x%x, 0x%x]\n"
operator|,
name|rabp
operator|->
name|ab_freecnt
operator|,
name|rabp
operator|->
name|ab_busycnt
operator|,
name|rabp
operator|->
name|ab_flag
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ralp
operator|->
name|al_len
operator|)
operator|&&
operator|(
name|rabp
operator|->
name|ab_freecnt
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|rabp
operator|->
name|ab_flag
operator|&
name|AB_NODES
condition|)
block|{
comment|/* 			 * This is level containing AlNodes, so try to  			 * insert recursively into last entry. 			 */
name|anp
operator|=
name|AB_LASTANP
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextentr: AlNode: [0x%x,0x%x] \n"
operator|,
name|anp
operator|->
name|an_nextoff
operator|,
name|anp
operator|->
name|an_lsn
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Try to insert... 			 */
name|error
operator|=
name|hpfs_addextentr
argument_list|(
name|hpmp
argument_list|,
name|anp
operator|->
name|an_lsn
argument_list|,
name|ralp
argument_list|,
name|ranp
argument_list|,
operator|&
name|pf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_addextentr: FAILED %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|pf
condition|)
block|{
case|case
name|AE_SPLIT
case|:
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextentr: successful (split)\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * Then hpfs_addextentr has split tree below, now 				 * we need to fix this level. Particulary: 				 * fix last AlNode and add another one. 				 */
name|bcopy
argument_list|(
name|ranp
argument_list|,
name|AB_LASTANP
argument_list|(
name|rabp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|alnode_t
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|AB_ADDAN
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
name|wb
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
case|case
name|AE_DONE
case|:
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextentr: successful\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|alp
operator|=
name|AB_LASTALP
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextentr: AlLeaf: [0x%x,0x%x,0x%x] \n"
operator|,
name|alp
operator|->
name|al_off
operator|,
name|alp
operator|->
name|al_len
operator|,
name|alp
operator|->
name|al_lsn
operator|)
argument_list|)
expr_stmt|;
comment|/* Check if we trying to add in right place */
if|if
condition|(
name|alp
operator|->
name|al_off
operator|+
name|alp
operator|->
name|al_len
operator|==
name|ralp
operator|->
name|al_off
condition|)
block|{
name|lsn_t
name|nlsn
decl_stmt|;
name|u_long
name|nlen
decl_stmt|;
comment|/* 				 * Search bitmap for block begining from 				 * alp->al_lsn + alp->al_len and long of ralp->al_len 				 */
name|error
operator|=
name|hpfs_bmlookup
argument_list|(
name|hpmp
argument_list|,
literal|0
argument_list|,
name|alp
operator|->
name|al_lsn
operator|+
name|alp
operator|->
name|al_len
argument_list|,
name|ralp
operator|->
name|al_len
argument_list|,
operator|&
name|nlsn
argument_list|,
operator|&
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|hpfs_bmmarkbusy
argument_list|(
name|hpmp
argument_list|,
name|nlsn
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextentr: new: 0x%x 0x%lx, "
operator|,
name|nlsn
operator|,
name|nlen
operator|)
argument_list|)
expr_stmt|;
comment|/*  				 * If ending of existed entry fits the 				 * begining of the extent being added, 				 * then we add concatenate two extents. 				 */
if|if
condition|(
name|alp
operator|->
name|al_lsn
operator|+
name|alp
operator|->
name|al_len
operator|==
name|nlsn
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"concat\n"
operator|)
argument_list|)
expr_stmt|;
name|alp
operator|->
name|al_len
operator|+=
name|nlen
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
operator|(
literal|"created new leaf\n"
operator|)
argument_list|)
expr_stmt|;
name|AL_SET
argument_list|(
name|AB_FREEALP
argument_list|(
name|rabp
argument_list|)
argument_list|,
name|ralp
operator|->
name|al_off
argument_list|,
name|nlen
argument_list|,
name|nlsn
argument_list|)
expr_stmt|;
name|AB_ADDAL
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
block|}
name|ralp
operator|->
name|al_len
operator|-=
name|nlen
expr_stmt|;
name|ralp
operator|->
name|al_off
operator|+=
name|nlen
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"hpfs_addextentr: INTERNAL INCONSISTENCE\n"
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
name|EINVAL
operator|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
block|}
comment|/* 	 * Split AlBlk if overflowed. 	 */
if|if
condition|(
name|rabp
operator|->
name|ab_freecnt
operator|<=
literal|0
condition|)
block|{
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
name|alsec_t
modifier|*
name|nrasp
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_addextentr: overflow, split\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hpfs_splitalsec
argument_list|(
name|hpmp
argument_list|,
name|rasp
argument_list|,
operator|&
name|nrasp
argument_list|,
operator|&
name|nbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_addextent: CAN'T SPLIT\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|rabp
operator|->
name|ab_flag
operator|&
name|AB_NODES
condition|)
block|{
name|int
name|i
decl_stmt|;
name|alsec_t
modifier|*
name|asp
decl_stmt|;
name|alnode_t
modifier|*
name|anp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|ranp
index|[
literal|0
index|]
operator|.
name|an_nextoff
operator|=
name|AB_LASTANP
argument_list|(
operator|&
name|rasp
operator|->
name|as_ab
argument_list|)
operator|->
name|an_nextoff
expr_stmt|;
comment|/* We need to set left subtree's last entry 			 * offset to 0xFFFFFFFF for OS/2 to be able 			 * to read our files. It treats absence  of 			 * 0xFFFFFFFF as error. 			 */
name|AB_LASTANP
argument_list|(
operator|&
name|rasp
operator|->
name|as_ab
argument_list|)
operator|->
name|an_nextoff
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* We need to fix new allocated AlSec's 			 * children, becouse their parent has changed. 			 */
name|anp
operator|=
name|AB_ALNODE
argument_list|(
operator|&
name|nrasp
operator|->
name|as_ab
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrasp
operator|->
name|as_ab
operator|.
name|ab_busycnt
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|hpfs_breadalsec
argument_list|(
name|hpmp
argument_list|,
name|anp
operator|->
name|an_lsn
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|asp
operator|=
operator|(
name|alsec_t
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|asp
operator|->
name|as_parent
operator|=
name|nrasp
operator|->
name|as_self
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|anp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|ranp
index|[
literal|0
index|]
operator|.
name|an_nextoff
operator|=
name|AB_ALLEAF
argument_list|(
operator|&
name|nrasp
operator|->
name|as_ab
argument_list|)
operator|->
name|al_off
expr_stmt|;
block|}
name|ranp
index|[
literal|0
index|]
operator|.
name|an_lsn
operator|=
name|rasp
operator|->
name|as_self
expr_stmt|;
name|ranp
index|[
literal|1
index|]
operator|.
name|an_nextoff
operator|=
operator|~
literal|0
expr_stmt|;
name|ranp
index|[
literal|1
index|]
operator|.
name|an_lsn
operator|=
name|nrasp
operator|->
name|as_self
expr_stmt|;
name|bdwrite
argument_list|(
name|nbp
argument_list|)
expr_stmt|;
operator|*
name|resp
operator|=
name|AE_SPLIT
expr_stmt|;
name|wb
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|wb
condition|)
name|bdwrite
argument_list|(
name|rbp
argument_list|)
expr_stmt|;
else|else
name|brelse
argument_list|(
name|rbp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|brelse
argument_list|(
name|rbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Recursive routine walking down the b-tree and deallocating all  * extents above bn. Returns *resp != 0 if alblk was totally   * deallocated and may be freed. Tries to keep b-tree.  *  * (XXXX) NOTE! THIS ROUTINE WILL NEVER DECREMENT DEPTH OF  * THE TREE.  */
end_comment

begin_function
name|int
name|hpfs_truncatealblk
parameter_list|(
name|struct
name|hpfsmount
modifier|*
name|hpmp
parameter_list|,
name|alblk_t
modifier|*
name|abp
parameter_list|,
name|lsn_t
name|bn
parameter_list|,
name|int
modifier|*
name|resp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|alleaf_t
modifier|*
name|alp
decl_stmt|;
name|alnode_t
modifier|*
name|anp
decl_stmt|;
name|alsec_t
modifier|*
name|asp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_truncatealblk: AlBlk: [0x%x,0x%x, 0x%x]\n"
operator|,
name|abp
operator|->
name|ab_freecnt
operator|,
name|abp
operator|->
name|ab_busycnt
operator|,
name|abp
operator|->
name|ab_flag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abp
operator|->
name|ab_flag
operator|&
name|AB_NODES
condition|)
block|{
comment|/* 		 * Scan array of AlNodes backward, 		 * diving in recursion if needed 		 */
name|anp
operator|=
name|AB_LASTANP
argument_list|(
name|abp
argument_list|)
expr_stmt|;
while|while
condition|(
name|abp
operator|->
name|ab_busycnt
operator|&&
operator|(
name|bn
operator|<=
name|anp
operator|->
name|an_nextoff
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"hpfs_truncatealblk: AlNode: [0x%x,0x%x] \n"
operator|,
name|anp
operator|->
name|an_nextoff
operator|,
name|anp
operator|->
name|an_lsn
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hpfs_breadalsec
argument_list|(
name|hpmp
argument_list|,
name|anp
operator|->
name|an_lsn
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|asp
operator|=
operator|(
name|alsec_t
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|error
operator|=
name|hpfs_truncatealblk
argument_list|(
name|hpmp
argument_list|,
operator|&
name|asp
operator|->
name|as_ab
argument_list|,
name|bn
argument_list|,
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|resp
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|hpfs_bmmarkfree
argument_list|(
name|hpmp
argument_list|,
name|anp
operator|->
name|an_lsn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|AB_RMAN
argument_list|(
name|abp
argument_list|)
expr_stmt|;
name|anp
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/*  				 * We have deallocated some entries, some space 				 * migth been freed, then try to concat two  				 * last AlSec. 				 */
name|anp
operator|->
name|an_nextoff
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
name|abp
operator|->
name|ab_busycnt
operator|>=
literal|2
condition|)
block|{
name|alsec_t
modifier|*
name|as0p
decl_stmt|;
name|struct
name|buf
modifier|*
name|b0p
decl_stmt|;
name|error
operator|=
name|hpfs_breadalsec
argument_list|(
name|hpmp
argument_list|,
operator|(
name|anp
operator|-
literal|1
operator|)
operator|->
name|an_lsn
argument_list|,
operator|&
name|b0p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|as0p
operator|=
operator|(
name|alsec_t
operator|*
operator|)
name|b0p
operator|->
name|b_data
expr_stmt|;
name|error
operator|=
name|hpfs_concatalsec
argument_list|(
name|hpmp
argument_list|,
name|as0p
argument_list|,
name|asp
argument_list|,
name|anp
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
block|{
comment|/* Not enought space */
name|brelse
argument_list|(
name|b0p
argument_list|)
expr_stmt|;
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* All OK  */
operator|(
name|anp
operator|-
literal|1
operator|)
operator|->
name|an_nextoff
operator|=
name|anp
operator|->
name|an_nextoff
expr_stmt|;
name|bdwrite
argument_list|(
name|b0p
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|hpfs_bmmarkfree
argument_list|(
name|hpmp
argument_list|,
name|anp
operator|->
name|an_lsn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|AB_RMAN
argument_list|(
name|abp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* True error */
name|brelse
argument_list|(
name|b0p
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Nowhere to concatenate */
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* There can not be any more entries 				 * over greater bn, becouse last AlSec 				 * wasn't freed totally. So go out. 				 */
break|break;
block|}
block|}
if|if
condition|(
name|abp
operator|->
name|ab_busycnt
operator|==
literal|0
condition|)
operator|*
name|resp
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|resp
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Scan array of AlLeafs backward, 		 * free all above bn. 		 */
name|alp
operator|=
name|AB_LASTALP
argument_list|(
name|abp
argument_list|)
expr_stmt|;
while|while
condition|(
name|abp
operator|->
name|ab_busycnt
operator|&&
operator|(
name|bn
operator|<
name|alp
operator|->
name|al_off
operator|+
name|alp
operator|->
name|al_len
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"hpfs_truncatealblk: AlLeaf: [0x%x,0x%x,0x%x] \n"
operator|,
name|alp
operator|->
name|al_off
operator|,
name|alp
operator|->
name|al_len
operator|,
name|alp
operator|->
name|al_lsn
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bn
operator|<=
name|alp
operator|->
name|al_off
condition|)
block|{
name|error
operator|=
name|hpfs_bmmarkfree
argument_list|(
name|hpmp
argument_list|,
name|alp
operator|->
name|al_lsn
argument_list|,
name|alp
operator|->
name|al_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|AB_RMAL
argument_list|(
name|abp
argument_list|)
expr_stmt|;
name|alp
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bn
operator|>
name|alp
operator|->
name|al_off
operator|)
operator|&&
operator|(
name|bn
operator|<
name|alp
operator|->
name|al_off
operator|+
name|alp
operator|->
name|al_len
operator|)
condition|)
block|{
name|error
operator|=
name|hpfs_bmmarkfree
argument_list|(
name|hpmp
argument_list|,
name|alp
operator|->
name|al_lsn
operator|+
name|bn
operator|-
name|alp
operator|->
name|al_off
argument_list|,
name|alp
operator|->
name|al_len
operator|-
name|bn
operator|+
name|alp
operator|->
name|al_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|alp
operator|->
name|al_len
operator|=
name|bn
operator|-
name|alp
operator|->
name|al_off
expr_stmt|;
break|break;
block|}
else|else
break|break;
block|}
block|}
comment|/* Signal parent deallocation, if need */
if|if
condition|(
name|abp
operator|->
name|ab_busycnt
operator|==
literal|0
condition|)
operator|*
name|resp
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|resp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

