begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998, 1999 Semen Ustimenko (semenu@FreeBSD.org)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_vfs.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<fs/hpfs/hpfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/hpfs/hpfsmount.h>
end_include

begin_include
include|#
directive|include
file|<fs/hpfs/hpfs_subr.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_HPFSMNT
argument_list|,
literal|"hpfs_mount"
argument_list|,
literal|"HPFS mount structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_HPFSNO
argument_list|,
literal|"hpfs_node"
argument_list|,
literal|"HPFS node structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct_decl
struct_decl|struct
name|sockaddr
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|int
name|hpfs_mountfs
parameter_list|(
specifier|register
name|struct
name|vnode
modifier|*
parameter_list|,
name|struct
name|mount
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|vfs_fhtovp_t
name|hpfs_fhtovp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_vget_t
name|hpfs_vget
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_cmount_t
name|hpfs_cmount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_mount_t
name|hpfs_mount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_root_t
name|hpfs_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_statfs_t
name|hpfs_statfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vfs_unmount_t
name|hpfs_unmount
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|hpfs_cmount
parameter_list|(
name|struct
name|mntarg
modifier|*
name|ma
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|hpfs_args
name|args
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpfs_args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ma
operator|=
name|mount_argsu
argument_list|(
name|ma
argument_list|,
literal|"from"
argument_list|,
name|args
operator|.
name|fspec
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"export"
argument_list|,
operator|&
name|args
operator|.
name|export
argument_list|,
sizeof|sizeof
name|args
operator|.
name|export
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_argf
argument_list|(
name|ma
argument_list|,
literal|"uid"
argument_list|,
literal|"%d"
argument_list|,
name|args
operator|.
name|uid
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_argf
argument_list|(
name|ma
argument_list|,
literal|"gid"
argument_list|,
literal|"%d"
argument_list|,
name|args
operator|.
name|gid
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_argf
argument_list|(
name|ma
argument_list|,
literal|"mode"
argument_list|,
literal|"%d"
argument_list|,
name|args
operator|.
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|flags
operator|&
name|HPFSMNT_TABLES
condition|)
block|{
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"d2u"
argument_list|,
name|args
operator|.
name|d2u
argument_list|,
sizeof|sizeof
name|args
operator|.
name|d2u
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"u2d"
argument_list|,
name|args
operator|.
name|u2d
argument_list|,
sizeof|sizeof
name|args
operator|.
name|u2d
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|kernel_mount
argument_list|(
name|ma
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|hpfs_opts
index|[]
init|=
block|{
literal|"from"
block|,
literal|"export"
block|,
literal|"uid"
block|,
literal|"gid"
block|,
literal|"mode"
block|,
literal|"d2u"
block|,
literal|"u2d"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|hpfs_mount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|hpfsmount
modifier|*
name|hpmp
init|=
literal|0
decl_stmt|;
name|struct
name|nameidata
name|ndp
decl_stmt|;
name|struct
name|export_args
name|export
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_omount():\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *** 	 * Mounting non-root filesystem or updating a filesystem 	 *** 	 */
if|if
condition|(
name|vfs_filteropt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
name|hpfs_opts
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|from
operator|=
name|vfs_getopts
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"from"
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If updating, check whether changing from read-only to 	 * read/write; if there is no device name, that's all we do. 	 */
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"hpfs_omount: MNT_UPDATE: "
operator|)
argument_list|)
expr_stmt|;
name|hpmp
operator|=
name|VFSTOHPFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|vfs_copyopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"export"
argument_list|,
operator|&
name|export
argument_list|,
sizeof|sizeof
name|export
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dprintf
argument_list|(
operator|(
literal|"export 0x%x\n"
operator|,
name|args
operator|.
name|export
operator|.
name|ex_flags
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|vfs_export
argument_list|(
name|mp
argument_list|,
operator|&
name|export
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_omount: vfs_export failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
goto|goto
name|success
goto|;
block|}
else|else
block|{
name|dprintf
argument_list|(
operator|(
literal|"name [FAILED]\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|success
goto|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Not an update, or updating the name: look up the name 	 * and verify that it refers to a sensible block device. 	 */
name|NDINIT
argument_list|(
operator|&
name|ndp
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|from
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|err
operator|=
name|namei
argument_list|(
operator|&
name|ndp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* can't get devvp!*/
goto|goto
name|error_1
goto|;
block|}
name|devvp
operator|=
name|ndp
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
operator|!
name|vn_isdisk
argument_list|(
name|devvp
argument_list|,
operator|&
name|err
argument_list|)
condition|)
block|{
name|vput
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 ******************** 	 * NEW MOUNT 	 ******************** 	 */
comment|/* 	 * Since this is a new mount, we want the names for 	 * the device and the mount point copied in.  If an 	 * error occurs, the mountpoint is discarded by the 	 * upper level code.  Note that vfs_omount() handles 	 * copying the mountpoint f_mntonname for us, so we 	 * don't have to do it here unless we want to set it 	 * to something other than "path" for some rason. 	 */
comment|/* Save "mounted from" info for mount point (NULL pad)*/
name|vfs_mountedfrom
argument_list|(
name|mp
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|err
operator|=
name|hpfs_mountfs
argument_list|(
name|devvp
argument_list|,
name|mp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|vrele
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
goto|goto
name|error_1
goto|;
block|}
goto|goto
name|success
goto|;
name|error_1
label|:
comment|/* no state to back out*/
comment|/* XXX: Missing NDFREE(&ndp, ...) */
name|success
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common code for mount and mountroot  */
end_comment

begin_function
name|int
name|hpfs_mountfs
parameter_list|(
name|devvp
parameter_list|,
name|mp
parameter_list|,
name|td
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|ronly
decl_stmt|,
name|v
decl_stmt|;
name|struct
name|sublock
modifier|*
name|sup
decl_stmt|;
name|struct
name|spblock
modifier|*
name|spp
decl_stmt|;
name|struct
name|hpfsmount
modifier|*
name|hpmp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
init|=
name|devvp
operator|->
name|v_rdev
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_ROOTFS
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_mountfs():\n"
operator|)
argument_list|)
expr_stmt|;
name|ronly
operator|=
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* XXX: use VOP_ACCESS to check FS perms */
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_vfs_open
argument_list|(
name|devvp
argument_list|,
operator|&
name|cp
argument_list|,
literal|"hpfs"
argument_list|,
name|ronly
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bo
operator|=
operator|&
name|devvp
operator|->
name|v_bufobj
expr_stmt|;
name|bo
operator|->
name|bo_private
operator|=
name|cp
expr_stmt|;
name|bo
operator|->
name|bo_ops
operator|=
name|g_vfs_bufops
expr_stmt|;
comment|/* 	 * Do actual mount 	 */
name|hpmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hpfsmount
argument_list|)
argument_list|,
name|M_HPFSMNT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|hpmp
operator|->
name|hpm_cp
operator|=
name|cp
expr_stmt|;
name|hpmp
operator|->
name|hpm_bo
operator|=
name|bo
expr_stmt|;
comment|/* Read in SuperBlock */
name|error
operator|=
name|bread
argument_list|(
name|devvp
argument_list|,
name|SUBLOCK
argument_list|,
name|SUSIZE
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|hpmp
operator|->
name|hpm_su
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sublock
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
comment|/* Read in SpareBlock */
name|error
operator|=
name|bread
argument_list|(
name|devvp
argument_list|,
name|SPBLOCK
argument_list|,
name|SPSIZE
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|hpmp
operator|->
name|hpm_sp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spblock
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|sup
operator|=
operator|&
name|hpmp
operator|->
name|hpm_su
expr_stmt|;
name|spp
operator|=
operator|&
name|hpmp
operator|->
name|hpm_sp
expr_stmt|;
comment|/* Check magic */
if|if
condition|(
name|sup
operator|->
name|su_magic
operator|!=
name|SU_MAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_mountfs: SuperBlock MAGIC DOESN'T MATCH\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|spp
operator|->
name|sp_magic
operator|!=
name|SP_MAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_mountfs: SpareBlock MAGIC DOESN'T MATCH\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
name|hpmp
expr_stmt|;
name|hpmp
operator|->
name|hpm_devvp
operator|=
name|devvp
expr_stmt|;
name|hpmp
operator|->
name|hpm_dev
operator|=
name|devvp
operator|->
name|v_rdev
expr_stmt|;
name|hpmp
operator|->
name|hpm_mp
operator|=
name|mp
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|vfs_scanopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"uid"
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|v
argument_list|)
condition|)
name|hpmp
operator|->
name|hpm_uid
operator|=
name|v
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|vfs_scanopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"gid"
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|v
argument_list|)
condition|)
name|hpmp
operator|->
name|hpm_gid
operator|=
name|v
expr_stmt|;
if|if
condition|(
literal|1
operator|==
name|vfs_scanopt
argument_list|(
name|mp
operator|->
name|mnt_optnew
argument_list|,
literal|"mode"
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|v
argument_list|)
condition|)
name|hpmp
operator|->
name|hpm_mode
operator|=
name|v
expr_stmt|;
name|error
operator|=
name|hpfs_bminit
argument_list|(
name|hpmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
name|error
operator|=
name|hpfs_cpinit
argument_list|(
name|mp
argument_list|,
name|hpmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|hpfs_bmdeinit
argument_list|(
name|hpmp
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|error
operator|=
name|hpfs_root
argument_list|(
name|mp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|vp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|hpfs_cpdeinit
argument_list|(
name|hpmp
argument_list|)
expr_stmt|;
name|hpfs_bmdeinit
argument_list|(
name|hpmp
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|dev2udev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
name|mp
operator|->
name|mnt_maxsymlinklen
operator|=
literal|0
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
name|NULL
expr_stmt|;
name|g_vfs_close
argument_list|(
name|cp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|,
name|ronly
decl_stmt|;
specifier|register
name|struct
name|hpfsmount
modifier|*
name|hpmp
init|=
name|VFSTOHPFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_unmount():\n"
operator|)
argument_list|)
expr_stmt|;
name|ronly
operator|=
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|!=
literal|0
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mntflags
operator|&
name|MNT_FORCE
condition|)
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_unmount: vflushing...\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_unmount: vflush failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vinvalbuf
argument_list|(
name|hpmp
operator|->
name|hpm_devvp
argument_list|,
name|V_SAVE
argument_list|,
name|td
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_vfs_close
argument_list|(
name|hpmp
operator|->
name|hpm_cp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|hpmp
operator|->
name|hpm_devvp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_umount: freeing memory...\n"
operator|)
argument_list|)
expr_stmt|;
name|hpfs_cpdeinit
argument_list|(
name|hpmp
argument_list|)
expr_stmt|;
name|hpfs_bmdeinit
argument_list|(
name|hpmp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
literal|0
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_LOCAL
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|hpmp
argument_list|,
name|M_HPFSMNT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|hpfsmount
modifier|*
name|hpmp
init|=
name|VFSTOHPFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_root():\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
operator|(
name|ino_t
operator|)
name|hpmp
operator|->
name|hpm_su
operator|.
name|su_rootfno
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_root: VFS_VGET failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|hpfsmount
modifier|*
name|hpmp
init|=
name|VFSTOHPFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_statfs(): HPFS%d.%d\n"
operator|,
name|hpmp
operator|->
name|hpm_su
operator|.
name|su_hpfsver
operator|,
name|hpmp
operator|->
name|hpm_su
operator|.
name|su_fnctver
operator|)
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_type
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
name|sbp
operator|->
name|f_bsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|sbp
operator|->
name|f_iosize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
name|hpmp
operator|->
name|hpm_su
operator|.
name|su_btotal
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
name|sbp
operator|->
name|f_bavail
operator|=
name|hpmp
operator|->
name|hpm_bavail
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_flags
operator|=
name|mp
operator|->
name|mnt_flag
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|hpfs_fhtovp
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|fid
modifier|*
name|fhp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|struct
name|hpfid
modifier|*
name|hpfhp
init|=
operator|(
expr|struct
name|hpfid
operator|*
operator|)
name|fhp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|hpfhp
operator|->
name|hpfid_ino
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|nvp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* XXX as unlink/rmdir/mkdir/creat are not currently possible 	 * with HPFS, we don't need to check anything else for now */
operator|*
name|vpp
operator|=
name|nvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_vget
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|hpfsmount
modifier|*
name|hpmp
init|=
name|VFSTOHPFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|hpfsnode
modifier|*
name|hp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_vget(0x%x): "
operator|,
name|ino
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vfs_hash_get
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
name|flags
argument_list|,
name|curthread
argument_list|,
name|vpp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|*
name|vpp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|hp
operator|=
name|NULL
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We have to lock node creation for a while, 	 * but then we have to call getnewvnode(),  	 * this may cause hpfs_reclaim() to be called, 	 * this may need to VOP_VGET() parent dir for 	 * update reasons, and if parent is not in 	 * hash, we have to lock node creation... 	 * To solve this, we MALLOC, getnewvnode and init while 	 * not locked (probability of node appearence 	 * at that time is little, and anyway - we'll 	 * check for it). 	 */
name|MALLOC
argument_list|(
name|hp
argument_list|,
expr|struct
name|hpfsnode
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpfsnode
argument_list|)
argument_list|,
name|M_HPFSNO
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|getnewvnode
argument_list|(
literal|"hpfs"
argument_list|,
name|mp
argument_list|,
operator|&
name|hpfs_vnodeops
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_vget: can't get new vnode\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|hp
argument_list|,
name|M_HPFSNO
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"prenew "
operator|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|hp
expr_stmt|;
if|if
condition|(
name|ino
operator|==
operator|(
name|ino_t
operator|)
name|hpmp
operator|->
name|hpm_su
operator|.
name|su_rootfno
condition|)
name|vp
operator|->
name|v_vflag
operator||=
name|VV_ROOT
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|hp
operator|->
name|h_interlock
argument_list|,
literal|"hpfsnode interlock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|hp
operator|->
name|h_flag
operator|=
name|H_INVAL
expr_stmt|;
name|hp
operator|->
name|h_vp
operator|=
name|vp
expr_stmt|;
name|hp
operator|->
name|h_hpmp
operator|=
name|hpmp
expr_stmt|;
name|hp
operator|->
name|h_no
operator|=
name|ino
expr_stmt|;
name|hp
operator|->
name|h_dev
operator|=
name|hpmp
operator|->
name|hpm_dev
expr_stmt|;
name|hp
operator|->
name|h_uid
operator|=
name|hpmp
operator|->
name|hpm_uid
expr_stmt|;
name|hp
operator|->
name|h_gid
operator|=
name|hpmp
operator|->
name|hpm_uid
expr_stmt|;
name|hp
operator|->
name|h_mode
operator|=
name|hpmp
operator|->
name|hpm_mode
expr_stmt|;
name|hp
operator|->
name|h_devvp
operator|=
name|hpmp
operator|->
name|hpm_devvp
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|lockmgr
argument_list|(
name|vp
operator|->
name|v_vnlock
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|insmntque
argument_list|(
name|vp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|hp
argument_list|,
name|M_HPFSNO
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|vfs_hash_insert
argument_list|(
name|vp
argument_list|,
name|ino
argument_list|,
name|flags
argument_list|,
name|td
argument_list|,
name|vpp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|*
name|vpp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|bread
argument_list|(
name|hpmp
operator|->
name|hpm_devvp
argument_list|,
name|ino
argument_list|,
name|FNODESIZE
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_vget: can't read ino %d\n"
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|hp
operator|->
name|h_fn
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fnode
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_fn
operator|.
name|fn_magic
operator|!=
name|FN_MAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_vget: MAGIC DOESN'T MATCH\n"
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|vp
operator|->
name|v_type
operator|=
name|hp
operator|->
name|h_fn
operator|.
name|fn_flag
condition|?
name|VDIR
else|:
name|VREG
expr_stmt|;
name|hp
operator|->
name|h_flag
operator|&=
operator|~
name|H_INVAL
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|hpfs_vfsops
init|=
block|{
operator|.
name|vfs_fhtovp
operator|=
name|hpfs_fhtovp
block|,
operator|.
name|vfs_cmount
operator|=
name|hpfs_cmount
block|,
operator|.
name|vfs_mount
operator|=
name|hpfs_mount
block|,
operator|.
name|vfs_root
operator|=
name|hpfs_root
block|,
operator|.
name|vfs_statfs
operator|=
name|hpfs_statfs
block|,
operator|.
name|vfs_unmount
operator|=
name|hpfs_unmount
block|,
operator|.
name|vfs_vget
operator|=
name|hpfs_vget
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|hpfs_vfsops
argument_list|,
name|hpfs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

