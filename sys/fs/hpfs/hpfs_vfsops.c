begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998, 1999 Semen Ustimenko (semenu@FreeBSD.org)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fs/hpfs/hpfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/hpfs/hpfsmount.h>
end_include

begin_include
include|#
directive|include
file|<fs/hpfs/hpfs_subr.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_HPFSMNT
argument_list|,
literal|"HPFS mount"
argument_list|,
literal|"HPFS mount structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_HPFSNO
argument_list|,
literal|"HPFS node"
argument_list|,
literal|"HPFS node structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|hpfs_root
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_statfs
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
expr|struct
name|statfs
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_unmount
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
name|int
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_vget
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
name|mp
operator|,
name|ino_t
name|ino
operator|,
expr|struct
name|vnode
operator|*
operator|*
name|vpp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_mountfs
name|__P
argument_list|(
operator|(
specifier|register
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|mount
operator|*
operator|,
expr|struct
name|hpfs_args
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_vptofh
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|fid
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_fhtovp
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
expr|struct
name|fid
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|hpfs_quotactl
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
name|int
operator|,
name|uid_t
operator|,
name|caddr_t
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_start
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
name|int
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_sync
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
name|int
operator|,
expr|struct
name|ucred
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_struct_decl
struct_decl|struct
name|sockaddr
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|int
name|hpfs_mount
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
name|char
operator|*
operator|,
name|caddr_t
operator|,
expr|struct
name|nameidata
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_init
name|__P
argument_list|(
operator|(
expr|struct
name|vfsconf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_checkexp
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
name|int
operator|*
operator|,
expr|struct
name|ucred
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined(__NetBSD__) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hpfs_mount
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|void
operator|*
operator|,
expr|struct
name|nameidata
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpfs_init
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_mountroot
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_sysctl
name|__P
argument_list|(
operator|(
name|int
operator|*
operator|,
name|u_int
operator|,
name|void
operator|*
operator|,
name|size_t
operator|*
operator|,
name|void
operator|*
operator|,
name|size_t
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_checkexp
name|__P
argument_list|(
operator|(
expr|struct
name|mount
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
name|int
operator|*
operator|,
expr|struct
name|ucred
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|hpfs_checkexp
parameter_list|(
name|mp
parameter_list|,
name|nam
parameter_list|,
name|exflagsp
parameter_list|,
name|credanonp
parameter_list|)
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
specifier|register
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|int
modifier|*
name|exflagsp
decl_stmt|;
name|struct
name|ucred
modifier|*
modifier|*
name|credanonp
decl_stmt|;
else|#
directive|else
comment|/* defined(__NetBSD__) */
specifier|register
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
name|int
modifier|*
name|exflagsp
decl_stmt|;
name|struct
name|ucred
modifier|*
modifier|*
name|credanonp
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|struct
name|netcred
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|hpfsmount
modifier|*
name|hpm
init|=
name|VFSTOHPFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
comment|/* 	 * Get the export permission structure for this<mp, client> tuple. 	 */
name|np
operator|=
name|vfs_export_lookup
argument_list|(
name|mp
argument_list|,
operator|&
name|hpm
operator|->
name|hpm_export
argument_list|,
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
operator|*
name|exflagsp
operator|=
name|np
operator|->
name|netc_exflags
expr_stmt|;
operator|*
name|credanonp
operator|=
operator|&
name|np
operator|->
name|netc_anon
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|hpfs_sysctl
parameter_list|(
name|name
parameter_list|,
name|namelen
parameter_list|,
name|oldp
parameter_list|,
name|oldlenp
parameter_list|,
name|newp
parameter_list|,
name|newlen
parameter_list|,
name|p
parameter_list|)
name|int
modifier|*
name|name
decl_stmt|;
name|u_int
name|namelen
decl_stmt|;
name|void
modifier|*
name|oldp
decl_stmt|;
name|size_t
modifier|*
name|oldlenp
decl_stmt|;
name|void
modifier|*
name|newp
decl_stmt|;
name|size_t
name|newlen
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_mountroot
parameter_list|()
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|hpfs_init
argument_list|(
expr|struct
name|vfsconf
operator|*
name|vcp
argument_list|)
else|#
directive|else
comment|/* defined(__NetBSD__) */
decl|static
name|void
name|hpfs_init
argument_list|()
endif|#
directive|endif
block|{
name|dprintf
argument_list|(
operator|(
literal|"hpfs_init():\n"
operator|)
argument_list|)
expr_stmt|;
name|hpfs_hphashinit
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_function
specifier|static
name|int
name|hpfs_mount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|char
modifier|*
name|path
parameter_list|,
name|caddr_t
name|data
parameter_list|,
else|#
directive|else
comment|/* defined(__NetBSD__) */
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
endif|#
directive|endif
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|u_int
name|size
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|hpfs_args
name|args
decl_stmt|;
name|struct
name|hpfsmount
modifier|*
name|hpmp
init|=
literal|0
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_mount():\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 *** 	 * Mounting non-root file system or updating a file system 	 *** 	 */
comment|/* copy in user arguments*/
name|err
operator|=
name|copyin
argument_list|(
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpfs_args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|error_1
goto|;
comment|/* can't get arguments*/
comment|/* 	 * If updating, check whether changing from read-only to 	 * read/write; if there is no device name, that's all we do. 	 */
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"hpfs_mount: MNT_UPDATE: "
operator|)
argument_list|)
expr_stmt|;
name|hpmp
operator|=
name|VFSTOHPFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|fspec
operator|==
literal|0
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"export 0x%x\n"
operator|,
name|args
operator|.
name|export
operator|.
name|ex_flags
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|vfs_export
argument_list|(
name|mp
argument_list|,
operator|&
name|hpmp
operator|->
name|hpm_export
argument_list|,
operator|&
name|args
operator|.
name|export
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_mount: vfs_export failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
goto|goto
name|success
goto|;
block|}
else|else
block|{
name|dprintf
argument_list|(
operator|(
literal|"name [FAILED]\n"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|success
goto|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Not an update, or updating the name: look up the name 	 * and verify that it refers to a sensible block device. 	 */
name|NDINIT
argument_list|(
name|ndp
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|args
operator|.
name|fspec
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|err
operator|=
name|namei
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* can't get devvp!*/
goto|goto
name|error_1
goto|;
block|}
name|devvp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
operator|!
name|vn_isdisk
argument_list|(
name|devvp
argument_list|,
operator|&
name|err
argument_list|)
condition|)
goto|goto
name|error_2
goto|;
else|#
directive|else
comment|/* defined(__NetBSD__) */
if|if
condition|(
name|devvp
operator|->
name|v_type
operator|!=
name|VBLK
condition|)
block|{
name|err
operator|=
name|ENOTBLK
expr_stmt|;
goto|goto
name|error_2
goto|;
block|}
if|if
condition|(
name|major
argument_list|(
name|devvp
operator|->
name|v_rdev
argument_list|)
operator|>=
name|nblkdev
condition|)
block|{
name|err
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|error_2
goto|;
block|}
endif|#
directive|endif
comment|/* 	 ******************** 	 * NEW MOUNT 	 ******************** 	 */
comment|/* 	 * Since this is a new mount, we want the names for 	 * the device and the mount point copied in.  If an 	 * error occurs,  the mountpoint is discarded by the 	 * upper level code. 	 */
comment|/* Save "last mounted on" info for mount point (NULL pad)*/
name|copyinstr
argument_list|(
name|path
argument_list|,
comment|/* mount point*/
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
comment|/* save area*/
name|MNAMELEN
operator|-
literal|1
argument_list|,
comment|/* max size*/
operator|&
name|size
argument_list|)
expr_stmt|;
comment|/* real size*/
name|bzero
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
operator|+
name|size
argument_list|,
name|MNAMELEN
operator|-
name|size
argument_list|)
expr_stmt|;
comment|/* Save "mounted from" info for mount point (NULL pad)*/
name|copyinstr
argument_list|(
name|args
operator|.
name|fspec
argument_list|,
comment|/* device name*/
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
comment|/* save area*/
name|MNAMELEN
operator|-
literal|1
argument_list|,
comment|/* max size*/
operator|&
name|size
argument_list|)
expr_stmt|;
comment|/* real size*/
name|bzero
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
operator|+
name|size
argument_list|,
name|MNAMELEN
operator|-
name|size
argument_list|)
expr_stmt|;
name|err
operator|=
name|hpfs_mountfs
argument_list|(
name|devvp
argument_list|,
name|mp
argument_list|,
operator|&
name|args
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|error_2
goto|;
comment|/* 	 * Initialize FS stat information in mount struct; uses both 	 * mp->mnt_stat.f_mntonname and mp->mnt_stat.f_mntfromname 	 * 	 * This code is common to root and non-root mounts 	 */
operator|(
name|void
operator|)
name|VFS_STATFS
argument_list|(
name|mp
argument_list|,
operator|&
name|mp
operator|->
name|mnt_stat
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|success
goto|;
name|error_2
label|:
comment|/* error with devvp held*/
comment|/* release devvp before failing*/
name|vrele
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
name|error_1
label|:
comment|/* no state to back out*/
name|success
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common code for mount and mountroot  */
end_comment

begin_function
name|int
name|hpfs_mountfs
parameter_list|(
name|devvp
parameter_list|,
name|mp
parameter_list|,
name|argsp
parameter_list|,
name|p
parameter_list|)
specifier|register
name|struct
name|vnode
modifier|*
name|devvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|hpfs_args
modifier|*
name|argsp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|ncount
decl_stmt|,
name|ronly
decl_stmt|;
name|struct
name|sublock
modifier|*
name|sup
decl_stmt|;
name|struct
name|spblock
modifier|*
name|spp
decl_stmt|;
name|struct
name|hpfsmount
modifier|*
name|hpmp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|dev_t
name|dev
init|=
name|devvp
operator|->
name|v_rdev
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_mountfs():\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Disallow multiple mounts of the same device. 	 * Disallow mounting of a device that is currently in use 	 * (except for root, which might share swap device for miniroot). 	 * Flush out any old buffers remaining from a previous use. 	 */
name|error
operator|=
name|vfs_mountedon
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ncount
operator|=
name|vcount
argument_list|(
name|devvp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|devvp
operator|->
name|v_object
condition|)
name|ncount
operator|-=
literal|1
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ncount
operator|>
literal|1
operator|&&
name|devvp
operator|!=
name|rootvp
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|VN_LOCK
argument_list|(
name|devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|vinvalbuf
argument_list|(
name|devvp
argument_list|,
name|V_SAVE
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP__UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|vinvalbuf
argument_list|(
name|devvp
argument_list|,
name|V_SAVE
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ronly
operator|=
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|!=
literal|0
expr_stmt|;
name|VN_LOCK
argument_list|(
name|devvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|devvp
argument_list|,
name|ronly
condition|?
name|FREAD
else|:
name|FREAD
operator||
name|FWRITE
argument_list|,
name|FSCRED
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VOP__UNLOCK
argument_list|(
name|devvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Do actual mount 	 */
name|hpmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hpfsmount
argument_list|)
argument_list|,
name|M_HPFSMNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hpmp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpfsmount
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in SuperBlock */
name|error
operator|=
name|bread
argument_list|(
name|devvp
argument_list|,
name|SUBLOCK
argument_list|,
name|SUSIZE
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|hpmp
operator|->
name|hpm_su
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sublock
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
comment|/* Read in SpareBlock */
name|error
operator|=
name|bread
argument_list|(
name|devvp
argument_list|,
name|SPBLOCK
argument_list|,
name|SPSIZE
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|hpmp
operator|->
name|hpm_sp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spblock
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|sup
operator|=
operator|&
name|hpmp
operator|->
name|hpm_su
expr_stmt|;
name|spp
operator|=
operator|&
name|hpmp
operator|->
name|hpm_sp
expr_stmt|;
comment|/* Check magic */
if|if
condition|(
name|sup
operator|->
name|su_magic
operator|!=
name|SU_MAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_mountfs: SuperBlock MAGIC DOESN'T MATCH\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|spp
operator|->
name|sp_magic
operator|!=
name|SP_MAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_mountfs: SpareBlock MAGIC DOESN'T MATCH\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
name|hpmp
expr_stmt|;
name|hpmp
operator|->
name|hpm_devvp
operator|=
name|devvp
expr_stmt|;
name|hpmp
operator|->
name|hpm_dev
operator|=
name|devvp
operator|->
name|v_rdev
expr_stmt|;
name|hpmp
operator|->
name|hpm_mp
operator|=
name|mp
expr_stmt|;
name|hpmp
operator|->
name|hpm_uid
operator|=
name|argsp
operator|->
name|uid
expr_stmt|;
name|hpmp
operator|->
name|hpm_gid
operator|=
name|argsp
operator|->
name|gid
expr_stmt|;
name|hpmp
operator|->
name|hpm_mode
operator|=
name|argsp
operator|->
name|mode
expr_stmt|;
name|error
operator|=
name|hpfs_bminit
argument_list|(
name|hpmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
name|error
operator|=
name|hpfs_cpinit
argument_list|(
name|hpmp
argument_list|,
name|argsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|hpfs_bmdeinit
argument_list|(
name|hpmp
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|error
operator|=
name|hpfs_root
argument_list|(
name|mp
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|hpfs_cpdeinit
argument_list|(
name|hpmp
argument_list|)
expr_stmt|;
name|hpfs_bmdeinit
argument_list|(
name|hpmp
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|dev2udev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
else|#
directive|else
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|dev
expr_stmt|;
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|makefstype
argument_list|(
name|MOUNT_HPFS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mp
operator|->
name|mnt_maxsymlinklen
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
name|devvp
operator|->
name|v_specmountpoint
operator|=
name|mp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|devvp
operator|->
name|v_specmountpoint
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|devvp
operator|->
name|v_specflags
operator|&=
operator|~
name|SI_MOUNTEDON
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|devvp
argument_list|,
name|ronly
condition|?
name|FREAD
else|:
name|FREAD
operator||
name|FWRITE
argument_list|,
name|NOCRED
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
specifier|static
name|int
name|hpfs_start
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|hpfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|,
name|ronly
decl_stmt|;
specifier|register
name|struct
name|hpfsmount
modifier|*
name|hpmp
init|=
name|VFSTOHPFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_unmount():\n"
operator|)
argument_list|)
expr_stmt|;
name|ronly
operator|=
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|!=
literal|0
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mntflags
operator|&
name|MNT_FORCE
condition|)
name|flags
operator||=
name|FORCECLOSE
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_unmount: vflushing...\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
name|NULLVP
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_unmount: vflush failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|hpmp
operator|->
name|hpm_devvp
operator|->
name|v_specmountpoint
operator|=
name|NULL
expr_stmt|;
else|#
directive|else
name|hpmp
operator|->
name|hpm_devvp
operator|->
name|v_specflags
operator|&=
operator|~
name|SI_MOUNTEDON
expr_stmt|;
endif|#
directive|endif
name|vinvalbuf
argument_list|(
name|hpmp
operator|->
name|hpm_devvp
argument_list|,
name|V_SAVE
argument_list|,
name|NOCRED
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CLOSE
argument_list|(
name|hpmp
operator|->
name|hpm_devvp
argument_list|,
name|ronly
condition|?
name|FREAD
else|:
name|FREAD
operator||
name|FWRITE
argument_list|,
name|NOCRED
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|hpmp
operator|->
name|hpm_devvp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_umount: freeing memory...\n"
operator|)
argument_list|)
expr_stmt|;
name|hpfs_cpdeinit
argument_list|(
name|hpmp
argument_list|)
expr_stmt|;
name|hpfs_bmdeinit
argument_list|(
name|hpmp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_data
operator|=
operator|(
name|qaddr_t
operator|)
literal|0
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_LOCAL
expr_stmt|;
name|FREE
argument_list|(
name|hpmp
argument_list|,
name|M_HPFSMNT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|hpfsmount
modifier|*
name|hpmp
init|=
name|VFSTOHPFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_root():\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
operator|(
name|ino_t
operator|)
name|hpmp
operator|->
name|hpm_su
operator|.
name|su_rootfno
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_root: VFS_VGET failed: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|hpfsmount
modifier|*
name|hpmp
init|=
name|VFSTOHPFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_statfs(): HPFS%d.%d\n"
operator|,
name|hpmp
operator|->
name|hpm_su
operator|.
name|su_hpfsver
operator|,
name|hpmp
operator|->
name|hpm_su
operator|.
name|su_fnctver
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sbp
operator|->
name|f_type
operator|=
name|mp
operator|->
name|mnt_vfc
operator|->
name|vfc_typenum
expr_stmt|;
else|#
directive|else
comment|/* defined(__NetBSD__) */
name|sbp
operator|->
name|f_type
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|sbp
operator|->
name|f_bsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|sbp
operator|->
name|f_iosize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
name|hpmp
operator|->
name|hpm_su
operator|.
name|su_btotal
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
name|sbp
operator|->
name|f_bavail
operator|=
name|hpmp
operator|->
name|hpm_bavail
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sbp
operator|!=
operator|&
name|mp
operator|->
name|mnt_stat
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbp
operator|->
name|f_mntonname
index|[
literal|0
index|]
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbp
operator|->
name|f_mntfromname
index|[
literal|0
index|]
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
block|}
name|sbp
operator|->
name|f_flags
operator|=
name|mp
operator|->
name|mnt_flag
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
specifier|static
name|int
name|hpfs_sync
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|waitfor
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_quotactl
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|cmds
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|printf
argument_list|(
literal|"hpfs_quotactl():\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|hpfs_fhtovp
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|fid
modifier|*
name|fhp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|struct
name|hpfid
modifier|*
name|hpfhp
init|=
operator|(
expr|struct
name|hpfid
operator|*
operator|)
name|fhp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|hpfhp
operator|->
name|hpfid_ino
argument_list|,
operator|&
name|nvp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* XXX as unlink/rmdir/mkdir/creat are not currently possible 	 * with HPFS, we don't need to check anything else for now */
operator|*
name|vpp
operator|=
name|nvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_vptofh
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|fid
modifier|*
name|fhp
parameter_list|)
block|{
specifier|register
name|struct
name|hpfsnode
modifier|*
name|hpp
decl_stmt|;
specifier|register
name|struct
name|hpfid
modifier|*
name|hpfhp
decl_stmt|;
name|hpp
operator|=
name|VTOHP
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|hpfhp
operator|=
operator|(
expr|struct
name|hpfid
operator|*
operator|)
name|fhp
expr_stmt|;
name|hpfhp
operator|->
name|hpfid_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|hpfid
argument_list|)
expr_stmt|;
name|hpfhp
operator|->
name|hpfid_ino
operator|=
name|hpp
operator|->
name|h_no
expr_stmt|;
comment|/* hpfhp->hpfid_gen = hpp->h_gen; */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_vget
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|ino_t
name|ino
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|hpfsmount
modifier|*
name|hpmp
init|=
name|VFSTOHPFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|hpfsnode
modifier|*
name|hp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|int
name|error
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_vget(0x%x): "
operator|,
name|ino
operator|)
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|hp
operator|=
name|NULL
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|vpp
operator|=
name|hpfs_hphashvget
argument_list|(
name|hpmp
operator|->
name|hpm_dev
argument_list|,
name|ino
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"hashed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We have to lock node creation for a while, 	 * but then we have to call getnewvnode(),  	 * this may cause hpfs_reclaim() to be called, 	 * this may need to VOP_VGET() parent dir for 	 * update reasons, and if parent is not in 	 * hash, we have to lock node creation... 	 * To solve this, we MALLOC, getnewvnode and init while 	 * not locked (probability of node appearence 	 * at that time is little, and anyway - we'll 	 * check for it). 	 */
name|MALLOC
argument_list|(
name|hp
argument_list|,
expr|struct
name|hpfsnode
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpfsnode
argument_list|)
argument_list|,
name|M_HPFSNO
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|getnewvnode
argument_list|(
name|VT_HPFS
argument_list|,
name|hpmp
operator|->
name|hpm_mp
argument_list|,
name|hpfs_vnodeop_p
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_vget: can't get new vnode\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|hp
argument_list|,
name|M_HPFSNO
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"prenew "
operator|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|hp
expr_stmt|;
if|if
condition|(
name|ino
operator|==
operator|(
name|ino_t
operator|)
name|hpmp
operator|->
name|hpm_su
operator|.
name|su_rootfno
condition|)
name|vp
operator|->
name|v_flag
operator||=
name|VROOT
expr_stmt|;
name|simple_lock_init
argument_list|(
operator|&
name|hp
operator|->
name|h_interlock
argument_list|)
expr_stmt|;
name|lockinit
argument_list|(
operator|&
name|hp
operator|->
name|h_lock
argument_list|,
name|PINOD
argument_list|,
literal|"hpnode"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|h_flag
operator|=
name|H_INVAL
expr_stmt|;
name|hp
operator|->
name|h_vp
operator|=
name|vp
expr_stmt|;
name|hp
operator|->
name|h_hpmp
operator|=
name|hpmp
expr_stmt|;
name|hp
operator|->
name|h_no
operator|=
name|ino
expr_stmt|;
name|hp
operator|->
name|h_dev
operator|=
name|hpmp
operator|->
name|hpm_dev
expr_stmt|;
name|hp
operator|->
name|h_uid
operator|=
name|hpmp
operator|->
name|hpm_uid
expr_stmt|;
name|hp
operator|->
name|h_gid
operator|=
name|hpmp
operator|->
name|hpm_uid
expr_stmt|;
name|hp
operator|->
name|h_mode
operator|=
name|hpmp
operator|->
name|hpm_mode
expr_stmt|;
name|hp
operator|->
name|h_devvp
operator|=
name|hpmp
operator|->
name|hpm_devvp
expr_stmt|;
name|VREF
argument_list|(
name|hp
operator|->
name|h_devvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VN_LOCK
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
do|do
block|{
if|if
condition|(
operator|(
operator|*
name|vpp
operator|=
name|hpfs_hphashvget
argument_list|(
name|hpmp
operator|->
name|hpm_dev
argument_list|,
name|ino
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"hashed2\n"
operator|)
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
do|while
condition|(
name|LOCKMGR
argument_list|(
operator|&
name|hpfs_hphash_lock
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_SLEEPFAIL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
do|;
name|hpfs_hphashins
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|LOCKMGR
argument_list|(
operator|&
name|hpfs_hphash_lock
argument_list|,
name|LK_RELEASE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|hpmp
operator|->
name|hpm_devvp
argument_list|,
name|ino
argument_list|,
name|FNODESIZE
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_vget: can't read ino %d\n"
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
operator|&
name|hp
operator|->
name|h_fn
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fnode
argument_list|)
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_fn
operator|.
name|fn_magic
operator|!=
name|FN_MAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_vget: MAGIC DOESN'T MATCH\n"
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|vp
operator|->
name|v_type
operator|=
name|hp
operator|->
name|h_fn
operator|.
name|fn_flag
condition|?
name|VDIR
else|:
name|VREG
expr_stmt|;
name|hp
operator|->
name|h_flag
operator|&=
operator|~
name|H_INVAL
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|hpfs_vfsops
init|=
block|{
name|hpfs_mount
block|,
name|vfs_stdstart
block|,
name|hpfs_unmount
block|,
name|hpfs_root
block|,
name|vfs_stdquotactl
block|,
name|hpfs_statfs
block|,
name|vfs_stdsync
block|,
name|hpfs_vget
block|,
name|hpfs_fhtovp
block|,
name|hpfs_checkexp
block|,
name|hpfs_vptofh
block|,
name|hpfs_init
block|,
name|vfs_stduninit
block|,
name|vfs_stdextattrctl
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|hpfs_vfsops
argument_list|,
name|hpfs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined(__NetBSD__) */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|vnodeopv_desc
name|hpfs_vnodeop_opv_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnodeopv_desc
modifier|*
name|hpfs_vnodeopv_descs
index|[]
init|=
block|{
operator|&
name|hpfs_vnodeop_opv_desc
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vfsops
name|hpfs_vfsops
init|=
block|{
name|MOUNT_HPFS
block|,
name|hpfs_mount
block|,
name|hpfs_start
block|,
name|hpfs_unmount
block|,
name|hpfs_root
block|,
name|hpfs_quotactl
block|,
name|hpfs_statfs
block|,
name|hpfs_sync
block|,
name|hpfs_vget
block|,
name|hpfs_fhtovp
block|,
name|hpfs_vptofh
block|,
name|hpfs_init
block|,
name|hpfs_sysctl
block|,
name|hpfs_mountroot
block|,
name|hpfs_checkexp
block|,
name|hpfs_vnodeopv_descs
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

