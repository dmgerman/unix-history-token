begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998, 1999 Semen Ustimenko (semenu@FreeBSD.org)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_zone.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<vm/vnode_pager.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/genfs/genfs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_comment
comment|/* for pathconf(2) constants */
end_comment

begin_include
include|#
directive|include
file|<fs/hpfs/hpfs.h>
end_include

begin_include
include|#
directive|include
file|<fs/hpfs/hpfsmount.h>
end_include

begin_include
include|#
directive|include
file|<fs/hpfs/hpfs_subr.h>
end_include

begin_include
include|#
directive|include
file|<fs/hpfs/hpfs_ioctl.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|hpfs_de_uiomove
name|__P
argument_list|(
operator|(
expr|struct
name|hpfsmount
operator|*
operator|,
expr|struct
name|hpfsdirent
operator|*
operator|,
expr|struct
name|uio
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|vop_ioctl_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_read
name|__P
argument_list|(
operator|(
expr|struct
name|vop_read_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_write
name|__P
argument_list|(
operator|(
expr|struct
name|vop_write_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_getattr
name|__P
argument_list|(
operator|(
expr|struct
name|vop_getattr_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_setattr
name|__P
argument_list|(
operator|(
expr|struct
name|vop_setattr_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_inactive
name|__P
argument_list|(
operator|(
expr|struct
name|vop_inactive_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_print
name|__P
argument_list|(
operator|(
expr|struct
name|vop_print_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_reclaim
name|__P
argument_list|(
operator|(
expr|struct
name|vop_reclaim_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_strategy
name|__P
argument_list|(
operator|(
expr|struct
name|vop_strategy_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_access
name|__P
argument_list|(
operator|(
expr|struct
name|vop_access_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_open
name|__P
argument_list|(
operator|(
expr|struct
name|vop_open_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_close
name|__P
argument_list|(
operator|(
expr|struct
name|vop_close_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_readdir
name|__P
argument_list|(
operator|(
expr|struct
name|vop_readdir_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_lookup
name|__P
argument_list|(
operator|(
expr|struct
name|vop_lookup_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_create
name|__P
argument_list|(
operator|(
expr|struct
name|vop_create_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_remove
name|__P
argument_list|(
operator|(
expr|struct
name|vop_remove_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_bmap
name|__P
argument_list|(
operator|(
expr|struct
name|vop_bmap_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|hpfs_getpages
name|__P
argument_list|(
operator|(
expr|struct
name|vop_getpages_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_putpages
name|__P
argument_list|(
operator|(
expr|struct
name|vop_putpages_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hpfs_fsync
name|__P
argument_list|(
operator|(
expr|struct
name|vop_fsync_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|hpfs_pathconf
name|__P
argument_list|(
operator|(
expr|struct
name|vop_pathconf_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
name|int
name|hpfs_getpages
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getpages_args
modifier|*
name|ap
decl_stmt|;
block|{
return|return
name|vnode_pager_generic_getpages
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_m
argument_list|,
name|ap
operator|->
name|a_count
argument_list|,
name|ap
operator|->
name|a_reqpage
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|hpfs_putpages
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_putpages_args
modifier|*
name|ap
decl_stmt|;
block|{
return|return
name|vnode_pager_generic_putpages
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_m
argument_list|,
name|ap
operator|->
name|a_count
argument_list|,
name|ap
operator|->
name|a_sync
argument_list|,
name|ap
operator|->
name|a_rtvals
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_fsync
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fsync_args
comment|/* { 		struct vnode *a_vp; 		struct ucred *a_cred; 		int a_waitfor; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|;
comment|/* 	 * Flush all dirty buffers associated with a vnode. 	 */
name|loop
label|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|vp
operator|->
name|v_dirtyblkhd
argument_list|)
init|;
name|bp
condition|;
name|bp
operator|=
name|nbp
control|)
block|{
name|nbp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_vnbufs
argument_list|)
expr_stmt|;
if|if
condition|(
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"hpfs_fsync: not dirty"
argument_list|)
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
while|while
condition|(
name|vp
operator|->
name|v_numoutput
condition|)
block|{
name|vp
operator|->
name|v_flag
operator||=
name|VBWAIT
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vp
operator|->
name|v_numoutput
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|,
literal|"hpfsn"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|vp
operator|->
name|v_dirtyblkhd
argument_list|)
condition|)
block|{
name|vprint
argument_list|(
literal|"hpfs_fsync: dirty"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Write out the on-disc version of the vnode. 	 */
return|return
name|hpfs_update
argument_list|(
name|VTOHP
argument_list|(
name|vp
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|hpfs_ioctl
parameter_list|(
name|struct
name|vop_ioctl_args
comment|/* { 		struct vnode *a_vp; 		u_long a_command; 		caddr_t a_data; 		int a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
parameter_list|)
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|hpfsnode
modifier|*
name|hp
init|=
name|VTOHP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|printf
argument_list|(
literal|"hpfs_ioctl(0x%x, 0x%lx, 0x%p, 0x%x): "
argument_list|,
name|hp
operator|->
name|h_no
argument_list|,
name|ap
operator|->
name|a_command
argument_list|,
name|ap
operator|->
name|a_data
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ap
operator|->
name|a_command
condition|)
block|{
case|case
name|HPFSIOCGEANUM
case|:
block|{
name|u_long
name|eanum
decl_stmt|;
name|u_long
name|passed
decl_stmt|;
name|struct
name|ea
modifier|*
name|eap
decl_stmt|;
name|eanum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_fn
operator|.
name|fn_ealen
operator|>
literal|0
condition|)
block|{
name|eap
operator|=
operator|(
expr|struct
name|ea
operator|*
operator|)
operator|&
operator|(
name|hp
operator|->
name|h_fn
operator|.
name|fn_int
operator|)
expr_stmt|;
name|passed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|passed
operator|<
name|hp
operator|->
name|h_fn
operator|.
name|fn_ealen
condition|)
block|{
name|printf
argument_list|(
literal|"EAname: %s\n"
argument_list|,
name|EA_NAME
argument_list|(
name|eap
argument_list|)
argument_list|)
expr_stmt|;
name|eanum
operator|++
expr_stmt|;
name|passed
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ea
argument_list|)
operator|+
name|eap
operator|->
name|ea_namelen
operator|+
literal|1
operator|+
name|eap
operator|->
name|ea_vallen
expr_stmt|;
name|eap
operator|=
operator|(
expr|struct
name|ea
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|hp
operator|->
name|h_fn
operator|.
name|fn_int
operator|+
name|passed
operator|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%lu eas\n"
argument_list|,
name|eanum
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
name|ap
operator|->
name|a_data
operator|=
name|eanum
expr_stmt|;
break|break;
block|}
case|case
name|HPFSIOCGEASZ
case|:
block|{
name|u_long
name|eanum
decl_stmt|;
name|u_long
name|passed
decl_stmt|;
name|struct
name|ea
modifier|*
name|eap
decl_stmt|;
name|printf
argument_list|(
literal|"EA%ld\n"
argument_list|,
operator|*
operator|(
name|u_long
operator|*
operator|)
name|ap
operator|->
name|a_data
argument_list|)
expr_stmt|;
name|eanum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_fn
operator|.
name|fn_ealen
operator|>
literal|0
condition|)
block|{
name|eap
operator|=
operator|(
expr|struct
name|ea
operator|*
operator|)
operator|&
operator|(
name|hp
operator|->
name|h_fn
operator|.
name|fn_int
operator|)
expr_stmt|;
name|passed
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
while|while
condition|(
name|passed
operator|<
name|hp
operator|->
name|h_fn
operator|.
name|fn_ealen
condition|)
block|{
name|printf
argument_list|(
literal|"EAname: %s\n"
argument_list|,
name|EA_NAME
argument_list|(
name|eap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eanum
operator|==
operator|*
operator|(
name|u_long
operator|*
operator|)
name|ap
operator|->
name|a_data
condition|)
block|{
operator|*
operator|(
name|u_long
operator|*
operator|)
name|ap
operator|->
name|a_data
operator|=
name|eap
operator|->
name|ea_namelen
operator|+
literal|1
operator|+
name|eap
operator|->
name|ea_vallen
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|eanum
operator|++
expr_stmt|;
name|passed
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ea
argument_list|)
operator|+
name|eap
operator|->
name|ea_namelen
operator|+
literal|1
operator|+
name|eap
operator|->
name|ea_vallen
expr_stmt|;
name|eap
operator|=
operator|(
expr|struct
name|ea
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|hp
operator|->
name|h_fn
operator|.
name|fn_int
operator|+
name|passed
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
break|break;
block|}
case|case
name|HPFSIOCRDEA
case|:
block|{
name|u_long
name|eanum
decl_stmt|;
name|u_long
name|passed
decl_stmt|;
name|struct
name|hpfs_rdea
modifier|*
name|rdeap
decl_stmt|;
name|struct
name|ea
modifier|*
name|eap
decl_stmt|;
name|rdeap
operator|=
operator|(
expr|struct
name|hpfs_rdea
operator|*
operator|)
name|ap
operator|->
name|a_data
expr_stmt|;
name|printf
argument_list|(
literal|"EA%ld\n"
argument_list|,
name|rdeap
operator|->
name|ea_no
argument_list|)
expr_stmt|;
name|eanum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_fn
operator|.
name|fn_ealen
operator|>
literal|0
condition|)
block|{
name|eap
operator|=
operator|(
expr|struct
name|ea
operator|*
operator|)
operator|&
operator|(
name|hp
operator|->
name|h_fn
operator|.
name|fn_int
operator|)
expr_stmt|;
name|passed
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
while|while
condition|(
name|passed
operator|<
name|hp
operator|->
name|h_fn
operator|.
name|fn_ealen
condition|)
block|{
name|printf
argument_list|(
literal|"EAname: %s\n"
argument_list|,
name|EA_NAME
argument_list|(
name|eap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eanum
operator|==
name|rdeap
operator|->
name|ea_no
condition|)
block|{
name|rdeap
operator|->
name|ea_sz
operator|=
name|eap
operator|->
name|ea_namelen
operator|+
literal|1
operator|+
name|eap
operator|->
name|ea_vallen
expr_stmt|;
name|copyout
argument_list|(
name|EA_NAME
argument_list|(
name|eap
argument_list|)
argument_list|,
name|rdeap
operator|->
name|ea_data
argument_list|,
name|rdeap
operator|->
name|ea_sz
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|eanum
operator|++
expr_stmt|;
name|passed
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ea
argument_list|)
operator|+
name|eap
operator|->
name|ea_namelen
operator|+
literal|1
operator|+
name|eap
operator|->
name|ea_vallen
expr_stmt|;
name|eap
operator|=
operator|(
expr|struct
name|ea
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|hp
operator|->
name|h_fn
operator|.
name|fn_int
operator|+
name|passed
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map file offset to disk offset.  */
end_comment

begin_function
name|int
name|hpfs_bmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bmap_args
comment|/* { 		struct vnode *a_vp; 		daddr_t  a_bn; 		struct vnode **a_vpp; 		daddr_t *a_bnp; 		int *a_runp; 		int *a_runb; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|hpfsnode
modifier|*
name|hp
init|=
name|VTOHP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vpp
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|hp
operator|->
name|h_devvp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|ap
operator|->
name|a_runb
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_runb
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ap
operator|->
name|a_bnp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_bmap(0x%x, 0x%x): "
operator|,
name|hp
operator|->
name|h_no
operator|,
name|ap
operator|->
name|a_bn
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hpfs_hpbmap
argument_list|(
name|hp
argument_list|,
name|ap
operator|->
name|a_bn
argument_list|,
name|ap
operator|->
name|a_bnp
argument_list|,
name|ap
operator|->
name|a_runp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|hpfsnode
modifier|*
name|hp
init|=
name|VTOHP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|u_int
name|xfersz
decl_stmt|,
name|toread
decl_stmt|;
name|u_int
name|off
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|,
name|bn
decl_stmt|;
name|int
name|resid
decl_stmt|;
name|int
name|runl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|resid
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|hp
operator|->
name|h_fn
operator|.
name|fn_size
operator|-
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_read(0x%x, off: %d resid: %d, segflg: %d): [resid: 0x%x]\n"
operator|,
name|hp
operator|->
name|h_no
operator|,
operator|(
name|u_int32_t
operator|)
name|uio
operator|->
name|uio_offset
operator|,
name|uio
operator|->
name|uio_resid
operator|,
name|uio
operator|->
name|uio_segflg
operator|,
name|resid
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|resid
condition|)
block|{
name|lbn
operator|=
name|uio
operator|->
name|uio_offset
operator|>>
name|DEV_BSHIFT
expr_stmt|;
name|off
operator|=
name|uio
operator|->
name|uio_offset
operator|&
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_read: resid: 0x%x lbn: 0x%x off: 0x%x\n"
operator|,
name|uio
operator|->
name|uio_resid
operator|,
name|lbn
operator|,
name|off
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hpfs_hpbmap
argument_list|(
name|hp
argument_list|,
name|lbn
argument_list|,
operator|&
name|bn
argument_list|,
operator|&
name|runl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|toread
operator|=
name|min
argument_list|(
name|off
operator|+
name|resid
argument_list|,
name|min
argument_list|(
name|DFLTPHYS
argument_list|,
operator|(
name|runl
operator|+
literal|1
operator|)
operator|*
name|DEV_BSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|xfersz
operator|=
operator|(
name|toread
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_read: bn: 0x%x (0x%x) toread: 0x%x (0x%x)\n"
operator|,
name|bn
operator|,
name|runl
operator|,
name|toread
operator|,
name|xfersz
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|toread
operator|==
literal|0
condition|)
break|break;
name|error
operator|=
name|bread
argument_list|(
name|hp
operator|->
name|h_devvp
argument_list|,
name|bn
argument_list|,
name|xfersz
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|uiomove
argument_list|(
name|bp
operator|->
name|b_data
operator|+
name|off
argument_list|,
name|toread
operator|-
name|off
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|resid
operator|-=
name|toread
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"hpfs_read: successful\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_write
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_write_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int  a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|hpfsnode
modifier|*
name|hp
init|=
name|VTOHP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|u_int
name|xfersz
decl_stmt|,
name|towrite
decl_stmt|;
name|u_int
name|off
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|,
name|bn
decl_stmt|;
name|int
name|runl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_write(0x%x, off: %d resid: %d, segflg: %d):\n"
operator|,
name|hp
operator|->
name|h_no
operator|,
operator|(
name|u_int32_t
operator|)
name|uio
operator|->
name|uio_offset
operator|,
name|uio
operator|->
name|uio_resid
operator|,
name|uio
operator|->
name|uio_segflg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_ioflag
operator|&
name|IO_APPEND
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"hpfs_write: APPEND mode\n"
operator|)
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|=
name|hp
operator|->
name|h_fn
operator|.
name|fn_size
expr_stmt|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
operator|>
name|hp
operator|->
name|h_fn
operator|.
name|fn_size
condition|)
block|{
name|error
operator|=
name|hpfs_extend
argument_list|(
name|hp
argument_list|,
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_write: hpfs_extend FAILED %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
while|while
condition|(
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|lbn
operator|=
name|uio
operator|->
name|uio_offset
operator|>>
name|DEV_BSHIFT
expr_stmt|;
name|off
operator|=
name|uio
operator|->
name|uio_offset
operator|&
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_write: resid: 0x%x lbn: 0x%x off: 0x%x\n"
operator|,
name|uio
operator|->
name|uio_resid
operator|,
name|lbn
operator|,
name|off
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hpfs_hpbmap
argument_list|(
name|hp
argument_list|,
name|lbn
argument_list|,
operator|&
name|bn
argument_list|,
operator|&
name|runl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|towrite
operator|=
name|min
argument_list|(
name|off
operator|+
name|uio
operator|->
name|uio_resid
argument_list|,
name|min
argument_list|(
name|DFLTPHYS
argument_list|,
operator|(
name|runl
operator|+
literal|1
operator|)
operator|*
name|DEV_BSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|xfersz
operator|=
operator|(
name|towrite
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_write: bn: 0x%x (0x%x) towrite: 0x%x (0x%x)\n"
operator|,
name|bn
operator|,
name|runl
operator|,
name|towrite
operator|,
name|xfersz
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|==
literal|0
operator|)
operator|&&
operator|(
name|towrite
operator|==
name|xfersz
operator|)
condition|)
block|{
name|bp
operator|=
name|getblk
argument_list|(
name|hp
operator|->
name|h_devvp
argument_list|,
name|bn
argument_list|,
name|xfersz
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|bread
argument_list|(
name|hp
operator|->
name|h_devvp
argument_list|,
name|bn
argument_list|,
name|xfersz
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|error
operator|=
name|uiomove
argument_list|(
name|bp
operator|->
name|b_data
operator|+
name|off
argument_list|,
name|towrite
operator|-
name|off
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|ap
operator|->
name|a_ioflag
operator|&
name|IO_SYNC
condition|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"hpfs_write: successful\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXXXX do we need hpfsnode locking inside?  */
end_comment

begin_function
specifier|static
name|int
name|hpfs_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|hpfsnode
modifier|*
name|hp
init|=
name|VTOHP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_getattr(0x%x):\n"
operator|,
name|hp
operator|->
name|h_no
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|vap
operator|->
name|va_fsid
operator|=
name|dev2udev
argument_list|(
name|hp
operator|->
name|h_dev
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* defined(__NetBSD__) */
name|vap
operator|->
name|va_fsid
operator|=
name|ip
operator|->
name|i_dev
expr_stmt|;
endif|#
directive|endif
name|vap
operator|->
name|va_fileid
operator|=
name|hp
operator|->
name|h_no
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|hp
operator|->
name|h_mode
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
literal|1
expr_stmt|;
name|vap
operator|->
name|va_uid
operator|=
name|hp
operator|->
name|h_uid
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
name|hp
operator|->
name|h_gid
expr_stmt|;
name|vap
operator|->
name|va_rdev
operator|=
literal|0
expr_stmt|;
comment|/* XXX UNODEV ? */
name|vap
operator|->
name|va_size
operator|=
name|hp
operator|->
name|h_fn
operator|.
name|fn_size
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
operator|(
operator|(
name|hp
operator|->
name|h_fn
operator|.
name|fn_size
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|DEV_BSIZE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|hp
operator|->
name|h_flag
operator|&
name|H_PARVALID
operator|)
condition|)
block|{
name|error
operator|=
name|hpfs_validateparent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vap
operator|->
name|va_atime
operator|=
name|hpfstimetounix
argument_list|(
name|hp
operator|->
name|h_atime
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|=
name|hpfstimetounix
argument_list|(
name|hp
operator|->
name|h_mtime
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_ctime
operator|=
name|hpfstimetounix
argument_list|(
name|hp
operator|->
name|h_ctime
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_flags
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_gen
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_blocksize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|vp
operator|->
name|v_type
expr_stmt|;
name|vap
operator|->
name|va_filerev
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXXXX do we need hpfsnode locking inside?  */
end_comment

begin_function
specifier|static
name|int
name|hpfs_setattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|hpfsnode
modifier|*
name|hp
init|=
name|VTOHP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|ap
operator|->
name|a_p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_setattr(0x%x):\n"
operator|,
name|hp
operator|->
name|h_no
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check for unsettable attributes. 	 */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_type
operator|!=
name|VNON
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_nlink
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fsid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fileid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_blocksize
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_rdev
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_bytes
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_gen
operator|!=
name|VNOVAL
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"hpfs_setattr: changing nonsettable attr\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Can't change flags XXX Could be implemented */
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_setattr: FLAGS CANNOT BE SET\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Can't change uid/gid XXX Could be implemented */
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_setattr: UID/GID CANNOT BE SET\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Can't change mode XXX Could be implemented */
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_setattr: MODE CANNOT BE SET\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Update times */
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
name|hp
operator|->
name|h_uid
operator|&&
operator|(
name|error
operator|=
name|suser_xxx
argument_list|(
name|cred
argument_list|,
name|p
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|vap
operator|->
name|va_vaflags
operator|&
name|VA_UTIMES_NULL
operator|)
operator|==
literal|0
operator|||
operator|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VWRITE
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
operator|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
name|hp
operator|->
name|h_atime
operator|=
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
name|hp
operator|->
name|h_mtime
operator|=
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
expr_stmt|;
name|hp
operator|->
name|h_flag
operator||=
name|H_PARCHANGE
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VDIR
case|:
return|return
operator|(
name|EISDIR
operator|)
return|;
case|case
name|VREG
case|:
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
break|break;
default|default:
name|printf
argument_list|(
literal|"hpfs_setattr: WRONG v_type\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_size
operator|<
name|hp
operator|->
name|h_fn
operator|.
name|fn_size
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|error
operator|=
name|vtruncbuf
argument_list|(
name|vp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|vap
operator|->
name|va_size
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
else|#
directive|else
comment|/* defined(__NetBSD__) */
error|#
directive|error
error|Need alternation for vtruncbuf()
endif|#
directive|endif
name|error
operator|=
name|hpfs_truncate
argument_list|(
name|hp
argument_list|,
name|vap
operator|->
name|va_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|va_size
operator|>
name|hp
operator|->
name|h_fn
operator|.
name|fn_size
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|vap
operator|->
name|va_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|hpfs_extend
argument_list|(
name|hp
argument_list|,
name|vap
operator|->
name|va_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Last reference to an node.  If necessary, write or delete it.  */
end_comment

begin_function
name|int
name|hpfs_inactive
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_inactive_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|hpfsnode
modifier|*
name|hp
init|=
name|VTOHP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_inactive(0x%x): \n"
operator|,
name|hp
operator|->
name|h_no
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_flag
operator|&
name|H_CHANGE
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"hpfs_inactive: node changed, update\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hpfs_update
argument_list|(
name|hp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|hp
operator|->
name|h_flag
operator|&
name|H_PARCHANGE
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"hpfs_inactive: parent node changed, update\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|hpfs_updateparent
argument_list|(
name|hp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|prtactive
operator|&&
name|vp
operator|->
name|v_usecount
operator|!=
literal|0
condition|)
name|vprint
argument_list|(
literal|"hpfs_inactive: pushing active"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_flag
operator|&
name|H_INVAL
condition|)
block|{
name|VOP__UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|vrecycle
argument_list|(
name|vp
argument_list|,
operator|(
expr|struct
name|simplelock
operator|*
operator|)
literal|0
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* defined(__NetBSD__) */
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|VOP__UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim an inode so that it can be used for other purposes.  */
end_comment

begin_function
name|int
name|hpfs_reclaim
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_reclaim_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|hpfsnode
modifier|*
name|hp
init|=
name|VTOHP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_reclaim(0x%x0): \n"
operator|,
name|hp
operator|->
name|h_no
operator|)
argument_list|)
expr_stmt|;
name|hpfs_hphashrem
argument_list|(
name|hp
argument_list|)
expr_stmt|;
comment|/* Purge old data structures associated with the inode. */
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_devvp
condition|)
block|{
name|vrele
argument_list|(
name|hp
operator|->
name|h_devvp
argument_list|)
expr_stmt|;
name|hp
operator|->
name|h_devvp
operator|=
name|NULL
expr_stmt|;
block|}
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
name|FREE
argument_list|(
name|hp
argument_list|,
name|M_HPFSNO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_print
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_print_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|hpfsnode
modifier|*
name|hp
init|=
name|VTOHP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"tag VT_HPFS, ino 0x%x"
argument_list|,
name|hp
operator|->
name|h_no
argument_list|)
expr_stmt|;
name|lockmgr_printinfo
argument_list|(
operator|&
name|hp
operator|->
name|h_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the logical to physical mapping if not done already,  * then call the device strategy routine.  *  * In order to be able to swap to a file, the VOP_BMAP operation may not  * deadlock on memory.  See hpfs_bmap() for details. XXXXXXX (not impl)  */
end_comment

begin_function
name|int
name|hpfs_strategy
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_strategy_args
comment|/* { 		struct buf *a_bp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_strategy(): \n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
operator|||
name|vp
operator|->
name|v_type
operator|==
name|VCHR
condition|)
name|panic
argument_list|(
literal|"hpfs_strategy: spec"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|bp
operator|->
name|b_lblkno
condition|)
block|{
name|error
operator|=
name|VOP_BMAP
argument_list|(
name|vp
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
operator|&
name|nvp
argument_list|,
operator|&
name|bp
operator|->
name|b_blkno
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_strategy: VOP_BMAP FAILED %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|error
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
name|vfs_bio_clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
block|{
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bp
operator|->
name|b_dev
operator|=
name|nvp
operator|->
name|v_rdev
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|nvp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXXXX do we need hpfsnode locking inside?  */
end_comment

begin_function
name|int
name|hpfs_access
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_access_args
comment|/* { 		struct vnode *a_vp; 		int  a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|hpfsnode
modifier|*
name|hp
init|=
name|VTOHP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|mode_t
name|mask
decl_stmt|,
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
specifier|register
name|gid_t
modifier|*
name|gp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_access(0x%x):\n"
operator|,
name|hp
operator|->
name|h_no
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Disallow write attempts on read-only file systems; 	 * unless the file is a socket, fifo, or a block or 	 * character device resident on the file system. 	 */
if|if
condition|(
name|mode
operator|&
name|VWRITE
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
case|case
name|VREG
case|:
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
break|break;
block|}
block|}
comment|/* Otherwise, user id 0 always gets access. */
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mask
operator|=
literal|0
expr_stmt|;
comment|/* Otherwise, check the owner. */
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
name|hp
operator|->
name|h_uid
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|VEXEC
condition|)
name|mask
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|VREAD
condition|)
name|mask
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|VWRITE
condition|)
name|mask
operator||=
name|S_IWUSR
expr_stmt|;
return|return
operator|(
operator|(
name|hp
operator|->
name|h_mode
operator|&
name|mask
operator|)
operator|==
name|mask
condition|?
literal|0
else|:
name|EACCES
operator|)
return|;
block|}
comment|/* Otherwise, check the groups. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|gp
operator|=
name|cred
operator|->
name|cr_groups
init|;
name|i
operator|<
name|cred
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
operator|,
name|gp
operator|++
control|)
if|if
condition|(
name|hp
operator|->
name|h_gid
operator|==
operator|*
name|gp
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|VEXEC
condition|)
name|mask
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|VREAD
condition|)
name|mask
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|VWRITE
condition|)
name|mask
operator||=
name|S_IWGRP
expr_stmt|;
return|return
operator|(
operator|(
name|hp
operator|->
name|h_mode
operator|&
name|mask
operator|)
operator|==
name|mask
condition|?
literal|0
else|:
name|EACCES
operator|)
return|;
block|}
comment|/* Otherwise, check everyone else. */
if|if
condition|(
name|mode
operator|&
name|VEXEC
condition|)
name|mask
operator||=
name|S_IXOTH
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|VREAD
condition|)
name|mask
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|VWRITE
condition|)
name|mask
operator||=
name|S_IWOTH
expr_stmt|;
return|return
operator|(
operator|(
name|hp
operator|->
name|h_mode
operator|&
name|mask
operator|)
operator|==
name|mask
condition|?
literal|0
else|:
name|EACCES
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open called.  *  * Nothing to do.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|hpfs_open
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_open_args
comment|/* { 		struct vnode *a_vp; 		int  a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
if|#
directive|if
name|HPFS_DEBUG
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|hpfsnode
modifier|*
name|hp
init|=
name|VTOHP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"hpfs_open(0x%x):\n"
argument_list|,
name|hp
operator|->
name|h_no
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Files marked append-only must be opened for appending. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close called.  *  * Update the times on the inode.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|hpfs_close
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_close_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
if|#
directive|if
name|HPFS_DEBUG
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|hpfsnode
modifier|*
name|hp
init|=
name|VTOHP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"hpfs_close: %d\n"
argument_list|,
name|hp
operator|->
name|h_no
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpfs_de_uiomove
parameter_list|(
name|struct
name|hpfsmount
modifier|*
name|hpmp
parameter_list|,
name|struct
name|hpfsdirent
modifier|*
name|dep
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|struct
name|dirent
name|cde
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"[no: 0x%x, size: %d, name: %2d:%.*s, flag: 0x%x] "
operator|,
name|dep
operator|->
name|de_fnode
operator|,
name|dep
operator|->
name|de_size
operator|,
name|dep
operator|->
name|de_namelen
operator|,
name|dep
operator|->
name|de_namelen
operator|,
name|dep
operator|->
name|de_name
operator|,
name|dep
operator|->
name|de_flag
operator|)
argument_list|)
expr_stmt|;
comment|/*strncpy(cde.d_name, dep->de_name, dep->de_namelen);*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dep
operator|->
name|de_namelen
condition|;
name|i
operator|++
control|)
name|cde
operator|.
name|d_name
index|[
name|i
index|]
operator|=
name|hpfs_d2u
argument_list|(
name|hpmp
argument_list|,
name|dep
operator|->
name|de_name
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cde
operator|.
name|d_name
index|[
name|dep
operator|->
name|de_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cde
operator|.
name|d_namlen
operator|=
name|dep
operator|->
name|de_namelen
expr_stmt|;
name|cde
operator|.
name|d_fileno
operator|=
name|dep
operator|->
name|de_fnode
expr_stmt|;
name|cde
operator|.
name|d_type
operator|=
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_DIR
operator|)
condition|?
name|DT_DIR
else|:
name|DT_REG
expr_stmt|;
name|cde
operator|.
name|d_reclen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cde
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dprintf
argument_list|(
operator|(
literal|"[0x%x] "
operator|,
name|uio
operator|->
name|uio_resid
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|dirent
name|hpfs_de_dot
init|=
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
block|,
name|DT_DIR
block|,
literal|1
block|,
literal|"."
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dirent
name|hpfs_de_dotdot
init|=
block|{
literal|0
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
block|,
name|DT_DIR
block|,
literal|2
block|,
literal|".."
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|hpfs_readdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 		int *a_ncookies; 		u_int **cookies; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|hpfsnode
modifier|*
name|hp
init|=
name|VTOHP
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|hpfsmount
modifier|*
name|hpmp
init|=
name|hp
operator|->
name|h_hpmp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|int
name|ncookies
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|num
decl_stmt|,
name|cnum
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|dirblk
modifier|*
name|dp
decl_stmt|;
name|struct
name|hpfsdirent
modifier|*
name|dep
decl_stmt|;
name|lsn_t
name|olsn
decl_stmt|;
name|lsn_t
name|lsn
decl_stmt|;
name|int
name|level
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_readdir(0x%x, 0x%x, 0x%x): "
operator|,
name|hp
operator|->
name|h_no
operator|,
operator|(
name|u_int32_t
operator|)
name|uio
operator|->
name|uio_offset
operator|,
name|uio
operator|->
name|uio_resid
operator|)
argument_list|)
expr_stmt|;
name|off
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|". faked, "
operator|)
argument_list|)
expr_stmt|;
name|hpfs_de_dot
operator|.
name|d_fileno
operator|=
name|hp
operator|->
name|h_no
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hpfs_de_dot
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ncookies
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|".. faked, "
operator|)
argument_list|)
expr_stmt|;
name|hpfs_de_dotdot
operator|.
name|d_fileno
operator|=
name|hp
operator|->
name|h_fn
operator|.
name|fn_parent
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hpfs_de_dotdot
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ncookies
operator|++
expr_stmt|;
block|}
name|num
operator|=
name|uio
operator|->
name|uio_offset
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
operator|-
literal|2
expr_stmt|;
name|cnum
operator|=
literal|0
expr_stmt|;
name|lsn
operator|=
operator|(
operator|(
name|alleaf_t
operator|*
operator|)
name|hp
operator|->
name|h_fn
operator|.
name|fn_abd
operator|)
operator|->
name|al_lsn
expr_stmt|;
name|olsn
operator|=
literal|0
expr_stmt|;
name|level
operator|=
literal|1
expr_stmt|;
name|dive
label|:
name|dprintf
argument_list|(
operator|(
literal|"[dive 0x%x] "
operator|,
name|lsn
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|hp
operator|->
name|h_devvp
argument_list|,
name|lsn
argument_list|,
name|D_BSIZE
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dp
operator|=
operator|(
expr|struct
name|dirblk
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_magic
operator|!=
name|D_MAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_readdir: MAGIC DOESN'T MATCH\n"
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|dep
operator|=
name|D_DIRENT
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|olsn
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"[restore 0x%x] "
operator|,
name|olsn
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_END
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_DOWN
operator|)
operator|&&
operator|(
name|olsn
operator|==
name|DE_DOWNLSN
argument_list|(
name|dep
argument_list|)
operator|)
condition|)
break|break;
name|dep
operator|=
operator|(
name|hpfsdirent_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|dep
operator|+
name|dep
operator|->
name|de_reclen
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_DOWN
operator|)
operator|&&
operator|(
name|olsn
operator|==
name|DE_DOWNLSN
argument_list|(
name|dep
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_END
condition|)
goto|goto
name|blockdone
goto|;
if|if
condition|(
operator|!
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_SPECIAL
operator|)
condition|)
block|{
if|if
condition|(
name|num
operator|<=
name|cnum
condition|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"[resid] "
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|readdone
goto|;
block|}
name|error
operator|=
name|hpfs_de_uiomove
argument_list|(
name|hpmp
argument_list|,
name|dep
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ncookies
operator|++
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"[resid] "
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|readdone
goto|;
block|}
block|}
name|cnum
operator|++
expr_stmt|;
block|}
name|dep
operator|=
operator|(
name|hpfsdirent_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|dep
operator|+
name|dep
operator|->
name|de_reclen
operator|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"hpfs_readdir: ERROR! oLSN not found\n"
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|olsn
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_END
operator|)
condition|)
block|{
if|if
condition|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_DOWN
condition|)
block|{
name|lsn
operator|=
name|DE_DOWNLSN
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
goto|goto
name|dive
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_SPECIAL
operator|)
condition|)
block|{
if|if
condition|(
name|num
operator|<=
name|cnum
condition|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"[resid] "
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|readdone
goto|;
block|}
name|error
operator|=
name|hpfs_de_uiomove
argument_list|(
name|hpmp
argument_list|,
name|dep
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ncookies
operator|++
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"[resid] "
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|readdone
goto|;
block|}
block|}
name|cnum
operator|++
expr_stmt|;
block|}
name|dep
operator|=
operator|(
name|hpfsdirent_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|dep
operator|+
name|dep
operator|->
name|de_reclen
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_DOWN
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"[enddive] "
operator|)
argument_list|)
expr_stmt|;
name|lsn
operator|=
name|DE_DOWNLSN
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|level
operator|++
expr_stmt|;
goto|goto
name|dive
goto|;
block|}
name|blockdone
label|:
name|dprintf
argument_list|(
operator|(
literal|"[EOB] "
operator|)
argument_list|)
expr_stmt|;
name|olsn
operator|=
name|lsn
expr_stmt|;
name|lsn
operator|=
name|dp
operator|->
name|d_parent
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|level
operator|--
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"[level %d] "
operator|,
name|level
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|>
literal|0
condition|)
goto|goto
name|dive
goto|;
comment|/* undive really */
if|if
condition|(
name|ap
operator|->
name|a_eofflag
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"[EOF] "
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_eofflag
operator|=
literal|1
expr_stmt|;
block|}
name|readdone
label|:
name|dprintf
argument_list|(
operator|(
literal|"[readdone]\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|ap
operator|->
name|a_ncookies
operator|!=
name|NULL
condition|)
block|{
name|struct
name|dirent
modifier|*
name|dpStart
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|u_long
modifier|*
name|cookies
decl_stmt|;
name|u_long
modifier|*
name|cookiep
decl_stmt|;
else|#
directive|else
comment|/* defined(__NetBSD__) */
name|off_t
modifier|*
name|cookies
decl_stmt|;
name|off_t
modifier|*
name|cookiep
decl_stmt|;
endif|#
directive|endif
name|dprintf
argument_list|(
operator|(
literal|"%d cookies, "
operator|,
name|ncookies
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|!=
name|UIO_SYSSPACE
operator|||
name|uio
operator|->
name|uio_iovcnt
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"hpfs_readdir: unexpected uio from NFS server"
argument_list|)
expr_stmt|;
name|dpStart
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|-
operator|(
name|uio
operator|->
name|uio_offset
operator|-
name|off
operator|)
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|MALLOC
argument_list|(
name|cookies
argument_list|,
name|u_long
operator|*
argument_list|,
name|ncookies
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* defined(__NetBSD__) */
name|MALLOC
argument_list|(
name|cookies
argument_list|,
name|off_t
operator|*
argument_list|,
name|ncookies
operator|*
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|dp
operator|=
name|dpStart
operator|,
name|cookiep
operator|=
name|cookies
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncookies
condition|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|dp
operator|+
name|dp
operator|->
name|d_reclen
operator|)
operator|,
name|i
operator|++
control|)
block|{
name|off
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
operator|*
name|cookiep
operator|++
operator|=
operator|(
name|u_int
operator|)
name|off
expr_stmt|;
block|}
operator|*
name|ap
operator|->
name|a_ncookies
operator|=
name|ncookies
expr_stmt|;
operator|*
name|ap
operator|->
name|a_cookies
operator|=
name|cookies
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hpfs_lookup
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lookup_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|dvp
init|=
name|ap
operator|->
name|a_dvp
decl_stmt|;
specifier|register
name|struct
name|hpfsnode
modifier|*
name|dhp
init|=
name|VTOHP
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|struct
name|hpfsmount
modifier|*
name|hpmp
init|=
name|dhp
operator|->
name|h_hpmp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|cnp
operator|->
name|cn_cred
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|nameiop
init|=
name|cnp
operator|->
name|cn_nameiop
decl_stmt|;
name|int
name|flags
init|=
name|cnp
operator|->
name|cn_flags
decl_stmt|;
name|int
name|lockparent
init|=
name|flags
operator|&
name|LOCKPARENT
decl_stmt|;
if|#
directive|if
name|HPFS_DEBUG
name|int
name|wantparent
init|=
name|flags
operator|&
operator|(
name|LOCKPARENT
operator||
name|WANTPARENT
operator|)
decl_stmt|;
endif|#
directive|endif
name|dprintf
argument_list|(
operator|(
literal|"hpfs_lookup(0x%x, %s, %ld, %d, %d): \n"
operator|,
name|dhp
operator|->
name|h_no
operator|,
name|cnp
operator|->
name|cn_nameptr
operator|,
name|cnp
operator|->
name|cn_namelen
operator|,
name|lockparent
operator|,
name|wantparent
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameiop
operator|!=
name|CREATE
operator|&&
name|nameiop
operator|!=
name|DELETE
operator|&&
name|nameiop
operator|!=
name|LOOKUP
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_lookup: LOOKUP, DELETE and CREATE are only supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VEXEC
argument_list|,
name|cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_namelen
operator|==
literal|1
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
literal|"."
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"hpfs_lookup(0x%x,...): . faked\n"
operator|,
name|dhp
operator|->
name|h_no
operator|)
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|dvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_namelen
operator|==
literal|2
operator|)
operator|&&
operator|!
name|strncmp
argument_list|(
name|cnp
operator|->
name|cn_nameptr
argument_list|,
literal|".."
argument_list|,
literal|2
argument_list|)
operator|&&
operator|(
name|flags
operator|&
name|ISDOTDOT
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"hpfs_lookup(0x%x,...): .. faked (0x%x)\n"
operator|,
name|dhp
operator|->
name|h_no
operator|,
name|dhp
operator|->
name|h_fn
operator|.
name|fn_parent
operator|)
argument_list|)
expr_stmt|;
name|VOP__UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_VGET
argument_list|(
name|hpmp
operator|->
name|hpm_mp
argument_list|,
name|dhp
operator|->
name|h_fn
operator|.
name|fn_parent
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP__LOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|lockparent
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|error
operator|=
name|VOP__LOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
operator|)
condition|)
block|{
name|vput
argument_list|(
operator|*
operator|(
name|ap
operator|->
name|a_vpp
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|hpfsdirent
modifier|*
name|dep
decl_stmt|;
name|struct
name|hpfsnode
modifier|*
name|hp
decl_stmt|;
name|error
operator|=
name|hpfs_genlookupbyname
argument_list|(
name|dhp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|dep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|==
name|ENOENT
operator|)
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|&&
operator|(
name|nameiop
operator|==
name|CREATE
operator|||
name|nameiop
operator|==
name|RENAME
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|lockparent
condition|)
name|VOP__UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"hpfs_lookup: fnode: 0x%x, CPID: 0x%x\n"
operator|,
name|dep
operator|->
name|de_fnode
operator|,
name|dep
operator|->
name|de_cpid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameiop
operator|==
name|DELETE
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
block|{
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VWRITE
argument_list|,
name|cred
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|dhp
operator|->
name|h_no
operator|==
name|dep
operator|->
name|de_fnode
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|dvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|VFS_VGET
argument_list|(
name|hpmp
operator|->
name|hpm_mp
argument_list|,
name|dep
operator|->
name|de_fnode
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"hpfs_lookup: VFS_VGET FAILED %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|hp
operator|=
name|VTOHP
argument_list|(
operator|*
name|ap
operator|->
name|a_vpp
argument_list|)
expr_stmt|;
name|hp
operator|->
name|h_mtime
operator|=
name|dep
operator|->
name|de_mtime
expr_stmt|;
name|hp
operator|->
name|h_ctime
operator|=
name|dep
operator|->
name|de_ctime
expr_stmt|;
name|hp
operator|->
name|h_atime
operator|=
name|dep
operator|->
name|de_atime
expr_stmt|;
name|bcopy
argument_list|(
name|dep
operator|->
name|de_name
argument_list|,
name|hp
operator|->
name|h_name
argument_list|,
name|dep
operator|->
name|de_namelen
argument_list|)
expr_stmt|;
name|hp
operator|->
name|h_name
index|[
name|dep
operator|->
name|de_namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|hp
operator|->
name|h_namelen
operator|=
name|dep
operator|->
name|de_namelen
expr_stmt|;
name|hp
operator|->
name|h_flag
operator||=
name|H_PARVALID
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lockparent
operator|||
operator|!
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
name|VOP__UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|cnp
operator|->
name|cn_proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MAKEENTRY
operator|)
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|||
operator|(
name|nameiop
operator|!=
name|DELETE
operator|&&
name|nameiop
operator|!=
name|CREATE
operator|)
operator|)
condition|)
name|cache_enter
argument_list|(
name|dvp
argument_list|,
operator|*
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hpfs_remove
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_remove_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_remove(0x%x, %s, %ld): \n"
operator|,
name|VTOHP
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|h_no
operator|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_nameptr
operator|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_namelen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|error
operator|=
name|hpfs_removefnode
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hpfs_create
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_create_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"hpfs_create(0x%x, %s, %ld): \n"
operator|,
name|VTOHP
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
operator|->
name|h_no
operator|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_nameptr
operator|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_namelen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ap
operator|->
name|a_cnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
condition|)
name|panic
argument_list|(
literal|"hpfs_create: no name\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|hpfs_makefnode
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return POSIX pathconf information applicable to NTFS filesystem  */
end_comment

begin_function
name|int
name|hpfs_pathconf
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_pathconf_args
comment|/* { 		struct vnode *a_vp; 		int a_name; 		register_t *a_retval; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
switch|switch
condition|(
name|ap
operator|->
name|a_name
condition|)
block|{
case|case
name|_PC_LINK_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_NAME_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|HPFS_MAXFILENAME
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_PATH_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|PATH_MAX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_CHOWN_RESTRICTED
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_NO_TRUNC
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
case|case
name|_PC_SYNC_IO
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_FILESIZEBITS
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|32
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Global vfs data structures  */
end_comment

begin_decl_stmt
name|vop_t
modifier|*
modifier|*
name|hpfs_vnodeop_p
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
name|struct
name|vnodeopv_entry_desc
name|hpfs_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_defaultop
block|}
block|,
block|{
operator|&
name|vop_getattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_getattr
block|}
block|,
block|{
operator|&
name|vop_setattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_setattr
block|}
block|,
block|{
operator|&
name|vop_inactive_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_inactive
block|}
block|,
block|{
operator|&
name|vop_reclaim_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_reclaim
block|}
block|,
block|{
operator|&
name|vop_print_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_print
block|}
block|,
block|{
operator|&
name|vop_create_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_create
block|}
block|,
block|{
operator|&
name|vop_remove_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_remove
block|}
block|,
block|{
operator|&
name|vop_islocked_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdislocked
block|}
block|,
block|{
operator|&
name|vop_unlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdunlock
block|}
block|,
block|{
operator|&
name|vop_lock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdlock
block|}
block|,
block|{
operator|&
name|vop_cachedlookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_lookup
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vfs_cache_lookup
block|}
block|,
block|{
operator|&
name|vop_access_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_access
block|}
block|,
block|{
operator|&
name|vop_close_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_close
block|}
block|,
block|{
operator|&
name|vop_open_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_open
block|}
block|,
block|{
operator|&
name|vop_readdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_readdir
block|}
block|,
block|{
operator|&
name|vop_fsync_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_fsync
block|}
block|,
block|{
operator|&
name|vop_bmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_bmap
block|}
block|,
block|{
operator|&
name|vop_getpages_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_getpages
block|}
block|,
block|{
operator|&
name|vop_putpages_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_putpages
block|}
block|,
block|{
operator|&
name|vop_strategy_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_strategy
block|}
block|,
block|{
operator|&
name|vop_bwrite_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdbwrite
block|}
block|,
block|{
operator|&
name|vop_read_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_read
block|}
block|,
block|{
operator|&
name|vop_write_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_write
block|}
block|,
block|{
operator|&
name|vop_ioctl_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_ioctl
block|}
block|,
block|{
operator|&
name|vop_pathconf_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_pathconf
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|hpfs_vnodeop_opv_desc
init|=
block|{
operator|&
name|hpfs_vnodeop_p
block|,
name|hpfs_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|hpfs_vnodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* defined(__NetBSD__) */
end_comment

begin_decl_stmt
name|struct
name|vnodeopv_entry_desc
name|ntfs_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|genfs_badop
block|}
block|,
comment|/* XXX */
block|{
operator|&
name|vop_lookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_lookup
block|}
block|,
comment|/* lookup */
block|{
operator|&
name|vop_create_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* create */
block|{
operator|&
name|vop_mknod_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* mknod */
block|{
operator|&
name|vop_open_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_open
block|}
block|,
comment|/* open */
block|{
operator|&
name|vop_close_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_close
block|}
block|,
comment|/* close */
block|{
operator|&
name|vop_access_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_access
block|}
block|,
comment|/* access */
block|{
operator|&
name|vop_getattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_getattr
block|}
block|,
comment|/* getattr */
block|{
operator|&
name|vop_setattr_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* setattr */
block|{
operator|&
name|vop_read_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_read
block|}
block|,
comment|/* read */
block|{
operator|&
name|vop_write_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_write
block|}
block|,
comment|/* write */
block|{
operator|&
name|vop_lease_desc
block|,
name|genfs_lease_check
block|}
block|,
comment|/* lease */
block|{
operator|&
name|vop_fcntl_desc
block|,
name|genfs_fcntl
block|}
block|,
comment|/* fcntl */
block|{
operator|&
name|vop_ioctl_desc
block|,
name|genfs_enoioctl
block|}
block|,
comment|/* ioctl */
block|{
operator|&
name|vop_poll_desc
block|,
name|genfs_poll
block|}
block|,
comment|/* poll */
block|{
operator|&
name|vop_revoke_desc
block|,
name|genfs_revoke
block|}
block|,
comment|/* revoke */
block|{
operator|&
name|vop_mmap_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* mmap */
block|{
operator|&
name|vop_fsync_desc
block|,
name|genfs_fsync
block|}
block|,
comment|/* fsync */
block|{
operator|&
name|vop_seek_desc
block|,
name|genfs_seek
block|}
block|,
comment|/* seek */
block|{
operator|&
name|vop_remove_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* remove */
block|{
operator|&
name|vop_link_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* link */
block|{
operator|&
name|vop_rename_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* rename */
block|{
operator|&
name|vop_mkdir_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* mkdir */
block|{
operator|&
name|vop_rmdir_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* rmdir */
block|{
operator|&
name|vop_symlink_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* symlink */
block|{
operator|&
name|vop_readdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_readdir
block|}
block|,
comment|/* readdir */
block|{
operator|&
name|vop_readlink_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* readlink */
block|{
operator|&
name|vop_abortop_desc
block|,
name|genfs_abortop
block|}
block|,
comment|/* abortop */
block|{
operator|&
name|vop_inactive_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_inactive
block|}
block|,
comment|/* inactive */
block|{
operator|&
name|vop_reclaim_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_reclaim
block|}
block|,
comment|/* reclaim */
block|{
operator|&
name|vop_lock_desc
block|,
name|genfs_lock
block|}
block|,
comment|/* lock */
block|{
operator|&
name|vop_unlock_desc
block|,
name|genfs_unlock
block|}
block|,
comment|/* unlock */
block|{
operator|&
name|vop_bmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_bmap
block|}
block|,
comment|/* bmap */
block|{
operator|&
name|vop_strategy_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_strategy
block|}
block|,
comment|/* strategy */
block|{
operator|&
name|vop_print_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|hpfs_print
block|}
block|,
comment|/* print */
block|{
operator|&
name|vop_islocked_desc
block|,
name|genfs_islocked
block|}
block|,
comment|/* islocked */
block|{
operator|&
name|vop_pathconf_desc
block|,
name|hpfs_pathconf
block|}
block|,
comment|/* pathconf */
block|{
operator|&
name|vop_advlock_desc
block|,
name|genfs_nullop
block|}
block|,
comment|/* advlock */
block|{
operator|&
name|vop_blkatoff_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* blkatoff */
block|{
operator|&
name|vop_valloc_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* valloc */
block|{
operator|&
name|vop_reallocblks_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* reallocblks */
block|{
operator|&
name|vop_vfree_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* vfree */
block|{
operator|&
name|vop_truncate_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* truncate */
block|{
operator|&
name|vop_update_desc
block|,
name|genfs_eopnotsupp
block|}
block|,
comment|/* update */
block|{
operator|&
name|vop_bwrite_desc
block|,
name|vn_bwrite
block|}
block|,
comment|/* bwrite */
block|{
operator|(
expr|struct
name|vnodeop_desc
operator|*
operator|)
name|NULL
block|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
operator|)
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnodeopv_desc
name|ntfs_vnodeop_opv_desc
init|=
block|{
operator|&
name|ntfs_vnodeop_p
block|,
name|ntfs_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

