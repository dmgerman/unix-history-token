begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Rick Macklem, University of Guelph  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|APPLEKEXT
end_ifndef

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_decl_stmt
name|struct
name|nfsrv_stablefirst
name|nfsrv_stablefirst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsrv_issuedelegs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsrv_dolocallocks
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfsv4lock
name|nfsv4rootfs_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|newnfs_numnfsd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsstats
name|newnfsstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_lease
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|timeval
name|nfsboottime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|u_int32_t
name|newnfs_true
decl_stmt|,
name|newnfs_false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NFSV4ROOTLOCKMUTEX
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NFSSTATESPINLOCK
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Hash and lru lists for nfs V4.  * (Some would put them in the .h file, but I don't like declaring storage  *  in a .h)  */
end_comment

begin_decl_stmt
name|struct
name|nfsclienthashhead
name|nfsclienthash
index|[
name|NFSCLIENTHASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfslockhashhead
name|nfslockhash
index|[
name|NFSLOCKHASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APPLEKEXT */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|nfsrv_openpluslock
init|=
literal|0
decl_stmt|,
name|nfsrv_delegatecnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|time_t
name|nfsrvboottime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsrv_writedelegifpos
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsrv_returnoldstateid
init|=
literal|0
decl_stmt|,
name|nfsrv_clients
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsrv_clienthighwater
init|=
name|NFSRV_CLIENTHIGHWATER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsrv_nogsscallback
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|nfsrv_dumpaclient
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|,
name|struct
name|nfsd_dumpclients
modifier|*
name|dumpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrv_freeopenowner
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|int
name|cansleep
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_freeopen
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|int
modifier|*
name|freedlockp
parameter_list|,
name|int
name|cansleep
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_freelockowner
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|int
modifier|*
name|freedlockp
parameter_list|,
name|int
name|cansleep
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_freeallnfslocks
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|int
modifier|*
name|freedlockp
parameter_list|,
name|int
name|cansleep
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrv_freenfslock
parameter_list|(
name|struct
name|nfslock
modifier|*
name|lop
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrv_freenfslockfile
parameter_list|(
name|struct
name|nfslockfile
modifier|*
name|lfp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrv_freedeleg
parameter_list|(
name|struct
name|nfsstate
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_getstate
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|struct
name|nfsstate
modifier|*
modifier|*
name|stpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrv_getowner
parameter_list|(
name|struct
name|nfsstatehead
modifier|*
name|hp
parameter_list|,
name|struct
name|nfsstate
modifier|*
name|new_stp
parameter_list|,
name|struct
name|nfsstate
modifier|*
modifier|*
name|stpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_getlockfh
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_short
name|flags
parameter_list|,
name|struct
name|nfslockfile
modifier|*
modifier|*
name|new_lfpp
parameter_list|,
name|fhandle_t
modifier|*
name|nfhp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_getlockfile
parameter_list|(
name|u_short
name|flags
parameter_list|,
name|struct
name|nfslockfile
modifier|*
modifier|*
name|new_lfpp
parameter_list|,
name|struct
name|nfslockfile
modifier|*
modifier|*
name|lfpp
parameter_list|,
name|fhandle_t
modifier|*
name|nfhp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrv_insertlock
parameter_list|(
name|struct
name|nfslock
modifier|*
name|new_lop
parameter_list|,
name|struct
name|nfslock
modifier|*
name|insert_lop
parameter_list|,
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|struct
name|nfslockfile
modifier|*
name|lfp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrv_updatelock
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|struct
name|nfslock
modifier|*
modifier|*
name|new_lopp
parameter_list|,
name|struct
name|nfslock
modifier|*
modifier|*
name|other_lopp
parameter_list|,
name|struct
name|nfslockfile
modifier|*
name|lfp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_getipnumber
parameter_list|(
name|u_char
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_checkrestart
parameter_list|(
name|nfsquad_t
name|clientid
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|int
name|specialid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_checkgrace
parameter_list|(
name|u_int32_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_docallback
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|,
name|int
name|procnum
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|int
name|trunc
parameter_list|,
name|fhandle_t
modifier|*
name|fhp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|nfsattrbit_t
modifier|*
name|attrbitp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|nfsrv_nextclientindex
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|nfsrv_nextstateindex
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrv_markstable
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_checkstable
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_clientconflict
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|,
name|int
modifier|*
name|haslockp
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_delegconflict
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|int
modifier|*
name|haslockp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|vnode_t
name|vp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_cleandeleg
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfslockfile
modifier|*
name|lfp
parameter_list|,
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|,
name|int
modifier|*
name|haslockp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_notsamecredname
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|nfsrv_leaseexpiry
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrv_delaydelegtimeout
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_checkseqid
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|u_int32_t
name|seqid
parameter_list|,
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|struct
name|nfsrvcache
modifier|*
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrv_locallocks
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfslockfile
modifier|*
name|lfp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrv_nootherstate
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Scan the client list for a match and either return the current one,  * create a new entry or return an error.  * If returning a non-error, the clp structure must either be linked into  * the client list or free'd.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_setclient
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsclient
modifier|*
modifier|*
name|new_clpp
parameter_list|,
name|nfsquad_t
modifier|*
name|clientidp
parameter_list|,
name|nfsquad_t
modifier|*
name|confirmp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclient
modifier|*
name|clp
init|=
name|NULL
decl_stmt|,
modifier|*
name|new_clp
init|=
operator|*
name|new_clpp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|,
modifier|*
name|tstp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sad
decl_stmt|,
modifier|*
name|rad
decl_stmt|;
name|int
name|zapit
init|=
literal|0
decl_stmt|,
name|gotit
decl_stmt|,
name|hasstate
init|=
literal|0
decl_stmt|,
name|igotlock
decl_stmt|;
specifier|static
name|u_int64_t
name|confirm_index
init|=
literal|0
decl_stmt|;
comment|/* 	 * Check for state resource limit exceeded. 	 */
if|if
condition|(
name|nfsrv_openpluslock
operator|>
name|NFSRV_V4STATELIMIT
condition|)
return|return
operator|(
name|NFSERR_RESOURCE
operator|)
return|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_GSS
operator|)
operator|&&
name|nfsrv_nogsscallback
condition|)
comment|/* 		 * Don't do callbacks for AUTH_GSS. 		 * (Since these aren't yet debugged, they might cause the 		 *  server to crap out, if they get past the Init call to 		 *  the client.) 		 */
name|new_clp
operator|->
name|lc_program
operator|=
literal|0
expr_stmt|;
comment|/* Lock out other nfsd threads */
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_relref
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|)
expr_stmt|;
do|do
block|{
name|igotlock
operator|=
name|nfsv4_lock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NFSV4ROOTLOCKMUTEXPTR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|igotlock
condition|)
do|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* to avoid a race with */
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* nfsrv_servertimer() */
comment|/* 	 * Search for a match in the client list. 	 */
name|gotit
operator|=
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|NFSCLIENTHASHSIZE
operator|&&
operator|!
name|gotit
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|clp
argument_list|,
argument|&nfsclienthash[i]
argument_list|,
argument|lc_hash
argument_list|)
block|{
if|if
condition|(
name|new_clp
operator|->
name|lc_idlen
operator|==
name|clp
operator|->
name|lc_idlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|new_clp
operator|->
name|lc_id
argument_list|,
name|clp
operator|->
name|lc_id
argument_list|,
name|clp
operator|->
name|lc_idlen
argument_list|)
condition|)
block|{
name|gotit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gotit
operator|||
operator|(
name|clp
operator|->
name|lc_flags
operator|&
operator|(
name|LCL_NEEDSCONFIRM
operator||
name|LCL_ADMINREVOKED
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Get rid of the old one. 		 */
if|if
condition|(
name|i
operator|!=
name|NFSCLIENTHASHSIZE
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|clp
argument_list|,
name|lc_hash
argument_list|)
expr_stmt|;
name|nfsrv_cleanclient
argument_list|(
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfsrv_freedeleglist
argument_list|(
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|)
expr_stmt|;
name|nfsrv_freedeleglist
argument_list|(
operator|&
name|clp
operator|->
name|lc_olddeleg
argument_list|)
expr_stmt|;
name|zapit
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Add it after assigning a client id to it. 		 */
name|new_clp
operator|->
name|lc_flags
operator||=
name|LCL_NEEDSCONFIRM
expr_stmt|;
name|confirmp
operator|->
name|qval
operator|=
name|new_clp
operator|->
name|lc_confirm
operator|.
name|qval
operator|=
operator|++
name|confirm_index
expr_stmt|;
name|clientidp
operator|->
name|lval
index|[
literal|0
index|]
operator|=
name|new_clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|0
index|]
operator|=
operator|(
name|u_int32_t
operator|)
name|nfsrvboottime
expr_stmt|;
name|clientidp
operator|->
name|lval
index|[
literal|1
index|]
operator|=
name|new_clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
operator|=
name|nfsrv_nextclientindex
argument_list|()
expr_stmt|;
name|new_clp
operator|->
name|lc_stateindex
operator|=
literal|0
expr_stmt|;
name|new_clp
operator|->
name|lc_statemaxindex
operator|=
literal|0
expr_stmt|;
name|new_clp
operator|->
name|lc_cbref
operator|=
literal|0
expr_stmt|;
name|new_clp
operator|->
name|lc_expiry
operator|=
name|nfsrv_leaseexpiry
argument_list|()
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|new_clp
operator|->
name|lc_open
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|new_clp
operator|->
name|lc_deleg
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|new_clp
operator|->
name|lc_olddeleg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSSTATEHASHSIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|new_clp
operator|->
name|lc_stateid
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|NFSCLIENTHASH
argument_list|(
name|new_clp
operator|->
name|lc_clientid
argument_list|)
argument_list|,
name|new_clp
argument_list|,
name|lc_hash
argument_list|)
expr_stmt|;
name|newnfsstats
operator|.
name|srvclients
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
name|nfsrv_clients
operator|++
expr_stmt|;
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
if|if
condition|(
name|zapit
condition|)
name|nfsrv_zapclient
argument_list|(
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|new_clpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now, handle the cases where the id is already issued. 	 */
if|if
condition|(
name|nfsrv_notsamecredname
argument_list|(
name|nd
argument_list|,
name|clp
argument_list|)
condition|)
block|{
comment|/* 	     * Check to see if there is expired state that should go away. 	     */
if|if
condition|(
name|clp
operator|->
name|lc_expiry
operator|<
name|NFSD_MONOSEC
operator|&&
operator|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|clp
operator|->
name|lc_open
argument_list|)
operator|||
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|)
operator|)
condition|)
block|{
name|nfsrv_cleanclient
argument_list|(
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfsrv_freedeleglist
argument_list|(
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * If there is outstanding state, then reply NFSERR_CLIDINUSE per 	     * RFC3530 Sec. 8.1.2 last para. 	     */
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|)
condition|)
block|{
name|hasstate
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|clp
operator|->
name|lc_open
argument_list|)
condition|)
block|{
name|hasstate
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|hasstate
operator|=
literal|0
expr_stmt|;
comment|/* Look for an Open on the OpenOwner */
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&clp->lc_open
argument_list|,
argument|ls_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|stp
operator|->
name|ls_open
argument_list|)
condition|)
block|{
name|hasstate
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|hasstate
condition|)
block|{
comment|/* 		 * If the uid doesn't match, return NFSERR_CLIDINUSE after 		 * filling out the correct ipaddr and portnum. 		 */
name|sad
operator|=
name|NFSSOCKADDR
argument_list|(
name|new_clp
operator|->
name|lc_req
operator|.
name|nr_nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
name|rad
operator|=
name|NFSSOCKADDR
argument_list|(
name|clp
operator|->
name|lc_req
operator|.
name|nr_nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
name|sad
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|rad
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|sad
operator|->
name|sin_port
operator|=
name|rad
operator|->
name|sin_port
expr_stmt|;
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
return|return
operator|(
name|NFSERR_CLIDINUSE
operator|)
return|;
block|}
block|}
if|if
condition|(
name|NFSBCMP
argument_list|(
name|new_clp
operator|->
name|lc_verf
argument_list|,
name|clp
operator|->
name|lc_verf
argument_list|,
name|NFSX_VERF
argument_list|)
condition|)
block|{
comment|/* 		 * If the verifier has changed, the client has rebooted 		 * and a new client id is issued. The old state info 		 * can be thrown away once the SETCLIENTID_CONFIRM occurs. 		 */
name|LIST_REMOVE
argument_list|(
name|clp
argument_list|,
name|lc_hash
argument_list|)
expr_stmt|;
name|new_clp
operator|->
name|lc_flags
operator||=
name|LCL_NEEDSCONFIRM
expr_stmt|;
name|confirmp
operator|->
name|qval
operator|=
name|new_clp
operator|->
name|lc_confirm
operator|.
name|qval
operator|=
operator|++
name|confirm_index
expr_stmt|;
name|clientidp
operator|->
name|lval
index|[
literal|0
index|]
operator|=
name|new_clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|nfsrvboottime
expr_stmt|;
name|clientidp
operator|->
name|lval
index|[
literal|1
index|]
operator|=
name|new_clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
operator|=
name|nfsrv_nextclientindex
argument_list|()
expr_stmt|;
name|new_clp
operator|->
name|lc_stateindex
operator|=
literal|0
expr_stmt|;
name|new_clp
operator|->
name|lc_statemaxindex
operator|=
literal|0
expr_stmt|;
name|new_clp
operator|->
name|lc_cbref
operator|=
literal|0
expr_stmt|;
name|new_clp
operator|->
name|lc_expiry
operator|=
name|nfsrv_leaseexpiry
argument_list|()
expr_stmt|;
comment|/* 		 * Save the state until confirmed. 		 */
name|LIST_NEWHEAD
argument_list|(
operator|&
name|new_clp
operator|->
name|lc_open
argument_list|,
operator|&
name|clp
operator|->
name|lc_open
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|tstp
argument_list|,
argument|&new_clp->lc_open
argument_list|,
argument|ls_list
argument_list|)
name|tstp
operator|->
name|ls_clp
operator|=
name|new_clp
expr_stmt|;
name|LIST_NEWHEAD
argument_list|(
operator|&
name|new_clp
operator|->
name|lc_deleg
argument_list|,
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|tstp
argument_list|,
argument|&new_clp->lc_deleg
argument_list|,
argument|ls_list
argument_list|)
name|tstp
operator|->
name|ls_clp
operator|=
name|new_clp
expr_stmt|;
name|LIST_NEWHEAD
argument_list|(
operator|&
name|new_clp
operator|->
name|lc_olddeleg
argument_list|,
operator|&
name|clp
operator|->
name|lc_olddeleg
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|tstp
argument_list|,
argument|&new_clp->lc_olddeleg
argument_list|,
argument|ls_list
argument_list|)
name|tstp
operator|->
name|ls_clp
operator|=
name|new_clp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSSTATEHASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_NEWHEAD
argument_list|(
operator|&
name|new_clp
operator|->
name|lc_stateid
index|[
name|i
index|]
argument_list|,
operator|&
name|clp
operator|->
name|lc_stateid
index|[
name|i
index|]
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|tstp
argument_list|,
argument|&new_clp->lc_stateid[i]
argument_list|,
argument|ls_list
argument_list|)
name|tstp
operator|->
name|ls_clp
operator|=
name|new_clp
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
name|NFSCLIENTHASH
argument_list|(
name|new_clp
operator|->
name|lc_clientid
argument_list|)
argument_list|,
name|new_clp
argument_list|,
name|lc_hash
argument_list|)
expr_stmt|;
name|newnfsstats
operator|.
name|srvclients
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
name|nfsrv_clients
operator|++
expr_stmt|;
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
comment|/* 		 * Must wait until any outstanding callback on the old clp 		 * completes. 		 */
while|while
condition|(
name|clp
operator|->
name|lc_cbref
condition|)
block|{
name|clp
operator|->
name|lc_flags
operator||=
name|LCL_WAKEUPWANTED
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|clp
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|,
literal|"nfsd clp"
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|nfsrv_zapclient
argument_list|(
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|new_clpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * id and verifier match, so update the net address info 	 * and get rid of any existing callback authentication 	 * handle, so a new one will be acquired. 	 */
name|LIST_REMOVE
argument_list|(
name|clp
argument_list|,
name|lc_hash
argument_list|)
expr_stmt|;
name|new_clp
operator|->
name|lc_flags
operator||=
operator|(
name|LCL_NEEDSCONFIRM
operator||
name|LCL_DONTCLEAN
operator|)
expr_stmt|;
name|new_clp
operator|->
name|lc_expiry
operator|=
name|nfsrv_leaseexpiry
argument_list|()
expr_stmt|;
name|confirmp
operator|->
name|qval
operator|=
name|new_clp
operator|->
name|lc_confirm
operator|.
name|qval
operator|=
operator|++
name|confirm_index
expr_stmt|;
name|clientidp
operator|->
name|lval
index|[
literal|0
index|]
operator|=
name|new_clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
name|clientidp
operator|->
name|lval
index|[
literal|1
index|]
operator|=
name|new_clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|new_clp
operator|->
name|lc_delegtime
operator|=
name|clp
operator|->
name|lc_delegtime
expr_stmt|;
name|new_clp
operator|->
name|lc_stateindex
operator|=
name|clp
operator|->
name|lc_stateindex
expr_stmt|;
name|new_clp
operator|->
name|lc_statemaxindex
operator|=
name|clp
operator|->
name|lc_statemaxindex
expr_stmt|;
name|new_clp
operator|->
name|lc_cbref
operator|=
literal|0
expr_stmt|;
name|LIST_NEWHEAD
argument_list|(
operator|&
name|new_clp
operator|->
name|lc_open
argument_list|,
operator|&
name|clp
operator|->
name|lc_open
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|tstp
argument_list|,
argument|&new_clp->lc_open
argument_list|,
argument|ls_list
argument_list|)
name|tstp
operator|->
name|ls_clp
operator|=
name|new_clp
expr_stmt|;
name|LIST_NEWHEAD
argument_list|(
operator|&
name|new_clp
operator|->
name|lc_deleg
argument_list|,
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|tstp
argument_list|,
argument|&new_clp->lc_deleg
argument_list|,
argument|ls_list
argument_list|)
name|tstp
operator|->
name|ls_clp
operator|=
name|new_clp
expr_stmt|;
name|LIST_NEWHEAD
argument_list|(
operator|&
name|new_clp
operator|->
name|lc_olddeleg
argument_list|,
operator|&
name|clp
operator|->
name|lc_olddeleg
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|tstp
argument_list|,
argument|&new_clp->lc_olddeleg
argument_list|,
argument|ls_list
argument_list|)
name|tstp
operator|->
name|ls_clp
operator|=
name|new_clp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSSTATEHASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_NEWHEAD
argument_list|(
operator|&
name|new_clp
operator|->
name|lc_stateid
index|[
name|i
index|]
argument_list|,
operator|&
name|clp
operator|->
name|lc_stateid
index|[
name|i
index|]
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|tstp
argument_list|,
argument|&new_clp->lc_stateid[i]
argument_list|,
argument|ls_list
argument_list|)
name|tstp
operator|->
name|ls_clp
operator|=
name|new_clp
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
name|NFSCLIENTHASH
argument_list|(
name|new_clp
operator|->
name|lc_clientid
argument_list|)
argument_list|,
name|new_clp
argument_list|,
name|lc_hash
argument_list|)
expr_stmt|;
name|newnfsstats
operator|.
name|srvclients
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
name|nfsrv_clients
operator|++
expr_stmt|;
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
comment|/* 	 * Must wait until any outstanding callback on the old clp 	 * completes. 	 */
while|while
condition|(
name|clp
operator|->
name|lc_cbref
condition|)
block|{
name|clp
operator|->
name|lc_flags
operator||=
name|LCL_WAKEUPWANTED
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|clp
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|,
literal|"nfsd clp"
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|nfsrv_zapclient
argument_list|(
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|new_clpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the client id exists and optionally confirm it.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_getclient
parameter_list|(
name|nfsquad_t
name|clientid
parameter_list|,
name|int
name|opflags
parameter_list|,
name|struct
name|nfsclient
modifier|*
modifier|*
name|clpp
parameter_list|,
name|nfsquad_t
name|confirm
parameter_list|,
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|nfsclienthashhead
modifier|*
name|hp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|igotlock
decl_stmt|,
name|doneok
decl_stmt|;
if|if
condition|(
name|clpp
condition|)
operator|*
name|clpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nfsrvboottime
operator|!=
name|clientid
operator|.
name|lval
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|NFSERR_STALECLIENTID
operator|)
return|;
comment|/* 	 * If called with opflags == CLOPS_RENEW, the State Lock is 	 * already held. Otherwise, we need to get either that or, 	 * for the case of Confirm, lock out the nfsd threads. 	 */
if|if
condition|(
name|opflags
operator|&
name|CLOPS_CONFIRM
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_relref
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|)
expr_stmt|;
do|do
block|{
name|igotlock
operator|=
name|nfsv4_lock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NFSV4ROOTLOCKMUTEXPTR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|igotlock
condition|)
do|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* to avoid a race with */
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* nfsrv_servertimer() */
block|}
elseif|else
if|if
condition|(
name|opflags
operator|!=
name|CLOPS_RENEW
condition|)
block|{
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
block|}
name|hp
operator|=
name|NFSCLIENTHASH
argument_list|(
name|clientid
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|clp
argument_list|,
argument|hp
argument_list|,
argument|lc_hash
argument_list|)
block|{
if|if
condition|(
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
operator|==
name|clientid
operator|.
name|lval
index|[
literal|1
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|clp
operator|==
name|LIST_END
argument_list|(
name|hp
argument_list|)
condition|)
block|{
if|if
condition|(
name|opflags
operator|&
name|CLOPS_CONFIRM
condition|)
name|error
operator|=
name|NFSERR_STALECLIENTID
expr_stmt|;
else|else
name|error
operator|=
name|NFSERR_EXPIRED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_ADMINREVOKED
condition|)
block|{
comment|/* 		 * If marked admin revoked, just return the error. 		 */
name|error
operator|=
name|NFSERR_ADMINREVOKED
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|opflags
operator|&
name|CLOPS_CONFIRM
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opflags
operator|!=
name|CLOPS_RENEW
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Perform any operations specified by the opflags. 	 */
if|if
condition|(
name|opflags
operator|&
name|CLOPS_CONFIRM
condition|)
block|{
if|if
condition|(
name|clp
operator|->
name|lc_confirm
operator|.
name|qval
operator|!=
name|confirm
operator|.
name|qval
condition|)
name|error
operator|=
name|NFSERR_STALECLIENTID
expr_stmt|;
elseif|else
if|if
condition|(
name|nfsrv_notsamecredname
argument_list|(
name|nd
argument_list|,
name|clp
argument_list|)
condition|)
name|error
operator|=
name|NFSERR_CLIDINUSE
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
operator|(
name|clp
operator|->
name|lc_flags
operator|&
operator|(
name|LCL_NEEDSCONFIRM
operator||
name|LCL_DONTCLEAN
operator|)
operator|)
operator|==
name|LCL_NEEDSCONFIRM
condition|)
block|{
comment|/* 			 * Hang onto the delegations (as old delegations) 			 * for an Open with CLAIM_DELEGATE_PREV unless in 			 * grace, but get rid of the rest of the state. 			 */
name|nfsrv_cleanclient
argument_list|(
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfsrv_freedeleglist
argument_list|(
operator|&
name|clp
operator|->
name|lc_olddeleg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfsrv_checkgrace
argument_list|(
literal|0
argument_list|)
condition|)
block|{
comment|/* In grace, so just delete delegations */
name|nfsrv_freedeleglist
argument_list|(
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&clp->lc_deleg
argument_list|,
argument|ls_list
argument_list|)
name|stp
operator|->
name|ls_flags
operator||=
name|NFSLCK_OLDDELEG
expr_stmt|;
name|clp
operator|->
name|lc_delegtime
operator|=
name|NFSD_MONOSEC
operator|+
name|nfsrv_lease
operator|+
name|NFSRV_LEASEDELTA
expr_stmt|;
name|LIST_NEWHEAD
argument_list|(
operator|&
name|clp
operator|->
name|lc_olddeleg
argument_list|,
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
block|}
block|}
name|clp
operator|->
name|lc_flags
operator|&=
operator|~
operator|(
name|LCL_NEEDSCONFIRM
operator||
name|LCL_DONTCLEAN
operator|)
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|lc_program
condition|)
name|clp
operator|->
name|lc_flags
operator||=
name|LCL_NEEDSCBNULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_NEEDSCONFIRM
condition|)
block|{
name|error
operator|=
name|NFSERR_EXPIRED
expr_stmt|;
block|}
comment|/* 	 * If called by the Renew Op, we must check the principal. 	 */
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|opflags
operator|&
name|CLOPS_RENEWOP
operator|)
condition|)
block|{
if|if
condition|(
name|nfsrv_notsamecredname
argument_list|(
name|nd
argument_list|,
name|clp
argument_list|)
condition|)
block|{
name|doneok
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSSTATEHASHSIZE
operator|&&
name|doneok
operator|==
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&clp->lc_stateid[i]
argument_list|,
argument|ls_hash
argument_list|)
block|{
if|if
condition|(
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_OPEN
operator|)
operator|&&
name|stp
operator|->
name|ls_uid
operator|==
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
condition|)
block|{
name|doneok
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|doneok
condition|)
name|error
operator|=
name|NFSERR_ACCES
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_CBDOWN
operator|)
condition|)
name|error
operator|=
name|NFSERR_CBPATHDOWN
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|error
operator|||
name|error
operator|==
name|NFSERR_CBPATHDOWN
operator|)
operator|&&
operator|(
name|opflags
operator|&
name|CLOPS_RENEW
operator|)
condition|)
block|{
name|clp
operator|->
name|lc_expiry
operator|=
name|nfsrv_leaseexpiry
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|opflags
operator|&
name|CLOPS_CONFIRM
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opflags
operator|!=
name|CLOPS_RENEW
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|clpp
condition|)
operator|*
name|clpp
operator|=
name|clp
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from the new nfssvc syscall to admin revoke a clientid.  * Returns 0 for success, error otherwise.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_adminrevoke
parameter_list|(
name|struct
name|nfsd_clid
modifier|*
name|revokep
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclient
modifier|*
name|clp
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|gotit
decl_stmt|,
name|igotlock
decl_stmt|;
comment|/* 	 * First, lock out the nfsd so that state won't change while the 	 * revocation record is being written to the stable storage restart 	 * file. 	 */
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_relref
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|)
expr_stmt|;
do|do
block|{
name|igotlock
operator|=
name|nfsv4_lock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NFSV4ROOTLOCKMUTEXPTR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|igotlock
condition|)
do|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* to avoid a race with */
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* nfsrv_servertimer() */
comment|/* 	 * Search for a match in the client list. 	 */
name|gotit
operator|=
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|NFSCLIENTHASHSIZE
operator|&&
operator|!
name|gotit
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|clp
argument_list|,
argument|&nfsclienthash[i]
argument_list|,
argument|lc_hash
argument_list|)
block|{
if|if
condition|(
name|revokep
operator|->
name|nclid_idlen
operator|==
name|clp
operator|->
name|lc_idlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|revokep
operator|->
name|nclid_id
argument_list|,
name|clp
operator|->
name|lc_id
argument_list|,
name|clp
operator|->
name|lc_idlen
argument_list|)
condition|)
block|{
name|gotit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|gotit
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
comment|/* 	 * Now, write out the revocation record 	 */
name|nfsrv_writestable
argument_list|(
name|clp
operator|->
name|lc_id
argument_list|,
name|clp
operator|->
name|lc_idlen
argument_list|,
name|NFSNST_REVOKE
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * and clear out the state, marking the clientid revoked. 	 */
name|clp
operator|->
name|lc_flags
operator|&=
operator|~
name|LCL_CALLBACKSON
expr_stmt|;
name|clp
operator|->
name|lc_flags
operator||=
name|LCL_ADMINREVOKED
expr_stmt|;
name|nfsrv_cleanclient
argument_list|(
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfsrv_freedeleglist
argument_list|(
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|)
expr_stmt|;
name|nfsrv_freedeleglist
argument_list|(
operator|&
name|clp
operator|->
name|lc_olddeleg
argument_list|)
expr_stmt|;
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump out stats for all clients. Called from nfssvc(2), that is used  * newnfsstats.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_dumpclients
parameter_list|(
name|struct
name|nfsd_dumpclients
modifier|*
name|dumpp
parameter_list|,
name|int
name|maxcnt
parameter_list|)
block|{
name|struct
name|nfsclient
modifier|*
name|clp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * Rattle through the client lists until done. 	 */
while|while
condition|(
name|i
operator|<
name|NFSCLIENTHASHSIZE
operator|&&
name|cnt
operator|<
name|maxcnt
condition|)
block|{
name|clp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|nfsclienthash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|clp
operator|!=
name|LIST_END
argument_list|(
operator|&
name|nfsclienthash
index|[
name|i
index|]
argument_list|)
operator|&&
name|cnt
operator|<
name|maxcnt
condition|)
block|{
name|nfsrv_dumpaclient
argument_list|(
name|clp
argument_list|,
operator|&
name|dumpp
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|clp
operator|=
name|LIST_NEXT
argument_list|(
name|clp
argument_list|,
name|lc_hash
argument_list|)
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|<
name|maxcnt
condition|)
name|dumpp
index|[
name|cnt
index|]
operator|.
name|ndcl_clid
operator|.
name|nclid_idlen
operator|=
literal|0
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump stats for a client. Must be called with the NFSSTATELOCK and spl'd.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_dumpaclient
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|,
name|struct
name|nfsd_dumpclients
modifier|*
name|dumpp
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|,
modifier|*
name|openstp
decl_stmt|,
modifier|*
name|lckownstp
decl_stmt|;
name|struct
name|nfslock
modifier|*
name|lop
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sad
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rad
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|rad6
decl_stmt|;
name|dumpp
operator|->
name|ndcl_nopenowners
operator|=
name|dumpp
operator|->
name|ndcl_nlockowners
operator|=
literal|0
expr_stmt|;
name|dumpp
operator|->
name|ndcl_nopens
operator|=
name|dumpp
operator|->
name|ndcl_nlocks
operator|=
literal|0
expr_stmt|;
name|dumpp
operator|->
name|ndcl_ndelegs
operator|=
name|dumpp
operator|->
name|ndcl_nolddelegs
operator|=
literal|0
expr_stmt|;
name|dumpp
operator|->
name|ndcl_flags
operator|=
name|clp
operator|->
name|lc_flags
expr_stmt|;
name|dumpp
operator|->
name|ndcl_clid
operator|.
name|nclid_idlen
operator|=
name|clp
operator|->
name|lc_idlen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|clp
operator|->
name|lc_id
argument_list|,
name|dumpp
operator|->
name|ndcl_clid
operator|.
name|nclid_id
argument_list|,
name|clp
operator|->
name|lc_idlen
argument_list|)
expr_stmt|;
name|sad
operator|=
name|NFSSOCKADDR
argument_list|(
name|clp
operator|->
name|lc_req
operator|.
name|nr_nam
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
expr_stmt|;
name|dumpp
operator|->
name|ndcl_addrfam
operator|=
name|sad
operator|->
name|sa_family
expr_stmt|;
if|if
condition|(
name|sad
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|rad
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sad
expr_stmt|;
name|dumpp
operator|->
name|ndcl_cbaddr
operator|.
name|sin_addr
operator|=
name|rad
operator|->
name|sin_addr
expr_stmt|;
block|}
else|else
block|{
name|rad6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sad
expr_stmt|;
name|dumpp
operator|->
name|ndcl_cbaddr
operator|.
name|sin6_addr
operator|=
name|rad6
operator|->
name|sin6_addr
expr_stmt|;
block|}
comment|/* 	 * Now, scan the state lists and total up the opens and locks. 	 */
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&clp->lc_open
argument_list|,
argument|ls_list
argument_list|)
block|{
name|dumpp
operator|->
name|ndcl_nopenowners
operator|++
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|openstp
argument_list|,
argument|&stp->ls_open
argument_list|,
argument|ls_list
argument_list|)
block|{
name|dumpp
operator|->
name|ndcl_nopens
operator|++
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lckownstp
argument_list|,
argument|&openstp->ls_open
argument_list|,
argument|ls_list
argument_list|)
block|{
name|dumpp
operator|->
name|ndcl_nlockowners
operator|++
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lop
argument_list|,
argument|&lckownstp->ls_lock
argument_list|,
argument|lo_lckowner
argument_list|)
block|{
name|dumpp
operator|->
name|ndcl_nlocks
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * and the delegation lists. 	 */
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&clp->lc_deleg
argument_list|,
argument|ls_list
argument_list|)
block|{
name|dumpp
operator|->
name|ndcl_ndelegs
operator|++
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&clp->lc_olddeleg
argument_list|,
argument|ls_list
argument_list|)
block|{
name|dumpp
operator|->
name|ndcl_nolddelegs
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump out lock stats for a file.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_dumplocks
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsd_dumplocks
modifier|*
name|ldumpp
parameter_list|,
name|int
name|maxcnt
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|;
name|struct
name|nfslock
modifier|*
name|lop
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|struct
name|nfslockfile
modifier|*
name|lfp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sad
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rad
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|rad6
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|fhandle_t
name|nfh
decl_stmt|;
name|ret
operator|=
name|nfsrv_getlockfh
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfh
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|nfsrv_getlockfile
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|lfp
argument_list|,
operator|&
name|nfh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|ldumpp
index|[
literal|0
index|]
operator|.
name|ndlck_clid
operator|.
name|nclid_idlen
operator|=
literal|0
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 	 * For each open share on file, dump it out. 	 */
name|stp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lfp
operator|->
name|lf_open
argument_list|)
expr_stmt|;
while|while
condition|(
name|stp
operator|!=
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_open
argument_list|)
operator|&&
name|cnt
operator|<
name|maxcnt
condition|)
block|{
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_flags
operator|=
name|stp
operator|->
name|ls_flags
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_stateid
operator|.
name|seqid
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_owner
operator|.
name|nclid_idlen
operator|=
name|stp
operator|->
name|ls_openowner
operator|->
name|ls_ownerlen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|stp
operator|->
name|ls_openowner
operator|->
name|ls_owner
argument_list|,
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_owner
operator|.
name|nclid_id
argument_list|,
name|stp
operator|->
name|ls_openowner
operator|->
name|ls_ownerlen
argument_list|)
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_clid
operator|.
name|nclid_idlen
operator|=
name|stp
operator|->
name|ls_clp
operator|->
name|lc_idlen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|stp
operator|->
name|ls_clp
operator|->
name|lc_id
argument_list|,
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_clid
operator|.
name|nclid_id
argument_list|,
name|stp
operator|->
name|ls_clp
operator|->
name|lc_idlen
argument_list|)
expr_stmt|;
name|sad
operator|=
name|NFSSOCKADDR
argument_list|(
name|stp
operator|->
name|ls_clp
operator|->
name|lc_req
operator|.
name|nr_nam
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_addrfam
operator|=
name|sad
operator|->
name|sa_family
expr_stmt|;
if|if
condition|(
name|sad
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|rad
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sad
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_cbaddr
operator|.
name|sin_addr
operator|=
name|rad
operator|->
name|sin_addr
expr_stmt|;
block|}
else|else
block|{
name|rad6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sad
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_cbaddr
operator|.
name|sin6_addr
operator|=
name|rad6
operator|->
name|sin6_addr
expr_stmt|;
block|}
name|stp
operator|=
name|LIST_NEXT
argument_list|(
name|stp
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
comment|/* 	 * and all locks. 	 */
name|lop
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|lop
operator|!=
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
operator|&&
name|cnt
operator|<
name|maxcnt
condition|)
block|{
name|stp
operator|=
name|lop
operator|->
name|lo_stp
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_flags
operator|=
name|lop
operator|->
name|lo_flags
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_first
operator|=
name|lop
operator|->
name|lo_first
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_end
operator|=
name|lop
operator|->
name|lo_end
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_stateid
operator|.
name|seqid
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_owner
operator|.
name|nclid_idlen
operator|=
name|stp
operator|->
name|ls_ownerlen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|stp
operator|->
name|ls_owner
argument_list|,
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_owner
operator|.
name|nclid_id
argument_list|,
name|stp
operator|->
name|ls_ownerlen
argument_list|)
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_clid
operator|.
name|nclid_idlen
operator|=
name|stp
operator|->
name|ls_clp
operator|->
name|lc_idlen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|stp
operator|->
name|ls_clp
operator|->
name|lc_id
argument_list|,
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_clid
operator|.
name|nclid_id
argument_list|,
name|stp
operator|->
name|ls_clp
operator|->
name|lc_idlen
argument_list|)
expr_stmt|;
name|sad
operator|=
name|NFSSOCKADDR
argument_list|(
name|stp
operator|->
name|ls_clp
operator|->
name|lc_req
operator|.
name|nr_nam
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_addrfam
operator|=
name|sad
operator|->
name|sa_family
expr_stmt|;
if|if
condition|(
name|sad
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|rad
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sad
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_cbaddr
operator|.
name|sin_addr
operator|=
name|rad
operator|->
name|sin_addr
expr_stmt|;
block|}
else|else
block|{
name|rad6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sad
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_cbaddr
operator|.
name|sin6_addr
operator|=
name|rad6
operator|->
name|sin6_addr
expr_stmt|;
block|}
name|lop
operator|=
name|LIST_NEXT
argument_list|(
name|lop
argument_list|,
name|lo_lckfile
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
comment|/* 	 * and the delegations. 	 */
name|stp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
expr_stmt|;
while|while
condition|(
name|stp
operator|!=
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
operator|&&
name|cnt
operator|<
name|maxcnt
condition|)
block|{
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_flags
operator|=
name|stp
operator|->
name|ls_flags
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_stateid
operator|.
name|seqid
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_owner
operator|.
name|nclid_idlen
operator|=
literal|0
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_clid
operator|.
name|nclid_idlen
operator|=
name|stp
operator|->
name|ls_clp
operator|->
name|lc_idlen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|stp
operator|->
name|ls_clp
operator|->
name|lc_id
argument_list|,
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_clid
operator|.
name|nclid_id
argument_list|,
name|stp
operator|->
name|ls_clp
operator|->
name|lc_idlen
argument_list|)
expr_stmt|;
name|sad
operator|=
name|NFSSOCKADDR
argument_list|(
name|stp
operator|->
name|ls_clp
operator|->
name|lc_req
operator|.
name|nr_nam
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_addrfam
operator|=
name|sad
operator|->
name|sa_family
expr_stmt|;
if|if
condition|(
name|sad
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|rad
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sad
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_cbaddr
operator|.
name|sin_addr
operator|=
name|rad
operator|->
name|sin_addr
expr_stmt|;
block|}
else|else
block|{
name|rad6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sad
expr_stmt|;
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_cbaddr
operator|.
name|sin6_addr
operator|=
name|rad6
operator|->
name|sin6_addr
expr_stmt|;
block|}
name|stp
operator|=
name|LIST_NEXT
argument_list|(
name|stp
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
comment|/* 	 * If list isn't full, mark end of list by setting the client name 	 * to zero length. 	 */
if|if
condition|(
name|cnt
operator|<
name|maxcnt
condition|)
name|ldumpp
index|[
name|cnt
index|]
operator|.
name|ndlck_clid
operator|.
name|nclid_idlen
operator|=
literal|0
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Server timer routine. It can scan any linked list, so long  * as it holds the spin lock and there is no exclusive lock on  * nfsv4rootfs_lock.  * Must be called by a kernel thread and not a timer interrupt,  * so that it only runs when the nfsd threads are sleeping on a  * uniprocessor and uses the State spin lock for an SMP system.  * (For OpenBSD, a kthread is ok. For FreeBSD, I think it is ok  *  to do this from a callout, since the spin locks work. For  *  Darwin, I'm not sure what will work correctly yet.)  * Should be called once per second.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_servertimer
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|nfsclient
modifier|*
name|clp
decl_stmt|,
modifier|*
name|nclp
decl_stmt|;
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|,
modifier|*
name|nstp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Make sure nfsboottime is set. This is used by V3 as well 	 * as V4. Note that nfsboottime is not nfsrvboottime, which is 	 * only used by the V4 server for leases. 	 */
if|if
condition|(
name|nfsboottime
operator|.
name|tv_sec
operator|==
literal|0
condition|)
name|NFSSETBOOTTIME
argument_list|(
name|nfsboottime
argument_list|)
expr_stmt|;
comment|/* 	 * If server hasn't started yet, just return. 	 */
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|nfsrv_stablefirst
operator|.
name|nsf_eograce
operator|==
literal|0
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|nfsrv_stablefirst
operator|.
name|nsf_flags
operator|&
name|NFSNSF_UPDATEDONE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|nfsrv_stablefirst
operator|.
name|nsf_flags
operator|&
name|NFSNSF_GRACEOVER
operator|)
operator|&&
name|NFSD_MONOSEC
operator|>
name|nfsrv_stablefirst
operator|.
name|nsf_eograce
condition|)
name|nfsrv_stablefirst
operator|.
name|nsf_flags
operator||=
operator|(
name|NFSNSF_GRACEOVER
operator||
name|NFSNSF_NEEDLOCK
operator|)
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 	 * Return now if an nfsd thread has the exclusive lock on 	 * nfsv4rootfs_lock. The dirty trick here is that we have 	 * the spin lock already and the nfsd threads do a: 	 * NFSLOCKSTATE, NFSUNLOCKSTATE after getting the exclusive 	 * lock, so they won't race with code after this check. 	 */
if|if
condition|(
name|nfsv4rootfs_lock
operator|.
name|nfslock_lock
operator|&
name|NFSV4LOCK_LOCK
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 	 * For each client... 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSCLIENTHASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|clp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|nfsclienthash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|clp
operator|!=
name|LIST_END
argument_list|(
operator|&
name|nfsclienthash
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|nclp
operator|=
name|LIST_NEXT
argument_list|(
name|clp
argument_list|,
name|lc_hash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_EXPIREIT
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|clp
operator|->
name|lc_expiry
operator|+
name|NFSRV_STALELEASE
operator|)
operator|<
name|NFSD_MONOSEC
operator|&&
operator|(
operator|(
name|LIST_EMPTY
argument_list|(
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|clp
operator|->
name|lc_open
argument_list|)
operator|)
operator|||
name|nfsrv_clients
operator|>
name|nfsrv_clienthighwater
operator|)
operator|)
operator|||
operator|(
name|clp
operator|->
name|lc_expiry
operator|+
name|NFSRV_MOULDYLEASE
operator|)
operator|<
name|NFSD_MONOSEC
operator|||
operator|(
name|clp
operator|->
name|lc_expiry
operator|<
name|NFSD_MONOSEC
operator|&&
operator|(
name|nfsrv_openpluslock
operator|*
literal|10
operator|/
literal|9
operator|)
operator|>
name|NFSRV_V4STATELIMIT
operator|)
condition|)
block|{
comment|/* 			 * Lease has expired several nfsrv_lease times ago: 			 * PLUS 			 *    - no state is associated with it 			 *    OR 			 *    - above high water mark for number of clients 			 *      (nfsrv_clienthighwater should be large enough 			 *       that this only occurs when clients fail to 			 *       use the same nfs_client_id4.id. Maybe somewhat 			 *       higher that the maximum number of clients that 			 *       will mount this server?) 			 * OR 			 * Lease has expired a very long time ago 			 * OR 			 * Lease has expired PLUS the number of opens + locks 			 * has exceeded 90% of capacity 			 * 			 * --> Mark for expiry. The actual expiry will be done 			 *     by an nfsd sometime soon. 			 */
name|clp
operator|->
name|lc_flags
operator||=
name|LCL_EXPIREIT
expr_stmt|;
name|nfsrv_stablefirst
operator|.
name|nsf_flags
operator||=
operator|(
name|NFSNSF_NEEDLOCK
operator||
name|NFSNSF_EXPIREDCLIENT
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * If there are no opens, increment no open tick cnt 			 * If time exceeds NFSNOOPEN, mark it to be thrown away 			 * otherwise, if there is an open, reset no open time 			 * Hopefully, this will avoid excessive re-creation 			 * of open owners and subsequent open confirms. 			 */
name|stp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|clp
operator|->
name|lc_open
argument_list|)
expr_stmt|;
while|while
condition|(
name|stp
operator|!=
name|LIST_END
argument_list|(
operator|&
name|clp
operator|->
name|lc_open
argument_list|)
condition|)
block|{
name|nstp
operator|=
name|LIST_NEXT
argument_list|(
name|stp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|stp
operator|->
name|ls_open
argument_list|)
condition|)
block|{
name|stp
operator|->
name|ls_noopens
operator|++
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|ls_noopens
operator|>
name|NFSNOOPEN
operator|||
operator|(
name|nfsrv_openpluslock
operator|*
literal|2
operator|)
operator|>
name|NFSRV_V4STATELIMIT
condition|)
name|nfsrv_stablefirst
operator|.
name|nsf_flags
operator||=
name|NFSNSF_NOOPENS
expr_stmt|;
block|}
else|else
block|{
name|stp
operator|->
name|ls_noopens
operator|=
literal|0
expr_stmt|;
block|}
name|stp
operator|=
name|nstp
expr_stmt|;
block|}
block|}
block|}
name|clp
operator|=
name|nclp
expr_stmt|;
block|}
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The following set of functions free up the various data structures.  */
end_comment

begin_comment
comment|/*  * Clear out all open/lock state related to this nfsclient.  * Caller must hold an exclusive lock on nfsv4rootfs_lock, so that  * there are no other active nfsd threads.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_cleanclient
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|,
modifier|*
name|nstp
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|stp
argument_list|,
argument|&clp->lc_open
argument_list|,
argument|ls_list
argument_list|,
argument|nstp
argument_list|)
block|{
name|nfsrv_freeopenowner
argument_list|(
name|stp
argument_list|,
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free a client that has been cleaned. It should also already have been  * removed from the lists.  * (Just to be safe w.r.t. newnfs_disconnect(), call this function when  *  softclock interrupts are enabled.)  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_zapclient
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
operator|(
name|clp
operator|->
name|lc_flags
operator|&
operator|(
name|LCL_GSS
operator||
name|LCL_CALLBACKSON
operator|)
operator|)
operator|==
operator|(
name|LCL_GSS
operator||
name|LCL_CALLBACKSON
operator|)
operator|&&
operator|(
name|clp
operator|->
name|lc_hand
operator|.
name|nfsh_flag
operator|&
name|NFSG_COMPLETE
operator|)
operator|&&
name|clp
operator|->
name|lc_handlelen
operator|>
literal|0
condition|)
block|{
name|clp
operator|->
name|lc_hand
operator|.
name|nfsh_flag
operator|&=
operator|~
name|NFSG_COMPLETE
expr_stmt|;
name|clp
operator|->
name|lc_hand
operator|.
name|nfsh_flag
operator||=
name|NFSG_DESTROYED
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_docallback
argument_list|(
name|clp
argument_list|,
name|NFSV4PROC_CBNULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|newnfs_disconnect
argument_list|(
operator|&
name|clp
operator|->
name|lc_req
argument_list|)
expr_stmt|;
name|NFSSOCKADDRFREE
argument_list|(
name|clp
operator|->
name|lc_req
operator|.
name|nr_nam
argument_list|)
expr_stmt|;
name|NFSFREEMUTEX
argument_list|(
operator|&
name|clp
operator|->
name|lc_req
operator|.
name|nr_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|clp
argument_list|,
name|M_NFSDCLIENT
argument_list|)
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
name|newnfsstats
operator|.
name|srvclients
operator|--
expr_stmt|;
name|nfsrv_openpluslock
operator|--
expr_stmt|;
name|nfsrv_clients
operator|--
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a list of delegation state structures.  * (This function will also free all nfslockfile structures that no  *  longer have associated state.)  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_freedeleglist
parameter_list|(
name|struct
name|nfsstatehead
modifier|*
name|sthp
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|,
modifier|*
name|nstp
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|stp
argument_list|,
argument|sthp
argument_list|,
argument|ls_list
argument_list|,
argument|nstp
argument_list|)
block|{
name|nfsrv_freedeleg
argument_list|(
name|stp
argument_list|)
expr_stmt|;
block|}
name|LIST_INIT
argument_list|(
name|sthp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free up a delegation.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_freedeleg
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|)
block|{
name|struct
name|nfslockfile
modifier|*
name|lfp
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|stp
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|stp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|stp
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
name|lfp
operator|=
name|stp
operator|->
name|ls_lfp
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_open
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
condition|)
name|nfsrv_freenfslockfile
argument_list|(
name|lfp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|stp
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
name|newnfsstats
operator|.
name|srvdelegates
operator|--
expr_stmt|;
name|nfsrv_openpluslock
operator|--
expr_stmt|;
name|nfsrv_delegatecnt
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function frees an open owner and all associated opens.  * Must be called with soft clock interrupts disabled.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_freeopenowner
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|int
name|cansleep
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|nstp
decl_stmt|,
modifier|*
name|tstp
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|stp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
comment|/* 	 * Now, free all associated opens. 	 */
name|nstp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|stp
operator|->
name|ls_open
argument_list|)
expr_stmt|;
while|while
condition|(
name|nstp
operator|!=
name|LIST_END
argument_list|(
operator|&
name|stp
operator|->
name|ls_open
argument_list|)
condition|)
block|{
name|tstp
operator|=
name|nstp
expr_stmt|;
name|nstp
operator|=
name|LIST_NEXT
argument_list|(
name|nstp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_freeopen
argument_list|(
name|tstp
argument_list|,
name|NULL
argument_list|,
name|cansleep
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stp
operator|->
name|ls_op
condition|)
name|nfsrvd_derefcache
argument_list|(
name|stp
operator|->
name|ls_op
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|stp
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
name|newnfsstats
operator|.
name|srvopenowners
operator|--
expr_stmt|;
name|nfsrv_openpluslock
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function frees an open (nfsstate open structure) with all associated  * lock_owners and locks. It also frees the nfslockfile structure iff there  * are no other opens on the file.  * Must be called with soft clock interrupts disabled.  * Returns 1 if it free'd the nfslockfile, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_freeopen
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|int
modifier|*
name|freedlockp
parameter_list|,
name|int
name|cansleep
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|nstp
decl_stmt|,
modifier|*
name|tstp
decl_stmt|;
name|struct
name|nfslockfile
modifier|*
name|lfp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|ret2
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|stp
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|stp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|stp
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
name|lfp
operator|=
name|stp
operator|->
name|ls_lfp
expr_stmt|;
comment|/* 	 * The nfslockfile is freed here if there are no locks 	 * associated with the open. 	 * If there are locks associated with the open, the 	 * nfslockfile structure can be freed via nfsrv_freelockowner(). 	 * (That is why the call must be here instead of after the loop.) 	 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_open
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
condition|)
block|{
name|nfsrv_freenfslockfile
argument_list|(
name|lfp
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Now, free all lockowners associated with this open. 	 */
name|nstp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|stp
operator|->
name|ls_open
argument_list|)
expr_stmt|;
while|while
condition|(
name|nstp
operator|!=
name|LIST_END
argument_list|(
operator|&
name|stp
operator|->
name|ls_open
argument_list|)
condition|)
block|{
name|tstp
operator|=
name|nstp
expr_stmt|;
name|nstp
operator|=
name|LIST_NEXT
argument_list|(
name|nstp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|ret2
operator|=
name|nfsrv_freelockowner
argument_list|(
name|tstp
argument_list|,
name|freedlockp
argument_list|,
name|cansleep
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
name|ret2
operator|!=
literal|0
condition|)
name|ret
operator|=
name|ret2
expr_stmt|;
block|}
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|stp
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
name|newnfsstats
operator|.
name|srvopens
operator|--
expr_stmt|;
name|nfsrv_openpluslock
operator|--
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Frees a lockowner and all associated locks.  * It also frees the nfslockfile structure, if there are no more  * references to it.  * Must be called with soft clock interrupts disabled.  * Returns 1 if it free'd the nfslockfile structure, 1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_freelockowner
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|int
modifier|*
name|freedlockp
parameter_list|,
name|int
name|cansleep
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|stp
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|stp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nfsrv_freeallnfslocks
argument_list|(
name|stp
argument_list|,
name|freedlockp
argument_list|,
name|cansleep
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|ls_op
condition|)
name|nfsrvd_derefcache
argument_list|(
name|stp
operator|->
name|ls_op
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|stp
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
name|newnfsstats
operator|.
name|srvlockowners
operator|--
expr_stmt|;
name|nfsrv_openpluslock
operator|--
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all the nfs locks on a lockowner.  * Returns 1 if it free'd the nfslockfile structure, 0 otherwise.  * If any byte range lock is free'd, *freedlockp is set to 1.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_freeallnfslocks
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|int
modifier|*
name|freedlockp
parameter_list|,
name|int
name|cansleep
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfslock
modifier|*
name|lop
decl_stmt|,
modifier|*
name|nlop
decl_stmt|;
name|struct
name|nfslockfile
modifier|*
name|lfp
init|=
name|NULL
decl_stmt|,
modifier|*
name|olfp
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|lop
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|stp
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|lop
operator|!=
name|LIST_END
argument_list|(
operator|&
name|stp
operator|->
name|ls_lock
argument_list|)
condition|)
block|{
name|nlop
operator|=
name|LIST_NEXT
argument_list|(
name|lop
argument_list|,
name|lo_lckowner
argument_list|)
expr_stmt|;
comment|/* 		 * Since locks off a lockowner are ordered by 		 * file, you should update the local locks when 		 * you hit the next file OR the end of the lock 		 * list. If there are no locks for other owners, 		 * it must be done before the lockowner is discarded. 		 * (All this only applies if cansleep == 1.) 		 */
name|olfp
operator|=
name|lfp
expr_stmt|;
name|lfp
operator|=
name|lop
operator|->
name|lo_lfp
expr_stmt|;
name|nfsrv_freenfslock
argument_list|(
name|lop
argument_list|)
expr_stmt|;
if|if
condition|(
name|freedlockp
condition|)
operator|*
name|freedlockp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_open
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
condition|)
block|{
if|if
condition|(
name|cansleep
condition|)
name|nfsrv_locallocks
argument_list|(
name|NULL
argument_list|,
name|lfp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfsrv_freenfslockfile
argument_list|(
name|lfp
argument_list|)
expr_stmt|;
comment|/* 			 * Set the pointer(s) to this lockowner NULL, 			 * to indicate it has been free'd and local 			 * locks discarded already. 			 */
if|if
condition|(
name|olfp
operator|==
name|lfp
condition|)
name|olfp
operator|=
name|NULL
expr_stmt|;
name|lfp
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cansleep
operator|&&
name|olfp
operator|!=
name|lfp
operator|&&
name|olfp
operator|!=
name|NULL
condition|)
name|nfsrv_locallocks
argument_list|(
name|NULL
argument_list|,
name|olfp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|lop
operator|=
name|nlop
expr_stmt|;
block|}
if|if
condition|(
name|cansleep
operator|&&
name|lfp
operator|!=
name|NULL
condition|)
name|nfsrv_locallocks
argument_list|(
name|NULL
argument_list|,
name|olfp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free an nfslock structure.  * Must be called with soft clock interrupts disabled.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_freenfslock
parameter_list|(
name|struct
name|nfslock
modifier|*
name|lop
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|lop
argument_list|,
name|lo_lckfile
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|lop
argument_list|,
name|lo_lckowner
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|lop
argument_list|,
name|M_NFSDLOCK
argument_list|)
expr_stmt|;
name|newnfsstats
operator|.
name|srvlocks
operator|--
expr_stmt|;
name|nfsrv_openpluslock
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function frees an nfslockfile structure.  * Must be called with soft clock interrupts disabled.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_freenfslockfile
parameter_list|(
name|struct
name|nfslockfile
modifier|*
name|lfp
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|lfp
argument_list|,
name|lf_hash
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|lfp
argument_list|,
name|M_NFSDLOCKFILE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function looks up an nfsstate structure via stateid.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_getstate
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|__unused
name|u_int32_t
name|flags
parameter_list|,
name|struct
name|nfsstate
modifier|*
modifier|*
name|stpp
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|;
name|struct
name|nfsstatehead
modifier|*
name|hp
decl_stmt|;
operator|*
name|stpp
operator|=
name|NULL
expr_stmt|;
name|hp
operator|=
name|NFSSTATEHASH
argument_list|(
name|clp
argument_list|,
operator|*
name|stateidp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|hp
argument_list|,
argument|ls_hash
argument_list|)
block|{
if|if
condition|(
operator|!
name|NFSBCMP
argument_list|(
name|stp
operator|->
name|ls_stateid
operator|.
name|other
argument_list|,
name|stateidp
operator|->
name|other
argument_list|,
name|NFSX_STATEIDOTHER
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * If no state id in list, return NFSERR_BADSTATEID. 	 */
if|if
condition|(
name|stp
operator|==
name|LIST_END
argument_list|(
name|hp
argument_list|)
condition|)
return|return
operator|(
name|NFSERR_BADSTATEID
operator|)
return|;
operator|*
name|stpp
operator|=
name|stp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function gets an nfsstate structure via owner string.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_getowner
parameter_list|(
name|struct
name|nfsstatehead
modifier|*
name|hp
parameter_list|,
name|struct
name|nfsstate
modifier|*
name|new_stp
parameter_list|,
name|struct
name|nfsstate
modifier|*
modifier|*
name|stpp
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|;
operator|*
name|stpp
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|hp
argument_list|,
argument|ls_list
argument_list|)
block|{
if|if
condition|(
name|new_stp
operator|->
name|ls_ownerlen
operator|==
name|stp
operator|->
name|ls_ownerlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|new_stp
operator|->
name|ls_owner
argument_list|,
name|stp
operator|->
name|ls_owner
argument_list|,
name|stp
operator|->
name|ls_ownerlen
argument_list|)
condition|)
block|{
operator|*
name|stpp
operator|=
name|stp
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Lock control function called to update lock status.  * Returns 0 upon success, -1 if there is no lock and the flags indicate  * that one isn't to be created and an NFSERR_xxx for other errors.  * The structures new_stp and new_lop are passed in as pointers that should  * be set to NULL if the structure is used and shouldn't be free'd.  * For the NFSLCK_TEST and NFSLCK_CHECK cases, the structures are  * never used and can safely be allocated on the stack. For all other  * cases, *new_stpp and *new_lopp should be malloc'd before the call,  * in case they are used.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_lockctrl
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsstate
modifier|*
modifier|*
name|new_stpp
parameter_list|,
name|struct
name|nfslock
modifier|*
modifier|*
name|new_lopp
parameter_list|,
name|struct
name|nfslockconflict
modifier|*
name|cfp
parameter_list|,
name|nfsquad_t
name|clientid
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|__unused
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|,
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfslock
modifier|*
name|lop
decl_stmt|;
name|struct
name|nfsstate
modifier|*
name|new_stp
init|=
operator|*
name|new_stpp
decl_stmt|;
name|struct
name|nfslock
modifier|*
name|new_lop
init|=
operator|*
name|new_lopp
decl_stmt|;
name|struct
name|nfsstate
modifier|*
name|tstp
decl_stmt|,
modifier|*
name|mystp
decl_stmt|,
modifier|*
name|nstp
decl_stmt|;
name|int
name|specialid
init|=
literal|0
decl_stmt|;
name|struct
name|nfslockfile
modifier|*
name|lfp
decl_stmt|;
name|struct
name|nfslock
modifier|*
name|other_lop
init|=
name|NULL
decl_stmt|;
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|,
modifier|*
name|lckstp
init|=
name|NULL
decl_stmt|;
name|struct
name|nfsclient
modifier|*
name|clp
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|bits
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|haslock
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|getlckret
decl_stmt|,
name|delegation
init|=
literal|0
decl_stmt|;
name|fhandle_t
name|nfh
decl_stmt|;
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_CHECK
operator||
name|NFSLCK_SETATTR
operator|)
condition|)
block|{
comment|/* 		 * Note the special cases of "all 1s" or "all 0s" stateids and 		 * let reads with all 1s go ahead. 		 */
if|if
condition|(
name|new_stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|==
literal|0x0
operator|&&
name|new_stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|==
literal|0x0
operator|&&
name|new_stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|==
literal|0x0
operator|&&
name|new_stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|==
literal|0x0
condition|)
name|specialid
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|new_stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|==
literal|0xffffffff
operator|&&
name|new_stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|==
literal|0xffffffff
operator|&&
name|new_stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|==
literal|0xffffffff
operator|&&
name|new_stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|==
literal|0xffffffff
condition|)
name|specialid
operator|=
literal|2
expr_stmt|;
block|}
comment|/* 	 * Check for restart conditions (client and server). 	 */
name|error
operator|=
name|nfsrv_checkrestart
argument_list|(
name|clientid
argument_list|,
name|new_stp
operator|->
name|ls_flags
argument_list|,
operator|&
name|new_stp
operator|->
name|ls_stateid
argument_list|,
name|specialid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Check for state resource limit exceeded. 	 */
if|if
condition|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_LOCK
operator|)
operator|&&
name|nfsrv_openpluslock
operator|>
name|NFSRV_V4STATELIMIT
condition|)
return|return
operator|(
name|NFSERR_RESOURCE
operator|)
return|;
comment|/* 	 * For Lock, check for a conflict with a lock held by 	 * a process running locally on the server now, before 	 * monkeying with nfsd state. Since the vp is locked, any 	 * other local calls are blocked during this Op. 	 */
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_LOCK
condition|)
block|{
if|if
condition|(
name|new_lop
operator|->
name|lo_flags
operator|&
name|NFSLCK_WRITE
condition|)
name|error
operator|=
name|nfsvno_localconflict
argument_list|(
name|vp
argument_list|,
name|F_WRLCK
argument_list|,
name|new_lop
operator|->
name|lo_first
argument_list|,
name|new_lop
operator|->
name|lo_end
argument_list|,
name|cfp
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nfsvno_localconflict
argument_list|(
name|vp
argument_list|,
name|F_RDLCK
argument_list|,
name|new_lop
operator|->
name|lo_first
argument_list|,
name|new_lop
operator|->
name|lo_end
argument_list|,
name|cfp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * For the lock case, get another nfslock structure, 	 * just in case we need it. 	 * Malloc now, before we start sifting through the linked lists, 	 * in case we have to wait for memory. 	 */
name|tryagain
label|:
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_LOCK
condition|)
name|MALLOC
argument_list|(
name|other_lop
argument_list|,
expr|struct
name|nfslock
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfslock
argument_list|)
argument_list|,
name|M_NFSDLOCK
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Get the lockfile structure for CFH now, so we can do a sanity 	 * check against the stateid, before incrementing the seqid#, since 	 * we want to return NFSERR_BADSTATEID on failure and the seqid# 	 * shouldn't be incremented for this case. 	 * If nfsrv_getlockfile() returns -1, it means "not found", which 	 * will be handled later. 	 */
name|getlckret
operator|=
name|nfsrv_getlockfh
argument_list|(
name|vp
argument_list|,
name|new_stp
operator|->
name|ls_flags
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfh
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|getlckret
condition|)
name|getlckret
operator|=
name|nfsrv_getlockfile
argument_list|(
name|new_stp
operator|->
name|ls_flags
argument_list|,
name|NULL
argument_list|,
operator|&
name|lfp
argument_list|,
operator|&
name|nfh
argument_list|)
expr_stmt|;
if|if
condition|(
name|getlckret
operator|!=
literal|0
operator|&&
name|getlckret
operator|!=
operator|-
literal|1
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|other_lop
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|other_lop
argument_list|,
name|M_NFSDLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|getlckret
operator|)
return|;
block|}
comment|/* 	 * Since the code is manipulating lists that are also 	 * manipulated by nfsrv_servertimer(), soft clock interrupts 	 * must be masked off. 	 */
if|if
condition|(
name|specialid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_TEST
condition|)
block|{
comment|/* 		 * RFC 3530 does not list LockT as an op that renews a 		 * lease, but the concensus seems to be that it is ok 		 * for a server to do so. 		 */
name|error
operator|=
name|nfsrv_getclient
argument_list|(
name|clientid
argument_list|,
name|CLOPS_RENEW
argument_list|,
operator|&
name|clp
argument_list|,
call|(
name|nfsquad_t
call|)
argument_list|(
operator|(
name|u_quad_t
operator|)
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * Since NFSERR_EXPIRED, NFSERR_ADMINREVOKED are not valid 		 * error returns for LockT, just go ahead and test for a lock, 		 * since there are no locks for this client, but other locks 		 * can conflict. (ie. same client will always be false) 		 */
if|if
condition|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|||
name|error
operator|==
name|NFSERR_ADMINREVOKED
condition|)
name|error
operator|=
literal|0
expr_stmt|;
name|lckstp
operator|=
name|new_stp
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfsrv_getclient
argument_list|(
name|clientid
argument_list|,
name|CLOPS_RENEW
argument_list|,
operator|&
name|clp
argument_list|,
call|(
name|nfsquad_t
call|)
argument_list|(
operator|(
name|u_quad_t
operator|)
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
comment|/* 		 * Look up the stateid 		 */
name|error
operator|=
name|nfsrv_getstate
argument_list|(
name|clp
argument_list|,
operator|&
name|new_stp
operator|->
name|ls_stateid
argument_list|,
name|new_stp
operator|->
name|ls_flags
argument_list|,
operator|&
name|stp
argument_list|)
expr_stmt|;
comment|/* 	       * do some sanity checks for an unconfirmed open or a 	       * stateid that refers to the wrong file, for an open stateid 	       */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_OPEN
operator|)
operator|&&
operator|(
operator|(
name|stp
operator|->
name|ls_openowner
operator|->
name|ls_flags
operator|&
name|NFSLCK_NEEDSCONFIRM
operator|)
operator|||
operator|(
name|getlckret
operator|!=
operator|-
literal|1
operator|&&
name|stp
operator|->
name|ls_lfp
operator|!=
name|lfp
operator|)
operator|)
condition|)
name|error
operator|=
name|NFSERR_BADSTATEID
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_DELEGREAD
operator||
name|NFSLCK_DELEGWRITE
operator|)
operator|)
operator|&&
name|getlckret
operator|!=
operator|-
literal|1
operator|&&
name|stp
operator|->
name|ls_lfp
operator|!=
name|lfp
condition|)
name|error
operator|=
name|NFSERR_BADSTATEID
expr_stmt|;
comment|/* 	       * If the lockowner stateid doesn't refer to the same file, 	       * I believe that is considered ok, since some clients will 	       * only create a single lockowner and use that for all locks 	       * on all files. 	       * For now, log it as a diagnostic, instead of considering it 	       * a BadStateid. 	       */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_OPEN
operator||
name|NFSLCK_DELEGREAD
operator||
name|NFSLCK_DELEGWRITE
operator|)
operator|)
operator|==
literal|0
operator|&&
name|getlckret
operator|!=
operator|-
literal|1
operator|&&
name|stp
operator|->
name|ls_lfp
operator|!=
name|lfp
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"Got a lock statid for different file open\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		  error = NFSERR_BADSTATEID; 		  */
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_OPENTOLOCK
condition|)
block|{
comment|/* 			 * If haslock set, we've already checked the seqid. 			 */
if|if
condition|(
operator|!
name|haslock
condition|)
block|{
if|if
condition|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_OPEN
condition|)
name|error
operator|=
name|nfsrv_checkseqid
argument_list|(
name|nd
argument_list|,
name|new_stp
operator|->
name|ls_seq
argument_list|,
name|stp
operator|->
name|ls_openowner
argument_list|,
name|new_stp
operator|->
name|ls_op
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|NFSERR_BADSTATEID
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|nfsrv_getowner
argument_list|(
operator|&
name|stp
operator|->
name|ls_open
argument_list|,
name|new_stp
argument_list|,
operator|&
name|lckstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lckstp
condition|)
comment|/* 			     * I believe this should be an error, but it 			     * isn't obvious what NFSERR_xxx would be 			     * appropriate, so I'll use NFSERR_INVAL for now. 			     */
name|error
operator|=
name|NFSERR_INVAL
expr_stmt|;
else|else
name|lckstp
operator|=
name|new_stp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_LOCK
operator||
name|NFSLCK_UNLOCK
operator|)
condition|)
block|{
comment|/* 			 * If haslock set, ditto above. 			 */
if|if
condition|(
operator|!
name|haslock
condition|)
block|{
if|if
condition|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_OPEN
condition|)
name|error
operator|=
name|NFSERR_BADSTATEID
expr_stmt|;
else|else
name|error
operator|=
name|nfsrv_checkseqid
argument_list|(
name|nd
argument_list|,
name|new_stp
operator|->
name|ls_seq
argument_list|,
name|stp
argument_list|,
name|new_stp
operator|->
name|ls_op
argument_list|)
expr_stmt|;
block|}
name|lckstp
operator|=
name|stp
expr_stmt|;
block|}
else|else
block|{
name|lckstp
operator|=
name|stp
expr_stmt|;
block|}
block|}
comment|/* 	       * If the seqid part of the stateid isn't the same, return 	       * NFSERR_OLDSTATEID for cases other than I/O Ops. 	       * For I/O Ops, only return NFSERR_OLDSTATEID if 	       * nfsrv_returnoldstateid is set. (The concensus on the email 	       * list was that most clients would prefer to not receive 	       * NFSERR_OLDSTATEID for I/O Ops, but the RFC suggests that that 	       * is what will happen, so I use the nfsrv_returnoldstateid to 	       * allow for either server configuration.) 	       */
if|if
condition|(
operator|!
name|error
operator|&&
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|!=
name|new_stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|&&
operator|(
operator|!
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_CHECK
operator|)
operator|||
name|nfsrv_returnoldstateid
operator|)
condition|)
name|error
operator|=
name|NFSERR_OLDSTATEID
expr_stmt|;
block|}
block|}
comment|/* 	 * Now we can check for grace. 	 */
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_checkgrace
argument_list|(
name|new_stp
operator|->
name|ls_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_RECLAIM
operator|)
operator|&&
operator|!
name|error
operator|&&
name|nfsrv_checkstable
argument_list|(
name|clp
argument_list|)
condition|)
name|error
operator|=
name|NFSERR_NOGRACE
expr_stmt|;
comment|/* 	 * If we successfully Reclaimed state, note that. 	 */
if|if
condition|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_RECLAIM
operator|)
operator|&&
operator|!
name|error
condition|)
name|nfsrv_markstable
argument_list|(
name|clp
argument_list|)
expr_stmt|;
comment|/* 	 * If nd_repstat is set, we can return that now, since the 	 * seqid# has been incremented. 	 */
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|other_lop
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|other_lop
argument_list|,
name|M_NFSDLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Check the nfsrv_getlockfile return. 	 * Returned -1 if no structure found. 	 */
if|if
condition|(
name|getlckret
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|NFSERR_EXPIRED
expr_stmt|;
comment|/* 		 * Called from lockt, so no lock is OK. 		 */
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_TEST
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_CHECK
operator||
name|NFSLCK_SETATTR
operator|)
condition|)
block|{
comment|/* 			 * Called to check for a lock, OK if the stateid is all 			 * 1s or all 0s, but there should be an nfsstate 			 * otherwise. 			 * (ie. If there is no open, I'll assume no share 			 *  deny bits.) 			 */
if|if
condition|(
name|specialid
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
name|error
operator|=
name|NFSERR_BADSTATEID
expr_stmt|;
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * Called to lock or unlock, so the lock has gone away. 		 */
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * For NFSLCK_CHECK and NFSLCK_LOCK, test for a share conflict. 	 * For NFSLCK_CHECK, allow a read if write access is granted, 	 * but check for a deny. For NFSLCK_LOCK, require correct access, 	 * which implies a conflicting deny can't exist. 	 */
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_CHECK
operator||
name|NFSLCK_LOCK
operator|)
condition|)
block|{
comment|/* 	     * Four kinds of state id: 	     * - specialid (all 0s or all 1s), only for NFSLCK_CHECK 	     * - stateid for an open 	     * - stateid for a delegation 	     * - stateid for a lock owner 	     */
if|if
condition|(
operator|!
name|specialid
condition|)
block|{
if|if
condition|(
name|stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_DELEGREAD
operator||
name|NFSLCK_DELEGWRITE
operator|)
condition|)
block|{
name|delegation
operator|=
literal|1
expr_stmt|;
name|mystp
operator|=
name|stp
expr_stmt|;
name|nfsrv_delaydelegtimeout
argument_list|(
name|stp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_OPEN
condition|)
block|{
name|mystp
operator|=
name|stp
expr_stmt|;
block|}
else|else
block|{
name|mystp
operator|=
name|stp
operator|->
name|ls_openstp
expr_stmt|;
block|}
comment|/* 		 * If locking or checking, require correct access 		 * bit set. 		 */
if|if
condition|(
operator|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_LOCK
operator|)
operator|&&
operator|!
operator|(
operator|(
name|new_lop
operator|->
name|lo_flags
operator|>>
name|NFSLCK_LOCKSHIFT
operator|)
operator|&
name|mystp
operator|->
name|ls_flags
operator|&
name|NFSLCK_ACCESSBITS
operator|)
operator|)
operator|||
operator|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_CHECK
operator||
name|NFSLCK_READACCESS
operator|)
operator|)
operator|==
operator|(
name|NFSLCK_CHECK
operator||
name|NFSLCK_READACCESS
operator|)
operator|&&
operator|!
operator|(
name|mystp
operator|->
name|ls_flags
operator|&
name|NFSLCK_READACCESS
operator|)
operator|)
operator|||
operator|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_CHECK
operator||
name|NFSLCK_WRITEACCESS
operator|)
operator|)
operator|==
operator|(
name|NFSLCK_CHECK
operator||
name|NFSLCK_WRITEACCESS
operator|)
operator|&&
operator|!
operator|(
name|mystp
operator|->
name|ls_flags
operator|&
name|NFSLCK_WRITEACCESS
operator|)
operator|)
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|other_lop
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|other_lop
argument_list|,
name|M_NFSDLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|NFSERR_OPENMODE
operator|)
return|;
block|}
block|}
else|else
name|mystp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_CHECK
operator|)
operator|&&
operator|!
name|delegation
condition|)
block|{
comment|/* 		 * Check for a conflicting deny bit. 		 */
name|LIST_FOREACH
argument_list|(
argument|tstp
argument_list|,
argument|&lfp->lf_open
argument_list|,
argument|ls_file
argument_list|)
block|{
if|if
condition|(
name|tstp
operator|!=
name|mystp
condition|)
block|{
name|bits
operator|=
name|tstp
operator|->
name|ls_flags
expr_stmt|;
name|bits
operator|>>=
name|NFSLCK_SHIFT
expr_stmt|;
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|bits
operator|&
name|NFSLCK_ACCESSBITS
condition|)
block|{
name|ret
operator|=
name|nfsrv_clientconflict
argument_list|(
name|tstp
operator|->
name|ls_clp
argument_list|,
operator|&
name|haslock
argument_list|,
name|vp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* 				* nfsrv_clientconflict unlocks state 				 * when it returns non-zero. 				 */
name|lckstp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|NFSERR_OPENMODE
operator|)
return|;
block|}
block|}
block|}
comment|/* We're outta here */
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * For setattr, just get rid of all the Delegations for other clients. 	 */
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_SETATTR
condition|)
block|{
name|ret
operator|=
name|nfsrv_cleandeleg
argument_list|(
name|vp
argument_list|,
name|lfp
argument_list|,
name|clp
argument_list|,
operator|&
name|haslock
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* 			 * nfsrv_cleandeleg() unlocks state when it 			 * returns non-zero. 			 */
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|lckstp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_CHECK
operator|)
operator|||
operator|(
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_open
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
operator|)
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Check for a conflicting delegation. If one is found, call 	 * nfsrv_delegconflict() to handle it. If the v4root lock hasn't 	 * been set yet, it will get the lock. Otherwise, it will recall 	 * the delegation. Then, we try try again... 	 * I currently believe the conflict algorithm to be: 	 * For Lock Ops (Lock/LockT/LockU) 	 * - there is a conflict iff a different client has a write delegation 	 * For Reading (Read Op) 	 * - there is a conflict iff a different client has a write delegation 	 *   (the specialids are always a different client) 	 * For Writing (Write/Setattr of size) 	 * - there is a conflict if a different client has any delegation 	 * - there is a conflict if the same client has a read delegation 	 *   (I don't understand why this isn't allowed, but that seems to be 	 *    the current concensus?) 	 */
name|tstp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
expr_stmt|;
while|while
condition|(
name|tstp
operator|!=
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
condition|)
block|{
name|nstp
operator|=
name|LIST_NEXT
argument_list|(
name|tstp
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_LOCK
operator||
name|NFSLCK_UNLOCK
operator||
name|NFSLCK_TEST
operator|)
operator|)
operator|||
operator|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_CHECK
operator|)
operator|&&
operator|(
name|new_lop
operator|->
name|lo_flags
operator|&
name|NFSLCK_READ
operator|)
operator|)
operator|)
operator|&&
name|clp
operator|!=
name|tstp
operator|->
name|ls_clp
operator|&&
operator|(
name|tstp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGWRITE
operator|)
operator|)
operator|||
operator|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_CHECK
operator|)
operator|&&
operator|(
name|new_lop
operator|->
name|lo_flags
operator|&
name|NFSLCK_WRITE
operator|)
operator|&&
operator|(
name|clp
operator|!=
name|tstp
operator|->
name|ls_clp
operator|||
operator|(
name|tstp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGREAD
operator|)
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|nfsrv_delegconflict
argument_list|(
name|tstp
argument_list|,
operator|&
name|haslock
argument_list|,
name|p
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* 		     * nfsrv_delegconflict unlocks state when it 		     * returns non-zero. 		     */
if|if
condition|(
name|other_lop
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|other_lop
argument_list|,
name|M_NFSDLOCK
argument_list|)
expr_stmt|;
name|other_lop
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|lckstp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
name|tstp
operator|=
name|nstp
expr_stmt|;
block|}
comment|/* 	 * Handle the unlock case by calling nfsrv_updatelock(). 	 * (Should I have done some access checking above for unlock? For now, 	 *  just let it happen.) 	 */
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_UNLOCK
condition|)
block|{
name|nfsrv_updatelock
argument_list|(
name|stp
argument_list|,
name|new_lopp
argument_list|,
operator|&
name|other_lop
argument_list|,
name|lfp
argument_list|)
expr_stmt|;
name|stateidp
operator|->
name|seqid
operator|=
operator|++
operator|(
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|)
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
comment|/* 		 * For a non-empty flp->lf_lock list, I believe 		 * nfsrv_locallocks() can safely traverse the list, including 		 * sleeping, for two reasons: 		 * 1 - The Lock/LockU/Close Ops all require a locked 		 *     vnode for the file and we currently have that. 		 * 2 - The only other thing that modifies a non-empty 		 *     list is nfsrv_cleanclient() and it is always 		 *     done with the exclusive nfsv4rootfs_lock held. 		 *     Since this Op in progress holds either a shared or 		 *     exclusive lock on nfsv4rootfs_lock, that can't 		 *     happen now. 		 * However, the structure pointed to by lfp can go 		 * in many places for an empty list, so that is handled 		 * by passing a NULL pointer to nfsrv_locallocks(). 		 * Do that check now, while we are still SMP safe. 		 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
condition|)
name|lfp
operator|=
name|NULL
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
name|nfsrv_locallocks
argument_list|(
name|vp
argument_list|,
name|lfp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Search for a conflicting lock. A lock conflicts if: 	 * - the lock range overlaps and 	 * - at least one lock is a write lock and 	 * - it is not owned by the same lock owner 	 */
if|if
condition|(
operator|!
name|delegation
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|lop
argument_list|,
argument|&lfp->lf_lock
argument_list|,
argument|lo_lckfile
argument_list|)
block|{
if|if
condition|(
name|new_lop
operator|->
name|lo_end
operator|>
name|lop
operator|->
name|lo_first
operator|&&
name|new_lop
operator|->
name|lo_first
operator|<
name|lop
operator|->
name|lo_end
operator|&&
operator|(
name|new_lop
operator|->
name|lo_flags
operator|==
name|NFSLCK_WRITE
operator|||
name|lop
operator|->
name|lo_flags
operator|==
name|NFSLCK_WRITE
operator|)
operator|&&
name|lckstp
operator|!=
name|lop
operator|->
name|lo_stp
operator|&&
operator|(
name|clp
operator|!=
name|lop
operator|->
name|lo_stp
operator|->
name|ls_clp
operator|||
name|lckstp
operator|->
name|ls_ownerlen
operator|!=
name|lop
operator|->
name|lo_stp
operator|->
name|ls_ownerlen
operator|||
name|NFSBCMP
argument_list|(
name|lckstp
operator|->
name|ls_owner
argument_list|,
name|lop
operator|->
name|lo_stp
operator|->
name|ls_owner
argument_list|,
name|lckstp
operator|->
name|ls_ownerlen
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|other_lop
condition|)
block|{
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|other_lop
argument_list|,
name|M_NFSDLOCK
argument_list|)
expr_stmt|;
name|other_lop
operator|=
name|NULL
expr_stmt|;
block|}
name|ret
operator|=
name|nfsrv_clientconflict
argument_list|(
name|lop
operator|->
name|lo_stp
operator|->
name|ls_clp
argument_list|,
operator|&
name|haslock
argument_list|,
name|vp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* 		     * nfsrv_clientconflict() unlocks state when it 		     * returns non-zero. 		     */
name|lckstp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
comment|/* 		 * Found a conflicting lock, so record the conflict and 		 * return the error. 		 */
if|if
condition|(
name|cfp
condition|)
block|{
name|cfp
operator|->
name|cl_clientid
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|lop
operator|->
name|lo_stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
name|cfp
operator|->
name|cl_clientid
operator|.
name|lval
index|[
literal|1
index|]
operator|=
name|lop
operator|->
name|lo_stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
name|cfp
operator|->
name|cl_first
operator|=
name|lop
operator|->
name|lo_first
expr_stmt|;
name|cfp
operator|->
name|cl_end
operator|=
name|lop
operator|->
name|lo_end
expr_stmt|;
name|cfp
operator|->
name|cl_flags
operator|=
name|lop
operator|->
name|lo_flags
expr_stmt|;
name|cfp
operator|->
name|cl_ownerlen
operator|=
name|lop
operator|->
name|lo_stp
operator|->
name|ls_ownerlen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|lop
operator|->
name|lo_stp
operator|->
name|ls_owner
argument_list|,
name|cfp
operator|->
name|cl_owner
argument_list|,
name|cfp
operator|->
name|cl_ownerlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_RECLAIM
condition|)
name|error
operator|=
name|NFSERR_RECLAIMCONFLICT
expr_stmt|;
elseif|else
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_CHECK
condition|)
name|error
operator|=
name|NFSERR_LOCKED
expr_stmt|;
else|else
name|error
operator|=
name|NFSERR_DENIED
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * We only get here if there was no lock that conflicted. 	 */
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_TEST
operator||
name|NFSLCK_CHECK
operator|)
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We only get here when we are creating or modifying a lock. 	 * There are two variants: 	 * - exist_lock_owner where lock_owner exists 	 * - open_to_lock_owner with new lock_owner 	 */
if|if
condition|(
operator|!
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_OPENTOLOCK
operator|)
condition|)
block|{
name|nfsrv_updatelock
argument_list|(
name|lckstp
argument_list|,
name|new_lopp
argument_list|,
operator|&
name|other_lop
argument_list|,
name|lfp
argument_list|)
expr_stmt|;
name|stateidp
operator|->
name|seqid
operator|=
operator|++
operator|(
name|lckstp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|)
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|lckstp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|lckstp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|lckstp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The new open_to_lock_owner case. 		 * Link the new nfsstate into the lists. 		 */
name|new_stp
operator|->
name|ls_seq
operator|=
name|new_stp
operator|->
name|ls_opentolockseq
expr_stmt|;
name|nfsrvd_refcache
argument_list|(
name|new_stp
operator|->
name|ls_op
argument_list|)
expr_stmt|;
name|stateidp
operator|->
name|seqid
operator|=
name|new_stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|=
literal|0
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|new_stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|new_stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|new_stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|nfsrv_nextstateindex
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|new_stp
operator|->
name|ls_clp
operator|=
name|clp
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|new_stp
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
name|new_stp
operator|->
name|ls_openstp
operator|=
name|stp
expr_stmt|;
name|new_stp
operator|->
name|ls_lfp
operator|=
name|lfp
expr_stmt|;
name|nfsrv_insertlock
argument_list|(
name|new_lop
argument_list|,
operator|(
expr|struct
name|nfslock
operator|*
operator|)
name|new_stp
argument_list|,
name|new_stp
argument_list|,
name|lfp
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|NFSSTATEHASH
argument_list|(
name|clp
argument_list|,
name|new_stp
operator|->
name|ls_stateid
argument_list|)
argument_list|,
name|new_stp
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|stp
operator|->
name|ls_open
argument_list|,
name|new_stp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
operator|*
name|new_lopp
operator|=
name|NULL
expr_stmt|;
operator|*
name|new_stpp
operator|=
name|NULL
expr_stmt|;
name|newnfsstats
operator|.
name|srvlockowners
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
block|}
comment|/* See comment above, w.r.t. nfsrv_locallocks(). */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
condition|)
name|lfp
operator|=
name|NULL
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
name|nfsrv_locallocks
argument_list|(
name|vp
argument_list|,
name|lfp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|other_lop
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|other_lop
argument_list|,
name|M_NFSDLOCK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for state errors for Open.  * repstat is passed back out as an error if more critical errors  * are not detected.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_opencheck
parameter_list|(
name|nfsquad_t
name|clientid
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|struct
name|nfsstate
modifier|*
name|new_stp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|int
name|repstat
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|,
modifier|*
name|nstp
decl_stmt|;
name|struct
name|nfsclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsstate
modifier|*
name|ownerstp
decl_stmt|;
name|struct
name|nfslockfile
modifier|*
name|lfp
decl_stmt|,
modifier|*
name|new_lfp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|haslock
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|,
name|readonly
init|=
literal|0
decl_stmt|,
name|getfhret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_SHAREBITS
operator|)
operator|==
name|NFSLCK_READACCESS
condition|)
name|readonly
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Check for restart conditions (client and server). 	 */
name|error
operator|=
name|nfsrv_checkrestart
argument_list|(
name|clientid
argument_list|,
name|new_stp
operator|->
name|ls_flags
argument_list|,
operator|&
name|new_stp
operator|->
name|ls_stateid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Check for state resource limit exceeded. 	 * Technically this should be SMP protected, but the worst 	 * case error is "out by one or two" on the count when it 	 * returns NFSERR_RESOURCE and the limit is just a rather 	 * arbitrary high water mark, so no harm is done. 	 */
if|if
condition|(
name|nfsrv_openpluslock
operator|>
name|NFSRV_V4STATELIMIT
condition|)
return|return
operator|(
name|NFSERR_RESOURCE
operator|)
return|;
name|tryagain
label|:
name|MALLOC
argument_list|(
name|new_lfp
argument_list|,
expr|struct
name|nfslockfile
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfslockfile
argument_list|)
argument_list|,
name|M_NFSDLOCKFILE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
condition|)
name|getfhret
operator|=
name|nfsrv_getlockfh
argument_list|(
name|vp
argument_list|,
name|new_stp
operator|->
name|ls_flags
argument_list|,
operator|&
name|new_lfp
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * Get the nfsclient structure. 	 * Since the code is manipulating lists that are also 	 * manipulated by nfsrv_servertimer(), soft clock interrupts 	 * must be masked off. 	 */
name|error
operator|=
name|nfsrv_getclient
argument_list|(
name|clientid
argument_list|,
name|CLOPS_RENEW
argument_list|,
operator|&
name|clp
argument_list|,
call|(
name|nfsquad_t
call|)
argument_list|(
operator|(
name|u_quad_t
operator|)
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Look up the open owner. See if it needs confirmation and 	 * check the seq#, as required. 	 */
if|if
condition|(
operator|!
name|error
condition|)
name|nfsrv_getowner
argument_list|(
operator|&
name|clp
operator|->
name|lc_open
argument_list|,
name|new_stp
argument_list|,
operator|&
name|ownerstp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|ownerstp
condition|)
block|{
name|error
operator|=
name|nfsrv_checkseqid
argument_list|(
name|nd
argument_list|,
name|new_stp
operator|->
name|ls_seq
argument_list|,
name|ownerstp
argument_list|,
name|new_stp
operator|->
name|ls_op
argument_list|)
expr_stmt|;
comment|/* 		 * If the OpenOwner hasn't been confirmed, assume the 		 * old one was a replay and this one is ok. 		 * See: RFC3530 Sec. 14.2.18. 		 */
if|if
condition|(
name|error
operator|==
name|NFSERR_BADSEQID
operator|&&
operator|(
name|ownerstp
operator|->
name|ls_flags
operator|&
name|NFSLCK_NEEDSCONFIRM
operator|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Check for grace. 	 */
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_checkgrace
argument_list|(
name|new_stp
operator|->
name|ls_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_RECLAIM
operator|)
operator|&&
operator|!
name|error
operator|&&
name|nfsrv_checkstable
argument_list|(
name|clp
argument_list|)
condition|)
name|error
operator|=
name|NFSERR_NOGRACE
expr_stmt|;
comment|/* 	 * If none of the above errors occurred, let repstat be 	 * returned. 	 */
if|if
condition|(
name|repstat
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|repstat
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_lfp
argument_list|,
name|M_NFSDLOCKFILE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If vp == NULL, the file doesn't exist yet, so return ok. 	 * (This always happens on the first pass, so haslock must be 0.) 	 */
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_lfp
argument_list|,
name|M_NFSDLOCKFILE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Get the structure for the underlying file. 	 */
if|if
condition|(
name|getfhret
condition|)
name|error
operator|=
name|getfhret
expr_stmt|;
else|else
name|error
operator|=
name|nfsrv_getlockfile
argument_list|(
name|new_stp
operator|->
name|ls_flags
argument_list|,
operator|&
name|new_lfp
argument_list|,
operator|&
name|lfp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_lfp
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_lfp
argument_list|,
name|M_NFSDLOCKFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Search for a conflicting open/share. 	 */
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGCUR
condition|)
block|{
comment|/* 	     * For Delegate_Cur, search for the matching Delegation, 	     * which indicates no conflict. 	     * An old delegation should have been recovered by the 	     * client doing a Claim_DELEGATE_Prev, so I won't let 	     * it match and return NFSERR_EXPIRED. Should I let it 	     * match? 	     */
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&lfp->lf_deleg
argument_list|,
argument|ls_file
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_OLDDELEG
operator|)
operator|&&
name|stateidp
operator|->
name|seqid
operator|==
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|stateidp
operator|->
name|other
argument_list|,
name|stp
operator|->
name|ls_stateid
operator|.
name|other
argument_list|,
name|NFSX_STATEIDOTHER
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|stp
operator|==
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
operator|||
operator|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_WRITEACCESS
operator|)
operator|&&
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGREAD
operator|)
operator|)
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|NFSERR_EXPIRED
operator|)
return|;
block|}
block|}
comment|/* 	 * Check for access/deny bit conflicts. I check for the same 	 * owner as well, in case the client didn't bother. 	 */
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&lfp->lf_open
argument_list|,
argument|ls_file
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGCUR
operator|)
operator|&&
operator|(
operator|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_ACCESSBITS
operator|)
operator|&
operator|(
operator|(
name|stp
operator|->
name|ls_flags
operator|>>
name|NFSLCK_SHIFT
operator|)
operator|&
name|NFSLCK_ACCESSBITS
operator|)
operator|)
operator|||
operator|(
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_ACCESSBITS
operator|)
operator|&
operator|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|>>
name|NFSLCK_SHIFT
operator|)
operator|&
name|NFSLCK_ACCESSBITS
operator|)
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|nfsrv_clientconflict
argument_list|(
name|stp
operator|->
name|ls_clp
argument_list|,
operator|&
name|haslock
argument_list|,
name|vp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* 				 * nfsrv_clientconflict() unlocks 				 * state when it returns non-zero. 				 */
goto|goto
name|tryagain
goto|;
block|}
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_RECLAIM
condition|)
name|error
operator|=
name|NFSERR_RECLAIMCONFLICT
expr_stmt|;
else|else
name|error
operator|=
name|NFSERR_SHAREDENIED
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Check for a conflicting delegation. If one is found, call 	 * nfsrv_delegconflict() to handle it. If the v4root lock hasn't 	 * been set yet, it will get the lock. Otherwise, it will recall 	 * the delegation. Then, we try try again... 	 * (If NFSLCK_DELEGCUR is set, it has a delegation, so there 	 *  isn't a conflict.) 	 * I currently believe the conflict algorithm to be: 	 * For Open with Read Access and Deny None 	 * - there is a conflict iff a different client has a write delegation 	 * For Open with other Write Access or any Deny except None 	 * - there is a conflict if a different client has any delegation 	 * - there is a conflict if the same client has a read delegation 	 *   (The current concensus is that this last case should be 	 *    considered a conflict since the client with a read delegation 	 *    could have done an Open with ReadAccess and WriteDeny 	 *    locally and then not have checked for the WriteDeny.) 	 * Don't check for a Reclaim, since that will be dealt with 	 * by nfsrv_openctrl(). 	 */
if|if
condition|(
operator|!
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_DELEGPREV
operator||
name|NFSLCK_DELEGCUR
operator||
name|NFSLCK_RECLAIM
operator|)
operator|)
condition|)
block|{
name|stp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
expr_stmt|;
while|while
condition|(
name|stp
operator|!=
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
condition|)
block|{
name|nstp
operator|=
name|LIST_NEXT
argument_list|(
name|stp
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|readonly
operator|&&
name|stp
operator|->
name|ls_clp
operator|!=
name|clp
operator|&&
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGWRITE
operator|)
operator|)
operator|||
operator|(
operator|!
name|readonly
operator|&&
operator|(
name|stp
operator|->
name|ls_clp
operator|!=
name|clp
operator|||
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGREAD
operator|)
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|nfsrv_delegconflict
argument_list|(
name|stp
argument_list|,
operator|&
name|haslock
argument_list|,
name|p
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* 			     * nfsrv_delegconflict() unlocks state 			     * when it returns non-zero. 			     */
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
goto|goto
name|tryagain
goto|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
name|stp
operator|=
name|nstp
expr_stmt|;
block|}
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open control function to create/update open state for an open.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_openctrl
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsstate
modifier|*
modifier|*
name|new_stpp
parameter_list|,
name|nfsquad_t
name|clientid
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|delegstateidp
parameter_list|,
name|u_int32_t
modifier|*
name|rflagsp
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|u_quad_t
name|filerev
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|new_stp
init|=
operator|*
name|new_stpp
decl_stmt|;
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|,
modifier|*
name|nstp
decl_stmt|;
name|struct
name|nfsstate
modifier|*
name|openstp
init|=
name|NULL
decl_stmt|,
modifier|*
name|new_open
decl_stmt|,
modifier|*
name|ownerstp
decl_stmt|,
modifier|*
name|new_deleg
decl_stmt|;
name|struct
name|nfslockfile
modifier|*
name|lfp
decl_stmt|,
modifier|*
name|new_lfp
decl_stmt|;
name|struct
name|nfsclient
modifier|*
name|clp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|haslock
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|,
name|delegate
init|=
literal|1
decl_stmt|,
name|writedeleg
init|=
literal|1
decl_stmt|;
name|int
name|readonly
init|=
literal|0
decl_stmt|,
name|cbret
init|=
literal|1
decl_stmt|,
name|getfhret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_SHAREBITS
operator|)
operator|==
name|NFSLCK_READACCESS
condition|)
name|readonly
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Check for restart conditions (client and server). 	 * (Paranoia, should have been detected by nfsrv_opencheck().) 	 * If an error does show up, return NFSERR_EXPIRED, since the 	 * the seqid# has already been incremented. 	 */
name|error
operator|=
name|nfsrv_checkrestart
argument_list|(
name|clientid
argument_list|,
name|new_stp
operator|->
name|ls_flags
argument_list|,
operator|&
name|new_stp
operator|->
name|ls_stateid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"Nfsd: openctrl unexpected restart err=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NFSERR_EXPIRED
operator|)
return|;
block|}
name|tryagain
label|:
name|MALLOC
argument_list|(
name|new_lfp
argument_list|,
expr|struct
name|nfslockfile
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfslockfile
argument_list|)
argument_list|,
name|M_NFSDLOCKFILE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|new_open
argument_list|,
expr|struct
name|nfsstate
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsstate
argument_list|)
argument_list|,
name|M_NFSDSTATE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|new_deleg
argument_list|,
expr|struct
name|nfsstate
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsstate
argument_list|)
argument_list|,
name|M_NFSDSTATE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|getfhret
operator|=
name|nfsrv_getlockfh
argument_list|(
name|vp
argument_list|,
name|new_stp
operator|->
name|ls_flags
argument_list|,
operator|&
name|new_lfp
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * Get the client structure. Since the linked lists could be changed 	 * by other nfsd processes if this process does a tsleep(), one of 	 * two things must be done. 	 * 1 - don't tsleep() 	 * or 	 * 2 - get the nfsv4_lock() { indicated by haslock == 1 } 	 *     before using the lists, since this lock stops the other 	 *     nfsd. This should only be used for rare cases, since it 	 *     essentially single threads the nfsd. 	 *     At this time, it is only done for cases where the stable 	 *     storage file must be written prior to completion of state 	 *     expiration. 	 */
name|error
operator|=
name|nfsrv_getclient
argument_list|(
name|clientid
argument_list|,
name|CLOPS_RENEW
argument_list|,
operator|&
name|clp
argument_list|,
call|(
name|nfsquad_t
call|)
argument_list|(
operator|(
name|u_quad_t
operator|)
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_NEEDSCBNULL
operator|)
operator|&&
name|clp
operator|->
name|lc_program
condition|)
block|{
comment|/* 		 * This happens on the first open for a client 		 * that supports callbacks. 		 */
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* 		 * Although nfsrv_docallback() will sleep, clp won't 		 * go away, since they are only removed when the 		 * nfsv4_lock() has blocked the nfsd threads. The 		 * fields in clp can change, but having multiple 		 * threads do this Null callback RPC should be 		 * harmless. 		 */
name|cbret
operator|=
name|nfsrv_docallback
argument_list|(
name|clp
argument_list|,
name|NFSV4PROC_CBNULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
name|clp
operator|->
name|lc_flags
operator|&=
operator|~
name|LCL_NEEDSCBNULL
expr_stmt|;
if|if
condition|(
operator|!
name|cbret
condition|)
name|clp
operator|->
name|lc_flags
operator||=
name|LCL_CALLBACKSON
expr_stmt|;
block|}
comment|/* 	 * Look up the open owner. See if it needs confirmation and 	 * check the seq#, as required. 	 */
if|if
condition|(
operator|!
name|error
condition|)
name|nfsrv_getowner
argument_list|(
operator|&
name|clp
operator|->
name|lc_open
argument_list|,
name|new_stp
argument_list|,
operator|&
name|ownerstp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Nfsd: openctrl unexpected state err=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_lfp
argument_list|,
name|M_NFSDLOCKFILE
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_open
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_deleg
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|NFSERR_EXPIRED
operator|)
return|;
block|}
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_RECLAIM
condition|)
name|nfsrv_markstable
argument_list|(
name|clp
argument_list|)
expr_stmt|;
comment|/* 	 * Get the structure for the underlying file. 	 */
if|if
condition|(
name|getfhret
condition|)
name|error
operator|=
name|getfhret
expr_stmt|;
else|else
name|error
operator|=
name|nfsrv_getlockfile
argument_list|(
name|new_stp
operator|->
name|ls_flags
argument_list|,
operator|&
name|new_lfp
argument_list|,
operator|&
name|lfp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_lfp
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_lfp
argument_list|,
name|M_NFSDLOCKFILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Nfsd openctrl unexpected getlockfile err=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_open
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_deleg
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Search for a conflicting open/share. 	 */
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGCUR
condition|)
block|{
comment|/* 	     * For Delegate_Cur, search for the matching Delegation, 	     * which indicates no conflict. 	     * An old delegation should have been recovered by the 	     * client doing a Claim_DELEGATE_Prev, so I won't let 	     * it match and return NFSERR_EXPIRED. Should I let it 	     * match? 	     */
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&lfp->lf_deleg
argument_list|,
argument|ls_file
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_OLDDELEG
operator|)
operator|&&
name|stateidp
operator|->
name|seqid
operator|==
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|stateidp
operator|->
name|other
argument_list|,
name|stp
operator|->
name|ls_stateid
operator|.
name|other
argument_list|,
name|NFSX_STATEIDOTHER
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|stp
operator|==
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
operator|||
operator|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_WRITEACCESS
operator|)
operator|&&
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGREAD
operator|)
operator|)
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Nfsd openctrl unexpected expiry\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_open
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_deleg
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|NFSERR_EXPIRED
operator|)
return|;
block|}
comment|/* 	     * Don't issue a Delegation, since one already exists and 	     * delay delegation timeout, as required. 	     */
name|delegate
operator|=
literal|0
expr_stmt|;
name|nfsrv_delaydelegtimeout
argument_list|(
name|stp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for access/deny bit conflicts. I also check for the 	 * same owner, since the client might not have bothered to check. 	 * Also, note an open for the same file and owner, if found, 	 * which is all we do here for Delegate_Cur, since conflict 	 * checking is already done. 	 */
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&lfp->lf_open
argument_list|,
argument|ls_file
argument_list|)
block|{
if|if
condition|(
name|ownerstp
operator|&&
name|stp
operator|->
name|ls_openowner
operator|==
name|ownerstp
condition|)
name|openstp
operator|=
name|stp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGCUR
operator|)
condition|)
block|{
comment|/* 		     * If another client has the file open, the only 		     * delegation that can be issued is a Read delegation 		     * and only if it is a Read open with Deny none. 		     */
if|if
condition|(
name|clp
operator|!=
name|stp
operator|->
name|ls_clp
condition|)
block|{
if|if
condition|(
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_SHAREBITS
operator|)
operator|==
name|NFSLCK_READACCESS
condition|)
name|writedeleg
operator|=
literal|0
expr_stmt|;
else|else
name|delegate
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_ACCESSBITS
operator|)
operator|&
operator|(
operator|(
name|stp
operator|->
name|ls_flags
operator|>>
name|NFSLCK_SHIFT
operator|)
operator|&
name|NFSLCK_ACCESSBITS
operator|)
operator|)
operator|||
operator|(
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_ACCESSBITS
operator|)
operator|&
operator|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|>>
name|NFSLCK_SHIFT
operator|)
operator|&
name|NFSLCK_ACCESSBITS
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|nfsrv_clientconflict
argument_list|(
name|stp
operator|->
name|ls_clp
argument_list|,
operator|&
name|haslock
argument_list|,
name|vp
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* 				 * nfsrv_clientconflict() unlocks state 				 * when it returns non-zero. 				 */
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_open
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_deleg
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
name|openstp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_RECLAIM
condition|)
name|error
operator|=
name|NFSERR_RECLAIMCONFLICT
expr_stmt|;
else|else
name|error
operator|=
name|NFSERR_SHAREDENIED
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_open
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_deleg
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"nfsd openctrl unexpected client cnfl\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * Check for a conflicting delegation. If one is found, call 	 * nfsrv_delegconflict() to handle it. If the v4root lock hasn't 	 * been set yet, it will get the lock. Otherwise, it will recall 	 * the delegation. Then, we try try again... 	 * (If NFSLCK_DELEGCUR is set, it has a delegation, so there 	 *  isn't a conflict.) 	 * I currently believe the conflict algorithm to be: 	 * For Open with Read Access and Deny None 	 * - there is a conflict iff a different client has a write delegation 	 * For Open with other Write Access or any Deny except None 	 * - there is a conflict if a different client has any delegation 	 * - there is a conflict if the same client has a read delegation 	 *   (The current concensus is that this last case should be 	 *    considered a conflict since the client with a read delegation 	 *    could have done an Open with ReadAccess and WriteDeny 	 *    locally and then not have checked for the WriteDeny.) 	 */
if|if
condition|(
operator|!
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_DELEGPREV
operator||
name|NFSLCK_DELEGCUR
operator|)
operator|)
condition|)
block|{
name|stp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
expr_stmt|;
while|while
condition|(
name|stp
operator|!=
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
condition|)
block|{
name|nstp
operator|=
name|LIST_NEXT
argument_list|(
name|stp
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|ls_clp
operator|!=
name|clp
operator|&&
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGREAD
operator|)
condition|)
name|writedeleg
operator|=
literal|0
expr_stmt|;
else|else
name|delegate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|readonly
operator|&&
name|stp
operator|->
name|ls_clp
operator|!=
name|clp
operator|&&
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGWRITE
operator|)
operator|)
operator|||
operator|(
operator|!
name|readonly
operator|&&
operator|(
name|stp
operator|->
name|ls_clp
operator|!=
name|clp
operator|||
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGREAD
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_RECLAIM
condition|)
block|{
name|delegate
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|nfsrv_delegconflict
argument_list|(
name|stp
argument_list|,
operator|&
name|haslock
argument_list|,
name|p
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* 			     * nfsrv_delegconflict() unlocks state 			     * when it returns non-zero. 			     */
name|printf
argument_list|(
literal|"Nfsd openctrl unexpected deleg cnfl\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_open
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_deleg
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|openstp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
name|stp
operator|=
name|nstp
expr_stmt|;
block|}
block|}
comment|/* 	 * We only get here if there was no open that conflicted. 	 * If an open for the owner exists, or in the access/deny bits. 	 * Otherwise it is a new open. If the open_owner hasn't been 	 * confirmed, replace the open with the new one needing confirmation, 	 * otherwise add the open. 	 */
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGPREV
condition|)
block|{
comment|/* 	     * Handle NFSLCK_DELEGPREV by searching the old delegations for 	     * a match. If found, just move the old delegation to the current 	     * delegation list and issue open. If not found, return 	     * NFSERR_EXPIRED. 	     */
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&clp->lc_olddeleg
argument_list|,
argument|ls_list
argument_list|)
block|{
if|if
condition|(
name|stp
operator|->
name|ls_lfp
operator|==
name|lfp
condition|)
block|{
comment|/* Found it */
if|if
condition|(
name|stp
operator|->
name|ls_clp
operator|!=
name|clp
condition|)
name|panic
argument_list|(
literal|"olddeleg clp"
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|stp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|stp
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
name|stp
operator|->
name|ls_flags
operator|&=
operator|~
name|NFSLCK_OLDDELEG
expr_stmt|;
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|=
name|delegstateidp
operator|->
name|seqid
operator|=
literal|0
expr_stmt|;
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|delegstateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|delegstateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|delegstateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|nfsrv_nextstateindex
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|stp
operator|->
name|ls_compref
operator|=
name|nd
operator|->
name|nd_compref
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|,
name|stp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|NFSSTATEHASH
argument_list|(
name|clp
argument_list|,
name|stp
operator|->
name|ls_stateid
argument_list|)
argument_list|,
name|stp
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGWRITE
condition|)
operator|*
name|rflagsp
operator||=
name|NFSV4OPEN_WRITEDELEGATE
expr_stmt|;
else|else
operator|*
name|rflagsp
operator||=
name|NFSV4OPEN_READDELEGATE
expr_stmt|;
name|clp
operator|->
name|lc_delegtime
operator|=
name|NFSD_MONOSEC
operator|+
name|nfsrv_lease
operator|+
name|NFSRV_LEASEDELTA
expr_stmt|;
comment|/* 		     * Now, do the associated open. 		     */
name|new_open
operator|->
name|ls_stateid
operator|.
name|seqid
operator|=
literal|0
expr_stmt|;
name|new_open
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
name|new_open
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|new_open
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|nfsrv_nextstateindex
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|new_open
operator|->
name|ls_flags
operator|=
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DENYBITS
operator|)
operator||
name|NFSLCK_OPEN
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGWRITE
condition|)
name|new_open
operator|->
name|ls_flags
operator||=
operator|(
name|NFSLCK_READACCESS
operator||
name|NFSLCK_WRITEACCESS
operator|)
expr_stmt|;
else|else
name|new_open
operator|->
name|ls_flags
operator||=
name|NFSLCK_READACCESS
expr_stmt|;
name|new_open
operator|->
name|ls_uid
operator|=
name|new_stp
operator|->
name|ls_uid
expr_stmt|;
name|new_open
operator|->
name|ls_lfp
operator|=
name|lfp
expr_stmt|;
name|new_open
operator|->
name|ls_clp
operator|=
name|clp
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|new_open
operator|->
name|ls_open
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lfp
operator|->
name|lf_open
argument_list|,
name|new_open
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|NFSSTATEHASH
argument_list|(
name|clp
argument_list|,
name|new_open
operator|->
name|ls_stateid
argument_list|)
argument_list|,
name|new_open
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
comment|/* 		     * and handle the open owner 		     */
if|if
condition|(
name|ownerstp
condition|)
block|{
name|new_open
operator|->
name|ls_openowner
operator|=
name|ownerstp
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ownerstp
operator|->
name|ls_open
argument_list|,
name|new_open
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_open
operator|->
name|ls_openowner
operator|=
name|new_stp
expr_stmt|;
name|new_stp
operator|->
name|ls_flags
operator|=
literal|0
expr_stmt|;
name|nfsrvd_refcache
argument_list|(
name|new_stp
operator|->
name|ls_op
argument_list|)
expr_stmt|;
name|new_stp
operator|->
name|ls_noopens
operator|=
literal|0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|new_stp
operator|->
name|ls_open
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|new_stp
operator|->
name|ls_open
argument_list|,
name|new_open
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|clp
operator|->
name|lc_open
argument_list|,
name|new_stp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
operator|*
name|new_stpp
operator|=
name|NULL
expr_stmt|;
name|newnfsstats
operator|.
name|srvopenowners
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
block|}
name|openstp
operator|=
name|new_open
expr_stmt|;
name|new_open
operator|=
name|NULL
expr_stmt|;
name|newnfsstats
operator|.
name|srvopens
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stp
operator|==
name|LIST_END
argument_list|(
operator|&
name|clp
operator|->
name|lc_olddeleg
argument_list|)
condition|)
name|error
operator|=
name|NFSERR_EXPIRED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
operator|(
name|NFSLCK_DELEGREAD
operator||
name|NFSLCK_DELEGWRITE
operator|)
condition|)
block|{
comment|/* 	     * Scan to see that no delegation for this client and file 	     * doesn't already exist. 	     * There also shouldn't yet be an Open for this file and 	     * openowner. 	     */
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&lfp->lf_deleg
argument_list|,
argument|ls_file
argument_list|)
block|{
if|if
condition|(
name|stp
operator|->
name|ls_clp
operator|==
name|clp
condition|)
break|break;
block|}
if|if
condition|(
name|stp
operator|==
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
operator|&&
name|openstp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This is the Claim_Previous case with a delegation 		 * type != Delegate_None. 		 */
comment|/* 		 * First, add the delegation. (Although we must issue the 		 * delegation, we can also ask for an immediate return.) 		 */
name|new_deleg
operator|->
name|ls_stateid
operator|.
name|seqid
operator|=
name|delegstateidp
operator|->
name|seqid
operator|=
literal|0
expr_stmt|;
name|new_deleg
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|delegstateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
name|new_deleg
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|delegstateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|new_deleg
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|delegstateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|nfsrv_nextstateindex
argument_list|(
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGWRITE
condition|)
block|{
name|new_deleg
operator|->
name|ls_flags
operator|=
operator|(
name|NFSLCK_DELEGWRITE
operator||
name|NFSLCK_READACCESS
operator||
name|NFSLCK_WRITEACCESS
operator|)
expr_stmt|;
operator|*
name|rflagsp
operator||=
name|NFSV4OPEN_WRITEDELEGATE
expr_stmt|;
block|}
else|else
block|{
name|new_deleg
operator|->
name|ls_flags
operator|=
operator|(
name|NFSLCK_DELEGREAD
operator||
name|NFSLCK_READACCESS
operator|)
expr_stmt|;
operator|*
name|rflagsp
operator||=
name|NFSV4OPEN_READDELEGATE
expr_stmt|;
block|}
name|new_deleg
operator|->
name|ls_uid
operator|=
name|new_stp
operator|->
name|ls_uid
expr_stmt|;
name|new_deleg
operator|->
name|ls_lfp
operator|=
name|lfp
expr_stmt|;
name|new_deleg
operator|->
name|ls_clp
operator|=
name|clp
expr_stmt|;
name|new_deleg
operator|->
name|ls_filerev
operator|=
name|filerev
expr_stmt|;
name|new_deleg
operator|->
name|ls_compref
operator|=
name|nd
operator|->
name|nd_compref
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|,
name|new_deleg
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|NFSSTATEHASH
argument_list|(
name|clp
argument_list|,
name|new_deleg
operator|->
name|ls_stateid
argument_list|)
argument_list|,
name|new_deleg
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|,
name|new_deleg
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|new_deleg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|delegate
operator|==
literal|2
operator|||
name|nfsrv_issuedelegs
operator|==
literal|0
operator|||
operator|(
name|clp
operator|->
name|lc_flags
operator|&
operator|(
name|LCL_CALLBACKSON
operator||
name|LCL_CBDOWN
operator|)
operator|)
operator|!=
name|LCL_CALLBACKSON
operator|||
name|NFSRV_V4DELEGLIMIT
argument_list|(
name|nfsrv_delegatecnt
argument_list|)
operator|||
operator|!
name|NFSVNO_DELEGOK
argument_list|(
name|vp
argument_list|)
condition|)
operator|*
name|rflagsp
operator||=
name|NFSV4OPEN_RECALL
expr_stmt|;
name|newnfsstats
operator|.
name|srvdelegates
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
name|nfsrv_delegatecnt
operator|++
expr_stmt|;
comment|/* 		 * Now, do the associated open. 		 */
name|new_open
operator|->
name|ls_stateid
operator|.
name|seqid
operator|=
literal|0
expr_stmt|;
name|new_open
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
name|new_open
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|new_open
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|nfsrv_nextstateindex
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|new_open
operator|->
name|ls_flags
operator|=
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DENYBITS
operator|)
operator||
name|NFSLCK_OPEN
expr_stmt|;
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGWRITE
condition|)
name|new_open
operator|->
name|ls_flags
operator||=
operator|(
name|NFSLCK_READACCESS
operator||
name|NFSLCK_WRITEACCESS
operator|)
expr_stmt|;
else|else
name|new_open
operator|->
name|ls_flags
operator||=
name|NFSLCK_READACCESS
expr_stmt|;
name|new_open
operator|->
name|ls_uid
operator|=
name|new_stp
operator|->
name|ls_uid
expr_stmt|;
name|new_open
operator|->
name|ls_lfp
operator|=
name|lfp
expr_stmt|;
name|new_open
operator|->
name|ls_clp
operator|=
name|clp
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|new_open
operator|->
name|ls_open
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lfp
operator|->
name|lf_open
argument_list|,
name|new_open
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|NFSSTATEHASH
argument_list|(
name|clp
argument_list|,
name|new_open
operator|->
name|ls_stateid
argument_list|)
argument_list|,
name|new_open
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
comment|/* 		 * and handle the open owner 		 */
if|if
condition|(
name|ownerstp
condition|)
block|{
name|new_open
operator|->
name|ls_openowner
operator|=
name|ownerstp
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ownerstp
operator|->
name|ls_open
argument_list|,
name|new_open
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_open
operator|->
name|ls_openowner
operator|=
name|new_stp
expr_stmt|;
name|new_stp
operator|->
name|ls_flags
operator|=
literal|0
expr_stmt|;
name|nfsrvd_refcache
argument_list|(
name|new_stp
operator|->
name|ls_op
argument_list|)
expr_stmt|;
name|new_stp
operator|->
name|ls_noopens
operator|=
literal|0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|new_stp
operator|->
name|ls_open
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|new_stp
operator|->
name|ls_open
argument_list|,
name|new_open
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|clp
operator|->
name|lc_open
argument_list|,
name|new_stp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
operator|*
name|new_stpp
operator|=
name|NULL
expr_stmt|;
name|newnfsstats
operator|.
name|srvopenowners
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
block|}
name|openstp
operator|=
name|new_open
expr_stmt|;
name|new_open
operator|=
name|NULL
expr_stmt|;
name|newnfsstats
operator|.
name|srvopens
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|NFSERR_RECLAIMCONFLICT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ownerstp
condition|)
block|{
if|if
condition|(
name|ownerstp
operator|->
name|ls_flags
operator|&
name|NFSLCK_NEEDSCONFIRM
condition|)
block|{
comment|/* Replace the open */
if|if
condition|(
name|ownerstp
operator|->
name|ls_op
condition|)
name|nfsrvd_derefcache
argument_list|(
name|ownerstp
operator|->
name|ls_op
argument_list|)
expr_stmt|;
name|ownerstp
operator|->
name|ls_op
operator|=
name|new_stp
operator|->
name|ls_op
expr_stmt|;
name|nfsrvd_refcache
argument_list|(
name|ownerstp
operator|->
name|ls_op
argument_list|)
expr_stmt|;
name|ownerstp
operator|->
name|ls_seq
operator|=
name|new_stp
operator|->
name|ls_seq
expr_stmt|;
operator|*
name|rflagsp
operator||=
name|NFSV4OPEN_RESULTCONFIRM
expr_stmt|;
name|stp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ownerstp
operator|->
name|ls_open
argument_list|)
expr_stmt|;
name|stp
operator|->
name|ls_flags
operator|=
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_SHAREBITS
operator|)
operator||
name|NFSLCK_OPEN
expr_stmt|;
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|=
literal|0
expr_stmt|;
name|stp
operator|->
name|ls_uid
operator|=
name|new_stp
operator|->
name|ls_uid
expr_stmt|;
if|if
condition|(
name|lfp
operator|!=
name|stp
operator|->
name|ls_lfp
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|stp
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lfp
operator|->
name|lf_open
argument_list|,
name|stp
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
name|stp
operator|->
name|ls_lfp
operator|=
name|lfp
expr_stmt|;
block|}
name|openstp
operator|=
name|stp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|openstp
condition|)
block|{
name|openstp
operator|->
name|ls_flags
operator||=
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_SHAREBITS
operator|)
expr_stmt|;
name|openstp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|++
expr_stmt|;
comment|/* 		     * This is where we can choose to issue a delegation. 		     */
if|if
condition|(
name|delegate
operator|&&
name|nfsrv_issuedelegs
operator|&&
name|writedeleg
operator|&&
operator|!
name|NFSVNO_EXRDONLY
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
name|nfsrv_writedelegifpos
operator|||
operator|!
name|readonly
operator|)
operator|&&
operator|(
name|clp
operator|->
name|lc_flags
operator|&
operator|(
name|LCL_CALLBACKSON
operator||
name|LCL_CBDOWN
operator|)
operator|)
operator|==
name|LCL_CALLBACKSON
operator|&&
operator|!
name|NFSRV_V4DELEGLIMIT
argument_list|(
name|nfsrv_delegatecnt
argument_list|)
operator|&&
name|NFSVNO_DELEGOK
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|new_deleg
operator|->
name|ls_stateid
operator|.
name|seqid
operator|=
name|delegstateidp
operator|->
name|seqid
operator|=
literal|0
expr_stmt|;
name|new_deleg
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|delegstateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
name|new_deleg
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|delegstateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|new_deleg
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|delegstateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|nfsrv_nextstateindex
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|new_deleg
operator|->
name|ls_flags
operator|=
operator|(
name|NFSLCK_DELEGWRITE
operator||
name|NFSLCK_READACCESS
operator||
name|NFSLCK_WRITEACCESS
operator|)
expr_stmt|;
operator|*
name|rflagsp
operator||=
name|NFSV4OPEN_WRITEDELEGATE
expr_stmt|;
name|new_deleg
operator|->
name|ls_uid
operator|=
name|new_stp
operator|->
name|ls_uid
expr_stmt|;
name|new_deleg
operator|->
name|ls_lfp
operator|=
name|lfp
expr_stmt|;
name|new_deleg
operator|->
name|ls_clp
operator|=
name|clp
expr_stmt|;
name|new_deleg
operator|->
name|ls_filerev
operator|=
name|filerev
expr_stmt|;
name|new_deleg
operator|->
name|ls_compref
operator|=
name|nd
operator|->
name|nd_compref
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|,
name|new_deleg
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|NFSSTATEHASH
argument_list|(
name|clp
argument_list|,
name|new_deleg
operator|->
name|ls_stateid
argument_list|)
argument_list|,
name|new_deleg
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|,
name|new_deleg
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|new_deleg
operator|=
name|NULL
expr_stmt|;
name|newnfsstats
operator|.
name|srvdelegates
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
name|nfsrv_delegatecnt
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|new_open
operator|->
name|ls_stateid
operator|.
name|seqid
operator|=
literal|0
expr_stmt|;
name|new_open
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
name|new_open
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|new_open
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|nfsrv_nextstateindex
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|new_open
operator|->
name|ls_flags
operator|=
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_SHAREBITS
operator|)
operator||
name|NFSLCK_OPEN
expr_stmt|;
name|new_open
operator|->
name|ls_uid
operator|=
name|new_stp
operator|->
name|ls_uid
expr_stmt|;
name|new_open
operator|->
name|ls_openowner
operator|=
name|ownerstp
expr_stmt|;
name|new_open
operator|->
name|ls_lfp
operator|=
name|lfp
expr_stmt|;
name|new_open
operator|->
name|ls_clp
operator|=
name|clp
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|new_open
operator|->
name|ls_open
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lfp
operator|->
name|lf_open
argument_list|,
name|new_open
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ownerstp
operator|->
name|ls_open
argument_list|,
name|new_open
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|NFSSTATEHASH
argument_list|(
name|clp
argument_list|,
name|new_open
operator|->
name|ls_stateid
argument_list|)
argument_list|,
name|new_open
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
name|openstp
operator|=
name|new_open
expr_stmt|;
name|new_open
operator|=
name|NULL
expr_stmt|;
name|newnfsstats
operator|.
name|srvopens
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
comment|/* 		     * This is where we can choose to issue a delegation. 		     */
if|if
condition|(
name|delegate
operator|&&
name|nfsrv_issuedelegs
operator|&&
operator|(
name|writedeleg
operator|||
name|readonly
operator|)
operator|&&
operator|(
name|clp
operator|->
name|lc_flags
operator|&
operator|(
name|LCL_CALLBACKSON
operator||
name|LCL_CBDOWN
operator|)
operator|)
operator|==
name|LCL_CALLBACKSON
operator|&&
operator|!
name|NFSRV_V4DELEGLIMIT
argument_list|(
name|nfsrv_delegatecnt
argument_list|)
operator|&&
name|NFSVNO_DELEGOK
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|new_deleg
operator|->
name|ls_stateid
operator|.
name|seqid
operator|=
name|delegstateidp
operator|->
name|seqid
operator|=
literal|0
expr_stmt|;
name|new_deleg
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|delegstateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
name|new_deleg
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|delegstateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|new_deleg
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|delegstateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|nfsrv_nextstateindex
argument_list|(
name|clp
argument_list|)
expr_stmt|;
if|if
condition|(
name|writedeleg
operator|&&
operator|!
name|NFSVNO_EXRDONLY
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
name|nfsrv_writedelegifpos
operator|||
operator|!
name|readonly
operator|)
condition|)
block|{
name|new_deleg
operator|->
name|ls_flags
operator|=
operator|(
name|NFSLCK_DELEGWRITE
operator||
name|NFSLCK_READACCESS
operator||
name|NFSLCK_WRITEACCESS
operator|)
expr_stmt|;
operator|*
name|rflagsp
operator||=
name|NFSV4OPEN_WRITEDELEGATE
expr_stmt|;
block|}
else|else
block|{
name|new_deleg
operator|->
name|ls_flags
operator|=
operator|(
name|NFSLCK_DELEGREAD
operator||
name|NFSLCK_READACCESS
operator|)
expr_stmt|;
operator|*
name|rflagsp
operator||=
name|NFSV4OPEN_READDELEGATE
expr_stmt|;
block|}
name|new_deleg
operator|->
name|ls_uid
operator|=
name|new_stp
operator|->
name|ls_uid
expr_stmt|;
name|new_deleg
operator|->
name|ls_lfp
operator|=
name|lfp
expr_stmt|;
name|new_deleg
operator|->
name|ls_clp
operator|=
name|clp
expr_stmt|;
name|new_deleg
operator|->
name|ls_filerev
operator|=
name|filerev
expr_stmt|;
name|new_deleg
operator|->
name|ls_compref
operator|=
name|nd
operator|->
name|nd_compref
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|,
name|new_deleg
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|NFSSTATEHASH
argument_list|(
name|clp
argument_list|,
name|new_deleg
operator|->
name|ls_stateid
argument_list|)
argument_list|,
name|new_deleg
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|,
name|new_deleg
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|new_deleg
operator|=
name|NULL
expr_stmt|;
name|newnfsstats
operator|.
name|srvdelegates
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
name|nfsrv_delegatecnt
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * New owner case. Start the open_owner sequence with a 		 * Needs confirmation (unless a reclaim) and hang the 		 * new open off it. 		 */
name|new_open
operator|->
name|ls_stateid
operator|.
name|seqid
operator|=
literal|0
expr_stmt|;
name|new_open
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|0
index|]
expr_stmt|;
name|new_open
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|clp
operator|->
name|lc_clientid
operator|.
name|lval
index|[
literal|1
index|]
expr_stmt|;
name|new_open
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|nfsrv_nextstateindex
argument_list|(
name|clp
argument_list|)
expr_stmt|;
name|new_open
operator|->
name|ls_flags
operator|=
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_SHAREBITS
operator|)
operator||
name|NFSLCK_OPEN
expr_stmt|;
name|new_open
operator|->
name|ls_uid
operator|=
name|new_stp
operator|->
name|ls_uid
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|new_open
operator|->
name|ls_open
argument_list|)
expr_stmt|;
name|new_open
operator|->
name|ls_openowner
operator|=
name|new_stp
expr_stmt|;
name|new_open
operator|->
name|ls_lfp
operator|=
name|lfp
expr_stmt|;
name|new_open
operator|->
name|ls_clp
operator|=
name|clp
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lfp
operator|->
name|lf_open
argument_list|,
name|new_open
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_RECLAIM
condition|)
block|{
name|new_stp
operator|->
name|ls_flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|rflagsp
operator||=
name|NFSV4OPEN_RESULTCONFIRM
expr_stmt|;
name|new_stp
operator|->
name|ls_flags
operator|=
name|NFSLCK_NEEDSCONFIRM
expr_stmt|;
block|}
name|nfsrvd_refcache
argument_list|(
name|new_stp
operator|->
name|ls_op
argument_list|)
expr_stmt|;
name|new_stp
operator|->
name|ls_noopens
operator|=
literal|0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|new_stp
operator|->
name|ls_open
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|new_stp
operator|->
name|ls_open
argument_list|,
name|new_open
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|clp
operator|->
name|lc_open
argument_list|,
name|new_stp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|NFSSTATEHASH
argument_list|(
name|clp
argument_list|,
name|new_open
operator|->
name|ls_stateid
argument_list|)
argument_list|,
name|new_open
argument_list|,
name|ls_hash
argument_list|)
expr_stmt|;
name|openstp
operator|=
name|new_open
expr_stmt|;
name|new_open
operator|=
name|NULL
expr_stmt|;
operator|*
name|new_stpp
operator|=
name|NULL
expr_stmt|;
name|newnfsstats
operator|.
name|srvopens
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
name|newnfsstats
operator|.
name|srvopenowners
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|stateidp
operator|->
name|seqid
operator|=
name|openstp
operator|->
name|ls_stateid
operator|.
name|seqid
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|openstp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|openstp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|openstp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|new_open
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_open
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_deleg
condition|)
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|new_deleg
argument_list|,
name|M_NFSDSTATE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open update. Does the confirm, downgrade and close.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_openupdate
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsstate
modifier|*
name|new_stp
parameter_list|,
name|nfsquad_t
name|clientid
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|,
modifier|*
name|ownerstp
decl_stmt|;
name|struct
name|nfsclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfslockfile
modifier|*
name|lfp
decl_stmt|;
name|u_int32_t
name|bits
decl_stmt|;
name|int
name|error
decl_stmt|,
name|gotstate
init|=
literal|0
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|,
name|freedlock
decl_stmt|;
name|u_char
name|client
index|[
name|NFSV4_OPAQUELIMIT
index|]
decl_stmt|;
comment|/* 	 * Check for restart conditions (client and server). 	 */
name|error
operator|=
name|nfsrv_checkrestart
argument_list|(
name|clientid
argument_list|,
name|new_stp
operator|->
name|ls_flags
argument_list|,
operator|&
name|new_stp
operator|->
name|ls_stateid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * Get the open structure via clientid and stateid. 	 */
name|error
operator|=
name|nfsrv_getclient
argument_list|(
name|clientid
argument_list|,
name|CLOPS_RENEW
argument_list|,
operator|&
name|clp
argument_list|,
call|(
name|nfsquad_t
call|)
argument_list|(
operator|(
name|u_quad_t
operator|)
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_getstate
argument_list|(
name|clp
argument_list|,
operator|&
name|new_stp
operator|->
name|ls_stateid
argument_list|,
name|new_stp
operator|->
name|ls_flags
argument_list|,
operator|&
name|stp
argument_list|)
expr_stmt|;
comment|/* 	 * Sanity check the open. 	 */
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
operator|!
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_OPEN
operator|)
operator|||
operator|(
operator|!
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_CONFIRM
operator|)
operator|&&
operator|(
name|stp
operator|->
name|ls_openowner
operator|->
name|ls_flags
operator|&
name|NFSLCK_NEEDSCONFIRM
operator|)
operator|)
operator|||
operator|(
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_CONFIRM
operator|)
operator|&&
operator|(
operator|!
operator|(
name|stp
operator|->
name|ls_openowner
operator|->
name|ls_flags
operator|&
name|NFSLCK_NEEDSCONFIRM
operator|)
operator|)
operator|)
operator|)
condition|)
name|error
operator|=
name|NFSERR_BADSTATEID
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_checkseqid
argument_list|(
name|nd
argument_list|,
name|new_stp
operator|->
name|ls_seq
argument_list|,
name|stp
operator|->
name|ls_openowner
argument_list|,
name|new_stp
operator|->
name|ls_op
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|!=
name|new_stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|&&
operator|!
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_CONFIRM
operator|)
condition|)
name|error
operator|=
name|NFSERR_OLDSTATEID
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|!=
name|VREG
condition|)
block|{
if|if
condition|(
name|vnode_vtype
argument_list|(
name|vp
argument_list|)
operator|==
name|VDIR
condition|)
name|error
operator|=
name|NFSERR_ISDIR
expr_stmt|;
else|else
name|error
operator|=
name|NFSERR_INVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * If a client tries to confirm an Open with a bad 		 * seqid# and there are no byte range locks or other Opens 		 * on the openowner, just throw it away, so the next use of the 		 * openowner will start a fresh seq#. 		 */
if|if
condition|(
name|error
operator|==
name|NFSERR_BADSEQID
operator|&&
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_CONFIRM
operator|)
operator|&&
name|nfsrv_nootherstate
argument_list|(
name|stp
argument_list|)
condition|)
name|nfsrv_freeopenowner
argument_list|(
name|stp
operator|->
name|ls_openowner
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Set the return stateid. 	 */
name|stateidp
operator|->
name|seqid
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|+
literal|1
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
expr_stmt|;
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
comment|/* 	 * Now, handle the three cases. 	 */
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_CONFIRM
condition|)
block|{
comment|/* 		 * If the open doesn't need confirmation, it seems to me that 		 * there is a client error, but I'll just log it and keep going? 		 */
if|if
condition|(
operator|!
operator|(
name|stp
operator|->
name|ls_openowner
operator|->
name|ls_flags
operator|&
name|NFSLCK_NEEDSCONFIRM
operator|)
condition|)
name|printf
argument_list|(
literal|"Nfsv4d: stray open confirm\n"
argument_list|)
expr_stmt|;
name|stp
operator|->
name|ls_openowner
operator|->
name|ls_flags
operator|=
literal|0
expr_stmt|;
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_STAMPEDSTABLE
operator|)
condition|)
block|{
name|clp
operator|->
name|lc_flags
operator||=
name|LCL_STAMPEDSTABLE
expr_stmt|;
name|len
operator|=
name|clp
operator|->
name|lc_idlen
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|clp
operator|->
name|lc_id
argument_list|,
name|client
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|gotstate
operator|=
literal|1
expr_stmt|;
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_CLOSE
condition|)
block|{
name|ownerstp
operator|=
name|stp
operator|->
name|ls_openowner
expr_stmt|;
name|lfp
operator|=
name|stp
operator|->
name|ls_lfp
expr_stmt|;
name|freedlock
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|nfsrv_freeopen
argument_list|(
name|stp
argument_list|,
operator|&
name|freedlock
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* See comment on nfsrv_lockctrl() w.r.t. locallocks. */
if|if
condition|(
name|ret
condition|)
block|{
name|lfp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
condition|)
name|lfp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * For now, I won't do this. The openowner should be 		 * free'd in NFSNOOPEN seconds and it will be deref'd then. 		if (LIST_EMPTY(&ownerstp->ls_open)&& ownerstp->ls_op) { 			nfsrvd_derefcache(ownerstp->ls_op); 			ownerstp->ls_op = NULL; 		} 		 */
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|freedlock
operator|&&
name|lfp
operator|!=
name|NULL
condition|)
name|nfsrv_locallocks
argument_list|(
name|vp
argument_list|,
name|lfp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Update the share bits, making sure that the new set are a 		 * subset of the old ones. 		 */
name|bits
operator|=
operator|(
name|new_stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_SHAREBITS
operator|)
expr_stmt|;
if|if
condition|(
operator|~
operator|(
name|stp
operator|->
name|ls_flags
operator|)
operator|&
name|bits
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|NFSERR_INVAL
operator|)
return|;
block|}
name|stp
operator|->
name|ls_flags
operator|=
operator|(
name|bits
operator||
name|NFSLCK_OPEN
operator|)
expr_stmt|;
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|++
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * If the client just confirmed its first open, write a timestamp 	 * to the stable storage file. 	 */
if|if
condition|(
name|gotstate
condition|)
name|nfsrv_writestable
argument_list|(
name|client
argument_list|,
name|len
argument_list|,
name|NFSNST_NEWSTATE
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delegation update. Does the purge and return.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_delegupdate
parameter_list|(
name|nfsquad_t
name|clientid
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|int
name|op
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|;
name|struct
name|nfsclient
modifier|*
name|clp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fhandle_t
name|fh
decl_stmt|;
comment|/* 	 * Do a sanity check against the file handle for DelegReturn. 	 */
if|if
condition|(
name|vp
condition|)
block|{
name|error
operator|=
name|nfsvno_getfh
argument_list|(
name|vp
argument_list|,
operator|&
name|fh
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Check for restart conditions (client and server). 	 */
if|if
condition|(
name|op
operator|==
name|NFSV4OP_DELEGRETURN
condition|)
name|error
operator|=
name|nfsrv_checkrestart
argument_list|(
name|clientid
argument_list|,
name|NFSLCK_DELEGRETURN
argument_list|,
name|stateidp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nfsrv_checkrestart
argument_list|(
name|clientid
argument_list|,
name|NFSLCK_DELEGPURGE
argument_list|,
name|stateidp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * Get the open structure via clientid and stateid. 	 */
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_getclient
argument_list|(
name|clientid
argument_list|,
name|CLOPS_RENEW
argument_list|,
operator|&
name|clp
argument_list|,
call|(
name|nfsquad_t
call|)
argument_list|(
operator|(
name|u_quad_t
operator|)
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|NFSERR_CBPATHDOWN
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_STALECLIENTID
operator|&&
name|op
operator|==
name|NFSV4OP_DELEGRETURN
condition|)
name|error
operator|=
name|NFSERR_STALESTATEID
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
name|op
operator|==
name|NFSV4OP_DELEGRETURN
condition|)
block|{
name|error
operator|=
name|nfsrv_getstate
argument_list|(
name|clp
argument_list|,
name|stateidp
argument_list|,
name|NFSLCK_DELEGRETURN
argument_list|,
operator|&
name|stp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|!=
name|stateidp
operator|->
name|seqid
condition|)
name|error
operator|=
name|NFSERR_OLDSTATEID
expr_stmt|;
block|}
comment|/* 	 * NFSERR_EXPIRED means that the state has gone away, 	 * so Delegations have been purged. Just return ok. 	 */
if|if
condition|(
name|error
operator|==
name|NFSERR_EXPIRED
operator|&&
name|op
operator|==
name|NFSV4OP_DELEGPURGE
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|op
operator|==
name|NFSV4OP_DELEGRETURN
condition|)
block|{
if|if
condition|(
name|NFSBCMP
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fh
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|stp
operator|->
name|ls_lfp
operator|->
name|lf_fh
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|NFSERR_BADSTATEID
operator|)
return|;
block|}
name|nfsrv_freedeleg
argument_list|(
name|stp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsrv_freedeleglist
argument_list|(
operator|&
name|clp
operator|->
name|lc_olddeleg
argument_list|)
expr_stmt|;
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release lock owner.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_releaselckown
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|new_stp
parameter_list|,
name|nfsquad_t
name|clientid
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|,
modifier|*
name|nstp
decl_stmt|,
modifier|*
name|openstp
decl_stmt|,
modifier|*
name|ownstp
decl_stmt|;
name|struct
name|nfsclient
modifier|*
name|clp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Check for restart conditions (client and server). 	 */
name|error
operator|=
name|nfsrv_checkrestart
argument_list|(
name|clientid
argument_list|,
name|new_stp
operator|->
name|ls_flags
argument_list|,
operator|&
name|new_stp
operator|->
name|ls_stateid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * Get the lock owner by name. 	 */
name|error
operator|=
name|nfsrv_getclient
argument_list|(
name|clientid
argument_list|,
name|CLOPS_RENEW
argument_list|,
operator|&
name|clp
argument_list|,
call|(
name|nfsquad_t
call|)
argument_list|(
operator|(
name|u_quad_t
operator|)
literal|0
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|ownstp
argument_list|,
argument|&clp->lc_open
argument_list|,
argument|ls_list
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|openstp
argument_list|,
argument|&ownstp->ls_open
argument_list|,
argument|ls_list
argument_list|)
block|{
name|stp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|openstp
operator|->
name|ls_open
argument_list|)
expr_stmt|;
while|while
condition|(
name|stp
operator|!=
name|LIST_END
argument_list|(
operator|&
name|openstp
operator|->
name|ls_open
argument_list|)
condition|)
block|{
name|nstp
operator|=
name|LIST_NEXT
argument_list|(
name|stp
argument_list|,
name|ls_list
argument_list|)
expr_stmt|;
comment|/* 		     * If the owner matches, check for locks and 		     * then free or return an error. 		     */
if|if
condition|(
name|stp
operator|->
name|ls_ownerlen
operator|==
name|new_stp
operator|->
name|ls_ownerlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|stp
operator|->
name|ls_owner
argument_list|,
name|new_stp
operator|->
name|ls_owner
argument_list|,
name|stp
operator|->
name|ls_ownerlen
argument_list|)
condition|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|stp
operator|->
name|ls_lock
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|nfsrv_freelockowner
argument_list|(
name|stp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|NFSERR_LOCKSHELD
operator|)
return|;
block|}
block|}
name|stp
operator|=
name|nstp
expr_stmt|;
block|}
block|}
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the file handle for a lock structure.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_getlockfh
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|u_short
name|flags
parameter_list|,
name|struct
name|nfslockfile
modifier|*
modifier|*
name|new_lfpp
parameter_list|,
name|fhandle_t
modifier|*
name|nfhp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|fhandle_t
modifier|*
name|fhp
init|=
name|NULL
decl_stmt|;
name|struct
name|nfslockfile
modifier|*
name|new_lfp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * For lock, use the new nfslock structure, otherwise just 	 * a fhandle_t on the stack. 	 */
if|if
condition|(
name|flags
operator|&
name|NFSLCK_OPEN
condition|)
block|{
name|new_lfp
operator|=
operator|*
name|new_lfpp
expr_stmt|;
name|fhp
operator|=
operator|&
name|new_lfp
operator|->
name|lf_fh
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfhp
condition|)
block|{
name|fhp
operator|=
name|nfhp
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"nfsrv_getlockfh"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|nfsvno_getfh
argument_list|(
name|vp
argument_list|,
name|fhp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get an nfs lock structure. Allocate one, as required, and return a  * pointer to it.  * Returns an NFSERR_xxx upon failure or -1 to indicate no current lock.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_getlockfile
parameter_list|(
name|u_short
name|flags
parameter_list|,
name|struct
name|nfslockfile
modifier|*
modifier|*
name|new_lfpp
parameter_list|,
name|struct
name|nfslockfile
modifier|*
modifier|*
name|lfpp
parameter_list|,
name|fhandle_t
modifier|*
name|nfhp
parameter_list|)
block|{
name|struct
name|nfslockfile
modifier|*
name|lfp
decl_stmt|;
name|fhandle_t
modifier|*
name|fhp
init|=
name|NULL
decl_stmt|,
modifier|*
name|tfhp
decl_stmt|;
name|struct
name|nfslockhashhead
modifier|*
name|hp
decl_stmt|;
name|struct
name|nfslockfile
modifier|*
name|new_lfp
init|=
name|NULL
decl_stmt|;
comment|/* 	 * For lock, use the new nfslock structure, otherwise just 	 * a fhandle_t on the stack. 	 */
if|if
condition|(
name|flags
operator|&
name|NFSLCK_OPEN
condition|)
block|{
name|new_lfp
operator|=
operator|*
name|new_lfpp
expr_stmt|;
name|fhp
operator|=
operator|&
name|new_lfp
operator|->
name|lf_fh
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nfhp
condition|)
block|{
name|fhp
operator|=
name|nfhp
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"nfsrv_getlockfile"
argument_list|)
expr_stmt|;
block|}
name|hp
operator|=
name|NFSLOCKHASH
argument_list|(
name|fhp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lfp
argument_list|,
argument|hp
argument_list|,
argument|lf_hash
argument_list|)
block|{
name|tfhp
operator|=
operator|&
name|lfp
operator|->
name|lf_fh
expr_stmt|;
if|if
condition|(
name|NFSVNO_CMPFH
argument_list|(
name|fhp
argument_list|,
name|tfhp
argument_list|)
condition|)
block|{
operator|*
name|lfpp
operator|=
name|lfp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|NFSLCK_OPEN
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * No match, so chain the new one into the list. 	 */
name|LIST_INIT
argument_list|(
operator|&
name|new_lfp
operator|->
name|lf_open
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|new_lfp
operator|->
name|lf_lock
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|new_lfp
operator|->
name|lf_deleg
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|hp
argument_list|,
name|new_lfp
argument_list|,
name|lf_hash
argument_list|)
expr_stmt|;
operator|*
name|lfpp
operator|=
name|new_lfp
expr_stmt|;
operator|*
name|new_lfpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function adds a nfslock lock structure to the list for the associated  * nfsstate and nfslockfile structures. It will be inserted after the  * entry pointed at by insert_lop.  * Must be called with soft clock interrupts disabled.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_insertlock
parameter_list|(
name|struct
name|nfslock
modifier|*
name|new_lop
parameter_list|,
name|struct
name|nfslock
modifier|*
name|insert_lop
parameter_list|,
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|struct
name|nfslockfile
modifier|*
name|lfp
parameter_list|)
block|{
name|struct
name|nfslock
modifier|*
name|lop
decl_stmt|,
modifier|*
name|nlop
decl_stmt|;
name|new_lop
operator|->
name|lo_stp
operator|=
name|stp
expr_stmt|;
name|new_lop
operator|->
name|lo_lfp
operator|=
name|lfp
expr_stmt|;
comment|/* Insert in increasing lo_first order */
name|lop
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lop
operator|==
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
operator|||
name|new_lop
operator|->
name|lo_first
operator|<=
name|lop
operator|->
name|lo_first
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|,
name|new_lop
argument_list|,
name|lo_lckfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nlop
operator|=
name|LIST_NEXT
argument_list|(
name|lop
argument_list|,
name|lo_lckfile
argument_list|)
expr_stmt|;
while|while
condition|(
name|nlop
operator|!=
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
operator|&&
name|nlop
operator|->
name|lo_first
operator|<
name|new_lop
operator|->
name|lo_first
condition|)
block|{
name|lop
operator|=
name|nlop
expr_stmt|;
name|nlop
operator|=
name|LIST_NEXT
argument_list|(
name|lop
argument_list|,
name|lo_lckfile
argument_list|)
expr_stmt|;
block|}
name|LIST_INSERT_AFTER
argument_list|(
name|lop
argument_list|,
name|new_lop
argument_list|,
name|lo_lckfile
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Insert after insert_lop, which is overloaded as stp for 	 * an empty list. 	 */
if|if
condition|(
operator|(
expr|struct
name|nfsstate
operator|*
operator|)
name|insert_lop
operator|==
name|stp
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|stp
operator|->
name|ls_lock
argument_list|,
name|new_lop
argument_list|,
name|lo_lckowner
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_AFTER
argument_list|(
name|insert_lop
argument_list|,
name|new_lop
argument_list|,
name|lo_lckowner
argument_list|)
expr_stmt|;
name|newnfsstats
operator|.
name|srvlocks
operator|++
expr_stmt|;
name|nfsrv_openpluslock
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function updates the locking for a lock owner and given file. It  * maintains a list of lock ranges ordered on increasing file offset that  * are NFSLCK_READ or NFSLCK_WRITE and non-overlapping (aka POSIX style).  * It always adds new_lop to the list and sometimes uses the one pointed  * at by other_lopp.  * Must be called with soft clock interrupts disabled.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_updatelock
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|struct
name|nfslock
modifier|*
modifier|*
name|new_lopp
parameter_list|,
name|struct
name|nfslock
modifier|*
modifier|*
name|other_lopp
parameter_list|,
name|struct
name|nfslockfile
modifier|*
name|lfp
parameter_list|)
block|{
name|struct
name|nfslock
modifier|*
name|new_lop
init|=
operator|*
name|new_lopp
decl_stmt|;
name|struct
name|nfslock
modifier|*
name|lop
decl_stmt|,
modifier|*
name|tlop
decl_stmt|,
modifier|*
name|ilop
decl_stmt|;
name|struct
name|nfslock
modifier|*
name|other_lop
init|=
operator|*
name|other_lopp
decl_stmt|;
name|int
name|unlock
init|=
literal|0
decl_stmt|,
name|myfile
init|=
literal|0
decl_stmt|;
name|u_int64_t
name|tmp
decl_stmt|;
comment|/* 	 * Work down the list until the lock is merged. 	 */
if|if
condition|(
name|new_lop
operator|->
name|lo_flags
operator|&
name|NFSLCK_UNLOCK
condition|)
name|unlock
operator|=
literal|1
expr_stmt|;
name|ilop
operator|=
operator|(
expr|struct
name|nfslock
operator|*
operator|)
name|stp
expr_stmt|;
name|lop
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|stp
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|lop
operator|!=
name|LIST_END
argument_list|(
operator|&
name|stp
operator|->
name|ls_lock
argument_list|)
condition|)
block|{
comment|/* 	     * Only check locks for this file that aren't before the start of 	     * new lock's range. 	     */
if|if
condition|(
name|lop
operator|->
name|lo_lfp
operator|==
name|lfp
condition|)
block|{
name|myfile
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lop
operator|->
name|lo_end
operator|>=
name|new_lop
operator|->
name|lo_first
condition|)
block|{
if|if
condition|(
name|new_lop
operator|->
name|lo_end
operator|<
name|lop
operator|->
name|lo_first
condition|)
block|{
comment|/* 			 * If the new lock ends before the start of the 			 * current lock's range, no merge, just insert 			 * the new lock. 			 */
break|break;
block|}
if|if
condition|(
name|new_lop
operator|->
name|lo_flags
operator|==
name|lop
operator|->
name|lo_flags
operator|||
operator|(
name|new_lop
operator|->
name|lo_first
operator|<=
name|lop
operator|->
name|lo_first
operator|&&
name|new_lop
operator|->
name|lo_end
operator|>=
name|lop
operator|->
name|lo_end
operator|)
condition|)
block|{
comment|/* 			 * This lock can be absorbed by the new lock/unlock. 			 * This happens when it covers the entire range 			 * of the old lock or is contiguous 			 * with the old lock and is of the same type or an 			 * unlock. 			 */
if|if
condition|(
name|lop
operator|->
name|lo_first
operator|<
name|new_lop
operator|->
name|lo_first
condition|)
name|new_lop
operator|->
name|lo_first
operator|=
name|lop
operator|->
name|lo_first
expr_stmt|;
if|if
condition|(
name|lop
operator|->
name|lo_end
operator|>
name|new_lop
operator|->
name|lo_end
condition|)
name|new_lop
operator|->
name|lo_end
operator|=
name|lop
operator|->
name|lo_end
expr_stmt|;
name|tlop
operator|=
name|lop
expr_stmt|;
name|lop
operator|=
name|LIST_NEXT
argument_list|(
name|lop
argument_list|,
name|lo_lckowner
argument_list|)
expr_stmt|;
name|nfsrv_freenfslock
argument_list|(
name|tlop
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * All these cases are for contiguous locks that are not the 		 * same type, so they can't be merged. 		 */
if|if
condition|(
name|new_lop
operator|->
name|lo_first
operator|<=
name|lop
operator|->
name|lo_first
condition|)
block|{
comment|/* 			 * This case is where the new lock overlaps with the 			 * first part of the old lock. Move the start of the 			 * old lock to just past the end of the new lock. The 			 * new lock will be inserted in front of the old, since 			 * ilop hasn't been updated. (We are done now.) 			 */
name|lop
operator|->
name|lo_first
operator|=
name|new_lop
operator|->
name|lo_end
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|new_lop
operator|->
name|lo_end
operator|>=
name|lop
operator|->
name|lo_end
condition|)
block|{
comment|/* 			 * This case is where the new lock overlaps with the 			 * end of the old lock's range. Move the old lock's 			 * end to just before the new lock's first and insert 			 * the new lock after the old lock. 			 * Might not be done yet, since the new lock could 			 * overlap further locks with higher ranges. 			 */
name|lop
operator|->
name|lo_end
operator|=
name|new_lop
operator|->
name|lo_first
expr_stmt|;
name|ilop
operator|=
name|lop
expr_stmt|;
name|lop
operator|=
name|LIST_NEXT
argument_list|(
name|lop
argument_list|,
name|lo_lckowner
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * The final case is where the new lock's range is in the 		 * middle of the current lock's and splits the current lock 		 * up. Use *other_lopp to handle the second part of the 		 * split old lock range. (We are done now.) 		 * For unlock, we use new_lop as other_lop and tmp, since 		 * other_lop and new_lop are the same for this case. 		 * We noted the unlock case above, so we don't need 		 * new_lop->lo_flags any longer. 		 */
name|tmp
operator|=
name|new_lop
operator|->
name|lo_first
expr_stmt|;
if|if
condition|(
name|other_lop
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|unlock
condition|)
name|panic
argument_list|(
literal|"nfsd srv update unlock"
argument_list|)
expr_stmt|;
name|other_lop
operator|=
name|new_lop
expr_stmt|;
operator|*
name|new_lopp
operator|=
name|NULL
expr_stmt|;
block|}
name|other_lop
operator|->
name|lo_first
operator|=
name|new_lop
operator|->
name|lo_end
expr_stmt|;
name|other_lop
operator|->
name|lo_end
operator|=
name|lop
operator|->
name|lo_end
expr_stmt|;
name|other_lop
operator|->
name|lo_flags
operator|=
name|lop
operator|->
name|lo_flags
expr_stmt|;
name|other_lop
operator|->
name|lo_stp
operator|=
name|stp
expr_stmt|;
name|other_lop
operator|->
name|lo_lfp
operator|=
name|lfp
expr_stmt|;
name|lop
operator|->
name|lo_end
operator|=
name|tmp
expr_stmt|;
name|nfsrv_insertlock
argument_list|(
name|other_lop
argument_list|,
name|lop
argument_list|,
name|stp
argument_list|,
name|lfp
argument_list|)
expr_stmt|;
operator|*
name|other_lopp
operator|=
name|NULL
expr_stmt|;
name|ilop
operator|=
name|lop
expr_stmt|;
break|break;
block|}
block|}
name|ilop
operator|=
name|lop
expr_stmt|;
name|lop
operator|=
name|LIST_NEXT
argument_list|(
name|lop
argument_list|,
name|lo_lckowner
argument_list|)
expr_stmt|;
if|if
condition|(
name|myfile
operator|&&
operator|(
name|lop
operator|==
name|LIST_END
argument_list|(
operator|&
name|stp
operator|->
name|ls_lock
argument_list|)
operator|||
name|lop
operator|->
name|lo_lfp
operator|!=
name|lfp
operator|)
condition|)
break|break;
block|}
comment|/* 	 * Insert the new lock in the list at the appropriate place. 	 */
if|if
condition|(
operator|!
name|unlock
condition|)
block|{
name|nfsrv_insertlock
argument_list|(
name|new_lop
argument_list|,
name|ilop
argument_list|,
name|stp
argument_list|,
name|lfp
argument_list|)
expr_stmt|;
operator|*
name|new_lopp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function handles sequencing of locks, etc.  * It returns an error that indicates what the caller should do.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_checkseqid
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|u_int32_t
name|seqid
parameter_list|,
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|struct
name|nfsrvcache
modifier|*
name|op
parameter_list|)
block|{
if|if
condition|(
name|op
operator|!=
name|nd
operator|->
name|nd_rp
condition|)
name|panic
argument_list|(
literal|"nfsrvstate checkseqid"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|op
operator|->
name|rc_flag
operator|&
name|RC_INPROG
operator|)
condition|)
name|panic
argument_list|(
literal|"nfsrvstate not inprog"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|ls_op
operator|&&
name|stp
operator|->
name|ls_op
operator|->
name|rc_refcnt
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"refcnt=%d\n"
argument_list|,
name|stp
operator|->
name|ls_op
operator|->
name|rc_refcnt
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"nfsrvstate op refcnt"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stp
operator|->
name|ls_seq
operator|+
literal|1
operator|)
operator|==
name|seqid
condition|)
block|{
if|if
condition|(
name|stp
operator|->
name|ls_op
condition|)
name|nfsrvd_derefcache
argument_list|(
name|stp
operator|->
name|ls_op
argument_list|)
expr_stmt|;
name|stp
operator|->
name|ls_op
operator|=
name|op
expr_stmt|;
name|nfsrvd_refcache
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|stp
operator|->
name|ls_seq
operator|=
name|seqid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|stp
operator|->
name|ls_seq
operator|==
name|seqid
operator|&&
name|stp
operator|->
name|ls_op
operator|&&
name|op
operator|->
name|rc_xid
operator|==
name|stp
operator|->
name|ls_op
operator|->
name|rc_xid
operator|&&
name|op
operator|->
name|rc_refcnt
operator|==
literal|0
operator|&&
name|op
operator|->
name|rc_reqlen
operator|==
name|stp
operator|->
name|ls_op
operator|->
name|rc_reqlen
operator|&&
name|op
operator|->
name|rc_cksum
operator|==
name|stp
operator|->
name|ls_op
operator|->
name|rc_cksum
condition|)
block|{
if|if
condition|(
name|stp
operator|->
name|ls_op
operator|->
name|rc_flag
operator|&
name|RC_INPROG
condition|)
return|return
operator|(
name|NFSERR_DONTREPLY
operator|)
return|;
name|nd
operator|->
name|nd_rp
operator|=
name|stp
operator|->
name|ls_op
expr_stmt|;
name|nd
operator|->
name|nd_rp
operator|->
name|rc_flag
operator||=
name|RC_INPROG
expr_stmt|;
name|nfsrvd_delcache
argument_list|(
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|NFSERR_REPLYFROMCACHE
operator|)
return|;
block|}
return|return
operator|(
name|NFSERR_BADSEQID
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the client ip address for callbacks. If the strings can't be parsed,  * just set lc_program to 0 to indicate no callbacks are possible.  * (For cases where the address can't be parsed or is 0.0.0.0.0.0, set  *  the address to the client's transport address. This won't be used  *  for callbacks, but can be printed out by newnfsstats for info.)  * Return error if the xdr can't be parsed, 0 otherwise.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_getclientipaddr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|rad
decl_stmt|,
modifier|*
name|sad
decl_stmt|;
name|u_char
name|protocol
index|[
literal|5
index|]
decl_stmt|,
name|addr
index|[
literal|24
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|cantparse
init|=
literal|0
decl_stmt|;
union|union
block|{
name|u_long
name|ival
decl_stmt|;
name|u_char
name|cval
index|[
literal|4
index|]
decl_stmt|;
block|}
name|ip
union|;
union|union
block|{
name|u_short
name|sval
decl_stmt|;
name|u_char
name|cval
index|[
literal|2
index|]
decl_stmt|;
block|}
name|port
union|;
name|rad
operator|=
name|NFSSOCKADDR
argument_list|(
name|clp
operator|->
name|lc_req
operator|.
name|nr_nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
name|rad
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|rad
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|rad
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|rad
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
name|clp
operator|->
name|lc_req
operator|.
name|nr_client
operator|=
name|NULL
expr_stmt|;
name|clp
operator|->
name|lc_req
operator|.
name|nr_lock
operator|=
literal|0
expr_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|3
operator|&&
name|i
operator|<=
literal|4
condition|)
block|{
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|protocol
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|protocol
argument_list|,
literal|"tcp"
argument_list|)
condition|)
block|{
name|clp
operator|->
name|lc_flags
operator||=
name|LCL_TCPCALLBACK
expr_stmt|;
name|clp
operator|->
name|lc_req
operator|.
name|nr_sotype
operator|=
name|SOCK_STREAM
expr_stmt|;
name|clp
operator|->
name|lc_req
operator|.
name|nr_soproto
operator|=
name|IPPROTO_TCP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|protocol
argument_list|,
literal|"udp"
argument_list|)
condition|)
block|{
name|clp
operator|->
name|lc_req
operator|.
name|nr_sotype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|clp
operator|->
name|lc_req
operator|.
name|nr_soproto
operator|=
name|IPPROTO_UDP
expr_stmt|;
block|}
else|else
block|{
name|cantparse
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|cantparse
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|cantparse
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cantparse
operator|&&
name|i
operator|<=
literal|23
operator|&&
name|i
operator|>=
literal|11
condition|)
block|{
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
comment|/* 		 * Parse out the address fields. We expect 6 decimal numbers 		 * separated by '.'s. 		 */
name|cp
operator|=
name|addr
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
name|i
operator|<
literal|6
condition|)
block|{
name|cp2
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|cp2
operator|&&
operator|*
name|cp2
operator|!=
literal|'.'
condition|)
name|cp2
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp2
condition|)
operator|*
name|cp2
operator|++
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|!=
literal|5
condition|)
block|{
name|cantparse
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|j
operator|=
name|nfsrv_getipnumber
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|<
literal|4
condition|)
name|ip
operator|.
name|cval
index|[
literal|3
operator|-
name|i
index|]
operator|=
name|j
expr_stmt|;
else|else
name|port
operator|.
name|cval
index|[
literal|5
operator|-
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
name|cantparse
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|cp
operator|=
name|cp2
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cantparse
condition|)
block|{
if|if
condition|(
name|ip
operator|.
name|ival
operator|!=
literal|0x0
condition|)
block|{
name|rad
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|ip
operator|.
name|ival
argument_list|)
expr_stmt|;
name|rad
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|port
operator|.
name|sval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cantparse
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|cantparse
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
block|}
if|if
condition|(
name|cantparse
condition|)
block|{
name|sad
operator|=
name|NFSSOCKADDR
argument_list|(
name|nd
operator|->
name|nd_nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
name|rad
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|sad
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|rad
operator|->
name|sin_port
operator|=
literal|0x0
expr_stmt|;
name|clp
operator|->
name|lc_program
operator|=
literal|0
expr_stmt|;
block|}
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Turn a string of up to three decimal digits into a number. Return -1 upon  * error.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_getipnumber
parameter_list|(
name|u_char
modifier|*
name|cp
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|j
operator|>
literal|2
operator|||
operator|*
name|cp
operator|<
literal|'0'
operator|||
operator|*
name|cp
operator|>
literal|'9'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|i
operator|*=
literal|10
expr_stmt|;
name|i
operator|+=
operator|(
operator|*
name|cp
operator|-
literal|'0'
operator|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|256
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function checks for restart conditions.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_checkrestart
parameter_list|(
name|nfsquad_t
name|clientid
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|int
name|specialid
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* 	 * First check for a server restart. Open, LockT, ReleaseLockOwner 	 * and DelegPurge have a clientid, the rest a stateid. 	 */
if|if
condition|(
name|flags
operator|&
operator|(
name|NFSLCK_OPEN
operator||
name|NFSLCK_TEST
operator||
name|NFSLCK_RELEASE
operator||
name|NFSLCK_DELEGPURGE
operator|)
condition|)
block|{
if|if
condition|(
name|clientid
operator|.
name|lval
index|[
literal|0
index|]
operator|!=
name|nfsrvboottime
condition|)
return|return
operator|(
name|NFSERR_STALECLIENTID
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
operator|!=
name|nfsrvboottime
operator|&&
name|specialid
operator|==
literal|0
condition|)
return|return
operator|(
name|NFSERR_STALESTATEID
operator|)
return|;
comment|/* 	 * Read, Write, Setattr and LockT can return NFSERR_GRACE and do 	 * not use a lock/open owner seqid#, so the check can be done now. 	 * (The others will be checked, as required, later.) 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|NFSLCK_CHECK
operator||
name|NFSLCK_TEST
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
name|ret
operator|=
name|nfsrv_checkgrace
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for grace.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_checkgrace
parameter_list|(
name|u_int32_t
name|flags
parameter_list|)
block|{
if|if
condition|(
name|nfsrv_stablefirst
operator|.
name|nsf_flags
operator|&
name|NFSNSF_GRACEOVER
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|NFSLCK_RECLAIM
condition|)
return|return
operator|(
name|NFSERR_NOGRACE
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|NFSLCK_RECLAIM
operator|)
condition|)
return|return
operator|(
name|NFSERR_GRACE
operator|)
return|;
comment|/* 		 * If grace is almost over and we are still getting Reclaims, 		 * extend grace a bit. 		 */
if|if
condition|(
operator|(
name|NFSD_MONOSEC
operator|+
name|NFSRV_LEASEDELTA
operator|)
operator|>
name|nfsrv_stablefirst
operator|.
name|nsf_eograce
condition|)
name|nfsrv_stablefirst
operator|.
name|nsf_eograce
operator|=
name|NFSD_MONOSEC
operator|+
name|NFSRV_LEASEDELTA
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do a server callback.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_docallback
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|,
name|int
name|procnum
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|int
name|trunc
parameter_list|,
name|fhandle_t
modifier|*
name|fhp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nap
parameter_list|,
name|nfsattrbit_t
modifier|*
name|attrbitp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|mbuf_t
name|m
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsrv_descript
name|nfsd
decl_stmt|,
modifier|*
name|nd
init|=
operator|&
name|nfsd
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|callback
decl_stmt|;
name|cred
operator|=
name|newnfs_getcred
argument_list|()
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* mostly for lc_cbref++ */
if|if
condition|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_NEEDSCONFIRM
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
name|panic
argument_list|(
literal|"docallb"
argument_list|)
expr_stmt|;
block|}
name|clp
operator|->
name|lc_cbref
operator|++
expr_stmt|;
comment|/* 	 * Fill the callback program# and version into the request 	 * structure for newnfs_connect() to use. 	 */
name|clp
operator|->
name|lc_req
operator|.
name|nr_prog
operator|=
name|clp
operator|->
name|lc_program
expr_stmt|;
name|clp
operator|->
name|lc_req
operator|.
name|nr_vers
operator|=
name|NFSV4_CBVERS
expr_stmt|;
comment|/* 	 * First, fill in some of the fields of nd and cr. 	 */
name|nd
operator|->
name|nd_flag
operator|=
name|ND_NFSV4
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_GSS
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_KERBV
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
name|cred
operator|->
name|cr_uid
operator|=
name|clp
operator|->
name|lc_uid
expr_stmt|;
name|cred
operator|->
name|cr_gid
operator|=
name|clp
operator|->
name|lc_gid
expr_stmt|;
name|callback
operator|=
name|clp
operator|->
name|lc_callback
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
name|cred
operator|->
name|cr_ngroups
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Get the first mbuf for the request. 	 */
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|mbuf_setlen
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mreq
operator|=
name|nd
operator|->
name|nd_mb
operator|=
name|m
expr_stmt|;
name|nd
operator|->
name|nd_bpos
operator|=
name|NFSMTOD
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* 	 * and build the callback request. 	 */
if|if
condition|(
name|procnum
operator|==
name|NFSV4OP_CBGETATTR
condition|)
block|{
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSV4PROC_CBCOMPOUND
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
literal|"CB Getattr"
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4_MINORVERSION
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|callback
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_CBGETATTR
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|fhp
argument_list|,
name|NFSX_MYFH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
name|attrbitp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|procnum
operator|==
name|NFSV4OP_CBRECALL
condition|)
block|{
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSV4PROC_CBCOMPOUND
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
literal|"CB Recall"
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
operator|+
name|NFSX_STATEID
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4_MINORVERSION
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|callback
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4OP_CBRECALL
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|stateidp
operator|->
name|seqid
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
name|stateidp
operator|->
name|other
argument_list|,
operator|(
name|caddr_t
operator|)
name|tl
argument_list|,
name|NFSX_STATEIDOTHER
argument_list|)
expr_stmt|;
name|tl
operator|+=
operator|(
name|NFSX_STATEIDOTHER
operator|/
name|NFSX_UNSIGNED
operator|)
expr_stmt|;
if|if
condition|(
name|trunc
condition|)
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
else|else
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
name|fhp
argument_list|,
name|NFSX_MYFH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nd
operator|->
name|nd_procnum
operator|=
name|NFSV4PROC_CBNULL
expr_stmt|;
block|}
comment|/* 	 * Call newnfs_connect(), as required, and then newnfs_request(). 	 */
operator|(
name|void
operator|)
name|newnfs_sndlock
argument_list|(
operator|&
name|clp
operator|->
name|lc_req
operator|.
name|nr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|lc_req
operator|.
name|nr_client
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|==
name|NFSV4PROC_CBNULL
condition|)
name|error
operator|=
name|newnfs_connect
argument_list|(
name|NULL
argument_list|,
operator|&
name|clp
operator|->
name|lc_req
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|newnfs_connect
argument_list|(
name|NULL
argument_list|,
operator|&
name|clp
operator|->
name|lc_req
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|newnfs_sndunlock
argument_list|(
operator|&
name|clp
operator|->
name|lc_req
operator|.
name|nr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|newnfs_request
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
name|clp
argument_list|,
operator|&
name|clp
operator|->
name|lc_req
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cred
argument_list|,
name|clp
operator|->
name|lc_program
argument_list|,
name|NFSV4_CBVERS
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|NFSFREECRED
argument_list|(
name|cred
argument_list|)
expr_stmt|;
comment|/* 	 * If error is set here, the Callback path isn't working 	 * properly, so twiddle the appropriate LCL_ flags. 	 * (nd_repstat != 0 indicates the Callback path is working, 	 *  but the callback failed on the client.) 	 */
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Mark the callback pathway down, which disabled issuing 		 * of delegations and gets Renew to return NFSERR_CBPATHDOWN. 		 */
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
name|clp
operator|->
name|lc_flags
operator||=
name|LCL_CBDOWN
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Callback worked. If the callback path was down, disable 		 * callbacks, so no more delegations will be issued. (This 		 * is done on the assumption that the callback pathway is 		 * flakey.) 		 */
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_CBDOWN
condition|)
name|clp
operator|->
name|lc_flags
operator|&=
operator|~
operator|(
name|LCL_CBDOWN
operator||
name|LCL_CALLBACKSON
operator|)
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
elseif|else
if|if
condition|(
name|procnum
operator|==
name|NFSV4OP_CBGETATTR
condition|)
name|error
operator|=
name|nfsv4_loadattr
argument_list|(
name|nd
argument_list|,
name|NULL
argument_list|,
name|nap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|)
expr_stmt|;
block|}
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
name|clp
operator|->
name|lc_cbref
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_WAKEUPWANTED
operator|)
operator|&&
name|clp
operator|->
name|lc_cbref
operator|==
literal|0
condition|)
block|{
name|clp
operator|->
name|lc_flags
operator|&=
operator|~
name|LCL_WAKEUPWANTED
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|clp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the next index# for a clientid. Mostly just increment and return  * the next one, but... if the 32bit unsigned does actually wrap around,  * it should be rebooted.  * At an average rate of one new client per second, it will wrap around in  * approximately 136 years. (I think the server will have been shut  * down or rebooted before then.)  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|nfsrv_nextclientindex
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|u_int32_t
name|client_index
init|=
literal|0
decl_stmt|;
name|client_index
operator|++
expr_stmt|;
if|if
condition|(
name|client_index
operator|!=
literal|0
condition|)
return|return
operator|(
name|client_index
operator|)
return|;
name|printf
argument_list|(
literal|"%s: out of clientids\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|client_index
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the next index# for a stateid. Mostly just increment and return  * the next one, but... if the 32bit unsigned does actually wrap around  * (will a BSD server stay up that long?), find  * new start and end values.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|nfsrv_nextstateindex
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int32_t
name|canuse
decl_stmt|,
name|min_index
decl_stmt|,
name|max_index
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_INDEXNOTOK
operator|)
condition|)
block|{
name|clp
operator|->
name|lc_stateindex
operator|++
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|lc_stateindex
operator|!=
name|clp
operator|->
name|lc_statemaxindex
condition|)
return|return
operator|(
name|clp
operator|->
name|lc_stateindex
operator|)
return|;
block|}
comment|/* 	 * Yuck, we've hit the end. 	 * Look for a new min and max. 	 */
name|min_index
operator|=
literal|0
expr_stmt|;
name|max_index
operator|=
literal|0xffffffff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSSTATEHASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&clp->lc_stateid[i]
argument_list|,
argument|ls_hash
argument_list|)
block|{
if|if
condition|(
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|>
literal|0x80000000
condition|)
block|{
if|if
condition|(
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|<
name|max_index
condition|)
name|max_index
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|>
name|min_index
condition|)
name|min_index
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Yikes, highly unlikely, but I'll handle it anyhow. 	 */
if|if
condition|(
name|min_index
operator|==
literal|0x80000000
operator|&&
name|max_index
operator|==
literal|0x80000001
condition|)
block|{
name|canuse
operator|=
literal|0
expr_stmt|;
comment|/* 	     * Loop around until we find an unused entry. Return that 	     * and set LCL_INDEXNOTOK, so the search will continue next time. 	     * (This is one of those rare cases where a goto is the 	     *  cleanest way to code the loop.) 	     */
name|tryagain
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSSTATEHASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&clp->lc_stateid[i]
argument_list|,
argument|ls_hash
argument_list|)
block|{
if|if
condition|(
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|==
name|canuse
condition|)
block|{
name|canuse
operator|++
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
block|}
block|}
name|clp
operator|->
name|lc_flags
operator||=
name|LCL_INDEXNOTOK
expr_stmt|;
return|return
operator|(
name|canuse
operator|)
return|;
block|}
comment|/* 	 * Ok to start again from min + 1. 	 */
name|clp
operator|->
name|lc_stateindex
operator|=
name|min_index
operator|+
literal|1
expr_stmt|;
name|clp
operator|->
name|lc_statemaxindex
operator|=
name|max_index
expr_stmt|;
name|clp
operator|->
name|lc_flags
operator|&=
operator|~
name|LCL_INDEXNOTOK
expr_stmt|;
return|return
operator|(
name|clp
operator|->
name|lc_stateindex
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The following functions handle the stable storage file that deals with  * the edge conditions described in RFC3530 Sec. 8.6.3.  * The file is as follows:  * - a single record at the beginning that has the lease time of the  *   previous server instance (before the last reboot) and the nfsrvboottime  *   values for the previous server boots.  *   These previous boot times are used to ensure that the current  *   nfsrvboottime does not, somehow, get set to a previous one.  *   (This is important so that Stale ClientIDs and StateIDs can  *    be recognized.)  *   The number of previous nfsvrboottime values preceeds the list.  * - followed by some number of appended records with:  *   - client id string  *   - flag that indicates it is a record revoking state via lease  *     expiration or similar  *     OR has successfully acquired state.  * These structures vary in length, with the client string at the end, up  * to NFSV4_OPAQUELIMIT in size.  *  * At the end of the grace period, the file is truncated, the first  * record is rewritten with updated information and any acquired state  * records for successful reclaims of state are written.  *  * Subsequent records are appended when the first state is issued to  * a client and when state is revoked for a client.  *  * When reading the file in, state issued records that come later in  * the file override older ones, since the append log is in cronological order.  * If, for some reason, the file can't be read, the grace period is  * immediately terminated and all reclaims get NFSERR_NOGRACE.  */
end_comment

begin_comment
comment|/*  * Read in the stable storage file. Called by nfssvc() before the nfsd  * processes start servicing requests.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_setupstable
parameter_list|(
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsrv_stablefirst
modifier|*
name|sf
init|=
operator|&
name|nfsrv_stablefirst
decl_stmt|;
name|struct
name|nfsrv_stable
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nsp
decl_stmt|;
name|struct
name|nfst_rec
modifier|*
name|tsp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|tryagain
decl_stmt|;
name|off_t
name|off
init|=
literal|0
decl_stmt|;
name|int
name|aresid
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|timeval
name|curtime
decl_stmt|;
comment|/* 	 * If NFSNSF_UPDATEDONE is set, this is a restart of the nfsds without 	 * a reboot, so state has not been lost. 	 */
if|if
condition|(
name|sf
operator|->
name|nsf_flags
operator|&
name|NFSNSF_UPDATEDONE
condition|)
return|return;
comment|/* 	 * Set Grace over just until the file reads successfully. 	 */
name|NFSGETTIME
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
name|nfsrvboottime
operator|=
name|curtime
operator|.
name|tv_sec
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sf
operator|->
name|nsf_head
argument_list|)
expr_stmt|;
name|sf
operator|->
name|nsf_flags
operator|=
operator|(
name|NFSNSF_GRACEOVER
operator||
name|NFSNSF_NEEDLOCK
operator|)
expr_stmt|;
name|sf
operator|->
name|nsf_eograce
operator|=
name|NFSD_MONOSEC
operator|+
name|NFSRV_LEASEDELTA
expr_stmt|;
if|if
condition|(
name|sf
operator|->
name|nsf_fp
operator|==
name|NULL
condition|)
return|return;
name|error
operator|=
name|NFSD_RDWR
argument_list|(
name|UIO_READ
argument_list|,
name|NFSFPVNODE
argument_list|(
name|sf
operator|->
name|nsf_fp
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sf
operator|->
name|nsf_rec
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsf_rec
argument_list|)
argument_list|,
name|off
argument_list|,
name|UIO_SYSSPACE
argument_list|,
literal|0
argument_list|,
name|NFSFPCRED
argument_list|(
name|sf
operator|->
name|nsf_fp
argument_list|)
argument_list|,
operator|&
name|aresid
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|aresid
operator|||
name|sf
operator|->
name|nsf_numboots
operator|==
literal|0
operator|||
name|sf
operator|->
name|nsf_numboots
operator|>
name|NFSNSF_MAXNUMBOOTS
condition|)
return|return;
comment|/* 	 * Now, read in the boottimes. 	 */
name|sf
operator|->
name|nsf_bootvals
operator|=
operator|(
name|time_t
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|sf
operator|->
name|nsf_numboots
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|off
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nfsf_rec
argument_list|)
expr_stmt|;
name|error
operator|=
name|NFSD_RDWR
argument_list|(
name|UIO_READ
argument_list|,
name|NFSFPVNODE
argument_list|(
name|sf
operator|->
name|nsf_fp
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|sf
operator|->
name|nsf_bootvals
argument_list|,
name|sf
operator|->
name|nsf_numboots
operator|*
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
argument_list|,
name|off
argument_list|,
name|UIO_SYSSPACE
argument_list|,
literal|0
argument_list|,
name|NFSFPCRED
argument_list|(
name|sf
operator|->
name|nsf_fp
argument_list|)
argument_list|,
operator|&
name|aresid
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|aresid
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sf
operator|->
name|nsf_bootvals
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sf
operator|->
name|nsf_bootvals
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* 	 * Make sure this nfsrvboottime is different from all recorded 	 * previous ones. 	 */
do|do
block|{
name|tryagain
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sf
operator|->
name|nsf_numboots
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nfsrvboottime
operator|==
name|sf
operator|->
name|nsf_bootvals
index|[
name|i
index|]
condition|)
block|{
name|nfsrvboottime
operator|++
expr_stmt|;
name|tryagain
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|tryagain
condition|)
do|;
name|sf
operator|->
name|nsf_flags
operator||=
name|NFSNSF_OK
expr_stmt|;
name|off
operator|+=
operator|(
name|sf
operator|->
name|nsf_numboots
operator|*
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Read through the file, building a list of records for grace 	 * checking. 	 * Each record is between sizeof (struct nfst_rec) and 	 * sizeof (struct nfst_rec) + NFSV4_OPAQUELIMIT - 1 	 * and is actually sizeof (struct nfst_rec) + nst_len - 1. 	 */
name|tsp
operator|=
operator|(
expr|struct
name|nfst_rec
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfst_rec
argument_list|)
operator|+
name|NFSV4_OPAQUELIMIT
operator|-
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
do|do
block|{
name|error
operator|=
name|NFSD_RDWR
argument_list|(
name|UIO_READ
argument_list|,
name|NFSFPVNODE
argument_list|(
name|sf
operator|->
name|nsf_fp
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|tsp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfst_rec
argument_list|)
operator|+
name|NFSV4_OPAQUELIMIT
operator|-
literal|1
argument_list|,
name|off
argument_list|,
name|UIO_SYSSPACE
argument_list|,
literal|0
argument_list|,
name|NFSFPCRED
argument_list|(
name|sf
operator|->
name|nsf_fp
argument_list|)
argument_list|,
operator|&
name|aresid
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfst_rec
argument_list|)
operator|+
name|NFSV4_OPAQUELIMIT
operator|-
literal|1
operator|)
operator|-
name|aresid
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|len
operator|>
literal|0
operator|&&
operator|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|nfst_rec
argument_list|)
operator|||
name|len
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfst_rec
argument_list|)
operator|+
name|tsp
operator|->
name|len
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Yuck, the file has been corrupted, so just return 		 * after clearing out any restart state, so the grace period 		 * is over. 		 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|sp
argument_list|,
argument|&sf->nsf_head
argument_list|,
argument|nst_list
argument_list|,
argument|nsp
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|sp
argument_list|,
name|nst_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|tsp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sf
operator|->
name|nsf_flags
operator|&=
operator|~
name|NFSNSF_OK
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sf
operator|->
name|nsf_bootvals
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sf
operator|->
name|nsf_bootvals
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|off
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nfst_rec
argument_list|)
operator|+
name|tsp
operator|->
name|len
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Search the list for a matching client. 		 */
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sf->nsf_head
argument_list|,
argument|nst_list
argument_list|)
block|{
if|if
condition|(
name|tsp
operator|->
name|len
operator|==
name|sp
operator|->
name|nst_len
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|tsp
operator|->
name|client
argument_list|,
name|sp
operator|->
name|nst_client
argument_list|,
name|tsp
operator|->
name|len
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|sp
operator|==
name|LIST_END
argument_list|(
operator|&
name|sf
operator|->
name|nsf_head
argument_list|)
condition|)
block|{
name|sp
operator|=
operator|(
expr|struct
name|nfsrv_stable
operator|*
operator|)
name|malloc
argument_list|(
name|tsp
operator|->
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|nfsrv_stable
argument_list|)
operator|-
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
name|tsp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sp
operator|->
name|nst_rec
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfst_rec
argument_list|)
operator|+
name|tsp
operator|->
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sf
operator|->
name|nsf_head
argument_list|,
name|sp
argument_list|,
name|nst_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tsp
operator|->
name|flag
operator|==
name|NFSNST_REVOKE
condition|)
name|sp
operator|->
name|nst_flag
operator||=
name|NFSNST_REVOKE
expr_stmt|;
else|else
comment|/* 				 * A subsequent timestamp indicates the client 				 * did a setclientid/confirm and any previous 				 * revoke is no longer relevant. 				 */
name|sp
operator|->
name|nst_flag
operator|&=
operator|~
name|NFSNST_REVOKE
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|len
operator|>
literal|0
condition|)
do|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|tsp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sf
operator|->
name|nsf_flags
operator|=
name|NFSNSF_OK
expr_stmt|;
name|sf
operator|->
name|nsf_eograce
operator|=
name|NFSD_MONOSEC
operator|+
name|sf
operator|->
name|nsf_lease
operator|+
name|NFSRV_LEASEDELTA
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the stable storage file, now that the grace period is over.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_updatestable
parameter_list|(
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsrv_stablefirst
modifier|*
name|sf
init|=
operator|&
name|nfsrv_stablefirst
decl_stmt|;
name|struct
name|nfsrv_stable
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nsp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|nfsvattr
name|nva
decl_stmt|;
name|vnode_t
name|vp
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD_version
argument_list|)
operator|&&
operator|(
name|__FreeBSD_version
operator|>=
literal|500000
operator|)
name|mount_t
name|mp
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sf
operator|->
name|nsf_fp
operator|==
name|NULL
operator|||
operator|(
name|sf
operator|->
name|nsf_flags
operator|&
name|NFSNSF_UPDATEDONE
operator|)
condition|)
return|return;
name|sf
operator|->
name|nsf_flags
operator||=
name|NFSNSF_UPDATEDONE
expr_stmt|;
comment|/* 	 * Ok, we need to rewrite the stable storage file. 	 * - truncate to 0 length 	 * - write the new first structure 	 * - loop through the data structures, writing out any that 	 *   have timestamps older than the old boot 	 */
if|if
condition|(
name|sf
operator|->
name|nsf_bootvals
condition|)
block|{
name|sf
operator|->
name|nsf_numboots
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sf
operator|->
name|nsf_numboots
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|sf
operator|->
name|nsf_bootvals
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|sf
operator|->
name|nsf_bootvals
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|sf
operator|->
name|nsf_numboots
operator|=
literal|1
expr_stmt|;
name|sf
operator|->
name|nsf_bootvals
operator|=
operator|(
name|time_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|sf
operator|->
name|nsf_bootvals
index|[
literal|0
index|]
operator|=
name|nfsrvboottime
expr_stmt|;
name|sf
operator|->
name|nsf_lease
operator|=
name|nfsrv_lease
expr_stmt|;
name|NFSVNO_ATTRINIT
argument_list|(
operator|&
name|nva
argument_list|)
expr_stmt|;
name|NFSVNO_SETATTRVAL
argument_list|(
operator|&
name|nva
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NFSFPVNODE
argument_list|(
name|sf
operator|->
name|nsf_fp
argument_list|)
expr_stmt|;
name|NFS_STARTWRITE
argument_list|(
name|vp
argument_list|,
operator|&
name|mp
argument_list|)
expr_stmt|;
name|NFSVOPLOCK
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsvno_setattr
argument_list|(
name|vp
argument_list|,
operator|&
name|nva
argument_list|,
name|NFSFPCRED
argument_list|(
name|sf
operator|->
name|nsf_fp
argument_list|)
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFS_ENDWRITE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|NFSD_RDWR
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sf
operator|->
name|nsf_rec
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsf_rec
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_SYNC
argument_list|,
name|NFSFPCRED
argument_list|(
name|sf
operator|->
name|nsf_fp
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|NFSD_RDWR
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
operator|(
name|caddr_t
operator|)
name|sf
operator|->
name|nsf_bootvals
argument_list|,
name|sf
operator|->
name|nsf_numboots
operator|*
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
argument_list|,
call|(
name|off_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsf_rec
argument_list|)
argument_list|)
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_SYNC
argument_list|,
name|NFSFPCRED
argument_list|(
name|sf
operator|->
name|nsf_fp
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sf
operator|->
name|nsf_bootvals
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sf
operator|->
name|nsf_bootvals
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sf
operator|->
name|nsf_flags
operator|&=
operator|~
name|NFSNSF_OK
expr_stmt|;
name|printf
argument_list|(
literal|"EEK! Can't write NfsV4 stable storage file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sf
operator|->
name|nsf_flags
operator||=
name|NFSNSF_OK
expr_stmt|;
comment|/* 	 * Loop through the list and write out timestamp records for 	 * any clients that successfully reclaimed state. 	 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|sp
argument_list|,
argument|&sf->nsf_head
argument_list|,
argument|nst_list
argument_list|,
argument|nsp
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|nst_flag
operator|&
name|NFSNST_GOTSTATE
condition|)
block|{
name|nfsrv_writestable
argument_list|(
name|sp
operator|->
name|nst_client
argument_list|,
name|sp
operator|->
name|nst_len
argument_list|,
name|NFSNST_NEWSTATE
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|sp
operator|->
name|nst_clp
operator|->
name|lc_flags
operator||=
name|LCL_STAMPEDSTABLE
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|sp
argument_list|,
name|nst_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Append a record to the stable storage file.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_writestable
parameter_list|(
name|u_char
modifier|*
name|client
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flag
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsrv_stablefirst
modifier|*
name|sf
init|=
operator|&
name|nfsrv_stablefirst
decl_stmt|;
name|struct
name|nfst_rec
modifier|*
name|sp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sf
operator|->
name|nsf_flags
operator|&
name|NFSNSF_OK
operator|)
operator|||
name|sf
operator|->
name|nsf_fp
operator|==
name|NULL
condition|)
return|return;
name|sp
operator|=
operator|(
expr|struct
name|nfst_rec
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfst_rec
argument_list|)
operator|+
name|len
operator|-
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sp
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|NFSBCOPY
argument_list|(
name|client
argument_list|,
name|sp
operator|->
name|client
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sp
operator|->
name|flag
operator|=
name|flag
expr_stmt|;
name|error
operator|=
name|NFSD_RDWR
argument_list|(
name|UIO_WRITE
argument_list|,
name|NFSFPVNODE
argument_list|(
name|sf
operator|->
name|nsf_fp
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfst_rec
argument_list|)
operator|+
name|len
operator|-
literal|1
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
operator|(
name|IO_SYNC
operator||
name|IO_APPEND
operator|)
argument_list|,
name|NFSFPCRED
argument_list|(
name|sf
operator|->
name|nsf_fp
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sf
operator|->
name|nsf_flags
operator|&=
operator|~
name|NFSNSF_OK
expr_stmt|;
name|printf
argument_list|(
literal|"EEK! Can't write NfsV4 stable storage file\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function is called during the grace period to mark a client  * that successfully reclaimed state.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_markstable
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|)
block|{
name|struct
name|nfsrv_stable
modifier|*
name|sp
decl_stmt|;
comment|/* 	 * First find the client structure. 	 */
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&nfsrv_stablefirst.nsf_head
argument_list|,
argument|nst_list
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|nst_len
operator|==
name|clp
operator|->
name|lc_idlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|sp
operator|->
name|nst_client
argument_list|,
name|clp
operator|->
name|lc_id
argument_list|,
name|sp
operator|->
name|nst_len
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|sp
operator|==
name|LIST_END
argument_list|(
operator|&
name|nfsrv_stablefirst
operator|.
name|nsf_head
argument_list|)
condition|)
return|return;
comment|/* 	 * Now, just mark it and set the nfsclient back pointer. 	 */
name|sp
operator|->
name|nst_flag
operator||=
name|NFSNST_GOTSTATE
expr_stmt|;
name|sp
operator|->
name|nst_clp
operator|=
name|clp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is called for a reclaim, to see if it gets grace.  * It returns 0 if a reclaim is allowed, 1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_checkstable
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|)
block|{
name|struct
name|nfsrv_stable
modifier|*
name|sp
decl_stmt|;
comment|/* 	 * First, find the entry for the client. 	 */
name|LIST_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&nfsrv_stablefirst.nsf_head
argument_list|,
argument|nst_list
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|nst_len
operator|==
name|clp
operator|->
name|lc_idlen
operator|&&
operator|!
name|NFSBCMP
argument_list|(
name|sp
operator|->
name|nst_client
argument_list|,
name|clp
operator|->
name|lc_id
argument_list|,
name|sp
operator|->
name|nst_len
argument_list|)
condition|)
break|break;
block|}
comment|/* 	 * If not in the list, state was revoked or no state was issued 	 * since the previous reboot, a reclaim is denied. 	 */
if|if
condition|(
name|sp
operator|==
name|LIST_END
argument_list|(
operator|&
name|nfsrv_stablefirst
operator|.
name|nsf_head
argument_list|)
operator|||
operator|(
name|sp
operator|->
name|nst_flag
operator|&
name|NFSNST_REVOKE
operator|)
operator|||
operator|!
operator|(
name|nfsrv_stablefirst
operator|.
name|nsf_flags
operator|&
name|NFSNSF_OK
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test for and try to clear out a conflicting client. This is called by  * nfsrv_lockctrl() and nfsrv_openctrl() when conflicts with other clients  * a found.  * The trick here is that it can't revoke a conflicting client with an  * expired lease unless it holds the v4root lock, so...  * If no v4root lock, get the lock and return 1 to indicate "try again".  * Return 0 to indicate the conflict can't be revoked and 1 to indicate  * the revocation worked and the conflicting client is "bye, bye", so it  * can be tried again.  * Unlocks State before a non-zero value is returned.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_clientconflict
parameter_list|(
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|,
name|int
modifier|*
name|haslockp
parameter_list|,
name|__unused
name|vnode_t
name|vp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|int
name|gotlock
decl_stmt|;
comment|/* 	 * If lease hasn't expired, we can't fix it. 	 */
if|if
condition|(
name|clp
operator|->
name|lc_expiry
operator|>=
name|NFSD_MONOSEC
operator|||
operator|!
operator|(
name|nfsrv_stablefirst
operator|.
name|nsf_flags
operator|&
name|NFSNSF_UPDATEDONE
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|haslockp
operator|==
literal|0
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_relref
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|)
expr_stmt|;
do|do
block|{
name|gotlock
operator|=
name|nfsv4_lock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NFSV4ROOTLOCKMUTEXPTR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|gotlock
condition|)
do|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* to avoid a race with */
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* nfsrv_servertimer() */
operator|*
name|haslockp
operator|=
literal|1
expr_stmt|;
name|NFSVOPLOCK
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * Ok, we can expire the conflicting client. 	 */
name|nfsrv_writestable
argument_list|(
name|clp
operator|->
name|lc_id
argument_list|,
name|clp
operator|->
name|lc_idlen
argument_list|,
name|NFSNST_REVOKE
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfsrv_cleanclient
argument_list|(
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfsrv_freedeleglist
argument_list|(
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|)
expr_stmt|;
name|nfsrv_freedeleglist
argument_list|(
operator|&
name|clp
operator|->
name|lc_olddeleg
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|clp
argument_list|,
name|lc_hash
argument_list|)
expr_stmt|;
name|nfsrv_zapclient
argument_list|(
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Resolve a delegation conflict.  * Returns 0 to indicate the conflict was resolved without sleeping.  * Return -1 to indicate that the caller should check for conflicts again.  * Return> 0 for an error that should be returned, normally NFSERR_DELAY.  *  * Also, manipulate the nfsv4root_lock, as required. It isn't changed  * for a return of 0, since there was no sleep and it could be required  * later. It is released for a return of NFSERR_DELAY, since the caller  * will return that error. It is released when a sleep was done waiting  * for the delegation to be returned or expire (so that other nfsds can  * handle ops). Then, it must be acquired for the write to stable storage.  * (This function is somewhat similar to nfsrv_clientconflict(), but  *  the semantics differ in a couple of subtle ways. The return of 0  *  indicates the conflict was resolved without sleeping here, not  *  that the conflict can't be resolved and the handling of nfsv4root_lock  *  differs, as noted above.)  * Unlocks State before returning a non-zero value.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_delegconflict
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|int
modifier|*
name|haslockp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|__unused
name|vnode_t
name|vp
parameter_list|)
block|{
name|struct
name|nfsclient
modifier|*
name|clp
init|=
name|stp
operator|->
name|ls_clp
decl_stmt|;
name|int
name|gotlock
decl_stmt|,
name|error
decl_stmt|,
name|retrycnt
decl_stmt|,
name|zapped_clp
decl_stmt|;
name|nfsv4stateid_t
name|tstateid
decl_stmt|;
name|fhandle_t
name|tfh
decl_stmt|;
comment|/* 	 * If the conflict is with an old delegation... 	 */
if|if
condition|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_OLDDELEG
condition|)
block|{
comment|/* 		 * You can delete it, if it has expired. 		 */
if|if
condition|(
name|clp
operator|->
name|lc_delegtime
operator|<
name|NFSD_MONOSEC
condition|)
block|{
name|nfsrv_freedeleg
argument_list|(
name|stp
argument_list|)
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* 		 * During this delay, the old delegation could expire or it 		 * could be recovered by the client via an Open with 		 * CLAIM_DELEGATE_PREV. 		 * Release the nfsv4root_lock, if held. 		 */
if|if
condition|(
operator|*
name|haslockp
condition|)
block|{
operator|*
name|haslockp
operator|=
literal|0
expr_stmt|;
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|NFSERR_DELAY
operator|)
return|;
block|}
comment|/* 	 * It's a current delegation, so: 	 * - check to see if the delegation has expired 	 *   - if so, get the v4root lock and then expire it 	 */
if|if
condition|(
operator|!
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGRECALL
operator|)
condition|)
block|{
comment|/* 		 * - do a recall callback, since not yet done 		 * For now, never allow truncate to be set. To use 		 * truncate safely, it must be guaranteed that the 		 * Remove, Rename or Setattr with size of 0 will 		 * succeed and that would require major changes to 		 * the VFS/Vnode OPs. 		 * Set the expiry time large enough so that it won't expire 		 * until after the callback, then set it correctly, once 		 * the callback is done. (The delegation will now time 		 * out whether or not the Recall worked ok. The timeout 		 * will be extended when ops are done on the delegation 		 * stateid, up to the timelimit.) 		 */
name|stp
operator|->
name|ls_delegtime
operator|=
name|NFSD_MONOSEC
operator|+
operator|(
literal|2
operator|*
name|nfsrv_lease
operator|)
operator|+
name|NFSRV_LEASEDELTA
expr_stmt|;
name|stp
operator|->
name|ls_delegtimelimit
operator|=
name|NFSD_MONOSEC
operator|+
operator|(
literal|6
operator|*
name|nfsrv_lease
operator|)
operator|+
name|NFSRV_LEASEDELTA
expr_stmt|;
name|stp
operator|->
name|ls_flags
operator||=
name|NFSLCK_DELEGRECALL
expr_stmt|;
comment|/* 		 * Loop NFSRV_CBRETRYCNT times while the CBRecall replies 		 * NFSERR_BADSTATEID or NFSERR_BADHANDLE. This is done 		 * in order to try and avoid a race that could happen 		 * when a CBRecall request passed the Open reply with 		 * the delegation in it when transitting the network. 		 * Since nfsrv_docallback will sleep, don't use stp after 		 * the call. 		 */
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|stp
operator|->
name|ls_stateid
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tstateid
argument_list|,
sizeof|sizeof
argument_list|(
name|tstateid
argument_list|)
argument_list|)
expr_stmt|;
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|stp
operator|->
name|ls_lfp
operator|->
name|lf_fh
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tfh
argument_list|,
sizeof|sizeof
argument_list|(
name|tfh
argument_list|)
argument_list|)
expr_stmt|;
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|haslockp
condition|)
block|{
operator|*
name|haslockp
operator|=
literal|0
expr_stmt|;
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
name|retrycnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrv_docallback
argument_list|(
name|clp
argument_list|,
name|NFSV4OP_CBRECALL
argument_list|,
operator|&
name|tstateid
argument_list|,
literal|0
argument_list|,
operator|&
name|tfh
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|retrycnt
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|error
operator|==
name|NFSERR_BADSTATEID
operator|||
name|error
operator|==
name|NFSERR_BADHANDLE
operator|)
operator|&&
name|retrycnt
operator|<
name|NFSV4_CBRETRYCNT
condition|)
do|;
return|return
operator|(
name|NFSERR_DELAY
operator|)
return|;
block|}
if|if
condition|(
name|clp
operator|->
name|lc_expiry
operator|>=
name|NFSD_MONOSEC
operator|&&
name|stp
operator|->
name|ls_delegtime
operator|>=
name|NFSD_MONOSEC
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* 		 * A recall has been done, but it has not yet expired. 		 * So, RETURN_DELAY. 		 */
if|if
condition|(
operator|*
name|haslockp
condition|)
block|{
operator|*
name|haslockp
operator|=
literal|0
expr_stmt|;
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|NFSERR_DELAY
operator|)
return|;
block|}
comment|/* 	 * If we don't yet have the lock, just get it and then return, 	 * since we need that before deleting expired state, such as 	 * this delegation. 	 * When getting the lock, unlock the vnode, so other nfsds that 	 * are in progress, won't get stuck waiting for the vnode lock. 	 */
if|if
condition|(
operator|*
name|haslockp
operator|==
literal|0
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_relref
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|)
expr_stmt|;
do|do
block|{
name|gotlock
operator|=
name|nfsv4_lock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|NFSV4ROOTLOCKMUTEXPTR
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|gotlock
condition|)
do|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* to avoid a race with */
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* nfsrv_servertimer() */
operator|*
name|haslockp
operator|=
literal|1
expr_stmt|;
name|NFSVOPLOCK
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
comment|/* 	 * Ok, we can delete the expired delegation. 	 * First, write the Revoke record to stable storage and then 	 * clear out the conflict. 	 * Since all other nfsd threads are now blocked, we can safely 	 * sleep without the state changing. 	 */
name|nfsrv_writestable
argument_list|(
name|clp
operator|->
name|lc_id
argument_list|,
name|clp
operator|->
name|lc_idlen
argument_list|,
name|NFSNST_REVOKE
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|clp
operator|->
name|lc_expiry
operator|<
name|NFSD_MONOSEC
condition|)
block|{
name|nfsrv_cleanclient
argument_list|(
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|nfsrv_freedeleglist
argument_list|(
operator|&
name|clp
operator|->
name|lc_deleg
argument_list|)
expr_stmt|;
name|nfsrv_freedeleglist
argument_list|(
operator|&
name|clp
operator|->
name|lc_olddeleg
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|clp
argument_list|,
name|lc_hash
argument_list|)
expr_stmt|;
name|zapped_clp
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nfsrv_freedeleg
argument_list|(
name|stp
argument_list|)
expr_stmt|;
name|zapped_clp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|zapped_clp
condition|)
name|nfsrv_zapclient
argument_list|(
name|clp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for a remove allowed, if remove is set to 1 and get rid of  * delegations.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_checkremove
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|int
name|remove
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|;
name|struct
name|nfslockfile
modifier|*
name|lfp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|haslock
init|=
literal|0
decl_stmt|;
name|fhandle_t
name|nfh
decl_stmt|;
comment|/* 	 * First, get the lock file structure. 	 * (A return of -1 means no associated state, so remove ok.) 	 */
name|error
operator|=
name|nfsrv_getlockfh
argument_list|(
name|vp
argument_list|,
name|NFSLCK_CHECK
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfh
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|tryagain
label|:
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_getlockfile
argument_list|(
name|NFSLCK_CHECK
argument_list|,
name|NULL
argument_list|,
operator|&
name|lfp
argument_list|,
operator|&
name|nfh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Now, we must Recall any delegations. 	 */
name|error
operator|=
name|nfsrv_cleandeleg
argument_list|(
name|vp
argument_list|,
name|lfp
argument_list|,
name|NULL
argument_list|,
operator|&
name|haslock
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * nfsrv_cleandeleg() unlocks state for non-zero 		 * return. 		 */
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
goto|goto
name|tryagain
goto|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Now, look for a conflicting open share. 	 */
if|if
condition|(
name|remove
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&lfp->lf_open
argument_list|,
argument|ls_file
argument_list|)
block|{
if|if
condition|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_WRITEDENY
condition|)
block|{
name|error
operator|=
name|NFSERR_FILEOPEN
expr_stmt|;
break|break;
block|}
block|}
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|haslock
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_unlock
argument_list|(
operator|&
name|nfsv4rootfs_lock
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear out all delegations for the file referred to by lfp.  * May return NFSERR_DELAY, if there will be a delay waiting for  * delegations to expire.  * Returns -1 to indicate it slept while recalling a delegation.  * This function has the side effect of deleting the nfslockfile structure,  * if it no longer has associated state and didn't have to sleep.  * Unlocks State before a non-zero value is returned.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_cleandeleg
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfslockfile
modifier|*
name|lfp
parameter_list|,
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|,
name|int
modifier|*
name|haslockp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|,
modifier|*
name|nstp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|stp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
expr_stmt|;
while|while
condition|(
name|stp
operator|!=
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
condition|)
block|{
name|nstp
operator|=
name|LIST_NEXT
argument_list|(
name|stp
argument_list|,
name|ls_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|ls_clp
operator|!=
name|clp
condition|)
block|{
name|ret
operator|=
name|nfsrv_delegconflict
argument_list|(
name|stp
argument_list|,
name|haslockp
argument_list|,
name|p
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* 				 * nfsrv_delegconflict() unlocks state 				 * when it returns non-zero. 				 */
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
name|stp
operator|=
name|nstp
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * There are certain operations that, when being done outside of NFSv4,  * require that any NFSv4 delegation for the file be recalled.  * This function is to be called for those cases:  * VOP_RENAME() - When a delegation is being recalled for any reason,  *	the client may have to do Opens against the server, using the file's  *	final component name. If the file has been renamed on the server,  *	that component name will be incorrect and the Open will fail.  * VOP_REMOVE() - Theoretically, a client could Open a file after it has  *	been removed on the server, if there is a delegation issued to  *	that client for the file. I say "theoretically" since clients  *	normally do an Access Op before the Open and that Access Op will  *	fail with ESTALE. Note that NFSv2 and 3 don't even do Opens, so  *	they will detect the file's removal in the same manner. (There is  *	one case where RFC3530 allows a client to do an Open without first  *	doing an Access Op, which is passage of a check against the ACE  *	returned with a Write delegation, but current practice is to ignore  *	the ACE and always do an Access Op.)  *	Since the functions can only be called with an unlocked vnode, this  *	can't be done at this time.  * VOP_ADVLOCK() - When a client holds a delegation, it can issue byte range  *	locks locally in the client, which are not visible to the server. To  *	deal with this, issuing of delegations for a vnode must be disabled  *	and all delegations for the vnode recalled. This is done via the  *	second function, using the VV_DISABLEDELEG vflag on the vnode.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsd_recalldelegation
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|timespec
name|mytime
decl_stmt|;
name|int32_t
name|starttime
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|(
literal|"vp %p is locked"
operator|,
name|vp
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * First, check to see if the server is currently running and it has 	 * been called for a regular file when issuing delegations. 	 */
if|if
condition|(
name|newnfs_numnfsd
operator|==
literal|0
operator|||
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|||
name|nfsrv_issuedelegs
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Now, call nfsrv_checkremove() in a loop while it returns 	 * NFSERR_DELAY. Return upon any other error or when timed out. 	 */
name|NFSGETNANOTIME
argument_list|(
operator|&
name|mytime
argument_list|)
expr_stmt|;
name|starttime
operator|=
operator|(
name|u_int32_t
operator|)
name|mytime
operator|.
name|tv_sec
expr_stmt|;
do|do
block|{
name|error
operator|=
name|nfsrv_checkremove
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
block|{
name|NFSGETNANOTIME
argument_list|(
operator|&
name|mytime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|u_int32_t
operator|)
name|mytime
operator|.
name|tv_sec
operator|-
name|starttime
operator|)
operator|>
name|NFS_REMOVETIMEO
operator|&&
operator|(
operator|(
name|u_int32_t
operator|)
name|mytime
operator|.
name|tv_sec
operator|-
name|starttime
operator|)
operator|<
literal|100000
condition|)
return|return;
comment|/* Sleep for a short period of time */
operator|(
name|void
operator|)
name|nfs_catnap
argument_list|(
name|PZERO
argument_list|,
literal|"nfsremove"
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|NFSERR_DELAY
condition|)
do|;
block|}
end_function

begin_function
name|APPLESTATIC
name|void
name|nfsd_disabledelegation
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VV_DISABLEDELEG
comment|/* 	 * First, flag issuance of delegations disabled. 	 */
name|atomic_set_long
argument_list|(
operator|&
name|vp
operator|->
name|v_vflag
argument_list|,
name|VV_DISABLEDELEG
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Then call nfsd_recalldelegation() to get rid of all extant 	 * delegations. 	 */
name|nfsd_recalldelegation
argument_list|(
name|vp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check for conflicting locks, etc. and then get rid of delegations.  * (At one point I thought that I should get rid of delegations for any  *  Setattr, since it could potentially disallow the I/O op (read or write)  *  allowed by the delegation. However, Setattr Ops that aren't changing  *  the size get a stateid of all 0s, so you can't tell if it is a delegation  *  for the same client or a different one, so I decided to only get rid  *  of delegations for other clients when the size is being changed.)  * In general, a Setattr can disable NFS I/O Ops that are outstanding, such  * as Write backs, even if there is no delegation, so it really isn't any  * different?)  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_checksetattr
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|nfsattrbit_t
modifier|*
name|attrbitp
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsstate
name|st
decl_stmt|,
modifier|*
name|stp
init|=
operator|&
name|st
decl_stmt|;
name|struct
name|nfslock
name|lo
decl_stmt|,
modifier|*
name|lop
init|=
operator|&
name|lo
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|nfsquad_t
name|clientid
decl_stmt|;
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_SIZE
argument_list|)
condition|)
block|{
name|stp
operator|->
name|ls_flags
operator|=
operator|(
name|NFSLCK_CHECK
operator||
name|NFSLCK_WRITEACCESS
operator|)
expr_stmt|;
name|lop
operator|->
name|lo_first
operator|=
name|nvap
operator|->
name|na_size
expr_stmt|;
block|}
else|else
block|{
name|stp
operator|->
name|ls_flags
operator|=
literal|0
expr_stmt|;
name|lop
operator|->
name|lo_first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_OWNER
argument_list|)
operator|||
name|NFSISSET_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_OWNERGROUP
argument_list|)
operator|||
name|NFSISSET_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_MODE
argument_list|)
operator|||
name|NFSISSET_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_ACL
argument_list|)
condition|)
name|stp
operator|->
name|ls_flags
operator||=
name|NFSLCK_SETATTR
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|ls_flags
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lop
operator|->
name|lo_end
operator|=
name|NFS64BITSSET
expr_stmt|;
name|lop
operator|->
name|lo_flags
operator|=
name|NFSLCK_WRITE
expr_stmt|;
name|stp
operator|->
name|ls_ownerlen
operator|=
literal|0
expr_stmt|;
name|stp
operator|->
name|ls_op
operator|=
name|NULL
expr_stmt|;
name|stp
operator|->
name|ls_uid
operator|=
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
expr_stmt|;
name|stp
operator|->
name|ls_stateid
operator|.
name|seqid
operator|=
name|stateidp
operator|->
name|seqid
expr_stmt|;
name|clientid
operator|.
name|lval
index|[
literal|0
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|0
index|]
operator|=
name|stateidp
operator|->
name|other
index|[
literal|0
index|]
expr_stmt|;
name|clientid
operator|.
name|lval
index|[
literal|1
index|]
operator|=
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|1
index|]
operator|=
name|stateidp
operator|->
name|other
index|[
literal|1
index|]
expr_stmt|;
name|stp
operator|->
name|ls_stateid
operator|.
name|other
index|[
literal|2
index|]
operator|=
name|stateidp
operator|->
name|other
index|[
literal|2
index|]
expr_stmt|;
name|error
operator|=
name|nfsrv_lockctrl
argument_list|(
name|vp
argument_list|,
operator|&
name|stp
argument_list|,
operator|&
name|lop
argument_list|,
name|NULL
argument_list|,
name|clientid
argument_list|,
name|stateidp
argument_list|,
name|exp
argument_list|,
name|nd
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for a write delegation and do a CBGETATTR if there is one, updating  * the attributes, as required.  * Should I return an error if I can't get the attributes? (For now, I'll  * just return ok.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_checkgetattr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|nfsattrbit_t
modifier|*
name|attrbitp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|;
name|struct
name|nfslockfile
modifier|*
name|lfp
decl_stmt|;
name|struct
name|nfsclient
modifier|*
name|clp
decl_stmt|;
name|struct
name|nfsvattr
name|nva
decl_stmt|;
name|fhandle_t
name|nfh
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfsattrbit_t
name|cbbits
decl_stmt|;
name|u_quad_t
name|delegfilerev
decl_stmt|;
name|NFSCBGETATTR_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
operator|&
name|cbbits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NFSNONZERO_ATTRBIT
argument_list|(
operator|&
name|cbbits
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Get the lock file structure. 	 * (A return of -1 means no associated state, so return ok.) 	 */
name|error
operator|=
name|nfsrv_getlockfh
argument_list|(
name|vp
argument_list|,
name|NFSLCK_CHECK
argument_list|,
name|NULL
argument_list|,
operator|&
name|nfh
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_getlockfile
argument_list|(
name|NFSLCK_CHECK
argument_list|,
name|NULL
argument_list|,
operator|&
name|lfp
argument_list|,
operator|&
name|nfh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Now, look for a write delegation. 	 */
name|LIST_FOREACH
argument_list|(
argument|stp
argument_list|,
argument|&lfp->lf_deleg
argument_list|,
argument|ls_file
argument_list|)
block|{
if|if
condition|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGWRITE
condition|)
break|break;
block|}
if|if
condition|(
name|stp
operator|==
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_deleg
argument_list|)
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|clp
operator|=
name|stp
operator|->
name|ls_clp
expr_stmt|;
name|delegfilerev
operator|=
name|stp
operator|->
name|ls_filerev
expr_stmt|;
comment|/* 	 * If the Write delegation was issued as a part of this Compound RPC 	 * or if we have an Implied Clientid (used in a previous Op in this 	 * compound) and it is the client the delegation was issued to, 	 * just return ok. 	 * I also assume that it is from the same client iff the network 	 * host IP address is the same as the callback address. (Not 	 * exactly correct by the RFC, but avoids a lot of Getattr 	 * callbacks.) 	 */
if|if
condition|(
name|nd
operator|->
name|nd_compref
operator|==
name|stp
operator|->
name|ls_compref
operator|||
operator|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_IMPLIEDCLID
operator|)
operator|&&
name|clp
operator|->
name|lc_clientid
operator|.
name|qval
operator|==
name|nd
operator|->
name|nd_clientid
operator|.
name|qval
operator|)
operator|||
name|nfsaddr2_match
argument_list|(
name|clp
operator|->
name|lc_req
operator|.
name|nr_nam
argument_list|,
name|nd
operator|->
name|nd_nam
argument_list|)
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We are now done with the delegation state structure, 	 * so the statelock can be released and we can now tsleep(). 	 */
comment|/* 	 * Now, we must do the CB Getattr callback, to see if Change or Size 	 * has changed. 	 */
if|if
condition|(
name|clp
operator|->
name|lc_expiry
operator|>=
name|NFSD_MONOSEC
condition|)
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
name|NFSVNO_ATTRINIT
argument_list|(
operator|&
name|nva
argument_list|)
expr_stmt|;
name|nva
operator|.
name|na_filerev
operator|=
name|NFS64BITSSET
expr_stmt|;
name|error
operator|=
name|nfsrv_docallback
argument_list|(
name|clp
argument_list|,
name|NFSV4OP_CBGETATTR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|nfh
argument_list|,
operator|&
name|nva
argument_list|,
operator|&
name|cbbits
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
operator|(
name|nva
operator|.
name|na_filerev
operator|!=
name|NFS64BITSSET
operator|&&
name|nva
operator|.
name|na_filerev
operator|>
name|delegfilerev
operator|)
operator|||
operator|(
name|NFSVNO_ISSETSIZE
argument_list|(
operator|&
name|nva
argument_list|)
operator|&&
name|nva
operator|.
name|na_size
operator|!=
name|nvap
operator|->
name|na_size
operator|)
condition|)
block|{
name|nfsvno_updfilerev
argument_list|(
name|vp
argument_list|,
name|nvap
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSVNO_ISSETSIZE
argument_list|(
operator|&
name|nva
argument_list|)
condition|)
name|nvap
operator|->
name|na_size
operator|=
name|nva
operator|.
name|na_size
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function looks for openowners that haven't had any opens for  * a while and throws them away. Called by an nfsd when NFSNSF_NOOPENS  * is set.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_throwawayopens
parameter_list|(
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsclient
modifier|*
name|clp
decl_stmt|,
modifier|*
name|nclp
decl_stmt|;
name|struct
name|nfsstate
modifier|*
name|stp
decl_stmt|,
modifier|*
name|nstp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|NFSLOCKSTATE
argument_list|()
expr_stmt|;
name|nfsrv_stablefirst
operator|.
name|nsf_flags
operator|&=
operator|~
name|NFSNSF_NOOPENS
expr_stmt|;
comment|/* 	 * For each client... 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSCLIENTHASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|clp
argument_list|,
argument|&nfsclienthash[i]
argument_list|,
argument|lc_hash
argument_list|,
argument|nclp
argument_list|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|stp
argument_list|,
argument|&clp->lc_open
argument_list|,
argument|ls_list
argument_list|,
argument|nstp
argument_list|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|stp
operator|->
name|ls_open
argument_list|)
operator|&&
operator|(
name|stp
operator|->
name|ls_noopens
operator|>
name|NFSNOOPEN
operator|||
operator|(
name|nfsrv_openpluslock
operator|*
literal|2
operator|)
operator|>
name|NFSRV_V4STATELIMIT
operator|)
condition|)
name|nfsrv_freeopenowner
argument_list|(
name|stp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|NFSUNLOCKSTATE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function checks to see if the credentials are the same.  * Returns 1 for not same, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_notsamecredname
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsclient
modifier|*
name|clp
parameter_list|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_GSS
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_GSS
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_NAME
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_princlen
operator|!=
name|clp
operator|->
name|lc_namelen
operator|||
name|NFSBCMP
argument_list|(
name|nd
operator|->
name|nd_principal
argument_list|,
name|clp
operator|->
name|lc_name
argument_list|,
name|clp
operator|->
name|lc_namelen
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
operator|==
name|clp
operator|->
name|lc_uid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|clp
operator|->
name|lc_flags
operator|&
name|LCL_GSS
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * For AUTH_SYS, allow the same uid or root. (This is underspecified 	 * in RFC3530, which talks about principals, but doesn't say anything 	 * about uids for AUTH_SYS.) 	 */
if|if
condition|(
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
operator|==
name|clp
operator|->
name|lc_uid
operator|||
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the lease expiry time.  */
end_comment

begin_function
specifier|static
name|time_t
name|nfsrv_leaseexpiry
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|curtime
decl_stmt|;
name|NFSGETTIME
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfsrv_stablefirst
operator|.
name|nsf_eograce
operator|>
name|NFSD_MONOSEC
condition|)
return|return
operator|(
name|NFSD_MONOSEC
operator|+
literal|2
operator|*
operator|(
name|nfsrv_lease
operator|+
name|NFSRV_LEASEDELTA
operator|)
operator|)
return|;
return|return
operator|(
name|NFSD_MONOSEC
operator|+
name|nfsrv_lease
operator|+
name|NFSRV_LEASEDELTA
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delay the delegation timeout as far as ls_delegtimelimit, as required.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_delaydelegtimeout
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|stp
operator|->
name|ls_flags
operator|&
name|NFSLCK_DELEGRECALL
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|stp
operator|->
name|ls_delegtime
operator|+
literal|15
operator|)
operator|>
name|NFSD_MONOSEC
operator|&&
name|stp
operator|->
name|ls_delegtime
operator|<
name|stp
operator|->
name|ls_delegtimelimit
condition|)
block|{
name|stp
operator|->
name|ls_delegtime
operator|+=
name|nfsrv_lease
expr_stmt|;
if|if
condition|(
name|stp
operator|->
name|ls_delegtime
operator|>
name|stp
operator|->
name|ls_delegtimelimit
condition|)
name|stp
operator|->
name|ls_delegtime
operator|=
name|stp
operator|->
name|ls_delegtimelimit
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Go through a lock list and set local locks for all ranges.  * This assumes that the lock list is sorted on increasing  * lo_first and that the list won't change, despite the possibility  * of sleeps.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrv_locallocks
parameter_list|(
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfslockfile
modifier|*
name|lfp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfslock
modifier|*
name|lop
decl_stmt|,
modifier|*
name|nlop
decl_stmt|;
name|vnode_t
name|tvp
decl_stmt|;
name|int
name|newcollate
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
name|u_int64_t
name|first
init|=
literal|0x0ull
decl_stmt|,
name|end
init|=
literal|0x0ull
decl_stmt|;
if|if
condition|(
operator|!
name|nfsrv_dolocallocks
condition|)
return|return;
comment|/* 	 * If vp is NULL, a vnode must be aquired from the file 	 * handle. 	 */
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lfp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfsrv_locallocks"
argument_list|)
expr_stmt|;
name|tvp
operator|=
name|nfsvno_getvp
argument_list|(
operator|&
name|lfp
operator|->
name|lf_fh
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|==
name|NULL
condition|)
return|return;
block|}
else|else
block|{
name|tvp
operator|=
name|vp
expr_stmt|;
block|}
comment|/* 	 * If lfp == NULL, the lock list is empty, so just unlock 	 * everything. 	 */
if|if
condition|(
name|lfp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|nfsvno_advlock
argument_list|(
name|tvp
argument_list|,
name|F_UNLCK
argument_list|,
operator|(
name|u_int64_t
operator|)
literal|0
argument_list|,
name|NFS64BITSSET
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* vp can't be NULL */
return|return;
block|}
comment|/* handle whole file case first */
name|lop
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lop
operator|!=
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
operator|&&
name|lop
operator|->
name|lo_first
operator|==
operator|(
name|u_int64_t
operator|)
literal|0
operator|&&
name|lop
operator|->
name|lo_end
operator|==
name|NFS64BITSSET
condition|)
block|{
if|if
condition|(
name|lop
operator|->
name|lo_flags
operator|&
name|NFSLCK_WRITE
condition|)
operator|(
name|void
operator|)
name|nfsvno_advlock
argument_list|(
name|tvp
argument_list|,
name|F_WRLCK
argument_list|,
name|lop
operator|->
name|lo_first
argument_list|,
name|lop
operator|->
name|lo_end
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|nfsvno_advlock
argument_list|(
name|tvp
argument_list|,
name|F_RDLCK
argument_list|,
name|lop
operator|->
name|lo_first
argument_list|,
name|lop
operator|->
name|lo_end
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Now, handle the separate byte ranges cases. 	 */
operator|(
name|void
operator|)
name|nfsvno_advlock
argument_list|(
name|tvp
argument_list|,
name|F_UNLCK
argument_list|,
operator|(
name|u_int64_t
operator|)
literal|0
argument_list|,
name|NFS64BITSSET
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|newcollate
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|lop
operator|!=
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
condition|)
block|{
name|nlop
operator|=
name|LIST_NEXT
argument_list|(
name|lop
argument_list|,
name|lo_lckfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|newcollate
condition|)
block|{
name|first
operator|=
name|lop
operator|->
name|lo_first
expr_stmt|;
name|end
operator|=
name|lop
operator|->
name|lo_end
expr_stmt|;
name|flags
operator|=
name|lop
operator|->
name|lo_flags
expr_stmt|;
name|newcollate
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nlop
operator|!=
name|LIST_END
argument_list|(
operator|&
name|lfp
operator|->
name|lf_lock
argument_list|)
operator|&&
name|flags
operator|==
name|nlop
operator|->
name|lo_flags
operator|&&
name|end
operator|>=
name|nlop
operator|->
name|lo_first
condition|)
block|{
comment|/* can collate this one */
name|end
operator|=
name|nlop
operator|->
name|lo_end
expr_stmt|;
block|}
else|else
block|{
comment|/* do the local lock and start again */
if|if
condition|(
name|flags
operator|&
name|NFSLCK_WRITE
condition|)
operator|(
name|void
operator|)
name|nfsvno_advlock
argument_list|(
name|tvp
argument_list|,
name|F_WRLCK
argument_list|,
name|first
argument_list|,
name|end
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|nfsvno_advlock
argument_list|(
name|tvp
argument_list|,
name|F_RDLCK
argument_list|,
name|first
argument_list|,
name|end
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|newcollate
operator|=
literal|1
expr_stmt|;
block|}
name|lop
operator|=
name|nlop
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function checks to see if there is any other state associated  * with the openowner for this Open.  * It returns 1 if there is no other state, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrv_nootherstate
parameter_list|(
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|)
block|{
name|struct
name|nfsstate
modifier|*
name|tstp
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|tstp
argument_list|,
argument|&stp->ls_openowner->ls_open
argument_list|,
argument|ls_list
argument_list|)
block|{
if|if
condition|(
name|tstp
operator|!=
name|stp
operator|||
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|tstp
operator|->
name|ls_lock
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

