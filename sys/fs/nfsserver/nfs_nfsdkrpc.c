begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_kgssapi.h"
end_include

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpcsec_gss.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfs_fha.h>
end_include

begin_include
include|#
directive|include
file|<fs/nfsserver/nfs_fha_new.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_expr_stmt
name|NFSDLOCKMUTEX
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NFSV4ROOTLOCKMUTEX
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|nfsv4lock
name|nfsd_suspend_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Mapping of old NFS Version 2 RPC numbers to generic numbers.  */
end_comment

begin_decl_stmt
name|int
name|newnfs_nfsv3_procid
index|[
name|NFS_V3NPROCS
index|]
init|=
block|{
name|NFSPROC_NULL
block|,
name|NFSPROC_GETATTR
block|,
name|NFSPROC_SETATTR
block|,
name|NFSPROC_NOOP
block|,
name|NFSPROC_LOOKUP
block|,
name|NFSPROC_READLINK
block|,
name|NFSPROC_READ
block|,
name|NFSPROC_NOOP
block|,
name|NFSPROC_WRITE
block|,
name|NFSPROC_CREATE
block|,
name|NFSPROC_REMOVE
block|,
name|NFSPROC_RENAME
block|,
name|NFSPROC_LINK
block|,
name|NFSPROC_SYMLINK
block|,
name|NFSPROC_MKDIR
block|,
name|NFSPROC_RMDIR
block|,
name|NFSPROC_READDIR
block|,
name|NFSPROC_FSSTAT
block|,
name|NFSPROC_NOOP
block|,
name|NFSPROC_NOOP
block|,
name|NFSPROC_NOOP
block|,
name|NFSPROC_NOOP
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_nfsd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|SVCPOOL
modifier|*
name|nfsrvd_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_privport
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfsd
argument_list|,
name|OID_AUTO
argument_list|,
name|nfs_privport
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_privport
argument_list|,
literal|0
argument_list|,
literal|"Only allow clients using a privileged port for NFSv2 and 3"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_minvers
init|=
name|NFS_VER2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfsd
argument_list|,
name|OID_AUTO
argument_list|,
name|server_min_nfsvers
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_minvers
argument_list|,
literal|0
argument_list|,
literal|"The lowest version of NFS handled by the server"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_maxvers
init|=
name|NFS_VER4
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfsd
argument_list|,
name|OID_AUTO
argument_list|,
name|server_max_nfsvers
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_maxvers
argument_list|,
literal|0
argument_list|,
literal|"The highest version of NFS handled by the server"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|nfs_proc
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|SVCXPRT
modifier|*
name|xprt
parameter_list|,
name|struct
name|nfsrvcache
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|u_long
name|sb_max_adj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|newnfs_numnfsd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|proc
modifier|*
name|nfsd_master_proc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * NFS server system calls  */
end_comment

begin_function
specifier|static
name|void
name|nfssvc_program
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqst
parameter_list|,
name|SVCXPRT
modifier|*
name|xprt
parameter_list|)
block|{
name|struct
name|nfsrv_descript
name|nd
decl_stmt|;
name|struct
name|nfsrvcache
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
name|int
name|cacherep
decl_stmt|,
name|credflavor
decl_stmt|;
name|memset
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqst
operator|->
name|rq_vers
operator|==
name|NFS_VER2
condition|)
block|{
if|if
condition|(
name|rqst
operator|->
name|rq_proc
operator|>
name|NFSV2PROC_STATFS
condition|)
block|{
name|svcerr_noproc
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|nd
operator|.
name|nd_procnum
operator|=
name|newnfs_nfsv3_procid
index|[
name|rqst
operator|->
name|rq_proc
index|]
expr_stmt|;
name|nd
operator|.
name|nd_flag
operator|=
name|ND_NFSV2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rqst
operator|->
name|rq_vers
operator|==
name|NFS_VER3
condition|)
block|{
if|if
condition|(
name|rqst
operator|->
name|rq_proc
operator|>=
name|NFS_V3NPROCS
condition|)
block|{
name|svcerr_noproc
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|nd
operator|.
name|nd_procnum
operator|=
name|rqst
operator|->
name|rq_proc
expr_stmt|;
name|nd
operator|.
name|nd_flag
operator|=
name|ND_NFSV3
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rqst
operator|->
name|rq_proc
operator|!=
name|NFSPROC_NULL
operator|&&
name|rqst
operator|->
name|rq_proc
operator|!=
name|NFSV4PROC_COMPOUND
condition|)
block|{
name|svcerr_noproc
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|nd
operator|.
name|nd_procnum
operator|=
name|rqst
operator|->
name|rq_proc
expr_stmt|;
name|nd
operator|.
name|nd_flag
operator|=
name|ND_NFSV4
expr_stmt|;
block|}
comment|/* 	 * Note: we want rq_addr, not svc_getrpccaller for nd_nam2 - 	 * NFS_SRVMAXDATA uses a NULL value for nd_nam2 to detect TCP 	 * mounts. 	 */
name|nd
operator|.
name|nd_mrep
operator|=
name|rqst
operator|->
name|rq_args
expr_stmt|;
name|rqst
operator|->
name|rq_args
operator|=
name|NULL
expr_stmt|;
name|newnfs_realign
argument_list|(
operator|&
name|nd
operator|.
name|nd_mrep
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nd
operator|.
name|nd_md
operator|=
name|nd
operator|.
name|nd_mrep
expr_stmt|;
name|nd
operator|.
name|nd_dpos
operator|=
name|mtod
argument_list|(
name|nd
operator|.
name|nd_md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|nd
operator|.
name|nd_nam
operator|=
name|svc_getrpccaller
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|nd
operator|.
name|nd_nam2
operator|=
name|rqst
operator|->
name|rq_addr
expr_stmt|;
name|nd
operator|.
name|nd_mreq
operator|=
name|NULL
expr_stmt|;
name|nd
operator|.
name|nd_cred
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nfs_privport
operator|&&
operator|(
name|nd
operator|.
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Check if source port is privileged */
name|u_short
name|port
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
init|=
name|nd
operator|.
name|nd_nam
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nam
expr_stmt|;
comment|/* 		 * INET/INET6 - same code: 		 *    sin_port and sin6_port are at same offset 		 */
name|port
operator|=
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|>=
name|IPPORT_RESERVED
operator|&&
name|nd
operator|.
name|nd_procnum
operator|!=
name|NFSPROC_NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
name|char
name|b6
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|KLD_MODULE
argument_list|)
comment|/* Do not use ip6_sprintf: the nfs module should work without INET6. */
define|#
directive|define
name|ip6_sprintf
parameter_list|(
name|buf
parameter_list|,
name|a
parameter_list|)
define|\
value|(sprintf((buf), "%x:%x:%x:%x:%x:%x:%x:%x",	\ 			    (a)->s6_addr16[0], (a)->s6_addr16[1],	\ 			    (a)->s6_addr16[2], (a)->s6_addr16[3],	\ 			    (a)->s6_addr16[4], (a)->s6_addr16[5],	\ 			    (a)->s6_addr16[6], (a)->s6_addr16[7]),	\ 			    (buf))
endif|#
directive|endif
endif|#
directive|endif
name|printf
argument_list|(
literal|"NFS request from unprivileged port (%s:%d)\n"
argument_list|,
ifdef|#
directive|ifdef
name|INET6
name|sin
operator|->
name|sin_family
operator|==
name|AF_INET6
condition|?
name|ip6_sprintf
argument_list|(
name|b6
argument_list|,
operator|&
name|satosin6
argument_list|(
name|sin
argument_list|)
operator|->
name|sin6_addr
argument_list|)
else|:
if|#
directive|if
name|defined
argument_list|(
name|KLD_MODULE
argument_list|)
undef|#
directive|undef
name|ip6_sprintf
endif|#
directive|endif
endif|#
directive|endif
name|inet_ntoa
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|svcerr_weakauth
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|nd
operator|.
name|nd_mrep
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|nd
operator|.
name|nd_procnum
operator|!=
name|NFSPROC_NULL
condition|)
block|{
if|if
condition|(
operator|!
name|svc_getcred
argument_list|(
name|rqst
argument_list|,
operator|&
name|nd
operator|.
name|nd_cred
argument_list|,
operator|&
name|credflavor
argument_list|)
condition|)
block|{
name|svcerr_weakauth
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|nd
operator|.
name|nd_mrep
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Set the flag based on credflavor */
if|if
condition|(
name|credflavor
operator|==
name|RPCSEC_GSS_KRB5
condition|)
block|{
name|nd
operator|.
name|nd_flag
operator||=
name|ND_GSS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|credflavor
operator|==
name|RPCSEC_GSS_KRB5I
condition|)
block|{
name|nd
operator|.
name|nd_flag
operator||=
operator|(
name|ND_GSS
operator||
name|ND_GSSINTEGRITY
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|credflavor
operator|==
name|RPCSEC_GSS_KRB5P
condition|)
block|{
name|nd
operator|.
name|nd_flag
operator||=
operator|(
name|ND_GSS
operator||
name|ND_GSSPRIVACY
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|credflavor
operator|!=
name|AUTH_SYS
condition|)
block|{
name|svcerr_weakauth
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|nd
operator|.
name|nd_mrep
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|mac_cred_associate_nfsd
argument_list|(
name|nd
operator|.
name|nd_cred
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Get a refcnt (shared lock) on nfsd_suspend_lock. 		 * NFSSVC_SUSPENDNFSD will take an exclusive lock on 		 * nfsd_suspend_lock to suspend these threads. 		 * This must be done here, before the check of 		 * nfsv4root exports by nfsvno_v4rootexport(). 		 */
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_getref
argument_list|(
operator|&
name|nfsd_suspend_lock
argument_list|,
name|NULL
argument_list|,
name|NFSV4ROOTLOCKMUTEXPTR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|.
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|!=
literal|0
condition|)
block|{
name|nd
operator|.
name|nd_repstat
operator|=
name|nfsvno_v4rootexport
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|nd_repstat
operator|!=
literal|0
condition|)
block|{
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_relref
argument_list|(
operator|&
name|nfsd_suspend_lock
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|svcerr_weakauth
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|nd
operator|.
name|nd_mrep
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|cacherep
operator|=
name|nfs_proc
argument_list|(
operator|&
name|nd
argument_list|,
name|rqst
operator|->
name|rq_xid
argument_list|,
name|xprt
argument_list|,
operator|&
name|rp
argument_list|)
expr_stmt|;
name|NFSLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
name|nfsv4_relref
argument_list|(
operator|&
name|nfsd_suspend_lock
argument_list|)
expr_stmt|;
name|NFSUNLOCKV4ROOTMUTEX
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|NFSMGET
argument_list|(
name|nd
operator|.
name|nd_mreq
argument_list|)
expr_stmt|;
name|nd
operator|.
name|nd_mreq
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|cacherep
operator|=
name|RC_REPLY
expr_stmt|;
block|}
if|if
condition|(
name|nd
operator|.
name|nd_mrep
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|nd
operator|.
name|nd_mrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|nd_cred
operator|!=
name|NULL
condition|)
name|crfree
argument_list|(
name|nd
operator|.
name|nd_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|cacherep
operator|==
name|RC_DROPIT
condition|)
block|{
if|if
condition|(
name|nd
operator|.
name|nd_mreq
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|nd
operator|.
name|nd_mreq
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nd
operator|.
name|nd_mreq
operator|==
name|NULL
condition|)
block|{
name|svcerr_decode
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nd
operator|.
name|nd_repstat
operator|&
name|NFSERR_AUTHERR
condition|)
block|{
name|svcerr_auth
argument_list|(
name|rqst
argument_list|,
name|nd
operator|.
name|nd_repstat
operator|&
operator|~
name|NFSERR_AUTHERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|nd_mreq
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|nd
operator|.
name|nd_mreq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|svc_sendreply_mbuf
argument_list|(
name|rqst
argument_list|,
name|nd
operator|.
name|nd_mreq
argument_list|)
condition|)
block|{
name|svcerr_systemerr
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
block|{
name|nfsrvd_sentcache
argument_list|(
name|rp
argument_list|,
operator|(
name|rqst
operator|->
name|rq_reply_seq
operator|!=
literal|0
operator|||
name|SVC_ACK
argument_list|(
name|xprt
argument_list|,
name|NULL
argument_list|)
operator|)
argument_list|,
name|rqst
operator|->
name|rq_reply_seq
argument_list|)
expr_stmt|;
block|}
name|svc_freereq
argument_list|(
name|rqst
argument_list|)
expr_stmt|;
name|out
label|:
name|NFSEXITCODE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check the cache and, optionally, do the RPC.  * Return the appropriate cache response.  */
end_comment

begin_function
specifier|static
name|int
name|nfs_proc
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|u_int32_t
name|xid
parameter_list|,
name|SVCXPRT
modifier|*
name|xprt
parameter_list|,
name|struct
name|nfsrvcache
modifier|*
modifier|*
name|rpp
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|int
name|cacherep
init|=
name|RC_DOIT
decl_stmt|,
name|isdgram
decl_stmt|,
name|taglen
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_char
name|tag
index|[
name|NFSV4_SMALLSTR
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|tagstr
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|minorvers
init|=
literal|0
decl_stmt|;
name|uint32_t
name|ack
decl_stmt|;
operator|*
name|rpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_nam2
operator|==
name|NULL
condition|)
block|{
name|nd
operator|->
name|nd_flag
operator||=
name|ND_STREAMSOCK
expr_stmt|;
name|isdgram
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|isdgram
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Two cases: 	 * 1 - For NFSv2 over UDP, if we are near our malloc/mget 	 *     limit, just drop the request. There is no 	 *     NFSERR_RESOURCE or NFSERR_DELAY for NFSv2 and the 	 *     client will timeout/retry over UDP in a little while. 	 * 2 - nd_repstat == 0&& nd_mreq == NULL, which 	 *     means a normal nfs rpc, so check the cache 	 */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
operator|)
operator|&&
name|nd
operator|->
name|nd_nam2
operator|!=
name|NULL
operator|&&
name|nfsrv_mallocmget_limit
argument_list|()
condition|)
block|{
name|cacherep
operator|=
name|RC_DROPIT
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * For NFSv3, play it safe and assume that the client is 		 * doing retries on the same TCP connection. 		 */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV4
operator||
name|ND_STREAMSOCK
operator|)
operator|)
operator|==
name|ND_STREAMSOCK
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_SAMETCPCONN
expr_stmt|;
name|nd
operator|->
name|nd_retxid
operator|=
name|xid
expr_stmt|;
name|nd
operator|->
name|nd_tcpconntime
operator|=
name|NFSD_MONOSEC
expr_stmt|;
name|nd
operator|->
name|nd_sockref
operator|=
name|xprt
operator|->
name|xp_sockref
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|!=
literal|0
condition|)
name|nfsd_getminorvers
argument_list|(
name|nd
argument_list|,
name|tag
argument_list|,
operator|&
name|tagstr
argument_list|,
operator|&
name|taglen
argument_list|,
operator|&
name|minorvers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV41
operator|)
operator|!=
literal|0
condition|)
comment|/* NFSv4.1 caches replies in the session slots. */
name|cacherep
operator|=
name|RC_DOIT
expr_stmt|;
else|else
block|{
name|cacherep
operator|=
name|nfsrvd_getcache
argument_list|(
name|nd
argument_list|)
expr_stmt|;
name|ack
operator|=
literal|0
expr_stmt|;
name|SVC_ACK
argument_list|(
name|xprt
argument_list|,
operator|&
name|ack
argument_list|)
expr_stmt|;
name|nfsrc_trimcache
argument_list|(
name|xprt
operator|->
name|xp_sockref
argument_list|,
name|ack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Handle the request. There are three cases. 	 * RC_DOIT - do the RPC 	 * RC_REPLY - return the reply already created 	 * RC_DROPIT - just throw the request away 	 */
if|if
condition|(
name|cacherep
operator|==
name|RC_DOIT
condition|)
block|{
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV41
operator|)
operator|!=
literal|0
condition|)
name|nd
operator|->
name|nd_xprt
operator|=
name|xprt
expr_stmt|;
name|nfsrvd_dorpc
argument_list|(
name|nd
argument_list|,
name|isdgram
argument_list|,
name|tagstr
argument_list|,
name|taglen
argument_list|,
name|minorvers
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV41
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
name|NFSERR_REPLYFROMCACHE
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_SAVEREPLY
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Cache a copy of the reply. */
name|m
operator|=
name|m_copym
argument_list|(
name|nd
operator|->
name|nd_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
else|else
name|m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_HASSEQUENCE
operator|)
operator|!=
literal|0
condition|)
name|nfsrv_cache_session
argument_list|(
name|nd
operator|->
name|nd_sessionid
argument_list|,
name|nd
operator|->
name|nd_slotid
argument_list|,
name|nd
operator|->
name|nd_repstat
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_REPLYFROMCACHE
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
name|cacherep
operator|=
name|RC_REPLY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_DONTREPLY
condition|)
name|cacherep
operator|=
name|RC_DROPIT
expr_stmt|;
else|else
name|cacherep
operator|=
name|RC_REPLY
expr_stmt|;
operator|*
name|rpp
operator|=
name|nfsrvd_updatecache
argument_list|(
name|nd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tagstr
operator|!=
name|NULL
operator|&&
name|taglen
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|tagstr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|NFSEXITCODE2
argument_list|(
literal|0
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|cacherep
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nfssvc_loss
parameter_list|(
name|SVCXPRT
modifier|*
name|xprt
parameter_list|)
block|{
name|uint32_t
name|ack
decl_stmt|;
name|ack
operator|=
literal|0
expr_stmt|;
name|SVC_ACK
argument_list|(
name|xprt
argument_list|,
operator|&
name|ack
argument_list|)
expr_stmt|;
name|nfsrc_trimcache
argument_list|(
name|xprt
operator|->
name|xp_sockref
argument_list|,
name|ack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adds a socket to the list for servicing by nfsds.  */
end_comment

begin_function
name|int
name|nfsrvd_addsock
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|siz
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|SVCXPRT
modifier|*
name|xprt
decl_stmt|;
specifier|static
name|u_int64_t
name|sockref
init|=
literal|0
decl_stmt|;
name|so
operator|=
name|fp
operator|->
name|f_data
expr_stmt|;
name|siz
operator|=
name|sb_max_adj
expr_stmt|;
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|siz
argument_list|,
name|siz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Steal the socket from userland so that it doesn't close 	 * unexpectedly. 	 */
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_DGRAM
condition|)
name|xprt
operator|=
name|svc_dg_create
argument_list|(
name|nfsrvd_pool
argument_list|,
name|so
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|xprt
operator|=
name|svc_vc_create
argument_list|(
name|nfsrvd_pool
argument_list|,
name|so
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xprt
condition|)
block|{
name|fp
operator|->
name|f_ops
operator|=
operator|&
name|badfileops
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
name|NULL
expr_stmt|;
name|xprt
operator|->
name|xp_sockref
operator|=
operator|++
name|sockref
expr_stmt|;
if|if
condition|(
name|nfs_minvers
operator|==
name|NFS_VER2
condition|)
name|svc_reg
argument_list|(
name|xprt
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER2
argument_list|,
name|nfssvc_program
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfs_minvers
operator|<=
name|NFS_VER3
operator|&&
name|nfs_maxvers
operator|>=
name|NFS_VER3
condition|)
name|svc_reg
argument_list|(
name|xprt
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER3
argument_list|,
name|nfssvc_program
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfs_maxvers
operator|>=
name|NFS_VER4
condition|)
name|svc_reg
argument_list|(
name|xprt
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|,
name|nfssvc_program
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
condition|)
name|svc_loss_reg
argument_list|(
name|xprt
argument_list|,
name|nfssvc_loss
argument_list|)
expr_stmt|;
name|SVC_RELEASE
argument_list|(
name|xprt
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by nfssvc() for nfsds. Just loops around servicing rpc requests  * until it is killed by a signal.  */
end_comment

begin_function
name|int
name|nfsrvd_nfsd
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|nfsd_nfsd_args
modifier|*
name|args
parameter_list|)
block|{
name|char
name|principal
index|[
name|MAXHOSTNAMELEN
operator|+
literal|5
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|bool_t
name|ret2
decl_stmt|,
name|ret3
decl_stmt|,
name|ret4
decl_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
name|args
operator|->
name|principal
argument_list|,
name|principal
argument_list|,
sizeof|sizeof
argument_list|(
name|principal
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Only the first nfsd actually does any work. The RPC code 	 * adds threads to it as needed. Any extra processes offered 	 * by nfsd just exit. If nfsd is new enough, it will call us 	 * once with a structure that specifies how many threads to 	 * use. 	 */
name|NFSD_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|newnfs_numnfsd
operator|==
literal|0
condition|)
block|{
name|newnfs_numnfsd
operator|++
expr_stmt|;
name|NFSD_UNLOCK
argument_list|()
expr_stmt|;
comment|/* An empty string implies AUTH_SYS only. */
if|if
condition|(
name|principal
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|ret2
operator|=
name|rpc_gss_set_svc_name_call
argument_list|(
name|principal
argument_list|,
literal|"kerberosv5"
argument_list|,
name|GSS_C_INDEFINITE
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER2
argument_list|)
expr_stmt|;
name|ret3
operator|=
name|rpc_gss_set_svc_name_call
argument_list|(
name|principal
argument_list|,
literal|"kerberosv5"
argument_list|,
name|GSS_C_INDEFINITE
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER3
argument_list|)
expr_stmt|;
name|ret4
operator|=
name|rpc_gss_set_svc_name_call
argument_list|(
name|principal
argument_list|,
literal|"kerberosv5"
argument_list|,
name|GSS_C_INDEFINITE
argument_list|,
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret2
operator|||
operator|!
name|ret3
operator|||
operator|!
name|ret4
condition|)
name|printf
argument_list|(
literal|"nfsd: can't register svc name\n"
argument_list|)
expr_stmt|;
block|}
name|nfsrvd_pool
operator|->
name|sp_minthreads
operator|=
name|args
operator|->
name|minthreads
expr_stmt|;
name|nfsrvd_pool
operator|->
name|sp_maxthreads
operator|=
name|args
operator|->
name|maxthreads
expr_stmt|;
name|svc_run
argument_list|(
name|nfsrvd_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|principal
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|rpc_gss_clear_svc_name_call
argument_list|(
name|NFS_PROG
argument_list|,
name|NFS_VER2
argument_list|)
expr_stmt|;
name|rpc_gss_clear_svc_name_call
argument_list|(
name|NFS_PROG
argument_list|,
name|NFS_VER3
argument_list|)
expr_stmt|;
name|rpc_gss_clear_svc_name_call
argument_list|(
name|NFS_PROG
argument_list|,
name|NFS_VER4
argument_list|)
expr_stmt|;
block|}
name|NFSD_LOCK
argument_list|()
expr_stmt|;
name|newnfs_numnfsd
operator|--
expr_stmt|;
name|nfsrvd_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|NFSD_UNLOCK
argument_list|()
expr_stmt|;
name|out
label|:
name|NFSEXITCODE
argument_list|(
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the data structures for the server.  * Handshake with any new nfsds starting up to avoid any chance of  * corruption.  */
end_comment

begin_function
name|void
name|nfsrvd_init
parameter_list|(
name|int
name|terminating
parameter_list|)
block|{
name|NFSD_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|terminating
condition|)
block|{
name|nfsd_master_proc
operator|=
name|NULL
expr_stmt|;
name|NFSD_UNLOCK
argument_list|()
expr_stmt|;
name|svcpool_destroy
argument_list|(
name|nfsrvd_pool
argument_list|)
expr_stmt|;
name|nfsrvd_pool
operator|=
name|NULL
expr_stmt|;
name|NFSD_LOCK
argument_list|()
expr_stmt|;
block|}
name|NFSD_UNLOCK
argument_list|()
expr_stmt|;
name|nfsrvd_pool
operator|=
name|svcpool_create
argument_list|(
literal|"nfsd"
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_vfs_nfsd
argument_list|)
argument_list|)
expr_stmt|;
name|nfsrvd_pool
operator|->
name|sp_rcache
operator|=
name|NULL
expr_stmt|;
name|nfsrvd_pool
operator|->
name|sp_assign
operator|=
name|fhanew_assign
expr_stmt|;
name|nfsrvd_pool
operator|->
name|sp_done
operator|=
name|fha_nd_complete
expr_stmt|;
name|NFSD_LOCK
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

