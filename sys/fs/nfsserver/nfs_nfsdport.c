begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Functions that perform the vfs operations required by the routines in  * nfsd_serv.c. It is hoped that this change will make the server more  * portable.  */
end_comment

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<nlm/nlm_prot.h>
end_include

begin_include
include|#
directive|include
file|<nlm/nlm.h>
end_include

begin_decl_stmt
specifier|extern
name|u_int32_t
name|newnfs_true
decl_stmt|,
name|newnfs_false
decl_stmt|,
name|newnfs_xdrneg1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_useacl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|newnfs_numnfsd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|mount
name|nfsv4root_mnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsrv_stablefirst
name|nfsrv_stablefirst
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|nfsd_call_servertimer
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|SVCPOOL
modifier|*
name|nfsrvd_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vfsoptlist
name|nfsv4root_opt
decl_stmt|,
name|nfsv4root_newopt
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NFSDLOCKMUTEX
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mtx
name|nfs_cache_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|nfs_v4root_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nfsrvfh
name|nfs_rootfh
decl_stmt|,
name|nfs_pubfh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfs_pubfhset
init|=
literal|0
decl_stmt|,
name|nfs_rootfhset
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|nfsd_master_proc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pid_t
name|nfsd_master_pid
init|=
operator|(
name|pid_t
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|nfsd_master_comm
index|[
name|MAXCOMLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|nfsd_master_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|nfsv4_sysid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|nfssvc_srvcall
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|nfssvc_args
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|nfsrv_enable_crossmntpt
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_commit_blks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nfs_commit_miss
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_issuedelegs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_dolocallocks
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_newnfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_newnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|mirrormnt
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfsrv_enable_crossmntpt
argument_list|,
literal|0
argument_list|,
literal|"Enable nfsd to cross mount points"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_newnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|commit_blks
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_commit_blks
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_newnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|commit_miss
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfs_commit_miss
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_newnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|issue_delegations
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfsrv_issuedelegs
argument_list|,
literal|0
argument_list|,
literal|"Enable nfsd to issue delegations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_newnfs
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_locallocks
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfsrv_dolocallocks
argument_list|,
literal|0
argument_list|,
literal|"Enable nfsd to acquire local locks on files"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NUM_HEURISTIC
value|1017
end_define

begin_define
define|#
directive|define
name|NHUSE_INIT
value|64
end_define

begin_define
define|#
directive|define
name|NHUSE_INC
value|16
end_define

begin_define
define|#
directive|define
name|NHUSE_MAX
value|2048
end_define

begin_struct
specifier|static
struct|struct
name|nfsheur
block|{
name|struct
name|vnode
modifier|*
name|nh_vp
decl_stmt|;
comment|/* vp to match (unreferenced pointer) */
name|off_t
name|nh_nextr
decl_stmt|;
comment|/* next offset for sequential detection */
name|int
name|nh_use
decl_stmt|;
comment|/* use count for selection */
name|int
name|nh_seqcount
decl_stmt|;
comment|/* heuristic */
block|}
name|nfsheur
index|[
name|NUM_HEURISTIC
index|]
struct|;
end_struct

begin_comment
comment|/*  * Get attributes into nfsvattr structure.  */
end_comment

begin_function
name|int
name|nfsvno_getattr
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|int
name|vpislocked
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|lockedit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vpislocked
operator|==
literal|0
condition|)
block|{
comment|/* 		 * When vpislocked == 0, the vnode is either exclusively 		 * locked by this thread or not locked by this thread. 		 * As such, shared lock it, if not exclusively locked. 		 */
if|if
condition|(
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
operator|!=
name|LK_EXCLUSIVE
condition|)
block|{
name|lockedit
operator|=
literal|1
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockedit
operator|!=
literal|0
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a file handle for a vnode.  */
end_comment

begin_function
name|int
name|nfsvno_getfh
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|fhandle_t
modifier|*
name|fhp
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|NFSBZERO
argument_list|(
operator|(
name|caddr_t
operator|)
name|fhp
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
expr_stmt|;
name|fhp
operator|->
name|fh_fsid
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
expr_stmt|;
name|error
operator|=
name|VOP_VPTOFH
argument_list|(
name|vp
argument_list|,
operator|&
name|fhp
operator|->
name|fh_fid
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform access checking for vnodes obtained from file handles that would  * refer to files already opened by a Unix client. You cannot just use  * vn_writechk() and VOP_ACCESSX() for two reasons.  * 1 - You must check for exported rdonly as well as MNT_RDONLY for the write  *     case.  * 2 - The owner is to be given access irrespective of mode bits for some  *     operations, so that processes that chmod after opening a file don't  *     break.  */
end_comment

begin_function
name|int
name|nfsvno_accchk
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|accmode_t
name|accmode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|int
name|override
parameter_list|,
name|int
name|vpislocked
parameter_list|,
name|u_int32_t
modifier|*
name|supportedtypep
parameter_list|)
block|{
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|getret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vpislocked
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
name|accmode
operator|&
name|VWRITE
condition|)
block|{
comment|/* Just vn_writechk() changed to check rdonly */
comment|/* 		 * Disallow write attempts on read-only file systems; 		 * unless the file is a socket or a block or character 		 * device resident on the file system. 		 */
if|if
condition|(
name|NFSVNO_EXRDONLY
argument_list|(
name|exp
argument_list|)
operator|||
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
name|error
operator|=
name|EROFS
expr_stmt|;
default|default:
break|break;
block|}
block|}
comment|/* 		 * If there's shared text associated with 		 * the inode, try to free it up once.  If 		 * we fail, we can't allow writing. 		 */
if|if
condition|(
operator|(
name|vp
operator|->
name|v_vflag
operator|&
name|VV_TEXT
operator|)
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|ETXTBSY
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|vpislocked
operator|==
literal|0
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Should the override still be applied when ACLs are enabled? 	 */
name|error
operator|=
name|VOP_ACCESSX
argument_list|(
name|vp
argument_list|,
name|accmode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
operator|(
name|accmode
operator|&
operator|(
name|VDELETE
operator||
name|VDELETE_CHILD
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Try again with VEXPLICIT_DENY, to see if the test for 		 * deletion is supported. 		 */
name|error
operator|=
name|VOP_ACCESSX
argument_list|(
name|vp
argument_list|,
name|accmode
operator||
name|VEXPLICIT_DENY
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|accmode
operator|&=
operator|~
operator|(
name|VDELETE
operator||
name|VDELETE_CHILD
operator|)
expr_stmt|;
name|accmode
operator||=
name|VWRITE
expr_stmt|;
name|error
operator|=
name|VOP_ACCESSX
argument_list|(
name|vp
argument_list|,
name|accmode
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|supportedtypep
operator|!=
name|NULL
condition|)
block|{
operator|*
name|supportedtypep
operator|&=
operator|~
name|NFSACCESS_DELETE
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Allow certain operations for the owner (reads and writes 	 * on files that are already open). 	 */
if|if
condition|(
name|override
operator|!=
name|NFSACCCHK_NOOVERRIDE
operator|&&
operator|(
name|error
operator|==
name|EPERM
operator|||
name|error
operator|==
name|EACCES
operator|)
condition|)
block|{
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
literal|0
operator|&&
operator|(
name|override
operator|&
name|NFSACCCHK_ALLOWROOT
operator|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|override
operator|&
name|NFSACCCHK_ALLOWOWNER
condition|)
block|{
name|getret
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|getret
operator|==
literal|0
operator|&&
name|cred
operator|->
name|cr_uid
operator|==
name|vattr
operator|.
name|va_uid
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vpislocked
operator|==
literal|0
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set attribute(s) vnop.  */
end_comment

begin_function
name|int
name|nfsvno_setattr
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|,
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up nameidata for a lookup() call and do it  * For the cases where we are crossing mount points  * (looking up the public fh path or the v4 root path when  *  not using a pseudo-root fs), set/release the Giant lock,  * as required.  */
end_comment

begin_function
name|int
name|nfsvno_namei
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|struct
name|vnode
modifier|*
name|dp
parameter_list|,
name|int
name|islocked
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|retdirp
parameter_list|)
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
operator|&
name|ndp
operator|->
name|ni_cnd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|int
name|lockleaf
init|=
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|LOCKLEAF
operator|)
operator|!=
literal|0
decl_stmt|,
name|linklen
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|crossmnt
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
operator|*
name|retdirp
operator|=
name|NULL
expr_stmt|;
name|cnp
operator|->
name|cn_nameptr
operator|=
name|cnp
operator|->
name|cn_pnbuf
expr_stmt|;
comment|/* 	 * Extract and set starting directory. 	 */
if|if
condition|(
name|dp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
if|if
condition|(
name|islocked
condition|)
name|vput
argument_list|(
name|dp
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTDIR
operator|)
return|;
block|}
if|if
condition|(
name|islocked
condition|)
name|NFSVOPUNLOCK
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VREF
argument_list|(
name|dp
argument_list|)
expr_stmt|;
operator|*
name|retdirp
operator|=
name|dp
expr_stmt|;
if|if
condition|(
name|NFSVNO_EXRDONLY
argument_list|(
name|exp
argument_list|)
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|RDONLY
expr_stmt|;
name|ndp
operator|->
name|ni_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|crossmnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_PUBLOOKUP
condition|)
block|{
name|ndp
operator|->
name|ni_loopcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_pnbuf
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|vrele
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* 			 * Check for degenerate pathnames here, since lookup() 			 * panics on them. 			 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|ndp
operator|->
name|ni_pathlen
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cnp
operator|->
name|cn_pnbuf
index|[
name|i
index|]
operator|!=
literal|'/'
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|ndp
operator|->
name|ni_pathlen
condition|)
block|{
name|error
operator|=
name|NFSERR_ACCES
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dp
operator|=
name|rootvnode
expr_stmt|;
name|VREF
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|nfsrv_enable_crossmntpt
operator|==
literal|0
operator|&&
name|NFSVNO_EXPORTED
argument_list|(
name|exp
argument_list|)
operator|)
operator|||
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Only cross mount points for NFSv4 when doing a 		 * mount while traversing the file system above 		 * the mount point, unless nfsrv_enable_crossmntpt is set. 		 */
name|cnp
operator|->
name|cn_flags
operator||=
name|NOCROSSMOUNT
expr_stmt|;
name|crossmnt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Initialize for scan, set ni_startdir and bump ref on dp again 	 * becuase lookup() will dereference ni_startdir. 	 */
name|cnp
operator|->
name|cn_thread
operator|=
name|p
expr_stmt|;
name|ndp
operator|->
name|ni_startdir
operator|=
name|dp
expr_stmt|;
name|ndp
operator|->
name|ni_rootdir
operator|=
name|rootvnode
expr_stmt|;
if|if
condition|(
operator|!
name|lockleaf
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|LOCKLEAF
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cnp
operator|->
name|cn_nameptr
operator|=
name|cnp
operator|->
name|cn_pnbuf
expr_stmt|;
comment|/* 		 * Call lookup() to do the real work.  If an error occurs, 		 * ndp->ni_vp and ni_dvp are left uninitialized or NULL and 		 * we do not have to dereference anything before returning. 		 * In either case ni_startdir will be dereferenced and NULLed 		 * out. 		 */
name|error
operator|=
name|lookup
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* 		 * Check for encountering a symbolic link.  Trivial 		 * termination occurs if no symlink encountered. 		 */
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISSYMLINK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
operator|(
name|SAVENAME
operator||
name|SAVESTART
operator|)
operator|)
operator|==
literal|0
condition|)
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_vp
operator|&&
operator|!
name|lockleaf
condition|)
name|NFSVOPUNLOCK
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Validate symlink 		 */
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|LOCKPARENT
operator|)
operator|&&
name|ndp
operator|->
name|ni_pathlen
operator|==
literal|1
condition|)
name|NFSVOPUNLOCK
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_PUBLOOKUP
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|badlink2
goto|;
block|}
if|if
condition|(
name|ndp
operator|->
name|ni_loopcnt
operator|++
operator|>=
name|MAXSYMLINKS
condition|)
block|{
name|error
operator|=
name|ELOOP
expr_stmt|;
goto|goto
name|badlink2
goto|;
block|}
if|if
condition|(
name|ndp
operator|->
name|ni_pathlen
operator|>
literal|1
condition|)
name|cp
operator|=
name|uma_zalloc
argument_list|(
name|namei_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|cnp
operator|->
name|cn_pnbuf
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|cp
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|MAXPATHLEN
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|NULL
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|MAXPATHLEN
expr_stmt|;
name|error
operator|=
name|VOP_READLINK
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|auio
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|badlink1
label|:
if|if
condition|(
name|ndp
operator|->
name|ni_pathlen
operator|>
literal|1
condition|)
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|badlink2
label|:
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
break|break;
block|}
name|linklen
operator|=
name|MAXPATHLEN
operator|-
name|auio
operator|.
name|uio_resid
expr_stmt|;
if|if
condition|(
name|linklen
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|badlink1
goto|;
block|}
if|if
condition|(
name|linklen
operator|+
name|ndp
operator|->
name|ni_pathlen
operator|>=
name|MAXPATHLEN
condition|)
block|{
name|error
operator|=
name|ENAMETOOLONG
expr_stmt|;
goto|goto
name|badlink1
goto|;
block|}
comment|/* 		 * Adjust or replace path 		 */
if|if
condition|(
name|ndp
operator|->
name|ni_pathlen
operator|>
literal|1
condition|)
block|{
name|NFSBCOPY
argument_list|(
name|ndp
operator|->
name|ni_next
argument_list|,
name|cp
operator|+
name|linklen
argument_list|,
name|ndp
operator|->
name|ni_pathlen
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|cnp
operator|->
name|cn_pnbuf
operator|=
name|cp
expr_stmt|;
block|}
else|else
name|cnp
operator|->
name|cn_pnbuf
index|[
name|linklen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ndp
operator|->
name|ni_pathlen
operator|+=
name|linklen
expr_stmt|;
comment|/* 		 * Cleanup refs for next loop and check if root directory 		 * should replace current directory.  Normally ni_dvp 		 * becomes the new base directory and is cleaned up when 		 * we loop.  Explicitly null pointers after invalidation 		 * to clarify operation. 		 */
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_vp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_pnbuf
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_dvp
operator|=
name|ndp
operator|->
name|ni_rootdir
expr_stmt|;
name|VREF
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
block|}
name|ndp
operator|->
name|ni_startdir
operator|=
name|ndp
operator|->
name|ni_dvp
expr_stmt|;
name|ndp
operator|->
name|ni_dvp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|lockleaf
condition|)
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|LOCKLEAF
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_vp
operator|=
name|NULL
expr_stmt|;
name|ndp
operator|->
name|ni_dvp
operator|=
name|NULL
expr_stmt|;
name|ndp
operator|->
name|ni_startdir
operator|=
name|NULL
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ndp
operator|->
name|ni_cnd
operator|.
name|cn_flags
operator|&
operator|(
name|WANTPARENT
operator||
name|LOCKPARENT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ndp
operator|->
name|ni_dvp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up a pathname buffer and return a pointer to it and, optionally  * set a hash pointer.  */
end_comment

begin_function
name|void
name|nfsvno_setpathbuf
parameter_list|(
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|char
modifier|*
modifier|*
name|bufpp
parameter_list|,
name|u_long
modifier|*
modifier|*
name|hashpp
parameter_list|)
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
operator|&
name|ndp
operator|->
name|ni_cnd
decl_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
operator|(
name|NOMACCHECK
operator||
name|HASBUF
operator|)
expr_stmt|;
name|cnp
operator|->
name|cn_pnbuf
operator|=
name|uma_zalloc
argument_list|(
name|namei_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashpp
operator|!=
name|NULL
condition|)
operator|*
name|hashpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|bufpp
operator|=
name|cnp
operator|->
name|cn_pnbuf
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release the above path buffer, if not released by nfsvno_namei().  */
end_comment

begin_function
name|void
name|nfsvno_relpathbuf
parameter_list|(
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ndp
operator|->
name|ni_cnd
operator|.
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfsrelpath"
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|namei_zone
argument_list|,
name|ndp
operator|->
name|ni_cnd
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_cnd
operator|.
name|cn_flags
operator|&=
operator|~
name|HASBUF
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Readlink vnode op into an mbuf list.  */
end_comment

begin_function
name|int
name|nfsvno_readlink
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mpp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mpendp
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
block|{
name|struct
name|iovec
name|iv
index|[
operator|(
name|NFS_MAXPATHLEN
operator|+
name|MLEN
operator|-
literal|1
operator|)
operator|/
name|MLEN
index|]
decl_stmt|;
name|struct
name|iovec
modifier|*
name|ivp
init|=
name|iv
decl_stmt|;
name|struct
name|uio
name|io
decl_stmt|,
modifier|*
name|uiop
init|=
operator|&
name|io
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|,
modifier|*
name|mp2
init|=
name|NULL
decl_stmt|,
modifier|*
name|mp3
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|tlen
decl_stmt|,
name|error
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|<
name|NFS_MAXPATHLEN
condition|)
block|{
name|NFSMGET
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|MCLGET
argument_list|(
name|mp
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_len
operator|=
name|NFSMSIZ
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|mp3
operator|=
name|mp2
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
name|mp2
operator|->
name|m_next
operator|=
name|mp
expr_stmt|;
name|mp2
operator|=
name|mp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|+
name|mp
operator|->
name|m_len
operator|)
operator|>
name|NFS_MAXPATHLEN
condition|)
block|{
name|mp
operator|->
name|m_len
operator|=
name|NFS_MAXPATHLEN
operator|-
name|len
expr_stmt|;
name|len
operator|=
name|NFS_MAXPATHLEN
expr_stmt|;
block|}
else|else
block|{
name|len
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
block|}
name|ivp
operator|->
name|iov_base
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|ivp
operator|->
name|iov_len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|ivp
operator|++
expr_stmt|;
block|}
name|uiop
operator|->
name|uio_iov
operator|=
name|iv
expr_stmt|;
name|uiop
operator|->
name|uio_iovcnt
operator|=
name|i
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|=
name|len
expr_stmt|;
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uiop
operator|->
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|uiop
operator|->
name|uio_td
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|VOP_READLINK
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|mp3
argument_list|)
expr_stmt|;
operator|*
name|lenp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|uiop
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|len
operator|-=
name|uiop
operator|->
name|uio_resid
expr_stmt|;
name|tlen
operator|=
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|nfsrv_adj
argument_list|(
name|mp3
argument_list|,
name|NFS_MAXPATHLEN
operator|-
name|tlen
argument_list|,
name|tlen
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
operator|*
name|lenp
operator|=
name|len
expr_stmt|;
operator|*
name|mpp
operator|=
name|mp3
expr_stmt|;
operator|*
name|mpendp
operator|=
name|mp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read vnode op call into mbuf list.  */
end_comment

begin_function
name|int
name|nfsvno_read
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
name|cnt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mpp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mpendp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iv
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iv2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|left
decl_stmt|,
name|siz
decl_stmt|,
name|tlen
decl_stmt|,
name|ioflag
init|=
literal|0
decl_stmt|,
name|hi
decl_stmt|,
name|try
init|=
literal|32
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
init|=
name|NULL
decl_stmt|,
modifier|*
name|m3
decl_stmt|;
name|struct
name|uio
name|io
decl_stmt|,
modifier|*
name|uiop
init|=
operator|&
name|io
decl_stmt|;
name|struct
name|nfsheur
modifier|*
name|nh
decl_stmt|;
comment|/* 	 * Calculate seqcount for heuristic 	 */
comment|/* 	 * Locate best candidate 	 */
name|hi
operator|=
operator|(
operator|(
name|int
operator|)
operator|(
name|vm_offset_t
operator|)
name|vp
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|vnode
argument_list|)
operator|)
operator|%
name|NUM_HEURISTIC
expr_stmt|;
name|nh
operator|=
operator|&
name|nfsheur
index|[
name|hi
index|]
expr_stmt|;
while|while
condition|(
name|try
operator|--
condition|)
block|{
if|if
condition|(
name|nfsheur
index|[
name|hi
index|]
operator|.
name|nh_vp
operator|==
name|vp
condition|)
block|{
name|nh
operator|=
operator|&
name|nfsheur
index|[
name|hi
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nfsheur
index|[
name|hi
index|]
operator|.
name|nh_use
operator|>
literal|0
condition|)
operator|--
name|nfsheur
index|[
name|hi
index|]
operator|.
name|nh_use
expr_stmt|;
name|hi
operator|=
operator|(
name|hi
operator|+
literal|1
operator|)
operator|%
name|NUM_HEURISTIC
expr_stmt|;
if|if
condition|(
name|nfsheur
index|[
name|hi
index|]
operator|.
name|nh_use
operator|<
name|nh
operator|->
name|nh_use
condition|)
name|nh
operator|=
operator|&
name|nfsheur
index|[
name|hi
index|]
expr_stmt|;
block|}
if|if
condition|(
name|nh
operator|->
name|nh_vp
operator|!=
name|vp
condition|)
block|{
name|nh
operator|->
name|nh_vp
operator|=
name|vp
expr_stmt|;
name|nh
operator|->
name|nh_nextr
operator|=
name|off
expr_stmt|;
name|nh
operator|->
name|nh_use
operator|=
name|NHUSE_INIT
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
name|nh
operator|->
name|nh_seqcount
operator|=
literal|4
expr_stmt|;
else|else
name|nh
operator|->
name|nh_seqcount
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Calculate heuristic 	 */
if|if
condition|(
operator|(
name|off
operator|==
literal|0
operator|&&
name|nh
operator|->
name|nh_seqcount
operator|>
literal|0
operator|)
operator|||
name|off
operator|==
name|nh
operator|->
name|nh_nextr
condition|)
block|{
if|if
condition|(
operator|++
name|nh
operator|->
name|nh_seqcount
operator|>
name|IO_SEQMAX
condition|)
name|nh
operator|->
name|nh_seqcount
operator|=
name|IO_SEQMAX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nh
operator|->
name|nh_seqcount
operator|>
literal|1
condition|)
block|{
name|nh
operator|->
name|nh_seqcount
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nh
operator|->
name|nh_seqcount
operator|=
literal|0
expr_stmt|;
block|}
name|nh
operator|->
name|nh_use
operator|+=
name|NHUSE_INC
expr_stmt|;
if|if
condition|(
name|nh
operator|->
name|nh_use
operator|>
name|NHUSE_MAX
condition|)
name|nh
operator|->
name|nh_use
operator|=
name|NHUSE_MAX
expr_stmt|;
name|ioflag
operator||=
name|nh
operator|->
name|nh_seqcount
operator|<<
name|IO_SEQSHIFT
expr_stmt|;
name|len
operator|=
name|left
operator|=
name|NFSM_RNDUP
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
name|m3
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Generate the mbuf list with the uio_iov ref. to it. 	 */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|NFSMGET
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|siz
operator|=
name|min
argument_list|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|left
operator|-=
name|siz
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|m3
condition|)
name|m2
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
else|else
name|m3
operator|=
name|m
expr_stmt|;
name|m2
operator|=
name|m
expr_stmt|;
block|}
name|MALLOC
argument_list|(
name|iv
argument_list|,
expr|struct
name|iovec
operator|*
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iovec
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|=
name|iv2
operator|=
name|iv
expr_stmt|;
name|m
operator|=
name|m3
expr_stmt|;
name|left
operator|=
name|len
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfsvno_read iov"
argument_list|)
expr_stmt|;
name|siz
operator|=
name|min
argument_list|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|,
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|siz
operator|>
literal|0
condition|)
block|{
name|iv
operator|->
name|iov_base
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
name|iv
operator|->
name|iov_len
operator|=
name|siz
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|siz
expr_stmt|;
name|left
operator|-=
name|siz
expr_stmt|;
name|iv
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|uiop
operator|->
name|uio_iovcnt
operator|=
name|i
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|=
name|off
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|=
name|len
expr_stmt|;
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|uiop
operator|->
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|error
operator|=
name|VOP_READ
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|IO_NODELOCKED
operator||
name|ioflag
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|iv2
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m3
argument_list|)
expr_stmt|;
operator|*
name|mpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tlen
operator|=
name|len
operator|-
name|uiop
operator|->
name|uio_resid
expr_stmt|;
name|cnt
operator|=
name|cnt
operator|<
name|tlen
condition|?
name|cnt
else|:
name|tlen
expr_stmt|;
name|tlen
operator|=
name|NFSM_RNDUP
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m3
argument_list|)
expr_stmt|;
name|m3
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|!=
name|tlen
operator|||
name|tlen
operator|!=
name|cnt
condition|)
name|nfsrv_adj
argument_list|(
name|m3
argument_list|,
name|len
operator|-
name|tlen
argument_list|,
name|tlen
operator|-
name|cnt
argument_list|)
expr_stmt|;
operator|*
name|mpp
operator|=
name|m3
expr_stmt|;
operator|*
name|mpendp
operator|=
name|m2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write vnode op from an mbuf list.  */
end_comment

begin_function
name|int
name|nfsvno_write
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
name|retlen
parameter_list|,
name|int
name|cnt
parameter_list|,
name|int
name|stable
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mp
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|iovec
modifier|*
name|ivp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iv
decl_stmt|;
name|int
name|ioflags
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|uio
name|io
decl_stmt|,
modifier|*
name|uiop
init|=
operator|&
name|io
decl_stmt|;
name|MALLOC
argument_list|(
name|ivp
argument_list|,
expr|struct
name|iovec
operator|*
argument_list|,
name|cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iovec
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|=
name|iv
operator|=
name|ivp
expr_stmt|;
name|uiop
operator|->
name|uio_iovcnt
operator|=
name|cnt
expr_stmt|;
name|i
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mp
operator|->
name|m_len
operator|-
name|cp
expr_stmt|;
name|len
operator|=
name|retlen
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"nfsvno_write"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|min
argument_list|(
name|i
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ivp
operator|->
name|iov_base
operator|=
name|cp
expr_stmt|;
name|ivp
operator|->
name|iov_len
operator|=
name|i
expr_stmt|;
name|ivp
operator|++
expr_stmt|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|mp
condition|)
block|{
name|i
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stable
operator|==
name|NFSWRITE_UNSTABLE
condition|)
name|ioflags
operator|=
name|IO_NODELOCKED
expr_stmt|;
else|else
name|ioflags
operator|=
operator|(
name|IO_SYNC
operator||
name|IO_NODELOCKED
operator|)
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|=
name|retlen
expr_stmt|;
name|uiop
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|uiop
operator|->
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|NFSUIOPROC
argument_list|(
name|uiop
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|=
name|off
expr_stmt|;
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|ioflags
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|iv
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common code for creating a regular file (plus special files for V2).  */
end_comment

begin_function
name|int
name|nfsvno_createsub
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|int
modifier|*
name|exclusive_flagp
parameter_list|,
name|int32_t
modifier|*
name|cverf
parameter_list|,
name|NFSDEV_T
name|rdev
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|)
block|{
name|u_quad_t
name|tempsize
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|ndp
operator|->
name|ni_vp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nvap
operator|->
name|na_type
operator|==
name|VREG
operator|||
name|nvap
operator|->
name|na_type
operator|==
name|VSOCK
condition|)
block|{
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_cnd
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
operator|*
name|exclusive_flagp
condition|)
block|{
operator|*
name|exclusive_flagp
operator|=
literal|0
expr_stmt|;
name|NFSVNO_ATTRINIT
argument_list|(
name|nvap
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_atime
operator|.
name|tv_sec
operator|=
name|cverf
index|[
literal|0
index|]
expr_stmt|;
name|nvap
operator|->
name|na_atime
operator|.
name|tv_nsec
operator|=
name|cverf
index|[
literal|1
index|]
expr_stmt|;
name|error
operator|=
name|VOP_SETATTR
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * NFS V2 Only. nfsrvd_mknod() does this for V3. 		 * (This implies, just get out on an error.) 		 */
block|}
elseif|else
if|if
condition|(
name|nvap
operator|->
name|na_type
operator|==
name|VCHR
operator|||
name|nvap
operator|->
name|na_type
operator|==
name|VBLK
operator|||
name|nvap
operator|->
name|na_type
operator|==
name|VFIFO
condition|)
block|{
if|if
condition|(
name|nvap
operator|->
name|na_type
operator|==
name|VCHR
operator|&&
name|rdev
operator|==
literal|0xffffffff
condition|)
name|nvap
operator|->
name|na_type
operator|=
name|VFIFO
expr_stmt|;
if|if
condition|(
name|nvap
operator|->
name|na_type
operator|!=
name|VFIFO
operator|&&
operator|(
name|error
operator|=
name|priv_check_cred
argument_list|(
name|nd
operator|->
name|nd_cred
argument_list|,
name|PRIV_VFS_MKNOD_DEV
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|nvap
operator|->
name|na_rdev
operator|=
name|rdev
expr_stmt|;
name|error
operator|=
name|VOP_MKNOD
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_cnd
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
operator|*
name|vpp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Handle cases where error is already set and/or 		 * the file exists. 		 * 1 - clean up the lookup 		 * 2 - iff !error and na_size set, truncate it 		 */
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|==
operator|*
name|vpp
condition|)
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|nvap
operator|->
name|na_size
operator|!=
name|VNOVAL
condition|)
block|{
name|error
operator|=
name|nfsvno_accchk
argument_list|(
operator|*
name|vpp
argument_list|,
name|VWRITE
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
name|exp
argument_list|,
name|p
argument_list|,
name|NFSACCCHK_NOOVERRIDE
argument_list|,
name|NFSACCCHK_VPISLOCKED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|tempsize
operator|=
name|nvap
operator|->
name|na_size
expr_stmt|;
name|NFSVNO_ATTRINIT
argument_list|(
name|nvap
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_size
operator|=
name|tempsize
expr_stmt|;
name|error
operator|=
name|VOP_SETATTR
argument_list|(
operator|*
name|vpp
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
name|vput
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do a mknod vnode op.  */
end_comment

begin_function
name|int
name|nfsvno_mknod
parameter_list|(
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|enum
name|vtype
name|vtyp
decl_stmt|;
name|vtyp
operator|=
name|nvap
operator|->
name|na_type
expr_stmt|;
comment|/* 	 * Iff doesn't exist, create it. 	 */
if|if
condition|(
name|ndp
operator|->
name|ni_vp
condition|)
block|{
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
if|if
condition|(
name|vtyp
operator|!=
name|VCHR
operator|&&
name|vtyp
operator|!=
name|VBLK
operator|&&
name|vtyp
operator|!=
name|VSOCK
operator|&&
name|vtyp
operator|!=
name|VFIFO
condition|)
block|{
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NFSERR_BADTYPE
operator|)
return|;
block|}
if|if
condition|(
name|vtyp
operator|==
name|VSOCK
condition|)
block|{
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_cnd
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nvap
operator|->
name|na_type
operator|!=
name|VFIFO
operator|&&
operator|(
name|error
operator|=
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_MKNOD_DEV
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|VOP_MKNOD
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_cnd
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
comment|/* 		 * Since VOP_MKNOD returns the ni_vp, I can't 		 * see any reason to do the lookup. 		 */
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mkdir vnode op.  */
end_comment

begin_function
name|int
name|nfsvno_mkdir
parameter_list|(
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|uid_t
name|saved_uid
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_vp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|==
name|ndp
operator|->
name|ni_vp
condition|)
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|error
operator|=
name|VOP_MKDIR
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_cnd
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * symlink vnode op.  */
end_comment

begin_function
name|int
name|nfsvno_symlink
parameter_list|(
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|char
modifier|*
name|pathcp
parameter_list|,
name|int
name|pathlen
parameter_list|,
name|int
name|not_v2
parameter_list|,
name|uid_t
name|saved_uid
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_vp
condition|)
block|{
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|==
name|ndp
operator|->
name|ni_vp
condition|)
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|error
operator|=
name|VOP_SYMLINK
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_cnd
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|,
name|pathcp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
comment|/* 	 * Although FreeBSD still had the lookup code in 	 * it for 7/current, there doesn't seem to be any 	 * point, since VOP_SYMLINK() returns the ni_vp. 	 * Just vput it for v2. 	 */
if|if
condition|(
operator|!
name|not_v2
operator|&&
operator|!
name|error
condition|)
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse symbolic link arguments.  * This function has an ugly side effect. It will MALLOC() an area for  * the symlink and set iov_base to point to it, only if it succeeds.  * So, if it returns with uiop->uio_iov->iov_base != NULL, that must  * be FREE'd later.  */
end_comment

begin_function
name|int
name|nfsvno_getsymlink
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|char
modifier|*
modifier|*
name|pathcpp
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|char
modifier|*
name|pathcp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|nfsv2_sattr
modifier|*
name|sp
decl_stmt|;
operator|*
name|pathcpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|lenp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|&&
operator|(
name|error
operator|=
name|nfsrv_sattr
argument_list|(
name|nd
argument_list|,
name|nvap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
operator|)
condition|)
goto|goto
name|nfsmout
goto|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|NFS_MAXPATHLEN
operator|||
name|len
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|MALLOC
argument_list|(
name|pathcp
argument_list|,
name|caddr_t
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|pathcp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|sp
argument_list|,
expr|struct
name|nfsv2_sattr
operator|*
argument_list|,
name|NFSX_V2SATTR
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_mode
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int16_t
argument_list|,
name|sp
operator|->
name|sa_mode
argument_list|)
expr_stmt|;
block|}
operator|*
name|pathcpp
operator|=
name|pathcp
expr_stmt|;
operator|*
name|lenp
operator|=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nfsmout
label|:
if|if
condition|(
name|pathcp
condition|)
name|free
argument_list|(
name|pathcp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a non-directory object.  */
end_comment

begin_function
name|int
name|nfsvno_removesub
parameter_list|(
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|int
name|is_v4
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|vp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|error
operator|=
name|NFSERR_ISDIR
expr_stmt|;
elseif|else
if|if
condition|(
name|is_v4
condition|)
name|error
operator|=
name|nfsrv_checkremove
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|VOP_REMOVE
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
name|vp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_cnd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a directory.  */
end_comment

begin_function
name|int
name|nfsvno_rmdirsub
parameter_list|(
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|int
name|is_v4
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|vp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|error
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * No rmdir "." please. 	 */
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|==
name|vp
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * The root of a mounted filesystem cannot be deleted. 	 */
if|if
condition|(
name|vp
operator|->
name|v_vflag
operator|&
name|VV_ROOT
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
name|out
label|:
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|VOP_RMDIR
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
name|vp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_cnd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rename vnode op.  */
end_comment

begin_function
name|int
name|nfsvno_rename
parameter_list|(
name|struct
name|nameidata
modifier|*
name|fromndp
parameter_list|,
name|struct
name|nameidata
modifier|*
name|tondp
parameter_list|,
name|u_int32_t
name|ndstat
parameter_list|,
name|u_int32_t
name|ndflag
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|fvp
decl_stmt|,
modifier|*
name|tvp
decl_stmt|,
modifier|*
name|tdvp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|fvp
operator|=
name|fromndp
operator|->
name|ni_vp
expr_stmt|;
if|if
condition|(
name|ndstat
condition|)
block|{
name|vrele
argument_list|(
name|fromndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ndstat
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
name|tdvp
operator|=
name|tondp
operator|->
name|ni_dvp
expr_stmt|;
name|tvp
operator|=
name|tondp
operator|->
name|ni_vp
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fvp
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
name|tvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|error
operator|=
operator|(
name|ndflag
operator|&
name|ND_NFSV2
operator|)
condition|?
name|EISDIR
else|:
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|fvp
operator|->
name|v_type
operator|!=
name|VDIR
operator|&&
name|tvp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|error
operator|=
operator|(
name|ndflag
operator|&
name|ND_NFSV2
operator|)
condition|?
name|ENOTDIR
else|:
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tvp
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
name|tvp
operator|->
name|v_mountedhere
condition|)
block|{
name|error
operator|=
operator|(
name|ndflag
operator|&
name|ND_NFSV2
operator|)
condition|?
name|ENOTEMPTY
else|:
name|EXDEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * A rename to '.' or '..' results in a prematurely 		 * unlocked vnode on FreeBSD5, so I'm just going to fail that 		 * here. 		 */
if|if
condition|(
operator|(
name|tondp
operator|->
name|ni_cnd
operator|.
name|cn_namelen
operator|==
literal|1
operator|&&
name|tondp
operator|->
name|ni_cnd
operator|.
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|tondp
operator|->
name|ni_cnd
operator|.
name|cn_namelen
operator|==
literal|2
operator|&&
name|tondp
operator|->
name|ni_cnd
operator|.
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|tondp
operator|->
name|ni_cnd
operator|.
name|cn_nameptr
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|fvp
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
name|fvp
operator|->
name|v_mountedhere
condition|)
block|{
name|error
operator|=
operator|(
name|ndflag
operator|&
name|ND_NFSV2
operator|)
condition|?
name|ENOTEMPTY
else|:
name|EXDEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fvp
operator|->
name|v_mount
operator|!=
name|tdvp
operator|->
name|v_mount
condition|)
block|{
name|error
operator|=
operator|(
name|ndflag
operator|&
name|ND_NFSV2
operator|)
condition|?
name|ENOTEMPTY
else|:
name|EXDEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fvp
operator|==
name|tdvp
condition|)
block|{
name|error
operator|=
operator|(
name|ndflag
operator|&
name|ND_NFSV2
operator|)
condition|?
name|ENOTEMPTY
else|:
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fvp
operator|==
name|tvp
condition|)
block|{
comment|/* 		 * If source and destination are the same, there is nothing to 		 * do. Set error to -1 to indicate this. 		 */
name|error
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ndflag
operator|&
name|ND_NFSV4
condition|)
block|{
if|if
condition|(
name|vn_lock
argument_list|(
name|fvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|nfsrv_checkremove
argument_list|(
name|fvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|fvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EPERM
expr_stmt|;
if|if
condition|(
name|tvp
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_checkremove
argument_list|(
name|tvp
argument_list|,
literal|1
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * For NFSv2 and NFSv3, try to get rid of the delegation, so 		 * that the NFSv4 client won't be confused by the rename. 		 * Since nfsd_recalldelegation() can only be called on an 		 * unlocked vnode at this point and fvp is the file that will 		 * still exist after the rename, just do fvp. 		 */
name|nfsd_recalldelegation
argument_list|(
name|fvp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|VOP_RENAME
argument_list|(
name|fromndp
operator|->
name|ni_dvp
argument_list|,
name|fromndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|fromndp
operator|->
name|ni_cnd
argument_list|,
name|tondp
operator|->
name|ni_dvp
argument_list|,
name|tondp
operator|->
name|ni_vp
argument_list|,
operator|&
name|tondp
operator|->
name|ni_cnd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tdvp
operator|==
name|tvp
condition|)
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fromndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|vrele
argument_list|(
name|tondp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|tondp
argument_list|)
expr_stmt|;
name|out1
label|:
name|vrele
argument_list|(
name|fromndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|fromndp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Link vnode op.  */
end_comment

begin_function
name|int
name|nfsvno_link
parameter_list|(
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|xp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|xp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
if|if
condition|(
name|xp
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
block|}
else|else
block|{
name|xp
operator|=
name|ndp
operator|->
name|ni_dvp
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|xp
operator|->
name|v_mount
condition|)
name|error
operator|=
name|EXDEV
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|VOP_LINK
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
name|vp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_cnd
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EPERM
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|==
name|ndp
operator|->
name|ni_vp
condition|)
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_vp
condition|)
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
block|}
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the fsync() appropriate for the commit.  */
end_comment

begin_function
name|int
name|nfsvno_fsync
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|u_int64_t
name|off
parameter_list|,
name|int
name|cnt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cnt
operator|>
name|MAX_COMMIT_COUNT
condition|)
block|{
comment|/* 		 * Give up and do the whole thing 		 */
if|if
condition|(
name|vp
operator|->
name|v_object
operator|&&
operator|(
name|vp
operator|->
name|v_object
operator|->
name|flags
operator|&
name|OBJ_MIGHTBEDIRTY
operator|)
condition|)
block|{
name|VM_OBJECT_LOCK
argument_list|(
name|vp
operator|->
name|v_object
argument_list|)
expr_stmt|;
name|vm_object_page_clean
argument_list|(
name|vp
operator|->
name|v_object
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|OBJPC_SYNC
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|vp
operator|->
name|v_object
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|MNT_WAIT
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Locate and synchronously write any buffers that fall 		 * into the requested range.  Note:  we are assuming that 		 * f_iosize is a power of 2. 		 */
name|int
name|iosize
init|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
decl_stmt|;
name|int
name|iomask
init|=
name|iosize
operator|-
literal|1
decl_stmt|;
name|struct
name|bufobj
modifier|*
name|bo
decl_stmt|;
name|daddr_t
name|lblkno
decl_stmt|;
comment|/* 		 * Align to iosize boundry, super-align to page boundry. 		 */
if|if
condition|(
name|off
operator|&
name|iomask
condition|)
block|{
name|cnt
operator|+=
name|off
operator|&
name|iomask
expr_stmt|;
name|off
operator|&=
operator|~
operator|(
name|u_quad_t
operator|)
name|iomask
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|&
name|PAGE_MASK
condition|)
block|{
name|cnt
operator|+=
name|off
operator|&
name|PAGE_MASK
expr_stmt|;
name|off
operator|&=
operator|~
operator|(
name|u_quad_t
operator|)
name|PAGE_MASK
expr_stmt|;
block|}
name|lblkno
operator|=
name|off
operator|/
name|iosize
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_object
operator|&&
operator|(
name|vp
operator|->
name|v_object
operator|->
name|flags
operator|&
name|OBJ_MIGHTBEDIRTY
operator|)
condition|)
block|{
name|VM_OBJECT_LOCK
argument_list|(
name|vp
operator|->
name|v_object
argument_list|)
expr_stmt|;
name|vm_object_page_clean
argument_list|(
name|vp
operator|->
name|v_object
argument_list|,
name|off
operator|/
name|PAGE_SIZE
argument_list|,
operator|(
name|cnt
operator|+
name|PAGE_MASK
operator|)
operator|/
name|PAGE_SIZE
argument_list|,
name|OBJPC_SYNC
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|vp
operator|->
name|v_object
argument_list|)
expr_stmt|;
block|}
name|bo
operator|=
operator|&
name|vp
operator|->
name|v_bufobj
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
while|while
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
comment|/* 			 * If we have a buffer and it is marked B_DELWRI we 			 * have to lock and write it.  Otherwise the prior 			 * write is assumed to have already been committed. 			 * 			 * gbincore() can return invalid buffers now so we 			 * have to check that bit as well (though B_DELWRI 			 * should not be set if B_INVAL is set there could be 			 * a race here since we haven't locked the buffer). 			 */
if|if
condition|(
operator|(
name|bp
operator|=
name|gbincore
argument_list|(
operator|&
name|vp
operator|->
name|v_bufobj
argument_list|,
name|lblkno
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|BUF_LOCK
argument_list|(
name|bp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_SLEEPFAIL
operator||
name|LK_INTERLOCK
argument_list|,
name|BO_MTX
argument_list|(
name|bo
argument_list|)
argument_list|)
operator|==
name|ENOLCK
condition|)
block|{
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
continue|continue;
comment|/* retry */
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_DELWRI
operator||
name|B_INVAL
operator|)
operator|)
operator|==
name|B_DELWRI
condition|)
block|{
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ASYNC
expr_stmt|;
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|++
name|nfs_commit_miss
expr_stmt|;
block|}
else|else
name|BUF_UNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|BO_LOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
block|}
operator|++
name|nfs_commit_blks
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
name|iosize
condition|)
break|break;
name|cnt
operator|-=
name|iosize
expr_stmt|;
operator|++
name|lblkno
expr_stmt|;
block|}
name|BO_UNLOCK
argument_list|(
name|bo
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Statfs vnode op.  */
end_comment

begin_function
name|int
name|nfsvno_statfs
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sf
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|VFS_STATFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|,
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Since NFS handles these values as unsigned on the 		 * wire, there is no way to represent negative values, 		 * so set them to 0. Without this, they will appear 		 * to be very large positive values for clients like 		 * Solaris10. 		 */
if|if
condition|(
name|sf
operator|->
name|f_bavail
operator|<
literal|0
condition|)
name|sf
operator|->
name|f_bavail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sf
operator|->
name|f_ffree
operator|<
literal|0
condition|)
name|sf
operator|->
name|f_ffree
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the vnode op stuff for Open. Similar to nfsvno_createsub(), but  * must handle nfsrv_opencheck() calls after any other access checks.  */
end_comment

begin_function
name|void
name|nfsvno_open
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nameidata
modifier|*
name|ndp
parameter_list|,
name|nfsquad_t
name|clientid
parameter_list|,
name|nfsv4stateid_t
modifier|*
name|stateidp
parameter_list|,
name|struct
name|nfsstate
modifier|*
name|stp
parameter_list|,
name|int
modifier|*
name|exclusive_flagp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|int32_t
modifier|*
name|cverf
parameter_list|,
name|int
name|create
parameter_list|,
name|NFSACL_T
modifier|*
name|aclp
parameter_list|,
name|nfsattrbit_t
modifier|*
name|attrbitp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|u_quad_t
name|tempsize
decl_stmt|;
name|struct
name|nfsexstuff
name|nes
decl_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_vp
operator|==
name|NULL
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsrv_opencheck
argument_list|(
name|clientid
argument_list|,
name|stateidp
argument_list|,
name|stp
argument_list|,
name|NULL
argument_list|,
name|nd
argument_list|,
name|p
argument_list|,
name|nd
operator|->
name|nd_repstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
if|if
condition|(
name|ndp
operator|->
name|ni_vp
operator|==
name|NULL
condition|)
block|{
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|VOP_CREATE
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|ndp
operator|->
name|ni_cnd
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
if|if
condition|(
operator|*
name|exclusive_flagp
condition|)
block|{
operator|*
name|exclusive_flagp
operator|=
literal|0
expr_stmt|;
name|NFSVNO_ATTRINIT
argument_list|(
name|nvap
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_atime
operator|.
name|tv_sec
operator|=
name|cverf
index|[
literal|0
index|]
expr_stmt|;
name|nvap
operator|->
name|na_atime
operator|.
name|tv_nsec
operator|=
name|cverf
index|[
literal|1
index|]
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|VOP_SETATTR
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsrv_fixattr
argument_list|(
name|nd
argument_list|,
name|ndp
operator|->
name|ni_vp
argument_list|,
name|nvap
argument_list|,
name|aclp
argument_list|,
name|p
argument_list|,
name|attrbitp
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
name|vp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ndp
operator|->
name|ni_startdir
condition|)
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ndp
operator|->
name|ni_vp
expr_stmt|;
if|if
condition|(
name|create
operator|==
name|NFSV4OPEN_CREATE
condition|)
block|{
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NFSVNO_ISSETSIZE
argument_list|(
name|nvap
argument_list|)
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
if|if
condition|(
name|ndp
operator|->
name|ni_cnd
operator|.
name|cn_flags
operator|&
name|RDONLY
condition|)
name|NFSVNO_SETEXRDONLY
argument_list|(
operator|&
name|nes
argument_list|)
expr_stmt|;
else|else
name|NFSVNO_EXINIT
argument_list|(
operator|&
name|nes
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsvno_accchk
argument_list|(
name|vp
argument_list|,
name|VWRITE
argument_list|,
name|cred
argument_list|,
operator|&
name|nes
argument_list|,
name|p
argument_list|,
name|NFSACCCHK_NOOVERRIDE
argument_list|,
name|NFSACCCHK_VPISLOCKED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsrv_opencheck
argument_list|(
name|clientid
argument_list|,
name|stateidp
argument_list|,
name|stp
argument_list|,
name|vp
argument_list|,
name|nd
argument_list|,
name|p
argument_list|,
name|nd
operator|->
name|nd_repstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|tempsize
operator|=
name|nvap
operator|->
name|na_size
expr_stmt|;
name|NFSVNO_ATTRINIT
argument_list|(
name|nvap
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_size
operator|=
name|tempsize
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|,
name|cred
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsrv_opencheck
argument_list|(
name|clientid
argument_list|,
name|stateidp
argument_list|,
name|stp
argument_list|,
name|vp
argument_list|,
name|nd
argument_list|,
name|p
argument_list|,
name|nd
operator|->
name|nd_repstat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|ndp
operator|->
name|ni_cnd
operator|.
name|cn_flags
operator|&
name|HASBUF
condition|)
name|nfsvno_relpathbuf
argument_list|(
name|ndp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_startdir
operator|&&
name|create
operator|==
name|NFSV4OPEN_CREATE
condition|)
block|{
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_startdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_dvp
operator|==
name|ndp
operator|->
name|ni_vp
condition|)
name|vrele
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|ndp
operator|->
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndp
operator|->
name|ni_vp
condition|)
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Updates the file rev and sets the mtime and ctime  * to the current clock time, returning the va_filerev and va_Xtime  * values.  */
end_comment

begin_function
name|void
name|nfsvno_updfilerev
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|vattr
name|va
decl_stmt|;
name|VATTR_NULL
argument_list|(
operator|&
name|va
argument_list|)
expr_stmt|;
name|getnanotime
argument_list|(
operator|&
name|va
operator|.
name|va_mtime
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|cred
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsvno_getattr
argument_list|(
name|vp
argument_list|,
name|nvap
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Glue routine to nfsv4_fillattr().  */
end_comment

begin_function
name|int
name|nfsvno_fillattr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|fhandle_t
modifier|*
name|fhp
parameter_list|,
name|int
name|rderror
parameter_list|,
name|nfsattrbit_t
modifier|*
name|attrbitp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|int
name|isdgram
parameter_list|,
name|int
name|reterr
parameter_list|,
name|int
name|supports_nfsv4acls
parameter_list|,
name|int
name|at_root
parameter_list|,
name|uint64_t
name|mounted_on_fileno
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|nfsv4_fillattr
argument_list|(
name|nd
argument_list|,
name|mp
argument_list|,
name|vp
argument_list|,
name|NULL
argument_list|,
operator|&
name|nvap
operator|->
name|na_vattr
argument_list|,
name|fhp
argument_list|,
name|rderror
argument_list|,
name|attrbitp
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
name|isdgram
argument_list|,
name|reterr
argument_list|,
name|supports_nfsv4acls
argument_list|,
name|at_root
argument_list|,
name|mounted_on_fileno
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Since the Readdir vnode ops vary, put the entire functions in here. */
end_comment

begin_comment
comment|/*  * nfs readdir service  * - mallocs what it thinks is enough to read  *	count rounded up to a multiple of DIRBLKSIZ<= NFS_MAXREADDIR  * - calls VOP_READDIR()  * - loops around building the reply  *	if the output generated exceeds count break out of loop  *	The NFSM_CLGET macro is used here so that the reply will be packed  *	tightly in mbuf clusters.  * - it trims out records with d_fileno == 0  *	this doesn't matter for Unix clients, but they might confuse clients  *	for other os'.  * - it trims out records with d_type == DT_WHT  *	these cannot be seen through NFS (unless we extend the protocol)  *     The alternate call nfsrvd_readdirplus() does lookups as well.  * PS: The NFS protocol spec. does not clarify what the "count" byte  *	argument is a count of.. just name strings and file id's or the  *	entire reply rpc or ...  *	I tried just file name and id sizes and it confused the Sun client,  *	so I am using the full rpc size now. The "paranoia.." comment refers  *	to including the status longwords that are not a part of the dir.  *	"entry" structures, but are in the rpc.  */
end_comment

begin_function
name|int
name|nfsrvd_readdir
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|int
name|isdgram
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|dirlen
decl_stmt|;
name|char
modifier|*
name|cpos
decl_stmt|,
modifier|*
name|cend
decl_stmt|,
modifier|*
name|rbuf
decl_stmt|;
name|struct
name|nfsvattr
name|at
decl_stmt|;
name|int
name|nlen
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|getret
init|=
literal|1
decl_stmt|;
name|int
name|siz
decl_stmt|,
name|cnt
decl_stmt|,
name|fullsiz
decl_stmt|,
name|eofflag
decl_stmt|,
name|ncookies
decl_stmt|;
name|u_int64_t
name|off
decl_stmt|,
name|toff
decl_stmt|,
name|verf
decl_stmt|;
name|u_long
modifier|*
name|cookies
init|=
name|NULL
decl_stmt|,
modifier|*
name|cookiep
decl_stmt|;
name|struct
name|uio
name|io
decl_stmt|;
name|struct
name|iovec
name|iv
decl_stmt|;
name|int
name|not_zfs
decl_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|nfsrv_postopattr
argument_list|(
name|nd
argument_list|,
name|getret
argument_list|,
operator|&
name|at
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|off
operator|=
name|fxdr_unsigned
argument_list|(
name|u_quad_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|5
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|off
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|verf
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
block|}
name|toff
operator|=
name|off
expr_stmt|;
name|cnt
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|NFS_SRVMAXDATA
argument_list|(
name|nd
argument_list|)
operator|||
name|cnt
operator|<
literal|0
condition|)
name|cnt
operator|=
name|NFS_SRVMAXDATA
argument_list|(
name|nd
argument_list|)
expr_stmt|;
name|siz
operator|=
operator|(
operator|(
name|cnt
operator|+
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|fullsiz
operator|=
name|siz
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|getret
operator|=
name|nfsvno_getattr
argument_list|(
name|vp
argument_list|,
operator|&
name|at
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 		 * va_filerev is not sufficient as a cookie verifier, 		 * since it is not supposed to change when entries are 		 * removed/added unless that offset cookies returned to 		 * the client are no longer valid. 		 */
block|if (!nd->nd_repstat&& toff&& verf != at.na_filerev) 			nd->nd_repstat = NFSERR_BAD_COOKIE;
endif|#
directive|endif
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
literal|0
operator|&&
name|cnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
condition|)
comment|/* NFSv2 does not have NFSERR_TOOSMALL */
name|nd
operator|->
name|nd_repstat
operator|=
name|EPERM
expr_stmt|;
else|else
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_TOOSMALL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsvno_accchk
argument_list|(
name|vp
argument_list|,
name|VEXEC
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
name|exp
argument_list|,
name|p
argument_list|,
name|NFSACCCHK_NOOVERRIDE
argument_list|,
name|NFSACCCHK_VPISLOCKED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|nfsrv_postopattr
argument_list|(
name|nd
argument_list|,
name|getret
argument_list|,
operator|&
name|at
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|not_zfs
operator|=
name|strcmp
argument_list|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_vfc
operator|->
name|vfc_name
argument_list|,
literal|"zfs"
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|rbuf
argument_list|,
name|caddr_t
argument_list|,
name|siz
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|again
label|:
name|eofflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cookies
operator|=
name|NULL
expr_stmt|;
block|}
name|iv
operator|.
name|iov_base
operator|=
name|rbuf
expr_stmt|;
name|iv
operator|.
name|iov_len
operator|=
name|siz
expr_stmt|;
name|io
operator|.
name|uio_iov
operator|=
operator|&
name|iv
expr_stmt|;
name|io
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|io
operator|.
name|uio_offset
operator|=
operator|(
name|off_t
operator|)
name|off
expr_stmt|;
name|io
operator|.
name|uio_resid
operator|=
name|siz
expr_stmt|;
name|io
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|io
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|io
operator|.
name|uio_td
operator|=
name|NULL
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|VOP_READDIR
argument_list|(
name|vp
argument_list|,
operator|&
name|io
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
operator|&
name|eofflag
argument_list|,
operator|&
name|ncookies
argument_list|,
operator|&
name|cookies
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
name|u_int64_t
operator|)
name|io
operator|.
name|uio_offset
expr_stmt|;
if|if
condition|(
name|io
operator|.
name|uio_resid
condition|)
name|siz
operator|-=
name|io
operator|.
name|uio_resid
expr_stmt|;
if|if
condition|(
operator|!
name|cookies
operator|&&
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_PERM
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|getret
operator|=
name|nfsvno_getattr
argument_list|(
name|vp
argument_list|,
operator|&
name|at
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|getret
expr_stmt|;
block|}
comment|/* 	 * Handles the failed cases. nd->nd_repstat == 0 past here. 	 */
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|nfsrv_postopattr
argument_list|(
name|nd
argument_list|,
name|getret
argument_list|,
operator|&
name|at
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If nothing read, return eof 	 * rpc reply 	 */
if|if
condition|(
name|siz
operator|==
literal|0
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nfsrv_postopattr
argument_list|(
name|nd
argument_list|,
name|getret
argument_list|,
operator|&
name|at
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|at
operator|.
name|na_filerev
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
block|}
operator|*
name|tl
operator|++
operator|=
name|newnfs_false
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|rbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check for degenerate cases of nothing useful read. 	 * If so go try again 	 */
name|cpos
operator|=
name|rbuf
expr_stmt|;
name|cend
operator|=
name|rbuf
operator|+
name|siz
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|cpos
expr_stmt|;
name|cookiep
operator|=
name|cookies
expr_stmt|;
comment|/* 	 * For some reason FreeBSD's ufs_readdir() chooses to back the 	 * directory offset up to a block boundary, so it is necessary to 	 * skip over the records that precede the requested offset. This 	 * requires the assumption that file offset cookies monotonically 	 * increase. 	 * Since the offset cookies don't monotonically increase for ZFS, 	 * this is not done when ZFS is the file system. 	 */
while|while
condition|(
name|cpos
operator|<
name|cend
operator|&&
name|ncookies
operator|>
literal|0
operator|&&
operator|(
name|dp
operator|->
name|d_fileno
operator|==
literal|0
operator|||
name|dp
operator|->
name|d_type
operator|==
name|DT_WHT
operator|||
operator|(
name|not_zfs
operator|!=
literal|0
operator|&&
operator|(
call|(
name|u_quad_t
call|)
argument_list|(
operator|*
name|cookiep
argument_list|)
operator|)
operator|<=
name|toff
operator|)
operator|)
condition|)
block|{
name|cpos
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|cpos
expr_stmt|;
name|cookiep
operator|++
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|cpos
operator|>=
name|cend
operator|||
name|ncookies
operator|==
literal|0
condition|)
block|{
name|siz
operator|=
name|fullsiz
expr_stmt|;
name|toff
operator|=
name|off
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * dirlen is the size of the reply, including all XDR and must 	 * not exceed cnt. For NFSv2, RFC1094 didn't clearly indicate 	 * if the XDR should be included in "count", but to be safe, we do. 	 * (Include the two booleans at the end of the reply in dirlen now.) 	 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|nfsrv_postopattr
argument_list|(
name|nd
argument_list|,
name|getret
argument_list|,
operator|&
name|at
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|at
operator|.
name|na_filerev
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|dirlen
operator|=
name|NFSX_V3POSTOPATTR
operator|+
name|NFSX_VERF
operator|+
literal|2
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
block|}
else|else
block|{
name|dirlen
operator|=
literal|2
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
block|}
comment|/* Loop through the records and build reply */
while|while
condition|(
name|cpos
operator|<
name|cend
operator|&&
name|ncookies
operator|>
literal|0
condition|)
block|{
name|nlen
operator|=
name|dp
operator|->
name|d_namlen
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_fileno
operator|!=
literal|0
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|DT_WHT
operator|&&
name|nlen
operator|<=
name|NFS_MAXNAMLEN
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|dirlen
operator|+=
operator|(
literal|6
operator|*
name|NFSX_UNSIGNED
operator|+
name|NFSM_RNDUP
argument_list|(
name|nlen
argument_list|)
operator|)
expr_stmt|;
else|else
name|dirlen
operator|+=
operator|(
literal|4
operator|*
name|NFSX_UNSIGNED
operator|+
name|NFSM_RNDUP
argument_list|(
name|nlen
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|dirlen
operator|>
name|cnt
condition|)
block|{
name|eofflag
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 			 * Build the directory record xdr from 			 * the dirent entry. 			 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_true
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_true
expr_stmt|;
block|}
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|dp
operator|->
name|d_fileno
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
operator|*
name|cookiep
argument_list|)
expr_stmt|;
block|}
name|cpos
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|cpos
expr_stmt|;
name|cookiep
operator|++
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|cpos
operator|<
name|cend
condition|)
name|eofflag
operator|=
literal|0
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_false
expr_stmt|;
if|if
condition|(
name|eofflag
condition|)
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
else|else
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|rbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nfsmout
label|:
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Readdirplus for V3 and Readdir for V4.  */
end_comment

begin_function
name|int
name|nfsrvd_readdirplus
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|int
name|isdgram
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|)
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|dirlen
decl_stmt|;
name|char
modifier|*
name|cpos
decl_stmt|,
modifier|*
name|cend
decl_stmt|,
modifier|*
name|rbuf
decl_stmt|;
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|fhandle_t
name|nfh
decl_stmt|;
name|struct
name|nfsvattr
name|nva
decl_stmt|,
name|at
decl_stmt|,
modifier|*
name|nvap
init|=
operator|&
name|nva
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb0
decl_stmt|,
modifier|*
name|mb1
decl_stmt|;
name|struct
name|nfsreferral
modifier|*
name|refp
decl_stmt|;
name|int
name|nlen
decl_stmt|,
name|r
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|getret
init|=
literal|1
decl_stmt|,
name|usevget
init|=
literal|1
decl_stmt|;
name|int
name|siz
decl_stmt|,
name|cnt
decl_stmt|,
name|fullsiz
decl_stmt|,
name|eofflag
decl_stmt|,
name|ncookies
decl_stmt|,
name|entrycnt
decl_stmt|;
name|caddr_t
name|bpos0
decl_stmt|,
name|bpos1
decl_stmt|;
name|u_int64_t
name|off
decl_stmt|,
name|toff
decl_stmt|,
name|verf
decl_stmt|;
name|u_long
modifier|*
name|cookies
init|=
name|NULL
decl_stmt|,
modifier|*
name|cookiep
decl_stmt|;
name|nfsattrbit_t
name|attrbits
decl_stmt|,
name|rderrbits
decl_stmt|,
name|savbits
decl_stmt|;
name|struct
name|uio
name|io
decl_stmt|;
name|struct
name|iovec
name|iv
decl_stmt|;
name|struct
name|componentname
name|cn
decl_stmt|;
name|int
name|at_root
decl_stmt|,
name|needs_unbusy
decl_stmt|,
name|not_zfs
decl_stmt|,
name|supports_nfsv4acls
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|,
modifier|*
name|new_mp
decl_stmt|;
name|uint64_t
name|mounted_on_fileno
decl_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|nfsrv_postopattr
argument_list|(
name|nd
argument_list|,
name|getret
argument_list|,
operator|&
name|at
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|6
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|off
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|toff
operator|=
name|off
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|verf
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|siz
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
comment|/* 	 * Use the server's maximum data transfer size as the upper bound 	 * on reply datalen. 	 */
if|if
condition|(
name|cnt
operator|>
name|NFS_SRVMAXDATA
argument_list|(
name|nd
argument_list|)
operator|||
name|cnt
operator|<
literal|0
condition|)
name|cnt
operator|=
name|NFS_SRVMAXDATA
argument_list|(
name|nd
argument_list|)
expr_stmt|;
comment|/* 	 * siz is a "hint" of how much directory information (name, fileid, 	 * cookie) should be in the reply. At least one client "hints" 0, 	 * so I set it to cnt for that case. I also round it up to the 	 * next multiple of DIRBLKSIZ. 	 */
if|if
condition|(
name|siz
operator|<=
literal|0
condition|)
name|siz
operator|=
name|cnt
expr_stmt|;
name|siz
operator|=
operator|(
operator|(
name|siz
operator|+
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DIRBLKSIZ
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
operator|&
name|attrbits
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|NFSSET_ATTRBIT
argument_list|(
operator|&
name|savbits
argument_list|,
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSCLRNOTFILLABLE_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|rderrbits
argument_list|)
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|rderrbits
argument_list|,
name|NFSATTRBIT_RDATTRERROR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
expr_stmt|;
block|}
name|fullsiz
operator|=
name|siz
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|getret
operator|=
name|nfsvno_getattr
argument_list|(
name|vp
argument_list|,
operator|&
name|at
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
if|if
condition|(
name|off
operator|&&
name|verf
operator|!=
name|at
operator|.
name|na_filerev
condition|)
block|{
comment|/* 		 * va_filerev is not sufficient as a cookie verifier, 		 * since it is not supposed to change when entries are 		 * removed/added unless that offset cookies returned to 		 * the client are no longer valid. 		 */
if|#
directive|if
literal|0
block|if (nd->nd_flag& ND_NFSV4) { 			nd->nd_repstat = NFSERR_NOTSAME; 		} else { 			nd->nd_repstat = NFSERR_BAD_COOKIE; 		}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|&&
name|off
operator|==
literal|0
operator|&&
name|verf
operator|!=
literal|0
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_BAD_COOKIE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_NOTDIR
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
name|cnt
operator|==
literal|0
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_TOOSMALL
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsvno_accchk
argument_list|(
name|vp
argument_list|,
name|VEXEC
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
name|exp
argument_list|,
name|p
argument_list|,
name|NFSACCCHK_NOOVERRIDE
argument_list|,
name|NFSACCCHK_VPISLOCKED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|nfsrv_postopattr
argument_list|(
name|nd
argument_list|,
name|getret
argument_list|,
operator|&
name|at
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|not_zfs
operator|=
name|strcmp
argument_list|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_vfc
operator|->
name|vfc_name
argument_list|,
literal|"zfs"
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|rbuf
argument_list|,
name|caddr_t
argument_list|,
name|siz
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|again
label|:
name|eofflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cookies
operator|=
name|NULL
expr_stmt|;
block|}
name|iv
operator|.
name|iov_base
operator|=
name|rbuf
expr_stmt|;
name|iv
operator|.
name|iov_len
operator|=
name|siz
expr_stmt|;
name|io
operator|.
name|uio_iov
operator|=
operator|&
name|iv
expr_stmt|;
name|io
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|io
operator|.
name|uio_offset
operator|=
operator|(
name|off_t
operator|)
name|off
expr_stmt|;
name|io
operator|.
name|uio_resid
operator|=
name|siz
expr_stmt|;
name|io
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|io
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|io
operator|.
name|uio_td
operator|=
name|NULL
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|VOP_READDIR
argument_list|(
name|vp
argument_list|,
operator|&
name|io
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
operator|&
name|eofflag
argument_list|,
operator|&
name|ncookies
argument_list|,
operator|&
name|cookies
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
name|u_int64_t
operator|)
name|io
operator|.
name|uio_offset
expr_stmt|;
if|if
condition|(
name|io
operator|.
name|uio_resid
condition|)
name|siz
operator|-=
name|io
operator|.
name|uio_resid
expr_stmt|;
name|getret
operator|=
name|nfsvno_getattr
argument_list|(
name|vp
argument_list|,
operator|&
name|at
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cookies
operator|&&
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_PERM
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|getret
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|nfsrv_postopattr
argument_list|(
name|nd
argument_list|,
name|getret
argument_list|,
operator|&
name|at
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If nothing read, return eof 	 * rpc reply 	 */
if|if
condition|(
name|siz
operator|==
literal|0
condition|)
block|{
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|nfsrv_postopattr
argument_list|(
name|nd
argument_list|,
name|getret
argument_list|,
operator|&
name|at
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|4
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|at
operator|.
name|na_filerev
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_false
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check for degenerate cases of nothing useful read. 	 * If so go try again 	 */
name|cpos
operator|=
name|rbuf
expr_stmt|;
name|cend
operator|=
name|rbuf
operator|+
name|siz
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|cpos
expr_stmt|;
name|cookiep
operator|=
name|cookies
expr_stmt|;
comment|/* 	 * For some reason FreeBSD's ufs_readdir() chooses to back the 	 * directory offset up to a block boundary, so it is necessary to 	 * skip over the records that precede the requested offset. This 	 * requires the assumption that file offset cookies monotonically 	 * increase. 	 * Since the offset cookies don't monotonically increase for ZFS, 	 * this is not done when ZFS is the file system. 	 */
while|while
condition|(
name|cpos
operator|<
name|cend
operator|&&
name|ncookies
operator|>
literal|0
operator|&&
operator|(
name|dp
operator|->
name|d_fileno
operator|==
literal|0
operator|||
name|dp
operator|->
name|d_type
operator|==
name|DT_WHT
operator|||
operator|(
name|not_zfs
operator|!=
literal|0
operator|&&
operator|(
call|(
name|u_quad_t
call|)
argument_list|(
operator|*
name|cookiep
argument_list|)
operator|)
operator|<=
name|toff
operator|)
operator|||
operator|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|&&
operator|(
operator|(
name|dp
operator|->
name|d_namlen
operator|==
literal|1
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|dp
operator|->
name|d_namlen
operator|==
literal|2
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
name|cpos
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|cpos
expr_stmt|;
name|cookiep
operator|++
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|cpos
operator|>=
name|cend
operator|||
name|ncookies
operator|==
literal|0
condition|)
block|{
name|siz
operator|=
name|fullsiz
expr_stmt|;
name|toff
operator|=
name|off
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * Busy the file system so that the mount point won't go away 	 * and, as such, VFS_VGET() can be used safely. 	 */
name|mp
operator|=
name|vp
operator|->
name|v_mount
expr_stmt|;
name|vfs_ref
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|vfs_busy
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vfs_rel
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
literal|0
condition|)
block|{
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|nfsrv_postopattr
argument_list|(
name|nd
argument_list|,
name|getret
argument_list|,
operator|&
name|at
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Save this position, in case there is an error before one entry 	 * is created. 	 */
name|mb0
operator|=
name|nd
operator|->
name|nd_mb
expr_stmt|;
name|bpos0
operator|=
name|nd
operator|->
name|nd_bpos
expr_stmt|;
comment|/* 	 * Fill in the first part of the reply. 	 * dirlen is the reply length in bytes and cannot exceed cnt. 	 * (Include the two booleans at the end of the reply in dirlen now, 	 *  so we recognize when we have exceeded cnt.) 	 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|dirlen
operator|=
name|NFSX_V3POSTOPATTR
operator|+
name|NFSX_VERF
operator|+
literal|2
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
name|nfsrv_postopattr
argument_list|(
name|nd
argument_list|,
name|getret
argument_list|,
operator|&
name|at
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dirlen
operator|=
name|NFSX_VERF
operator|+
literal|2
operator|*
name|NFSX_UNSIGNED
expr_stmt|;
block|}
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_VERF
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|at
operator|.
name|na_filerev
argument_list|,
name|tl
argument_list|)
expr_stmt|;
comment|/* 	 * Save this position, in case there is an empty reply needed. 	 */
name|mb1
operator|=
name|nd
operator|->
name|nd_mb
expr_stmt|;
name|bpos1
operator|=
name|nd
operator|->
name|nd_bpos
expr_stmt|;
comment|/* Loop through the records and build reply */
name|entrycnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cpos
operator|<
name|cend
operator|&&
name|ncookies
operator|>
literal|0
operator|&&
name|dirlen
operator|<
name|cnt
condition|)
block|{
name|nlen
operator|=
name|dp
operator|->
name|d_namlen
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_fileno
operator|!=
literal|0
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|DT_WHT
operator|&&
name|nlen
operator|<=
name|NFS_MAXNAMLEN
operator|&&
operator|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|||
name|nlen
operator|>
literal|2
operator|||
operator|(
name|nlen
operator|==
literal|2
operator|&&
operator|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'.'
operator|)
operator|)
operator|||
operator|(
name|nlen
operator|==
literal|1
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|)
operator|)
condition|)
block|{
comment|/* 			 * Save the current position in the reply, in case 			 * this entry exceeds cnt. 			 */
name|mb1
operator|=
name|nd
operator|->
name|nd_mb
expr_stmt|;
name|bpos1
operator|=
name|nd
operator|->
name|nd_bpos
expr_stmt|;
comment|/* 			 * For readdir_and_lookup get the vnode using 			 * the file number. 			 */
name|nvp
operator|=
name|NULL
expr_stmt|;
name|refp
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
name|at_root
operator|=
literal|0
expr_stmt|;
name|needs_unbusy
operator|=
literal|0
expr_stmt|;
name|new_mp
operator|=
name|mp
expr_stmt|;
name|mounted_on_fileno
operator|=
operator|(
name|uint64_t
operator|)
name|dp
operator|->
name|d_fileno
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|||
name|NFSNONZERO_ATTRBIT
argument_list|(
operator|&
name|savbits
argument_list|)
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|refp
operator|=
name|nfsv4root_getreferral
argument_list|(
name|NULL
argument_list|,
name|vp
argument_list|,
name|dp
operator|->
name|d_fileno
argument_list|)
expr_stmt|;
if|if
condition|(
name|refp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|usevget
condition|)
name|r
operator|=
name|VFS_VGET
argument_list|(
name|mp
argument_list|,
name|dp
operator|->
name|d_fileno
argument_list|,
name|LK_SHARED
argument_list|,
operator|&
name|nvp
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|EOPNOTSUPP
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|EOPNOTSUPP
condition|)
block|{
if|if
condition|(
name|usevget
condition|)
block|{
name|usevget
operator|=
literal|0
expr_stmt|;
name|cn
operator|.
name|cn_nameiop
operator|=
name|LOOKUP
expr_stmt|;
name|cn
operator|.
name|cn_lkflags
operator|=
name|LK_SHARED
operator||
name|LK_RETRY
expr_stmt|;
name|cn
operator|.
name|cn_cred
operator|=
name|nd
operator|->
name|nd_cred
expr_stmt|;
name|cn
operator|.
name|cn_thread
operator|=
name|p
expr_stmt|;
block|}
name|cn
operator|.
name|cn_nameptr
operator|=
name|dp
operator|->
name|d_name
expr_stmt|;
name|cn
operator|.
name|cn_namelen
operator|=
name|nlen
expr_stmt|;
name|cn
operator|.
name|cn_flags
operator|=
name|ISLASTCN
operator||
name|NOFOLLOW
operator||
name|LOCKLEAF
operator||
name|MPSAFE
expr_stmt|;
if|if
condition|(
name|nlen
operator|==
literal|2
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
name|cn
operator|.
name|cn_flags
operator||=
name|ISDOTDOT
expr_stmt|;
if|if
condition|(
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|vp
operator|->
name|v_vflag
operator|&
name|VV_ROOT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|cn
operator|.
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|!=
literal|0
condition|)
block|{
name|vref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|nvp
operator|=
name|vp
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|VOP_LOOKUP
argument_list|(
name|vp
argument_list|,
operator|&
name|nvp
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|nvp
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 					 * For NFSv4, check to see if nvp is 					 * a mount point and get the mount 					 * point vnode, as required. 					 */
if|if
condition|(
name|r
operator|==
literal|0
operator|&&
name|nfsrv_enable_crossmntpt
operator|!=
literal|0
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|!=
literal|0
operator|&&
name|nvp
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
name|nvp
operator|->
name|v_mountedhere
operator|!=
name|NULL
condition|)
block|{
name|new_mp
operator|=
name|nvp
operator|->
name|v_mountedhere
expr_stmt|;
name|r
operator|=
name|vfs_busy
argument_list|(
name|new_mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nvp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|r
operator|=
name|VFS_ROOT
argument_list|(
name|new_mp
argument_list|,
name|LK_SHARED
argument_list|,
operator|&
name|nvp
argument_list|)
expr_stmt|;
name|needs_unbusy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
name|at_root
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|r
condition|)
block|{
if|if
condition|(
name|refp
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|||
name|NFSNONZERO_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|)
operator|)
condition|)
block|{
name|r
operator|=
name|nfsvno_getfh
argument_list|(
name|nvp
argument_list|,
operator|&
name|nfh
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
name|r
operator|=
name|nfsvno_getattr
argument_list|(
name|nvp
argument_list|,
name|nvap
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|nvp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|r
condition|)
block|{
if|if
condition|(
operator|!
name|NFSISSET_ATTRBIT
argument_list|(
operator|&
name|attrbits
argument_list|,
name|NFSATTRBIT_RDATTRERROR
argument_list|)
condition|)
block|{
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
name|vput
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_unbusy
operator|!=
literal|0
condition|)
name|vfs_unbusy
argument_list|(
name|new_mp
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|r
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 			 * Build the directory record xdr 			 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_true
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|dp
operator|->
name|d_fileno
argument_list|)
expr_stmt|;
name|dirlen
operator|+=
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
operator|*
name|cookiep
argument_list|)
expr_stmt|;
name|nfsrv_postopattr
argument_list|(
name|nd
argument_list|,
literal|0
argument_list|,
name|nvap
argument_list|)
expr_stmt|;
name|dirlen
operator|+=
name|nfsm_fhtom
argument_list|(
name|nd
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|nfh
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dirlen
operator|+=
operator|(
literal|5
operator|*
name|NFSX_UNSIGNED
operator|+
name|NFSX_V3POSTOPATTR
operator|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
name|vput
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|3
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_true
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
operator|*
name|cookiep
argument_list|)
expr_stmt|;
name|dirlen
operator|+=
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
block|{
name|supports_nfsv4acls
operator|=
name|nfs_supportsnfsv4acls
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|nvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|supports_nfsv4acls
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|refp
operator|!=
name|NULL
condition|)
block|{
name|dirlen
operator|+=
name|nfsrv_putreferralattr
argument_list|(
name|nd
argument_list|,
operator|&
name|savbits
argument_list|,
name|refp
argument_list|,
literal|0
argument_list|,
operator|&
name|nd
operator|->
name|nd_repstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_unbusy
operator|!=
literal|0
condition|)
name|vfs_unbusy
argument_list|(
name|new_mp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|r
condition|)
block|{
name|dirlen
operator|+=
name|nfsvno_fillattr
argument_list|(
name|nd
argument_list|,
name|new_mp
argument_list|,
name|nvp
argument_list|,
name|nvap
argument_list|,
operator|&
name|nfh
argument_list|,
name|r
argument_list|,
operator|&
name|rderrbits
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
name|p
argument_list|,
name|isdgram
argument_list|,
literal|0
argument_list|,
name|supports_nfsv4acls
argument_list|,
name|at_root
argument_list|,
name|mounted_on_fileno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dirlen
operator|+=
name|nfsvno_fillattr
argument_list|(
name|nd
argument_list|,
name|new_mp
argument_list|,
name|nvp
argument_list|,
name|nvap
argument_list|,
operator|&
name|nfh
argument_list|,
name|r
argument_list|,
operator|&
name|attrbits
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
name|p
argument_list|,
name|isdgram
argument_list|,
literal|0
argument_list|,
name|supports_nfsv4acls
argument_list|,
name|at_root
argument_list|,
name|mounted_on_fileno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|dirlen
operator|+=
operator|(
literal|3
operator|*
name|NFSX_UNSIGNED
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|needs_unbusy
operator|!=
literal|0
condition|)
name|vfs_unbusy
argument_list|(
name|new_mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirlen
operator|<=
name|cnt
condition|)
name|entrycnt
operator|++
expr_stmt|;
block|}
name|cpos
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|cpos
expr_stmt|;
name|cookiep
operator|++
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * If dirlen> cnt, we must strip off the last entry. If that 	 * results in an empty reply, report NFSERR_TOOSMALL. 	 */
if|if
condition|(
name|dirlen
operator|>
name|cnt
operator|||
name|nd
operator|->
name|nd_repstat
condition|)
block|{
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
name|entrycnt
operator|==
literal|0
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_TOOSMALL
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
name|newnfs_trimtrailing
argument_list|(
name|nd
argument_list|,
name|mb0
argument_list|,
name|bpos0
argument_list|)
expr_stmt|;
else|else
name|newnfs_trimtrailing
argument_list|(
name|nd
argument_list|,
name|mb1
argument_list|,
name|bpos1
argument_list|)
expr_stmt|;
name|eofflag
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cpos
operator|<
name|cend
condition|)
name|eofflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_false
expr_stmt|;
if|if
condition|(
name|eofflag
condition|)
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
else|else
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
block|}
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|rbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|nfsmout
label|:
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the settable attributes out of the mbuf list.  * (Return 0 or EBADRPC)  */
end_comment

begin_function
name|int
name|nfsrv_sattr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|nfsattrbit_t
modifier|*
name|attrbitp
parameter_list|,
name|NFSACL_T
modifier|*
name|aclp
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|nfsv2_sattr
modifier|*
name|sp
decl_stmt|;
name|struct
name|timeval
name|curtime
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|toclient
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV2
operator||
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
case|case
name|ND_NFSV2
case|:
name|NFSM_DISSECT
argument_list|(
name|sp
argument_list|,
expr|struct
name|nfsv2_sattr
operator|*
argument_list|,
name|NFSX_V2SATTR
argument_list|)
expr_stmt|;
comment|/* 		 * Some old clients didn't fill in the high order 16bits. 		 * --> check the low order 2 bytes for 0xffff 		 */
if|if
condition|(
operator|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
name|sp
operator|->
name|sa_mode
argument_list|)
operator|&
literal|0xffff
operator|)
operator|!=
literal|0xffff
condition|)
name|nvap
operator|->
name|na_mode
operator|=
name|nfstov_mode
argument_list|(
name|sp
operator|->
name|sa_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sa_uid
operator|!=
name|newnfs_xdrneg1
condition|)
name|nvap
operator|->
name|na_uid
operator|=
name|fxdr_unsigned
argument_list|(
name|uid_t
argument_list|,
name|sp
operator|->
name|sa_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sa_gid
operator|!=
name|newnfs_xdrneg1
condition|)
name|nvap
operator|->
name|na_gid
operator|=
name|fxdr_unsigned
argument_list|(
name|gid_t
argument_list|,
name|sp
operator|->
name|sa_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sa_size
operator|!=
name|newnfs_xdrneg1
condition|)
name|nvap
operator|->
name|na_size
operator|=
name|fxdr_unsigned
argument_list|(
name|u_quad_t
argument_list|,
name|sp
operator|->
name|sa_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sa_atime
operator|.
name|nfsv2_sec
operator|!=
name|newnfs_xdrneg1
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
name|fxdr_nfsv2time
argument_list|(
operator|&
name|sp
operator|->
name|sa_atime
argument_list|,
operator|&
name|nvap
operator|->
name|na_atime
argument_list|)
expr_stmt|;
else|#
directive|else
name|nvap
operator|->
name|na_atime
operator|.
name|tv_sec
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
name|sp
operator|->
name|sa_atime
operator|.
name|nfsv2_sec
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_atime
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|sp
operator|->
name|sa_mtime
operator|.
name|nfsv2_sec
operator|!=
name|newnfs_xdrneg1
condition|)
name|fxdr_nfsv2time
argument_list|(
operator|&
name|sp
operator|->
name|sa_mtime
argument_list|,
operator|&
name|nvap
operator|->
name|na_mtime
argument_list|)
expr_stmt|;
break|break;
case|case
name|ND_NFSV3
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_true
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_mode
operator|=
name|nfstov_mode
argument_list|(
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_true
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_uid
operator|=
name|fxdr_unsigned
argument_list|(
name|uid_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_true
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_gid
operator|=
name|fxdr_unsigned
argument_list|(
name|gid_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|==
name|newnfs_true
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_size
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
condition|)
block|{
case|case
name|NFSV3SATTRTIME_TOCLIENT
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|fxdr_nfsv3time
argument_list|(
name|tl
argument_list|,
operator|&
name|nvap
operator|->
name|na_atime
argument_list|)
expr_stmt|;
name|toclient
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NFSV3SATTRTIME_TOSERVER
case|:
name|NFSGETTIME
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_atime
operator|.
name|tv_sec
operator|=
name|curtime
operator|.
name|tv_sec
expr_stmt|;
name|nvap
operator|->
name|na_atime
operator|.
name|tv_nsec
operator|=
name|curtime
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
name|nvap
operator|->
name|na_vaflags
operator||=
name|VA_UTIMES_NULL
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
condition|)
block|{
case|case
name|NFSV3SATTRTIME_TOCLIENT
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|fxdr_nfsv3time
argument_list|(
name|tl
argument_list|,
operator|&
name|nvap
operator|->
name|na_mtime
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_vaflags
operator|&=
operator|~
name|VA_UTIMES_NULL
expr_stmt|;
break|break;
case|case
name|NFSV3SATTRTIME_TOSERVER
case|:
name|NFSGETTIME
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_mtime
operator|.
name|tv_sec
operator|=
name|curtime
operator|.
name|tv_sec
expr_stmt|;
name|nvap
operator|->
name|na_mtime
operator|.
name|tv_nsec
operator|=
name|curtime
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
operator|!
name|toclient
condition|)
name|nvap
operator|->
name|na_vaflags
operator||=
name|VA_UTIMES_NULL
expr_stmt|;
break|break;
block|}
empty_stmt|;
break|break;
case|case
name|ND_NFSV4
case|:
name|error
operator|=
name|nfsv4_sattr
argument_list|(
name|nd
argument_list|,
name|nvap
argument_list|,
name|attrbitp
argument_list|,
name|aclp
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle the setable attributes for V4.  * Returns NFSERR_BADXDR if it can't be parsed, 0 otherwise.  */
end_comment

begin_function
name|int
name|nfsv4_sattr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|nfsattrbit_t
modifier|*
name|attrbitp
parameter_list|,
name|NFSACL_T
modifier|*
name|aclp
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|attrsum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|error
decl_stmt|,
name|attrsize
decl_stmt|,
name|bitpos
decl_stmt|,
name|aclsize
decl_stmt|,
name|aceerr
decl_stmt|,
name|retnotsup
init|=
literal|0
decl_stmt|;
name|int
name|toclient
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
name|namestr
index|[
name|NFSV4_SMALLSTR
operator|+
literal|1
index|]
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|struct
name|timeval
name|curtime
decl_stmt|;
name|error
operator|=
name|nfsrv_getattrbits
argument_list|(
name|nd
argument_list|,
name|attrbitp
argument_list|,
name|NULL
argument_list|,
operator|&
name|retnotsup
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|attrsize
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
comment|/* 	 * Loop around getting the setable attributes. If an unsupported 	 * one is found, set nd_repstat == NFSERR_ATTRNOTSUPP and return. 	 */
if|if
condition|(
name|retnotsup
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
name|bitpos
operator|=
name|NFSATTRBIT_MAX
expr_stmt|;
block|}
else|else
block|{
name|bitpos
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|bitpos
operator|<
name|NFSATTRBIT_MAX
condition|;
name|bitpos
operator|++
control|)
block|{
if|if
condition|(
name|attrsum
operator|>
name|attrsize
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|bitpos
argument_list|)
condition|)
switch|switch
condition|(
name|bitpos
condition|)
block|{
case|case
name|NFSATTRBIT_SIZE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_size
operator|=
name|fxdr_hyper
argument_list|(
name|tl
argument_list|)
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_ACL
case|:
name|error
operator|=
name|nfsrv_dissectacl
argument_list|(
name|nd
argument_list|,
name|aclp
argument_list|,
operator|&
name|aceerr
argument_list|,
operator|&
name|aclsize
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
if|if
condition|(
name|aceerr
operator|&&
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
name|attrsum
operator|+=
name|aclsize
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_ARCHIVE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_HIDDEN
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MIMETYPE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|i
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|i
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
name|attrsum
operator|+=
operator|(
name|NFSX_UNSIGNED
operator|+
name|NFSM_RNDUP
argument_list|(
name|i
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_MODE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_mode
operator|=
name|nfstov_mode
argument_list|(
operator|*
name|tl
argument_list|)
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_OWNER
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|j
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
return|return
operator|(
name|NFSERR_BADXDR
operator|)
return|;
if|if
condition|(
name|j
operator|>
name|NFSV4_SMALLSTR
condition|)
name|cp
operator|=
name|malloc
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|M_NFSSTRING
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|namestr
expr_stmt|;
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|j
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsv4_strtouid
argument_list|(
name|cp
argument_list|,
name|j
argument_list|,
operator|&
name|uid
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nvap
operator|->
name|na_uid
operator|=
name|uid
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
name|attrsum
operator|+=
operator|(
name|NFSX_UNSIGNED
operator|+
name|NFSM_RNDUP
argument_list|(
name|j
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_OWNERGROUP
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|j
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
return|return
operator|(
name|NFSERR_BADXDR
operator|)
return|;
if|if
condition|(
name|j
operator|>
name|NFSV4_SMALLSTR
condition|)
name|cp
operator|=
name|malloc
argument_list|(
name|j
operator|+
literal|1
argument_list|,
name|M_NFSSTRING
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|cp
operator|=
name|namestr
expr_stmt|;
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|j
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsv4_strtogid
argument_list|(
name|cp
argument_list|,
name|j
argument_list|,
operator|&
name|gid
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nvap
operator|->
name|na_gid
operator|=
name|gid
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|cp
argument_list|,
name|M_NFSSTRING
argument_list|)
expr_stmt|;
name|attrsum
operator|+=
operator|(
name|NFSX_UNSIGNED
operator|+
name|NFSM_RNDUP
argument_list|(
name|j
argument_list|)
operator|)
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_SYSTEM
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEACCESSSET
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
if|if
condition|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|==
name|NFSV4SATTRTIME_TOCLIENT
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
name|fxdr_nfsv4time
argument_list|(
name|tl
argument_list|,
operator|&
name|nvap
operator|->
name|na_atime
argument_list|)
expr_stmt|;
name|toclient
operator|=
literal|1
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
block|}
else|else
block|{
name|NFSGETTIME
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_atime
operator|.
name|tv_sec
operator|=
name|curtime
operator|.
name|tv_sec
expr_stmt|;
name|nvap
operator|->
name|na_atime
operator|.
name|tv_nsec
operator|=
name|curtime
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
name|nvap
operator|->
name|na_vaflags
operator||=
name|VA_UTIMES_NULL
expr_stmt|;
block|}
break|break;
case|case
name|NFSATTRBIT_TIMEBACKUP
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMECREATE
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_TIMEMODIFYSET
case|:
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
if|if
condition|(
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
operator|==
name|NFSV4SATTRTIME_TOCLIENT
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4TIME
argument_list|)
expr_stmt|;
name|fxdr_nfsv4time
argument_list|(
name|tl
argument_list|,
operator|&
name|nvap
operator|->
name|na_mtime
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_vaflags
operator|&=
operator|~
name|VA_UTIMES_NULL
expr_stmt|;
name|attrsum
operator|+=
name|NFSX_V4TIME
expr_stmt|;
block|}
else|else
block|{
name|NFSGETTIME
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
name|nvap
operator|->
name|na_mtime
operator|.
name|tv_sec
operator|=
name|curtime
operator|.
name|tv_sec
expr_stmt|;
name|nvap
operator|->
name|na_mtime
operator|.
name|tv_nsec
operator|=
name|curtime
operator|.
name|tv_usec
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
operator|!
name|toclient
condition|)
name|nvap
operator|->
name|na_vaflags
operator||=
name|VA_UTIMES_NULL
expr_stmt|;
block|}
break|break;
default|default:
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_ATTRNOTSUPP
expr_stmt|;
comment|/* 			 * set bitpos so we drop out of the loop. 			 */
name|bitpos
operator|=
name|NFSATTRBIT_MAX
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
comment|/* 	 * some clients pad the attrlist, so we need to skip over the 	 * padding. 	 */
if|if
condition|(
name|attrsum
operator|>
name|attrsize
condition|)
block|{
name|error
operator|=
name|NFSERR_BADXDR
expr_stmt|;
block|}
else|else
block|{
name|attrsize
operator|=
name|NFSM_RNDUP
argument_list|(
name|attrsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrsum
operator|<
name|attrsize
condition|)
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|attrsize
operator|-
name|attrsum
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|nfsmout
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check/setup export credentials.  */
end_comment

begin_function
name|int
name|nfsd_excred
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|,
name|struct
name|ucred
modifier|*
name|credanon
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Check/setup credentials. 	 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_GSS
condition|)
name|exp
operator|->
name|nes_exflag
operator|&=
operator|~
name|MNT_EXPORTANON
expr_stmt|;
comment|/* 	 * Check to see if the operation is allowed for this security flavor. 	 * RFC2623 suggests that the NFSv3 Fsinfo RPC be allowed to 	 * AUTH_NONE or AUTH_SYS for file systems requiring RPCSEC_GSS. 	 * Also, allow Secinfo, so that it can acquire the correct flavor(s). 	 */
if|if
condition|(
name|nfsvno_testexp
argument_list|(
name|nd
argument_list|,
name|exp
argument_list|)
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSV4OP_SECINFO
operator|&&
name|nd
operator|->
name|nd_procnum
operator|!=
name|NFSPROC_FSINFO
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|error
operator|=
name|NFSERR_WRONGSEC
expr_stmt|;
else|else
name|error
operator|=
operator|(
name|NFSERR_AUTHERR
operator||
name|AUTH_TOOWEAK
operator|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Check to see if the file system is exported V4 only. 	 */
if|if
condition|(
name|NFSVNO_EXV4ONLY
argument_list|(
name|exp
argument_list|)
operator|&&
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
condition|)
return|return
operator|(
name|NFSERR_PROGNOTV4
operator|)
return|;
comment|/* 	 * Now, map the user credentials. 	 * (Note that ND_AUTHNONE will only be set for an NFSv3 	 *  Fsinfo RPC. If set for anything else, this code might need 	 *  to change.) 	 */
if|if
condition|(
name|NFSVNO_EXPORTED
argument_list|(
name|exp
argument_list|)
operator|&&
operator|(
operator|(
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_GSS
operator|)
operator|&&
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
operator|==
literal|0
operator|)
operator|||
name|NFSVNO_EXPORTANON
argument_list|(
name|exp
argument_list|)
operator|||
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_AUTHNONE
operator|)
operator|)
condition|)
block|{
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
operator|=
name|credanon
operator|->
name|cr_uid
expr_stmt|;
name|nd
operator|->
name|nd_cred
operator|->
name|cr_gid
operator|=
name|credanon
operator|->
name|cr_gid
expr_stmt|;
name|crsetgroups
argument_list|(
name|nd
operator|->
name|nd_cred
argument_list|,
name|credanon
operator|->
name|cr_ngroups
argument_list|,
name|credanon
operator|->
name|cr_groups
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check exports.  */
end_comment

begin_function
name|int
name|nfsvno_checkexp
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|,
name|struct
name|ucred
modifier|*
modifier|*
name|credp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
modifier|*
name|secflavors
decl_stmt|;
name|error
operator|=
name|VFS_CHECKEXP
argument_list|(
name|mp
argument_list|,
name|nam
argument_list|,
operator|&
name|exp
operator|->
name|nes_exflag
argument_list|,
name|credp
argument_list|,
operator|&
name|exp
operator|->
name|nes_numsecflavor
argument_list|,
operator|&
name|secflavors
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|nfs_rootfhset
condition|)
block|{
name|exp
operator|->
name|nes_exflag
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|nes_numsecflavor
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Copy the security flavors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|exp
operator|->
name|nes_numsecflavor
condition|;
name|i
operator|++
control|)
name|exp
operator|->
name|nes_secflavors
index|[
name|i
index|]
operator|=
name|secflavors
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a vnode for a file handle and export stuff.  */
end_comment

begin_function
name|int
name|nfsvno_fhtovp
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|fhandle_t
modifier|*
name|fhp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|int
name|lktype
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|,
name|struct
name|ucred
modifier|*
modifier|*
name|credp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
modifier|*
name|secflavors
decl_stmt|;
operator|*
name|credp
operator|=
name|NULL
expr_stmt|;
name|exp
operator|->
name|nes_numsecflavor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|VFS_NEEDSGIANT
argument_list|(
name|mp
argument_list|)
condition|)
name|error
operator|=
name|ESTALE
expr_stmt|;
else|else
name|error
operator|=
name|VFS_FHTOVP
argument_list|(
name|mp
argument_list|,
operator|&
name|fhp
operator|->
name|fh_fid
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
comment|/* Make sure the server replies ESTALE to the client. */
name|error
operator|=
name|ESTALE
expr_stmt|;
if|if
condition|(
name|nam
operator|&&
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|VFS_CHECKEXP
argument_list|(
name|mp
argument_list|,
name|nam
argument_list|,
operator|&
name|exp
operator|->
name|nes_exflag
argument_list|,
name|credp
argument_list|,
operator|&
name|exp
operator|->
name|nes_numsecflavor
argument_list|,
operator|&
name|secflavors
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|nfs_rootfhset
condition|)
block|{
name|exp
operator|->
name|nes_exflag
operator|=
literal|0
expr_stmt|;
name|exp
operator|->
name|nes_numsecflavor
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|vput
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Copy the security flavors. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|exp
operator|->
name|nes_numsecflavor
condition|;
name|i
operator|++
control|)
name|exp
operator|->
name|nes_secflavors
index|[
name|i
index|]
operator|=
name|secflavors
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|lktype
operator|==
name|LK_SHARED
condition|)
comment|/* 		 * It would be much better to pass lktype to VFS_FHTOVP(), 		 * but this will have to do until VFS_FHTOVP() has a lock 		 * type argument like VFS_VGET(). 		 */
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|LK_DOWNGRADE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the pathconf vnode op.  */
end_comment

begin_function
name|int
name|nfsvno_pathconf
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|flag
parameter_list|,
name|register_t
modifier|*
name|retf
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|VOP_PATHCONF
argument_list|(
name|vp
argument_list|,
name|flag
argument_list|,
name|retf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EOPNOTSUPP
operator|||
name|error
operator|==
name|EINVAL
condition|)
block|{
comment|/* 		 * Some file systems return EINVAL for name arguments not 		 * supported and some return EOPNOTSUPP for this case. 		 * So the NFSv3 Pathconf RPC doesn't fail for these cases, 		 * just fake them. 		 */
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|_PC_LINK_MAX
case|:
operator|*
name|retf
operator|=
name|LINK_MAX
expr_stmt|;
break|break;
case|case
name|_PC_NAME_MAX
case|:
operator|*
name|retf
operator|=
name|NAME_MAX
expr_stmt|;
break|break;
case|case
name|_PC_CHOWN_RESTRICTED
case|:
operator|*
name|retf
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|_PC_NO_TRUNC
case|:
operator|*
name|retf
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Only happens if a _PC_xxx is added to the server, 			 * but this isn't updated. 			 */
operator|*
name|retf
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"nfsrvd pathconf flag=%d not supp\n"
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nfsd_fhtovp() - convert a fh to a vnode ptr  * 	- look up fsid in mount list (if not found ret error)  *	- get vp and export rights by calling nfsvno_fhtovp()  *	- if cred->cr_uid == 0 or MNT_EXPORTANON set it to credanon  *	  for AUTH_SYS  *	- if mpp != NULL, return the mount point so that it can  *	  be used for vn_finished_write() by the caller  */
end_comment

begin_function
name|void
name|nfsd_fhtovp
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsrvfh
modifier|*
name|nfp
parameter_list|,
name|int
name|lktype
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|,
name|struct
name|mount
modifier|*
modifier|*
name|mpp
parameter_list|,
name|int
name|startwrite
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|credanon
decl_stmt|;
name|fhandle_t
modifier|*
name|fhp
decl_stmt|;
name|fhp
operator|=
operator|(
name|fhandle_t
operator|*
operator|)
name|nfp
operator|->
name|nfsrvfh_data
expr_stmt|;
comment|/* 	 * Check for the special case of the nfsv4root_fh. 	 */
name|mp
operator|=
name|vfs_busyfs
argument_list|(
operator|&
name|fhp
operator|->
name|fh_fsid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpp
operator|!=
name|NULL
condition|)
operator|*
name|mpp
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|ESTALE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|startwrite
condition|)
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
name|mpp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsvno_fhtovp
argument_list|(
name|mp
argument_list|,
name|fhp
argument_list|,
name|nd
operator|->
name|nd_nam
argument_list|,
name|lktype
argument_list|,
name|vpp
argument_list|,
name|exp
argument_list|,
operator|&
name|credanon
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * For NFSv4 without a pseudo root fs, unexported file handles 	 * can be returned, so that Lookup works everywhere. 	 */
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
operator|&&
name|exp
operator|->
name|nes_exflag
operator|==
literal|0
operator|&&
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
condition|)
block|{
name|vput
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|EACCES
expr_stmt|;
block|}
comment|/* 	 * Personally, I've never seen any point in requiring a 	 * reserved port#, since only in the rare case where the 	 * clients are all boxes with secure system priviledges, 	 * does it provide any enhanced security, but... some people 	 * believe it to be useful and keep putting this code back in. 	 * (There is also some "security checker" out there that 	 *  complains if the nfs server doesn't enforce this.) 	 * However, note the following: 	 * RFC3530 (NFSv4) specifies that a reserved port# not be 	 *	required. 	 * RFC2623 recommends that, if a reserved port# is checked for, 	 *	that there be a way to turn that off--> ifdef'd. 	 */
ifdef|#
directive|ifdef
name|NFS_REQRSVPORT
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|saddr
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|saddr6
decl_stmt|;
name|saddr
operator|=
name|NFSSOCKADDR
argument_list|(
name|nd
operator|->
name|nd_nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
name|saddr6
operator|=
name|NFSSOCKADDR
argument_list|(
name|nd
operator|->
name|nd_nam
argument_list|,
expr|struct
name|sockaddr_in6
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|&&
operator|(
operator|(
name|saddr
operator|->
name|sin_family
operator|==
name|AF_INET
operator|&&
name|ntohs
argument_list|(
name|saddr
operator|->
name|sin_port
argument_list|)
operator|>=
name|IPPORT_RESERVED
operator|)
operator|||
operator|(
name|saddr6
operator|->
name|sin6_family
operator|==
name|AF_INET6
operator|&&
name|ntohs
argument_list|(
name|saddr6
operator|->
name|sin6_port
argument_list|)
operator|>=
name|IPPORT_RESERVED
operator|)
operator|)
condition|)
block|{
name|vput
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
operator|(
name|NFSERR_AUTHERR
operator||
name|AUTH_TOOWEAK
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NFS_REQRSVPORT */
comment|/* 	 * Check/setup credentials. 	 */
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
block|{
name|nd
operator|->
name|nd_saveduid
operator|=
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsd_excred
argument_list|(
name|nd
argument_list|,
name|exp
argument_list|,
name|credanon
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
name|vput
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|credanon
operator|!=
name|NULL
condition|)
name|crfree
argument_list|(
name|credanon
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_repstat
condition|)
block|{
if|if
condition|(
name|startwrite
condition|)
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mpp
operator|!=
name|NULL
condition|)
operator|*
name|mpp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * glue for fp.  */
end_comment

begin_function
name|int
name|fp_getfvp
parameter_list|(
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|file
modifier|*
modifier|*
name|fpp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|fdp
operator|=
name|p
operator|->
name|td_proc
operator|->
name|p_fd
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
name|fdp
operator|->
name|fd_nfiles
operator|||
operator|(
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
operator|*
name|fpp
operator|=
name|fp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from nfssvc() to update the exports list. Just call  * vfs_export(). This has to be done, since the v4 root fake fs isn't  * in the mount list.  */
end_comment

begin_function
name|int
name|nfsrv_v4rootexport
parameter_list|(
name|void
modifier|*
name|argp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|nfsex_args
modifier|*
name|nfsexargp
init|=
operator|(
expr|struct
name|nfsex_args
operator|*
operator|)
name|argp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|fhandle_t
name|fh
decl_stmt|;
name|error
operator|=
name|vfs_export
argument_list|(
operator|&
name|nfsv4root_mnt
argument_list|,
operator|&
name|nfsexargp
operator|->
name|export
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nfsexargp
operator|->
name|export
operator|.
name|ex_flags
operator|&
name|MNT_DELEXPORT
operator|)
operator|!=
literal|0
condition|)
name|nfs_rootfhset
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nfsexargp
operator|->
name|fspec
operator|==
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 		 * If fspec != NULL, this is the v4root path. 		 */
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|MPSAFE
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|nfsexargp
operator|->
name|fspec
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfsvno_getfh
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|fh
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|nfs_rootfh
operator|.
name|nfsrvfh_len
operator|=
name|NFSX_MYFH
expr_stmt|;
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fh
argument_list|,
name|nfs_rootfh
operator|.
name|nfsrvfh_data
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
expr_stmt|;
name|nfs_rootfhset
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the tcp socket sequence numbers we need.  * (Maybe this should be moved to the tcp sources?)  */
end_comment

begin_function
name|int
name|nfsrv_getsocksndseq
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|tcp_seq
modifier|*
name|maxp
parameter_list|,
name|tcp_seq
modifier|*
name|unap
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"nfsrv_getsocksndseq: inp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
operator|(
name|INP_TIMEWAIT
operator||
name|INP_DROPPED
operator|)
condition|)
block|{
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPIPE
operator|)
return|;
block|}
name|tp
operator|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|!=
name|TCPS_ESTABLISHED
condition|)
block|{
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPIPE
operator|)
return|;
block|}
operator|*
name|maxp
operator|=
name|tp
operator|->
name|snd_max
expr_stmt|;
operator|*
name|unap
operator|=
name|tp
operator|->
name|snd_una
expr_stmt|;
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function needs to test to see if the system is near its limit  * for memory allocation via malloc() or mget() and return True iff  * either of these resources are near their limit.  * XXX (For now, this is just a stub.)  */
end_comment

begin_decl_stmt
name|int
name|nfsrv_testmalloclimit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|nfsrv_mallocmget_limit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|printmesg
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|testval
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|nfsrv_testmalloclimit
operator|&&
operator|(
name|testval
operator|++
operator|%
literal|1000
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|printmesg
operator|++
operator|%
literal|100
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"nfsd: malloc/mget near limit\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * BSD specific initialization of a mount point.  */
end_comment

begin_function
name|void
name|nfsd_mntinit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inited
condition|)
return|return;
name|inited
operator|=
literal|1
expr_stmt|;
name|nfsv4root_mnt
operator|.
name|mnt_flag
operator|=
operator|(
name|MNT_RDONLY
operator||
name|MNT_EXPORTED
operator|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nfsv4root_mnt
operator|.
name|mnt_nvnodelist
argument_list|)
expr_stmt|;
name|nfsv4root_mnt
operator|.
name|mnt_export
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nfsv4root_opt
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nfsv4root_newopt
argument_list|)
expr_stmt|;
name|nfsv4root_mnt
operator|.
name|mnt_opt
operator|=
operator|&
name|nfsv4root_opt
expr_stmt|;
name|nfsv4root_mnt
operator|.
name|mnt_optnew
operator|=
operator|&
name|nfsv4root_newopt
expr_stmt|;
name|nfsv4root_mnt
operator|.
name|mnt_nvnodelistsize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a vnode for a file handle, without checking exports, etc.  */
end_comment

begin_function
name|struct
name|vnode
modifier|*
name|nfsvno_getvp
parameter_list|(
name|fhandle_t
modifier|*
name|fhp
parameter_list|)
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mp
operator|=
name|vfs_busyfs
argument_list|(
operator|&
name|fhp
operator|->
name|fh_fsid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|error
operator|=
name|VFS_FHTOVP
argument_list|(
name|mp
argument_list|,
operator|&
name|fhp
operator|->
name|fh_fid
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do a local VOP_ADVLOCK().  */
end_comment

begin_function
name|int
name|nfsvno_advlock
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|ftype
parameter_list|,
name|u_int64_t
name|first
parameter_list|,
name|u_int64_t
name|end
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|flock
name|fl
decl_stmt|;
name|u_int64_t
name|tlen
decl_stmt|;
if|if
condition|(
name|nfsrv_dolocallocks
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Check for VI_DOOMED here, so that VOP_ADVLOCK() isn't performed. */
if|if
condition|(
operator|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|fl
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|fl
operator|.
name|l_type
operator|=
name|ftype
expr_stmt|;
name|fl
operator|.
name|l_start
operator|=
operator|(
name|off_t
operator|)
name|first
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|NFS64BITSSET
condition|)
block|{
name|fl
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tlen
operator|=
name|end
operator|-
name|first
expr_stmt|;
name|fl
operator|.
name|l_len
operator|=
operator|(
name|off_t
operator|)
name|tlen
expr_stmt|;
block|}
comment|/* 	 * For FreeBSD8, the l_pid and l_sysid must be set to the same 	 * values for all calls, so that all locks will be held by the 	 * nfsd server. (The nfsd server handles conflicts between the 	 * various clients.) 	 * Since an NFSv4 lockowner is a ClientID plus an array of up to 1024 	 * bytes, so it can't be put in l_sysid. 	 */
if|if
condition|(
name|nfsv4_sysid
operator|==
literal|0
condition|)
name|nfsv4_sysid
operator|=
name|nlm_acquire_next_sysid
argument_list|()
expr_stmt|;
name|fl
operator|.
name|l_pid
operator|=
operator|(
name|pid_t
operator|)
literal|0
expr_stmt|;
name|fl
operator|.
name|l_sysid
operator|=
operator|(
name|int
operator|)
name|nfsv4_sysid
expr_stmt|;
name|NFSVOPUNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftype
operator|==
name|F_UNLCK
condition|)
name|error
operator|=
name|VOP_ADVLOCK
argument_list|(
name|vp
argument_list|,
operator|(
name|caddr_t
operator|)
name|td
operator|->
name|td_proc
argument_list|,
name|F_UNLCK
argument_list|,
operator|&
name|fl
argument_list|,
operator|(
name|F_POSIX
operator||
name|F_REMOTE
operator|)
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|VOP_ADVLOCK
argument_list|(
name|vp
argument_list|,
operator|(
name|caddr_t
operator|)
name|td
operator|->
name|td_proc
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|fl
argument_list|,
operator|(
name|F_POSIX
operator||
name|F_REMOTE
operator|)
argument_list|)
expr_stmt|;
name|NFSVOPLOCK
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the nfsv4 root exports.  */
end_comment

begin_function
name|int
name|nfsvno_v4rootexport
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|credanon
decl_stmt|;
name|int
name|exflags
decl_stmt|,
name|error
decl_stmt|,
name|numsecflavor
decl_stmt|,
modifier|*
name|secflavors
decl_stmt|,
name|i
decl_stmt|;
name|error
operator|=
name|vfs_stdcheckexp
argument_list|(
operator|&
name|nfsv4root_mnt
argument_list|,
name|nd
operator|->
name|nd_nam
argument_list|,
operator|&
name|exflags
argument_list|,
operator|&
name|credanon
argument_list|,
operator|&
name|numsecflavor
argument_list|,
operator|&
name|secflavors
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|NFSERR_PROGUNAVAIL
operator|)
return|;
if|if
condition|(
name|credanon
operator|!=
name|NULL
condition|)
name|crfree
argument_list|(
name|credanon
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsecflavor
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|secflavors
index|[
name|i
index|]
operator|==
name|AUTH_SYS
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_EXAUTHSYS
expr_stmt|;
elseif|else
if|if
condition|(
name|secflavors
index|[
name|i
index|]
operator|==
name|RPCSEC_GSS_KRB5
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_EXGSS
expr_stmt|;
elseif|else
if|if
condition|(
name|secflavors
index|[
name|i
index|]
operator|==
name|RPCSEC_GSS_KRB5I
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_EXGSSINTEGRITY
expr_stmt|;
elseif|else
if|if
condition|(
name|secflavors
index|[
name|i
index|]
operator|==
name|RPCSEC_GSS_KRB5P
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_EXGSSPRIVACY
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Nfs server psuedo system call for the nfsd's  */
end_comment

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
specifier|static
name|int
name|nfssvc_nfsd
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|nfssvc_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|nfsd_addsock_args
name|sockarg
decl_stmt|;
name|struct
name|nfsd_nfsd_args
name|nfsdarg
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_NFSDADDSOCK
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sockarg
argument_list|,
sizeof|sizeof
argument_list|(
name|sockarg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|sockarg
operator|.
name|sock
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_SOCKET
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|error
operator|=
name|nfsrvd_addsock
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_NFSDNFSD
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|argp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|nfsdarg
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsdarg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|nfsrvd_nfsd
argument_list|(
name|td
argument_list|,
operator|&
name|nfsdarg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfssvc_srvcall
argument_list|(
name|td
argument_list|,
name|uap
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nfssvc_srvcall
parameter_list|(
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|struct
name|nfssvc_args
modifier|*
name|uap
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|struct
name|nfsex_args
name|export
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|int
name|stablefd
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|nfsd_clid
name|adminrevoke
decl_stmt|;
name|struct
name|nfsd_dumplist
name|dumplist
decl_stmt|;
name|struct
name|nfsd_dumpclients
modifier|*
name|dumpclients
decl_stmt|;
name|struct
name|nfsd_dumplocklist
name|dumplocklist
decl_stmt|;
name|struct
name|nfsd_dumplocks
modifier|*
name|dumplocks
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|vnode_t
name|vp
decl_stmt|;
name|int
name|error
init|=
name|EINVAL
decl_stmt|;
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_PUBLICFH
condition|)
block|{
name|NFSBZERO
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nfs_pubfh
operator|.
name|nfsrvfh_data
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|&
name|nfs_pubfh
operator|.
name|nfsrvfh_data
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|nfs_pubfhset
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_V4ROOTEXPORT
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|export
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsex_args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_v4rootexport
argument_list|(
operator|&
name|export
argument_list|,
name|cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_NOPUBLICFH
condition|)
block|{
name|nfs_pubfhset
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_STABLERESTART
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|stablefd
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|fp_getfvp
argument_list|(
name|p
argument_list|,
name|stablefd
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|NFSFPFLAG
argument_list|(
name|fp
argument_list|)
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
operator|)
operator|!=
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|newnfs_numnfsd
operator|!=
literal|0
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|nfsrv_stablefirst
operator|.
name|nsf_fp
operator|=
name|fp
expr_stmt|;
name|nfsrv_setupstable
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_ADMINREVOKE
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|adminrevoke
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsd_clid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_adminrevoke
argument_list|(
operator|&
name|adminrevoke
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_DUMPCLIENTS
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dumplist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsd_dumplist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|dumplist
operator|.
name|ndl_size
operator|<
literal|1
operator|||
name|dumplist
operator|.
name|ndl_size
operator|>
name|NFSRV_MAXDUMPLIST
operator|)
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nfsd_dumpclients
argument_list|)
operator|*
name|dumplist
operator|.
name|ndl_size
expr_stmt|;
name|dumpclients
operator|=
operator|(
expr|struct
name|nfsd_dumpclients
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nfsrv_dumpclients
argument_list|(
name|dumpclients
argument_list|,
name|dumplist
operator|.
name|ndl_size
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|dumpclients
argument_list|,
name|CAST_USER_ADDR_T
argument_list|(
name|dumplist
operator|.
name|ndl_list
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|dumpclients
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_DUMPLOCKS
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|argp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|dumplocklist
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsd_dumplocklist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|dumplocklist
operator|.
name|ndllck_size
operator|<
literal|1
operator|||
name|dumplocklist
operator|.
name|ndllck_size
operator|>
name|NFSRV_MAXDUMPLIST
operator|)
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|nfsrv_lookupfilename
argument_list|(
operator|&
name|nd
argument_list|,
name|dumplocklist
operator|.
name|ndllck_fname
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nfsd_dumplocks
argument_list|)
operator|*
name|dumplocklist
operator|.
name|ndllck_size
expr_stmt|;
name|dumplocks
operator|=
operator|(
expr|struct
name|nfsd_dumplocks
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nfsrv_dumplocks
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|dumplocks
argument_list|,
name|dumplocklist
operator|.
name|ndllck_size
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|dumplocks
argument_list|,
name|CAST_USER_ADDR_T
argument_list|(
name|dumplocklist
operator|.
name|ndllck_list
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|dumplocks
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|flag
operator|&
name|NFSSVC_BACKUPSTABLE
condition|)
block|{
name|procp
operator|=
name|p
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|procp
argument_list|)
expr_stmt|;
name|nfsd_master_pid
operator|=
name|procp
operator|->
name|p_pid
expr_stmt|;
name|bcopy
argument_list|(
name|procp
operator|->
name|p_comm
argument_list|,
name|nfsd_master_comm
argument_list|,
name|MAXCOMLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nfsd_master_start
operator|=
name|procp
operator|->
name|p_stats
operator|->
name|p_start
expr_stmt|;
name|nfsd_master_proc
operator|=
name|procp
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|procp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check exports.  * Returns 0 if ok, 1 otherwise.  */
end_comment

begin_function
name|int
name|nfsvno_testexp
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * This seems odd, but allow the case where the security flavor 	 * list is empty. This happens when NFSv4 is traversing non-exported 	 * file systems. Exported file systems should always have a non-empty 	 * security flavor list. 	 */
if|if
condition|(
name|exp
operator|->
name|nes_numsecflavor
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|exp
operator|->
name|nes_numsecflavor
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * The tests for privacy and integrity must be first, 		 * since ND_GSS is set for everything but AUTH_SYS. 		 */
if|if
condition|(
name|exp
operator|->
name|nes_secflavors
index|[
name|i
index|]
operator|==
name|RPCSEC_GSS_KRB5P
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_GSSPRIVACY
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|exp
operator|->
name|nes_secflavors
index|[
name|i
index|]
operator|==
name|RPCSEC_GSS_KRB5I
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_GSSINTEGRITY
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|exp
operator|->
name|nes_secflavors
index|[
name|i
index|]
operator|==
name|RPCSEC_GSS_KRB5
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_GSS
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|exp
operator|->
name|nes_secflavors
index|[
name|i
index|]
operator|==
name|AUTH_SYS
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_GSS
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate a hash value for the fid in a file handle.  */
end_comment

begin_function
name|uint32_t
name|nfsrv_hashfh
parameter_list|(
name|fhandle_t
modifier|*
name|fhp
parameter_list|)
block|{
name|uint32_t
name|hashval
decl_stmt|;
name|hashval
operator|=
name|hash32_buf
argument_list|(
operator|&
name|fhp
operator|->
name|fh_fid
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|hashval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Signal the userland master nfsd to backup the stable restart file.  */
end_comment

begin_function
name|void
name|nfsrv_backupstable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|procp
decl_stmt|;
if|if
condition|(
name|nfsd_master_proc
operator|!=
name|NULL
condition|)
block|{
name|procp
operator|=
name|pfind
argument_list|(
name|nfsd_master_pid
argument_list|)
expr_stmt|;
comment|/* Try to make sure it is the correct process. */
if|if
condition|(
name|procp
operator|==
name|nfsd_master_proc
operator|&&
name|procp
operator|->
name|p_stats
operator|->
name|p_start
operator|.
name|tv_sec
operator|==
name|nfsd_master_start
operator|.
name|tv_sec
operator|&&
name|procp
operator|->
name|p_stats
operator|->
name|p_start
operator|.
name|tv_usec
operator|==
name|nfsd_master_start
operator|.
name|tv_usec
operator|&&
name|strcmp
argument_list|(
name|procp
operator|->
name|p_comm
argument_list|,
name|nfsd_master_comm
argument_list|)
operator|==
literal|0
condition|)
name|psignal
argument_list|(
name|procp
argument_list|,
name|SIGUSR2
argument_list|)
expr_stmt|;
else|else
name|nfsd_master_proc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|procp
operator|!=
name|NULL
condition|)
name|PROC_UNLOCK
argument_list|(
name|procp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|nfsd_call_nfsd
function_decl|)
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|nfssvc_args
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Called once to initialize data structures...  */
end_comment

begin_function
specifier|static
name|int
name|nfsd_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|loaded
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
name|loaded
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|newnfs_portinit
argument_list|()
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nfs_cache_mutex
argument_list|,
literal|"nfs_cache_mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nfs_v4root_mutex
argument_list|,
literal|"nfs_v4root_mutex"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nfsv4root_mnt
operator|.
name|mnt_mtx
argument_list|,
literal|"struct mount mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|lockinit
argument_list|(
operator|&
name|nfsv4root_mnt
operator|.
name|mnt_explock
argument_list|,
name|PVFS
argument_list|,
literal|"explock"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nfsrvd_initcache
argument_list|()
expr_stmt|;
name|nfsd_init
argument_list|()
expr_stmt|;
name|NFSD_LOCK
argument_list|()
expr_stmt|;
name|nfsrvd_init
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|NFSD_UNLOCK
argument_list|()
expr_stmt|;
name|nfsd_mntinit
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|VV_DISABLEDELEG
name|vn_deleg_ops
operator|.
name|vndeleg_recall
operator|=
name|nfsd_recalldelegation
expr_stmt|;
name|vn_deleg_ops
operator|.
name|vndeleg_disable
operator|=
name|nfsd_disabledelegation
expr_stmt|;
endif|#
directive|endif
name|nfsd_call_servertimer
operator|=
name|nfsrv_servertimer
expr_stmt|;
name|nfsd_call_nfsd
operator|=
name|nfssvc_nfsd
expr_stmt|;
name|loaded
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
name|newnfs_numnfsd
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|VV_DISABLEDELEG
name|vn_deleg_ops
operator|.
name|vndeleg_recall
operator|=
name|NULL
expr_stmt|;
name|vn_deleg_ops
operator|.
name|vndeleg_disable
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|nfsd_call_servertimer
operator|=
name|NULL
expr_stmt|;
name|nfsd_call_nfsd
operator|=
name|NULL
expr_stmt|;
comment|/* Clean out all NFSv4 state. */
name|nfsrv_throwawayallstate
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* Clean the NFS server reply cache */
name|nfsrvd_cleancache
argument_list|()
expr_stmt|;
comment|/* Free up the krpc server pool. */
if|if
condition|(
name|nfsrvd_pool
operator|!=
name|NULL
condition|)
name|svcpool_destroy
argument_list|(
name|nfsrvd_pool
argument_list|)
expr_stmt|;
comment|/* and get rid of the locks */
name|mtx_destroy
argument_list|(
operator|&
name|nfs_cache_mutex
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nfs_v4root_mutex
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|nfsv4root_mnt
operator|.
name|mnt_mtx
argument_list|)
expr_stmt|;
name|lockdestroy
argument_list|(
operator|&
name|nfsv4root_mnt
operator|.
name|mnt_explock
argument_list|)
expr_stmt|;
name|loaded
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|nfsd_mod
init|=
block|{
literal|"nfsd"
block|,
name|nfsd_modevent
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|nfsd
argument_list|,
name|nfsd_mod
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* So that loader and kldload(2) can find us, wherever we are.. */
end_comment

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|nfsd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nfsd
argument_list|,
name|nfscommon
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nfsd
argument_list|,
name|nfslock
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nfsd
argument_list|,
name|nfslockd
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nfsd
argument_list|,
name|krpc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nfsd
argument_list|,
name|nfssvc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

