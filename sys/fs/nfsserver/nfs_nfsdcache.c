begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Here is the basic algorithm:  * First, some design criteria I used:  * - I think a false hit is more serious than a false miss  * - A false hit for an RPC that has Op(s) that order via seqid# must be  *   avoided at all cost  * - A valid hit will probably happen a long time after the original reply  *   and the TCP socket that the original request was received on will no  *   longer be active  *   (The long time delay implies to me that LRU is not appropriate.)  * - The mechanism will satisfy the requirements of ordering Ops with seqid#s  *   in them as well as minimizing the risk of redoing retried non-idempotent  *   Ops.  * Because it is biased towards avoiding false hits, multiple entries with  * the same xid are to be expected, especially for the case of the entry  * in the cache being related to a seqid# sequenced Op.  *   * The basic algorithm I'm about to code up:  * - Null RPCs bypass the cache and are just done  * For TCP  * 	- key on<xid, NFS version> (as noted above, there can be several  * 				     entries with the same key)  * 	When a request arrives:  * 		For all that match key  * 		- if RPC# != OR request_size !=  * 			- not a match with this one  * 		- if NFSv4 and received on same TCP socket OR  *			received on a TCP connection created before the  *			entry was cached  * 			- not a match with this one  * 			(V2,3 clients might retry on same TCP socket)  * 		- calculate checksum on first N bytes of NFS XDR  * 		- if checksum !=  * 			- not a match for this one  * 		If any of the remaining ones that match has a  * 			seqid_refcnt> 0  * 			- not a match (go do RPC, using new cache entry)  * 		If one match left  * 			- a hit (reply from cache)  * 		else  * 			- miss (go do RPC, using new cache entry)  *   * 	During processing of NFSv4 request:  * 		- set a flag when a non-idempotent Op is processed  * 		- when an Op that uses a seqid# (Open,...) is processed  * 			- if same seqid# as referenced entry in cache  * 				- free new cache entry  * 				- reply from referenced cache entry  * 			  else if next seqid# in order  * 				- free referenced cache entry  * 				- increment seqid_refcnt on new cache entry  * 				- set pointer from Openowner/Lockowner to  * 					new cache entry (aka reference it)  * 			  else if first seqid# in sequence  * 				- increment seqid_refcnt on new cache entry  * 				- set pointer from Openowner/Lockowner to  * 					new cache entry (aka reference it)  *   * 	At end of RPC processing:  * 		- if seqid_refcnt> 0 OR flagged non-idempotent on new  * 			cache entry  * 			- save reply in cache entry  * 			- calculate checksum on first N bytes of NFS XDR  * 				request  * 			- note op and length of XDR request (in bytes)  * 			- timestamp it  * 		  else  * 			- free new cache entry  * 		- Send reply (noting info for socket activity check, below)  *   * 	For cache entries saved above:  * 		- if saved since seqid_refcnt was> 0  * 			- free when seqid_refcnt decrements to 0  * 			  (when next one in sequence is processed above, or  * 			   when Openowner/Lockowner is discarded)  * 		  else { non-idempotent Op(s) }  * 			- free when  * 				- some further activity observed on same  * 					socket  * 				  (I'm not yet sure how I'm going to do  * 				   this. Maybe look at the TCP connection  * 				   to see if the send_tcp_sequence# is well  * 				   past sent reply OR K additional RPCs  * 				   replied on same socket OR?)  * 			  OR  * 				- when very old (hours, days, weeks?)  *   * For UDP (v2, 3 only), pretty much the old way:  * - key on<xid, NFS version, RPC#, Client host ip#>  *   (at most one entry for each key)  *   * When a Request arrives:  * - if a match with entry via key  * 	- if RPC marked In_progress  * 		- discard request (don't send reply)  * 	  else  * 		- reply from cache  * 		- timestamp cache entry  *   else  * 	- add entry to cache, marked In_progress  * 	- do RPC  * 	- when RPC done  * 		- if RPC# non-idempotent  * 			- mark entry Done (not In_progress)  * 			- save reply  * 			- timestamp cache entry  * 		  else  * 			- free cache entry  * 		- send reply  *   * Later, entries with saved replies are free'd a short time (few minutes)  * after reply sent (timestamp).  * Reference: Chet Juszczak, "Improving the Performance and Correctness  *		of an NFS Server", in Proc. Winter 1989 USENIX Conference,  *		pages 53-63. San Diego, February 1989.  *	 for the UDP case.  * nfsrc_floodlevel is set to the allowable upper limit for saved replies  *	for TCP. For V3, a reply won't be saved when the flood level is  *	hit. For V4, the non-idempotent Op will return NFSERR_RESOURCE in  *	that case. This level should be set high enough that this almost  *	never happens.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|APPLEKEXT
end_ifndef

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|nfsstats
name|newnfsstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|mtx
name|nfsrc_udpmtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsrchash_bucket
name|nfsrchash_table
index|[
name|NFSRVCACHE_HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsrchash_bucket
name|nfsrcahash_table
index|[
name|NFSRVCACHE_HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nfsrc_floodlevel
init|=
name|NFSRVCACHE_FLOODLEVEL
decl_stmt|,
name|nfsrc_tcpsavedreplies
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APPLEKEXT */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_nfsd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|nfsrc_tcphighwater
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sysctl_tcphighwater
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|newhighwater
decl_stmt|;
name|newhighwater
operator|=
name|nfsrc_tcphighwater
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|newhighwater
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|newhighwater
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|newhighwater
operator|>=
name|nfsrc_floodlevel
condition|)
name|nfsrc_floodlevel
operator|=
name|newhighwater
operator|+
name|newhighwater
operator|/
literal|5
expr_stmt|;
name|nfsrc_tcphighwater
operator|=
name|newhighwater
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vfs_nfsd
argument_list|,
name|OID_AUTO
argument_list|,
name|tcphighwater
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nfsrc_tcphighwater
argument_list|)
argument_list|,
name|sysctl_tcphighwater
argument_list|,
literal|"IU"
argument_list|,
literal|"High water mark for TCP cache entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|nfsrc_udphighwater
init|=
name|NFSRVCACHE_UDPHIGHWATER
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_nfsd
argument_list|,
name|OID_AUTO
argument_list|,
name|udphighwater
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfsrc_udphighwater
argument_list|,
literal|0
argument_list|,
literal|"High water mark for UDP cache entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|nfsrc_tcptimeout
init|=
name|NFSRVCACHE_TCPTIMEOUT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_nfsd
argument_list|,
name|OID_AUTO
argument_list|,
name|tcpcachetimeo
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfsrc_tcptimeout
argument_list|,
literal|0
argument_list|,
literal|"Timeout for TCP entries in the DRC"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|nfsrc_tcpnonidempotent
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_vfs_nfsd
argument_list|,
name|OID_AUTO
argument_list|,
name|cachetcp
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nfsrc_tcpnonidempotent
argument_list|,
literal|0
argument_list|,
literal|"Enable the DRC for NFS over TCP"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|nfsrc_udpcachesize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|nfsrvcache
argument_list|)
name|nfsrvudplru
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|nfsrvhashhead
name|nfsrvudphashtbl
index|[
name|NFSRVCACHE_HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * and the reverse mapping from generic to Version 2 procedure numbers  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|newnfsv2_procid
index|[
name|NFS_V3NPROCS
index|]
init|=
block|{
name|NFSV2PROC_NULL
block|,
name|NFSV2PROC_GETATTR
block|,
name|NFSV2PROC_SETATTR
block|,
name|NFSV2PROC_LOOKUP
block|,
name|NFSV2PROC_NOOP
block|,
name|NFSV2PROC_READLINK
block|,
name|NFSV2PROC_READ
block|,
name|NFSV2PROC_WRITE
block|,
name|NFSV2PROC_CREATE
block|,
name|NFSV2PROC_MKDIR
block|,
name|NFSV2PROC_SYMLINK
block|,
name|NFSV2PROC_CREATE
block|,
name|NFSV2PROC_REMOVE
block|,
name|NFSV2PROC_RMDIR
block|,
name|NFSV2PROC_RENAME
block|,
name|NFSV2PROC_LINK
block|,
name|NFSV2PROC_READDIR
block|,
name|NFSV2PROC_NOOP
block|,
name|NFSV2PROC_STATFS
block|,
name|NFSV2PROC_NOOP
block|,
name|NFSV2PROC_NOOP
block|,
name|NFSV2PROC_NOOP
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|nfsrc_hash
parameter_list|(
name|xid
parameter_list|)
value|(((xid) + ((xid)>> 24)) % NFSRVCACHE_HASHSIZE)
end_define

begin_define
define|#
directive|define
name|NFSRCUDPHASH
parameter_list|(
name|xid
parameter_list|)
define|\
value|(&nfsrvudphashtbl[nfsrc_hash(xid)])
end_define

begin_define
define|#
directive|define
name|NFSRCHASH
parameter_list|(
name|xid
parameter_list|)
define|\
value|(&nfsrchash_table[nfsrc_hash(xid)].tbl)
end_define

begin_define
define|#
directive|define
name|NFSRCAHASH
parameter_list|(
name|xid
parameter_list|)
value|(&nfsrcahash_table[nfsrc_hash(xid)])
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|NFSRVCACHE_CHECKLEN
value|100
end_define

begin_comment
comment|/* True iff the rpc reply is an nfs status ONLY! */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nfsv2_repstat
index|[
name|NFS_V3NPROCS
index|]
init|=
block|{
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|TRUE
block|,
name|TRUE
block|,
name|TRUE
block|,
name|TRUE
block|,
name|FALSE
block|,
name|TRUE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|,
name|FALSE
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Will NFS want to work over IPv6 someday?  */
end_comment

begin_define
define|#
directive|define
name|NETFAMILY
parameter_list|(
name|rp
parameter_list|)
define|\
value|(((rp)->rc_flag& RC_INETIPV6) ? AF_INET6 : AF_INET)
end_define

begin_comment
comment|/* local functions */
end_comment

begin_function_decl
specifier|static
name|int
name|nfsrc_getudp
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsrvcache
modifier|*
name|newrp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrc_gettcp
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsrvcache
modifier|*
name|newrp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrc_lock
parameter_list|(
name|struct
name|nfsrvcache
modifier|*
name|rp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrc_unlock
parameter_list|(
name|struct
name|nfsrvcache
modifier|*
name|rp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrc_wanted
parameter_list|(
name|struct
name|nfsrvcache
modifier|*
name|rp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrc_freecache
parameter_list|(
name|struct
name|nfsrvcache
modifier|*
name|rp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nfsrc_getlenandcksum
parameter_list|(
name|mbuf_t
name|m1
parameter_list|,
name|u_int16_t
modifier|*
name|cksum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nfsrc_marksametcpconn
parameter_list|(
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Return the correct mutex for this cache entry.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mtx
operator|*
name|nfsrc_cachemutex
argument_list|(
argument|struct nfsrvcache *rp
argument_list|)
block|{
if|if
condition|(
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_UDP
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|&
name|nfsrc_udpmtx
operator|)
return|;
end_expr_stmt

begin_return
return|return
operator|(
operator|&
name|nfsrchash_table
index|[
name|nfsrc_hash
argument_list|(
name|rp
operator|->
name|rc_xid
argument_list|)
index|]
operator|.
name|mtx
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Initialize the server request cache list  */
end_comment

begin_function
unit|APPLESTATIC
name|void
name|nfsrvd_initcache
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inited
condition|)
return|return;
name|inited
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSRVCACHE_HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|nfsrvudphashtbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|nfsrchash_table
index|[
name|i
index|]
operator|.
name|tbl
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|nfsrcahash_table
index|[
name|i
index|]
operator|.
name|tbl
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|nfsrvudplru
argument_list|)
expr_stmt|;
name|nfsrc_tcpsavedreplies
operator|=
literal|0
expr_stmt|;
name|nfsrc_udpcachesize
operator|=
literal|0
expr_stmt|;
name|newnfsstats
operator|.
name|srvcache_tcppeak
operator|=
literal|0
expr_stmt|;
name|newnfsstats
operator|.
name|srvcache_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a cache entry for this request. Basically just malloc a new one  * and then call nfsrc_getudp() or nfsrc_gettcp() to do the rest.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrvd_getcache
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|)
block|{
name|struct
name|nfsrvcache
modifier|*
name|newrp
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|==
name|NFSPROC_NULL
condition|)
name|panic
argument_list|(
literal|"nfsd cache null"
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|newrp
argument_list|,
expr|struct
name|nfsrvcache
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsrvcache
argument_list|)
argument_list|,
name|M_NFSRVCACHE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|NFSBZERO
argument_list|(
operator|(
name|caddr_t
operator|)
name|newrp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nfsrvcache
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|newrp
operator|->
name|rc_flag
operator|=
name|RC_NFSV4
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|newrp
operator|->
name|rc_flag
operator|=
name|RC_NFSV3
expr_stmt|;
else|else
name|newrp
operator|->
name|rc_flag
operator|=
name|RC_NFSV2
expr_stmt|;
name|newrp
operator|->
name|rc_xid
operator|=
name|nd
operator|->
name|nd_retxid
expr_stmt|;
name|newrp
operator|->
name|rc_proc
operator|=
name|nd
operator|->
name|nd_procnum
expr_stmt|;
name|newrp
operator|->
name|rc_sockref
operator|=
name|nd
operator|->
name|nd_sockref
expr_stmt|;
name|newrp
operator|->
name|rc_cachetime
operator|=
name|nd
operator|->
name|nd_tcpconntime
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_SAMETCPCONN
condition|)
name|newrp
operator|->
name|rc_flag
operator||=
name|RC_SAMETCPCONN
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_nam2
operator|!=
name|NULL
condition|)
block|{
name|newrp
operator|->
name|rc_flag
operator||=
name|RC_UDP
expr_stmt|;
name|ret
operator|=
name|nfsrc_getudp
argument_list|(
name|nd
argument_list|,
name|newrp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|nfsrc_gettcp
argument_list|(
name|nd
argument_list|,
name|newrp
argument_list|)
expr_stmt|;
block|}
name|NFSEXITCODE2
argument_list|(
literal|0
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For UDP (v2, v3):  * - key on<xid, NFS version, RPC#, Client host ip#>  *   (at most one entry for each key)  */
end_comment

begin_function
specifier|static
name|int
name|nfsrc_getudp
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsrvcache
modifier|*
name|newrp
parameter_list|)
block|{
name|struct
name|nfsrvcache
modifier|*
name|rp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|saddr
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|saddr6
decl_stmt|;
name|struct
name|nfsrvhashhead
modifier|*
name|hp
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mutex
decl_stmt|;
name|mutex
operator|=
name|nfsrc_cachemutex
argument_list|(
name|newrp
argument_list|)
expr_stmt|;
name|hp
operator|=
name|NFSRCUDPHASH
argument_list|(
name|newrp
operator|->
name|rc_xid
argument_list|)
expr_stmt|;
name|loop
label|:
name|mtx_lock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|rp
argument_list|,
argument|hp
argument_list|,
argument|rc_hash
argument_list|)
block|{
if|if
condition|(
name|newrp
operator|->
name|rc_xid
operator|==
name|rp
operator|->
name|rc_xid
operator|&&
name|newrp
operator|->
name|rc_proc
operator|==
name|rp
operator|->
name|rc_proc
operator|&&
operator|(
name|newrp
operator|->
name|rc_flag
operator|&
name|rp
operator|->
name|rc_flag
operator|&
name|RC_NFSVERS
operator|)
operator|&&
name|nfsaddr_match
argument_list|(
name|NETFAMILY
argument_list|(
name|rp
argument_list|)
argument_list|,
operator|&
name|rp
operator|->
name|rc_haddr
argument_list|,
name|nd
operator|->
name|nd_nam
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|rp
operator|->
name|rc_flag
operator||=
name|RC_WANTED
expr_stmt|;
operator|(
name|void
operator|)
name|mtx_sleep
argument_list|(
name|rp
argument_list|,
name|mutex
argument_list|,
operator|(
name|PZERO
operator|-
literal|1
operator|)
operator||
name|PDROP
argument_list|,
literal|"nfsrc"
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|rp
operator|->
name|rc_flag
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs udp cache0"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rc_flag
operator||=
name|RC_LOCKED
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nfsrvudplru
argument_list|,
name|rp
argument_list|,
name|rc_lru
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nfsrvudplru
argument_list|,
name|rp
argument_list|,
name|rc_lru
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_INPROG
condition|)
block|{
name|newnfsstats
operator|.
name|srvcache_inproghits
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|ret
operator|=
name|RC_DROPIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_REPSTATUS
condition|)
block|{
comment|/* 				 * V2 only. 				 */
name|newnfsstats
operator|.
name|srvcache_nonidemdonehits
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|nfsrvd_rephead
argument_list|(
name|nd
argument_list|)
expr_stmt|;
operator|*
operator|(
name|nd
operator|->
name|nd_errp
operator|)
operator|=
name|rp
operator|->
name|rc_status
expr_stmt|;
name|ret
operator|=
name|RC_REPLY
expr_stmt|;
name|rp
operator|->
name|rc_timestamp
operator|=
name|NFSD_MONOSEC
operator|+
name|NFSRVCACHE_UDPTIMEOUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_REPMBUF
condition|)
block|{
name|newnfsstats
operator|.
name|srvcache_nonidemdonehits
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mreq
operator|=
name|m_copym
argument_list|(
name|rp
operator|->
name|rc_reply
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|RC_REPLY
expr_stmt|;
name|rp
operator|->
name|rc_timestamp
operator|=
name|NFSD_MONOSEC
operator|+
name|NFSRVCACHE_UDPTIMEOUT
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"nfs udp cache1"
argument_list|)
expr_stmt|;
block|}
name|nfsrc_unlock
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|newrp
argument_list|,
name|M_NFSRVCACHE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|newnfsstats
operator|.
name|srvcache_misses
operator|++
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|newnfsstats
operator|.
name|srvcache_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nfsrc_udpcachesize
operator|++
expr_stmt|;
name|newrp
operator|->
name|rc_flag
operator||=
name|RC_INPROG
expr_stmt|;
name|saddr
operator|=
name|NFSSOCKADDR
argument_list|(
name|nd
operator|->
name|nd_nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|saddr
operator|->
name|sin_family
operator|==
name|AF_INET
condition|)
name|newrp
operator|->
name|rc_inet
operator|=
name|saddr
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
elseif|else
if|if
condition|(
name|saddr
operator|->
name|sin_family
operator|==
name|AF_INET6
condition|)
block|{
name|saddr6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|saddr
expr_stmt|;
name|NFSBCOPY
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|saddr6
operator|->
name|sin6_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|newrp
operator|->
name|rc_inet6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|newrp
operator|->
name|rc_flag
operator||=
name|RC_INETIPV6
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
name|hp
argument_list|,
name|newrp
argument_list|,
name|rc_hash
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nfsrvudplru
argument_list|,
name|newrp
argument_list|,
name|rc_lru
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_rp
operator|=
name|newrp
expr_stmt|;
name|ret
operator|=
name|RC_DOIT
expr_stmt|;
name|out
label|:
name|NFSEXITCODE2
argument_list|(
literal|0
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update a request cache entry after the rpc has been done  */
end_comment

begin_function
name|APPLESTATIC
name|struct
name|nfsrvcache
modifier|*
name|nfsrvd_updatecache
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|)
block|{
name|struct
name|nfsrvcache
modifier|*
name|rp
decl_stmt|;
name|struct
name|nfsrvcache
modifier|*
name|retrp
init|=
name|NULL
decl_stmt|;
name|mbuf_t
name|m
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mutex
decl_stmt|;
name|rp
operator|=
name|nd
operator|->
name|nd_rp
expr_stmt|;
if|if
condition|(
operator|!
name|rp
condition|)
name|panic
argument_list|(
literal|"nfsrvd_updatecache null rp"
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_rp
operator|=
name|NULL
expr_stmt|;
name|mutex
operator|=
name|nfsrc_cachemutex
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|nfsrc_lock
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_INPROG
operator|)
condition|)
name|panic
argument_list|(
literal|"nfsrvd_updatecache not inprog"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rc_flag
operator|&=
operator|~
name|RC_INPROG
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_UDP
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nfsrvudplru
argument_list|,
name|rp
argument_list|,
name|rc_lru
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nfsrvudplru
argument_list|,
name|rp
argument_list|,
name|rc_lru
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reply from cache is a special case returned by nfsrv_checkseqid(). 	 */
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_REPLYFROMCACHE
condition|)
block|{
name|newnfsstats
operator|.
name|srvcache_nonidemdonehits
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_mreq
condition|)
name|mbuf_freem
argument_list|(
name|nd
operator|->
name|nd_mreq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_REPMBUF
operator|)
condition|)
name|panic
argument_list|(
literal|"reply from cache"
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_mreq
operator|=
name|m_copym
argument_list|(
name|rp
operator|->
name|rc_reply
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rc_timestamp
operator|=
name|NFSD_MONOSEC
operator|+
name|nfsrc_tcptimeout
expr_stmt|;
name|nfsrc_unlock
argument_list|(
name|rp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If rc_refcnt> 0, save it 	 * For UDP, save it if ND_SAVEREPLY is set 	 * For TCP, save it if ND_SAVEREPLY and nfsrc_tcpnonidempotent is set 	 */
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|!=
name|NFSERR_DONTREPLY
operator|&&
operator|(
name|rp
operator|->
name|rc_refcnt
operator|>
literal|0
operator|||
operator|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_SAVEREPLY
operator|)
operator|&&
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_UDP
operator|)
operator|)
operator|||
operator|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_SAVEREPLY
operator|)
operator|&&
operator|!
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_UDP
operator|)
operator|&&
name|nfsrc_tcpsavedreplies
operator|<=
name|nfsrc_floodlevel
operator|&&
name|nfsrc_tcpnonidempotent
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|rc_refcnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_NFSV4
operator|)
condition|)
name|panic
argument_list|(
literal|"update_cache refcnt"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rc_flag
operator||=
name|RC_REFCNT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
operator|)
operator|&&
name|nfsv2_repstat
index|[
name|newnfsv2_procid
index|[
name|nd
operator|->
name|nd_procnum
index|]
index|]
condition|)
block|{
name|rp
operator|->
name|rc_status
operator|=
name|nd
operator|->
name|nd_repstat
expr_stmt|;
name|rp
operator|->
name|rc_flag
operator||=
name|RC_REPSTATUS
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_UDP
operator|)
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|nfsrc_tcpsavedreplies
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfsrc_tcpsavedreplies
operator|>
name|newnfsstats
operator|.
name|srvcache_tcppeak
condition|)
name|newnfsstats
operator|.
name|srvcache_tcppeak
operator|=
name|nfsrc_tcpsavedreplies
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_copym
argument_list|(
name|nd
operator|->
name|nd_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rc_reply
operator|=
name|m
expr_stmt|;
name|rp
operator|->
name|rc_flag
operator||=
name|RC_REPMBUF
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_UDP
condition|)
block|{
name|rp
operator|->
name|rc_timestamp
operator|=
name|NFSD_MONOSEC
operator|+
name|NFSRVCACHE_UDPTIMEOUT
expr_stmt|;
name|nfsrc_unlock
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|->
name|rc_timestamp
operator|=
name|NFSD_MONOSEC
operator|+
name|nfsrc_tcptimeout
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rc_refcnt
operator|>
literal|0
condition|)
name|nfsrc_unlock
argument_list|(
name|rp
argument_list|)
expr_stmt|;
else|else
name|retrp
operator|=
name|rp
expr_stmt|;
block|}
block|}
else|else
block|{
name|nfsrc_freecache
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|NFSEXITCODE2
argument_list|(
literal|0
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|retrp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Invalidate and, if possible, free an in prog cache entry.  * Must not sleep.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrvd_delcache
parameter_list|(
name|struct
name|nfsrvcache
modifier|*
name|rp
parameter_list|)
block|{
name|struct
name|mtx
modifier|*
name|mutex
decl_stmt|;
name|mutex
operator|=
name|nfsrc_cachemutex
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_INPROG
operator|)
condition|)
name|panic
argument_list|(
literal|"nfsrvd_delcache not in prog"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rc_flag
operator|&=
operator|~
name|RC_INPROG
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rc_refcnt
operator|==
literal|0
operator|&&
operator|!
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_LOCKED
operator|)
condition|)
name|nfsrc_freecache
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called after nfsrvd_updatecache() once the reply is sent, to update  * the entry's sequence number and unlock it. The argument is  * the pointer returned by nfsrvd_updatecache().  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrvd_sentcache
parameter_list|(
name|struct
name|nfsrvcache
modifier|*
name|rp
parameter_list|,
name|int
name|have_seq
parameter_list|,
name|uint32_t
name|seq
parameter_list|)
block|{
name|struct
name|nfsrchash_bucket
modifier|*
name|hbp
decl_stmt|;
name|KASSERT
argument_list|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_LOCKED
argument_list|,
operator|(
literal|"nfsrvd_sentcache not locked"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_seq
condition|)
block|{
name|hbp
operator|=
name|NFSRCAHASH
argument_list|(
name|rp
operator|->
name|rc_sockref
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hbp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rc_tcpseq
operator|=
name|seq
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rc_acked
operator|!=
name|RC_NO_ACK
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|hbp
operator|->
name|tbl
argument_list|,
name|rp
argument_list|,
name|rc_ahash
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rc_acked
operator|=
name|RC_NO_ACK
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|hbp
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|nfsrc_unlock
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a cache entry for TCP  * - key on<xid, nfs version>  *   (allow multiple entries for a given key)  */
end_comment

begin_function
specifier|static
name|int
name|nfsrc_gettcp
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsrvcache
modifier|*
name|newrp
parameter_list|)
block|{
name|struct
name|nfsrvcache
modifier|*
name|rp
decl_stmt|,
modifier|*
name|nextrp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|nfsrvcache
modifier|*
name|hitrp
decl_stmt|;
name|struct
name|nfsrvhashhead
modifier|*
name|hp
decl_stmt|,
name|nfsrc_templist
decl_stmt|;
name|int
name|hit
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mutex
decl_stmt|;
name|mutex
operator|=
name|nfsrc_cachemutex
argument_list|(
name|newrp
argument_list|)
expr_stmt|;
name|hp
operator|=
name|NFSRCHASH
argument_list|(
name|newrp
operator|->
name|rc_xid
argument_list|)
expr_stmt|;
name|newrp
operator|->
name|rc_reqlen
operator|=
name|nfsrc_getlenandcksum
argument_list|(
name|nd
operator|->
name|nd_mrep
argument_list|,
operator|&
name|newrp
operator|->
name|rc_cksum
argument_list|)
expr_stmt|;
name|tryagain
label|:
name|mtx_lock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|hit
operator|=
literal|1
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|nfsrc_templist
argument_list|)
expr_stmt|;
comment|/* 	 * Get all the matches and put them on the temp list. 	 */
name|rp
operator|=
name|LIST_FIRST
argument_list|(
name|hp
argument_list|)
expr_stmt|;
while|while
condition|(
name|rp
operator|!=
name|LIST_END
argument_list|(
name|hp
argument_list|)
condition|)
block|{
name|nextrp
operator|=
name|LIST_NEXT
argument_list|(
name|rp
argument_list|,
name|rc_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrp
operator|->
name|rc_xid
operator|==
name|rp
operator|->
name|rc_xid
operator|&&
operator|(
operator|!
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_INPROG
operator|)
operator|||
operator|(
operator|(
name|newrp
operator|->
name|rc_flag
operator|&
name|RC_SAMETCPCONN
operator|)
operator|&&
name|newrp
operator|->
name|rc_sockref
operator|==
name|rp
operator|->
name|rc_sockref
operator|)
operator|)
operator|&&
operator|(
name|newrp
operator|->
name|rc_flag
operator|&
name|rp
operator|->
name|rc_flag
operator|&
name|RC_NFSVERS
operator|)
operator|&&
name|newrp
operator|->
name|rc_proc
operator|==
name|rp
operator|->
name|rc_proc
operator|&&
operator|(
operator|(
name|newrp
operator|->
name|rc_flag
operator|&
name|RC_NFSV4
operator|)
operator|&&
name|newrp
operator|->
name|rc_sockref
operator|!=
name|rp
operator|->
name|rc_sockref
operator|&&
name|newrp
operator|->
name|rc_cachetime
operator|>=
name|rp
operator|->
name|rc_cachetime
operator|)
operator|&&
name|newrp
operator|->
name|rc_reqlen
operator|==
name|rp
operator|->
name|rc_reqlen
operator|&&
name|newrp
operator|->
name|rc_cksum
operator|==
name|rp
operator|->
name|rc_cksum
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|rp
argument_list|,
name|rc_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|nfsrc_templist
argument_list|,
name|rp
argument_list|,
name|rc_hash
argument_list|)
expr_stmt|;
block|}
name|rp
operator|=
name|nextrp
expr_stmt|;
block|}
comment|/* 	 * Now, use nfsrc_templist to decide if there is a match. 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|rp
argument_list|,
argument|&nfsrc_templist
argument_list|,
argument|rc_hash
argument_list|)
block|{
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rc_refcnt
operator|>
literal|0
condition|)
block|{
name|hit
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Can be a hit only if one entry left. 	 * Note possible hit entry and put nfsrc_templist back on hash 	 * list. 	 */
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|hit
operator|=
literal|0
expr_stmt|;
name|hitrp
operator|=
name|rp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|nfsrc_templist
argument_list|)
expr_stmt|;
while|while
condition|(
name|rp
operator|!=
name|LIST_END
argument_list|(
operator|&
name|nfsrc_templist
argument_list|)
condition|)
block|{
name|nextrp
operator|=
name|LIST_NEXT
argument_list|(
name|rp
argument_list|,
name|rc_hash
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rp
argument_list|,
name|rc_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|hp
argument_list|,
name|rp
argument_list|,
name|rc_hash
argument_list|)
expr_stmt|;
name|rp
operator|=
name|nextrp
expr_stmt|;
block|}
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|nfsrc_templist
argument_list|)
operator|!=
name|LIST_END
argument_list|(
operator|&
name|nfsrc_templist
argument_list|)
condition|)
name|panic
argument_list|(
literal|"nfs gettcp cache templist"
argument_list|)
expr_stmt|;
if|if
condition|(
name|hit
condition|)
block|{
name|rp
operator|=
name|hitrp
expr_stmt|;
if|if
condition|(
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|rp
operator|->
name|rc_flag
operator||=
name|RC_WANTED
expr_stmt|;
operator|(
name|void
operator|)
name|mtx_sleep
argument_list|(
name|rp
argument_list|,
name|mutex
argument_list|,
operator|(
name|PZERO
operator|-
literal|1
operator|)
operator||
name|PDROP
argument_list|,
literal|"nfsrc"
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
if|if
condition|(
name|rp
operator|->
name|rc_flag
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs tcp cache0"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rc_flag
operator||=
name|RC_LOCKED
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_INPROG
condition|)
block|{
name|newnfsstats
operator|.
name|srvcache_inproghits
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrp
operator|->
name|rc_sockref
operator|==
name|rp
operator|->
name|rc_sockref
condition|)
name|nfsrc_marksametcpconn
argument_list|(
name|rp
operator|->
name|rc_sockref
argument_list|)
expr_stmt|;
name|ret
operator|=
name|RC_DROPIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_REPSTATUS
condition|)
block|{
comment|/* 			 * V2 only. 			 */
name|newnfsstats
operator|.
name|srvcache_nonidemdonehits
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrp
operator|->
name|rc_sockref
operator|==
name|rp
operator|->
name|rc_sockref
condition|)
name|nfsrc_marksametcpconn
argument_list|(
name|rp
operator|->
name|rc_sockref
argument_list|)
expr_stmt|;
name|ret
operator|=
name|RC_REPLY
expr_stmt|;
name|nfsrvd_rephead
argument_list|(
name|nd
argument_list|)
expr_stmt|;
operator|*
operator|(
name|nd
operator|->
name|nd_errp
operator|)
operator|=
name|rp
operator|->
name|rc_status
expr_stmt|;
name|rp
operator|->
name|rc_timestamp
operator|=
name|NFSD_MONOSEC
operator|+
name|nfsrc_tcptimeout
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_REPMBUF
condition|)
block|{
name|newnfsstats
operator|.
name|srvcache_nonidemdonehits
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|newrp
operator|->
name|rc_sockref
operator|==
name|rp
operator|->
name|rc_sockref
condition|)
name|nfsrc_marksametcpconn
argument_list|(
name|rp
operator|->
name|rc_sockref
argument_list|)
expr_stmt|;
name|ret
operator|=
name|RC_REPLY
expr_stmt|;
name|nd
operator|->
name|nd_mreq
operator|=
name|m_copym
argument_list|(
name|rp
operator|->
name|rc_reply
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rc_timestamp
operator|=
name|NFSD_MONOSEC
operator|+
name|nfsrc_tcptimeout
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"nfs tcp cache1"
argument_list|)
expr_stmt|;
block|}
name|nfsrc_unlock
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|newrp
argument_list|,
name|M_NFSRVCACHE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|newnfsstats
operator|.
name|srvcache_misses
operator|++
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|newnfsstats
operator|.
name|srvcache_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * For TCP, multiple entries for a key are allowed, so don't 	 * chain it into the hash table until done. 	 */
name|newrp
operator|->
name|rc_cachetime
operator|=
name|NFSD_MONOSEC
expr_stmt|;
name|newrp
operator|->
name|rc_flag
operator||=
name|RC_INPROG
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|hp
argument_list|,
name|newrp
argument_list|,
name|rc_hash
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_rp
operator|=
name|newrp
expr_stmt|;
name|ret
operator|=
name|RC_DOIT
expr_stmt|;
name|out
label|:
name|NFSEXITCODE2
argument_list|(
literal|0
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock a cache entry.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrc_lock
parameter_list|(
name|struct
name|nfsrvcache
modifier|*
name|rp
parameter_list|)
block|{
name|struct
name|mtx
modifier|*
name|mutex
decl_stmt|;
name|mutex
operator|=
name|nfsrc_cachemutex
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
name|mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|rp
operator|->
name|rc_flag
operator||=
name|RC_WANTED
expr_stmt|;
operator|(
name|void
operator|)
name|mtx_sleep
argument_list|(
name|rp
argument_list|,
name|mutex
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|,
literal|"nfsrc"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|rp
operator|->
name|rc_flag
operator||=
name|RC_LOCKED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unlock a cache entry.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrc_unlock
parameter_list|(
name|struct
name|nfsrvcache
modifier|*
name|rp
parameter_list|)
block|{
name|struct
name|mtx
modifier|*
name|mutex
decl_stmt|;
name|mutex
operator|=
name|nfsrc_cachemutex
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rc_flag
operator|&=
operator|~
name|RC_LOCKED
expr_stmt|;
name|nfsrc_wanted
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wakeup anyone wanting entry.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrc_wanted
parameter_list|(
name|struct
name|nfsrvcache
modifier|*
name|rp
parameter_list|)
block|{
if|if
condition|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_WANTED
condition|)
block|{
name|rp
operator|->
name|rc_flag
operator|&=
operator|~
name|RC_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free up the entry.  * Must not sleep.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrc_freecache
parameter_list|(
name|struct
name|nfsrvcache
modifier|*
name|rp
parameter_list|)
block|{
name|struct
name|nfsrchash_bucket
modifier|*
name|hbp
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|rp
argument_list|,
name|rc_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_UDP
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nfsrvudplru
argument_list|,
name|rp
argument_list|,
name|rc_lru
argument_list|)
expr_stmt|;
name|nfsrc_udpcachesize
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|rc_acked
operator|!=
name|RC_NO_SEQ
condition|)
block|{
name|hbp
operator|=
name|NFSRCAHASH
argument_list|(
name|rp
operator|->
name|rc_sockref
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hbp
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rc_acked
operator|==
name|RC_NO_ACK
condition|)
name|LIST_REMOVE
argument_list|(
name|rp
argument_list|,
name|rc_ahash
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|hbp
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|nfsrc_wanted
argument_list|(
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_REPMBUF
condition|)
block|{
name|mbuf_freem
argument_list|(
name|rp
operator|->
name|rc_reply
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_UDP
operator|)
condition|)
name|atomic_add_int
argument_list|(
operator|&
name|nfsrc_tcpsavedreplies
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
operator|(
name|caddr_t
operator|)
name|rp
argument_list|,
name|M_NFSRVCACHE
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|newnfsstats
operator|.
name|srvcache_size
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clean out the cache. Called when nfsserver module is unloaded.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrvd_cleancache
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|nfsrvcache
modifier|*
name|rp
decl_stmt|,
modifier|*
name|nextrp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSRVCACHE_HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nfsrchash_table
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|rp
argument_list|,
argument|&nfsrchash_table[i].tbl
argument_list|,
argument|rc_hash
argument_list|,
argument|nextrp
argument_list|)
name|nfsrc_freecache
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nfsrchash_table
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|nfsrc_udpmtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSRVCACHE_HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|rp
argument_list|,
argument|&nfsrvudphashtbl[i]
argument_list|,
argument|rc_hash
argument_list|,
argument|nextrp
argument_list|)
block|{
name|nfsrc_freecache
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
name|newnfsstats
operator|.
name|srvcache_size
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nfsrc_udpmtx
argument_list|)
expr_stmt|;
name|nfsrc_tcpsavedreplies
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|HISTSIZE
value|16
end_define

begin_comment
comment|/*  * The basic rule is to get rid of entries that are expired.  */
end_comment

begin_function
name|void
name|nfsrc_trimcache
parameter_list|(
name|u_int64_t
name|sockref
parameter_list|,
name|uint32_t
name|snd_una
parameter_list|,
name|int
name|final
parameter_list|)
block|{
name|struct
name|nfsrchash_bucket
modifier|*
name|hbp
decl_stmt|;
name|struct
name|nfsrvcache
modifier|*
name|rp
decl_stmt|,
modifier|*
name|nextrp
decl_stmt|;
name|int
name|force
decl_stmt|,
name|lastslot
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|tto
decl_stmt|,
name|time_histo
index|[
name|HISTSIZE
index|]
decl_stmt|;
name|time_t
name|thisstamp
decl_stmt|;
specifier|static
name|time_t
name|udp_lasttrim
init|=
literal|0
decl_stmt|,
name|tcp_lasttrim
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|onethread
init|=
literal|0
decl_stmt|,
name|oneslot
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sockref
operator|!=
literal|0
condition|)
block|{
name|hbp
operator|=
name|NFSRCAHASH
argument_list|(
name|sockref
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|hbp
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|rp
argument_list|,
argument|&hbp->tbl
argument_list|,
argument|rc_ahash
argument_list|,
argument|nextrp
argument_list|)
block|{
if|if
condition|(
name|sockref
operator|==
name|rp
operator|->
name|rc_sockref
condition|)
block|{
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|snd_una
argument_list|,
name|rp
operator|->
name|rc_tcpseq
argument_list|)
condition|)
block|{
name|rp
operator|->
name|rc_acked
operator|=
name|RC_ACK
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rp
argument_list|,
name|rc_ahash
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|final
condition|)
block|{
name|rp
operator|->
name|rc_acked
operator|=
name|RC_NACK
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rp
argument_list|,
name|rc_ahash
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|hbp
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|atomic_cmpset_acq_int
argument_list|(
operator|&
name|onethread
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|NFSD_MONOSEC
operator|!=
name|udp_lasttrim
operator|||
name|nfsrc_udpcachesize
operator|>=
operator|(
name|nfsrc_udphighwater
operator|+
name|nfsrc_udphighwater
operator|/
literal|2
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nfsrc_udpmtx
argument_list|)
expr_stmt|;
name|udp_lasttrim
operator|=
name|NFSD_MONOSEC
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|rp
argument_list|,
argument|&nfsrvudplru
argument_list|,
argument|rc_lru
argument_list|,
argument|nextrp
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|rc_flag
operator|&
operator|(
name|RC_INPROG
operator||
name|RC_LOCKED
operator||
name|RC_WANTED
operator|)
operator|)
operator|&&
name|rp
operator|->
name|rc_refcnt
operator|==
literal|0
operator|&&
operator|(
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_REFCNT
operator|)
operator|||
name|udp_lasttrim
operator|>
name|rp
operator|->
name|rc_timestamp
operator|||
name|nfsrc_udpcachesize
operator|>
name|nfsrc_udphighwater
operator|)
condition|)
name|nfsrc_freecache
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nfsrc_udpmtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NFSD_MONOSEC
operator|!=
name|tcp_lasttrim
operator|||
name|nfsrc_tcpsavedreplies
operator|>=
name|nfsrc_tcphighwater
condition|)
block|{
name|force
operator|=
name|nfsrc_tcphighwater
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|force
operator|>
literal|0
operator|&&
name|nfsrc_tcpsavedreplies
operator|+
name|force
operator|>=
name|nfsrc_tcphighwater
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HISTSIZE
condition|;
name|i
operator|++
control|)
name|time_histo
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|lastslot
operator|=
name|NFSRVCACHE_HASHSIZE
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|force
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NFSD_MONOSEC
operator|!=
name|tcp_lasttrim
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|lastslot
operator|=
name|NFSRVCACHE_HASHSIZE
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|lastslot
operator|=
name|i
operator|=
name|oneslot
expr_stmt|;
if|if
condition|(
operator|++
name|oneslot
operator|>=
name|NFSRVCACHE_HASHSIZE
condition|)
name|oneslot
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|tto
operator|=
name|nfsrc_tcptimeout
expr_stmt|;
name|tcp_lasttrim
operator|=
name|NFSD_MONOSEC
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<=
name|lastslot
condition|;
name|i
operator|++
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nfsrchash_table
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|rp
argument_list|,
argument|&nfsrchash_table[i].tbl
argument_list|,
argument|rc_hash
argument_list|,
argument|nextrp
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|rc_flag
operator|&
operator|(
name|RC_INPROG
operator||
name|RC_LOCKED
operator||
name|RC_WANTED
operator|)
operator|)
operator|&&
name|rp
operator|->
name|rc_refcnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_REFCNT
operator|)
operator|||
name|tcp_lasttrim
operator|>
name|rp
operator|->
name|rc_timestamp
operator|||
name|rp
operator|->
name|rc_acked
operator|==
name|RC_ACK
condition|)
block|{
name|nfsrc_freecache
argument_list|(
name|rp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|force
operator|==
literal|0
condition|)
continue|continue;
comment|/* 					 * The timestamps range from roughly the 					 * present (tcp_lasttrim) to the present 					 * + nfsrc_tcptimeout. Generate a simple 					 * histogram of where the timeouts fall. 					 */
name|j
operator|=
name|rp
operator|->
name|rc_timestamp
operator|-
name|tcp_lasttrim
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|tto
condition|)
name|j
operator|=
name|HISTSIZE
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|j
operator|=
literal|0
expr_stmt|;
else|else
name|j
operator|=
name|j
operator|*
name|HISTSIZE
operator|/
name|tto
expr_stmt|;
name|time_histo
index|[
name|j
index|]
operator|++
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nfsrchash_table
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force
condition|)
block|{
comment|/* 			 * Trim some more with a smaller timeout of as little 			 * as 20% of nfsrc_tcptimeout to try and get below 			 * 80% of the nfsrc_tcphighwater. 			 */
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|HISTSIZE
operator|-
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|k
operator|+=
name|time_histo
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|force
condition|)
break|break;
block|}
name|k
operator|=
name|tto
operator|*
operator|(
name|i
operator|+
literal|1
operator|)
operator|/
name|HISTSIZE
expr_stmt|;
if|if
condition|(
name|k
operator|<
literal|1
condition|)
name|k
operator|=
literal|1
expr_stmt|;
name|thisstamp
operator|=
name|tcp_lasttrim
operator|+
name|k
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFSRVCACHE_HASHSIZE
condition|;
name|i
operator|++
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nfsrchash_table
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|rp
argument_list|,
argument|&nfsrchash_table[i].tbl
argument_list|,
argument|rc_hash
argument_list|,
argument|nextrp
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|rp
operator|->
name|rc_flag
operator|&
operator|(
name|RC_INPROG
operator||
name|RC_LOCKED
operator||
name|RC_WANTED
operator|)
operator|)
operator|&&
name|rp
operator|->
name|rc_refcnt
operator|==
literal|0
operator|&&
operator|(
operator|(
name|rp
operator|->
name|rc_flag
operator|&
name|RC_REFCNT
operator|)
operator|||
name|thisstamp
operator|>
name|rp
operator|->
name|rc_timestamp
operator|||
name|rp
operator|->
name|rc_acked
operator|==
name|RC_ACK
operator|)
condition|)
name|nfsrc_freecache
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nfsrchash_table
index|[
name|i
index|]
operator|.
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|atomic_store_rel_int
argument_list|(
operator|&
name|onethread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a seqid# reference to the cache entry.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrvd_refcache
parameter_list|(
name|struct
name|nfsrvcache
modifier|*
name|rp
parameter_list|)
block|{
name|struct
name|mtx
modifier|*
name|mutex
decl_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
comment|/* For NFSv4.1, there is no cache entry. */
return|return;
name|mutex
operator|=
name|nfsrc_cachemutex
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rc_refcnt
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs cache refcnt"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rc_refcnt
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dereference a seqid# cache entry.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrvd_derefcache
parameter_list|(
name|struct
name|nfsrvcache
modifier|*
name|rp
parameter_list|)
block|{
name|struct
name|mtx
modifier|*
name|mutex
decl_stmt|;
name|mutex
operator|=
name|nfsrc_cachemutex
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rc_refcnt
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs cache derefcnt"
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rc_refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rc_refcnt
operator|==
literal|0
operator|&&
operator|!
operator|(
name|rp
operator|->
name|rc_flag
operator|&
operator|(
name|RC_LOCKED
operator||
name|RC_INPROG
operator|)
operator|)
condition|)
name|nfsrc_freecache
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculate the length of the mbuf list and a checksum on the first up to  * NFSRVCACHE_CHECKLEN bytes.  */
end_comment

begin_function
specifier|static
name|int
name|nfsrc_getlenandcksum
parameter_list|(
name|mbuf_t
name|m1
parameter_list|,
name|u_int16_t
modifier|*
name|cksum
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|,
name|cklen
decl_stmt|;
name|mbuf_t
name|m
decl_stmt|;
name|m
operator|=
name|m1
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|len
operator|+=
name|mbuf_len
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|mbuf_next
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|cklen
operator|=
operator|(
name|len
operator|>
name|NFSRVCACHE_CHECKLEN
operator|)
condition|?
name|NFSRVCACHE_CHECKLEN
else|:
name|len
expr_stmt|;
operator|*
name|cksum
operator|=
name|in_cksum
argument_list|(
name|m1
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark a TCP connection that is seeing retries. Should never happen for  * NFSv4.  */
end_comment

begin_function
specifier|static
name|void
name|nfsrc_marksametcpconn
parameter_list|(
name|u_int64_t
name|sockref
parameter_list|)
block|{ }
end_function

end_unit

