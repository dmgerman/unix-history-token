begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-3-Clause  *  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Rick Macklem at The University of Guelph.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|APPLEKEXT
end_ifndef

begin_comment
comment|/*  * These functions support the macros and help fiddle mbuf chains for  * the nfs op functions. They do things like create the rpc header and  * copy data between mbuf chains and uio lists.  */
end_comment

begin_include
include|#
directive|include
file|<fs/nfs/nfsport.h>
end_include

begin_decl_stmt
specifier|extern
name|u_int32_t
name|newnfs_true
decl_stmt|,
name|newnfs_false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfs_pubfhset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfsclienthashhead
modifier|*
name|nfsclienthash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_clienthashsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfslockhashhead
modifier|*
name|nfslockhash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_lockhashsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|nfssessionhash
modifier|*
name|nfssessionhash
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_sessionhashsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nfsrv_useacl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|uid_t
name|nfsrv_defaultuid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|gid_t
name|nfsrv_defaultgid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|nfs_v2pubfh
index|[
name|NFSX_V2FH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|nfstype
name|newnfsv2_type
index|[
literal|9
index|]
init|=
block|{
name|NFNON
block|,
name|NFREG
block|,
name|NFDIR
block|,
name|NFBLK
block|,
name|NFCHR
block|,
name|NFLNK
block|,
name|NFNON
block|,
name|NFCHR
block|,
name|NFNON
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|nfstype
name|nfsv34_type
index|[
literal|9
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !APPLEKEXT */
end_comment

begin_function_decl
specifier|static
name|u_int32_t
name|nfsrv_isannfserr
parameter_list|(
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_nfsd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|enable_checkutf8
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfsd
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_checkutf8
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|enable_checkutf8
argument_list|,
literal|0
argument_list|,
literal|"Enable the NFSv4 check for the UTF8 compliant name required by rfc3530"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|enable_nobodycheck
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfsd
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_nobodycheck
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|enable_nobodycheck
argument_list|,
literal|0
argument_list|,
literal|"Enable the NFSv4 check when setting user nobody as owner"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|enable_nogroupcheck
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_nfsd
argument_list|,
name|OID_AUTO
argument_list|,
name|enable_nogroupcheck
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|enable_nogroupcheck
argument_list|,
literal|0
argument_list|,
literal|"Enable the NFSv4 check when setting group nogroup as owner"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|char
name|nfsrv_hexdigit
parameter_list|(
name|char
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Maps errno values to nfs error numbers.  * Use NFSERR_IO as the catch all for ones not specifically defined in  * RFC 1094. (It now includes the errors added for NFSv3.)  */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|nfsrv_v2errmap
index|[
name|NFSERR_REMOTE
index|]
init|=
block|{
name|NFSERR_PERM
block|,
name|NFSERR_NOENT
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_NXIO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_EXIST
block|,
name|NFSERR_XDEV
block|,
name|NFSERR_NODEV
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_FBIG
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_IO
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_MLINK
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_NOTEMPTY
block|,
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_REMOTE
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Maps errno values to nfs error numbers.  * Although it is not obvious whether or not NFS clients really care if  * a returned error value is in the specified list for the procedure, the  * safest thing to do is filter them appropriately. For Version 2, the  * X/Open XNFS document is the only specification that defines error values  * for each RPC (The RFC simply lists all possible error values for all RPCs),  * so I have decided to not do this for Version 2.  * The first entry is the default error return and the rest are the valid  * errors for that RPC in increasing numeric order.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_null
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_getattr
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_setattr
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_PERM
block|,
name|NFSERR_IO
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_NOT_SYNC
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_lookup
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_NOENT
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_IO
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_access
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_readlink
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_read
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_NXIO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_write
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_FBIG
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_create
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_EXIST
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_IO
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_mkdir
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_EXIST
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_IO
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_symlink
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_EXIST
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_IO
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_mknod
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_EXIST
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_IO
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_BADTYPE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_remove
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_NOENT
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_IO
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_rmdir
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_NOENT
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_IO
block|,
name|NFSERR_EXIST
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_NOTEMPTY
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_rename
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_NOENT
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_EXIST
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_XDEV
block|,
name|NFSERR_IO
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_MLINK
block|,
name|NFSERR_NOTEMPTY
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_link
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_EXIST
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_IO
block|,
name|NFSERR_XDEV
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_MLINK
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_readdir
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_IO
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BAD_COOKIE
block|,
name|NFSERR_TOOSMALL
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_readdirplus
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_IO
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BAD_COOKIE
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_TOOSMALL
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_fsstat
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_fsinfo
index|[]
init|=
block|{
name|NFSERR_STALE
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_pathconf
index|[]
init|=
block|{
name|NFSERR_STALE
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv3err_commit
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_IO
block|,
name|NFSERR_STALE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_DELAY
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|nfsrv_v3errmap
index|[]
init|=
block|{
name|nfsv3err_null
block|,
name|nfsv3err_getattr
block|,
name|nfsv3err_setattr
block|,
name|nfsv3err_lookup
block|,
name|nfsv3err_access
block|,
name|nfsv3err_readlink
block|,
name|nfsv3err_read
block|,
name|nfsv3err_write
block|,
name|nfsv3err_create
block|,
name|nfsv3err_mkdir
block|,
name|nfsv3err_symlink
block|,
name|nfsv3err_mknod
block|,
name|nfsv3err_remove
block|,
name|nfsv3err_rmdir
block|,
name|nfsv3err_rename
block|,
name|nfsv3err_link
block|,
name|nfsv3err_readdir
block|,
name|nfsv3err_readdirplus
block|,
name|nfsv3err_fsstat
block|,
name|nfsv3err_fsinfo
block|,
name|nfsv3err_pathconf
block|,
name|nfsv3err_commit
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * And the same for V4.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_null
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_access
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_close
index|[]
init|=
block|{
name|NFSERR_EXPIRED
block|,
name|NFSERR_ADMINREVOKED
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADSEQID
block|,
name|NFSERR_BADSTATEID
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_EXPIRED
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_LEASEMOVED
block|,
name|NFSERR_LOCKSHELD
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_OLDSTATEID
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_STALESTATEID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_commit
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_create
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_ATTRNOTSUPP
block|,
name|NFSERR_BADCHAR
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADNAME
block|,
name|NFSERR_BADOWNER
block|,
name|NFSERR_BADTYPE
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_EXIST
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_PERM
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_delegpurge
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_LEASEMOVED
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALECLIENTID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_delegreturn
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_ADMINREVOKED
block|,
name|NFSERR_BADSTATEID
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_EXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_LEASEMOVED
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_OLDSTATEID
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_STALESTATEID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_getattr
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_getfh
index|[]
init|=
block|{
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_link
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_BADCHAR
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADNAME
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_EXIST
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_FILEOPEN
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_MLINK
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_NOENT
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_WRONGSEC
block|,
name|NFSERR_XDEV
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_lock
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_ADMINREVOKED
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADRANGE
block|,
name|NFSERR_BADSEQID
block|,
name|NFSERR_BADSTATEID
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DEADLOCK
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_DENIED
block|,
name|NFSERR_EXPIRED
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_GRACE
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_LEASEMOVED
block|,
name|NFSERR_LOCKNOTSUPP
block|,
name|NFSERR_LOCKRANGE
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOGRACE
block|,
name|NFSERR_OLDSTATEID
block|,
name|NFSERR_OPENMODE
block|,
name|NFSERR_RECLAIMBAD
block|,
name|NFSERR_RECLAIMCONFLICT
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_STALECLIENTID
block|,
name|NFSERR_STALESTATEID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_lockt
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADRANGE
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_DENIED
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_GRACE
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_LEASEMOVED
block|,
name|NFSERR_LOCKRANGE
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_STALECLIENTID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_locku
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_ADMINREVOKED
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADRANGE
block|,
name|NFSERR_BADSEQID
block|,
name|NFSERR_BADSTATEID
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_EXPIRED
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_GRACE
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_LEASEMOVED
block|,
name|NFSERR_LOCKRANGE
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_OLDSTATEID
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_STALESTATEID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_lookup
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_BADCHAR
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADNAME
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_NOENT
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_SYMLINK
block|,
name|NFSERR_WRONGSEC
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_lookupp
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_IO
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOENT
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_nverify
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_ATTRNOTSUPP
block|,
name|NFSERR_BADCHAR
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SAME
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_open
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_ADMINREVOKED
block|,
name|NFSERR_ATTRNOTSUPP
block|,
name|NFSERR_BADCHAR
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADNAME
block|,
name|NFSERR_BADOWNER
block|,
name|NFSERR_BADSEQID
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_EXIST
block|,
name|NFSERR_EXPIRED
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_GRACE
block|,
name|NFSERR_IO
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_LEASEMOVED
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_NOENT
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOGRACE
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_PERM
block|,
name|NFSERR_RECLAIMBAD
block|,
name|NFSERR_RECLAIMCONFLICT
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_SHAREDENIED
block|,
name|NFSERR_STALE
block|,
name|NFSERR_STALECLIENTID
block|,
name|NFSERR_SYMLINK
block|,
name|NFSERR_WRONGSEC
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_openattr
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_IO
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOENT
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_openconfirm
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_ADMINREVOKED
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADSEQID
block|,
name|NFSERR_BADSTATEID
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_EXPIRED
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_OLDSTATEID
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_STALESTATEID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_opendowngrade
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_ADMINREVOKED
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADSEQID
block|,
name|NFSERR_BADSTATEID
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_EXPIRED
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_OLDSTATEID
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_STALESTATEID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_putfh
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_WRONGSEC
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_putpubfh
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_WRONGSEC
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_putrootfh
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_WRONGSEC
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_read
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_ADMINREVOKED
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADSTATEID
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_EXPIRED
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_GRACE
block|,
name|NFSERR_IO
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_LEASEMOVED
block|,
name|NFSERR_LOCKED
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NXIO
block|,
name|NFSERR_OLDSTATEID
block|,
name|NFSERR_OPENMODE
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_STALESTATEID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_readdir
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BAD_COOKIE
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_NOTSAME
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_TOOSMALL
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_readlink
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOTSUPP
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_remove
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_BADCHAR
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADNAME
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_FILEOPEN
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_NOENT
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_NOTEMPTY
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_rename
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_BADCHAR
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADNAME
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_EXIST
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_FILEOPEN
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_NOENT
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_NOTEMPTY
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_WRONGSEC
block|,
name|NFSERR_XDEV
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_renew
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_ADMINREVOKED
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_CBPATHDOWN
block|,
name|NFSERR_EXPIRED
block|,
name|NFSERR_LEASEMOVED
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALECLIENTID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_restorefh
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_RESTOREFH
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_WRONGSEC
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_savefh
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_secinfo
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_BADCHAR
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADNAME
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NAMETOL
block|,
name|NFSERR_NOENT
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOTDIR
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_setattr
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_ADMINREVOKED
block|,
name|NFSERR_ATTRNOTSUPP
block|,
name|NFSERR_BADCHAR
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADOWNER
block|,
name|NFSERR_BADSTATEID
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_EXPIRED
block|,
name|NFSERR_FBIG
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_GRACE
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_LOCKED
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_OLDSTATEID
block|,
name|NFSERR_OPENMODE
block|,
name|NFSERR_PERM
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_STALESTATEID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_setclientid
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_CLIDINUSE
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_WRONGSEC
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_setclientidconfirm
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_CLIDINUSE
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALECLIENTID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_verify
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_ATTRNOTSUPP
block|,
name|NFSERR_BADCHAR
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOTSAME
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_write
index|[]
init|=
block|{
name|NFSERR_IO
block|,
name|NFSERR_ACCES
block|,
name|NFSERR_ADMINREVOKED
block|,
name|NFSERR_BADHANDLE
block|,
name|NFSERR_BADSTATEID
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_DELAY
block|,
name|NFSERR_DQUOT
block|,
name|NFSERR_EXPIRED
block|,
name|NFSERR_FBIG
block|,
name|NFSERR_FHEXPIRED
block|,
name|NFSERR_GRACE
block|,
name|NFSERR_INVAL
block|,
name|NFSERR_IO
block|,
name|NFSERR_ISDIR
block|,
name|NFSERR_LEASEMOVED
block|,
name|NFSERR_LOCKED
block|,
name|NFSERR_MOVED
block|,
name|NFSERR_NOFILEHANDLE
block|,
name|NFSERR_NOSPC
block|,
name|NFSERR_NXIO
block|,
name|NFSERR_OLDSTATEID
block|,
name|NFSERR_OPENMODE
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_ROFS
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALE
block|,
name|NFSERR_STALESTATEID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|nfsv4err_releaselockowner
index|[]
init|=
block|{
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_ADMINREVOKED
block|,
name|NFSERR_BADXDR
block|,
name|NFSERR_EXPIRED
block|,
name|NFSERR_LEASEMOVED
block|,
name|NFSERR_LOCKSHELD
block|,
name|NFSERR_RESOURCE
block|,
name|NFSERR_SERVERFAULT
block|,
name|NFSERR_STALECLIENTID
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
modifier|*
name|nfsrv_v4errmap
index|[]
init|=
block|{
name|nfsv4err_null
block|,
name|nfsv4err_null
block|,
name|nfsv4err_null
block|,
name|nfsv4err_access
block|,
name|nfsv4err_close
block|,
name|nfsv4err_commit
block|,
name|nfsv4err_create
block|,
name|nfsv4err_delegpurge
block|,
name|nfsv4err_delegreturn
block|,
name|nfsv4err_getattr
block|,
name|nfsv4err_getfh
block|,
name|nfsv4err_link
block|,
name|nfsv4err_lock
block|,
name|nfsv4err_lockt
block|,
name|nfsv4err_locku
block|,
name|nfsv4err_lookup
block|,
name|nfsv4err_lookupp
block|,
name|nfsv4err_nverify
block|,
name|nfsv4err_open
block|,
name|nfsv4err_openattr
block|,
name|nfsv4err_openconfirm
block|,
name|nfsv4err_opendowngrade
block|,
name|nfsv4err_putfh
block|,
name|nfsv4err_putpubfh
block|,
name|nfsv4err_putrootfh
block|,
name|nfsv4err_read
block|,
name|nfsv4err_readdir
block|,
name|nfsv4err_readlink
block|,
name|nfsv4err_remove
block|,
name|nfsv4err_rename
block|,
name|nfsv4err_renew
block|,
name|nfsv4err_restorefh
block|,
name|nfsv4err_savefh
block|,
name|nfsv4err_secinfo
block|,
name|nfsv4err_setattr
block|,
name|nfsv4err_setclientid
block|,
name|nfsv4err_setclientidconfirm
block|,
name|nfsv4err_verify
block|,
name|nfsv4err_write
block|,
name|nfsv4err_releaselockowner
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A fiddled version of m_adj() that ensures null fill to a long  * boundary and only trims off the back end  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_adj
parameter_list|(
name|mbuf_t
name|mp
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|nul
parameter_list|)
block|{
name|mbuf_t
name|m
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * Trim from tail.  Scan the mbuf chain, 	 * calculating its length and finding the last mbuf. 	 * If the adjustment only affects this mbuf, then just 	 * adjust and return.  Otherwise, rescan and truncate 	 * after the remaining size. 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|mp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|count
operator|+=
name|mbuf_len
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbuf_next
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
condition|)
break|break;
name|m
operator|=
name|mbuf_next
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mbuf_len
argument_list|(
name|m
argument_list|)
operator|>
name|len
condition|)
block|{
name|mbuf_setlen
argument_list|(
name|m
argument_list|,
name|mbuf_len
argument_list|(
name|m
argument_list|)
operator|-
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nul
operator|>
literal|0
condition|)
block|{
name|cp
operator|=
name|NFSMTOD
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mbuf_len
argument_list|(
name|m
argument_list|)
operator|-
name|nul
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nul
condition|;
name|i
operator|++
control|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return;
block|}
name|count
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Correct length for chain is "count". 	 * Find the mbuf with last data, adjust its length, 	 * and toss data from remaining mbufs on chain. 	 */
for|for
control|(
name|m
operator|=
name|mp
init|;
name|m
condition|;
name|m
operator|=
name|mbuf_next
argument_list|(
name|m
argument_list|)
control|)
block|{
if|if
condition|(
name|mbuf_len
argument_list|(
name|m
argument_list|)
operator|>=
name|count
condition|)
block|{
name|mbuf_setlen
argument_list|(
name|m
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|nul
operator|>
literal|0
condition|)
block|{
name|cp
operator|=
name|NFSMTOD
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mbuf_len
argument_list|(
name|m
argument_list|)
operator|-
name|nul
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nul
condition|;
name|i
operator|++
control|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
break|break;
block|}
name|count
operator|-=
name|mbuf_len
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|m
operator|=
name|mbuf_next
argument_list|(
name|m
argument_list|)
init|;
name|m
condition|;
name|m
operator|=
name|mbuf_next
argument_list|(
name|m
argument_list|)
control|)
name|mbuf_setlen
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make these functions instead of macros, so that the kernel text size  * doesn't get too big...  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_wcc
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|int
name|before_ret
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|before_nvap
parameter_list|,
name|int
name|after_ret
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|after_nvap
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
if|if
condition|(
name|before_ret
condition|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
block|}
else|else
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|7
operator|*
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|newnfs_true
expr_stmt|;
name|txdr_hyper
argument_list|(
name|before_nvap
operator|->
name|na_size
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|txdr_nfsv3time
argument_list|(
operator|&
operator|(
name|before_nvap
operator|->
name|na_mtime
operator|)
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|tl
operator|+=
literal|2
expr_stmt|;
name|txdr_nfsv3time
argument_list|(
operator|&
operator|(
name|before_nvap
operator|->
name|na_ctime
operator|)
argument_list|,
name|tl
argument_list|)
expr_stmt|;
block|}
name|nfsrv_postopattr
argument_list|(
name|nd
argument_list|,
name|after_ret
argument_list|,
name|after_nvap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|APPLESTATIC
name|void
name|nfsrv_postopattr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|int
name|after_ret
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|after_nvap
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_ret
condition|)
operator|*
name|tl
operator|=
name|newnfs_false
expr_stmt|;
else|else
block|{
operator|*
name|tl
operator|=
name|newnfs_true
expr_stmt|;
name|nfsrv_fillattr
argument_list|(
name|nd
argument_list|,
name|after_nvap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fill in file attributes for V2 and 3. For V4, call a separate  * routine that sifts through all the attribute bits.  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_fillattr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|)
block|{
name|struct
name|nfs_fattr
modifier|*
name|fp
decl_stmt|;
name|int
name|fattr_size
decl_stmt|;
comment|/* 	 * Build space for the attribute structure. 	 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|fattr_size
operator|=
name|NFSX_V3FATTR
expr_stmt|;
else|else
name|fattr_size
operator|=
name|NFSX_V2FATTR
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|fp
argument_list|,
expr|struct
name|nfs_fattr
operator|*
argument_list|,
name|fattr_size
argument_list|)
expr_stmt|;
comment|/* 	 * Now just fill it all in. 	 */
name|fp
operator|->
name|fa_nlink
operator|=
name|txdr_unsigned
argument_list|(
name|nvap
operator|->
name|na_nlink
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fa_uid
operator|=
name|txdr_unsigned
argument_list|(
name|nvap
operator|->
name|na_uid
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fa_gid
operator|=
name|txdr_unsigned
argument_list|(
name|nvap
operator|->
name|na_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
block|{
name|fp
operator|->
name|fa_type
operator|=
name|vtonfsv34_type
argument_list|(
name|nvap
operator|->
name|na_type
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fa_mode
operator|=
name|vtonfsv34_mode
argument_list|(
name|nvap
operator|->
name|na_mode
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|nvap
operator|->
name|na_size
argument_list|,
operator|&
name|fp
operator|->
name|fa3_size
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|nvap
operator|->
name|na_bytes
argument_list|,
operator|&
name|fp
operator|->
name|fa3_used
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fa3_rdev
operator|.
name|specdata1
operator|=
name|txdr_unsigned
argument_list|(
name|NFSMAJOR
argument_list|(
name|nvap
operator|->
name|na_rdev
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fa3_rdev
operator|.
name|specdata2
operator|=
name|txdr_unsigned
argument_list|(
name|NFSMINOR
argument_list|(
name|nvap
operator|->
name|na_rdev
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fa3_fsid
operator|.
name|nfsuquad
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|fa3_fsid
operator|.
name|nfsuquad
index|[
literal|1
index|]
operator|=
name|txdr_unsigned
argument_list|(
name|nvap
operator|->
name|na_fsid
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|nvap
operator|->
name|na_fileid
argument_list|,
operator|&
name|fp
operator|->
name|fa3_fileid
argument_list|)
expr_stmt|;
name|txdr_nfsv3time
argument_list|(
operator|&
name|nvap
operator|->
name|na_atime
argument_list|,
operator|&
name|fp
operator|->
name|fa3_atime
argument_list|)
expr_stmt|;
name|txdr_nfsv3time
argument_list|(
operator|&
name|nvap
operator|->
name|na_mtime
argument_list|,
operator|&
name|fp
operator|->
name|fa3_mtime
argument_list|)
expr_stmt|;
name|txdr_nfsv3time
argument_list|(
operator|&
name|nvap
operator|->
name|na_ctime
argument_list|,
operator|&
name|fp
operator|->
name|fa3_ctime
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|fa_type
operator|=
name|vtonfsv2_type
argument_list|(
name|nvap
operator|->
name|na_type
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fa_mode
operator|=
name|vtonfsv2_mode
argument_list|(
name|nvap
operator|->
name|na_type
argument_list|,
name|nvap
operator|->
name|na_mode
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fa2_size
operator|=
name|txdr_unsigned
argument_list|(
name|nvap
operator|->
name|na_size
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fa2_blocksize
operator|=
name|txdr_unsigned
argument_list|(
name|nvap
operator|->
name|na_blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvap
operator|->
name|na_type
operator|==
name|VFIFO
condition|)
name|fp
operator|->
name|fa2_rdev
operator|=
literal|0xffffffff
expr_stmt|;
else|else
name|fp
operator|->
name|fa2_rdev
operator|=
name|txdr_unsigned
argument_list|(
name|nvap
operator|->
name|na_rdev
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fa2_blocks
operator|=
name|txdr_unsigned
argument_list|(
name|nvap
operator|->
name|na_bytes
operator|/
name|NFS_FABLKSIZE
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fa2_fsid
operator|=
name|txdr_unsigned
argument_list|(
name|nvap
operator|->
name|na_fsid
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fa2_fileid
operator|=
name|txdr_unsigned
argument_list|(
name|nvap
operator|->
name|na_fileid
argument_list|)
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|nvap
operator|->
name|na_atime
argument_list|,
operator|&
name|fp
operator|->
name|fa2_atime
argument_list|)
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|nvap
operator|->
name|na_mtime
argument_list|,
operator|&
name|fp
operator|->
name|fa2_mtime
argument_list|)
expr_stmt|;
name|txdr_nfsv2time
argument_list|(
operator|&
name|nvap
operator|->
name|na_ctime
argument_list|,
operator|&
name|fp
operator|->
name|fa2_ctime
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function gets a file handle out of an mbuf list.  * It returns 0 for success, EBADRPC otherwise.  * If sets the third flagp argument to 1 if the file handle is  * the public file handle.  * For NFSv4, if the length is incorrect, set nd_repstat == NFSERR_BADHANDLE  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_mtofh
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsrvfh
modifier|*
name|fhp
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|,
name|copylen
decl_stmt|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|nfs_pubfhset
operator|&&
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
operator|)
operator|&&
name|nd
operator|->
name|nd_procnum
operator|==
name|NFSPROC_LOOKUP
condition|)
block|{
name|nd
operator|->
name|nd_flag
operator||=
name|ND_PUBLOOKUP
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|len
operator|<
name|NFSRV_MINFH
operator|||
name|len
operator|>
name|NFSRV_MAXFH
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<=
name|NFSX_V4FHMAX
condition|)
block|{
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_BADHANDLE
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
else|else
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
block|}
name|copylen
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * For NFSv2, the file handle is always 32 bytes on the 		 * wire, but this server only cares about the first 		 * NFSRV_MAXFH bytes. 		 */
name|len
operator|=
name|NFSX_V2FH
expr_stmt|;
name|copylen
operator|=
name|NFSRV_MAXFH
expr_stmt|;
block|}
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV2
operator|)
operator|&&
name|nfs_pubfhset
operator|&&
name|nd
operator|->
name|nd_procnum
operator|==
name|NFSPROC_LOOKUP
operator|&&
operator|!
name|NFSBCMP
argument_list|(
operator|(
name|caddr_t
operator|)
name|tl
argument_list|,
name|nfs_v2pubfh
argument_list|,
name|NFSX_V2FH
argument_list|)
condition|)
block|{
name|nd
operator|->
name|nd_flag
operator||=
name|ND_PUBLOOKUP
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|NFSBCOPY
argument_list|(
name|tl
argument_list|,
operator|(
name|caddr_t
operator|)
name|fhp
operator|->
name|nfsrvfh_data
argument_list|,
name|copylen
argument_list|)
expr_stmt|;
name|fhp
operator|->
name|nfsrvfh_len
operator|=
name|copylen
expr_stmt|;
name|nfsmout
label|:
name|NFSEXITCODE2
argument_list|(
name|error
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map errnos to NFS error numbers. For Version 3 and 4 also filter out error  * numbers not specified for the associated procedure.  * NFSPROC_NOOP is a special case, where the high order bits of nd_repstat  * should be cleared. NFSPROC_NOOP is used to return errors when a valid  * RPC procedure is not involved.  * Returns the error number in XDR.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsd_errmap
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|)
block|{
name|short
modifier|*
name|defaulterrp
decl_stmt|,
modifier|*
name|errp
decl_stmt|;
if|if
condition|(
operator|!
name|nd
operator|->
name|nd_repstat
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_NFSV3
operator||
name|ND_NFSV4
operator|)
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_procnum
operator|==
name|NFSPROC_NOOP
condition|)
return|return
operator|(
name|txdr_unsigned
argument_list|(
name|nd
operator|->
name|nd_repstat
operator|&
literal|0xffff
argument_list|)
operator|)
return|;
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV3
condition|)
name|errp
operator|=
name|defaulterrp
operator|=
name|nfsrv_v3errmap
index|[
name|nd
operator|->
name|nd_procnum
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|EBADRPC
condition|)
return|return
operator|(
name|txdr_unsigned
argument_list|(
name|NFSERR_BADXDR
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_MINORVERMISMATCH
operator|||
name|nd
operator|->
name|nd_repstat
operator|==
name|NFSERR_OPILLEGAL
condition|)
return|return
operator|(
name|txdr_unsigned
argument_list|(
name|nd
operator|->
name|nd_repstat
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV41
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|==
name|EOPNOTSUPP
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_NOTSUPP
expr_stmt|;
name|nd
operator|->
name|nd_repstat
operator|=
name|nfsrv_isannfserr
argument_list|(
name|nd
operator|->
name|nd_repstat
argument_list|)
expr_stmt|;
return|return
operator|(
name|txdr_unsigned
argument_list|(
name|nd
operator|->
name|nd_repstat
argument_list|)
operator|)
return|;
block|}
else|else
name|errp
operator|=
name|defaulterrp
operator|=
name|nfsrv_v4errmap
index|[
name|nd
operator|->
name|nd_procnum
index|]
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|errp
condition|)
if|if
condition|(
operator|*
name|errp
operator|==
name|nd
operator|->
name|nd_repstat
condition|)
return|return
operator|(
name|txdr_unsigned
argument_list|(
name|nd
operator|->
name|nd_repstat
argument_list|)
operator|)
return|;
return|return
operator|(
name|txdr_unsigned
argument_list|(
operator|*
name|defaulterrp
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_repstat
operator|<=
name|NFSERR_REMOTE
condition|)
return|return
operator|(
name|txdr_unsigned
argument_list|(
name|nfsrv_v2errmap
index|[
name|nd
operator|->
name|nd_repstat
operator|-
literal|1
index|]
argument_list|)
operator|)
return|;
return|return
operator|(
name|txdr_unsigned
argument_list|(
name|NFSERR_IO
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if the error is a valid NFS one. If not, replace it with  * NFSERR_IO.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|nfsrv_isannfserr
parameter_list|(
name|u_int32_t
name|errval
parameter_list|)
block|{
if|if
condition|(
name|errval
operator|==
name|NFSERR_OK
condition|)
return|return
operator|(
name|errval
operator|)
return|;
if|if
condition|(
name|errval
operator|>=
name|NFSERR_BADHANDLE
operator|&&
name|errval
operator|<=
name|NFSERR_DELEGREVOKED
condition|)
return|return
operator|(
name|errval
operator|)
return|;
if|if
condition|(
name|errval
operator|>
literal|0
operator|&&
name|errval
operator|<=
name|NFSERR_REMOTE
condition|)
return|return
operator|(
name|nfsrv_v2errmap
index|[
name|errval
operator|-
literal|1
index|]
operator|)
return|;
return|return
operator|(
name|NFSERR_IO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if setting a uid/gid is permitted when creating a new  * file object. (Called when uid and/or gid is specified in the  * settable attributes for V4.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_checkuidgid
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * If not setting either uid nor gid, it's OK. 	 */
if|if
condition|(
name|NFSVNO_NOTSETUID
argument_list|(
name|nvap
argument_list|)
operator|&&
name|NFSVNO_NOTSETGID
argument_list|(
name|nvap
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|NFSVNO_ISSETUID
argument_list|(
name|nvap
argument_list|)
operator|&&
name|nvap
operator|->
name|na_uid
operator|==
name|nfsrv_defaultuid
operator|&&
name|enable_nobodycheck
operator|==
literal|1
operator|)
operator|||
operator|(
name|NFSVNO_ISSETGID
argument_list|(
name|nvap
argument_list|)
operator|&&
name|nvap
operator|->
name|na_gid
operator|==
name|nfsrv_defaultgid
operator|&&
name|enable_nogroupcheck
operator|==
literal|1
operator|)
condition|)
block|{
name|error
operator|=
name|NFSERR_BADOWNER
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|NFSVNO_ISSETUID
argument_list|(
name|nvap
argument_list|)
operator|&&
name|nvap
operator|->
name|na_uid
operator|!=
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
operator|)
operator|||
operator|(
name|NFSVNO_ISSETGID
argument_list|(
name|nvap
argument_list|)
operator|&&
name|nvap
operator|->
name|na_gid
operator|!=
name|nd
operator|->
name|nd_cred
operator|->
name|cr_gid
operator|&&
operator|!
name|groupmember
argument_list|(
name|nvap
operator|->
name|na_gid
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|)
operator|)
condition|)
name|error
operator|=
name|NFSERR_PERM
expr_stmt|;
name|out
label|:
name|NFSEXITCODE2
argument_list|(
name|error
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * and this routine fixes up the settable attributes for V4 if allowed  * by nfsrv_checkuidgid().  */
end_comment

begin_function
name|APPLESTATIC
name|void
name|nfsrv_fixattr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|vnode_t
name|vp
parameter_list|,
name|struct
name|nfsvattr
modifier|*
name|nvap
parameter_list|,
name|NFSACL_T
modifier|*
name|aclp
parameter_list|,
name|NFSPROC_T
modifier|*
name|p
parameter_list|,
name|nfsattrbit_t
modifier|*
name|attrbitp
parameter_list|,
name|struct
name|nfsexstuff
modifier|*
name|exp
parameter_list|)
block|{
name|int
name|change
init|=
literal|0
decl_stmt|;
name|struct
name|nfsvattr
name|nva
decl_stmt|;
name|uid_t
name|tuid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nfsattrbit_t
name|nattrbits
decl_stmt|;
comment|/* 	 * Maybe this should be done for V2 and 3 but it never has been 	 * and nobody seems to be upset, so I think it's best not to change 	 * the V2 and 3 semantics. 	 */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|NFSVNO_ATTRINIT
argument_list|(
operator|&
name|nva
argument_list|)
expr_stmt|;
name|NFSZERO_ATTRBIT
argument_list|(
operator|&
name|nattrbits
argument_list|)
expr_stmt|;
name|tuid
operator|=
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
expr_stmt|;
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_OWNER
argument_list|)
operator|&&
name|NFSVNO_ISSETUID
argument_list|(
name|nvap
argument_list|)
operator|&&
name|nvap
operator|->
name|na_uid
operator|!=
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
operator|==
literal|0
condition|)
block|{
name|nva
operator|.
name|na_uid
operator|=
name|nvap
operator|->
name|na_uid
expr_stmt|;
name|change
operator|++
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|nattrbits
argument_list|,
name|NFSATTRBIT_OWNER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSCLRBIT_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_OWNER
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_TIMEACCESSSET
argument_list|)
operator|&&
name|NFSVNO_ISSETATIME
argument_list|(
name|nvap
argument_list|)
condition|)
block|{
name|nva
operator|.
name|na_atime
operator|=
name|nvap
operator|->
name|na_atime
expr_stmt|;
name|change
operator|++
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|nattrbits
argument_list|,
name|NFSATTRBIT_TIMEACCESSSET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_TIMEMODIFYSET
argument_list|)
operator|&&
name|NFSVNO_ISSETMTIME
argument_list|(
name|nvap
argument_list|)
condition|)
block|{
name|nva
operator|.
name|na_mtime
operator|=
name|nvap
operator|->
name|na_mtime
expr_stmt|;
name|change
operator|++
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|nattrbits
argument_list|,
name|NFSATTRBIT_TIMEMODIFYSET
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_OWNERGROUP
argument_list|)
operator|&&
name|NFSVNO_ISSETGID
argument_list|(
name|nvap
argument_list|)
condition|)
block|{
if|if
condition|(
name|nvap
operator|->
name|na_gid
operator|==
name|nd
operator|->
name|nd_cred
operator|->
name|cr_gid
operator|||
name|groupmember
argument_list|(
name|nvap
operator|->
name|na_gid
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|)
condition|)
block|{
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
operator|=
literal|0
expr_stmt|;
name|nva
operator|.
name|na_gid
operator|=
name|nvap
operator|->
name|na_gid
expr_stmt|;
name|change
operator|++
expr_stmt|;
name|NFSSETBIT_ATTRBIT
argument_list|(
operator|&
name|nattrbits
argument_list|,
name|NFSATTRBIT_OWNERGROUP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NFSCLRBIT_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_OWNERGROUP
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|change
condition|)
block|{
name|error
operator|=
name|nfsvno_setattr
argument_list|(
name|vp
argument_list|,
operator|&
name|nva
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
name|p
argument_list|,
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NFSCLRALL_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
operator|&
name|nattrbits
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_SIZE
argument_list|)
operator|&&
name|NFSVNO_ISSETSIZE
argument_list|(
name|nvap
argument_list|)
operator|&&
name|nvap
operator|->
name|na_size
operator|!=
operator|(
name|u_quad_t
operator|)
literal|0
condition|)
block|{
name|NFSCLRBIT_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_SIZE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NFS4_ACL_EXTATTR_NAME
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_ACL
argument_list|)
operator|&&
name|nfsrv_useacl
operator|!=
literal|0
operator|&&
name|aclp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|aclp
operator|->
name|acl_cnt
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|nfsrv_setacl
argument_list|(
name|vp
argument_list|,
name|aclp
argument_list|,
name|nd
operator|->
name|nd_cred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NFSCLRBIT_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_ACL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
name|NFSCLRBIT_ATTRBIT
argument_list|(
name|attrbitp
argument_list|,
name|NFSATTRBIT_ACL
argument_list|)
expr_stmt|;
name|nd
operator|->
name|nd_cred
operator|->
name|cr_uid
operator|=
name|tuid
expr_stmt|;
name|out
label|:
name|NFSEXITCODE2
argument_list|(
literal|0
argument_list|,
name|nd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Translate an ASCII hex digit to it's binary value. Return -1 if the  * char isn't a hex digit.  */
end_comment

begin_function
specifier|static
name|char
name|nfsrv_hexdigit
parameter_list|(
name|char
name|c
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
operator|*
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
operator|(
name|c
operator|-
literal|'0'
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
return|return
operator|(
name|c
operator|-
literal|'a'
operator|+
operator|(
operator|(
name|char
operator|)
literal|10
operator|)
operator|)
return|;
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
return|return
operator|(
name|c
operator|-
literal|'A'
operator|+
operator|(
operator|(
name|char
operator|)
literal|10
operator|)
operator|)
return|;
comment|/* Not valid ! */
operator|*
name|err
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* BOGUS */
block|}
end_function

begin_comment
comment|/*  * Check to see if NFSERR_MOVED can be returned for this op. Return 1 iff  * it can be.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_errmoved
parameter_list|(
name|int
name|op
parameter_list|)
block|{
name|short
modifier|*
name|errp
decl_stmt|;
name|errp
operator|=
name|nfsrv_v4errmap
index|[
name|op
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|errp
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|errp
operator|==
name|NFSERR_MOVED
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|errp
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in attributes for a Referral.  * (Return the number of bytes of XDR created.)  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_putreferralattr
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|nfsattrbit_t
modifier|*
name|retbitp
parameter_list|,
name|struct
name|nfsreferral
modifier|*
name|refp
parameter_list|,
name|int
name|getattr
parameter_list|,
name|int
modifier|*
name|reterrp
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|tl
decl_stmt|,
modifier|*
name|retnump
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|prefixnum
decl_stmt|,
name|retnum
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|bitpos
decl_stmt|,
name|rderrbit
init|=
literal|0
decl_stmt|,
name|nonrefbit
init|=
literal|0
decl_stmt|;
name|int
name|fslocationsbit
init|=
literal|0
decl_stmt|;
name|nfsattrbit_t
name|tmpbits
decl_stmt|,
name|refbits
decl_stmt|;
name|NFSREFERRAL_ATTRBIT
argument_list|(
operator|&
name|refbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|getattr
condition|)
name|NFSCLRBIT_ATTRBIT
argument_list|(
operator|&
name|refbits
argument_list|,
name|NFSATTRBIT_RDATTRERROR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|retbitp
argument_list|,
name|NFSATTRBIT_RDATTRERROR
argument_list|)
condition|)
name|rderrbit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
name|retbitp
argument_list|,
name|NFSATTRBIT_FSLOCATIONS
argument_list|)
condition|)
name|fslocationsbit
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Check for the case where unsupported referral attributes are 	 * requested. 	 */
name|NFSSET_ATTRBIT
argument_list|(
operator|&
name|tmpbits
argument_list|,
name|retbitp
argument_list|)
expr_stmt|;
name|NFSCLRALL_ATTRBIT
argument_list|(
operator|&
name|tmpbits
argument_list|,
operator|&
name|refbits
argument_list|)
expr_stmt|;
if|if
condition|(
name|NFSNONZERO_ATTRBIT
argument_list|(
operator|&
name|tmpbits
argument_list|)
condition|)
name|nonrefbit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nonrefbit
operator|&&
operator|!
name|fslocationsbit
operator|&&
operator|(
name|getattr
operator|||
operator|!
name|rderrbit
operator|)
condition|)
block|{
operator|*
name|reterrp
operator|=
name|NFSERR_MOVED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now we can fill in the attributes. 	 */
name|NFSSET_ATTRBIT
argument_list|(
operator|&
name|tmpbits
argument_list|,
name|retbitp
argument_list|)
expr_stmt|;
name|NFSCLRNOT_ATTRBIT
argument_list|(
operator|&
name|tmpbits
argument_list|,
operator|&
name|refbits
argument_list|)
expr_stmt|;
comment|/* 	 * Put out the attribute bitmap for the ones being filled in 	 * and get the field for the number of attributes returned. 	 */
name|prefixnum
operator|=
name|nfsrv_putattrbit
argument_list|(
name|nd
argument_list|,
operator|&
name|tmpbits
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|retnump
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|prefixnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
comment|/* 	 * Now, loop around filling in the attributes for each bit set. 	 */
for|for
control|(
name|bitpos
operator|=
literal|0
init|;
name|bitpos
operator|<
name|NFSATTRBIT_MAX
condition|;
name|bitpos
operator|++
control|)
block|{
if|if
condition|(
name|NFSISSET_ATTRBIT
argument_list|(
operator|&
name|tmpbits
argument_list|,
name|bitpos
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|bitpos
condition|)
block|{
case|case
name|NFSATTRBIT_TYPE
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFDIR
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FSID
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_V4FSID
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4ROOT_FSID0
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSV4ROOT_REFERRAL
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_V4FSID
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_RDATTRERROR
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|nonrefbit
condition|)
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|NFSERR_MOVED
argument_list|)
expr_stmt|;
else|else
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
break|break;
case|case
name|NFSATTRBIT_FSLOCATIONS
case|:
name|retnum
operator|+=
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
name|refp
operator|->
name|nfr_srvcnt
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
name|cp
operator|=
name|refp
operator|->
name|nfr_srvlist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|refp
operator|->
name|nfr_srvcnt
condition|;
name|i
operator|++
control|)
block|{
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
name|txdr_unsigned
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_UNSIGNED
expr_stmt|;
name|cp2
operator|=
name|STRCHR
argument_list|(
name|cp
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp2
operator|!=
name|NULL
condition|)
name|len
operator|=
name|cp2
operator|-
name|cp
expr_stmt|;
else|else
name|len
operator|=
literal|1
expr_stmt|;
name|retnum
operator|+=
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp2
operator|!=
name|NULL
condition|)
name|cp
operator|=
name|cp2
operator|+
literal|1
expr_stmt|;
name|cp2
operator|=
name|STRCHR
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp2
operator|!=
name|NULL
condition|)
name|len
operator|=
name|cp2
operator|-
name|cp
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|nfsm_strtom
argument_list|(
name|nd
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp2
operator|!=
name|NULL
condition|)
name|cp
operator|=
name|cp2
operator|+
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|NFSATTRBIT_MOUNTEDONFILEID
case|:
name|NFSM_BUILD
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_HYPER
argument_list|)
expr_stmt|;
name|txdr_hyper
argument_list|(
name|refp
operator|->
name|nfr_dfileno
argument_list|,
name|tl
argument_list|)
expr_stmt|;
name|retnum
operator|+=
name|NFSX_HYPER
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"EEK! Bad V4 refattr bitpos=%d\n"
argument_list|,
name|bitpos
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|retnump
operator|=
name|txdr_unsigned
argument_list|(
name|retnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|retnum
operator|+
name|prefixnum
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a file name out of a request.  */
end_comment

begin_function
name|APPLESTATIC
name|int
name|nfsrv_parsename
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|char
modifier|*
name|bufp
parameter_list|,
name|u_long
modifier|*
name|hashp
parameter_list|,
name|NFSPATHLEN_T
modifier|*
name|outlenp
parameter_list|)
block|{
name|char
modifier|*
name|fromcp
decl_stmt|,
modifier|*
name|tocp
decl_stmt|,
name|val
init|=
literal|'\0'
decl_stmt|;
name|mbuf_t
name|md
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|rem
decl_stmt|,
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|pubtype
init|=
literal|0
decl_stmt|,
name|outlen
init|=
literal|0
decl_stmt|,
name|percent
init|=
literal|0
decl_stmt|;
name|char
name|digit
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|u_long
name|hash
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hashp
operator|!=
name|NULL
condition|)
operator|*
name|hashp
operator|=
literal|0
expr_stmt|;
name|tocp
operator|=
name|bufp
expr_stmt|;
comment|/* 	 * For V4, check for lookup parent. 	 * Otherwise, get the component name. 	 */
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
operator|)
operator|&&
name|nd
operator|->
name|nd_procnum
operator|==
name|NFSV4OP_LOOKUPP
condition|)
block|{
operator|*
name|tocp
operator|++
operator|=
literal|'.'
expr_stmt|;
name|hash
operator|+=
operator|(
operator|(
name|u_char
operator|)
literal|'.'
operator|)
expr_stmt|;
operator|*
name|tocp
operator|++
operator|=
literal|'.'
expr_stmt|;
name|hash
operator|+=
operator|(
operator|(
name|u_char
operator|)
literal|'.'
operator|)
expr_stmt|;
name|outlen
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * First, get the name length. 	     */
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|len
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|NFS_MAXNAMLEN
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_NAMETOL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_INVAL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
comment|/* 	     * Now, copy the component name into the buffer. 	     */
name|fromcp
operator|=
name|nd
operator|->
name|nd_dpos
expr_stmt|;
name|md
operator|=
name|nd
operator|->
name|nd_md
expr_stmt|;
name|rem
operator|=
name|NFSMTOD
argument_list|(
name|md
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mbuf_len
argument_list|(
name|md
argument_list|)
operator|-
name|fromcp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|rem
operator|==
literal|0
condition|)
block|{
name|md
operator|=
name|mbuf_next
argument_list|(
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|fromcp
operator|=
name|NFSMTOD
argument_list|(
name|md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|rem
operator|=
name|mbuf_len
argument_list|(
name|md
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|fromcp
operator|==
literal|'\0'
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|EACCES
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
comment|/* 		 * For lookups on the public filehandle, do some special 		 * processing on the name. (The public file handle is the 		 * root of the public file system for this server.) 		 */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_PUBLOOKUP
condition|)
block|{
comment|/* 			 * If the first char is ASCII, it is a canonical 			 * path, otherwise it is a native path. (RFC2054 			 * doesn't actually state what it is if the first 			 * char isn't ASCII or 0x80, so I assume native.) 			 * pubtype == 1 -> native path 			 * pubtype == 2 -> canonical path 			 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|fromcp
operator|&
literal|0x80
condition|)
block|{
comment|/* 					 * Since RFC2054 doesn't indicate 					 * that a native path of just 0x80 					 * isn't allowed, I'll replace the 					 * 0x80 with '/' instead of just 					 * throwing it away. 					 */
operator|*
name|fromcp
operator|=
literal|'/'
expr_stmt|;
name|pubtype
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pubtype
operator|=
literal|2
expr_stmt|;
block|}
block|}
comment|/* 			 * '/' only allowed in a native path 			 */
if|if
condition|(
operator|*
name|fromcp
operator|==
literal|'/'
operator|&&
name|pubtype
operator|!=
literal|1
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|EACCES
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
comment|/* 			 * For the special case of 2 hex digits after a 			 * '%' in an absolute path, calculate the value. 			 * percent == 1 -> indicates "get first hex digit" 			 * percent == 2 -> indicates "get second hex digit" 			 */
if|if
condition|(
name|percent
operator|>
literal|0
condition|)
block|{
name|digit
operator|=
name|nfsrv_hexdigit
argument_list|(
operator|*
name|fromcp
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|EACCES
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|percent
operator|==
literal|1
condition|)
block|{
name|val
operator|=
operator|(
name|digit
operator|<<
literal|4
operator|)
expr_stmt|;
name|percent
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|val
operator|+=
name|digit
expr_stmt|;
name|percent
operator|=
literal|0
expr_stmt|;
operator|*
name|tocp
operator|++
operator|=
name|val
expr_stmt|;
name|hash
operator|+=
operator|(
operator|(
name|u_char
operator|)
name|val
operator|)
expr_stmt|;
name|outlen
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|fromcp
operator|==
literal|'%'
operator|&&
name|pubtype
operator|==
literal|2
condition|)
block|{
comment|/* 					 * Must be followed by 2 hex digits 					 */
if|if
condition|(
operator|(
name|len
operator|-
name|i
operator|)
operator|<
literal|3
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|EACCES
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|percent
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|tocp
operator|++
operator|=
operator|*
name|fromcp
expr_stmt|;
name|hash
operator|+=
operator|(
operator|(
name|u_char
operator|)
operator|*
name|fromcp
operator|)
expr_stmt|;
name|outlen
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * Normal, non lookup on public, name. 			 */
if|if
condition|(
operator|*
name|fromcp
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_BADNAME
expr_stmt|;
else|else
name|nd
operator|->
name|nd_repstat
operator|=
name|EACCES
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
name|hash
operator|+=
operator|(
operator|(
name|u_char
operator|)
operator|*
name|fromcp
operator|)
expr_stmt|;
operator|*
name|tocp
operator|++
operator|=
operator|*
name|fromcp
expr_stmt|;
name|outlen
operator|++
expr_stmt|;
block|}
name|fromcp
operator|++
expr_stmt|;
name|rem
operator|--
expr_stmt|;
block|}
name|nd
operator|->
name|nd_md
operator|=
name|md
expr_stmt|;
name|nd
operator|->
name|nd_dpos
operator|=
name|fromcp
expr_stmt|;
name|i
operator|=
name|NFSM_RNDUP
argument_list|(
name|len
argument_list|)
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rem
operator|>=
name|i
condition|)
block|{
name|nd
operator|->
name|nd_dpos
operator|+=
name|i
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|nfsm_advance
argument_list|(
name|nd
argument_list|,
name|i
argument_list|,
name|rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|nfsmout
goto|;
block|}
block|}
comment|/* 	     * For v4, don't allow lookups of '.' or '..' and 	     * also check for non-utf8 strings. 	     */
if|if
condition|(
name|nd
operator|->
name|nd_flag
operator|&
name|ND_NFSV4
condition|)
block|{
if|if
condition|(
operator|(
name|outlen
operator|==
literal|1
operator|&&
name|bufp
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|||
operator|(
name|outlen
operator|==
literal|2
operator|&&
name|bufp
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|bufp
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_BADNAME
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|enable_checkutf8
operator|==
literal|1
operator|&&
name|nfsrv_checkutf8
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|bufp
argument_list|,
name|outlen
argument_list|)
condition|)
block|{
name|nd
operator|->
name|nd_repstat
operator|=
name|NFSERR_INVAL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
block|}
block|}
operator|*
name|tocp
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|outlenp
operator|=
operator|(
name|size_t
operator|)
name|outlen
expr_stmt|;
if|if
condition|(
name|hashp
operator|!=
name|NULL
condition|)
operator|*
name|hashp
operator|=
name|hash
expr_stmt|;
name|nfsmout
label|:
name|NFSEXITCODE2
argument_list|(
name|error
argument_list|,
name|nd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nfsd_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inited
condition|)
return|return;
name|inited
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Initialize client queues. Don't free/reinitialize 	 * them when nfsds are restarted. 	 */
name|nfsclienthash
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfsclienthashhead
argument_list|)
operator|*
name|nfsrv_clienthashsize
argument_list|,
name|M_NFSDCLIENT
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_clienthashsize
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|nfsclienthash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nfslockhash
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfslockhashhead
argument_list|)
operator|*
name|nfsrv_lockhashsize
argument_list|,
name|M_NFSDLOCKFILE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_lockhashsize
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|nfslockhash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|nfssessionhash
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nfssessionhash
argument_list|)
operator|*
name|nfsrv_sessionhashsize
argument_list|,
name|M_NFSDSESSION
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfsrv_sessionhashsize
condition|;
name|i
operator|++
control|)
block|{
name|mtx_init
argument_list|(
operator|&
name|nfssessionhash
index|[
name|i
index|]
operator|.
name|mtx
argument_list|,
literal|"nfssm"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|nfssessionhash
index|[
name|i
index|]
operator|.
name|list
argument_list|)
expr_stmt|;
block|}
comment|/* and the v2 pubfh should be all zeros */
name|NFSBZERO
argument_list|(
name|nfs_v2pubfh
argument_list|,
name|NFSX_V2FH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check the v4 root exports.  * Return 0 if ok, 1 otherwise.  */
end_comment

begin_function
name|int
name|nfsd_checkrootexp
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|)
block|{
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_GSS
operator||
name|ND_EXAUTHSYS
operator|)
operator|)
operator|==
name|ND_EXAUTHSYS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_GSSINTEGRITY
operator||
name|ND_EXGSSINTEGRITY
operator|)
operator|)
operator|==
operator|(
name|ND_GSSINTEGRITY
operator||
name|ND_EXGSSINTEGRITY
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_GSSPRIVACY
operator||
name|ND_EXGSSPRIVACY
operator|)
operator|)
operator|==
operator|(
name|ND_GSSPRIVACY
operator||
name|ND_EXGSSPRIVACY
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|nd
operator|->
name|nd_flag
operator|&
operator|(
name|ND_GSS
operator||
name|ND_GSSINTEGRITY
operator||
name|ND_GSSPRIVACY
operator||
name|ND_EXGSS
operator|)
operator|)
operator|==
operator|(
name|ND_GSS
operator||
name|ND_EXGSS
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the first part of an NFSv4 compound to find out what the minor  * version# is.  */
end_comment

begin_function
name|void
name|nfsd_getminorvers
parameter_list|(
name|struct
name|nfsrv_descript
modifier|*
name|nd
parameter_list|,
name|u_char
modifier|*
name|tag
parameter_list|,
name|u_char
modifier|*
modifier|*
name|tagstrp
parameter_list|,
name|int
modifier|*
name|taglenp
parameter_list|,
name|u_int32_t
modifier|*
name|minversp
parameter_list|)
block|{
name|uint32_t
modifier|*
name|tl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|taglen
init|=
operator|-
literal|1
decl_stmt|;
name|u_char
modifier|*
name|tagstr
init|=
name|NULL
decl_stmt|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
name|taglen
operator|=
name|fxdr_unsigned
argument_list|(
name|int
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|taglen
operator|<
literal|0
operator|||
name|taglen
operator|>
name|NFSV4_OPAQUELIMIT
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|nfsmout
goto|;
block|}
if|if
condition|(
name|taglen
operator|<=
name|NFSV4_SMALLSTR
condition|)
name|tagstr
operator|=
name|tag
expr_stmt|;
else|else
name|tagstr
operator|=
name|malloc
argument_list|(
name|taglen
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|nfsrv_mtostr
argument_list|(
name|nd
argument_list|,
name|tagstr
argument_list|,
name|taglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|nfsmout
goto|;
name|NFSM_DISSECT
argument_list|(
name|tl
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|NFSX_UNSIGNED
argument_list|)
expr_stmt|;
operator|*
name|minversp
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
operator|*
name|tagstrp
operator|=
name|tagstr
expr_stmt|;
if|if
condition|(
operator|*
name|minversp
operator|==
name|NFSV41_MINORVERSION
condition|)
name|nd
operator|->
name|nd_flag
operator||=
name|ND_NFSV41
expr_stmt|;
name|nfsmout
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|tagstr
operator|!=
name|NULL
operator|&&
name|taglen
operator|>
name|NFSV4_SMALLSTR
condition|)
name|free
argument_list|(
name|tagstr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|taglen
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
name|taglenp
operator|=
name|taglen
expr_stmt|;
block|}
end_function

end_unit

