begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1984, 1985, 1986, 1987 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)spp_usrreq.c	7.15 (Berkeley) 6/27/91  *	$Id: spp_usrreq.c,v 1.4 1993/11/25 01:36:36 wollman Exp $  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/tcp_fsm.h"
end_include

begin_include
include|#
directive|include
file|"ns.h"
end_include

begin_include
include|#
directive|include
file|"ns_pcb.h"
end_include

begin_include
include|#
directive|include
file|"idp.h"
end_include

begin_include
include|#
directive|include
file|"idp_var.h"
end_include

begin_include
include|#
directive|include
file|"ns_error.h"
end_include

begin_include
include|#
directive|include
file|"sp.h"
end_include

begin_include
include|#
directive|include
file|"spidp.h"
end_include

begin_include
include|#
directive|include
file|"spp_timer.h"
end_include

begin_include
include|#
directive|include
file|"spp_var.h"
end_include

begin_include
include|#
directive|include
file|"spp_debug.h"
end_include

begin_function_decl
specifier|static
name|void
name|spp_quench
parameter_list|(
name|struct
name|nspcb
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spp_abort
parameter_list|(
name|struct
name|nspcb
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spp_setpersist
parameter_list|(
name|struct
name|sppcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spp_template
parameter_list|(
name|struct
name|sppcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|spp_istat
name|spp_istat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|spp_iss
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * SP protocol implementation.  */
end_comment

begin_function
name|void
name|spp_init
parameter_list|()
block|{
name|spp_iss
operator|=
literal|1
expr_stmt|;
comment|/* WRONG !! should fish it out of TODR */
block|}
end_function

begin_decl_stmt
name|struct
name|spidp
name|spp_savesi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|traceallspps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sppconsdebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|spp_hardnosed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|spp_use_delack
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|spp_newchecks
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|spp_input
parameter_list|(
name|m
parameter_list|,
name|nsp
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
block|{
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|struct
name|spidp
modifier|*
name|si
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|short
name|ostate
init|=
literal|0
decl_stmt|;
name|int
name|dropsocket
init|=
literal|0
decl_stmt|;
name|sppstat
operator|.
name|spps_rcvtotal
operator|++
expr_stmt|;
if|if
condition|(
name|nsp
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"No nspcb in spp_input\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cb
operator|=
name|nstosppcb
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|sppstat
operator|.
name|spps_rcvshort
operator|++
expr_stmt|;
return|return;
block|}
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
block|}
name|si
operator|->
name|si_seq
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_ack
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_alo
argument_list|)
expr_stmt|;
name|so
operator|=
name|nsp
operator|->
name|nsp_socket
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
block|{
name|ostate
operator|=
name|cb
operator|->
name|s_state
expr_stmt|;
name|spp_savesi
operator|=
operator|*
name|si
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
block|{
name|struct
name|sppcb
modifier|*
name|ocb
init|=
name|cb
decl_stmt|;
name|so
operator|=
name|sonewconn
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
literal|0
condition|)
block|{
goto|goto
name|drop
goto|;
block|}
comment|/* 		 * This is ugly, but .... 		 * 		 * Mark socket as temporary until we're 		 * committed to keeping it.  The code at 		 * ``drop'' and ``dropwithreset'' check the 		 * flag dropsocket to see if the temporary 		 * socket created here should be discarded. 		 * We mark the socket as discardable until 		 * we're committed to it below in TCPS_LISTEN. 		 */
name|dropsocket
operator|++
expr_stmt|;
name|nsp
operator|=
operator|(
expr|struct
name|nspcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|nsp
operator|->
name|nsp_laddr
operator|=
name|si
operator|->
name|si_dna
expr_stmt|;
name|cb
operator|=
name|nstosppcb
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_mtu
operator|=
name|ocb
operator|->
name|s_mtu
expr_stmt|;
comment|/* preserve sockopts */
name|cb
operator|->
name|s_flags
operator|=
name|ocb
operator|->
name|s_flags
expr_stmt|;
comment|/* preserve sockopts */
name|cb
operator|->
name|s_flags2
operator|=
name|ocb
operator|->
name|s_flags2
expr_stmt|;
comment|/* preserve sockopts */
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
block|}
comment|/* 	 * Packet received on connection. 	 * reset idle time and keep-alive timer; 	 */
name|cb
operator|->
name|s_idle
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPPT_KEEP
index|]
operator|=
name|SPPTV_KEEP
expr_stmt|;
switch|switch
condition|(
name|cb
operator|->
name|s_state
condition|)
block|{
case|case
name|TCPS_LISTEN
case|:
block|{
name|struct
name|mbuf
modifier|*
name|am
decl_stmt|;
specifier|register
name|struct
name|sockaddr_ns
modifier|*
name|sns
decl_stmt|;
name|struct
name|ns_addr
name|laddr
decl_stmt|;
comment|/* 		 * If somebody here was carying on a conversation 		 * and went away, and his pen pal thinks he can 		 * still talk, we get the misdirected packet. 		 */
if|if
condition|(
name|spp_hardnosed
operator|&&
operator|(
name|si
operator|->
name|si_did
operator|!=
literal|0
operator|||
name|si
operator|->
name|si_seq
operator|!=
literal|0
operator|)
condition|)
block|{
name|spp_istat
operator|.
name|gonawy
operator|++
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
name|am
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|am
operator|==
name|NULL
condition|)
goto|goto
name|drop
goto|;
name|am
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ns
argument_list|)
expr_stmt|;
name|sns
operator|=
name|mtod
argument_list|(
name|am
argument_list|,
expr|struct
name|sockaddr_ns
operator|*
argument_list|)
expr_stmt|;
name|sns
operator|->
name|sns_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sns
argument_list|)
expr_stmt|;
name|sns
operator|->
name|sns_family
operator|=
name|AF_NS
expr_stmt|;
name|sns
operator|->
name|sns_addr
operator|=
name|si
operator|->
name|si_sna
expr_stmt|;
name|laddr
operator|=
name|nsp
operator|->
name|nsp_laddr
expr_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
name|laddr
argument_list|)
condition|)
name|nsp
operator|->
name|nsp_laddr
operator|=
name|si
operator|->
name|si_dna
expr_stmt|;
if|if
condition|(
name|ns_pcbconnect
argument_list|(
name|nsp
argument_list|,
name|am
argument_list|)
condition|)
block|{
name|nsp
operator|->
name|nsp_laddr
operator|=
name|laddr
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|am
argument_list|)
expr_stmt|;
name|spp_istat
operator|.
name|noconn
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|am
argument_list|)
expr_stmt|;
name|spp_template
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|dropsocket
operator|=
literal|0
expr_stmt|;
comment|/* committed to socket */
name|cb
operator|->
name|s_did
operator|=
name|si
operator|->
name|si_sid
expr_stmt|;
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
define|#
directive|define
name|THREEWAYSHAKE
ifdef|#
directive|ifdef
name|THREEWAYSHAKE
name|cb
operator|->
name|s_state
operator|=
name|TCPS_SYN_RECEIVED
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|SPPT_KEEP
expr_stmt|;
name|sppstat
operator|.
name|spps_accepts
operator|++
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPPT_KEEP
index|]
operator|=
name|SPPTV_KEEP
expr_stmt|;
block|}
break|break;
comment|/* 	 * This state means that we have heard a response 	 * to our acceptance of their connection 	 * It is probably logically unnecessary in this 	 * implementation. 	 */
case|case
name|TCPS_SYN_RECEIVED
case|:
block|{
if|if
condition|(
name|si
operator|->
name|si_did
operator|!=
name|cb
operator|->
name|s_sid
condition|)
block|{
name|spp_istat
operator|.
name|wrncon
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
endif|#
directive|endif
name|nsp
operator|->
name|nsp_fport
operator|=
name|si
operator|->
name|si_sport
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPPT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPPT_KEEP
index|]
operator|=
name|SPPTV_KEEP
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
name|sppstat
operator|.
name|spps_accepts
operator|++
expr_stmt|;
block|}
break|break;
comment|/* 	 * This state means that we have gotten a response 	 * to our attempt to establish a connection. 	 * We fill in the data from the other side, 	 * telling us which port to respond to, instead of the well- 	 * known one we might have sent to in the first place. 	 * We also require that this is a response to our 	 * connection id. 	 */
case|case
name|TCPS_SYN_SENT
case|:
if|if
condition|(
name|si
operator|->
name|si_did
operator|!=
name|cb
operator|->
name|s_sid
condition|)
block|{
name|spp_istat
operator|.
name|notme
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|sppstat
operator|.
name|spps_connects
operator|++
expr_stmt|;
name|cb
operator|->
name|s_did
operator|=
name|si
operator|->
name|si_sid
expr_stmt|;
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
name|cb
operator|->
name|s_dport
operator|=
name|nsp
operator|->
name|nsp_fport
operator|=
name|si
operator|->
name|si_sport
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPPT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_ACKNOW
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
comment|/* Use roundtrip time of connection request for initial rtt */
if|if
condition|(
name|cb
operator|->
name|s_rtt
condition|)
block|{
name|cb
operator|->
name|s_srtt
operator|=
name|cb
operator|->
name|s_rtt
operator|<<
literal|3
expr_stmt|;
name|cb
operator|->
name|s_rttvar
operator|=
name|cb
operator|->
name|s_rtt
operator|<<
literal|1
expr_stmt|;
name|SPPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_rxtcur
argument_list|,
operator|(
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
operator|+
name|cb
operator|->
name|s_rttvar
operator|)
operator|>>
literal|1
argument_list|,
name|SPPTV_MIN
argument_list|,
name|SPPTV_REXMTMAX
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_INPUT
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spp_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|idp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|idp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|idp
argument_list|)
expr_stmt|;
if|if
condition|(
name|spp_reass
argument_list|(
name|cb
argument_list|,
name|si
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|s_force
operator|||
operator|(
name|cb
operator|->
name|s_flags
operator|&
operator|(
name|SF_ACKNOW
operator||
name|SF_WIN
operator||
name|SF_RXT
operator|)
operator|)
condition|)
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_flags
operator|&=
operator|~
operator|(
name|SF_WIN
operator||
name|SF_RXT
operator|)
expr_stmt|;
return|return;
name|dropwithreset
label|:
if|if
condition|(
name|dropsocket
condition|)
operator|(
name|void
operator|)
name|soabort
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_seq
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_ack
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_alo
argument_list|)
expr_stmt|;
name|ns_error
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|,
name|NS_ERR_NOSOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_DROP
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spp_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
name|drop
label|:
name|bad
label|:
if|if
condition|(
name|cb
operator|==
literal|0
operator|||
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_DROP
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spp_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|spprexmtthresh
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is structurally similar to the tcp reassembly routine  * but its function is somewhat different:  It merely queues  * packets up, and suppresses duplicates.  */
end_comment

begin_function
name|int
name|spp_reass
parameter_list|(
name|cb
parameter_list|,
name|si
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|struct
name|spidp
modifier|*
name|si
decl_stmt|;
block|{
specifier|register
name|struct
name|spidp_q
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
decl_stmt|;
name|char
name|packetp
init|=
name|cb
operator|->
name|s_flags
operator|&
name|SF_HI
decl_stmt|;
name|int
name|incr
decl_stmt|;
name|char
name|wakeup
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|si
operator|==
name|SI
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|present
goto|;
comment|/* 	 * Update our news from them. 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SP_SA
condition|)
name|cb
operator|->
name|s_flags
operator||=
operator|(
name|spp_use_delack
condition|?
name|SF_DELACK
else|:
name|SF_ACKNOW
operator|)
expr_stmt|;
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_alo
argument_list|,
name|cb
operator|->
name|s_ralo
argument_list|)
condition|)
name|cb
operator|->
name|s_flags
operator||=
name|SF_WIN
expr_stmt|;
if|if
condition|(
name|SSEQ_LEQ
argument_list|(
name|si
operator|->
name|si_ack
argument_list|,
name|cb
operator|->
name|s_rack
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SP_SP
operator|)
operator|&&
name|cb
operator|->
name|s_rack
operator|!=
operator|(
name|cb
operator|->
name|s_smax
operator|+
literal|1
operator|)
condition|)
block|{
name|sppstat
operator|.
name|spps_rcvdupack
operator|++
expr_stmt|;
comment|/* 			 * If this is a completely duplicate ack 			 * and other conditions hold, we assume 			 * a packet has been dropped and retransmit 			 * it exactly as in tcp_input(). 			 */
if|if
condition|(
name|si
operator|->
name|si_ack
operator|!=
name|cb
operator|->
name|s_rack
operator|||
name|si
operator|->
name|si_alo
operator|!=
name|cb
operator|->
name|s_ralo
condition|)
name|cb
operator|->
name|s_dupacks
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|cb
operator|->
name|s_dupacks
operator|==
name|spprexmtthresh
condition|)
block|{
name|u_short
name|onxt
init|=
name|cb
operator|->
name|s_snxt
decl_stmt|;
name|int
name|cwnd
init|=
name|cb
operator|->
name|s_cwnd
decl_stmt|;
name|cb
operator|->
name|s_snxt
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
name|CUNIT
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|SPPT_REXMT
expr_stmt|;
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPPT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cwnd
operator|>=
literal|4
operator|*
name|CUNIT
condition|)
name|cb
operator|->
name|s_cwnd
operator|=
name|cwnd
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|onxt
argument_list|,
name|cb
operator|->
name|s_snxt
argument_list|)
condition|)
name|cb
operator|->
name|s_snxt
operator|=
name|onxt
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
name|cb
operator|->
name|s_dupacks
operator|=
literal|0
expr_stmt|;
goto|goto
name|update_window
goto|;
block|}
name|cb
operator|->
name|s_dupacks
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If our correspondent acknowledges data we haven't sent 	 * TCP would drop the packet after acking.  We'll be a little 	 * more permissive 	 */
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_ack
argument_list|,
operator|(
name|cb
operator|->
name|s_smax
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|sppstat
operator|.
name|spps_rcvacktoomuch
operator|++
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|cb
operator|->
name|s_smax
operator|+
literal|1
expr_stmt|;
block|}
name|sppstat
operator|.
name|spps_rcvackpack
operator|++
expr_stmt|;
comment|/* 	 * If transmit timer is running and timed sequence 	 * number was acked, update smoothed round trip time. 	 * See discussion of algorithm in tcp_input.c 	 */
if|if
condition|(
name|cb
operator|->
name|s_rtt
operator|&&
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_ack
argument_list|,
name|cb
operator|->
name|s_rtseq
argument_list|)
condition|)
block|{
name|sppstat
operator|.
name|spps_rttupdated
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_srtt
operator|!=
literal|0
condition|)
block|{
specifier|register
name|short
name|delta
decl_stmt|;
name|delta
operator|=
name|cb
operator|->
name|s_rtt
operator|-
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|3
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_srtt
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|cb
operator|->
name|s_srtt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
name|delta
operator|-=
operator|(
name|cb
operator|->
name|s_rttvar
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_rttvar
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|cb
operator|->
name|s_rttvar
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * No rtt measurement yet 			 */
name|cb
operator|->
name|s_srtt
operator|=
name|cb
operator|->
name|s_rtt
operator|<<
literal|3
expr_stmt|;
name|cb
operator|->
name|s_rttvar
operator|=
name|cb
operator|->
name|s_rtt
operator|<<
literal|1
expr_stmt|;
block|}
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
name|SPPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_rxtcur
argument_list|,
operator|(
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
operator|+
name|cb
operator|->
name|s_rttvar
operator|)
operator|>>
literal|1
argument_list|,
name|SPPTV_MIN
argument_list|,
name|SPPTV_REXMTMAX
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If all outstanding data is acked, stop retransmit 	 * timer and remember to restart (more output or persist). 	 * If there is more data to be acked, restart retransmit 	 * timer, using current (possibly backed-off) value; 	 */
if|if
condition|(
name|si
operator|->
name|si_ack
operator|==
name|cb
operator|->
name|s_smax
operator|+
literal|1
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPPT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_RXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPPT_PERSIST
index|]
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_timer
index|[
name|SPPT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
comment|/* 	 * When new data is acked, open the congestion window. 	 * If the window gives us less than ssthresh packets 	 * in flight, open exponentially (maxseg at a time). 	 * Otherwise open linearly (maxseg^2 / cwnd at a time). 	 */
name|incr
operator|=
name|CUNIT
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_cwnd
operator|>
name|cb
operator|->
name|s_ssthresh
condition|)
name|incr
operator|=
name|max
argument_list|(
name|incr
operator|*
name|incr
operator|/
name|cb
operator|->
name|s_cwnd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
name|min
argument_list|(
name|cb
operator|->
name|s_cwnd
operator|+
name|incr
argument_list|,
name|cb
operator|->
name|s_cwmx
argument_list|)
expr_stmt|;
comment|/* 	 * Trim Acked data from output queue. 	 */
while|while
condition|(
operator|(
name|m
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_mb
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SSEQ_LT
argument_list|(
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
operator|)
operator|->
name|si_seq
argument_list|,
name|si
operator|->
name|si_ack
argument_list|)
condition|)
name|sbdroprecord
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|sowwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|update_window
label|:
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_snxt
argument_list|,
name|cb
operator|->
name|s_rack
argument_list|)
condition|)
name|cb
operator|->
name|s_snxt
operator|=
name|cb
operator|->
name|s_rack
expr_stmt|;
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_swl1
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
operator|||
name|cb
operator|->
name|s_swl1
operator|==
name|si
operator|->
name|si_seq
operator|&&
operator|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_swl2
argument_list|,
name|si
operator|->
name|si_ack
argument_list|)
operator|||
name|cb
operator|->
name|s_swl2
operator|==
name|si
operator|->
name|si_ack
operator|&&
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_ralo
argument_list|,
name|si
operator|->
name|si_alo
argument_list|)
operator|)
condition|)
block|{
comment|/* keep track of pure window updates */
if|if
condition|(
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SP_SP
operator|)
operator|&&
name|cb
operator|->
name|s_swl2
operator|==
name|si
operator|->
name|si_ack
operator|&&
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_ralo
argument_list|,
name|si
operator|->
name|si_alo
argument_list|)
condition|)
block|{
name|sppstat
operator|.
name|spps_rcvwinupd
operator|++
expr_stmt|;
name|sppstat
operator|.
name|spps_rcvdupack
operator|--
expr_stmt|;
block|}
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
name|cb
operator|->
name|s_swl1
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
name|cb
operator|->
name|s_swl2
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_swnd
operator|=
operator|(
literal|1
operator|+
name|si
operator|->
name|si_alo
operator|-
name|si
operator|->
name|si_ack
operator|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_swnd
operator|>
name|cb
operator|->
name|s_smxw
condition|)
name|cb
operator|->
name|s_smxw
operator|=
name|cb
operator|->
name|s_swnd
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_WIN
expr_stmt|;
block|}
comment|/* 	 * If this packet number is higher than that which 	 * we have allocated refuse it, unless urgent 	 */
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_alo
argument_list|)
condition|)
block|{
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SP_SP
condition|)
block|{
name|sppstat
operator|.
name|spps_rcvwinprobe
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|sppstat
operator|.
name|spps_rcvpackafterwin
operator|++
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SP_OB
condition|)
block|{
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_alo
operator|+
literal|60
argument_list|)
condition|)
block|{
name|ns_error
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|,
name|NS_ERR_FULLUP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* else queue this packet; */
block|}
else|else
block|{
comment|/*register struct socket *so = cb->s_nspcb->nsp_socket; 			if (so->so_state&& SS_NOFDREF) { 				ns_error(dtom(si), NS_ERR_NOSOCK, 0); 				(void)spp_close(cb); 			} else 				       would crash system*/
name|spp_istat
operator|.
name|notyet
operator|++
expr_stmt|;
name|ns_error
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|,
name|NS_ERR_FULLUP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * If this is a system packet, we don't need to 	 * queue it up, and won't update acknowledge # 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SP_SP
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * We have already seen this packet, so drop. 	 */
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_ack
argument_list|)
condition|)
block|{
name|spp_istat
operator|.
name|bdreas
operator|++
expr_stmt|;
name|sppstat
operator|.
name|spps_rcvduppack
operator|++
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|cb
operator|->
name|s_ack
operator|-
literal|1
condition|)
name|spp_istat
operator|.
name|lstdup
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Loop through all packets queued up to insert in 	 * appropriate sequence. 	 */
for|for
control|(
name|q
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
init|;
name|q
operator|!=
operator|&
name|cb
operator|->
name|s_q
condition|;
name|q
operator|=
name|q
operator|->
name|si_next
control|)
block|{
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
condition|)
block|{
name|sppstat
operator|.
name|spps_rcvduppack
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
argument_list|)
condition|)
block|{
name|sppstat
operator|.
name|spps_rcvoopack
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|insque
argument_list|(
name|si
argument_list|,
name|q
operator|->
name|si_prev
argument_list|)
expr_stmt|;
comment|/* 	 * If this packet is urgent, inform process 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SP_OB
condition|)
block|{
name|cb
operator|->
name|s_iobc
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|si
operator|)
index|[
literal|1
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
index|]
expr_stmt|;
name|sohasoutofband
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_oobflags
operator||=
name|SF_IOOB
expr_stmt|;
block|}
name|present
label|:
define|#
directive|define
name|SPINC
value|sizeof(struct sphdr)
comment|/* 	 * Loop through all packets queued up to update acknowledge 	 * number, and present all acknowledged data to user; 	 * If in packet interface mode, show packet headers. 	 */
for|for
control|(
name|q
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
init|;
name|q
operator|!=
operator|&
name|cb
operator|->
name|s_q
condition|;
name|q
operator|=
name|q
operator|->
name|si_next
control|)
block|{
if|if
condition|(
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
operator|==
name|cb
operator|->
name|s_ack
condition|)
block|{
name|cb
operator|->
name|s_ack
operator|++
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_cc
operator|&
name|SP_OB
condition|)
block|{
name|cb
operator|->
name|s_oobflags
operator|&=
operator|~
name|SF_IOOB
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
condition|)
name|so
operator|->
name|so_oobmark
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
else|else
name|so
operator|->
name|so_state
operator||=
name|SS_RCVATMARK
expr_stmt|;
block|}
name|q
operator|=
name|q
operator|->
name|si_prev
expr_stmt|;
name|remque
argument_list|(
name|q
operator|->
name|si_next
argument_list|)
expr_stmt|;
name|wakeup
operator|=
literal|1
expr_stmt|;
name|sppstat
operator|.
name|spps_rcvpack
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SF_NEWCALL
if|if
condition|(
name|cb
operator|->
name|s_flags2
operator|&
name|SF_NEWCALL
condition|)
block|{
name|struct
name|sphdr
modifier|*
name|sp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
decl_stmt|;
name|u_char
name|dt
init|=
name|sp
operator|->
name|sp_dt
decl_stmt|;
name|spp_newchecks
index|[
literal|4
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|dt
operator|!=
name|cb
operator|->
name|s_rhdr
operator|.
name|sp_dt
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mm
init|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_CONTROL
argument_list|)
decl_stmt|;
name|spp_newchecks
index|[
literal|0
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|mm
operator|!=
name|NULL
condition|)
block|{
name|u_short
modifier|*
name|s
init|=
name|mtod
argument_list|(
name|mm
argument_list|,
name|u_short
operator|*
argument_list|)
decl_stmt|;
name|cb
operator|->
name|s_rhdr
operator|.
name|sp_dt
operator|=
name|dt
expr_stmt|;
name|mm
operator|->
name|m_len
operator|=
literal|5
expr_stmt|;
comment|/*XXX*/
name|s
index|[
literal|0
index|]
operator|=
literal|5
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|s
index|[
literal|2
index|]
operator|)
operator|=
name|dt
expr_stmt|;
name|sbappend
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|mm
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|sp_cc
operator|&
name|SP_OB
condition|)
block|{
name|MCHTYPE
argument_list|(
name|m
argument_list|,
name|MT_OOBDATA
argument_list|)
expr_stmt|;
name|spp_newchecks
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|so
operator|->
name|so_oobmark
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_RCVATMARK
expr_stmt|;
block|}
if|if
condition|(
name|packetp
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|m_data
operator|+=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|SPINC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|sp_cc
operator|&
name|SP_EM
operator|)
operator|||
name|packetp
condition|)
block|{
name|sbappendrecord
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|spp_newchecks
index|[
literal|9
index|]
operator|++
expr_stmt|;
block|}
else|else
name|sbappend
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|packetp
condition|)
block|{
name|sbappendrecord
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|s_rhdr
operator|=
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|SPINC
expr_stmt|;
name|sbappend
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|wakeup
condition|)
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spp_ctlinput
parameter_list|(
name|cmd
parameter_list|,
name|arg
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|arg
decl_stmt|;
block|{
name|struct
name|ns_addr
modifier|*
name|na
decl_stmt|;
name|struct
name|ns_errp
modifier|*
name|errp
init|=
literal|0
decl_stmt|;
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
name|struct
name|sockaddr_ns
modifier|*
name|sns
decl_stmt|;
name|int
name|type
decl_stmt|;
if|if
condition|(
name|cmd
operator|<
literal|0
operator|||
name|cmd
operator|>
name|PRC_NCMDS
condition|)
return|return;
name|type
operator|=
name|NS_ERR_UNREACH_HOST
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_ROUTEDEAD
case|:
return|return;
case|case
name|PRC_IFDOWN
case|:
case|case
name|PRC_HOSTDEAD
case|:
case|case
name|PRC_HOSTUNREACH
case|:
name|sns
operator|=
operator|(
expr|struct
name|sockaddr_ns
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sns
operator|->
name|sns_family
operator|!=
name|AF_NS
condition|)
return|return;
name|na
operator|=
operator|&
name|sns
operator|->
name|sns_addr
expr_stmt|;
break|break;
default|default:
name|errp
operator|=
operator|(
expr|struct
name|ns_errp
operator|*
operator|)
name|arg
expr_stmt|;
name|na
operator|=
operator|&
name|errp
operator|->
name|ns_err_idp
operator|.
name|idp_dna
expr_stmt|;
name|type
operator|=
name|errp
operator|->
name|ns_err_num
expr_stmt|;
name|type
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|type
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|NS_ERR_UNREACH_HOST
case|:
name|ns_pcbnotify
argument_list|(
name|na
argument_list|,
operator|(
name|int
operator|)
name|nsctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|spp_abort
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_ERR_TOO_BIG
case|:
case|case
name|NS_ERR_NOSOCK
case|:
name|nsp
operator|=
name|ns_pcblookup
argument_list|(
name|na
argument_list|,
name|errp
operator|->
name|ns_err_idp
operator|.
name|idp_sna
operator|.
name|x_port
argument_list|,
name|NS_WILDCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsp
condition|)
block|{
if|if
condition|(
name|nsp
operator|->
name|nsp_pcb
condition|)
operator|(
name|void
operator|)
name|spp_drop
argument_list|(
operator|(
expr|struct
name|sppcb
operator|*
operator|)
name|nsp
operator|->
name|nsp_pcb
argument_list|,
operator|(
name|int
operator|)
name|nsctlerrmap
index|[
name|cmd
index|]
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|idp_drop
argument_list|(
name|nsp
argument_list|,
operator|(
name|int
operator|)
name|nsctlerrmap
index|[
name|cmd
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NS_ERR_FULLUP
case|:
name|ns_pcbnotify
argument_list|(
name|na
argument_list|,
literal|0
argument_list|,
name|spp_quench
argument_list|,
operator|(
name|long
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * When a source quench is received, close congestion window  * to one packet.  We will gradually open it again as we proceed.  */
end_comment

begin_function
specifier|static
name|void
name|spp_quench
parameter_list|(
name|nsp
parameter_list|,
name|errno
parameter_list|)
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
name|int
name|errno
decl_stmt|;
block|{
name|struct
name|sppcb
modifier|*
name|cb
init|=
name|nstosppcb
argument_list|(
name|nsp
argument_list|)
decl_stmt|;
if|if
condition|(
name|cb
condition|)
name|cb
operator|->
name|s_cwnd
operator|=
name|CUNIT
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_function
name|int
name|spp_fixmtu
parameter_list|(
name|nsp
parameter_list|)
specifier|register
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
block|{
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
init|=
operator|(
expr|struct
name|sppcb
operator|*
operator|)
operator|(
name|nsp
operator|->
name|nsp_pcb
operator|)
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|spidp
modifier|*
name|si
decl_stmt|;
name|struct
name|ns_errp
modifier|*
name|ep
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|badseq
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|firstbad
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
if|if
condition|(
name|cb
condition|)
block|{
comment|/*  		 * The notification that we have sent 		 * too much is bad news -- we will 		 * have to go through queued up so far 		 * splitting ones which are too big and 		 * reassigning sequence numbers and checksums. 		 * we should then retransmit all packets from 		 * one above the offending packet to the last one 		 * we had sent (or our allocation) 		 * then the offending one so that the any queued 		 * data at our destination will be discarded. 		 */
name|ep
operator|=
operator|(
expr|struct
name|ns_errp
operator|*
operator|)
name|nsp
operator|->
name|nsp_notify_param
expr_stmt|;
name|sb
operator|=
operator|&
name|nsp
operator|->
name|nsp_socket
operator|->
name|so_snd
expr_stmt|;
name|cb
operator|->
name|s_mtu
operator|=
name|ep
operator|->
name|ns_err_param
expr_stmt|;
name|badseq
operator|=
name|SI
argument_list|(
operator|&
name|ep
operator|->
name|ns_err_idp
argument_list|)
operator|->
name|si_seq
expr_stmt|;
for|for
control|(
name|m
operator|=
name|sb
operator|->
name|sb_mb
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_act
control|)
block|{
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|badseq
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|firstbad
operator|=
name|m
expr_stmt|;
comment|/*for (;;) {*/
comment|/* calculate length */
for|for
control|(
name|m0
operator|=
name|m
operator|,
name|len
operator|=
literal|0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|cb
operator|->
name|s_mtu
condition|)
block|{ 			}
comment|/* FINISH THIS 		} */
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|spp_output
parameter_list|(
name|cb
parameter_list|,
name|m0
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|spidp
modifier|*
name|si
init|=
operator|(
expr|struct
name|spidp
operator|*
operator|)
literal|0
decl_stmt|;
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_snd
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|,
name|win
decl_stmt|,
name|rcv_win
decl_stmt|;
name|short
name|span
decl_stmt|,
name|off
decl_stmt|,
name|recordp
init|=
literal|0
decl_stmt|;
name|u_short
name|alo
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|sendalot
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|int
name|idle
decl_stmt|;
endif|#
directive|endif
name|struct
name|mbuf
modifier|*
name|mprev
decl_stmt|;
specifier|extern
name|int
name|idpcksum
decl_stmt|;
if|if
condition|(
name|m0
condition|)
block|{
name|int
name|mtu
init|=
name|cb
operator|->
name|s_mtu
decl_stmt|;
name|int
name|datalen
decl_stmt|;
comment|/* 		 * Make sure that packet isn't too big. 		 */
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|mprev
operator|=
name|m
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EOR
condition|)
name|recordp
operator|=
literal|1
expr_stmt|;
block|}
name|datalen
operator|=
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_HO
operator|)
condition|?
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
else|:
name|len
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
name|mtu
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
else|else
block|{
name|int
name|oldEM
init|=
name|cb
operator|->
name|s_cc
operator|&
name|SP_EM
decl_stmt|;
name|cb
operator|->
name|s_cc
operator|&=
operator|~
name|SP_EM
expr_stmt|;
while|while
condition|(
name|len
operator|>
name|mtu
condition|)
block|{
comment|/* 					 * Here we are only being called 					 * from usrreq(), so it is OK to 					 * block. 					 */
name|m
operator|=
name|m_copym
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|mtu
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_NEWCALL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mm
init|=
name|m
decl_stmt|;
name|spp_newchecks
index|[
literal|7
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|mm
condition|)
block|{
name|mm
operator|->
name|m_flags
operator|&=
operator|~
name|M_EOR
expr_stmt|;
name|mm
operator|=
name|mm
operator|->
name|m_next
expr_stmt|;
block|}
block|}
name|error
operator|=
name|spp_output
argument_list|(
name|cb
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cb
operator|->
name|s_cc
operator||=
name|oldEM
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|m_adj
argument_list|(
name|m0
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|len
operator|-=
name|mtu
expr_stmt|;
block|}
name|cb
operator|->
name|s_cc
operator||=
name|oldEM
expr_stmt|;
block|}
block|}
comment|/* 		 * Force length even, by adding a "garbage byte" if 		 * necessary. 		 */
if|if
condition|(
name|len
operator|&
literal|1
condition|)
block|{
name|m
operator|=
name|mprev
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|>=
literal|1
condition|)
name|m
operator|->
name|m_len
operator|++
expr_stmt|;
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m1
init|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
decl_stmt|;
if|if
condition|(
name|m1
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m1
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|mtod
argument_list|(
name|m1
argument_list|,
name|u_char
operator|*
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m1
expr_stmt|;
block|}
block|}
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 		 * Fill in mbuf with extended SP header 		 * and addresses and length put into network format. 		 */
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_i
operator|=
operator|*
name|cb
operator|->
name|s_idp
expr_stmt|;
name|si
operator|->
name|si_s
operator|=
name|cb
operator|->
name|s_shdr
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
operator|)
operator|&&
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_HO
operator|)
condition|)
block|{
specifier|register
name|struct
name|sphdr
modifier|*
name|sh
decl_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m0
operator|=
name|m_pullup
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
block|}
name|sh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_dt
operator|=
name|sh
operator|->
name|sp_dt
expr_stmt|;
name|si
operator|->
name|si_cc
operator||=
name|sh
operator|->
name|sp_cc
operator|&
name|SP_EM
expr_stmt|;
name|m0
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
block|}
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_flags2
operator|&
name|SF_NEWCALL
operator|)
operator|&&
name|recordp
condition|)
block|{
name|si
operator|->
name|si_cc
operator||=
name|SP_EM
expr_stmt|;
name|spp_newchecks
index|[
literal|8
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_SOOB
condition|)
block|{
comment|/* 			 * Per jqj@cornell: 			 * make sure OB packets convey exactly 1 byte. 			 * If the packet is 1 byte or larger, we 			 * have already guaranted there to be at least 			 * one garbage byte for the checksum, and 			 * extra bytes shouldn't hurt! 			 */
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
condition|)
block|{
name|si
operator|->
name|si_cc
operator||=
name|SP_OB
expr_stmt|;
name|len
operator|=
operator|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
name|si
operator|->
name|si_len
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
operator|(
operator|(
name|len
operator|-
literal|1
operator|)
operator||
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* 		 * queue stuff up for output 		 */
name|sbappendrecord
argument_list|(
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_seq
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
name|idle
operator|=
operator|(
name|cb
operator|->
name|s_smax
operator|==
operator|(
name|cb
operator|->
name|s_rack
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|again
label|:
name|sendalot
operator|=
literal|0
expr_stmt|;
name|off
operator|=
name|cb
operator|->
name|s_snxt
operator|-
name|cb
operator|->
name|s_rack
expr_stmt|;
name|win
operator|=
name|min
argument_list|(
name|cb
operator|->
name|s_swnd
argument_list|,
operator|(
name|cb
operator|->
name|s_cwnd
operator|/
name|CUNIT
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If in persist timeout with window of 0, send a probe. 	 * Otherwise, if window is small but nonzero 	 * and timer expired, send what we can and go into 	 * transmit state. 	 */
if|if
condition|(
name|cb
operator|->
name|s_force
operator|==
literal|1
operator|+
name|SPPT_PERSIST
condition|)
block|{
if|if
condition|(
name|win
operator|!=
literal|0
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPPT_PERSIST
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|span
operator|=
name|cb
operator|->
name|s_seq
operator|-
name|cb
operator|->
name|s_rack
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|span
argument_list|,
name|win
argument_list|)
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Window shrank after we went into it. 		 * If window shrank to 0, cancel pending 		 * restransmission and pull s_snxt back 		 * to (closed) window.  We will enter persist 		 * state below.  If the widndow didn't close completely, 		 * just wait for an ACK. 		 */
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|win
operator|==
literal|0
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPPT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_snxt
operator|=
name|cb
operator|->
name|s_rack
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|1
condition|)
name|sendalot
operator|=
literal|1
expr_stmt|;
name|rcv_win
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 	 * Send if we owe peer an ACK. 	 */
if|if
condition|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_SOOB
condition|)
block|{
comment|/* 		 * must transmit this out of band packet 		 */
name|cb
operator|->
name|s_oobflags
operator|&=
operator|~
name|SF_SOOB
expr_stmt|;
name|sendalot
operator|=
literal|1
expr_stmt|;
name|sppstat
operator|.
name|spps_sndurg
operator|++
expr_stmt|;
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_ACKNOW
condition|)
goto|goto
name|send
goto|;
if|if
condition|(
name|cb
operator|->
name|s_state
operator|<
name|TCPS_ESTABLISHED
condition|)
goto|goto
name|send
goto|;
comment|/* 	 * Silly window can't happen in spp. 	 * Code from tcp deleted. 	 */
if|if
condition|(
name|len
condition|)
goto|goto
name|send
goto|;
comment|/* 	 * Compare available window to amount of window 	 * known to peer (as advertised window less 	 * next expected input.)  If the difference is at least two 	 * packets or at least 35% of the mximum possible window, 	 * then want to send a window update to peer. 	 */
if|if
condition|(
name|rcv_win
operator|>
literal|0
condition|)
block|{
name|u_short
name|delta
init|=
literal|1
operator|+
name|cb
operator|->
name|s_alo
operator|-
name|cb
operator|->
name|s_ack
decl_stmt|;
name|int
name|adv
init|=
name|rcv_win
operator|-
operator|(
name|delta
operator|*
name|cb
operator|->
name|s_mtu
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|==
literal|0
operator|&&
name|adv
operator|>=
operator|(
literal|2
operator|*
name|cb
operator|->
name|s_mtu
operator|)
operator|)
operator|||
operator|(
literal|100
operator|*
name|adv
operator|/
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|>=
literal|35
operator|)
condition|)
block|{
name|sppstat
operator|.
name|spps_sndwinup
operator|++
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_ACKNOW
expr_stmt|;
goto|goto
name|send
goto|;
block|}
block|}
comment|/* 	 * Many comments from tcp_output.c are appropriate here 	 * including . . . 	 * If send window is too small, there is data to transmit, and no 	 * retransmit or persist is pending, then go to persist state. 	 * If nothing happens soon, send when timer expires: 	 * if window is nonzero, transmit what we can, 	 * otherwise send a probe. 	 */
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
operator|&&
name|cb
operator|->
name|s_timer
index|[
name|SPPT_REXMT
index|]
operator|==
literal|0
operator|&&
name|cb
operator|->
name|s_timer
index|[
name|SPPT_PERSIST
index|]
operator|==
literal|0
condition|)
block|{
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
name|spp_setpersist
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * No reason to send a packet, just return. 	 */
name|cb
operator|->
name|s_outx
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|send
label|:
comment|/* 	 * Find requested packet. 	 */
name|si
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|cb
operator|->
name|s_want
operator|=
name|cb
operator|->
name|s_snxt
expr_stmt|;
for|for
control|(
name|m
operator|=
name|sb
operator|->
name|sb_mb
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_act
control|)
block|{
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSEQ_LEQ
argument_list|(
name|cb
operator|->
name|s_snxt
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
condition|)
break|break;
block|}
name|found
label|:
if|if
condition|(
name|si
condition|)
block|{
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|cb
operator|->
name|s_snxt
condition|)
name|cb
operator|->
name|s_snxt
operator|++
expr_stmt|;
else|else
name|sppstat
operator|.
name|spps_sndvoid
operator|++
operator|,
name|si
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * update window 	 */
if|if
condition|(
name|rcv_win
operator|<
literal|0
condition|)
name|rcv_win
operator|=
literal|0
expr_stmt|;
name|alo
operator|=
name|cb
operator|->
name|s_ack
operator|-
literal|1
operator|+
operator|(
name|rcv_win
operator|/
operator|(
operator|(
name|short
operator|)
name|cb
operator|->
name|s_mtu
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|alo
argument_list|,
name|cb
operator|->
name|s_alo
argument_list|)
condition|)
name|alo
operator|=
name|cb
operator|->
name|s_alo
expr_stmt|;
if|if
condition|(
name|si
condition|)
block|{
comment|/* 		 * must make a copy of this packet for 		 * idp_output to monkey with 		 */
name|m
operator|=
name|m_copy
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_smax
argument_list|)
condition|)
name|sppstat
operator|.
name|spps_sndrexmitpack
operator|++
expr_stmt|;
else|else
name|sppstat
operator|.
name|spps_sndpack
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|s_force
operator|||
name|cb
operator|->
name|s_flags
operator|&
name|SF_ACKNOW
condition|)
block|{
comment|/* 		 * Must send an acknowledgement or a probe 		 */
if|if
condition|(
name|cb
operator|->
name|s_force
condition|)
name|sppstat
operator|.
name|spps_sndprobe
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_ACKNOW
condition|)
name|sppstat
operator|.
name|spps_sndacks
operator|++
expr_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 		 * Fill in mbuf with extended SP header 		 * and addresses and length put into network format. 		 */
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spidp
operator|*
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_i
operator|=
operator|*
name|cb
operator|->
name|s_idp
expr_stmt|;
name|si
operator|->
name|si_s
operator|=
name|cb
operator|->
name|s_shdr
expr_stmt|;
name|si
operator|->
name|si_seq
operator|=
name|cb
operator|->
name|s_smax
operator|+
literal|1
expr_stmt|;
name|si
operator|->
name|si_len
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_cc
operator||=
name|SP_SP
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|s_outx
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_OUTPUT
argument_list|,
name|cb
operator|->
name|s_state
argument_list|,
name|cb
argument_list|,
name|si
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Stuff checksum and output datagram. 	 */
if|if
condition|(
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SP_SP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_force
operator|!=
operator|(
literal|1
operator|+
name|SPPT_PERSIST
operator|)
operator|||
name|cb
operator|->
name|s_timer
index|[
name|SPPT_PERSIST
index|]
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If this is a new packet and we are not currently  			 * timing anything, time this one. 			 */
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_smax
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
condition|)
block|{
name|cb
operator|->
name|s_smax
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rtt
operator|==
literal|0
condition|)
block|{
name|sppstat
operator|.
name|spps_segstimed
operator|++
expr_stmt|;
name|cb
operator|->
name|s_rtseq
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
name|cb
operator|->
name|s_rtt
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 			 * Set rexmt timer if not currently set, 			 * Initial value for retransmit timer is smoothed 			 * round-trip time + 2 * round-trip time variance. 			 * Initialize shift counter which is used for backoff 			 * of retransmit time. 			 */
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPPT_REXMT
index|]
operator|==
literal|0
operator|&&
name|cb
operator|->
name|s_snxt
operator|!=
name|cb
operator|->
name|s_rack
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPPT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPPT_PERSIST
index|]
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPPT_PERSIST
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_smax
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
condition|)
block|{
name|cb
operator|->
name|s_smax
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|s_state
operator|<
name|TCPS_ESTABLISHED
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_rtt
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_rtt
operator|=
literal|1
expr_stmt|;
comment|/* Time initial handshake */
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPPT_REXMT
index|]
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_timer
index|[
name|SPPT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
block|}
block|{
comment|/* 		 * Do not request acks when we ack their data packets or 		 * when we do a gratuitous window update. 		 */
if|if
condition|(
operator|(
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SP_SP
operator|)
operator|==
literal|0
operator|)
operator|||
name|cb
operator|->
name|s_force
condition|)
name|si
operator|->
name|si_cc
operator||=
name|SP_SA
expr_stmt|;
name|si
operator|->
name|si_seq
operator|=
name|htons
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|htons
argument_list|(
name|alo
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|htons
argument_list|(
name|cb
operator|->
name|s_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|idpcksum
condition|)
block|{
name|si
operator|->
name|si_sum
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|len
operator|++
expr_stmt|;
name|si
operator|->
name|si_sum
operator|=
name|ns_cksum
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
name|si
operator|->
name|si_sum
operator|=
literal|0xffff
expr_stmt|;
name|cb
operator|->
name|s_outx
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
condition|)
name|spp_trace
argument_list|(
name|SA_OUTPUT
argument_list|,
name|cb
operator|->
name|s_state
argument_list|,
name|cb
argument_list|,
name|si
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
condition|)
name|error
operator|=
name|ns_output
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|route
operator|*
operator|)
literal|0
argument_list|,
name|NS_ROUTETOIF
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ns_output
argument_list|(
name|m
argument_list|,
operator|&
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_route
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sppstat
operator|.
name|spps_sndtotal
operator|++
expr_stmt|;
comment|/* 	 * Data sent (as far as we can tell). 	 * If this advertises a larger window than any other segment, 	 * then remember the size of the advertized window. 	 * Any pending ACK has now been sent. 	 */
name|cb
operator|->
name|s_force
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_flags
operator|&=
operator|~
operator|(
name|SF_ACKNOW
operator||
name|SF_DELACK
operator|)
expr_stmt|;
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|alo
argument_list|,
name|cb
operator|->
name|s_alo
argument_list|)
condition|)
name|cb
operator|->
name|s_alo
operator|=
name|alo
expr_stmt|;
if|if
condition|(
name|sendalot
condition|)
goto|goto
name|again
goto|;
name|cb
operator|->
name|s_outx
operator|=
literal|5
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|spp_do_persist_panics
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|spp_setpersist
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
block|{
specifier|register
name|t
operator|=
operator|(
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
operator|+
name|cb
operator|->
name|s_rttvar
operator|)
operator|>>
literal|1
expr_stmt|;
specifier|extern
name|int
name|spp_backoff
index|[]
decl_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPPT_REXMT
index|]
operator|&&
name|spp_do_persist_panics
condition|)
name|panic
argument_list|(
literal|"spp_output REXMT"
argument_list|)
expr_stmt|;
comment|/* 	 * Start/restart persistance timer. 	 */
name|SPPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|SPPT_PERSIST
index|]
argument_list|,
name|t
operator|*
name|spp_backoff
index|[
name|cb
operator|->
name|s_rxtshift
index|]
argument_list|,
name|SPPTV_PERSMIN
argument_list|,
name|SPPTV_PERSMAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rxtshift
operator|<
name|SPP_MAXRXTSHIFT
condition|)
name|cb
operator|->
name|s_rxtshift
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|spp_ctloutput
parameter_list|(
name|req
parameter_list|,
name|so
parameter_list|,
name|level
parameter_list|,
name|name
parameter_list|,
name|value
parameter_list|)
name|int
name|req
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|name
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|value
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|sotonspcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|level
operator|!=
name|NSPROTO_SPP
condition|)
block|{
comment|/* This will have to be changed when we do more general 		   stacking of protocols */
return|return
operator|(
name|idp_ctloutput
argument_list|(
name|req
argument_list|,
name|so
argument_list|,
name|level
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|nsp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
else|else
name|cb
operator|=
name|nstosppcb
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRCO_GETOPT
case|:
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
switch|switch
condition|(
name|name
condition|)
block|{
case|case
name|SO_HEADERS_ON_INPUT
case|:
name|mask
operator|=
name|SF_HI
expr_stmt|;
goto|goto
name|get_flags
goto|;
case|case
name|SO_HEADERS_ON_OUTPUT
case|:
name|mask
operator|=
name|SF_HO
expr_stmt|;
name|get_flags
label|:
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|short
operator|*
argument_list|)
operator|=
name|cb
operator|->
name|s_flags
operator|&
name|mask
expr_stmt|;
break|break;
case|case
name|SO_MTU
case|:
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|short
operator|*
argument_list|)
operator|=
name|cb
operator|->
name|s_mtu
expr_stmt|;
break|break;
case|case
name|SO_LAST_HEADER
case|:
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sphdr
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
operator|=
name|cb
operator|->
name|s_rhdr
expr_stmt|;
break|break;
case|case
name|SO_DEFAULT_HEADERS
case|:
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
operator|=
name|cb
operator|->
name|s_shdr
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|*
name|value
operator|=
name|m
expr_stmt|;
break|break;
case|case
name|PRCO_SETOPT
case|:
if|if
condition|(
name|value
operator|==
literal|0
operator|||
operator|*
name|value
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|name
condition|)
block|{
name|int
modifier|*
name|ok
decl_stmt|;
case|case
name|SO_HEADERS_ON_INPUT
case|:
name|mask
operator|=
name|SF_HI
expr_stmt|;
goto|goto
name|set_head
goto|;
case|case
name|SO_HEADERS_ON_OUTPUT
case|:
name|mask
operator|=
name|SF_HO
expr_stmt|;
name|set_head
label|:
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
condition|)
block|{
name|ok
operator|=
name|mtod
argument_list|(
operator|*
name|value
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ok
condition|)
name|cb
operator|->
name|s_flags
operator||=
name|mask
expr_stmt|;
else|else
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SO_MTU
case|:
name|cb
operator|->
name|s_mtu
operator|=
operator|*
operator|(
name|mtod
argument_list|(
operator|*
name|value
argument_list|,
name|u_short
operator|*
argument_list|)
operator|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SF_NEWCALL
case|case
name|SO_NEWCALL
case|:
name|ok
operator|=
name|mtod
argument_list|(
operator|*
name|value
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ok
condition|)
block|{
name|cb
operator|->
name|s_flags2
operator||=
name|SF_NEWCALL
expr_stmt|;
name|spp_newchecks
index|[
literal|5
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|s_flags2
operator|&=
operator|~
name|SF_NEWCALL
expr_stmt|;
name|spp_newchecks
index|[
literal|6
index|]
operator|++
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|SO_DEFAULT_HEADERS
case|:
block|{
specifier|register
name|struct
name|sphdr
modifier|*
name|sp
init|=
name|mtod
argument_list|(
operator|*
name|value
argument_list|,
expr|struct
name|sphdr
operator|*
argument_list|)
decl_stmt|;
name|cb
operator|->
name|s_dt
operator|=
name|sp
operator|->
name|sp_dt
expr_stmt|;
name|cb
operator|->
name|s_cc
operator|=
name|sp
operator|->
name|sp_cc
operator|&
name|SP_EM
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|m_freem
argument_list|(
operator|*
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|release
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|spp_usrreq
parameter_list|(
name|so
parameter_list|,
name|req
parameter_list|,
name|m
parameter_list|,
name|nam
parameter_list|,
name|controlp
parameter_list|,
name|dummy
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|req
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
decl|*
name|nam
decl_stmt|,
modifier|*
name|controlp
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|dummy
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|sotonspcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|ostate
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
if|if
condition|(
name|req
operator|==
name|PRU_CONTROL
condition|)
return|return
operator|(
name|ns_control
argument_list|(
name|so
argument_list|,
operator|(
name|int
operator|)
name|m
argument_list|,
operator|(
name|caddr_t
operator|)
name|nam
argument_list|,
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|controlp
argument_list|)
operator|)
return|;
if|if
condition|(
name|nsp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|req
operator|!=
name|PRU_ATTACH
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
else|else
name|cb
operator|=
name|nstosppcb
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
name|ostate
operator|=
name|cb
condition|?
name|cb
operator|->
name|s_state
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRU_ATTACH
case|:
if|if
condition|(
name|nsp
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|ns_pcballoc
argument_list|(
name|so
argument_list|,
operator|&
name|nspcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|==
literal|0
operator|||
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
operator|(
name|u_long
operator|)
literal|3072
argument_list|,
operator|(
name|u_long
operator|)
literal|3072
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|nsp
operator|=
name|sotonspcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|mm
operator|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_PCB
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|cb
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|sppcb
operator|*
argument_list|)
expr_stmt|;
name|mm
operator|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|cb
operator|->
name|s_idp
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|idp
operator|*
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
name|cb
operator|->
name|s_smax
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|->
name|s_swl1
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|->
name|s_q
operator|.
name|si_next
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_prev
operator|=
operator|&
name|cb
operator|->
name|s_q
expr_stmt|;
name|cb
operator|->
name|s_nspcb
operator|=
name|nsp
expr_stmt|;
name|cb
operator|->
name|s_mtu
operator|=
literal|576
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|*
name|CUNIT
operator|/
name|cb
operator|->
name|s_mtu
expr_stmt|;
name|cb
operator|->
name|s_ssthresh
operator|=
name|cb
operator|->
name|s_cwnd
expr_stmt|;
name|cb
operator|->
name|s_cwmx
operator|=
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|*
name|CUNIT
operator|/
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
operator|)
expr_stmt|;
comment|/* Above is recomputed when connecting to account 		   for changed buffering or mtu's */
name|cb
operator|->
name|s_rtt
operator|=
name|SPPTV_SRTTBASE
expr_stmt|;
name|cb
operator|->
name|s_rttvar
operator|=
name|SPPTV_SRTTDFLT
operator|<<
literal|2
expr_stmt|;
name|SPPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_rxtcur
argument_list|,
operator|(
operator|(
name|SPPTV_SRTTBASE
operator|>>
literal|2
operator|)
operator|+
operator|(
name|SPPTV_SRTTDFLT
operator|<<
literal|2
operator|)
operator|)
operator|>>
literal|1
argument_list|,
name|SPPTV_MIN
argument_list|,
name|SPPTV_REXMTMAX
argument_list|)
expr_stmt|;
name|nsp
operator|->
name|nsp_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|cb
expr_stmt|;
break|break;
case|case
name|PRU_DETACH
case|:
if|if
condition|(
name|nsp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cb
operator|->
name|s_state
operator|>
name|TCPS_LISTEN
condition|)
name|cb
operator|=
name|spp_disconnect
argument_list|(
name|cb
argument_list|)
expr_stmt|;
else|else
name|cb
operator|=
name|spp_close
argument_list|(
name|cb
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_BIND
case|:
name|error
operator|=
name|ns_pcbbind
argument_list|(
name|nsp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_LISTEN
case|:
if|if
condition|(
name|nsp
operator|->
name|nsp_lport
operator|==
literal|0
condition|)
name|error
operator|=
name|ns_pcbbind
argument_list|(
name|nsp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
break|break;
comment|/* 	 * Initiate connection to peer. 	 * Enter SYN_SENT state, and mark socket as connecting. 	 * Start keep-alive timer, setup prototype header, 	 * Send initial system packet requesting connection. 	 */
case|case
name|PRU_CONNECT
case|:
if|if
condition|(
name|nsp
operator|->
name|nsp_lport
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ns_pcbbind
argument_list|(
name|nsp
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|error
operator|=
name|ns_pcbconnect
argument_list|(
name|nsp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sppstat
operator|.
name|spps_connattempt
operator|++
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_SYN_SENT
expr_stmt|;
name|cb
operator|->
name|s_did
operator|=
literal|0
expr_stmt|;
name|spp_template
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPPT_KEEP
index|]
operator|=
name|SPPTV_KEEP
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|SPPTV_KEEP
expr_stmt|;
comment|/* 		 * Other party is required to respond to 		 * the port I send from, but he is not 		 * required to answer from where I am sending to, 		 * so allow wildcarding. 		 * original port I am sending to is still saved in 		 * cb->s_dport. 		 */
name|nsp
operator|->
name|nsp_fport
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_CONNECT2
case|:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
comment|/* 	 * We may decide later to implement connection closing 	 * handshaking at the spp level optionally. 	 * here is the hook to do it: 	 */
case|case
name|PRU_DISCONNECT
case|:
name|cb
operator|=
name|spp_disconnect
argument_list|(
name|cb
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Accept a connection.  Essentially all the work is 	 * done at higher levels; just return the address 	 * of the peer, storing through addr. 	 */
case|case
name|PRU_ACCEPT
case|:
block|{
name|struct
name|sockaddr_ns
modifier|*
name|sns
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_ns
operator|*
argument_list|)
decl_stmt|;
name|nam
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ns
argument_list|)
expr_stmt|;
name|sns
operator|->
name|sns_family
operator|=
name|AF_NS
expr_stmt|;
name|sns
operator|->
name|sns_addr
operator|=
name|nsp
operator|->
name|nsp_faddr
expr_stmt|;
break|break;
block|}
case|case
name|PRU_SHUTDOWN
case|:
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|spp_usrclosed
argument_list|(
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
condition|)
name|error
operator|=
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * After a receive, possibly send acknowledgment 	 * updating allocation. 	 */
case|case
name|PRU_RCVD
case|:
name|cb
operator|->
name|s_flags
operator||=
name|SF_RVD
expr_stmt|;
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|SF_RVD
expr_stmt|;
break|break;
case|case
name|PRU_ABORT
case|:
operator|(
name|void
operator|)
name|spp_drop
argument_list|(
name|cb
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_SENSE
case|:
case|case
name|PRU_CONTROL
case|:
name|m
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
case|case
name|PRU_RCVOOB
case|:
if|if
condition|(
operator|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_IOOB
operator|)
operator|||
name|so
operator|->
name|so_oobmark
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_RCVATMARK
operator|)
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|=
name|cb
operator|->
name|s_iobc
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|PRU_SENDOOB
case|:
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|<
operator|-
literal|512
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|cb
operator|->
name|s_oobflags
operator||=
name|SF_SOOB
expr_stmt|;
comment|/* fall into */
case|case
name|PRU_SEND
case|:
if|if
condition|(
name|controlp
condition|)
block|{
name|u_short
modifier|*
name|p
init|=
name|mtod
argument_list|(
name|controlp
argument_list|,
name|u_short
operator|*
argument_list|)
decl_stmt|;
name|spp_newchecks
index|[
literal|2
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|5
operator|)
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|1
condition|)
block|{
comment|/* XXXX, for testing */
name|cb
operator|->
name|s_shdr
operator|.
name|sp_dt
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|p
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|spp_newchecks
index|[
literal|3
index|]
operator|++
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|controlp
argument_list|)
expr_stmt|;
block|}
name|controlp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|spp_output
argument_list|(
name|cb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|PRU_SOCKADDR
case|:
name|ns_setsockaddr
argument_list|(
name|nsp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_PEERADDR
case|:
name|ns_setpeeraddr
argument_list|(
name|nsp
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_SLOWTIMO
case|:
name|cb
operator|=
name|spp_timers
argument_list|(
name|cb
argument_list|,
operator|(
name|int
operator|)
name|nam
argument_list|)
expr_stmt|;
name|req
operator||=
operator|(
operator|(
name|int
operator|)
name|nam
operator|)
operator|<<
literal|8
expr_stmt|;
break|break;
case|case
name|PRU_FASTTIMO
case|:
case|case
name|PRU_PROTORCV
case|:
case|case
name|PRU_PROTOSEND
case|:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"sp_usrreq"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspps
operator|)
condition|)
name|spp_trace
argument_list|(
name|SA_USER
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|(
expr|struct
name|spidp
operator|*
operator|)
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|release
label|:
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|controlp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_function
name|int
name|spp_usrreq_sp
parameter_list|(
name|so
parameter_list|,
name|req
parameter_list|,
name|m
parameter_list|,
name|nam
parameter_list|,
name|controlp
parameter_list|,
name|dummy
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|req
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
decl|*
name|nam
decl_stmt|,
modifier|*
name|controlp
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|dummy
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
init|=
name|spp_usrreq
argument_list|(
name|so
argument_list|,
name|req
argument_list|,
name|m
argument_list|,
name|nam
argument_list|,
name|controlp
argument_list|,
name|dummy
argument_list|)
decl_stmt|;
if|if
condition|(
name|req
operator|==
name|PRU_ATTACH
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|sotonspcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
operator|(
operator|(
expr|struct
name|sppcb
operator|*
operator|)
name|nsp
operator|->
name|nsp_pcb
operator|)
operator|->
name|s_flags
operator||=
operator|(
name|SF_HI
operator||
name|SF_HO
operator||
name|SF_PI
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Create template to be used to send spp packets on a connection.  * Called after host entry created, fills  * in a skeletal spp header (choosing connection id),  * minimizing the amount of work necessary when the connection is used.  */
end_comment

begin_function
specifier|static
name|void
name|spp_template
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
block|{
specifier|register
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|cb
operator|->
name|s_nspcb
decl_stmt|;
specifier|register
name|struct
name|idp
modifier|*
name|idp
init|=
name|cb
operator|->
name|s_idp
decl_stmt|;
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
operator|(
name|nsp
operator|->
name|nsp_socket
operator|->
name|so_snd
operator|)
decl_stmt|;
name|idp
operator|->
name|idp_pt
operator|=
name|NSPROTO_SPP
expr_stmt|;
name|idp
operator|->
name|idp_sna
operator|=
name|nsp
operator|->
name|nsp_laddr
expr_stmt|;
name|idp
operator|->
name|idp_dna
operator|=
name|nsp
operator|->
name|nsp_faddr
expr_stmt|;
name|cb
operator|->
name|s_sid
operator|=
name|htons
argument_list|(
name|spp_iss
argument_list|)
expr_stmt|;
name|spp_iss
operator|+=
name|SPP_ISSINCR
operator|/
literal|2
expr_stmt|;
name|cb
operator|->
name|s_alo
operator|=
literal|1
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
operator|(
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|*
name|CUNIT
operator|)
operator|/
name|cb
operator|->
name|s_mtu
expr_stmt|;
name|cb
operator|->
name|s_ssthresh
operator|=
name|cb
operator|->
name|s_cwnd
expr_stmt|;
comment|/* Try to expand fast to full complement 					of large packets */
name|cb
operator|->
name|s_cwmx
operator|=
operator|(
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|*
name|CUNIT
operator|)
operator|/
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|spidp
argument_list|)
operator|)
expr_stmt|;
name|cb
operator|->
name|s_cwmx
operator|=
name|max
argument_list|(
name|cb
operator|->
name|s_cwmx
argument_list|,
name|cb
operator|->
name|s_cwnd
argument_list|)
expr_stmt|;
comment|/* But allow for lots of little packets as well */
block|}
end_function

begin_comment
comment|/*  * Close a SPIP control block:  *	discard spp control block itself  *	discard ns protocol control block  *	wake up any sleepers  */
end_comment

begin_function
name|struct
name|sppcb
modifier|*
name|spp_close
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
block|{
specifier|register
name|struct
name|spidp_q
modifier|*
name|s
decl_stmt|;
name|struct
name|nspcb
modifier|*
name|nsp
init|=
name|cb
operator|->
name|s_nspcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|nsp
operator|->
name|nsp_socket
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|s
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
expr_stmt|;
while|while
condition|(
name|s
operator|!=
operator|&
operator|(
name|cb
operator|->
name|s_q
operator|)
condition|)
block|{
name|s
operator|=
name|s
operator|->
name|si_next
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|s
operator|->
name|si_prev
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|s
operator|->
name|si_prev
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|cb
operator|->
name|s_idp
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|cb
argument_list|)
argument_list|)
expr_stmt|;
name|nsp
operator|->
name|nsp_pcb
operator|=
literal|0
expr_stmt|;
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ns_pcbdetach
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
name|sppstat
operator|.
name|spps_closed
operator|++
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|sppcb
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Someday we may do level 3 handshaking  *	to close a connection or send a xerox style error.  *	For now, just close.  */
end_comment

begin_function
name|struct
name|sppcb
modifier|*
name|spp_usrclosed
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
block|{
return|return
operator|(
name|spp_close
argument_list|(
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sppcb
modifier|*
name|spp_disconnect
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
block|{
return|return
operator|(
name|spp_close
argument_list|(
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drop connection, reporting  * the specified error.  */
end_comment

begin_function
name|struct
name|sppcb
modifier|*
name|spp_drop
parameter_list|(
name|cb
parameter_list|,
name|errno
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|errno
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
decl_stmt|;
comment|/* 	 * someday, in the xerox world 	 * we will generate error protocol packets 	 * announcing that the socket has gone away. 	 */
if|if
condition|(
name|TCPS_HAVERCVDSYN
argument_list|(
name|cb
operator|->
name|s_state
argument_list|)
condition|)
block|{
name|sppstat
operator|.
name|spps_drops
operator|++
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_CLOSED
expr_stmt|;
comment|/*(void) tcp_output(cb);*/
block|}
else|else
name|sppstat
operator|.
name|spps_conndrops
operator|++
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
name|errno
expr_stmt|;
return|return
operator|(
name|spp_close
argument_list|(
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spp_abort
parameter_list|(
name|nsp
parameter_list|,
name|errno
parameter_list|)
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
name|int
name|errno
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|spp_close
argument_list|(
operator|(
expr|struct
name|sppcb
operator|*
operator|)
name|nsp
operator|->
name|nsp_pcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|spp_backoff
index|[
name|SPP_MAXRXTSHIFT
operator|+
literal|1
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Fast timeout routine for processing delayed acks  */
end_comment

begin_function
name|void
name|spp_fasttimo
parameter_list|()
block|{
specifier|register
name|struct
name|nspcb
modifier|*
name|nsp
decl_stmt|;
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|nsp
operator|=
name|nspcb
operator|.
name|nsp_next
expr_stmt|;
if|if
condition|(
name|nsp
condition|)
for|for
control|(
init|;
name|nsp
operator|!=
operator|&
name|nspcb
condition|;
name|nsp
operator|=
name|nsp
operator|->
name|nsp_next
control|)
if|if
condition|(
operator|(
name|cb
operator|=
operator|(
expr|struct
name|sppcb
operator|*
operator|)
name|nsp
operator|->
name|nsp_pcb
operator|)
operator|&&
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_DELACK
operator|)
condition|)
block|{
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|SF_DELACK
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_ACKNOW
expr_stmt|;
name|sppstat
operator|.
name|spps_delack
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * spp protocol timeout routine called every 500 ms.  * Updates the timers in all active pcb's and  * causes finite state machine actions if timers expire.  */
end_comment

begin_function
name|void
name|spp_slowtimo
parameter_list|()
block|{
specifier|register
name|struct
name|nspcb
modifier|*
name|ip
decl_stmt|,
modifier|*
name|ipnxt
decl_stmt|;
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Search through tcb's and update active timers. 	 */
name|ip
operator|=
name|nspcb
operator|.
name|nsp_next
expr_stmt|;
if|if
condition|(
name|ip
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|ip
operator|!=
operator|&
name|nspcb
condition|)
block|{
name|cb
operator|=
name|nstosppcb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ipnxt
operator|=
name|ip
operator|->
name|nsp_next
expr_stmt|;
if|if
condition|(
name|cb
operator|==
literal|0
condition|)
goto|goto
name|tpgone
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPPT_NTIMERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|i
index|]
operator|&&
operator|--
name|cb
operator|->
name|s_timer
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|spp_usrreq
argument_list|(
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
argument_list|,
name|PRU_SLOWTIMO
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|i
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipnxt
operator|->
name|nsp_prev
operator|!=
name|ip
condition|)
goto|goto
name|tpgone
goto|;
block|}
block|}
name|cb
operator|->
name|s_idle
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rtt
condition|)
name|cb
operator|->
name|s_rtt
operator|++
expr_stmt|;
name|tpgone
label|:
name|ip
operator|=
name|ipnxt
expr_stmt|;
block|}
name|spp_iss
operator|+=
name|SPP_ISSINCR
operator|/
name|PR_SLOWHZ
expr_stmt|;
comment|/* increment iss */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SPP timer processing.  */
end_comment

begin_function
name|struct
name|sppcb
modifier|*
name|spp_timers
parameter_list|(
name|cb
parameter_list|,
name|timer
parameter_list|)
specifier|register
name|struct
name|sppcb
modifier|*
name|cb
decl_stmt|;
name|int
name|timer
decl_stmt|;
block|{
name|long
name|rexmt
decl_stmt|;
name|int
name|win
decl_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|timer
expr_stmt|;
switch|switch
condition|(
name|timer
condition|)
block|{
comment|/* 	 * 2 MSL timeout in shutdown went off.  TCP deletes connection 	 * control block. 	 */
case|case
name|SPPT_2MSL
case|:
name|printf
argument_list|(
literal|"spp: SPPT_2MSL went off for no reason\n"
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|timer
index|]
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 	 * Retransmission timer went off.  Message has not 	 * been acked within retransmit interval.  Back off 	 * to a longer retransmit interval and retransmit one packet. 	 */
case|case
name|SPPT_REXMT
case|:
if|if
condition|(
operator|++
name|cb
operator|->
name|s_rxtshift
operator|>
name|SPP_MAXRXTSHIFT
condition|)
block|{
name|cb
operator|->
name|s_rxtshift
operator|=
name|SPP_MAXRXTSHIFT
expr_stmt|;
name|sppstat
operator|.
name|spps_timeoutdrop
operator|++
expr_stmt|;
name|cb
operator|=
name|spp_drop
argument_list|(
name|cb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
block|}
name|sppstat
operator|.
name|spps_rexmttimeo
operator|++
expr_stmt|;
name|rexmt
operator|=
operator|(
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
operator|+
name|cb
operator|->
name|s_rttvar
operator|)
operator|>>
literal|1
expr_stmt|;
name|rexmt
operator|*=
name|spp_backoff
index|[
name|cb
operator|->
name|s_rxtshift
index|]
expr_stmt|;
name|SPPT_RANGESET
argument_list|(
name|cb
operator|->
name|s_rxtcur
argument_list|,
name|rexmt
argument_list|,
name|SPPTV_MIN
argument_list|,
name|SPPTV_REXMTMAX
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPPT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
comment|/* 		 * If we have backed off fairly far, our srtt 		 * estimate is probably bogus.  Clobber it 		 * so we'll take the next rtt measurement as our srtt; 		 * move the current srtt into rttvar to keep the current 		 * retransmit times until then. 		 */
if|if
condition|(
name|cb
operator|->
name|s_rxtshift
operator|>
name|SPP_MAXRXTSHIFT
operator|/
literal|4
condition|)
block|{
name|cb
operator|->
name|s_rttvar
operator|+=
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
expr_stmt|;
name|cb
operator|->
name|s_srtt
operator|=
literal|0
expr_stmt|;
block|}
name|cb
operator|->
name|s_snxt
operator|=
name|cb
operator|->
name|s_rack
expr_stmt|;
comment|/* 		 * If timing a packet, stop the timer. 		 */
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
comment|/* 		 * See very long discussion in tcp_timer.c about congestion 		 * window and sstrhesh 		 */
name|win
operator|=
name|min
argument_list|(
name|cb
operator|->
name|s_swnd
argument_list|,
operator|(
name|cb
operator|->
name|s_cwnd
operator|/
name|CUNIT
operator|)
argument_list|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|win
operator|<
literal|2
condition|)
name|win
operator|=
literal|2
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
name|CUNIT
expr_stmt|;
name|cb
operator|->
name|s_ssthresh
operator|=
name|win
operator|*
name|CUNIT
expr_stmt|;
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Persistance timer into zero window. 	 * Force a probe to be sent. 	 */
case|case
name|SPPT_PERSIST
case|:
name|sppstat
operator|.
name|spps_persisttimeo
operator|++
expr_stmt|;
name|spp_setpersist
argument_list|(
name|cb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Keep-alive timer went off; send something 	 * or drop connection if idle for too long. 	 */
case|case
name|SPPT_KEEP
case|:
name|sppstat
operator|.
name|spps_keeptimeo
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_state
operator|<
name|TCPS_ESTABLISHED
condition|)
goto|goto
name|dropit
goto|;
if|if
condition|(
name|cb
operator|->
name|s_nspcb
operator|->
name|nsp_socket
operator|->
name|so_options
operator|&
name|SO_KEEPALIVE
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_idle
operator|>=
name|SPPTV_MAXIDLE
condition|)
goto|goto
name|dropit
goto|;
name|sppstat
operator|.
name|spps_keepprobe
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|spp_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|cb
operator|->
name|s_idle
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPPT_KEEP
index|]
operator|=
name|SPPTV_KEEP
expr_stmt|;
break|break;
name|dropit
label|:
name|sppstat
operator|.
name|spps_keepdrops
operator|++
expr_stmt|;
name|cb
operator|=
name|spp_drop
argument_list|(
name|cb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|cb
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|int SppcbSize = sizeof (struct sppcb); int NspcbSize = sizeof (struct nspcb);
endif|#
directive|endif
end_endif

end_unit

