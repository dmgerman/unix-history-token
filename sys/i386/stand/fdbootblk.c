begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)fdbootblk.c	7.2 (Berkeley) 5/4/91  *	$Id$  */
end_comment

begin_comment
comment|/*  * fdbootblk.s:  *	Written 10/6/90 by William F. Jolitz  *	Initial block boot for AT/386 with typical stupid NEC controller  *  *	Goal is to read in sucessive 7.5Kbytes of bootstrap to  *	execute.  *  *	No attempt is made to handle disk errors.  */
end_comment

begin_comment
comment|/*#include "/sys/i386/isa/isa.h" #include "/sys/i386/isa/fdreg.h"*/
end_comment

begin_define
define|#
directive|define
name|NOP
value|inb	$0x84,%al
end_define

begin_define
define|#
directive|define
name|BIOSRELOC
value|0x7c00
end_define

begin_define
define|#
directive|define
name|start
value|RELOC+0x400
end_define

begin_comment
comment|/* mumbo-jumbo to pacify DOS, in the hope of getting diskcopy to work */
end_comment

begin_expr_stmt
name|jmp
literal|1f
operator|.
name|asciz
literal|"386BSD "
operator|.
name|byte
literal|1
operator|#
name|sectors
name|per
name|allocation
operator|.
name|word
literal|15
operator|#
name|additional
name|sectors
end_expr_stmt

begin_for
for|for bootstrap 	.word 0			# number of DOS fat sectors 	.word 0			# number of DOS rootdir entries 	.byte 0xf0		# media descriptor 	.word 0			# number of sectors per a DOS fat entry 	.word 18		# number of sectors per track 	.word 2			# number of heads 	.long 0			# number of hidden sectors 	.long 2880-18		# logical sectors per volume 	.byte 0			# physical drive 	.byte 0x29		# ? 	.long 137		# binary id 	.ascii "Release 0.1"	# volume label 	.space 5 1:
comment|/* step 0 force descriptors to bottom of address space */
for|cli 	.byte 0xb8
operator|,
literal|0x30
operator|,
literal|0x00
comment|/* mov $0x30,%ax */
name|mov
operator|%
name|ax
operator|,
operator|%
name|ss
operator|.
name|byte
literal|0xbc
operator|,
literal|0x00
operator|,
literal|0x01
comment|/* mov $0x100,%sp */
name|xorl
operator|%
name|eax
operator|,
operator|%
name|eax
name|movl
operator|%
name|ax
operator|,
operator|%
name|ds
name|movl
operator|%
name|ax
operator|,
operator|%
name|es
comment|/* obtain BIOS parameters for hard disk XXX */
name|movb
name|$0x9f
operator|,
operator|%
name|ah
comment|/* write to 0x9ff00  XXX */
name|movb
name|$0xf0
operator|,
operator|%
name|al
name|mov
operator|%
name|ax
operator|,
operator|%
name|es
name|xor
operator|%
name|edi
operator|,
operator|%
name|edi
operator|.
name|byte
literal|0xf
operator|,
literal|0xb4
operator|,
literal|0x36
expr_stmt|;
end_for

begin_expr_stmt
operator|.
name|word
literal|0x41
operator|*
literal|4
comment|/* lfs 0x41*4, %si */
name|xorb
operator|%
name|ch
operator|,
operator|%
name|ch
name|movb
name|$0x10
operator|,
operator|%
name|cl
name|fs
name|rep
name|movsb
operator|.
name|byte
literal|0xf
operator|,
literal|0xb4
operator|,
literal|0x36
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|.
name|word
literal|0x46
operator|*
literal|4
comment|/* lfs 0x46*4, %si */
name|xorb
operator|%
name|ch
operator|,
operator|%
name|ch
name|movb
name|$0x10
operator|,
operator|%
name|cl
name|fs
name|rep
name|movsb
name|xorl
operator|%
name|eax
operator|,
operator|%
name|eax
name|movl
operator|%
name|ax
operator|,
operator|%
name|es
comment|/* step 1 load new descriptor table */
operator|.
name|byte
literal|0x2E
operator|,
literal|0x0F
operator|,
literal|1
operator|,
literal|0x16
comment|/* word aword cs lgdt GDTptr */
operator|.
name|word
name|BIOSRELOC
operator|+
literal|0xa4
operator|#
name|GDTptr
comment|/* step 2 turn on protected mode */
name|smsw
operator|%
name|ax
name|orb
name|$1
operator|,
operator|%
name|al
name|lmsw
operator|%
name|ax
name|jmp
literal|1f
name|nop
comment|/* step 3  reload segment descriptors */
literal|1
operator|:
name|xorl
operator|%
name|eax
operator|,
operator|%
name|eax
name|movb
name|$0x10
operator|,
operator|%
name|al
name|movl
operator|%
name|ax
operator|,
operator|%
name|ds
name|movl
operator|%
name|ax
operator|,
operator|%
name|es
name|movl
operator|%
name|ax
operator|,
operator|%
name|ss
name|word
name|ljmp
name|$0x8
operator|,
name|$
name|BIOSRELOC
operator|+
literal|0xb3
comment|/* would be nice if .-RELOC+0x7c00 worked */
comment|/* Global Descriptor Table contains three descriptors:   * 0x00: Null: not used   * 0x08: Code: code segment starts at 0 and extents for 4 gigabytes   * 0x10: Data: data segment starts at 0 and extends for 4 gigabytes   *		(overlays code)   */
name|GDT
operator|:
name|NullDesc
operator|:
operator|.
name|word
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|#
name|null
name|descriptor
operator|-
name|not
name|used
name|CodeDesc
operator|:
operator|.
name|word
literal|0xFFFF
operator|#
name|limit
name|at
name|maximum
operator|:
operator|(
name|bits
literal|15
operator|:
literal|0
operator|)
operator|.
name|byte
literal|0
operator|,
literal|0
operator|,
literal|0
operator|#
name|base
name|at
literal|0
operator|:
operator|(
name|bits
literal|23
operator|:
literal|0
operator|)
operator|.
name|byte
literal|0x9f
operator|#
name|present
operator|/
name|priv
name|level
literal|0
operator|/
name|code
operator|/
name|conforming
operator|/
name|readable
operator|.
name|byte
literal|0xcf
operator|#
name|page
name|granular
operator|/
expr|default
literal|32
operator|-
name|bit
operator|/
name|limit
argument_list|(
name|bits
literal|19
operator|:
literal|16
argument_list|)
operator|.
name|byte
literal|0
operator|#
name|base
name|at
literal|0
operator|:
operator|(
name|bits
literal|31
operator|:
literal|24
operator|)
name|DataDesc
operator|:
operator|.
name|word
literal|0xFFFF
operator|#
name|limit
name|at
name|maximum
operator|:
operator|(
name|bits
literal|15
operator|:
literal|0
operator|)
operator|.
name|byte
literal|0
operator|,
literal|0
operator|,
literal|0
operator|#
name|base
name|at
literal|0
operator|:
operator|(
name|bits
literal|23
operator|:
literal|0
operator|)
operator|.
name|byte
literal|0x93
operator|#
name|present
operator|/
name|priv
name|level
literal|0
operator|/
name|data
operator|/
name|expand
operator|-
name|up
operator|/
name|writeable
operator|.
name|byte
literal|0xcf
operator|#
name|page
name|granular
operator|/
expr|default
literal|32
operator|-
name|bit
operator|/
name|limit
argument_list|(
name|bits
literal|19
operator|:
literal|16
argument_list|)
operator|.
name|byte
literal|0
operator|#
name|base
name|at
literal|0
operator|:
operator|(
name|bits
literal|31
operator|:
literal|24
operator|)
comment|/* Global Descriptor Table pointer  *  contains 6-byte pointer information for LGDT  */
name|GDTptr
operator|:
operator|.
name|word
literal|0x17
operator|#
name|limit
name|to
name|three
literal|8
name|byte
name|selectors
argument_list|(
name|null
argument_list|,
name|code
argument_list|,
name|data
argument_list|)
operator|.
name|long
name|BIOSRELOC
operator|+
literal|0x8c
operator|#
name|GDT
operator|--
name|arrgh
operator|,
name|gas
name|again
operator|!
name|readcmd
operator|:
operator|.
name|byte
literal|0xe6
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|2
operator|,
literal|18
operator|,
literal|0x1b
operator|,
literal|0xff
comment|/* step 4 relocate to final bootstrap address. */
name|reloc
operator|:
name|movl
name|$
name|BIOSRELOC
operator|,
operator|%
name|esi
name|movl
name|$
name|RELOC
operator|,
operator|%
name|edi
name|movl
name|$512
operator|,
operator|%
name|ecx
name|rep
name|movsb
name|movl
name|$0xa0000
operator|,
operator|%
name|esp
name|pushl
name|$dodisk
name|ret
comment|/* step 5 load remaining 15 sectors off disk */
name|dodisk
operator|:
name|movl
name|$
name|RELOC
operator|+
literal|0x200
operator|,
operator|%
name|edi
name|xorl
operator|%
name|ebx
operator|,
operator|%
name|ebx
name|incb
operator|%
name|bl
operator|#
name|shl
name|$1
operator|,
operator|%
name|bl
name|incb
operator|%
name|bl
name|movb
name|$0x20
operator|,
operator|%
name|al
operator|#
end_expr_stmt

begin_do
do|do
name|a
name|eoi
name|outb
operator|%
name|al
operator|,
name|$0x20
name|NOP
name|movb
name|$0xbf
operator|,
operator|%
name|al
operator|#
name|enable
name|floppy
name|interrupt
operator|,
name|mask
name|out
name|rest
name|outb
operator|%
name|al
operator|,
name|$0x21
name|NOP
literal|8
operator|:
name|movb
operator|%
name|bl
operator|,
name|readcmd
operator|+
literal|4
name|movl
operator|%
name|edi
operator|,
operator|%
name|ecx
comment|/* Set read/write bytes */
name|xorl
operator|%
name|edx
operator|,
operator|%
name|edx
name|movb
name|$0x0c
operator|,
operator|%
name|dl
operator|#
name|outb
argument_list|(
literal|0xC
argument_list|,
name|junk
argument_list|)
expr_stmt|;
do|outb(0xB
operator|,
do|0x46
end_do

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
operator|#
name|reset
name|DMA
name|controller
name|first
operator|/
name|last
name|flip
operator|-
name|flop
name|NOP
name|decb
operator|%
name|dx
name|movb
name|$0x46
operator|,
operator|%
name|al
operator|#
name|single
name|mode
operator|,
name|write
name|mem
operator|,
name|chan
literal|2
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
operator|#
name|output
name|DMA
name|controller
name|mode
name|byte
comment|/* Send start address */
name|movb
name|$0x04
operator|,
operator|%
name|dl
operator|#
name|outb
argument_list|(
literal|0x4
argument_list|,
name|addr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|movb
operator|%
name|cl
operator|,
operator|%
name|al
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
name|movb
operator|%
name|ch
operator|,
operator|%
name|al
operator|#
name|outb
argument_list|(
literal|0x4
argument_list|,
name|addr
operator|>>
literal|8
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
name|rorl
name|$8
operator|,
operator|%
name|ecx
operator|#
name|outb
argument_list|(
literal|0x81
argument_list|,
name|addr
operator|>>
literal|16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|movb
operator|%
name|ch
operator|,
operator|%
name|al
name|outb
operator|%
name|al
operator|,
name|$0x81
name|NOP
comment|/* Send count */
name|movb
name|$0x05
operator|,
operator|%
name|dl
operator|#
name|outb
argument_list|(
literal|0x5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xorl
operator|%
name|eax
operator|,
operator|%
name|eax
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
name|movb
name|$2
operator|,
operator|%
name|al
operator|#
name|outb
argument_list|(
literal|0x5
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
comment|/* set channel 2 */
name|movb
name|$2
operator|,
operator|%
name|al
operator|#
name|outb
argument_list|(
literal|0x0A
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|outb
operator|%
name|al
operator|,
name|$0x0A
name|NOP
comment|/* issue read command to fdc */
name|movw
name|$0x3f4
operator|,
operator|%
name|dx
name|movl
name|$readcmd
operator|,
operator|%
name|esi
name|xorl
operator|%
name|ecx
operator|,
operator|%
name|ecx
name|movb
name|$9
operator|,
operator|%
name|cl
literal|2
operator|:
name|NOP
name|inb
operator|%
name|dx
operator|,
operator|%
name|al
name|testb
name|$0x80
operator|,
operator|%
name|al
name|jz
literal|2b
name|incb
operator|%
name|dx
name|NOP
name|movl
argument_list|(
operator|%
name|esi
argument_list|)
operator|,
operator|%
name|al
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
name|incl
operator|%
name|esi
name|decb
operator|%
name|dx
name|loop
literal|2b
comment|/* watch the icu looking for an interrupt signalling completion */
name|xorl
operator|%
name|edx
operator|,
operator|%
name|edx
name|movb
name|$0x20
operator|,
operator|%
name|dl
literal|2
operator|:
name|NOP
name|movb
name|$0xc
operator|,
operator|%
name|al
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
name|inb
operator|%
name|dx
operator|,
operator|%
name|al
name|andb
name|$0x7f
operator|,
operator|%
name|al
name|cmpb
name|$6
operator|,
operator|%
name|al
name|jne
literal|2b
name|NOP
name|movb
name|$0x20
operator|,
operator|%
name|al
operator|#
end_expr_stmt

begin_do
do|do
name|a
name|eoi
name|outb
operator|%
name|al
operator|,
operator|%
name|dx
name|NOP
name|movl
name|$0x3f4
operator|,
operator|%
name|edx
name|xorl
operator|%
name|ecx
operator|,
operator|%
name|ecx
name|movb
name|$7
operator|,
operator|%
name|cl
literal|2
operator|:
name|NOP
name|inb
operator|%
name|dx
operator|,
operator|%
name|al
name|andb
name|$0xC0
operator|,
operator|%
name|al
name|cmpb
name|$0xc0
operator|,
operator|%
name|al
name|jne
literal|2b
name|incb
operator|%
name|dx
name|inb
operator|%
name|dx
operator|,
operator|%
name|al
name|decb
operator|%
name|dx
name|loop
literal|2b
comment|/* extract the status bytes after the read. must we do this? */
name|addw
name|$0x200
operator|,
operator|%
name|edi
operator|#
name|next
name|addr
name|to
name|load
name|to
name|incb
operator|%
name|bl
name|cmpb
name|$15
operator|,
operator|%
name|bl
name|jle
literal|8b
comment|/* for clever bootstrap, dig out boot unit and cylinder */
name|pushl
name|$0
name|pushl
name|$0
comment|/* fd controller is major device 2 */
name|pushl
name|$2
comment|/* dev */
comment|/* sorry, no flags at this point! */
name|movl
name|$
name|start
operator|,
operator|%
name|eax
name|call
operator|%
name|eax
comment|/* main (dev, unit, off) */
name|ebootblkcode
operator|:
comment|/* remaining space usable for a disk label */
operator|.
name|org
literal|0x1fe
operator|.
name|word
literal|0xaa55
comment|/* signature -- used by BIOS ROM */
name|ebootblk
operator|:
end_do

begin_comment
comment|/* MUST BE EXACTLY 0x200 BIG FOR SURE */
end_comment

end_unit

