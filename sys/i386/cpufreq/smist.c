begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005 Bruno Ducrot  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This driver is based upon information found by examining speedstep-0.5  * from Marc Lehman, which includes all the reverse engineering effort of  * Malik Martin (function 1 and 2 of the GSI).  *  * The correct way for the OS to take ownership from the BIOS was found by  * Hiroshi Miura (function 0 of the GSI).  *  * Finally, the int 15h call interface was (partially) documented by Intel.  *  * Many thanks to Jon Noack for testing and debugging this driver.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/vm86.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|"cpufreq_if.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|DPRINT
parameter_list|(
name|dev
parameter_list|,
name|x
modifier|...
parameter_list|)
value|device_printf(dev, x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINT
parameter_list|(
name|dev
parameter_list|,
name|x
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|smist_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|smi_cmd
decl_stmt|;
name|int
name|smi_data
decl_stmt|;
name|int
name|command
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|cf_setting
name|sets
index|[
literal|2
index|]
decl_stmt|;
comment|/* Only two settings. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
name|smist_magic
index|[]
init|=
literal|"Copyright (c) 1999 Intel Corporation"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|smist_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smist_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smist_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smist_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smist_settings
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cf_setting
modifier|*
name|sets
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smist_set
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|cf_setting
modifier|*
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smist_get
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cf_setting
modifier|*
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smist_type
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|smist_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|smist_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|smist_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|smist_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|smist_detach
argument_list|)
block|,
comment|/* cpufreq interface */
name|DEVMETHOD
argument_list|(
name|cpufreq_drv_set
argument_list|,
name|smist_set
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cpufreq_drv_get
argument_list|,
name|smist_get
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cpufreq_drv_type
argument_list|,
name|smist_type
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cpufreq_drv_settings
argument_list|,
name|smist_settings
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|smist_driver
init|=
block|{
literal|"smist"
block|,
name|smist_methods
block|,
expr|sizeof
operator|(
expr|struct
name|smist_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|smist_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|smist
argument_list|,
name|cpu
argument_list|,
name|smist_driver
argument_list|,
name|smist_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|piix4_pci_device
block|{
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|piix4_pci_device
name|piix4_pci_devices
index|[]
init|=
block|{
block|{
literal|0x8086
block|,
literal|0x7113
block|,
literal|"Intel PIIX4 ISA bridge"
block|}
block|,
block|{
literal|0x8086
block|,
literal|0x719b
block|,
literal|"Intel PIIX4 ISA bridge (embedded in MX440 chipset)"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SET_OWNERSHIP
value|0
end_define

begin_define
define|#
directive|define
name|GET_STATE
value|1
end_define

begin_define
define|#
directive|define
name|SET_STATE
value|2
end_define

begin_function
specifier|static
name|int
name|int15_gsic_call
parameter_list|(
name|int
modifier|*
name|sig
parameter_list|,
name|int
modifier|*
name|smi_cmd
parameter_list|,
name|int
modifier|*
name|command
parameter_list|,
name|int
modifier|*
name|smi_data
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x0000E980
expr_stmt|;
comment|/* IST support */
name|vmf
operator|.
name|vmf_edx
operator|=
literal|0x47534943
expr_stmt|;
comment|/* 'GSIC' in ASCII */
name|vm86_intcall
argument_list|(
literal|0x15
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmf
operator|.
name|vmf_eax
operator|==
literal|0x47534943
condition|)
block|{
operator|*
name|sig
operator|=
name|vmf
operator|.
name|vmf_eax
expr_stmt|;
operator|*
name|smi_cmd
operator|=
name|vmf
operator|.
name|vmf_ebx
operator|&
literal|0xff
expr_stmt|;
operator|*
name|command
operator|=
operator|(
name|vmf
operator|.
name|vmf_ebx
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|smi_data
operator|=
name|vmf
operator|.
name|vmf_ecx
expr_stmt|;
operator|*
name|flags
operator|=
name|vmf
operator|.
name|vmf_edx
expr_stmt|;
block|}
else|else
block|{
operator|*
name|sig
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|smi_cmd
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|command
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|smi_data
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|flags
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Temporary structure to hold mapped page and status. */
end_comment

begin_struct
struct|struct
name|set_ownership_data
block|{
name|int
name|smi_cmd
decl_stmt|;
name|int
name|command
decl_stmt|;
name|int
name|result
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Perform actual SMI call to enable SpeedStep. */
end_comment

begin_function
specifier|static
name|void
name|set_ownership_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|set_ownership_data
modifier|*
name|data
decl_stmt|;
name|data
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|data
operator|->
name|result
operator|=
name|error
expr_stmt|;
return|return;
block|}
comment|/* Copy in the magic string and send it by writing to the SMI port. */
name|strlcpy
argument_list|(
name|data
operator|->
name|buf
argument_list|,
name|smist_magic
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
asm|__asm __volatile(
literal|"movl $-1, %%edi\n\t"
literal|"out %%al, (%%dx)\n"
operator|:
literal|"=D"
operator|(
name|data
operator|->
name|result
operator|)
operator|:
literal|"a"
operator|(
name|data
operator|->
name|command
operator|)
operator|,
literal|"b"
operator|(
literal|0
operator|)
operator|,
literal|"c"
operator|(
literal|0
operator|)
operator|,
literal|"d"
operator|(
name|data
operator|->
name|smi_cmd
operator|)
operator|,
literal|"S"
operator|(
operator|(
name|uint32_t
operator|)
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|)
block|)
function|;
end_function

begin_function
unit|}  static
name|int
name|set_ownership
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|smist_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|set_ownership_data
name|cb_data
decl_stmt|;
name|bus_dma_tag_t
name|tag
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
comment|/* 	 * Specify the region to store the magic string.  Since its address is 	 * passed to the BIOS in a 32-bit register, we have to make sure it is 	 * located in a physical page below 4 GB (i.e., for PAE.) 	 */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
comment|/*parent*/
name|NULL
argument_list|,
comment|/*alignment*/
name|PAGE_SIZE
argument_list|,
comment|/*no boundary*/
literal|0
argument_list|,
comment|/*lowaddr*/
name|BUS_SPACE_MAXADDR_32BIT
argument_list|,
comment|/*highaddr*/
name|BUS_SPACE_MAXADDR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/*maxsize*/
name|PAGE_SIZE
argument_list|,
comment|/*segments*/
literal|1
argument_list|,
comment|/*maxsegsize*/
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|busdma_lock_mutex
argument_list|,
operator|&
name|Giant
argument_list|,
operator|&
name|tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't create mem tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|bus_dmamem_alloc
argument_list|(
name|tag
argument_list|,
operator|&
name|cb_data
operator|.
name|buf
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|map
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't alloc mapped mem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Load the physical page map and take ownership in the callback. */
name|cb_data
operator|.
name|smi_cmd
operator|=
name|sc
operator|->
name|smi_cmd
expr_stmt|;
name|cb_data
operator|.
name|command
operator|=
name|sc
operator|->
name|command
expr_stmt|;
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|tag
argument_list|,
name|map
argument_list|,
name|cb_data
operator|.
name|buf
argument_list|,
name|PAGE_SIZE
argument_list|,
name|set_ownership_cb
argument_list|,
operator|&
name|cb_data
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|tag
argument_list|,
name|cb_data
operator|.
name|buf
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|tag
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't load mem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
empty_stmt|;
name|DPRINT
argument_list|(
name|dev
argument_list|,
literal|"taking ownership over BIOS return %d\n"
argument_list|,
name|cb_data
operator|.
name|result
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|tag
argument_list|,
name|cb_data
operator|.
name|buf
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|cb_data
operator|.
name|result
condition|?
name|ENXIO
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getset_state
parameter_list|(
name|struct
name|smist_softc
modifier|*
name|sc
parameter_list|,
name|int
modifier|*
name|state
parameter_list|,
name|int
name|function
parameter_list|)
block|{
name|int
name|new_state
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|eax
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|function
operator|!=
name|GET_STATE
operator|&&
name|function
operator|!=
name|SET_STATE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|DPRINT
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"calling GSI\n"
argument_list|)
expr_stmt|;
asm|__asm __volatile(
literal|"movl $-1, %%edi\n\t"
literal|"out %%al, (%%dx)\n"
operator|:
literal|"=a"
operator|(
name|eax
operator|)
operator|,
literal|"=b"
operator|(
name|new_state
operator|)
operator|,
literal|"=D"
operator|(
name|result
operator|)
operator|:
literal|"a"
operator|(
name|sc
operator|->
name|command
operator|)
operator|,
literal|"b"
operator|(
name|function
operator|)
operator|,
literal|"c"
operator|(
operator|*
name|state
operator|)
operator|,
literal|"d"
operator|(
name|sc
operator|->
name|smi_cmd
operator|)
block|)
function|;
end_function

begin_expr_stmt
name|DPRINT
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"GSI returned: eax %.8x ebx %.8x edi %.8x\n"
argument_list|,
name|eax
argument_list|,
name|new_state
argument_list|,
name|result
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|state
operator|=
name|new_state
operator|&
literal|1
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|function
condition|)
block|{
case|case
name|GET_STATE
case|:
if|if
condition|(
name|eax
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
case|case
name|SET_STATE
case|:
if|if
condition|(
name|result
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
block|}
end_switch

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_function
unit|}  static
name|void
name|smist_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|struct
name|piix4_pci_device
modifier|*
name|id
decl_stmt|;
name|device_t
name|piix4
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"ichst"
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* Check for a supported processor */
if|if
condition|(
name|cpu_vendor_id
operator|!=
name|CPU_VENDOR_INTEL
condition|)
return|return;
switch|switch
condition|(
name|cpu_id
operator|&
literal|0xff0
condition|)
block|{
case|case
literal|0x680
case|:
comment|/* Pentium III [coppermine] */
case|case
literal|0x6a0
case|:
comment|/* Pentium III [Tualatin] */
break|break;
default|default:
return|return;
block|}
comment|/* Check for a supported PCI-ISA bridge */
for|for
control|(
name|id
operator|=
name|piix4_pci_devices
init|;
name|id
operator|->
name|desc
operator|!=
name|NULL
condition|;
operator|++
name|id
control|)
block|{
if|if
condition|(
operator|(
name|piix4
operator|=
name|pci_find_device
argument_list|(
name|id
operator|->
name|vendor
argument_list|,
name|id
operator|->
name|device
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|piix4
condition|)
return|return;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"smist: found supported isa bridge %s\n"
argument_list|,
name|id
operator|->
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_find_child
argument_list|(
name|parent
argument_list|,
literal|"smist"
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|30
argument_list|,
literal|"smist"
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"smist: add child failed\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|smist_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|smist_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|ichss_dev
decl_stmt|,
name|perf_dev
decl_stmt|;
name|int
name|sig
decl_stmt|,
name|smi_cmd
decl_stmt|,
name|command
decl_stmt|,
name|smi_data
decl_stmt|,
name|flags
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"smist"
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * If the ACPI perf or ICH SpeedStep drivers have attached and not 	 * just offering info, let them manage things. 	 */
name|perf_dev
operator|=
name|device_find_child
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"acpi_perf"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|perf_dev
operator|&&
name|device_is_attached
argument_list|(
name|perf_dev
argument_list|)
condition|)
block|{
name|rv
operator|=
name|CPUFREQ_DRV_TYPE
argument_list|(
name|perf_dev
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
operator|&&
operator|(
name|type
operator|&
name|CPUFREQ_FLAG_INFO_ONLY
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ichss_dev
operator|=
name|device_find_child
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"ichss"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ichss_dev
operator|&&
name|device_is_attached
argument_list|(
name|ichss_dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|int15_gsic_call
argument_list|(
operator|&
name|sig
argument_list|,
operator|&
name|smi_cmd
argument_list|,
operator|&
name|command
argument_list|,
operator|&
name|smi_data
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"sig %.8x smi_cmd %.4x command %.2x "
literal|"smi_data %.4x flags %.8x\n"
argument_list|,
name|sig
argument_list|,
name|smi_cmd
argument_list|,
name|command
argument_list|,
name|smi_data
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|!=
operator|-
literal|1
condition|)
block|{
name|sc
operator|->
name|smi_cmd
operator|=
name|smi_cmd
expr_stmt|;
name|sc
operator|->
name|smi_data
operator|=
name|smi_data
expr_stmt|;
comment|/* 		 * Sometimes int 15h 'GSIC' returns 0x80 for command, when 		 * it is actually 0x82.  The Windows driver will overwrite 		 * this value given by the registry. 		 */
if|if
condition|(
name|command
operator|==
literal|0x80
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"GSIC returned cmd 0x80, should be 0x82\n"
argument_list|)
expr_stmt|;
name|command
operator|=
literal|0x82
expr_stmt|;
block|}
name|sc
operator|->
name|command
operator|=
operator|(
name|sig
operator|&
literal|0xffffff00
operator|)
operator||
operator|(
name|command
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
block|}
else|else
block|{
comment|/* Give some default values */
name|sc
operator|->
name|smi_cmd
operator|=
literal|0xb2
expr_stmt|;
name|sc
operator|->
name|smi_data
operator|=
literal|0xb3
expr_stmt|;
name|sc
operator|->
name|command
operator|=
literal|0x47534982
expr_stmt|;
name|sc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"SpeedStep SMI"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1500
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smist_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|smist_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* If we can't take ownership over BIOS, then bail out */
if|if
condition|(
name|set_ownership
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Setup some defaults for our exported settings. */
name|sc
operator|->
name|sets
index|[
literal|0
index|]
operator|.
name|freq
operator|=
name|CPUFREQ_VAL_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|sets
index|[
literal|0
index|]
operator|.
name|volts
operator|=
name|CPUFREQ_VAL_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|sets
index|[
literal|0
index|]
operator|.
name|power
operator|=
name|CPUFREQ_VAL_UNKNOWN
expr_stmt|;
name|sc
operator|->
name|sets
index|[
literal|0
index|]
operator|.
name|lat
operator|=
literal|1000
expr_stmt|;
name|sc
operator|->
name|sets
index|[
literal|0
index|]
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sets
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|sets
index|[
literal|0
index|]
expr_stmt|;
name|cpufreq_register
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smist_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|cpufreq_unregister
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smist_settings
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cf_setting
modifier|*
name|sets
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|struct
name|smist_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cf_setting
name|set
decl_stmt|;
name|int
name|first
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|sets
operator|==
name|NULL
operator|||
name|count
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|*
name|count
operator|<
literal|2
condition|)
block|{
operator|*
name|count
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Estimate frequencies for both levels, temporarily switching to 	 * the other one if we haven't calibrated it yet. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sets
index|[
name|i
index|]
operator|.
name|freq
operator|==
name|CPUFREQ_VAL_UNKNOWN
condition|)
block|{
name|first
operator|=
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|smist_set
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|sets
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|smist_get
argument_list|(
name|dev
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
name|smist_set
argument_list|(
name|dev
argument_list|,
operator|&
name|sc
operator|->
name|sets
index|[
name|first
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|bcopy
argument_list|(
name|sc
operator|->
name|sets
argument_list|,
name|sets
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sets
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smist_set
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|cf_setting
modifier|*
name|set
parameter_list|)
block|{
name|struct
name|smist_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|state
decl_stmt|,
name|req_state
decl_stmt|,
name|try
decl_stmt|;
comment|/* Look up appropriate bit value based on frequency. */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPUFREQ_CMP
argument_list|(
name|set
operator|->
name|freq
argument_list|,
name|sc
operator|->
name|sets
index|[
literal|0
index|]
operator|.
name|freq
argument_list|)
condition|)
name|req_state
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|CPUFREQ_CMP
argument_list|(
name|set
operator|->
name|freq
argument_list|,
name|sc
operator|->
name|sets
index|[
literal|1
index|]
operator|.
name|freq
argument_list|)
condition|)
name|req_state
operator|=
literal|1
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
name|DPRINT
argument_list|(
name|dev
argument_list|,
literal|"requested setting %d\n"
argument_list|,
name|req_state
argument_list|)
expr_stmt|;
name|rv
operator|=
name|getset_state
argument_list|(
name|sc
argument_list|,
operator|&
name|state
argument_list|,
name|GET_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|req_state
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|try
operator|=
literal|3
expr_stmt|;
do|do
block|{
name|rv
operator|=
name|getset_state
argument_list|(
name|sc
argument_list|,
operator|&
name|req_state
argument_list|,
name|SET_STATE
argument_list|)
expr_stmt|;
comment|/* Sleep for 200 microseconds.  This value is just a guess. */
if|if
condition|(
name|rv
condition|)
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|rv
operator|&&
operator|--
name|try
condition|)
do|;
name|DPRINT
argument_list|(
name|dev
argument_list|,
literal|"set_state return %d, tried %d times\n"
argument_list|,
name|rv
argument_list|,
literal|4
operator|-
name|try
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smist_get
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cf_setting
modifier|*
name|set
parameter_list|)
block|{
name|struct
name|smist_softc
modifier|*
name|sc
decl_stmt|;
name|uint64_t
name|rate
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rv
operator|=
name|getset_state
argument_list|(
name|sc
argument_list|,
operator|&
name|state
argument_list|,
name|GET_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
comment|/* If we haven't changed settings yet, estimate the current value. */
if|if
condition|(
name|sc
operator|->
name|sets
index|[
name|state
index|]
operator|.
name|freq
operator|==
name|CPUFREQ_VAL_UNKNOWN
condition|)
block|{
name|cpu_est_clockrate
argument_list|(
literal|0
argument_list|,
operator|&
name|rate
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sets
index|[
name|state
index|]
operator|.
name|freq
operator|=
name|rate
operator|/
literal|1000000
expr_stmt|;
name|DPRINT
argument_list|(
name|dev
argument_list|,
literal|"get calibrated new rate of %d\n"
argument_list|,
name|sc
operator|->
name|sets
index|[
name|state
index|]
operator|.
name|freq
argument_list|)
expr_stmt|;
block|}
operator|*
name|set
operator|=
name|sc
operator|->
name|sets
index|[
name|state
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smist_type
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|type
operator|=
name|CPUFREQ_TYPE_ABSOLUTE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

