begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*      Copyright 1992 by Holger Veit  *	May be freely used with Bill Jolitz's port of   *	386bsd and may be included in a 386bsd collection  *	as long as binary and source are available and reproduce the above  *	copyright.  *  *	You may freely modify this code and contribute improvements based  *	on this code as long as you don't claim to be the original author.  *	Commercial use of this source requires permittance of the copyright   *	holder. A general license for 386bsd will override this restriction.  *  *	Use at your own risk. The copyright holder or any person who makes  *	this code available for the public (administrators of public archives  *	for instance) are not responsible for any harm to hardware or software  *	that might happen due to wrong application or program faults.  *  *	@(#) $RCSfile$	$Revision$ (Contributed to 386bsd) $Date$  *  *	History: see CO_HISTORY  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header$"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This file provides a real mini terminal emulator, basically one that  * has only the cursor functions, screen clear/home, DEL, TAB, BEL,  * but no attributes etc.  * This interface is used for a installation kernel which must be   * small enough to fit on a diskette.  */
end_comment

begin_comment
comment|/* check my optional symbol to avoid multiple inclusions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MINITERM
end_ifdef

begin_define
define|#
directive|define
name|COMPAT_CO011
end_define

begin_include
include|#
directive|include
file|"co_hdr.h"
end_include

begin_include
include|#
directive|include
file|"vty.h"
end_include

begin_define
define|#
directive|define
name|ESC_NONE
value|0
end_define

begin_comment
comment|/* No esc in progress */
end_comment

begin_define
define|#
directive|define
name|ESC_WBRAC
value|1
end_define

begin_comment
comment|/* got esc, wait for '[' or 'c' */
end_comment

begin_define
define|#
directive|define
name|ESC_WPARAM
value|2
end_define

begin_comment
comment|/* got esc [, wait for param, ';' or letter */
end_comment

begin_comment
comment|/*  *	Do the local initialisations. Notice that many things are already done  *	in vty_init  */
end_comment

begin_function
name|void
name|vtemul_init
parameter_list|()
block|{
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|id
init|=
literal|"coinst"
decl_stmt|;
name|XCHAR
modifier|*
name|xc
decl_stmt|;
name|Keycap_def
modifier|*
name|kp
decl_stmt|;
name|struct
name|Keycap2
modifier|*
name|k2
decl_stmt|;
comment|/* fill the cons_capabilities structure 	 * Don't use strcpy here! 	 */
name|c
operator|=
name|id
expr_stmt|;
name|xc
operator|=
name|cons_capabilities
operator|.
name|emul_name
expr_stmt|;
while|while
condition|(
operator|*
name|xc
operator|++
operator|=
name|xc_char2xc
argument_list|(
operator|*
name|c
operator|++
argument_list|)
condition|)
empty_stmt|;
define|#
directive|define
name|copydef
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
define|\
value|xc_bcopy(src,dst,KBDDEFOVLKEYSIZE)
block|}
end_function

begin_comment
comment|/*  *	this routine does all the ESC and character processing stuff  */
end_comment

begin_function
name|void
name|vtemul_exec
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|XCHAR
name|ch
parameter_list|)
block|{
name|int
name|inccol
decl_stmt|,
name|par1
decl_stmt|,
name|par2
decl_stmt|;
name|int
name|sc
init|=
literal|1
decl_stmt|;
comment|/* do scroll check */
name|u_short
name|at
decl_stmt|,
name|sat
decl_stmt|;
name|struct
name|outmode
modifier|*
name|sk
init|=
name|vp
operator|->
name|op
decl_stmt|;
comment|/* which attributes do we use? */
name|at
operator|=
name|sk
operator|->
name|fg_at
operator||
name|sk
operator|->
name|bg_at
expr_stmt|;
name|sat
operator|=
name|vp
operator|->
name|so_at
expr_stmt|;
comment|/* translate to proper font */
name|ch
operator|=
name|vga_xlatiso646
argument_list|(
name|vp
argument_list|,
operator|&
name|at
argument_list|,
operator|&
name|sat
argument_list|,
name|ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|0x1B
case|:
if|if
condition|(
name|sk
operator|->
name|escstate
operator|!=
name|ESC_NONE
condition|)
name|emul_wrtchar
argument_list|(
name|vp
argument_list|,
name|ch
argument_list|,
name|sat
argument_list|)
expr_stmt|;
else|else
name|sk
operator|->
name|escstate
operator|=
name|ESC_WBRAC
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|inccol
operator|=
operator|(
literal|8
operator|-
name|vp
operator|->
name|col
operator|%
literal|8
operator|)
expr_stmt|;
comment|/* non-destructive tab */
name|emul_cursorrelative
argument_list|(
name|vp
argument_list|,
name|inccol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\010'
case|:
name|emul_cursorleft
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|emul_cursorrelative
argument_list|(
name|vp
argument_list|,
operator|-
name|vp
operator|->
name|col
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|emul_cursorrelative
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x07
case|:
comment|/* different sounds for different vtys possible */
name|sysbeep
argument_list|(
name|vp
operator|->
name|pitch
argument_list|,
name|vp
operator|->
name|duration
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* ESC Processing */
switch|switch
condition|(
name|sk
operator|->
name|escstate
condition|)
block|{
default|default:
case|case
name|ESC_NONE
case|:
comment|/* NO ESC, normal processing */
name|emul_wrtchar
argument_list|(
name|vp
argument_list|,
name|ch
argument_list|,
name|vp
operator|->
name|so
condition|?
name|sat
else|:
name|at
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|col
operator|>=
name|vp
operator|->
name|ncol
condition|)
name|vp
operator|->
name|col
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ESC_WBRAC
case|:
comment|/* has seen ESC, wait for [ or 'c' */
if|if
condition|(
name|ch
operator|==
literal|'['
condition|)
block|{
name|sk
operator|->
name|escstate
operator|=
name|ESC_WPARAM
expr_stmt|;
name|sk
operator|->
name|parcnt
operator|=
literal|0
expr_stmt|;
name|sk
operator|->
name|param
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sk
operator|->
name|param
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'c'
condition|)
block|{
comment|/* Clear screen& home */
name|emul_clearcursor
argument_list|(
name|vp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|emul_cursormove
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sk
operator|->
name|escstate
operator|=
name|ESC_NONE
expr_stmt|;
block|}
else|else
block|{
comment|/* error */
name|sk
operator|->
name|escstate
operator|=
name|ESC_NONE
expr_stmt|;
name|emul_wrtchar
argument_list|(
name|vp
argument_list|,
name|ch
argument_list|,
name|sat
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ESC_WPARAM
case|:
comment|/* has seen ESC [ wait for digit, ';' or letter */
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
block|{
name|sk
operator|->
name|param
index|[
name|sk
operator|->
name|parcnt
index|]
operator|*=
literal|10
expr_stmt|;
name|sk
operator|->
name|param
index|[
name|sk
operator|->
name|parcnt
index|]
operator|+=
name|ch
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
name|sk
operator|->
name|parcnt
operator|>=
literal|2
condition|)
block|{
name|sk
operator|->
name|escstate
operator|=
name|ESC_NONE
expr_stmt|;
comment|/* error */
name|emul_wrtchar
argument_list|(
name|vp
argument_list|,
name|ch
argument_list|,
name|sat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sk
operator|->
name|parcnt
operator|++
expr_stmt|;
name|sk
operator|->
name|param
index|[
name|sk
operator|->
name|parcnt
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|' '
operator|&&
name|ch
operator|<=
literal|'~'
condition|)
block|{
name|par1
operator|=
name|sk
operator|->
name|param
index|[
literal|0
index|]
expr_stmt|;
name|par2
operator|=
name|sk
operator|->
name|param
index|[
literal|1
index|]
expr_stmt|;
name|sk
operator|->
name|parcnt
operator|++
expr_stmt|;
name|sk
operator|->
name|param
index|[
name|sk
operator|->
name|parcnt
index|]
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* back cx rows */
name|emul_cursorup
argument_list|(
name|vp
argument_list|,
name|par1
argument_list|)
expr_stmt|;
name|sc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* down cx rows */
name|emul_cursordown
argument_list|(
name|vp
argument_list|,
name|par1
argument_list|)
expr_stmt|;
name|sc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* right cursor */
name|emul_cursorright
argument_list|(
name|vp
argument_list|,
name|par1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* left cursor */
name|emul_cursorleft
argument_list|(
name|vp
argument_list|,
name|par1
argument_list|)
expr_stmt|;
name|sc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* Cursor move */
name|emul_cursormove
argument_list|(
name|vp
argument_list|,
name|par1
argument_list|,
name|par2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|emul_wrtchar
argument_list|(
name|vp
argument_list|,
name|ch
argument_list|,
name|sat
argument_list|)
expr_stmt|;
block|}
name|sk
operator|->
name|escstate
operator|=
name|ESC_NONE
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|sc
operator|&&
name|emul_checkcursor
argument_list|(
name|vp
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|consoftc
operator|.
name|cs_flags
operator|&
name|CO_OPEN
condition|)
do|do
operator|(
name|void
operator|)
name|kbd_sgetc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
name|vp
operator|->
name|scroll
condition|)
do|;
name|emul_scrollup
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	The following part provides a basic set of ioctls  */
end_comment

begin_function
name|void
name|coioctl_init
parameter_list|()
block|{}
end_function

begin_function
name|int
name|consioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|error
expr_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
name|dev2tty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
name|ENXIO
return|;
comment|/* mandatory */
if|if
condition|(
name|cmd
operator|==
name|CONSGINFO
condition|)
block|{
operator|*
operator|(
operator|(
expr|struct
name|consinfo
operator|*
operator|)
name|data
operator|)
operator|=
name|cons_capabilities
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|OLDCONSGINFO
condition|)
block|{
operator|(
operator|(
expr|struct
name|oldconsinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|info1
operator|=
name|cons_capabilities
operator|.
name|info1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* must be executed for backward compatibility 	 * must be executed *after* the tty ioctls, 	 * because it shares an essential ioctl with them. 	 */
name|error
operator|=
name|kbdioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
name|error
operator|==
literal|0
condition|?
literal|0
else|:
name|ENOTTY
return|;
block|}
end_function

begin_comment
comment|/*  *	process keyboard ioctls  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ofl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|kbdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|n
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|vty
modifier|*
name|vp
init|=
name|dev2vty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* CONSGINFO is mandatory ! */
case|case
name|CONSGINFO
case|:
operator|*
operator|(
operator|(
expr|struct
name|consinfo
operator|*
operator|)
name|data
operator|)
operator|=
name|cons_capabilities
expr_stmt|;
return|return
literal|0
return|;
case|case
name|OLDCONSGINFO
case|:
operator|(
operator|(
expr|struct
name|oldconsinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|info1
operator|=
name|cons_capabilities
operator|.
name|info1
expr_stmt|;
return|return
literal|0
return|;
comment|/* this is a relic from my youth mistakes */
return|return
literal|0
return|;
case|case
name|KBDCOLDRESET
case|:
name|kbd_coldreset
argument_list|()
expr_stmt|;
name|kbd_ovlinit
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDGCKEY
case|:
return|return
name|kbd_getckeydef
argument_list|(
operator|(
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
operator|)
operator|->
name|keynum
argument_list|,
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDSCKEY
case|:
return|return
name|kbd_setkeydef
argument_list|(
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDGOKEY
case|:
return|return
name|kbd_getokeydef
argument_list|(
operator|(
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
operator|)
operator|->
name|keynum
argument_list|,
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDRMKEY
case|:
return|return
name|kbd_rmkeydef
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDDEFAULT
case|:
name|kbd_ovlinit
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDSCLRLYR
case|:
name|kbs
operator|.
name|a0flag
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|kbs
operator|.
name|c0flag
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
literal|2
operator|)
operator|!=
literal|0
expr_stmt|;
name|kbs
operator|.
name|m0flag
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
literal|4
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/*not used yet*/
return|return
literal|0
return|;
default|default:
comment|/* backward compatibility */
name|error
operator|=
name|vgaioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
return|return
literal|0
return|;
else|else
return|return
name|ENOTTY
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_function
specifier|static
name|int
name|vioc_setfontmap
parameter_list|(
name|struct
name|fontmap
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|int
name|pg
init|=
name|data
operator|->
name|page
decl_stmt|;
name|u_char
modifier|*
name|ofs
init|=
operator|(
name|u_char
operator|*
operator|)
name|Crtat
operator|+
name|pg
operator|*
literal|0x4000
decl_stmt|;
if|if
condition|(
name|vds
operator|.
name|cardtype
operator|<
name|VG_EGA
operator|||
name|pg
operator|<
literal|0
operator|||
name|pg
operator|>
literal|7
condition|)
return|return
name|EINVAL
return|;
name|vds
operator|.
name|encoding
index|[
name|pg
index|]
operator|=
name|data
operator|->
name|encoding
expr_stmt|;
name|vga_enablecg
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|ofs
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|k
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|VGA_FNTCSIZE
operator|*
name|VGA_FNTNCHARS
operator|)
condition|;
name|k
operator|+=
literal|32
operator|,
name|i
operator|+=
name|VGA_FNTCSIZE
control|)
block|{
name|bcopy
argument_list|(
operator|&
name|data
operator|->
name|map
index|[
name|i
index|]
argument_list|,
name|ofs
operator|+
name|k
argument_list|,
name|VGA_FNTCSIZE
argument_list|)
expr_stmt|;
block|}
name|vga_disablecg
argument_list|()
expr_stmt|;
comment|/* enable SB/SBH when font 1 is loaded */
if|if
condition|(
name|pg
operator|==
literal|1
operator|&&
name|data
operator|->
name|encoding
operator|!=
name|NOFONT
condition|)
name|outw
argument_list|(
literal|0x3c4
argument_list|,
literal|0x0403
argument_list|)
expr_stmt|;
comment|/* SA=1,SB=0 */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vioc_getfontmap
parameter_list|(
name|struct
name|fontmap
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|int
name|pg
init|=
name|data
operator|->
name|page
decl_stmt|;
name|u_char
modifier|*
name|ofs
init|=
operator|(
name|u_char
operator|*
operator|)
name|Crtat
operator|+
name|pg
operator|*
literal|0x4000
decl_stmt|;
if|if
condition|(
name|vds
operator|.
name|cardtype
operator|<
name|VG_EGA
operator|||
name|pg
operator|<
literal|0
operator|||
name|pg
operator|>
literal|1
condition|)
return|return
name|EINVAL
return|;
name|data
operator|->
name|encoding
operator|=
name|vds
operator|.
name|encoding
index|[
name|pg
index|]
expr_stmt|;
name|vga_enablecg
argument_list|(
name|pg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|k
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|VGA_FNTCSIZE
operator|*
name|VGA_FNTNCHARS
operator|)
condition|;
name|k
operator|+=
literal|32
operator|,
name|i
operator|+=
name|VGA_FNTCSIZE
control|)
name|bcopy
argument_list|(
name|ofs
operator|+
name|k
argument_list|,
operator|&
name|data
operator|->
name|map
index|[
name|i
index|]
argument_list|,
name|VGA_FNTCSIZE
argument_list|)
expr_stmt|;
name|vga_disablecg
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  execute my own vga ioctls  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|vgaioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* CONSGINFO is mandatory ! */
case|case
name|CONSGINFO
case|:
operator|*
operator|(
operator|(
expr|struct
name|consinfo
operator|*
operator|)
name|data
operator|)
operator|=
name|cons_capabilities
expr_stmt|;
return|return
literal|0
return|;
case|case
name|OLDCONSGINFO
case|:
operator|(
operator|(
expr|struct
name|oldconsinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|info1
operator|=
name|cons_capabilities
operator|.
name|info1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONSOLE_X_MODE
case|:
return|return
name|kbd_setxserveriopl
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGAGINFO
case|:
return|return
name|vga_getvideoinfo
argument_list|(
operator|(
expr|struct
name|videoinfo
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGASFNTMAP
case|:
return|return
name|vioc_setfontmap
argument_list|(
operator|(
expr|struct
name|fontmap
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGAGFNTMAP
case|:
return|return
name|vioc_getfontmap
argument_list|(
operator|(
expr|struct
name|fontmap
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGATAKECTRL
case|:
comment|/* No op for now */
return|return
literal|0
return|;
case|case
name|VGAGIVECTRL
case|:
comment|/* No op for now */
return|return
literal|0
return|;
default|default:
return|return
name|ENOTTY
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MINITERM */
end_comment

end_unit

