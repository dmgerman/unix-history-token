begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*      Copyright 1992 by Holger Veit  *	May be freely used with Bill Jolitz's port of   *	386bsd and may be included in a 386bsd collection  *	as long as binary and source are available and reproduce the above  *	copyright. This includes special software collections which  *	are derived from 386bsd, such as the so-called NetBSD.  *  *	You may freely modify this code and contribute improvements based  *	on this code as long as you don't claim to be the original author.  *	Commercial use of this source requires permittance of the copyright   *	holder. A general license for 386bsd will override this restriction.  *  *	Use at your own risk. The copyright holder or any person who makes  *	this code available for the public (administrators of public archives  *	for instance) are not responsible for any harm to hardware or software  *	that might happen due to wrong application or program faults.  *  *	@(#) $RCSfile: co_codrv1.c,v $	$Revision: 1.6 $ (Contributed to 386bsd) $Date: 93/01/23 23:14:27 $  *  * This file processes the vga/kbdioctls  *  * History: see CO_HISTORY  *  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: /usr/src/sys.386bsd/i386/isa/codrv/RCS/co_codrv1.c,v 1.6 93/01/23 23:14:27 root Exp Locker: root $"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COMPAT_CO011
end_define

begin_include
include|#
directive|include
file|"co_hdr.h"
end_include

begin_comment
comment|/**************************************************************************  *  * This file serves as a plug-in interface for IOCTL processing.  *  * This file has been modified to understand most of the CODRV1 and  * CODRV2 ioctls which have been tested long in codrv-0.1.2-ALPHA.  * For some reasons, the CODRV2 font interface will be revised  * again. It is not integrated here. The other ioctls are available.  *  * This file has four public entry points:  *  * coioctl_init()			(called by coattach, initialization)  * consioctl(dev,cmd,addr,flag)		(serves /dev/console specific things)  * kbdioctl(dev,cmd,addr,flags)		(serves /dev/kbd specific things)  * vgaioctl(dev,cmd,addr,flags)		(serves /dev/vga specific things)  *  * In CODRV1 these functions were available with any console device,  * be it /dev/console, /dev/kbd, /dev/vga  *  * This ioctl package contains its own set of service functions, that  * were in co_kbd.c and co_vga.c before, with the exception of the   * keyboard overload subsystem, which is still in co_kbd.c.  *   * Programmers are invited to provide different interfaces, such as  * SVR3/SVR4/SUN-OS. There will be hopefully fully runtime-replacable  * kernel modules, which can make use of this.  *  ***********************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CODRV1
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|MINITERM
end_ifndef

begin_comment
comment|/*  *	initialize ioctl system  */
end_comment

begin_function
name|void
name|coioctl_init
parameter_list|()
block|{
name|cons_capabilities
operator|.
name|info1
operator||=
operator|(
name|CONS_CODRV1
operator||
name|CONS_CODRV2
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	process /dev/console ioctls  */
end_comment

begin_function
name|int
name|consioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|error
expr_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
name|dev2tty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
name|ENXIO
return|;
comment|/* mandatory */
if|if
condition|(
name|cmd
operator|==
name|CONSGINFO
condition|)
block|{
operator|*
operator|(
operator|(
expr|struct
name|consinfo
operator|*
operator|)
name|data
operator|)
operator|=
name|cons_capabilities
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|OLDCONSGINFO
condition|)
block|{
operator|(
operator|(
expr|struct
name|oldconsinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|info1
operator|=
name|cons_capabilities
operator|.
name|info1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* must be executed for backward compatibility 	 * must be executed *after* the tty ioctls, 	 * because it shares an essential ioctl with them. 	 */
name|error
operator|=
name|kbdioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
return|return
name|error
operator|==
literal|0
condition|?
literal|0
else|:
name|ENOTTY
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************  *  utility functions for kbdioctl  *********************************************************************/
end_comment

begin_function
specifier|static
name|struct
name|vty
modifier|*
name|n2vty
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|==
name|KBD_ACTVTY
condition|)
return|return
name|actvty
return|;
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|n
operator|<
name|nvty
condition|)
return|return
operator|&
name|vtys
index|[
name|n
index|]
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kioc_setlockkeys
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|snc
parameter_list|)
block|{
specifier|register
name|struct
name|vty
modifier|*
name|vp
init|=
name|dev2vty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|vp
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvty
condition|;
name|i
operator|++
control|)
block|{
name|vp
operator|=
operator|&
name|vtys
index|[
name|i
index|]
expr_stmt|;
name|vp
operator|->
name|scroll
operator|=
name|snc
operator|&
literal|1
expr_stmt|;
name|vp
operator|->
name|num
operator|=
operator|(
name|snc
operator|&
literal|2
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vp
operator|->
name|caps
operator|=
operator|(
name|snc
operator|&
literal|4
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|vp
operator|=
name|actvty
expr_stmt|;
block|}
name|vp
operator|->
name|scroll
operator|=
name|snc
operator|&
literal|1
expr_stmt|;
name|vp
operator|->
name|num
operator|=
operator|(
name|snc
operator|&
literal|2
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vp
operator|->
name|caps
operator|=
operator|(
name|snc
operator|&
literal|4
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|kbd_setleds
argument_list|(
name|leds
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|kioc_assignleds
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|param
parameter_list|)
block|{
name|u_char
name|ostate
decl_stmt|;
name|struct
name|vty
modifier|*
name|vp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|param
operator|&
literal|4
condition|)
block|{
comment|/* used for initialization */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvty
condition|;
name|i
operator|++
control|)
block|{
name|vp
operator|=
operator|&
name|vtys
index|[
name|i
index|]
expr_stmt|;
name|vp
operator|->
name|altgrled
operator|=
operator|(
name|param
operator|&
literal|3
operator|)
operator|==
literal|2
expr_stmt|;
name|vp
operator|->
name|shiftled
operator|=
operator|(
name|param
operator|&
literal|3
operator|)
operator|==
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|vp
operator|=
name|dev2vty
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vp
condition|)
name|vp
operator|=
name|actvty
expr_stmt|;
name|vp
operator|->
name|altgrled
operator|=
name|param
operator|==
literal|2
expr_stmt|;
name|vp
operator|->
name|shiftled
operator|=
name|param
operator|==
literal|1
expr_stmt|;
block|}
name|vp
operator|=
name|actvty
expr_stmt|;
name|kbd_setleds
argument_list|(
name|leds
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|ostate
operator|=
name|vp
operator|->
name|altgrled
condition|?
literal|2
else|:
name|vp
operator|->
name|shiftled
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|ostate
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kioc_dobeep
parameter_list|(
name|struct
name|kbd_bell
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
condition|)
block|{
name|int
name|p
decl_stmt|,
name|d
decl_stmt|;
name|kbd_cvtsound
argument_list|(
name|data
operator|->
name|pitch
argument_list|,
operator|&
name|p
argument_list|,
name|data
operator|->
name|duration
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|sysbeep
argument_list|(
name|p
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|sysbeep
argument_list|(
name|kbs
operator|.
name|pitch
argument_list|,
name|kbs
operator|.
name|duration
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kioc_getbeep2
parameter_list|(
name|struct
name|kbd_bell
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|vty
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|nr
operator|==
name|KBD_DEFLT
condition|)
block|{
name|data
operator|->
name|pitch
operator|=
literal|1193180
operator|/
name|kbs
operator|.
name|pitch
expr_stmt|;
name|data
operator|->
name|duration
operator|=
name|kbs
operator|.
name|duration
operator|/
name|hz
operator|*
literal|1000
expr_stmt|;
return|return
literal|0
return|;
block|}
name|vp
operator|=
name|n2vty
argument_list|(
name|data
operator|->
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vp
condition|)
return|return
name|EINVAL
return|;
name|data
operator|->
name|pitch
operator|=
literal|1193180
operator|/
name|vp
operator|->
name|pitch
expr_stmt|;
name|data
operator|->
name|duration
operator|=
name|vp
operator|->
name|duration
operator|/
name|hz
operator|*
literal|1000
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kioc_setbeep2
parameter_list|(
name|struct
name|kbd_bell
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|vty
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|nr
operator|==
name|KBD_DEFLT
condition|)
block|{
name|kbd_cvtsound
argument_list|(
name|data
operator|->
name|pitch
argument_list|,
operator|&
name|kbs
operator|.
name|pitch
argument_list|,
name|data
operator|->
name|duration
argument_list|,
operator|&
name|kbs
operator|.
name|duration
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|vp
operator|=
name|n2vty
argument_list|(
name|data
operator|->
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vp
condition|)
return|return
name|EINVAL
return|;
name|kbd_cvtsound
argument_list|(
name|data
operator|->
name|pitch
argument_list|,
operator|&
name|vp
operator|->
name|pitch
argument_list|,
name|data
operator|->
name|duration
argument_list|,
operator|&
name|vp
operator|->
name|duration
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *	process keyboard ioctls  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ofl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|kbdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|n
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|vty
modifier|*
name|vp
init|=
name|dev2vty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* CONSGINFO is mandatory ! */
case|case
name|CONSGINFO
case|:
operator|*
operator|(
operator|(
expr|struct
name|consinfo
operator|*
operator|)
name|data
operator|)
operator|=
name|cons_capabilities
expr_stmt|;
return|return
literal|0
return|;
case|case
name|OLDCONSGINFO
case|:
operator|(
operator|(
expr|struct
name|oldconsinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|info1
operator|=
name|cons_capabilities
operator|.
name|info1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDFORCEASCII
case|:
comment|/* this is a relic from my youth mistakes */
return|return
literal|0
return|;
case|case
name|KBDCOLDRESET
case|:
name|kbd_coldreset
argument_list|()
expr_stmt|;
name|kbd_ovlinit
argument_list|()
expr_stmt|;
name|kbd_settpmrate
argument_list|(
name|KBD_TPD500
operator||
name|KBD_TPM100
argument_list|)
expr_stmt|;
name|kioc_setlockkeys
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDWARMRESET
case|:
name|kbd_warmreset
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDGTPMAT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|kbs
operator|.
name|tpmrate
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDSTPMAT
case|:
name|kbd_settpmrate
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDGREPSW
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|kbs
operator|.
name|repeat
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDSREPSW
case|:
name|kbs
operator|.
name|repeat
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDGLEDS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|kbs
operator|.
name|ledstate
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDSLEDS
case|:
name|kbd_setleds
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDGLOCK
case|:
if|if
condition|(
operator|!
name|vp
condition|)
name|vp
operator|=
name|actvty
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|vp
operator|->
name|scroll
operator||
operator|(
name|vp
operator|->
name|num
operator|<<
literal|1
operator|)
operator||
operator|(
name|vp
operator|->
name|caps
operator|<<
literal|2
operator|)
operator||
operator|(
name|vp
operator|->
name|altgrlock
operator|<<
literal|3
operator|)
operator||
operator|(
name|vp
operator|->
name|shiftlock
operator|<<
literal|4
operator|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDSLOCK
case|:
name|kioc_setlockkeys
argument_list|(
name|dev
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDSCAPSLED
case|:
comment|/* assign CapsLock LED to AltgrLock or ShiftLock */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|kioc_assignleds
argument_list|(
name|dev
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDGCAPSLED
case|:
if|if
condition|(
operator|!
name|vp
condition|)
name|vp
operator|=
name|actvty
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|vp
operator|->
name|altgrled
condition|?
literal|2
else|:
name|vp
operator|->
name|shiftled
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
literal|0
return|;
case|case
name|OLDKBDSETBEEP
case|:
return|return
name|kbd_cvtsound
argument_list|(
operator|(
operator|(
expr|struct
name|kbd_sound
operator|*
operator|)
name|data
operator|)
operator|->
name|pitch
argument_list|,
operator|&
name|kbs
operator|.
name|pitch
argument_list|,
operator|(
operator|(
expr|struct
name|kbd_sound
operator|*
operator|)
name|data
operator|)
operator|->
name|duration
argument_list|,
operator|&
name|kbs
operator|.
name|duration
argument_list|)
return|;
case|case
name|KBDGETBEEP
case|:
return|return
name|kioc_getbeep2
argument_list|(
operator|(
expr|struct
name|kbd_bell
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDSETBEEP
case|:
return|return
name|kioc_setbeep2
argument_list|(
operator|(
expr|struct
name|kbd_bell
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDBELL
case|:
case|case
name|KBDSETBELL
case|:
comment|/* compatibility */
return|return
name|kioc_dobeep
argument_list|(
operator|(
expr|struct
name|kbd_bell
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDGCKEY
case|:
return|return
name|kbd_getckeydef
argument_list|(
operator|(
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
operator|)
operator|->
name|keynum
argument_list|,
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|OLDKBDGCKEY
case|:
block|{
name|int
name|stat
decl_stmt|;
name|Ovl_tbl
name|ok
decl_stmt|;
name|stat
operator|=
name|kbd_getckeydef
argument_list|(
name|ok
operator|.
name|keynum
argument_list|,
operator|&
name|ok
argument_list|)
expr_stmt|;
if|#
directive|if
name|XCHAR
operator|!=
name|u_char
name|ERROR
operator|!
name|FIX
name|ME
operator|!
else|#
directive|else
if|if
condition|(
operator|!
name|stat
condition|)
name|bcopy
argument_list|(
operator|&
name|ok
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|oldkbd_ovlkey
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|stat
return|;
block|}
case|case
name|KBDSCKEY
case|:
return|return
name|kbd_setkeydef
argument_list|(
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDGOKEY
case|:
return|return
name|kbd_getokeydef
argument_list|(
operator|(
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
operator|)
operator|->
name|keynum
argument_list|,
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDRMKEY
case|:
return|return
name|kbd_rmkeydef
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDDEFAULT
case|:
name|kbd_ovlinit
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KBDSCLRLYR
case|:
name|kbs
operator|.
name|a0flag
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
literal|1
operator|)
operator|!=
literal|0
expr_stmt|;
name|kbs
operator|.
name|c0flag
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
literal|2
operator|)
operator|!=
literal|0
expr_stmt|;
name|kbs
operator|.
name|m0flag
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
literal|4
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/*not used yet*/
return|return
literal|0
return|;
case|case
name|KBDGSPECF
case|:
return|return
name|kbd_gethotkey
argument_list|(
operator|(
expr|struct
name|kbd_hotkey
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDSSPECF
case|:
return|return
name|kbd_sethotkey
argument_list|(
operator|(
expr|struct
name|kbd_hotkey
operator|*
operator|)
name|data
argument_list|)
return|;
comment|/* and now some special features which are cheap */
case|case
name|FIONREAD
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|n
operator|=
name|RB_LEN
argument_list|(
operator|&
name|co_buf
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
operator|(
name|off_t
operator|*
operator|)
name|data
operator|=
name|n
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCSPGRP
case|:
name|consoftc
operator|.
name|cs_pgid
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TIOCGPGRP
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|consoftc
operator|.
name|cs_pgid
expr_stmt|;
return|return
literal|0
return|;
default|default:
comment|/* backward compatibility */
name|error
operator|=
name|vgaioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
return|return
literal|0
return|;
else|else
return|return
name|ENOTTY
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/**********************************************************************  *  utility functions for vgaioctl  *********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|chklim
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|int
name|x0
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y0
parameter_list|,
name|int
name|y1
parameter_list|)
block|{
if|if
condition|(
name|x0
operator|<
literal|0
operator|||
name|x0
operator|>=
name|vp
operator|->
name|ncol
operator|||
name|y0
operator|<
literal|0
operator|||
name|y0
operator|>=
name|vp
operator|->
name|nrow
operator|||
name|x1
operator|<
literal|0
operator|||
name|x1
operator|>=
name|vp
operator|->
name|ncol
operator|||
name|y1
operator|<
literal|0
operator|||
name|y1
operator|>=
name|vp
operator|->
name|nrow
operator|||
name|x0
operator|>
name|x1
operator|||
name|y0
operator|>
name|y1
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cpyblk
parameter_list|(
name|u_char
modifier|*
name|from
parameter_list|,
name|u_char
modifier|*
name|to
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|x0
parameter_list|,
name|int
name|x1
parameter_list|,
name|int
name|y0
parameter_list|,
name|int
name|y1
parameter_list|,
name|int
name|ncol
parameter_list|)
block|{
specifier|register
name|x
operator|,
name|y
operator|,
name|n
expr_stmt|;
name|u_char
modifier|*
name|ofs
decl_stmt|,
modifier|*
name|ofs2
decl_stmt|;
name|u_short
modifier|*
name|ofs1
decl_stmt|;
comment|/* copy the requested data, could be optimized */
name|ofs
operator|=
name|from
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|VGA_ATTR
case|:
name|ofs
operator|++
expr_stmt|;
comment|/*FALLTHRU*/
case|case
name|VGA_TEXT
case|:
name|ofs2
operator|=
name|ofs
operator|+
name|y0
operator|*
name|ncol
operator|*
literal|2
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|y
operator|=
name|y0
init|;
name|y
operator|<=
name|y1
condition|;
name|y
operator|++
operator|,
name|ofs
operator|+=
operator|(
name|ncol
operator|*
literal|2
operator|)
control|)
block|{
for|for
control|(
name|ofs2
operator|=
name|ofs
operator|,
name|x
operator|=
name|x0
init|;
name|x
operator|<=
name|x1
condition|;
name|x
operator|++
operator|,
name|n
operator|++
operator|,
name|ofs2
operator|+=
literal|2
control|)
operator|*
operator|(
name|to
operator|+
name|n
operator|)
operator|=
operator|*
name|ofs2
expr_stmt|;
block|}
break|break;
case|case
name|VGA_BOTH
case|:
name|ofs1
operator|=
operator|(
operator|(
name|u_short
operator|*
operator|)
name|from
operator|)
operator|+
name|x0
expr_stmt|;
for|for
control|(
name|y
operator|=
name|y0
init|;
name|y
operator|<=
name|y1
condition|;
name|y
operator|++
operator|,
name|ofs1
operator|+=
name|ncol
control|)
name|bcopy
argument_list|(
name|ofs1
argument_list|,
name|to
argument_list|,
operator|(
name|x1
operator|-
name|x0
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getsz
parameter_list|(
name|struct
name|vty
modifier|*
name|vp
parameter_list|,
name|struct
name|vga_block
modifier|*
name|p
parameter_list|)
block|{
name|int
name|sz
decl_stmt|;
comment|/* how much */
if|if
condition|(
operator|(
name|p
operator|->
name|mode
operator|&
literal|0x03
operator|)
operator|==
name|VGA_SCREEN
condition|)
block|{
name|p
operator|->
name|x0
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|y0
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|x1
operator|=
name|vp
operator|->
name|ncol
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|y1
operator|=
name|vp
operator|->
name|nrow
operator|-
literal|1
expr_stmt|;
name|sz
operator|=
name|vp
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|chklim
argument_list|(
name|vp
argument_list|,
name|p
operator|->
name|x0
argument_list|,
name|p
operator|->
name|x1
argument_list|,
name|p
operator|->
name|y0
argument_list|,
name|p
operator|->
name|y1
argument_list|)
condition|)
return|return
literal|0
return|;
name|sz
operator|=
operator|(
name|p
operator|->
name|x1
operator|-
name|p
operator|->
name|x0
operator|+
literal|1
operator|)
operator|*
operator|(
name|p
operator|->
name|y1
operator|-
name|p
operator|->
name|y0
operator|+
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|->
name|mode
operator|&
literal|0x30
operator|)
operator|==
name|VGA_BOTH
condition|)
name|sz
operator|*=
literal|2
expr_stmt|;
return|return
name|sz
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vioc_vgagetblock
parameter_list|(
name|struct
name|vga_block
modifier|*
name|p
parameter_list|)
block|{
name|u_char
modifier|*
name|data
init|=
literal|0
decl_stmt|;
name|struct
name|vty
modifier|*
name|vp
decl_stmt|;
name|int
name|sz
decl_stmt|,
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* check vty */
name|vp
operator|=
name|n2vty
argument_list|(
name|p
operator|->
name|pagenum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vp
condition|)
return|return
name|EINVAL
return|;
comment|/* get size */
if|if
condition|(
operator|!
operator|(
name|sz
operator|=
name|getsz
argument_list|(
name|vp
argument_list|,
name|p
argument_list|)
operator|)
condition|)
return|return
name|EINVAL
return|;
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|sz
argument_list|,
name|M_IOCTLOPS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* copy the data into buffer */
name|error
operator|=
name|cpyblk
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|vp
operator|->
name|Crtat
argument_list|,
name|data
argument_list|,
name|p
operator|->
name|mode
operator|&
literal|0x30
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|,
name|y0
argument_list|,
name|y1
argument_list|,
name|vp
operator|->
name|ncol
argument_list|)
expr_stmt|;
comment|/* to user process */
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|data
argument_list|,
name|p
operator|->
name|map
argument_list|,
name|sz
argument_list|)
expr_stmt|;
comment|/* clean up */
name|free
argument_list|(
name|data
argument_list|,
name|M_IOCTLOPS
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vioc_vgasetblock
parameter_list|(
name|struct
name|vga_block
modifier|*
name|p
parameter_list|)
block|{
name|u_char
modifier|*
name|data
init|=
literal|0
decl_stmt|;
name|struct
name|vty
modifier|*
name|vp
decl_stmt|;
name|int
name|sz
decl_stmt|,
name|x0
decl_stmt|,
name|y0
decl_stmt|,
name|x1
decl_stmt|,
name|y1
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* check vty */
name|vp
operator|=
name|n2vty
argument_list|(
name|p
operator|->
name|pagenum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vp
condition|)
return|return
name|EINVAL
return|;
comment|/* get size */
if|if
condition|(
operator|!
operator|(
name|sz
operator|=
name|getsz
argument_list|(
name|vp
argument_list|,
name|p
argument_list|)
operator|)
condition|)
return|return
name|EINVAL
return|;
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|sz
argument_list|,
name|M_IOCTLOPS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|p
operator|->
name|map
argument_list|,
name|data
argument_list|,
name|sz
argument_list|)
expr_stmt|;
comment|/* copy the requested data */
name|error
operator|=
name|cpyblk
argument_list|(
name|data
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|vp
operator|->
name|Crtat
argument_list|,
name|p
operator|->
name|mode
operator|&
literal|0x30
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|,
name|y0
argument_list|,
name|y1
argument_list|,
name|vp
operator|->
name|ncol
argument_list|)
expr_stmt|;
comment|/* clean up */
name|free
argument_list|(
name|data
argument_list|,
name|M_IOCTLOPS
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vioc_gettextpage
parameter_list|(
name|struct
name|textpage
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
modifier|*
name|p
init|=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|Crtat
operator|)
operator|+
name|tp
operator|->
name|ad
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|ad
operator|>
literal|1
operator|||
name|tp
operator|->
name|pagenum
operator|>
literal|7
condition|)
return|return
name|EINVAL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|actvty
operator|->
name|size
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|2
control|)
name|tp
operator|->
name|map
index|[
name|i
index|]
operator|=
operator|*
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vioc_settextpage
parameter_list|(
name|struct
name|textpage
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
modifier|*
name|p
init|=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|Crtat
operator|)
operator|+
name|tp
operator|->
name|ad
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|ad
operator|>
literal|1
operator|||
name|tp
operator|->
name|pagenum
operator|>
literal|7
condition|)
return|return
name|EINVAL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|actvty
operator|->
name|size
condition|;
name|i
operator|++
operator|,
name|p
operator|+=
literal|2
control|)
operator|*
name|p
operator|=
name|tp
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vioc_oldgetfontchar
parameter_list|(
name|struct
name|fontchar
modifier|*
name|fc
parameter_list|)
block|{
name|int
name|pg
init|=
name|fc
operator|->
name|page
decl_stmt|;
name|u_char
modifier|*
name|ofs
init|=
operator|(
name|u_char
operator|*
operator|)
name|Crtat
operator|+
name|pg
operator|*
literal|0x4000
decl_stmt|;
if|if
condition|(
name|vds
operator|.
name|cardtype
operator|<
name|VG_EGA
operator|||
name|pg
operator|<
literal|0
operator|||
name|pg
operator|>
literal|7
condition|)
return|return
name|EINVAL
return|;
name|vga_enablecg
argument_list|(
name|pg
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ofs
operator|+
operator|(
name|fc
operator|->
name|idx
operator|<<
literal|5
operator|)
argument_list|,
name|fc
operator|->
name|cmap
argument_list|,
name|VGA_FNTCSIZE
argument_list|)
expr_stmt|;
name|vga_disablecg
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vioc_oldsetfontchar
parameter_list|(
name|struct
name|fontchar
modifier|*
name|fc
parameter_list|)
block|{
name|int
name|pg
init|=
name|fc
operator|->
name|page
decl_stmt|;
name|u_char
modifier|*
name|ofs
init|=
operator|(
name|u_char
operator|*
operator|)
name|Crtat
operator|+
name|pg
operator|*
literal|0x4000
decl_stmt|;
if|if
condition|(
name|vds
operator|.
name|cardtype
operator|<
name|VG_EGA
operator|||
name|pg
operator|<
literal|0
operator|||
name|pg
operator|>
literal|7
condition|)
return|return
name|EINVAL
return|;
name|vga_enablecg
argument_list|(
name|pg
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fc
operator|->
name|cmap
argument_list|,
name|ofs
operator|+
operator|(
name|fc
operator|->
name|idx
operator|<<
literal|5
operator|)
argument_list|,
name|VGA_FNTCSIZE
argument_list|)
expr_stmt|;
name|vga_disablecg
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vioc_miscfunctions
parameter_list|(
name|struct
name|miscfcns
modifier|*
name|f
parameter_list|)
block|{
switch|switch
condition|(
name|f
operator|->
name|cmd
condition|)
block|{
case|case
literal|1
case|:
name|vds
operator|.
name|encoding
index|[
literal|1
index|]
operator|=
name|NOFONT
expr_stmt|;
name|outw
argument_list|(
literal|0x3c4
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
comment|/* SA=0,SB=0 */
break|break;
case|case
literal|2
case|:
name|f
operator|->
name|u
operator|.
name|enc
index|[
literal|0
index|]
operator|=
name|vds
operator|.
name|encoding
index|[
literal|0
index|]
expr_stmt|;
name|f
operator|->
name|u
operator|.
name|enc
index|[
literal|1
index|]
operator|=
name|vds
operator|.
name|encoding
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|vds
operator|.
name|scrtimeout
operator|=
name|f
operator|->
name|u
operator|.
name|timeout
expr_stmt|;
comment|/* seconds */
name|vga_doblanking
argument_list|(
name|BLANKSTART
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|f
operator|->
name|u
operator|.
name|timeout
operator|=
operator|(
name|vds
operator|.
name|scrtimeout
operator|&
literal|0x3FFFFFFF
operator|)
operator||
operator|(
call|(
name|u_long
call|)
argument_list|(
name|vds
operator|.
name|blanking
operator|&
literal|3
argument_list|)
operator|<<
literal|30
operator|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vioc_oldsetfontmap
parameter_list|(
name|struct
name|fontmap
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|int
name|pg
init|=
name|data
operator|->
name|page
decl_stmt|;
name|u_char
modifier|*
name|ofs
init|=
operator|(
name|u_char
operator|*
operator|)
name|Crtat
operator|+
name|pg
operator|*
literal|0x4000
decl_stmt|;
if|if
condition|(
name|vds
operator|.
name|cardtype
operator|<
name|VG_EGA
operator|||
name|pg
operator|<
literal|0
operator|||
name|pg
operator|>
literal|7
condition|)
return|return
name|EINVAL
return|;
name|vds
operator|.
name|encoding
index|[
name|pg
index|]
operator|=
name|data
operator|->
name|encoding
expr_stmt|;
name|vga_enablecg
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|ofs
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|k
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|VGA_FNTCSIZE
operator|*
name|VGA_FNTNCHARS
operator|)
condition|;
name|k
operator|+=
literal|32
operator|,
name|i
operator|+=
name|VGA_FNTCSIZE
control|)
block|{
name|bcopy
argument_list|(
operator|&
name|data
operator|->
name|map
index|[
name|i
index|]
argument_list|,
name|ofs
operator|+
name|k
argument_list|,
name|VGA_FNTCSIZE
argument_list|)
expr_stmt|;
block|}
name|vga_disablecg
argument_list|()
expr_stmt|;
comment|/* enable SB/SBH when font 1 is loaded */
if|if
condition|(
name|pg
operator|==
literal|1
operator|&&
name|data
operator|->
name|encoding
operator|!=
name|NOFONT
condition|)
name|outw
argument_list|(
literal|0x3c4
argument_list|,
literal|0x0403
argument_list|)
expr_stmt|;
comment|/* SA=1,SB=0 */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vioc_oldgetfontmap
parameter_list|(
name|struct
name|fontmap
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|int
name|pg
init|=
name|data
operator|->
name|page
decl_stmt|;
name|u_char
modifier|*
name|ofs
init|=
operator|(
name|u_char
operator|*
operator|)
name|Crtat
operator|+
name|pg
operator|*
literal|0x4000
decl_stmt|;
if|if
condition|(
name|vds
operator|.
name|cardtype
operator|<
name|VG_EGA
operator|||
name|pg
operator|<
literal|0
operator|||
name|pg
operator|>
literal|7
condition|)
return|return
name|EINVAL
return|;
name|data
operator|->
name|encoding
operator|=
name|vds
operator|.
name|encoding
index|[
name|pg
index|]
expr_stmt|;
name|vga_enablecg
argument_list|(
name|pg
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|k
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|VGA_FNTCSIZE
operator|*
name|VGA_FNTNCHARS
operator|)
condition|;
name|k
operator|+=
literal|32
operator|,
name|i
operator|+=
name|VGA_FNTCSIZE
control|)
name|bcopy
argument_list|(
name|ofs
operator|+
name|k
argument_list|,
operator|&
name|data
operator|->
name|map
index|[
name|i
index|]
argument_list|,
name|VGA_FNTCSIZE
argument_list|)
expr_stmt|;
name|vga_disablecg
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|FSPACE
value|256*32
end_define

begin_define
define|#
directive|define
name|FCHUNKS
value|32
end_define

begin_function
specifier|static
name|int
name|vioc_setfontmap
parameter_list|(
name|struct
name|fmap
modifier|*
name|f
parameter_list|)
block|{
name|u_char
modifier|*
name|ofs
init|=
operator|(
name|u_char
operator|*
operator|)
name|Crtat
operator|+
name|f
operator|->
name|page
operator|*
literal|0x4000
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|struct
name|fchar
modifier|*
name|cibuf
decl_stmt|,
name|fc
index|[
name|FCHUNKS
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|ec
decl_stmt|;
comment|/* XXX graphics */
if|if
condition|(
name|vds
operator|.
name|cardtype
operator|<
name|VG_EGA
operator|||
name|f
operator|->
name|page
operator|<
literal|0
operator|||
name|f
operator|->
name|page
operator|>
literal|1
operator|||
name|f
operator|->
name|x
operator|>
literal|9
operator|||
name|f
operator|->
name|y
operator|>
literal|16
operator|||
name|f
operator|->
name|nr
operator|>
literal|256
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|f
operator|->
name|nr
operator|>
literal|0
condition|)
block|{
name|vds
operator|.
name|f89bit
operator|=
name|vds
operator|.
name|cardtype
operator|>=
name|VG_EGA
condition|?
literal|9
else|:
literal|8
expr_stmt|;
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|FSPACE
argument_list|,
name|M_IOCTLOPS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|FSPACE
argument_list|)
expr_stmt|;
comment|/* fill the buffer */
name|cibuf
operator|=
name|f
operator|->
name|fntmap
expr_stmt|;
for|for
control|(
name|i
operator|=
name|f
operator|->
name|nr
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
name|FCHUNKS
operator|,
name|cibuf
operator|+=
name|FCHUNKS
control|)
block|{
name|j
operator|=
name|i
operator|>=
name|FCHUNKS
condition|?
name|FCHUNKS
else|:
name|i
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|cibuf
argument_list|,
name|fc
argument_list|,
name|j
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fchar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|erexit
goto|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|j
condition|;
name|k
operator|++
control|)
block|{
name|ec
operator|=
name|fc
index|[
name|k
index|]
operator|.
name|encoding
operator|&
literal|0xFF
expr_stmt|;
name|bcopy
argument_list|(
name|fc
index|[
name|k
index|]
operator|.
name|map
argument_list|,
name|buf
operator|+
operator|(
name|ec
operator|<<
literal|5
operator|)
argument_list|,
name|f
operator|->
name|y
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* set the extension bit (this is really switched in 		 * vga_disablecg() 		 */
if|if
condition|(
name|f
operator|->
name|x
operator|<
literal|9
condition|)
name|vds
operator|.
name|f89bit
operator|=
literal|8
expr_stmt|;
comment|/* move the data into CG space */
name|vga_enablecg
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|ofs
argument_list|,
name|FSPACE
argument_list|)
expr_stmt|;
name|vga_disablecg
argument_list|()
expr_stmt|;
block|}
comment|/* this is a hack, as long as XCHAR == u_char */
switch|switch
condition|(
name|f
operator|->
name|start
condition|)
block|{
case|case
literal|0
case|:
name|i
operator|=
name|XLAT2PC8
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|i
operator|=
name|NOFONT
expr_stmt|;
break|break;
default|default:
case|case
literal|2
case|:
name|i
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|vds
operator|.
name|encoding
index|[
name|f
operator|->
name|page
index|]
operator|=
operator|(
name|u_short
operator|)
name|i
expr_stmt|;
comment|/* enable SB/SBH when font 1 is loaded */
if|if
condition|(
name|f
operator|->
name|page
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|f
operator|->
name|nr
operator|>
literal|0
condition|)
name|outw
argument_list|(
literal|0x3c4
argument_list|,
literal|0x0403
argument_list|)
expr_stmt|;
comment|/* SA=1,SB=0 */
else|else
name|outw
argument_list|(
literal|0x3c4
argument_list|,
literal|0x0003
argument_list|)
expr_stmt|;
block|}
name|erexit
label|:
comment|/* clean up */
name|free
argument_list|(
name|buf
argument_list|,
name|M_IOCTLOPS
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vioc_getfontmap
parameter_list|(
name|struct
name|fmap
modifier|*
name|f
parameter_list|)
block|{
name|u_char
modifier|*
name|ofs
init|=
operator|(
name|u_char
operator|*
operator|)
name|Crtat
operator|+
name|f
operator|->
name|page
operator|*
literal|0x4000
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|struct
name|fchar
modifier|*
name|cobuf
decl_stmt|,
name|fc
index|[
name|FCHUNKS
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* XXX graphics */
if|if
condition|(
name|vds
operator|.
name|cardtype
operator|<
name|VG_EGA
operator|||
name|f
operator|->
name|page
operator|<
literal|0
operator|||
name|f
operator|->
name|page
operator|>
literal|1
operator|||
name|f
operator|->
name|nr
operator|>
literal|0
operator|&&
operator|(
name|f
operator|->
name|x
operator|>
literal|9
operator|||
name|f
operator|->
name|y
operator|>
literal|16
operator|)
operator|||
operator|(
name|f
operator|->
name|nr
operator|+
name|f
operator|->
name|start
operator|)
operator|>
literal|256
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|f
operator|->
name|nr
operator|>
literal|0
condition|)
block|{
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|FSPACE
argument_list|,
name|M_IOCTLOPS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* move the data from CG space */
name|vga_enablecg
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|ofs
argument_list|,
name|buf
argument_list|,
name|FSPACE
argument_list|)
expr_stmt|;
name|vga_disablecg
argument_list|()
expr_stmt|;
comment|/* fill the buffer */
name|cobuf
operator|=
name|f
operator|->
name|fntmap
expr_stmt|;
for|for
control|(
name|k
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f
operator|->
name|nr
condition|;
name|i
operator|++
operator|,
name|k
operator|++
control|)
block|{
if|if
condition|(
name|k
operator|==
name|FCHUNKS
condition|)
block|{
name|error
operator|=
name|copyout
argument_list|(
name|fc
argument_list|,
name|cobuf
argument_list|,
name|FCHUNKS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fchar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|erexit
goto|;
name|k
operator|=
literal|0
expr_stmt|;
name|cobuf
operator|+=
name|FCHUNKS
expr_stmt|;
block|}
name|fc
index|[
name|k
index|]
operator|.
name|encoding
operator|=
name|i
operator|+
name|f
operator|->
name|start
expr_stmt|;
name|bzero
argument_list|(
name|fc
index|[
name|k
index|]
operator|.
name|map
argument_list|,
name|VGA_MAXX
operator|/
literal|8
operator|*
name|VGA_MAXY
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
operator|+
literal|32
operator|*
operator|(
name|i
operator|+
name|f
operator|->
name|start
operator|)
argument_list|,
name|fc
index|[
name|k
index|]
operator|.
name|map
argument_list|,
name|f
operator|->
name|y
argument_list|)
expr_stmt|;
block|}
comment|/* copy the rest */
name|error
operator|=
name|copyout
argument_list|(
name|fc
argument_list|,
name|cobuf
argument_list|,
name|k
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fchar
argument_list|)
argument_list|)
expr_stmt|;
name|erexit
label|:
comment|/* clean up */
name|free
argument_list|(
name|buf
argument_list|,
name|M_IOCTLOPS
argument_list|)
expr_stmt|;
block|}
name|f
operator|->
name|start
operator|=
name|vds
operator|.
name|encoding
index|[
name|f
operator|->
name|page
index|]
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  *  execute my own vga ioctls  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|vgaioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* CONSGINFO is mandatory ! */
case|case
name|CONSGINFO
case|:
operator|*
operator|(
operator|(
expr|struct
name|consinfo
operator|*
operator|)
name|data
operator|)
operator|=
name|cons_capabilities
expr_stmt|;
return|return
literal|0
return|;
case|case
name|OLDCONSGINFO
case|:
operator|(
operator|(
expr|struct
name|oldconsinfo
operator|*
operator|)
name|data
operator|)
operator|->
name|info1
operator|=
name|cons_capabilities
operator|.
name|info1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONSOLE_X_MODE
case|:
return|return
name|kbd_setxserveriopl
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGASCURSOR
case|:
return|return
name|vga_setcshape
argument_list|(
operator|(
expr|struct
name|cursorshape
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGAGCURSOR
case|:
return|return
name|vga_getcshape
argument_list|(
operator|(
expr|struct
name|cursorshape
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGAGINFO
case|:
return|return
name|vga_getvideoinfo
argument_list|(
operator|(
expr|struct
name|videoinfo
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGAGBLANK
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|vds
operator|.
name|scrtimeout
operator|&
literal|0x3FFFFFFF
operator|)
operator||
operator|(
call|(
name|u_long
call|)
argument_list|(
name|vds
operator|.
name|blanking
operator|&
literal|3
argument_list|)
operator|<<
literal|30
operator|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|VGASBLANK
case|:
name|vds
operator|.
name|scrtimeout
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
comment|/* seconds */
name|vga_doblanking
argument_list|(
name|BLANKSTART
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|VGAGBLOCK
case|:
return|return
name|vioc_vgagetblock
argument_list|(
operator|(
expr|struct
name|vga_block
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGASBLOCK
case|:
return|return
name|vioc_vgasetblock
argument_list|(
operator|(
expr|struct
name|vga_block
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|OLDVGASFNTMAP
case|:
return|return
name|vioc_oldsetfontmap
argument_list|(
operator|(
expr|struct
name|fontmap
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|OLDVGAGFNTMAP
case|:
return|return
name|vioc_oldgetfontmap
argument_list|(
operator|(
expr|struct
name|fontmap
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGASFONTMAP
case|:
return|return
name|vioc_setfontmap
argument_list|(
operator|(
expr|struct
name|fmap
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGAGFONTMAP
case|:
return|return
name|vioc_getfontmap
argument_list|(
operator|(
expr|struct
name|fmap
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|OLDVGAGCHAR
case|:
return|return
name|vioc_oldgetfontchar
argument_list|(
operator|(
expr|struct
name|fontchar
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|OLDVGASCHAR
case|:
return|return
name|vioc_oldsetfontchar
argument_list|(
operator|(
expr|struct
name|fontchar
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGAGPAGE
case|:
return|return
name|vioc_gettextpage
argument_list|(
operator|(
expr|struct
name|textpage
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGASPAGE
case|:
return|return
name|vioc_settextpage
argument_list|(
operator|(
expr|struct
name|textpage
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGAMISCFCNS
case|:
return|return
name|vioc_miscfunctions
argument_list|(
operator|(
expr|struct
name|miscfcns
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|VGATAKECTRL
case|:
comment|/* No op for now */
return|return
literal|0
return|;
case|case
name|VGAGIVECTRL
case|:
comment|/* No op for now */
return|return
literal|0
return|;
default|default:
return|return
name|ENOTTY
return|;
block|}
comment|/*NOTREACHED*/
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!MINITERM*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*CODRV1*/
end_comment

end_unit

