begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992-1997 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"sc.h"
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_syscons.h"
end_include

begin_if
if|#
directive|if
name|NSC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cons.h>
end_include

begin_include
include|#
directive|include
file|<machine/console.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/display.h>
end_include

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_include
include|#
directive|include
file|<machine/random.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/timerreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/kbdtables.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/kbdio.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/syscons.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAXCONS
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAXCONS
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|COLD
value|0
end_define

begin_define
define|#
directive|define
name|WARM
value|1
end_define

begin_comment
comment|/* this may break on older VGA's but is useful on real 32 bit systems */
end_comment

begin_define
define|#
directive|define
name|bcopyw
value|bcopy
end_define

begin_decl_stmt
specifier|static
name|default_attr
name|user_default
init|=
block|{
operator|(
name|FG_LIGHTGREY
operator||
name|BG_BLACK
operator|)
operator|<<
literal|8
block|,
operator|(
name|FG_BLACK
operator||
name|BG_LIGHTGREY
operator|)
operator|<<
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|default_attr
name|kernel_default
init|=
block|{
operator|(
name|FG_WHITE
operator||
name|BG_BLACK
operator|)
operator|<<
literal|8
block|,
operator|(
name|FG_BLACK
operator||
name|BG_LIGHTGREY
operator|)
operator|<<
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scr_stat
name|main_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scr_stat
modifier|*
name|console
index|[
name|MAXCONS
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sc_devfs_token
index|[
name|MAXCONS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|scr_stat
modifier|*
name|cur_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|scr_stat
modifier|*
name|new_scp
decl_stmt|,
modifier|*
name|old_scp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|term_stat
name|kernel_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|default_attr
modifier|*
name|current_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sc_port
init|=
name|IO_KBD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|KBDC
name|sc_kbdc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|init_done
init|=
name|COLD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|sc_buffer
index|[
name|ROW
operator|*
name|COL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|switch_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|write_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|blink_in_progress
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|blinkrate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|crtc_addr
init|=
name|MONO_BASE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|crtc_vga
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|shfts
init|=
literal|0
decl_stmt|,
name|ctls
init|=
literal|0
decl_stmt|,
name|alts
init|=
literal|0
decl_stmt|,
name|agrs
init|=
literal|0
decl_stmt|,
name|metas
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|nlkcnt
init|=
literal|0
decl_stmt|,
name|clkcnt
init|=
literal|0
decl_stmt|,
name|slkcnt
init|=
literal|0
decl_stmt|,
name|alkcnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|n_fkey_tab
init|=
sizeof|sizeof
argument_list|(
name|fkey_tab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|fkey_tab
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|delayed_next_scr
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|scrn_blank_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* screen saver timeout value */
end_comment

begin_decl_stmt
name|int
name|scrn_blanked
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* screen saver active flag */
end_comment

begin_decl_stmt
specifier|static
name|long
name|scrn_time_stamp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|scr_map
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|scr_rmap
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|video_mode_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fonts_loaded
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|font_8
index|[
literal|256
operator|*
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|font_14
index|[
literal|256
operator|*
literal|14
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|font_16
index|[
literal|256
operator|*
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|palette
index|[
literal|256
operator|*
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cut_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|mouse_and_mask
index|[
literal|16
index|]
init|=
block|{
literal|0xc000
block|,
literal|0xe000
block|,
literal|0xf000
block|,
literal|0xf800
block|,
literal|0xfc00
block|,
literal|0xfe00
block|,
literal|0xff00
block|,
literal|0xff80
block|,
literal|0xfe00
block|,
literal|0x1e00
block|,
literal|0x1f00
block|,
literal|0x0f00
block|,
literal|0x0f00
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|mouse_or_mask
index|[
literal|16
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x4000
block|,
literal|0x6000
block|,
literal|0x7000
block|,
literal|0x7800
block|,
literal|0x7c00
block|,
literal|0x7e00
block|,
literal|0x6800
block|,
literal|0x0c00
block|,
literal|0x0c00
block|,
literal|0x0600
block|,
literal|0x0600
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|none_saver
parameter_list|(
name|int
name|blank
parameter_list|)
block|{ }
end_function

begin_function_decl
name|void
function_decl|(
modifier|*
name|current_saver
function_decl|)
parameter_list|(
name|int
name|blank
parameter_list|)
init|=
name|none_saver
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|sc_user_ioctl
function_decl|)
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_comment
comment|/* OS specific stuff */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|not_yet_done
end_ifdef

begin_define
define|#
directive|define
name|VIRTUAL_TTY
parameter_list|(
name|x
parameter_list|)
value|(sccons[x] = ttymalloc(sccons[x]))
end_define

begin_decl_stmt
name|struct
name|CONSOLE_TTY
argument_list|(
name|sccons
index|[
name|MAXCONS
index|]
operator|=
name|ttymalloc
argument_list|(
name|sccons
index|[
name|MAXCONS
index|]
argument_list|)
argument_list|)
decl|struct
name|MOUSE_TTY
argument_list|(
name|sccons
index|[
name|MAXCONS
operator|+
literal|1
index|]
operator|=
name|ttymalloc
argument_list|(
name|sccons
index|[
name|MAXCONS
operator|+
literal|1
index|]
argument_list|)
argument_list|)
decl|struct
name|tty
modifier|*
name|sccons
index|[
name|MAXCONS
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|VIRTUAL_TTY
parameter_list|(
name|x
parameter_list|)
value|&sccons[x]
end_define

begin_define
define|#
directive|define
name|CONSOLE_TTY
value|&sccons[MAXCONS]
end_define

begin_define
define|#
directive|define
name|MOUSE_TTY
value|&sccons[MAXCONS+1]
end_define

begin_decl_stmt
specifier|static
name|struct
name|tty
name|sccons
index|[
name|MAXCONS
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SC_MOUSE
value|128
end_define

begin_define
define|#
directive|define
name|SC_CONSOLE
value|255
end_define

begin_define
define|#
directive|define
name|MONO_BUF
value|pa_to_va(0xB0000)
end_define

begin_define
define|#
directive|define
name|CGA_BUF
value|pa_to_va(0xB8000)
end_define

begin_decl_stmt
name|u_short
modifier|*
name|Crtat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|nsccons
init|=
name|MAXCONS
operator|+
literal|2
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WRAPHIST
parameter_list|(
name|scp
parameter_list|,
name|pointer
parameter_list|,
name|offset
parameter_list|)
define|\
value|((scp->history) + ((((pointer) - (scp->history)) + (scp->history_size)\     + (offset)) % (scp->history_size)))
end_define

begin_comment
comment|/* prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|scattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scstart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scmousestart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scinit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|scgetc
parameter_list|(
name|u_int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SCGETC_CN
value|1
end_define

begin_define
define|#
directive|define
name|SCGETC_NONBLOCK
value|2
end_define

begin_function_decl
specifier|static
name|scr_stat
modifier|*
name|get_scr_stat
parameter_list|(
name|dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|scr_stat
modifier|*
name|alloc_scp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_scp
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_scr_num
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scrn_timer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|switch_scr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_int
name|next_scr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exchange_scr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|move_crsr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scan_esc
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draw_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ansi_put
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
modifier|*
name|get_fstr
parameter_list|(
name|u_int
name|c
parameter_list|,
name|u_int
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|history_to_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|history_up_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|history_down_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mask2attr
parameter_list|(
name|struct
name|term_stat
modifier|*
name|term
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_keyboard
parameter_list|(
name|int
name|command
parameter_list|,
name|int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_leds
parameter_list|(
name|int
name|which
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_vgaregs
parameter_list|(
name|char
modifier|*
name|modetable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_font_mode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_normal_mode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_destructive_cursor
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_mouse_pos
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_start
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_cut_end
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mouse_paste
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draw_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draw_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|save_palette
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_bell
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|pitch
parameter_list|,
name|int
name|duration
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|blink_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
end_ifdef

begin_function_decl
specifier|static
name|void
name|toggle_splash_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|isa_driver
name|scdriver
init|=
block|{
name|scprobe
block|,
name|scattach
block|,
literal|"sc"
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|scopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|scclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|scread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|scwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|scioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_devtotty_t
name|scdevtotty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|scmmap
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|12
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|scdevsw
init|=
block|{
name|scopen
block|,
name|scclose
block|,
name|scread
block|,
name|scwrite
block|,
name|scioctl
block|,
name|nullstop
block|,
name|noreset
block|,
name|scdevtotty
block|,
name|ttselect
block|,
name|scmmap
block|,
name|nostrategy
block|,
literal|"sc"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These functions need to be before calls to them so they can be inlined.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|draw_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
name|cursor_image
decl_stmt|,
modifier|*
name|ptr
init|=
name|Crtat
operator|+
operator|(
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
decl_stmt|;
comment|/* do we have a destructive cursor ? */
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
block|{
name|cursor_image
operator|=
operator|*
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|scp
operator|->
name|cursor_saveunder
operator|=
name|cursor_image
expr_stmt|;
comment|/* modify cursor_image */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
operator|&&
operator|(
name|blinkrate
operator|&
literal|4
operator|)
operator|)
condition|)
block|{
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|cursor_image
operator|&=
literal|0xff00
expr_stmt|;
name|cursor_image
operator||=
name|DEAD_CHAR
expr_stmt|;
block|}
block|}
else|else
block|{
name|cursor_image
operator|=
operator|(
operator|*
operator|(
name|ptr
operator|)
operator|&
literal|0x00ff
operator|)
operator||
operator|*
operator|(
name|scp
operator|->
name|cursor_pos
operator|)
operator|&
literal|0xff00
expr_stmt|;
name|scp
operator|->
name|cursor_saveunder
operator|=
name|cursor_image
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
operator|&&
operator|(
name|blinkrate
operator|&
literal|4
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cursor_image
operator|&
literal|0x7000
operator|)
operator|==
literal|0x7000
condition|)
block|{
name|cursor_image
operator|&=
literal|0x8fff
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cursor_image
operator|&
literal|0x0700
operator|)
condition|)
name|cursor_image
operator||=
literal|0x0700
expr_stmt|;
block|}
else|else
block|{
name|cursor_image
operator||=
literal|0x7000
expr_stmt|;
if|if
condition|(
operator|(
name|cursor_image
operator|&
literal|0x0700
operator|)
operator|==
literal|0x0700
condition|)
name|cursor_image
operator|&=
literal|0xf0ff
expr_stmt|;
block|}
block|}
block|}
operator|*
name|ptr
operator|=
name|cursor_image
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|remove_cursor_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
operator|*
operator|(
name|Crtat
operator|+
operator|(
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
operator|=
name|scp
operator|->
name|cursor_saveunder
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|move_crsr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|0
condition|)
name|y
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|>=
name|scp
operator|->
name|xsize
condition|)
name|x
operator|=
name|scp
operator|->
name|xsize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|y
operator|>=
name|scp
operator|->
name|ysize
condition|)
name|y
operator|=
name|scp
operator|->
name|ysize
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|xpos
operator|=
name|x
expr_stmt|;
name|scp
operator|->
name|ypos
operator|=
name|y
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|xpos
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|scprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|codeset
decl_stmt|;
name|int
name|c
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|m
decl_stmt|;
name|sc_port
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
name|sc_kbdc
operator|=
name|kbdc_open
argument_list|(
name|sc_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* driver error? */
name|printf
argument_list|(
literal|"sc%d: unable to lock the controller.\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|dev
operator|->
name|id_flags
operator|&
name|DETECT_KBD
operator|)
condition|?
literal|0
else|:
name|IO_KBDSIZE
operator|)
return|;
block|}
comment|/* discard anything left after UserConfig */
name|empty_both_buffers
argument_list|(
name|sc_kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* save the current keyboard controller command byte */
name|m
operator|=
name|kbdc_get_device_mask
argument_list|(
name|sc_kbdc
argument_list|)
operator|&
operator|~
name|KBD_KBD_CONTROL_BITS
expr_stmt|;
name|c
operator|=
name|get_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|printf
argument_list|(
literal|"sc%d: unable to get the current command byte value.\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: the current keyboard controller command byte %04x\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* override the keyboard lock switch */
block|c |= KBD_OVERRIDE_KBD_LOCK;
endif|#
directive|endif
comment|/*      * enable the keyboard port, but disable the keyboard intr.       * the aux port (mouse port) is disabled too.      */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
argument_list|,
name|KBD_ENABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR  	 * there is very little we can do... 	 */
name|printf
argument_list|(
literal|"sc%d: unable to set the command byte.\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/*        * Check if we have an XT keyboard before we attempt to reset it.        * The procedure assumes that the keyboard and the controller have        * been set up properly by BIOS and have not been messed up        * during the boot process.       */
name|codeset
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_flags
operator|&
name|XT_KEYBD
condition|)
comment|/* the user says there is a XT keyboard */
name|codeset
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DETECT_XT_KEYBOARD
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
name|KBD_TRANSLATION
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* SET_SCANCODE_SET is not always supported; ignore error */
if|if
condition|(
name|send_kbd_command_and_data
argument_list|(
name|sc_kbdc
argument_list|,
name|KBDC_SET_SCANCODE_SET
argument_list|,
literal|0
argument_list|)
operator|==
name|KBD_ACK
condition|)
name|codeset
operator|=
name|read_kbd_data
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: keyboard scancode set %d\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|codeset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DETECT_XT_KEYBOARD */
comment|/* reset keyboard hardware */
if|if
condition|(
operator|!
name|reset_kbd
argument_list|(
name|sc_kbdc
argument_list|)
condition|)
block|{
comment|/* KEYBOARD ERROR 	 * Keyboard reset may fail either because the keyboard doen't exist,          * or because the keyboard doesn't pass the self-test, or the keyboard           * controller on the motherboard and the keyboard somehow fail to           * shake hands. It is just possible, particularly in the last case,          * that the keyoard controller may be left in a hung state.           * test_controller() and test_kbd_port() appear to bring the keyboard          * controller back (I don't know why and how, though.) 	 */
name|empty_both_buffers
argument_list|(
name|sc_kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|test_controller
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
comment|/* We could disable the keyboard port and interrupt... but,  	 * the keyboard may still exist (see above).  	 */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"sc%d: failed to reset the keyboard.\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/*      * Allow us to set the XT_KEYBD flag in UserConfig so that keyboards      * such as those on the IBM ThinkPad laptop computers can be used      * with the standard console driver.      */
if|if
condition|(
name|codeset
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|send_kbd_command_and_data
argument_list|(
name|sc_kbdc
argument_list|,
name|KBDC_SET_SCANCODE_SET
argument_list|,
name|codeset
argument_list|)
operator|==
name|KBD_ACK
condition|)
block|{
comment|/* XT kbd doesn't need scan code translation */
name|c
operator|&=
operator|~
name|KBD_TRANSLATION
expr_stmt|;
block|}
else|else
block|{
comment|/* KEYBOARD ERROR  	     * The XT kbd isn't usable unless the proper scan code set 	     * is selected.  	     */
name|printf
argument_list|(
literal|"sc%d: unable to set the XT keyboard mode.\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* enable the keyboard port and intr. */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
operator||
name|KBD_OVERRIDE_KBD_LOCK
argument_list|,
operator|(
name|c
operator|&
operator|(
name|KBD_AUX_CONTROL_BITS
operator||
name|KBD_OVERRIDE_KBD_LOCK
operator|)
operator|)
operator||
name|KBD_ENABLE_KBD_PORT
operator||
name|KBD_ENABLE_KBD_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR  	 * This is serious; we are left with the disabled keyboard intr.  	 */
name|printf
argument_list|(
literal|"sc%d: unable to enable the keyboard port and intr.\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|succeed
label|:
name|kbdc_set_device_mask
argument_list|(
name|sc_kbdc
argument_list|,
name|m
operator||
name|KBD_KBD_CONTROL_BITS
argument_list|)
operator|,
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|IO_KBDSIZE
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|c
operator|!=
operator|-
literal|1
condition|)
comment|/* try to restore the command byte as before, if possible */
name|set_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|,
literal|0xff
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|kbdc_set_device_mask
argument_list|(
name|sc_kbdc
argument_list|,
operator|(
name|dev
operator|->
name|id_flags
operator|&
name|DETECT_KBD
operator|)
condition|?
name|m
else|:
name|m
operator||
name|KBD_KBD_CONTROL_BITS
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|dev
operator|->
name|id_flags
operator|&
name|DETECT_KBD
operator|)
condition|?
literal|0
else|:
name|IO_KBDSIZE
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_function
specifier|static
name|int
name|scresume
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|shfts
operator|=
name|ctls
operator|=
name|alts
operator|=
name|agrs
operator|=
name|metas
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|scattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|dev_t
name|cdev
init|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|int
name|vc
decl_stmt|;
endif|#
directive|endif
name|scinit
argument_list|()
expr_stmt|;
name|flags
operator|=
name|dev
operator|->
name|id_flags
expr_stmt|;
name|scp
operator|=
name|console
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|crtc_vga
condition|)
block|{
name|cut_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|scr_buf
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
comment|/* copy temporary buffer to final buffer */
name|bcopyw
argument_list|(
name|sc_buffer
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|=
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xpos
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_ypos
operator|/
name|scp
operator|->
name|font_size
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|mouse_xpos
operator|/
literal|8
operator|)
expr_stmt|;
comment|/* initialize history buffer& pointers */
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history_pos
operator|=
name|scp
operator|->
name|history
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|scp
operator|->
name|history_head
argument_list|,
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize cursor stuff */
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc_vga
operator|&&
operator|(
name|flags
operator|&
name|CHAR_CURSOR
operator|)
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
comment|/* get screen update going */
name|scrn_timer
argument_list|()
expr_stmt|;
name|update_leds
argument_list|(
name|scp
operator|->
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sc%d: "
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc_vga
condition|)
if|if
condition|(
name|crtc_addr
operator|==
name|MONO_BASE
condition|)
name|printf
argument_list|(
literal|"VGA mono"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"VGA color"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|crtc_addr
operator|==
name|MONO_BASE
condition|)
name|printf
argument_list|(
literal|"MDA/hercules"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"CGA/EGA"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<%d virtual consoles, flags=0x%x>\n"
argument_list|,
name|MAXCONS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|NAPM
operator|>
literal|0
name|scp
operator|->
name|r_hook
operator|.
name|ah_fun
operator|=
name|scresume
expr_stmt|;
name|scp
operator|->
name|r_hook
operator|.
name|ah_arg
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|r_hook
operator|.
name|ah_name
operator|=
literal|"system keyboard"
expr_stmt|;
name|scp
operator|->
name|r_hook
operator|.
name|ah_order
operator|=
name|APM_MID_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_RESUME
argument_list|,
operator|&
name|scp
operator|->
name|r_hook
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cdevsw_add
argument_list|(
operator|&
name|cdev
argument_list|,
operator|&
name|scdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
for|for
control|(
name|vc
operator|=
literal|0
init|;
name|vc
operator|<
name|MAXCONS
condition|;
name|vc
operator|++
control|)
name|sc_devfs_token
index|[
name|vc
index|]
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|scdevsw
argument_list|,
name|vc
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"ttyv%n"
argument_list|,
name|vc
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|tty
modifier|*
name|scdevtotty
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|init_done
operator|==
name|COLD
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|unit
operator|==
name|SC_CONSOLE
condition|)
return|return
name|CONSOLE_TTY
return|;
if|if
condition|(
name|unit
operator|==
name|SC_MOUSE
condition|)
return|return
name|MOUSE_TTY
return|;
if|if
condition|(
name|unit
operator|>=
name|MAXCONS
operator|||
name|unit
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
name|VIRTUAL_TTY
argument_list|(
name|unit
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|scopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|->
name|t_oproc
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
name|SC_MOUSE
operator|)
condition|?
name|scmousestart
else|:
name|scstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|scparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
name|scparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
name|MAXCONS
operator|&&
operator|!
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
condition|)
block|{
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|=
name|alloc_scp
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
name|MAXCONS
operator|&&
operator|!
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|&&
operator|!
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
condition|)
block|{
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|=
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|xsize
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
operator|=
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|ysize
expr_stmt|;
block|}
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|scr_stat
modifier|*
name|scp
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|<
name|MAXCONS
condition|)
block|{
name|scp
operator|=
name|get_scr_stat
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_ACQ
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|smode
argument_list|)
expr_stmt|;
if|#
directive|if
name|not_yet_done
if|if
condition|(
name|scp
operator|==
operator|&
name|main_console
condition|)
block|{
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|console
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
endif|#
directive|endif
block|}
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|spl0
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|scwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|scintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|static
name|struct
name|tty
modifier|*
name|cur_tty
decl_stmt|;
name|int
name|c
decl_stmt|,
name|len
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* make screensaver happy */
name|scrn_time_stamp
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|scrn_blanked
condition|)
block|{
call|(
modifier|*
name|current_saver
call|)
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
comment|/*       * Loop while there is still input to get from the keyboard.      * I don't think this is nessesary, and it doesn't fix      * the Xaccel-2.1 keyboard hang, but it can't hurt.		XXX      */
while|while
condition|(
operator|(
name|c
operator|=
name|scgetc
argument_list|(
name|SCGETC_NONBLOCK
argument_list|)
operator|)
operator|!=
name|NOKEY
condition|)
block|{
name|cur_tty
operator|=
name|VIRTUAL_TTY
argument_list|(
name|get_scr_num
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cur_tty
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
if|if
condition|(
operator|!
operator|(
operator|(
name|cur_tty
operator|=
name|CONSOLE_TTY
operator|)
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
continue|continue;
switch|switch
condition|(
name|c
operator|&
literal|0xff00
condition|)
block|{
case|case
literal|0x0000
case|:
comment|/* normal key */
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|&
literal|0xFF
operator|,
name|cur_tty
operator|)
expr_stmt|;
break|break;
case|case
name|FKEY
case|:
comment|/* function key, return string */
if|if
condition|(
name|cp
operator|=
name|get_fstr
argument_list|(
operator|(
name|u_int
operator|)
name|c
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|len
argument_list|)
condition|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|*
name|cp
operator|++
operator|&
literal|0xFF
operator|,
name|cur_tty
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|MKEY
case|:
comment|/* meta is active, prepend ESC */
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|0x1b
operator|,
name|cur_tty
operator|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|&
literal|0xFF
operator|,
name|cur_tty
operator|)
expr_stmt|;
break|break;
case|case
name|BKEY
case|:
comment|/* backtab fixed sequence (esc [ Z) */
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|0x1b
operator|,
name|cur_tty
operator|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|'['
operator|,
name|cur_tty
operator|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|cur_tty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|'Z'
operator|,
name|cur_tty
operator|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|MOUSE_ENABLED
condition|)
block|{
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|MOUSE_VISIBLE
expr_stmt|;
name|remove_mouse_image
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|scparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|scioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|fp
decl_stmt|;
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|tp
operator|=
name|scdevtotty
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
name|ENXIO
return|;
name|scp
operator|=
name|get_scr_stat
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
comment|/* If there is a user_ioctl function call that first */
if|if
condition|(
name|sc_user_ioctl
condition|)
block|{
if|if
condition|(
name|error
operator|=
call|(
modifier|*
name|sc_user_ioctl
call|)
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
condition|)
return|return
name|error
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* process console hardware related ioctl's */
case|case
name|GIO_ATTR
case|:
comment|/* get current attributes */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_COLOR
case|:
comment|/* is this a color console ? */
if|if
condition|(
name|crtc_addr
operator|==
name|COLOR_BASE
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|1
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_CURRENT
case|:
comment|/* get current adapter type */
if|if
condition|(
name|crtc_vga
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|KD_VGA
expr_stmt|;
elseif|else
if|if
condition|(
name|crtc_addr
operator|==
name|MONO_BASE
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|KD_MONO
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|KD_CGA
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_GET
case|:
comment|/* get current video mode */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|scp
operator|->
name|mode
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_BLANKTIME
case|:
comment|/* set screen saver timeout (0 = no saver) */
name|scrn_blank_time
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_CURSORTYPE
case|:
comment|/* set cursor type blink/noblink */
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0x01
condition|)
name|flags
operator||=
name|BLINK_CURSOR
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|BLINK_CURSOR
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0x02
condition|)
block|{
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
name|flags
operator||=
name|CHAR_CURSOR
expr_stmt|;
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
name|flags
operator|&=
operator|~
name|CHAR_CURSOR
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_BELLTYPE
case|:
comment|/* set bell type sound/visual */
if|if
condition|(
operator|*
name|data
condition|)
name|flags
operator||=
name|VISUAL_BELL
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|VISUAL_BELL
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CONS_HISTORY
case|:
comment|/* set history size */
if|if
condition|(
operator|*
name|data
condition|)
block|{
name|free
argument_list|(
name|scp
operator|->
name|history
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history_size
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history_size
operator|<
name|scp
operator|->
name|ysize
condition|)
name|scp
operator|->
name|history
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|scp
operator|->
name|history_size
operator|*=
name|scp
operator|->
name|xsize
expr_stmt|;
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history_pos
operator|=
name|scp
operator|->
name|history
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|scp
operator|->
name|history_head
argument_list|,
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
case|case
name|CONS_MOUSECTL
case|:
comment|/* control mouse arrow */
block|{
name|mouse_info_t
modifier|*
name|mouse
init|=
operator|(
name|mouse_info_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
switch|switch
condition|(
name|mouse
operator|->
name|operation
condition|)
block|{
case|case
name|MOUSE_MODE
case|:
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|mode
operator|.
name|signal
operator|>
literal|0
operator|&&
name|mouse
operator|->
name|u
operator|.
name|mode
operator|.
name|signal
operator|<
name|NSIG
condition|)
block|{
name|scp
operator|->
name|mouse_signal
operator|=
name|mouse
operator|->
name|u
operator|.
name|mode
operator|.
name|signal
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|p
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_SHOW
case|:
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_ENABLED
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator||=
operator|(
name|MOUSE_ENABLED
operator||
name|MOUSE_VISIBLE
operator|)
expr_stmt|;
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|EINVAL
return|;
break|break;
case|case
name|MOUSE_HIDE
case|:
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_ENABLED
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
operator|(
name|MOUSE_ENABLED
operator||
name|MOUSE_VISIBLE
operator|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|EINVAL
return|;
break|break;
case|case
name|MOUSE_MOVEABS
case|:
name|scp
operator|->
name|mouse_xpos
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_MOVEREL
case|:
name|scp
operator|->
name|mouse_xpos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
name|set_mouse_pos
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETINFO
case|:
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|=
name|scp
operator|->
name|mouse_xpos
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|=
name|scp
operator|->
name|mouse_ypos
expr_stmt|;
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|=
name|scp
operator|->
name|mouse_buttons
expr_stmt|;
break|break;
case|case
name|MOUSE_ACTION
case|:
comment|/* this should maybe only be settable from /dev/consolectl SOS */
comment|/* send out mouse event on /dev/sysmouse */
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|MOUSE_ENABLED
condition|)
name|cur_console
operator|->
name|status
operator||=
name|MOUSE_VISIBLE
expr_stmt|;
if|if
condition|(
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|u_char
name|buf
index|[
literal|5
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
operator|~
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|&
literal|0x1fe
operator|>>
literal|1
operator|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
operator|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|&
literal|0x1ff
operator|)
operator|-
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
operator|-
operator|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|&
literal|0x1fe
operator|>>
literal|1
operator|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
operator|-
operator|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|&
literal|0x1ff
operator|)
operator|-
name|buf
index|[
literal|2
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
operator|(
name|MOUSE_TTY
operator|)
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|buf
index|[
name|i
index|]
operator|,
name|MOUSE_TTY
operator|)
expr_stmt|;
block|}
name|cur_console
operator|->
name|mouse_xpos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
expr_stmt|;
name|cur_console
operator|->
name|mouse_ypos
operator|+=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|mouse_signal
condition|)
block|{
name|cur_console
operator|->
name|mouse_buttons
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
expr_stmt|;
comment|/* has controlling process died? */
if|if
condition|(
name|cur_console
operator|->
name|mouse_proc
operator|&&
operator|(
name|cur_console
operator|->
name|mouse_proc
operator|!=
name|pfind
argument_list|(
name|cur_console
operator|->
name|mouse_pid
argument_list|)
operator|)
condition|)
block|{
name|cur_console
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|cur_console
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|cur_console
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|psignal
argument_list|(
name|cur_console
operator|->
name|mouse_proc
argument_list|,
name|cur_console
operator|->
name|mouse_signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* process button presses */
if|if
condition|(
name|cur_console
operator|->
name|mouse_buttons
operator|!=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
condition|)
block|{
name|cur_console
operator|->
name|mouse_buttons
operator|=
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|buttons
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
if|if
condition|(
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|LEFT_BUTTON
condition|)
name|mouse_cut_start
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
else|else
name|mouse_cut_end
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|RIGHT_BUTTON
operator|||
name|cur_console
operator|->
name|mouse_buttons
operator|&
name|MIDDLE_BUTTON
condition|)
name|mouse_paste
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|x
operator|!=
literal|0
operator|||
name|mouse
operator|->
name|u
operator|.
name|data
operator|.
name|y
operator|!=
literal|0
condition|)
name|set_mouse_pos
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* make screensaver happy */
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
block|{
name|scrn_time_stamp
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|scrn_blanked
condition|)
block|{
call|(
modifier|*
name|current_saver
call|)
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
case|case
name|CONS_GETINFO
case|:
comment|/* get current (virtual) console info */
block|{
name|vid_info_t
modifier|*
name|ptr
init|=
operator|(
name|vid_info_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|ptr
operator|->
name|size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|vid_info
argument_list|)
condition|)
block|{
name|ptr
operator|->
name|m_num
operator|=
name|get_scr_num
argument_list|()
expr_stmt|;
name|ptr
operator|->
name|mv_col
operator|=
name|scp
operator|->
name|xpos
expr_stmt|;
name|ptr
operator|->
name|mv_row
operator|=
name|scp
operator|->
name|ypos
expr_stmt|;
name|ptr
operator|->
name|mv_csz
operator|=
name|scp
operator|->
name|xsize
expr_stmt|;
name|ptr
operator|->
name|mv_rsz
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|ptr
operator|->
name|mv_norm
operator|.
name|fore
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
expr_stmt|;
name|ptr
operator|->
name|mv_norm
operator|.
name|back
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
expr_stmt|;
name|ptr
operator|->
name|mv_rev
operator|.
name|fore
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
expr_stmt|;
name|ptr
operator|->
name|mv_rev
operator|.
name|back
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
expr_stmt|;
name|ptr
operator|->
name|mv_grfc
operator|.
name|fore
operator|=
literal|0
expr_stmt|;
comment|/* not supported */
name|ptr
operator|->
name|mv_grfc
operator|.
name|back
operator|=
literal|0
expr_stmt|;
comment|/* not supported */
name|ptr
operator|->
name|mv_ovscan
operator|=
name|scp
operator|->
name|border
expr_stmt|;
name|ptr
operator|->
name|mk_keylock
operator|=
name|scp
operator|->
name|status
operator|&
name|LOCK_KEY_MASK
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
case|case
name|CONS_GETVERS
case|:
comment|/* get version number */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0x200
expr_stmt|;
comment|/* version 2.0 */
return|return
literal|0
return|;
comment|/* VGA TEXT MODES */
case|case
name|SW_VGA_C40x25
case|:
case|case
name|SW_VGA_C80x25
case|:
case|case
name|SW_VGA_M80x25
case|:
case|case
name|SW_VGA_C80x30
case|:
case|case
name|SW_VGA_M80x30
case|:
case|case
name|SW_VGA_C80x50
case|:
case|case
name|SW_VGA_M80x50
case|:
case|case
name|SW_VGA_C80x60
case|:
case|case
name|SW_VGA_M80x60
case|:
case|case
name|SW_B40x25
case|:
case|case
name|SW_C40x25
case|:
case|case
name|SW_B80x25
case|:
case|case
name|SW_C80x25
case|:
case|case
name|SW_ENH_B40x25
case|:
case|case
name|SW_ENH_C40x25
case|:
case|case
name|SW_ENH_B80x25
case|:
case|case
name|SW_ENH_C80x25
case|:
case|case
name|SW_ENH_B80x43
case|:
case|case
name|SW_ENH_C80x43
case|:
if|if
condition|(
operator|!
name|crtc_vga
operator|||
name|video_mode_ptr
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
switch|switch
condition|(
name|cmd
operator|&
literal|0xff
condition|)
block|{
case|case
name|M_VGA_C80x60
case|:
case|case
name|M_VGA_M80x60
case|:
if|if
condition|(
operator|!
operator|(
name|fonts_loaded
operator|&
name|FONT_8
operator|)
condition|)
return|return
name|EINVAL
return|;
name|scp
operator|->
name|xsize
operator|=
literal|80
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
literal|60
expr_stmt|;
break|break;
case|case
name|M_VGA_C80x50
case|:
case|case
name|M_VGA_M80x50
case|:
if|if
condition|(
operator|!
operator|(
name|fonts_loaded
operator|&
name|FONT_8
operator|)
condition|)
return|return
name|EINVAL
return|;
name|scp
operator|->
name|xsize
operator|=
literal|80
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
literal|50
expr_stmt|;
break|break;
case|case
name|M_ENH_B80x43
case|:
case|case
name|M_ENH_C80x43
case|:
if|if
condition|(
operator|!
operator|(
name|fonts_loaded
operator|&
name|FONT_8
operator|)
condition|)
return|return
name|EINVAL
return|;
name|scp
operator|->
name|xsize
operator|=
literal|80
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
literal|43
expr_stmt|;
break|break;
case|case
name|M_VGA_C80x30
case|:
case|case
name|M_VGA_M80x30
case|:
name|scp
operator|->
name|xsize
operator|=
literal|80
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
literal|30
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|cmd
operator|&
literal|0xff
operator|)
operator|>
name|M_VGA_CG320
condition|)
return|return
name|EINVAL
return|;
else|else
name|scp
operator|->
name|xsize
operator|=
operator|*
operator|(
name|video_mode_ptr
operator|+
operator|(
operator|(
name|cmd
operator|&
literal|0xff
operator|)
operator|*
literal|64
operator|)
operator|)
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
operator|*
operator|(
name|video_mode_ptr
operator|+
operator|(
operator|(
name|cmd
operator|&
literal|0xff
operator|)
operator|*
literal|64
operator|)
operator|+
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
break|break;
block|}
name|scp
operator|->
name|mode
operator|=
name|cmd
operator|&
literal|0xff
expr_stmt|;
name|free
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|scp
operator|->
name|scr_buf
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|=
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xpos
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_ypos
operator|/
name|scp
operator|->
name|font_size
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|mouse_xpos
operator|/
literal|8
operator|)
expr_stmt|;
name|free
argument_list|(
name|cut_buffer
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cut_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|cut_buffer
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
name|clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|!=
name|scp
operator|->
name|xsize
operator|||
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
operator|!=
name|scp
operator|->
name|ysize
condition|)
block|{
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|=
name|scp
operator|->
name|xsize
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|pgsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGWINCH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* GRAPHICS MODES */
case|case
name|SW_BG320
case|:
case|case
name|SW_BG640
case|:
case|case
name|SW_CG320
case|:
case|case
name|SW_CG320_D
case|:
case|case
name|SW_CG640_E
case|:
case|case
name|SW_CG640x350
case|:
case|case
name|SW_ENH_CG640
case|:
case|case
name|SW_BG640x480
case|:
case|case
name|SW_CG640x480
case|:
case|case
name|SW_VGA_CG320
case|:
if|if
condition|(
operator|!
name|crtc_vga
operator|||
name|video_mode_ptr
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|scp
operator|->
name|mode
operator|=
name|cmd
operator|&
literal|0xFF
expr_stmt|;
name|scp
operator|->
name|xpixel
operator|=
operator|(
operator|*
operator|(
name|video_mode_ptr
operator|+
operator|(
name|scp
operator|->
name|mode
operator|*
literal|64
operator|)
operator|)
operator|)
operator|*
literal|8
expr_stmt|;
name|scp
operator|->
name|ypixel
operator|=
operator|(
operator|*
operator|(
name|video_mode_ptr
operator|+
operator|(
name|scp
operator|->
name|mode
operator|*
literal|64
operator|)
operator|+
literal|1
operator|)
operator|+
literal|1
operator|)
operator|*
operator|(
operator|*
operator|(
name|video_mode_ptr
operator|+
operator|(
name|scp
operator|->
name|mode
operator|*
literal|64
operator|)
operator|+
literal|2
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|UNKNOWN_MODE
expr_stmt|;
comment|/* graphics mode */
comment|/* clear_graphics();*/
if|if
condition|(
name|tp
operator|->
name|t_winsize
operator|.
name|ws_xpixel
operator|!=
name|scp
operator|->
name|xpixel
operator|||
name|tp
operator|->
name|t_winsize
operator|.
name|ws_ypixel
operator|!=
name|scp
operator|->
name|ypixel
condition|)
block|{
name|tp
operator|->
name|t_winsize
operator|.
name|ws_xpixel
operator|=
name|scp
operator|->
name|xpixel
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_ypixel
operator|=
name|scp
operator|->
name|ypixel
expr_stmt|;
name|pgsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|SIGWINCH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|VT_SETMODE
case|:
comment|/* set screen switcher mode */
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|scp
operator|->
name|smode
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vt_mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|scp
operator|->
name|proc
operator|=
name|p
expr_stmt|;
name|scp
operator|->
name|pid
operator|=
name|scp
operator|->
name|proc
operator|->
name|p_pid
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|VT_GETMODE
case|:
comment|/* get screen switcher mode */
name|bcopy
argument_list|(
operator|&
name|scp
operator|->
name|smode
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vt_mode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|VT_RELDISP
case|:
comment|/* screen switcher ioctl */
switch|switch
condition|(
operator|*
name|data
condition|)
block|{
case|case
name|VT_FALSE
case|:
comment|/* user refuses to release screen, abort */
if|if
condition|(
name|scp
operator|==
name|old_scp
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_REL
operator|)
condition|)
block|{
name|old_scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_REL
expr_stmt|;
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
case|case
name|VT_TRUE
case|:
comment|/* user has released screen, go on */
if|if
condition|(
name|scp
operator|==
name|old_scp
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_REL
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_REL
expr_stmt|;
name|exchange_scr
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|new_scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|psignal
argument_list|(
name|new_scp
operator|->
name|proc
argument_list|,
name|new_scp
operator|->
name|smode
operator|.
name|acqsig
argument_list|)
expr_stmt|;
block|}
else|else
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
case|case
name|VT_ACKACQ
case|:
comment|/* acquire acknowledged, switch completed */
if|if
condition|(
name|scp
operator|==
name|new_scp
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|SWITCH_WAIT_ACQ
operator|)
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* NOT REACHED */
case|case
name|VT_OPENQRY
case|:
comment|/* return free virtual console */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCONS
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|VIRTUAL_TTY
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
operator|*
name|data
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|EINVAL
return|;
case|case
name|VT_ACTIVATE
case|:
comment|/* switch to screen *data */
return|return
name|switch_scr
argument_list|(
name|scp
argument_list|,
operator|(
operator|*
name|data
operator|)
operator|-
literal|1
argument_list|)
return|;
case|case
name|VT_WAITACTIVE
case|:
comment|/* wait for switch to occur */
if|if
condition|(
operator|*
name|data
operator|>
name|MAXCONS
operator|||
operator|*
name|data
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
operator|(
operator|*
name|data
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
name|data
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
return|return
literal|0
return|;
block|}
else|else
name|scp
operator|=
name|console
index|[
operator|(
operator|*
name|data
operator|)
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|scp
operator|->
name|smode
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"waitvt"
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|ERESTART
condition|)
empty_stmt|;
return|return
name|error
return|;
case|case
name|VT_GETACTIVE
case|:
operator|*
name|data
operator|=
name|get_scr_num
argument_list|()
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDENABIO
case|:
comment|/* allow io operations */
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|securelevel
operator|>
literal|0
condition|)
return|return
name|EPERM
return|;
name|fp
operator|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
name|p
operator|->
name|p_md
operator|.
name|md_regs
expr_stmt|;
name|fp
operator|->
name|tf_eflags
operator||=
name|PSL_IOPL
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDDISABIO
case|:
comment|/* disallow io operations (default) */
name|fp
operator|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
name|p
operator|->
name|p_md
operator|.
name|md_regs
expr_stmt|;
name|fp
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_IOPL
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSETMODE
case|:
comment|/* set current mode of this (virtual) console */
switch|switch
condition|(
operator|*
name|data
condition|)
block|{
case|case
name|KD_TEXT
case|:
comment|/* switch to TEXT (known) mode */
comment|/* restore fonts& palette ! */
if|if
condition|(
name|crtc_vga
condition|)
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_8
condition|)
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_8
argument_list|,
name|font_8
argument_list|)
expr_stmt|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_14
condition|)
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_14
argument_list|,
name|font_14
argument_list|)
expr_stmt|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_16
condition|)
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|load_palette
argument_list|(
name|palette
argument_list|)
expr_stmt|;
block|}
comment|/* FALL THROUGH */
case|case
name|KD_TEXT1
case|:
comment|/* switch to TEXT (known) mode */
comment|/* no restore fonts& palette */
if|if
condition|(
name|crtc_vga
operator|&&
name|video_mode_ptr
condition|)
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
name|clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KD_GRAPHICS
case|:
comment|/* switch to GRAPHICS (unknown) mode */
name|scp
operator|->
name|status
operator||=
name|UNKNOWN_MODE
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* NOT REACHED */
case|case
name|KDGETMODE
case|:
comment|/* get current mode of this (virtual) console */
operator|*
name|data
operator|=
operator|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|?
name|KD_GRAPHICS
else|:
name|KD_TEXT
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSBORDER
case|:
comment|/* set border color of this (virtual) console */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
name|scp
operator|->
name|border
operator|=
operator|*
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|set_border
argument_list|(
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSKBSTATE
case|:
comment|/* set keyboard state (locks) */
if|if
condition|(
operator|*
name|data
operator|>=
literal|0
operator|&&
operator|*
name|data
operator|<=
name|LOCK_KEY_MASK
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|LOCK_KEY_MASK
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|*
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|update_leds
argument_list|(
name|scp
operator|->
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
case|case
name|KDGKBSTATE
case|:
comment|/* get keyboard state (locks) */
operator|*
name|data
operator|=
name|scp
operator|->
name|status
operator|&
name|LOCK_KEY_MASK
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSETRAD
case|:
comment|/* set keyboard repeat& delay rates */
if|if
condition|(
operator|*
name|data
operator|&
literal|0x80
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|sc_kbdc
operator|!=
name|NULL
condition|)
name|set_keyboard
argument_list|(
name|KBDC_SET_TYPEMATIC
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDSKBMODE
case|:
comment|/* set keyboard mode */
switch|switch
condition|(
operator|*
name|data
condition|)
block|{
case|case
name|K_RAW
case|:
comment|/* switch to RAW scancode mode */
name|scp
operator|->
name|status
operator||=
name|KBD_RAW_MODE
expr_stmt|;
return|return
literal|0
return|;
case|case
name|K_XLATE
case|:
comment|/* switch to XLT ascii mode */
if|if
condition|(
name|scp
operator|==
name|cur_console
operator|&&
name|scp
operator|->
name|status
operator|==
name|KBD_RAW_MODE
condition|)
name|shfts
operator|=
name|ctls
operator|=
name|alts
operator|=
name|agrs
operator|=
name|metas
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|KBD_RAW_MODE
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
comment|/* NOT REACHED */
case|case
name|KDGKBMODE
case|:
comment|/* get keyboard mode */
operator|*
name|data
operator|=
operator|(
name|scp
operator|->
name|status
operator|&
name|KBD_RAW_MODE
operator|)
condition|?
name|K_RAW
else|:
name|K_XLATE
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KDMKTONE
case|:
comment|/* sound the bell */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|do_bell
argument_list|(
name|scp
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|0xffff
argument_list|,
operator|(
operator|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|do_bell
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|bell_pitch
argument_list|,
name|scp
operator|->
name|bell_duration
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KIOCSOUND
case|:
comment|/* make tone (*data) hz */
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
name|int
name|pitch
init|=
name|timer_freq
operator|/
operator|*
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
comment|/* set command for counter 2, 2 byte write */
if|if
condition|(
name|acquire_timer2
argument_list|(
name|TIMER_16BIT
operator||
name|TIMER_SQWAVE
argument_list|)
condition|)
return|return
name|EBUSY
return|;
comment|/* set pitch */
name|outb
argument_list|(
name|TIMER_CNTR2
argument_list|,
name|pitch
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TIMER_CNTR2
argument_list|,
operator|(
name|pitch
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
comment|/* enable counter 2 output to speaker */
name|outb
argument_list|(
name|IO_PPI
argument_list|,
name|inb
argument_list|(
name|IO_PPI
argument_list|)
operator||
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* disable counter 2 output to speaker */
name|outb
argument_list|(
name|IO_PPI
argument_list|,
name|inb
argument_list|(
name|IO_PPI
argument_list|)
operator|&
literal|0xFC
argument_list|)
expr_stmt|;
name|release_timer2
argument_list|()
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
case|case
name|KDGKBTYPE
case|:
comment|/* get keyboard type */
operator|*
name|data
operator|=
literal|0
expr_stmt|;
comment|/* type not known (yet) */
return|return
literal|0
return|;
case|case
name|KDSETLED
case|:
comment|/* set keyboard LED status */
if|if
condition|(
operator|*
name|data
operator|>=
literal|0
operator|&&
operator|*
name|data
operator|<=
name|LED_MASK
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|LED_MASK
expr_stmt|;
name|scp
operator|->
name|status
operator||=
operator|*
name|data
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|update_leds
argument_list|(
name|scp
operator|->
name|status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
case|case
name|KDGETLED
case|:
comment|/* get keyboard LED status */
operator|*
name|data
operator|=
name|scp
operator|->
name|status
operator|&
name|LED_MASK
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GETFKEY
case|:
comment|/* get functionkey string */
if|if
condition|(
operator|*
operator|(
name|u_short
operator|*
operator|)
name|data
operator|<
name|n_fkey_tab
condition|)
block|{
name|fkeyarg_t
modifier|*
name|ptr
init|=
operator|(
name|fkeyarg_t
operator|*
operator|)
name|data
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|str
argument_list|,
name|ptr
operator|->
name|keydef
argument_list|,
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|flen
operator|=
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
case|case
name|SETFKEY
case|:
comment|/* set functionkey string */
if|if
condition|(
operator|*
operator|(
name|u_short
operator|*
operator|)
name|data
operator|<
name|n_fkey_tab
condition|)
block|{
name|fkeyarg_t
modifier|*
name|ptr
init|=
operator|(
name|fkeyarg_t
operator|*
operator|)
name|data
decl_stmt|;
name|bcopy
argument_list|(
name|ptr
operator|->
name|keydef
argument_list|,
operator|&
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|str
argument_list|,
name|min
argument_list|(
name|ptr
operator|->
name|flen
argument_list|,
name|MAXFK
argument_list|)
argument_list|)
expr_stmt|;
name|fkey_tab
index|[
name|ptr
operator|->
name|keynum
index|]
operator|.
name|len
operator|=
name|min
argument_list|(
name|ptr
operator|->
name|flen
argument_list|,
name|MAXFK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
case|case
name|GIO_SCRNMAP
case|:
comment|/* get output translation table */
name|bcopy
argument_list|(
operator|&
name|scr_map
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PIO_SCRNMAP
case|:
comment|/* set output translation table */
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|scr_map
argument_list|,
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
condition|;
name|i
operator|++
control|)
name|scr_rmap
index|[
name|scr_map
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_KEYMAP
case|:
comment|/* get keyboard translation table */
name|bcopy
argument_list|(
operator|&
name|key_map
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|key_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PIO_KEYMAP
case|:
comment|/* set keyboard translation table */
name|bcopy
argument_list|(
name|data
argument_list|,
operator|&
name|key_map
argument_list|,
sizeof|sizeof
argument_list|(
name|key_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|PIO_FONT8x8
case|:
comment|/* set 8x8 dot font */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|font_8
argument_list|,
literal|8
operator|*
literal|256
argument_list|)
expr_stmt|;
name|fonts_loaded
operator||=
name|FONT_8
expr_stmt|;
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_8
argument_list|,
name|font_8
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_FONT8x8
case|:
comment|/* get 8x8 dot font */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_8
condition|)
block|{
name|bcopy
argument_list|(
name|font_8
argument_list|,
name|data
argument_list|,
literal|8
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
case|case
name|PIO_FONT8x14
case|:
comment|/* set 8x14 dot font */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|font_14
argument_list|,
literal|14
operator|*
literal|256
argument_list|)
expr_stmt|;
name|fonts_loaded
operator||=
name|FONT_14
expr_stmt|;
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_14
argument_list|,
name|font_14
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_FONT8x14
case|:
comment|/* get 8x14 dot font */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_14
condition|)
block|{
name|bcopy
argument_list|(
name|font_14
argument_list|,
name|data
argument_list|,
literal|14
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
case|case
name|PIO_FONT8x16
case|:
comment|/* set 8x16 dot font */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|font_16
argument_list|,
literal|16
operator|*
literal|256
argument_list|)
expr_stmt|;
name|fonts_loaded
operator||=
name|FONT_16
expr_stmt|;
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_FONT8x16
case|:
comment|/* get 8x16 dot font */
if|if
condition|(
operator|!
name|crtc_vga
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_16
condition|)
block|{
name|bcopy
argument_list|(
name|font_16
argument_list|,
name|data
argument_list|,
literal|16
operator|*
literal|256
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|ENXIO
return|;
default|default:
break|break;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scstart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|clist
modifier|*
name|rbp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|;
name|u_char
name|buf
index|[
name|PCBURST
index|]
decl_stmt|;
name|scr_stat
modifier|*
name|scp
init|=
name|get_scr_stat
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|SLKED
operator|||
name|blink_in_progress
condition|)
return|return;
comment|/* XXX who repeats the call when the above flags are cleared? */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|rbp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
while|while
condition|(
name|rbp
operator|->
name|c_cc
condition|)
block|{
name|len
operator|=
name|q_to_b
argument_list|(
name|rbp
argument_list|,
name|buf
argument_list|,
name|PCBURST
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ansi_put
argument_list|(
name|scp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scmousestart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|clist
modifier|*
name|rbp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_char
name|buf
index|[
name|PCBURST
index|]
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|rbp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
while|while
condition|(
name|rbp
operator|->
name|c_cc
condition|)
block|{
name|q_to_b
argument_list|(
name|rbp
argument_list|,
name|buf
argument_list|,
name|PCBURST
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sccnprobe
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
comment|/*      * Take control if we are the highest priority enabled display device.      */
name|dvp
operator|=
name|find_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|dvp
operator|==
name|NULL
operator|||
name|dvp
operator|->
name|id_driver
operator|!=
operator|&
name|scdriver
condition|)
block|{
name|cp
operator|->
name|cn_pri
operator|=
name|CN_DEAD
expr_stmt|;
return|return;
block|}
comment|/* initialize required fields */
name|cp
operator|->
name|cn_dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
name|SC_CONSOLE
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cn_pri
operator|=
name|CN_INTERNAL
expr_stmt|;
name|sc_kbdc
operator|=
name|kbdc_open
argument_list|(
name|sc_port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sccninit
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|scinit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sccnputc
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|scr_stat
modifier|*
name|scp
init|=
name|console
index|[
literal|0
index|]
decl_stmt|;
name|term_stat
name|save
init|=
name|scp
operator|->
name|term
decl_stmt|;
name|scp
operator|->
name|term
operator|=
name|kernel_console
expr_stmt|;
name|current_default
operator|=
operator|&
name|kernel_default
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
name|remove_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|ansi_put
argument_list|(
name|scp
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kernel_console
operator|=
name|scp
operator|->
name|term
expr_stmt|;
name|current_default
operator|=
operator|&
name|user_default
expr_stmt|;
name|scp
operator|->
name|term
operator|=
name|save
expr_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
operator|&&
operator|!
operator|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
if|if
condition|(
comment|/* timer not running&& */
operator|(
name|scp
operator|->
name|start
operator|<=
name|scp
operator|->
name|end
operator|)
condition|)
block|{
name|bcopyw
argument_list|(
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|start
argument_list|,
name|Crtat
operator|+
name|scp
operator|->
name|start
argument_list|,
operator|(
literal|1
operator|+
name|scp
operator|->
name|end
operator|-
name|scp
operator|->
name|start
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
expr_stmt|;
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
block|}
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sccngetc
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|s
init|=
name|spltty
argument_list|()
decl_stmt|;
comment|/* block scintr while we poll */
name|int
name|c
init|=
name|scgetc
argument_list|(
name|SCGETC_CN
argument_list|)
decl_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sccncheckc
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|c
operator|=
name|scgetc
argument_list|(
name|SCGETC_CN
operator||
name|SCGETC_NONBLOCK
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|==
name|NOKEY
condition|?
operator|-
literal|1
else|:
name|c
operator|)
return|;
comment|/* c == -1 can't happen */
block|}
end_function

begin_function
specifier|static
name|scr_stat
modifier|*
name|get_scr_stat
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|==
name|SC_CONSOLE
condition|)
return|return
name|console
index|[
literal|0
index|]
return|;
if|if
condition|(
name|unit
operator|>=
name|MAXCONS
operator|||
name|unit
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
name|console
index|[
name|unit
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_scr_num
parameter_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
name|MAXCONS
operator|)
operator|&&
operator|(
name|cur_console
operator|!=
name|console
index|[
name|i
index|]
operator|)
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
operator|<
name|MAXCONS
condition|?
name|i
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scrn_timer
parameter_list|()
block|{
name|scr_stat
modifier|*
name|scp
init|=
name|cur_console
decl_stmt|;
name|int
name|s
init|=
name|spltty
argument_list|()
decl_stmt|;
comment|/*       * With release 2.1 of the Xaccel server, the keyboard is left      * hanging pretty often. Apparently an interrupt from the      * keyboard is lost, and I don't know why (yet).      * This ugly hack calls scintr if input is ready for the keyboard      * and conveniently hides the problem.			XXX      */
comment|/* Try removing anything stuck in the keyboard controller; whether      * it's a keyboard scan code or mouse data. `scintr()' doesn't      * read the mouse data directly, but `kbdio' routines will, as a      * side effect.      */
if|if
condition|(
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
comment|/* 	 * We have seen the lock flag is not set. Let's reset the flag early; 	 * otherwise `update_led()' failes which may want the lock  	 * during `scintr()'. 	 */
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdc_data_ready
argument_list|(
name|sc_kbdc
argument_list|)
condition|)
name|scintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* should we just return ? */
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
operator|||
name|blink_in_progress
operator|||
name|switch_in_progress
condition|)
block|{
name|timeout
argument_list|(
operator|(
name|timeout_func_t
operator|)
name|scrn_timer
argument_list|,
literal|0
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|scrn_blanked
condition|)
block|{
comment|/* update screen image */
if|if
condition|(
name|scp
operator|->
name|start
operator|<=
name|scp
operator|->
name|end
condition|)
block|{
name|bcopyw
argument_list|(
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|start
argument_list|,
name|Crtat
operator|+
name|scp
operator|->
name|start
argument_list|,
operator|(
literal|1
operator|+
name|scp
operator|->
name|end
operator|-
name|scp
operator|->
name|start
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* update "pseudo" mouse pointer image */
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
operator|)
operator|&&
name|crtc_vga
condition|)
block|{
comment|/* did mouse move since last time ? */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_MOVED
condition|)
block|{
comment|/* do we need to remove old mouse pointer image ? */
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|!=
name|NULL
operator|||
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|<=
name|scp
operator|->
name|start
operator|||
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|>=
name|scp
operator|->
name|end
condition|)
block|{
name|remove_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_MOVED
expr_stmt|;
name|draw_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* mouse didn't move, has it been overwritten ? */
if|if
condition|(
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|>=
name|scp
operator|->
name|start
operator|&&
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|<=
name|scp
operator|->
name|end
condition|)
block|{
name|draw_mouse_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* update cursor image */
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|CURSOR_ENABLED
condition|)
block|{
comment|/* did cursor move since last time ? */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|!=
name|scp
operator|->
name|cursor_oldpos
condition|)
block|{
comment|/* do we need to remove old cursor image ? */
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|<
name|scp
operator|->
name|start
operator|||
operator|(
operator|(
name|scp
operator|->
name|cursor_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|>
name|scp
operator|->
name|end
operator|)
condition|)
block|{
name|remove_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* cursor didn't move, has it been overwritten ? */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|>=
name|scp
operator|->
name|start
operator|&&
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|<=
name|scp
operator|->
name|end
condition|)
block|{
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if its a blinking cursor, we may have to update it */
if|if
condition|(
name|flags
operator|&
name|BLINK_CURSOR
condition|)
name|draw_cursor_image
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
name|blinkrate
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|mouse_cut_start
operator|!=
name|NULL
condition|)
name|draw_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
expr_stmt|;
block|}
if|if
condition|(
name|scrn_blank_time
operator|&&
operator|(
name|time
operator|.
name|tv_sec
operator|>
name|scrn_time_stamp
operator|+
name|scrn_blank_time
operator|)
condition|)
call|(
modifier|*
name|current_saver
call|)
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
operator|(
name|timeout_func_t
operator|)
name|scrn_timer
argument_list|,
literal|0
argument_list|,
name|hz
operator|/
literal|25
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_oldpos
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|switch_scr
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_int
name|next_scr
parameter_list|)
block|{
if|if
condition|(
name|switch_in_progress
operator|&&
operator|(
name|cur_console
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|cur_console
operator|->
name|pid
argument_list|)
operator|)
condition|)
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|next_scr
operator|>=
name|MAXCONS
operator|||
name|switch_in_progress
operator|||
operator|(
name|cur_console
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
operator|&&
name|cur_console
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
name|do_bell
argument_list|(
name|scp
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* is the wanted virtual console open ? */
if|if
condition|(
name|next_scr
condition|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|VIRTUAL_TTY
argument_list|(
name|next_scr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|do_bell
argument_list|(
name|scp
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
comment|/* delay switch if actively updating screen */
if|if
condition|(
name|write_in_progress
operator|||
name|blink_in_progress
condition|)
block|{
name|delayed_next_scr
operator|=
name|next_scr
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|switch_in_progress
operator|=
name|TRUE
expr_stmt|;
name|old_scp
operator|=
name|cur_console
expr_stmt|;
name|new_scp
operator|=
name|console
index|[
name|next_scr
index|]
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|new_scp
operator|->
name|smode
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_scp
operator|==
name|old_scp
condition|)
block|{
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
name|delayed_next_scr
operator|=
name|FALSE
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* has controlling process died? */
if|if
condition|(
name|old_scp
operator|->
name|proc
operator|&&
operator|(
name|old_scp
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|old_scp
operator|->
name|pid
argument_list|)
operator|)
condition|)
name|old_scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
if|if
condition|(
name|new_scp
operator|->
name|proc
operator|&&
operator|(
name|new_scp
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|new_scp
operator|->
name|pid
argument_list|)
operator|)
condition|)
name|new_scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
comment|/* check the modes and switch appropriately */
if|if
condition|(
name|old_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|old_scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_REL
expr_stmt|;
name|psignal
argument_list|(
name|old_scp
operator|->
name|proc
argument_list|,
name|old_scp
operator|->
name|smode
operator|.
name|relsig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|exchange_scr
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_scp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
name|new_scp
operator|->
name|status
operator||=
name|SWITCH_WAIT_ACQ
expr_stmt|;
name|psignal
argument_list|(
name|new_scp
operator|->
name|proc
argument_list|,
name|new_scp
operator|->
name|smode
operator|.
name|acqsig
argument_list|)
expr_stmt|;
block|}
else|else
name|switch_in_progress
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|exchange_scr
parameter_list|(
name|void
parameter_list|)
block|{
name|move_crsr
argument_list|(
name|old_scp
argument_list|,
name|old_scp
operator|->
name|xpos
argument_list|,
name|old_scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
name|cur_console
operator|=
name|new_scp
expr_stmt|;
if|if
condition|(
name|old_scp
operator|->
name|mode
operator|!=
name|new_scp
operator|->
name|mode
operator|||
operator|(
name|old_scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
condition|)
block|{
if|if
condition|(
name|crtc_vga
operator|&&
name|video_mode_ptr
condition|)
name|set_mode
argument_list|(
name|new_scp
argument_list|)
expr_stmt|;
block|}
name|move_crsr
argument_list|(
name|new_scp
argument_list|,
name|new_scp
operator|->
name|xpos
argument_list|,
name|new_scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|old_scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
operator|)
operator|&&
name|crtc_vga
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|new_scp
argument_list|)
expr_stmt|;
name|load_palette
argument_list|(
name|palette
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_scp
operator|->
name|status
operator|&
name|KBD_RAW_MODE
operator|||
name|new_scp
operator|->
name|status
operator|&
name|KBD_RAW_MODE
condition|)
name|shfts
operator|=
name|ctls
operator|=
name|alts
operator|=
name|agrs
operator|=
name|metas
operator|=
literal|0
expr_stmt|;
name|update_leds
argument_list|(
name|new_scp
operator|->
name|status
argument_list|)
expr_stmt|;
name|delayed_next_scr
operator|=
name|FALSE
expr_stmt|;
name|mark_all
argument_list|(
name|new_scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scan_esc
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
name|c
parameter_list|)
block|{
specifier|static
name|u_char
name|ansi_col
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|,
literal|8
block|,
literal|12
block|,
literal|10
block|,
literal|14
block|,
literal|9
block|,
literal|13
block|,
literal|11
block|,
literal|15
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_short
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'['
case|:
comment|/* Start ESC [ sequence */
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|2
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
init|;
name|i
operator|<
name|MAX_ESC_PAR
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|'M'
case|:
comment|/* Move cursor up 1 line, scroll if at top */
if|if
condition|(
name|scp
operator|->
name|ypos
operator|>
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|bcopyw
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
argument_list|,
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|notyet
case|case
literal|'Q'
case|:
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|4
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'c'
case|:
comment|/* Clear screen& home */
name|clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|last_param
operator|!=
name|scp
operator|->
name|term
operator|.
name|num_param
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|*=
literal|10
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
return|return;
block|}
block|}
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
name|scp
operator|->
name|term
operator|.
name|last_param
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|';'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
return|return;
break|break;
case|case
literal|'='
case|:
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|3
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
init|;
name|i
operator|<
name|MAX_ESC_PAR
condition|;
name|i
operator|++
control|)
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
literal|0
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
comment|/* up n rows */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|-
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* down n rows */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* right n columns */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
operator|+
name|n
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* left n columns */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
operator|-
name|n
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* cursor to start of line n lines down */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|ypos
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* cursor to start of line n lines up */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
name|scp
operator|->
name|ypos
operator|-
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Cursor move */
case|case
literal|'H'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|2
condition|)
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|-
literal|1
argument_list|,
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* Clear all or part of display */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* clear form cursor to end of display */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|cursor_pos
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* clear from beginning of display to cursor */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* clear entire display */
name|clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'K'
case|:
comment|/* Clear all or part of line */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* clear form cursor to end of line */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* clear from beginning of line to cursor */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|xpos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* clear entire line */
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
operator|(
name|scp
operator|->
name|ypos
operator|+
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'L'
case|:
comment|/* Insert n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
expr_stmt|;
name|src
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|dst
operator|=
name|src
operator|+
name|n
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|ysize
operator|-
operator|(
name|scp
operator|->
name|ypos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopyw
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* Delete n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
operator|-
name|scp
operator|->
name|ypos
expr_stmt|;
name|dst
operator|=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|n
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|ysize
operator|-
operator|(
name|scp
operator|->
name|ypos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopyw
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|count
operator|*
name|scp
operator|->
name|xsize
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|ypos
operator|*
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* Delete n chars */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
condition|)
name|n
operator|=
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
expr_stmt|;
name|dst
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|n
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|xsize
operator|-
operator|(
name|scp
operator|->
name|xpos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopyw
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|count
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|n
operator|+
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'@'
case|:
comment|/* Insert n chars */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
condition|)
name|n
operator|=
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
expr_stmt|;
name|src
operator|=
name|scp
operator|->
name|cursor_pos
expr_stmt|;
name|dst
operator|=
name|src
operator|+
name|n
expr_stmt|;
name|count
operator|=
name|scp
operator|->
name|xsize
operator|-
operator|(
name|scp
operator|->
name|xpos
operator|+
name|n
operator|)
expr_stmt|;
name|bcopyw
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|src
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|n
operator|+
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* scroll up n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|bcopyw
argument_list|(
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|n
operator|)
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|n
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* scroll down n lines */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|ysize
condition|)
name|n
operator|=
name|scp
operator|->
name|ysize
expr_stmt|;
name|bcopyw
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|n
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
name|n
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|n
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* erase n characters in line */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
condition|)
name|n
operator|=
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|cursor_pos
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
comment|/* move n tabs backwards */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|scp
operator|->
name|xpos
operator|&
literal|0xf8
operator|)
operator|==
name|scp
operator|->
name|xpos
condition|)
name|i
operator|-=
literal|8
operator|*
name|n
expr_stmt|;
else|else
name|i
operator|-=
literal|8
operator|*
operator|(
name|n
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|i
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
comment|/* move cursor to column n */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|n
operator|-
literal|1
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
comment|/* move cursor n columns to the right */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
operator|+
name|n
argument_list|,
name|scp
operator|->
name|ypos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* move cursor to row n */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|n
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* move cursor n rows down */
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|1
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|move_crsr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|xpos
argument_list|,
name|scp
operator|->
name|ypos
operator|+
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* change attribute */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|term
operator|.
name|num_param
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|i
index|]
condition|)
block|{
case|case
literal|0
case|:
comment|/* back to normal */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* bold */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|BOLD_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* underline */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|UNDERLINE_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* blink */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|BLINK_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* reverse video */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|REVERSE_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|30
case|:
case|case
literal|31
case|:
comment|/* set fg color */
case|case
literal|32
case|:
case|case
literal|33
case|:
case|case
literal|34
case|:
case|case
literal|35
case|:
case|case
literal|36
case|:
case|case
literal|37
case|:
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|FOREGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|n
operator|-
literal|30
operator|)
operator|&
literal|7
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|40
case|:
case|case
literal|41
case|:
comment|/* set bg color */
case|case
literal|42
case|:
case|case
literal|43
case|:
case|case
literal|44
case|:
case|case
literal|45
case|:
case|case
literal|46
case|:
case|case
literal|47
case|:
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator||=
name|BACKGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|n
operator|-
literal|40
operator|)
operator|&
literal|7
index|]
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|0
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|0
case|:
comment|/* reset attributes */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
name|current_default
operator|->
name|std_color
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
name|current_default
operator|->
name|rev_color
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* set ansi background */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|BACKGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* set ansi foreground */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|FOREGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* set ansi attribute directly */
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
operator|(
name|FOREGROUND_CHANGED
operator||
name|BACKGROUND_CHANGED
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* set ansi reverse video background */
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* set ansi reverse video foreground */
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
name|ansi_col
index|[
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0F
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* set ansi reverse video directly */
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'z'
case|:
comment|/* switch to (virtual) console n */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
name|switch_scr
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|last_param
operator|!=
name|scp
operator|->
name|term
operator|.
name|num_param
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|last_param
operator|=
name|scp
operator|->
name|term
operator|.
name|num_param
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|*=
literal|10
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|param
index|[
name|scp
operator|->
name|term
operator|.
name|num_param
index|]
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
return|return;
block|}
block|}
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
name|scp
operator|->
name|term
operator|.
name|last_param
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|';'
case|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|<
name|MAX_ESC_PAR
condition|)
return|return;
break|break;
case|case
literal|'A'
case|:
comment|/* set display border color */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
name|scp
operator|->
name|border
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
name|set_border
argument_list|(
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* set bell pitch and duration */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|2
condition|)
block|{
name|scp
operator|->
name|bell_pitch
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
expr_stmt|;
name|scp
operator|->
name|bell_duration
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|*
literal|10
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* set cursor type& shape */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x01
condition|)
name|flags
operator||=
name|BLINK_CURSOR
expr_stmt|;
else|else
name|flags
operator|&=
operator|~
name|BLINK_CURSOR
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x02
condition|)
block|{
name|flags
operator||=
name|CHAR_CURSOR
expr_stmt|;
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
name|flags
operator|&=
operator|~
name|CHAR_CURSOR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|2
condition|)
block|{
name|scp
operator|->
name|cursor_start
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x1F
expr_stmt|;
name|scp
operator|->
name|cursor_end
operator|=
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|1
index|]
operator|&
literal|0x1F
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'F'
case|:
comment|/* set ansi foreground */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|FOREGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'G'
case|:
comment|/* set ansi background */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|&=
operator|~
name|BACKGROUND_CHANGED
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|std_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'H'
case|:
comment|/* set ansi reverse video foreground */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0xF000
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
comment|/* set ansi reverse video background */
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|num_param
operator|==
literal|1
condition|)
block|{
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
operator|(
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|&
literal|0x0F00
operator|)
operator||
operator|(
operator|(
name|scp
operator|->
name|term
operator|.
name|param
index|[
literal|0
index|]
operator|&
literal|0x0F
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|mask2attr
argument_list|(
operator|&
name|scp
operator|->
name|term
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ansi_put
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_char
modifier|*
name|ptr
init|=
name|buf
decl_stmt|;
comment|/* make screensaver happy */
if|if
condition|(
name|scp
operator|==
name|cur_console
condition|)
block|{
name|scrn_time_stamp
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|scrn_blanked
condition|)
block|{
call|(
modifier|*
name|current_saver
call|)
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
block|}
name|write_in_progress
operator|++
expr_stmt|;
name|outloop
label|:
if|if
condition|(
name|scp
operator|->
name|term
operator|.
name|esc
condition|)
block|{
name|scan_esc
argument_list|(
name|scp
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PRINTABLE
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
block|{
comment|/* Print only printables */
name|int
name|cnt
init|=
name|len
operator|<=
operator|(
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
operator|)
condition|?
name|len
else|:
operator|(
name|scp
operator|->
name|xsize
operator|-
name|scp
operator|->
name|xpos
operator|)
decl_stmt|;
name|u_short
name|cur_attr
init|=
name|scp
operator|->
name|term
operator|.
name|cur_attr
decl_stmt|;
name|u_short
modifier|*
name|cursor_pos
init|=
name|scp
operator|->
name|cursor_pos
decl_stmt|;
do|do
block|{
comment|/* 	     * gcc-2.6.3 generates poor (un)sign extension code.  Casting the 	     * pointers in the following to volatile should have no effect, 	     * but in fact speeds up this inner loop from 26 to 18 cycles 	     * (+ cache misses) on i486's. 	     */
define|#
directive|define
name|UCVP
parameter_list|(
name|ucp
parameter_list|)
value|((u_char volatile *)(ucp))
operator|*
name|cursor_pos
operator|++
operator|=
name|UCVP
argument_list|(
name|scr_map
argument_list|)
index|[
operator|*
name|UCVP
argument_list|(
name|ptr
argument_list|)
index|]
operator||
name|cur_attr
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|cnt
operator|&&
name|PRINTABLE
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
do|;
name|len
operator|-=
operator|(
name|cursor_pos
operator|-
name|scp
operator|->
name|cursor_pos
operator|)
expr_stmt|;
name|scp
operator|->
name|xpos
operator|+=
operator|(
name|cursor_pos
operator|-
name|scp
operator|->
name|cursor_pos
operator|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|=
name|cursor_pos
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|xpos
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ypos
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
operator|*
name|ptr
condition|)
block|{
case|case
literal|0x07
case|:
name|do_bell
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|bell_pitch
argument_list|,
name|scp
operator|->
name|bell_duration
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
comment|/* non-destructive backspace */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|>
name|scp
operator|->
name|scr_buf
condition|)
block|{
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|--
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|xpos
operator|>
literal|0
condition|)
name|scp
operator|->
name|xpos
operator|--
expr_stmt|;
else|else
block|{
name|scp
operator|->
name|xpos
operator|+=
name|scp
operator|->
name|xsize
operator|-
literal|1
expr_stmt|;
name|scp
operator|->
name|ypos
operator|--
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x09
case|:
comment|/* non-destructive tab */
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|+=
operator|(
literal|8
operator|-
name|scp
operator|->
name|xpos
operator|%
literal|8u
operator|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|xpos
operator|+=
operator|(
literal|8
operator|-
name|scp
operator|->
name|xpos
operator|%
literal|8u
operator|)
operator|)
operator|>=
name|scp
operator|->
name|xsize
condition|)
block|{
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|ypos
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|0x0a
case|:
comment|/* newline, same pos */
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|+=
name|scp
operator|->
name|xsize
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|ypos
operator|++
expr_stmt|;
break|break;
case|case
literal|0x0c
case|:
comment|/* form feed, clears screen */
name|clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0d
case|:
comment|/* return, return to pos 0 */
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|-=
name|scp
operator|->
name|xpos
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|cursor_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|xpos
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x1b
case|:
comment|/* start escape sequence */
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|1
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|num_param
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|ptr
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
comment|/* do we have to scroll ?? */
if|if
condition|(
name|scp
operator|->
name|cursor_pos
operator|>=
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|xsize
condition|)
block|{
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history
condition|)
block|{
name|bcopyw
argument_list|(
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|history_head
argument_list|,
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|history_head
operator|+=
name|scp
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|history_head
operator|+
name|scp
operator|->
name|xsize
operator|>
name|scp
operator|->
name|history
operator|+
name|scp
operator|->
name|history_size
condition|)
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history
expr_stmt|;
block|}
name|bcopyw
argument_list|(
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
argument_list|,
name|scp
operator|->
name|scr_buf
argument_list|,
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
name|scp
operator|->
name|term
operator|.
name|cur_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|)
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_pos
operator|-=
name|scp
operator|->
name|xsize
expr_stmt|;
name|scp
operator|->
name|ypos
operator|--
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
goto|goto
name|outloop
goto|;
name|write_in_progress
operator|--
expr_stmt|;
if|if
condition|(
name|delayed_next_scr
condition|)
name|switch_scr
argument_list|(
name|scp
argument_list|,
name|delayed_next_scr
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scinit
parameter_list|(
name|void
parameter_list|)
block|{
name|u_short
specifier|volatile
modifier|*
name|cp
decl_stmt|;
name|u_short
name|was
decl_stmt|;
name|u_int
name|hw_cursor
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|init_done
operator|!=
name|COLD
condition|)
return|return;
name|init_done
operator|=
name|WARM
expr_stmt|;
comment|/*      * Finish defaulting crtc variables for a mono screen.  Crtat is a      * bogus common variable so that it can be shared with pcvt, so it      * can't be statically initialized.  XXX.      */
name|Crtat
operator|=
operator|(
name|u_short
operator|*
operator|)
name|MONO_BUF
expr_stmt|;
comment|/*      * If CGA memory seems to work, switch to color.      */
name|cp
operator|=
operator|(
name|u_short
operator|*
operator|)
name|CGA_BUF
expr_stmt|;
name|was
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
operator|(
name|u_short
operator|)
literal|0xA55A
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|0xA55A
condition|)
block|{
name|Crtat
operator|=
operator|(
name|u_short
operator|*
operator|)
name|CGA_BUF
expr_stmt|;
name|crtc_addr
operator|=
name|COLOR_BASE
expr_stmt|;
block|}
operator|*
name|cp
operator|=
name|was
expr_stmt|;
comment|/*      * Ensure a zero start address.  This is mainly to recover after      * switching from pcvt using userconfig().  The registers are w/o      * for old hardware so it's too hard to relocate the active screen      * memory.      */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* extract cursor location */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|hw_cursor
operator|=
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|hw_cursor
operator||=
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Validate cursor location.  It may be off the screen.  Then we must      * not use it for the initial buffer offset.      */
if|if
condition|(
name|hw_cursor
operator|>=
name|ROW
operator|*
name|COL
condition|)
name|hw_cursor
operator|=
operator|(
name|ROW
operator|-
literal|1
operator|)
operator|*
name|COL
expr_stmt|;
comment|/* move hardware cursor out of the way */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* is this a VGA or higher ? */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|crtc_addr
argument_list|)
operator|==
literal|7
condition|)
block|{
name|u_long
name|pa
decl_stmt|;
name|u_long
name|segoff
decl_stmt|;
name|crtc_vga
operator|=
name|TRUE
expr_stmt|;
comment|/* Get the BIOS video mode pointer */
name|segoff
operator|=
operator|*
operator|(
name|u_long
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x4a8
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
operator|(
operator|(
name|segoff
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|12
operator|)
operator|+
operator|(
name|segoff
operator|&
literal|0xffff
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ISMAPPED
argument_list|(
name|pa
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
condition|)
block|{
name|segoff
operator|=
operator|*
operator|(
name|u_long
operator|*
operator|)
name|pa_to_va
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
operator|(
operator|(
name|segoff
operator|&
literal|0xffff0000
operator|)
operator|>>
literal|12
operator|)
operator|+
operator|(
name|segoff
operator|&
literal|0xffff
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ISMAPPED
argument_list|(
name|pa
argument_list|,
literal|64
argument_list|)
condition|)
name|video_mode_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
block|}
name|current_default
operator|=
operator|&
name|user_default
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|=
operator|&
name|main_console
expr_stmt|;
name|init_scp
argument_list|(
name|console
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cur_console
operator|=
name|console
index|[
literal|0
index|]
expr_stmt|;
comment|/* copy screen to temporary buffer */
name|bcopyw
argument_list|(
name|Crtat
argument_list|,
name|sc_buffer
argument_list|,
name|console
index|[
literal|0
index|]
operator|->
name|xsize
operator|*
name|console
index|[
literal|0
index|]
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|scr_buf
operator|=
name|console
index|[
literal|0
index|]
operator|->
name|mouse_pos
operator|=
name|sc_buffer
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|cursor_pos
operator|=
name|console
index|[
literal|0
index|]
operator|->
name|cursor_oldpos
operator|=
name|sc_buffer
operator|+
name|hw_cursor
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|xpos
operator|=
name|hw_cursor
operator|%
name|COL
expr_stmt|;
name|console
index|[
literal|0
index|]
operator|->
name|ypos
operator|=
name|hw_cursor
operator|/
name|COL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAXCONS
condition|;
name|i
operator|++
control|)
name|console
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|kernel_console
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|kernel_console
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|kernel_console
operator|.
name|cur_attr
operator|=
name|kernel_console
operator|.
name|cur_color
operator|=
name|kernel_console
operator|.
name|std_color
operator|=
name|kernel_default
operator|.
name|std_color
expr_stmt|;
name|kernel_console
operator|.
name|rev_color
operator|=
name|kernel_default
operator|.
name|rev_color
expr_stmt|;
comment|/* initialize mapscrn arrays to a one to one map */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|scr_map
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|scr_map
index|[
name|i
index|]
operator|=
name|scr_rmap
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* Save font and palette if VGA */
if|if
condition|(
name|crtc_vga
condition|)
block|{
name|copy_font
argument_list|(
name|SAVE
argument_list|,
name|FONT_16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
name|fonts_loaded
operator|=
name|FONT_16
expr_stmt|;
name|save_palette
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
comment|/*       * Now put up a graphics image, and maybe cycle a      * couble of palette entries for simple animation.      */
name|toggle_splash_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|scr_stat
modifier|*
name|alloc_scp
parameter_list|()
block|{
name|scr_stat
modifier|*
name|scp
decl_stmt|;
name|scp
operator|=
operator|(
name|scr_stat
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|scr_stat
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|init_scp
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|scp
operator|->
name|scr_buf
operator|=
name|scp
operator|->
name|cursor_pos
operator|=
name|scp
operator|->
name|cursor_oldpos
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_ypos
operator|/
name|scp
operator|->
name|font_size
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|mouse_xpos
operator|/
literal|8
operator|)
expr_stmt|;
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history_pos
operator|=
name|scp
operator|->
name|history
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|scp
operator|->
name|history_head
argument_list|,
name|scp
operator|->
name|history_size
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SOS     if (crtc_vga&& video_mode_ptr) 	set_mode(scp); */
name|clear_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
name|scp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_scp
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|crtc_vga
condition|)
if|if
condition|(
name|crtc_addr
operator|==
name|MONO_BASE
condition|)
name|scp
operator|->
name|mode
operator|=
name|M_VGA_M80x25
expr_stmt|;
else|else
name|scp
operator|->
name|mode
operator|=
name|M_VGA_C80x25
expr_stmt|;
elseif|else
if|if
condition|(
name|crtc_addr
operator|==
name|MONO_BASE
condition|)
name|scp
operator|->
name|mode
operator|=
name|M_B80x25
expr_stmt|;
else|else
name|scp
operator|->
name|mode
operator|=
name|M_C80x25
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
name|FONT_16
expr_stmt|;
name|scp
operator|->
name|xsize
operator|=
name|COL
expr_stmt|;
name|scp
operator|->
name|ysize
operator|=
name|ROW
expr_stmt|;
name|scp
operator|->
name|start
operator|=
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
expr_stmt|;
name|scp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|attr_mask
operator|=
name|NORMAL_ATTR
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|cur_attr
operator|=
name|scp
operator|->
name|term
operator|.
name|cur_color
operator|=
name|scp
operator|->
name|term
operator|.
name|std_color
operator|=
name|current_default
operator|->
name|std_color
expr_stmt|;
name|scp
operator|->
name|term
operator|.
name|rev_color
operator|=
name|current_default
operator|->
name|rev_color
expr_stmt|;
name|scp
operator|->
name|border
operator|=
name|BG_BLACK
expr_stmt|;
name|scp
operator|->
name|cursor_start
operator|=
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x461
argument_list|)
expr_stmt|;
name|scp
operator|->
name|cursor_end
operator|=
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x460
argument_list|)
expr_stmt|;
name|scp
operator|->
name|mouse_xpos
operator|=
name|scp
operator|->
name|xsize
operator|*
literal|8
operator|/
literal|2
expr_stmt|;
name|scp
operator|->
name|mouse_ypos
operator|=
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
operator|/
literal|2
expr_stmt|;
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|mouse_cut_end
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|mouse_signal
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|mouse_proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|bell_pitch
operator|=
name|BELL_PITCH
expr_stmt|;
name|scp
operator|->
name|bell_duration
operator|=
name|BELL_DURATION
expr_stmt|;
name|scp
operator|->
name|status
operator|=
operator|(
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
literal|0x417
argument_list|)
operator|&
literal|0x20
operator|)
condition|?
name|NLKED
else|:
literal|0
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|CURSOR_ENABLED
expr_stmt|;
name|scp
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|scp
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
name|scp
operator|->
name|history_head
operator|=
name|scp
operator|->
name|history_pos
operator|=
name|scp
operator|->
name|history
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|history_size
operator|=
name|HISTORY_SIZE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_char
modifier|*
name|get_fstr
parameter_list|(
name|u_int
name|c
parameter_list|,
name|u_int
modifier|*
name|len
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|&
name|FKEY
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|i
operator|=
operator|(
name|c
operator|&
literal|0xFF
operator|)
operator|-
name|F_FN
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|n_fkey_tab
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|len
operator|=
name|fkey_tab
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
return|return
operator|(
name|fkey_tab
index|[
name|i
index|]
operator|.
name|str
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|history_to_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scp
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
name|bcopyw
argument_list|(
name|scp
operator|->
name|history
operator|+
operator|(
operator|(
operator|(
name|scp
operator|->
name|history_pos
operator|-
name|scp
operator|->
name|history
operator|)
operator|+
name|scp
operator|->
name|history_size
operator|-
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|)
operator|)
operator|%
name|scp
operator|->
name|history_size
operator|)
argument_list|,
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
operator|(
name|scp
operator|->
name|ysize
operator|-
literal|1
operator|-
name|i
operator|)
operator|)
argument_list|,
name|scp
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|history_up_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|WRAPHIST
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
operator|-
operator|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|)
argument_list|)
operator|!=
name|scp
operator|->
name|history_head
condition|)
block|{
name|scp
operator|->
name|history_pos
operator|=
name|WRAPHIST
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
operator|-
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|history_down_line
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|history_pos
operator|!=
name|scp
operator|->
name|history_head
condition|)
block|{
name|scp
operator|->
name|history_pos
operator|=
name|WRAPHIST
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|history_pos
argument_list|,
name|scp
operator|->
name|xsize
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|scp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * scgetc(flags) - get character from keyboard.  * If flags& SCGETC_CN, then avoid harmful side effects.  * If flags& SCGETC_NONBLOCK, then wait until a key is pressed, else  * return NOKEY if there is nothing there.  */
end_comment

begin_function
specifier|static
name|u_int
name|scgetc
parameter_list|(
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|key_t
modifier|*
name|key
decl_stmt|;
name|u_char
name|scancode
decl_stmt|,
name|keycode
decl_stmt|;
name|u_int
name|state
decl_stmt|,
name|action
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|static
name|u_char
name|esc_flag
init|=
literal|0
decl_stmt|,
name|compose
init|=
literal|0
decl_stmt|;
specifier|static
name|u_int
name|chr
init|=
literal|0
decl_stmt|;
name|next_code
label|:
comment|/* first see if there is something in the keyboard port */
if|if
condition|(
name|flags
operator|&
name|SCGETC_NONBLOCK
condition|)
block|{
name|c
operator|=
name|read_kbd_data_no_wait
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NOKEY
operator|)
return|;
block|}
else|else
block|{
do|do
block|{
name|c
operator|=
name|read_kbd_data
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
do|;
block|}
name|scancode
operator|=
operator|(
name|u_char
operator|)
name|c
expr_stmt|;
comment|/* do the /dev/random device a favour */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCGETC_CN
operator|)
condition|)
name|add_keyboard_randomness
argument_list|(
name|scancode
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|KBD_RAW_MODE
condition|)
return|return
name|scancode
return|;
name|keycode
operator|=
name|scancode
operator|&
literal|0x7F
expr_stmt|;
switch|switch
condition|(
name|esc_flag
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* normal scancode */
switch|switch
condition|(
name|scancode
condition|)
block|{
case|case
literal|0xB8
case|:
comment|/* left alt (compose key) */
if|if
condition|(
name|compose
condition|)
block|{
name|compose
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chr
operator|>
literal|255
condition|)
block|{
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
name|chr
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x38
case|:
if|if
condition|(
operator|!
name|compose
condition|)
block|{
name|compose
operator|=
literal|1
expr_stmt|;
name|chr
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|0xE0
case|:
case|case
literal|0xE1
case|:
name|esc_flag
operator|=
name|scancode
expr_stmt|;
goto|goto
name|next_code
goto|;
block|}
break|break;
case|case
literal|0xE0
case|:
comment|/* 0xE0 prefix */
name|esc_flag
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|keycode
condition|)
block|{
case|case
literal|0x1C
case|:
comment|/* right enter key */
name|keycode
operator|=
literal|0x59
expr_stmt|;
break|break;
case|case
literal|0x1D
case|:
comment|/* right ctrl key */
name|keycode
operator|=
literal|0x5A
expr_stmt|;
break|break;
case|case
literal|0x35
case|:
comment|/* keypad divide key */
name|keycode
operator|=
literal|0x5B
expr_stmt|;
break|break;
case|case
literal|0x37
case|:
comment|/* print scrn key */
name|keycode
operator|=
literal|0x5C
expr_stmt|;
break|break;
case|case
literal|0x38
case|:
comment|/* right alt key (alt gr) */
name|keycode
operator|=
literal|0x5D
expr_stmt|;
break|break;
case|case
literal|0x47
case|:
comment|/* grey home key */
name|keycode
operator|=
literal|0x5E
expr_stmt|;
break|break;
case|case
literal|0x48
case|:
comment|/* grey up arrow key */
name|keycode
operator|=
literal|0x5F
expr_stmt|;
break|break;
case|case
literal|0x49
case|:
comment|/* grey page up key */
name|keycode
operator|=
literal|0x60
expr_stmt|;
break|break;
case|case
literal|0x4B
case|:
comment|/* grey left arrow key */
name|keycode
operator|=
literal|0x61
expr_stmt|;
break|break;
case|case
literal|0x4D
case|:
comment|/* grey right arrow key */
name|keycode
operator|=
literal|0x62
expr_stmt|;
break|break;
case|case
literal|0x4F
case|:
comment|/* grey end key */
name|keycode
operator|=
literal|0x63
expr_stmt|;
break|break;
case|case
literal|0x50
case|:
comment|/* grey down arrow key */
name|keycode
operator|=
literal|0x64
expr_stmt|;
break|break;
case|case
literal|0x51
case|:
comment|/* grey page down key */
name|keycode
operator|=
literal|0x65
expr_stmt|;
break|break;
case|case
literal|0x52
case|:
comment|/* grey insert key */
name|keycode
operator|=
literal|0x66
expr_stmt|;
break|break;
case|case
literal|0x53
case|:
comment|/* grey delete key */
name|keycode
operator|=
literal|0x67
expr_stmt|;
break|break;
comment|/* the following 3 are only used on the MS "Natural" keyboard */
case|case
literal|0x5b
case|:
comment|/* left Window key */
name|keycode
operator|=
literal|0x69
expr_stmt|;
break|break;
case|case
literal|0x5c
case|:
comment|/* right Window key */
name|keycode
operator|=
literal|0x6a
expr_stmt|;
break|break;
case|case
literal|0x5d
case|:
comment|/* menu key */
name|keycode
operator|=
literal|0x6b
expr_stmt|;
break|break;
default|default:
comment|/* ignore everything else */
goto|goto
name|next_code
goto|;
block|}
break|break;
case|case
literal|0xE1
case|:
comment|/* 0xE1 prefix */
name|esc_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keycode
operator|==
literal|0x1D
condition|)
name|esc_flag
operator|=
literal|0x1D
expr_stmt|;
goto|goto
name|next_code
goto|;
comment|/* NOT REACHED */
case|case
literal|0x1D
case|:
comment|/* pause / break */
name|esc_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keycode
operator|!=
literal|0x45
condition|)
goto|goto
name|next_code
goto|;
name|keycode
operator|=
literal|0x68
expr_stmt|;
break|break;
block|}
comment|/* if scroll-lock pressed allow history browsing */
if|if
condition|(
name|cur_console
operator|->
name|history
operator|&&
name|cur_console
operator|->
name|status
operator|&
name|SLKED
condition|)
block|{
name|int
name|i
decl_stmt|;
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|CURSOR_ENABLED
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cur_console
operator|->
name|status
operator|&
name|BUFFER_SAVED
operator|)
condition|)
block|{
name|cur_console
operator|->
name|status
operator||=
name|BUFFER_SAVED
expr_stmt|;
name|cur_console
operator|->
name|history_save
operator|=
name|cur_console
operator|->
name|history_head
expr_stmt|;
comment|/* copy screen into top of history buffer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
block|{
name|bcopyw
argument_list|(
name|cur_console
operator|->
name|scr_buf
operator|+
operator|(
name|cur_console
operator|->
name|xsize
operator|*
name|i
operator|)
argument_list|,
name|cur_console
operator|->
name|history_head
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|cur_console
operator|->
name|history_head
operator|+=
name|cur_console
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|history_head
operator|+
name|cur_console
operator|->
name|xsize
operator|>
name|cur_console
operator|->
name|history
operator|+
name|cur_console
operator|->
name|history_size
condition|)
name|cur_console
operator|->
name|history_head
operator|=
name|cur_console
operator|->
name|history
expr_stmt|;
block|}
name|cur_console
operator|->
name|history_pos
operator|=
name|cur_console
operator|->
name|history_head
expr_stmt|;
name|history_to_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|scancode
condition|)
block|{
case|case
literal|0x47
case|:
comment|/* home key */
name|cur_console
operator|->
name|history_pos
operator|=
name|cur_console
operator|->
name|history_head
expr_stmt|;
name|history_to_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x4F
case|:
comment|/* end key */
name|cur_console
operator|->
name|history_pos
operator|=
name|WRAPHIST
argument_list|(
name|cur_console
argument_list|,
name|cur_console
operator|->
name|history_head
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
name|cur_console
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|history_to_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x48
case|:
comment|/* up arrow key */
if|if
condition|(
name|history_up_line
argument_list|(
name|cur_console
argument_list|)
condition|)
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x50
case|:
comment|/* down arrow key */
if|if
condition|(
name|history_down_line
argument_list|(
name|cur_console
argument_list|)
condition|)
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x49
case|:
comment|/* page up key */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|history_up_line
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|next_code
goto|;
case|case
literal|0x51
case|:
comment|/* page down key */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|history_down_line
argument_list|(
name|cur_console
argument_list|)
condition|)
block|{
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|next_code
goto|;
block|}
block|}
if|if
condition|(
name|compose
condition|)
block|{
switch|switch
condition|(
name|scancode
condition|)
block|{
comment|/* key pressed process it */
case|case
literal|0x47
case|:
case|case
literal|0x48
case|:
case|case
literal|0x49
case|:
comment|/* keypad 7,8,9 */
name|chr
operator|=
operator|(
name|scancode
operator|-
literal|0x40
operator|)
operator|+
name|chr
operator|*
literal|10
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x4B
case|:
case|case
literal|0x4C
case|:
case|case
literal|0x4D
case|:
comment|/* keypad 4,5,6 */
name|chr
operator|=
operator|(
name|scancode
operator|-
literal|0x47
operator|)
operator|+
name|chr
operator|*
literal|10
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x4F
case|:
case|case
literal|0x50
case|:
case|case
literal|0x51
case|:
comment|/* keypad 1,2,3 */
name|chr
operator|=
operator|(
name|scancode
operator|-
literal|0x4E
operator|)
operator|+
name|chr
operator|*
literal|10
expr_stmt|;
goto|goto
name|next_code
goto|;
case|case
literal|0x52
case|:
comment|/* keypad 0 */
name|chr
operator|*=
literal|10
expr_stmt|;
goto|goto
name|next_code
goto|;
comment|/* key release, no interest here */
case|case
literal|0xC7
case|:
case|case
literal|0xC8
case|:
case|case
literal|0xC9
case|:
comment|/* keypad 7,8,9 */
case|case
literal|0xCB
case|:
case|case
literal|0xCC
case|:
case|case
literal|0xCD
case|:
comment|/* keypad 4,5,6 */
case|case
literal|0xCF
case|:
case|case
literal|0xD0
case|:
case|case
literal|0xD1
case|:
comment|/* keypad 1,2,3 */
case|case
literal|0xD2
case|:
comment|/* keypad 0 */
goto|goto
name|next_code
goto|;
case|case
literal|0x38
case|:
comment|/* left alt key */
break|break;
default|default:
if|if
condition|(
name|chr
condition|)
block|{
name|compose
operator|=
name|chr
operator|=
literal|0
expr_stmt|;
name|do_bell
argument_list|(
name|cur_console
argument_list|,
name|BELL_PITCH
argument_list|,
name|BELL_DURATION
argument_list|)
expr_stmt|;
goto|goto
name|next_code
goto|;
block|}
break|break;
block|}
block|}
name|state
operator|=
operator|(
name|shfts
condition|?
literal|1
else|:
literal|0
operator|)
operator||
operator|(
literal|2
operator|*
operator|(
name|ctls
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
operator||
operator|(
literal|4
operator|*
operator|(
name|alts
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|agrs
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|ALKED
operator|)
operator|)
operator|||
operator|(
name|agrs
operator|&&
operator|!
operator|(
name|cur_console
operator|->
name|status
operator|&
name|ALKED
operator|)
operator|)
condition|)
name|keycode
operator|+=
name|ALTGR_OFFSET
expr_stmt|;
name|key
operator|=
operator|&
name|key_map
operator|.
name|key
index|[
name|keycode
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|key
operator|->
name|flgs
operator|&
name|FLAG_LOCK_C
operator|)
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|CLKED
operator|)
operator|)
operator|||
operator|(
operator|(
name|key
operator|->
name|flgs
operator|&
name|FLAG_LOCK_N
operator|)
operator|&&
operator|(
name|cur_console
operator|->
name|status
operator|&
name|NLKED
operator|)
operator|)
condition|)
name|state
operator|^=
literal|1
expr_stmt|;
comment|/* Check for make/break */
name|action
operator|=
name|key
operator|->
name|map
index|[
name|state
index|]
expr_stmt|;
if|if
condition|(
name|scancode
operator|&
literal|0x80
condition|)
block|{
comment|/* key released */
if|if
condition|(
name|key
operator|->
name|spcl
operator|&
literal|0x80
condition|)
block|{
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|LSH
case|:
name|shfts
operator|&=
operator|~
literal|1
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|shfts
operator|&=
operator|~
literal|2
expr_stmt|;
break|break;
case|case
name|LCTR
case|:
name|ctls
operator|&=
operator|~
literal|1
expr_stmt|;
break|break;
case|case
name|RCTR
case|:
name|ctls
operator|&=
operator|~
literal|2
expr_stmt|;
break|break;
case|case
name|LALT
case|:
name|alts
operator|&=
operator|~
literal|1
expr_stmt|;
break|break;
case|case
name|RALT
case|:
name|alts
operator|&=
operator|~
literal|2
expr_stmt|;
break|break;
case|case
name|NLK
case|:
name|nlkcnt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CLK
case|:
name|clkcnt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SLK
case|:
name|slkcnt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ASH
case|:
name|agrs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ALK
case|:
name|alkcnt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|META
case|:
name|metas
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|chr
operator|&&
operator|!
name|compose
condition|)
block|{
name|action
operator|=
name|chr
expr_stmt|;
name|chr
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* key pressed */
if|if
condition|(
name|key
operator|->
name|spcl
operator|&
operator|(
literal|0x80
operator|>>
name|state
operator|)
condition|)
block|{
switch|switch
condition|(
name|action
condition|)
block|{
comment|/* LOCKING KEYS */
case|case
name|NLK
case|:
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
name|toggle_splash_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
comment|/* SOS XXX */
endif|#
directive|endif
if|if
condition|(
operator|!
name|nlkcnt
condition|)
block|{
name|nlkcnt
operator|++
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|NLKED
condition|)
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|NLKED
expr_stmt|;
else|else
name|cur_console
operator|->
name|status
operator||=
name|NLKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLK
case|:
if|if
condition|(
operator|!
name|clkcnt
condition|)
block|{
name|clkcnt
operator|++
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|CLKED
condition|)
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|CLKED
expr_stmt|;
else|else
name|cur_console
operator|->
name|status
operator||=
name|CLKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SLK
case|:
if|if
condition|(
operator|!
name|slkcnt
condition|)
block|{
name|slkcnt
operator|++
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|SLKED
condition|)
block|{
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|SLKED
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|BUFFER_SAVED
condition|)
block|{
name|int
name|i
decl_stmt|;
name|u_short
modifier|*
name|ptr
init|=
name|cur_console
operator|->
name|history_save
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cur_console
operator|->
name|ysize
condition|;
name|i
operator|++
control|)
block|{
name|bcopyw
argument_list|(
name|ptr
argument_list|,
name|cur_console
operator|->
name|scr_buf
operator|+
operator|(
name|cur_console
operator|->
name|xsize
operator|*
name|i
operator|)
argument_list|,
name|cur_console
operator|->
name|xsize
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|cur_console
operator|->
name|xsize
expr_stmt|;
if|if
condition|(
name|ptr
operator|+
name|cur_console
operator|->
name|xsize
operator|>
name|cur_console
operator|->
name|history
operator|+
name|cur_console
operator|->
name|history_size
condition|)
name|ptr
operator|=
name|cur_console
operator|->
name|history
expr_stmt|;
block|}
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|BUFFER_SAVED
expr_stmt|;
name|cur_console
operator|->
name|history_head
operator|=
name|cur_console
operator|->
name|history_save
expr_stmt|;
name|cur_console
operator|->
name|status
operator||=
name|CURSOR_ENABLED
expr_stmt|;
name|mark_all
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
block|}
name|scstart
argument_list|(
name|VIRTUAL_TTY
argument_list|(
name|get_scr_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|cur_console
operator|->
name|status
operator||=
name|SLKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ALK
case|:
if|if
condition|(
operator|!
name|alkcnt
condition|)
block|{
name|alkcnt
operator|++
expr_stmt|;
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|ALKED
condition|)
name|cur_console
operator|->
name|status
operator|&=
operator|~
name|ALKED
expr_stmt|;
else|else
name|cur_console
operator|->
name|status
operator||=
name|ALKED
expr_stmt|;
name|update_leds
argument_list|(
name|cur_console
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* NON-LOCKING KEYS */
case|case
name|NOP
case|:
break|break;
case|case
name|SPSC
case|:
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
name|toggle_splash_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|RBT
case|:
name|shutdown_nice
argument_list|()
expr_stmt|;
break|break;
case|case
name|SUSP
case|:
if|#
directive|if
name|NAPM
operator|>
literal|0
name|apm_suspend
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DBG
case|:
ifdef|#
directive|ifdef
name|DDB
comment|/* try to switch to console 0 */
if|if
condition|(
name|cur_console
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
operator|&&
name|console
index|[
literal|0
index|]
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_AUTO
condition|)
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"manual escape to debugger"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"No debugger in kernel\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|LSH
case|:
name|shfts
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|RSH
case|:
name|shfts
operator||=
literal|2
expr_stmt|;
break|break;
case|case
name|LCTR
case|:
name|ctls
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|RCTR
case|:
name|ctls
operator||=
literal|2
expr_stmt|;
break|break;
case|case
name|LALT
case|:
name|alts
operator||=
literal|1
expr_stmt|;
break|break;
case|case
name|RALT
case|:
name|alts
operator||=
literal|2
expr_stmt|;
break|break;
case|case
name|ASH
case|:
name|agrs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|META
case|:
name|metas
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|NEXT
case|:
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
operator|(
name|get_scr_num
argument_list|()
operator|+
literal|1
operator|)
operator|%
name|MAXCONS
argument_list|)
expr_stmt|;
break|break;
case|case
name|BTAB
case|:
return|return
operator|(
name|BKEY
operator|)
return|;
default|default:
if|if
condition|(
name|action
operator|>=
name|F_SCR
operator|&&
name|action
operator|<=
name|L_SCR
condition|)
block|{
name|switch_scr
argument_list|(
name|cur_console
argument_list|,
name|action
operator|-
name|F_SCR
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|action
operator|>=
name|F_FN
operator|&&
name|action
operator|<=
name|L_FN
condition|)
name|action
operator||=
name|FKEY
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|metas
condition|)
name|action
operator||=
name|MKEY
expr_stmt|;
return|return
operator|(
name|action
operator|)
return|;
block|}
block|}
goto|goto
name|next_code
goto|;
block|}
end_function

begin_function
name|int
name|scmmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|>
literal|0x20000
operator|-
name|PAGE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i386_btop
argument_list|(
operator|(
name|VIDEOMEM
operator|+
name|offset
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate hardware attributes word using logical attributes mask and  * hardware colors  */
end_comment

begin_function
specifier|static
name|int
name|mask2attr
parameter_list|(
name|struct
name|term_stat
modifier|*
name|term
parameter_list|)
block|{
name|int
name|attr
decl_stmt|,
name|mask
init|=
name|term
operator|->
name|attr_mask
decl_stmt|;
if|if
condition|(
name|mask
operator|&
name|REVERSE_ATTR
condition|)
block|{
name|attr
operator|=
operator|(
operator|(
name|mask
operator|&
name|FOREGROUND_CHANGED
operator|)
condition|?
operator|(
operator|(
name|term
operator|->
name|cur_color
operator|&
literal|0xF000
operator|)
operator|>>
literal|4
operator|)
else|:
operator|(
name|term
operator|->
name|rev_color
operator|&
literal|0x0F00
operator|)
operator|)
operator||
operator|(
operator|(
name|mask
operator|&
name|BACKGROUND_CHANGED
operator|)
condition|?
operator|(
operator|(
name|term
operator|->
name|cur_color
operator|&
literal|0x0F00
operator|)
operator|<<
literal|4
operator|)
else|:
operator|(
name|term
operator|->
name|rev_color
operator|&
literal|0xF000
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|attr
operator|=
name|term
operator|->
name|cur_color
expr_stmt|;
comment|/* XXX: underline mapping for Hercules adapter can be better */
if|if
condition|(
name|mask
operator|&
operator|(
name|BOLD_ATTR
operator||
name|UNDERLINE_ATTR
operator|)
condition|)
name|attr
operator|^=
literal|0x0800
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|BLINK_ATTR
condition|)
name|attr
operator|^=
literal|0x8000
expr_stmt|;
return|return
name|attr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_keyboard
parameter_list|(
name|int
name|command
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|sc_kbdc
operator|==
name|NULL
condition|)
return|return;
comment|/* prevent the timeout routine from polling the keyboard */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return;
comment|/* disable the keyboard and mouse interrupt */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|c
operator|=
name|get_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
operator|-
literal|1
operator|)
operator|||
operator|!
name|set_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc_kbdc
argument_list|)
argument_list|,
name|KBD_ENABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*       * Now that the keyboard controller is told not to generate       * the keyboard and mouse interrupts, call `splx()' to allow       * the other tty interrupts. The clock interrupt may also occur,       * but the timeout routine (`scrn_timer()') will be blocked       * by the lock flag set via `kbdc_lock()'      */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|send_kbd_command_and_data
argument_list|(
name|sc_kbdc
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* restore the interrupts */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc_kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc_kbdc
argument_list|)
argument_list|,
name|c
operator|&
operator|(
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
operator|)
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR */
block|}
name|kbdc_lock
argument_list|(
name|sc_kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_leds
parameter_list|(
name|int
name|which
parameter_list|)
block|{
specifier|static
name|u_char
name|xlate_leds
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|4
block|,
literal|2
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|7
block|}
decl_stmt|;
comment|/* replace CAPS led with ALTGR led for ALTGR keyboards */
if|if
condition|(
name|key_map
operator|.
name|n_keys
operator|>
name|ALTGR_OFFSET
condition|)
block|{
if|if
condition|(
name|which
operator|&
name|ALKED
condition|)
name|which
operator||=
name|CLKED
expr_stmt|;
else|else
name|which
operator|&=
operator|~
name|CLKED
expr_stmt|;
block|}
name|set_keyboard
argument_list|(
name|KBDC_SET_LEDS
argument_list|,
name|xlate_leds
index|[
name|which
operator|&
name|LED_MASK
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_mode
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|char
modifier|*
name|modetable
decl_stmt|;
name|char
name|special_modetable
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
return|return;
comment|/* setup video hardware for the given mode */
switch|switch
condition|(
name|scp
operator|->
name|mode
condition|)
block|{
case|case
name|M_VGA_M80x60
case|:
name|bcopyw
argument_list|(
name|video_mode_ptr
operator|+
operator|(
literal|64
operator|*
name|M_VGA_M80x25
operator|)
argument_list|,
operator|&
name|special_modetable
argument_list|,
literal|64
argument_list|)
expr_stmt|;
goto|goto
name|special_80x60
goto|;
case|case
name|M_VGA_C80x60
case|:
name|bcopyw
argument_list|(
name|video_mode_ptr
operator|+
operator|(
literal|64
operator|*
name|M_VGA_C80x25
operator|)
argument_list|,
operator|&
name|special_modetable
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|special_80x60
label|:
name|special_modetable
index|[
literal|2
index|]
operator|=
literal|0x08
expr_stmt|;
name|special_modetable
index|[
literal|19
index|]
operator|=
literal|0x47
expr_stmt|;
goto|goto
name|special_480l
goto|;
case|case
name|M_VGA_M80x30
case|:
name|bcopyw
argument_list|(
name|video_mode_ptr
operator|+
operator|(
literal|64
operator|*
name|M_VGA_M80x25
operator|)
argument_list|,
operator|&
name|special_modetable
argument_list|,
literal|64
argument_list|)
expr_stmt|;
goto|goto
name|special_80x30
goto|;
case|case
name|M_VGA_C80x30
case|:
name|bcopyw
argument_list|(
name|video_mode_ptr
operator|+
operator|(
literal|64
operator|*
name|M_VGA_C80x25
operator|)
argument_list|,
operator|&
name|special_modetable
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|special_80x30
label|:
name|special_modetable
index|[
literal|19
index|]
operator|=
literal|0x4f
expr_stmt|;
name|special_480l
label|:
name|special_modetable
index|[
literal|9
index|]
operator||=
literal|0xc0
expr_stmt|;
name|special_modetable
index|[
literal|16
index|]
operator|=
literal|0x08
expr_stmt|;
name|special_modetable
index|[
literal|17
index|]
operator|=
literal|0x3e
expr_stmt|;
name|special_modetable
index|[
literal|26
index|]
operator|=
literal|0xea
expr_stmt|;
name|special_modetable
index|[
literal|28
index|]
operator|=
literal|0xdf
expr_stmt|;
name|special_modetable
index|[
literal|31
index|]
operator|=
literal|0xe7
expr_stmt|;
name|special_modetable
index|[
literal|32
index|]
operator|=
literal|0x04
expr_stmt|;
name|modetable
operator|=
name|special_modetable
expr_stmt|;
goto|goto
name|setup_mode
goto|;
case|case
name|M_ENH_B80x43
case|:
name|bcopyw
argument_list|(
name|video_mode_ptr
operator|+
operator|(
literal|64
operator|*
name|M_ENH_B80x25
operator|)
argument_list|,
operator|&
name|special_modetable
argument_list|,
literal|64
argument_list|)
expr_stmt|;
goto|goto
name|special_80x43
goto|;
case|case
name|M_ENH_C80x43
case|:
name|bcopyw
argument_list|(
name|video_mode_ptr
operator|+
operator|(
literal|64
operator|*
name|M_ENH_C80x25
operator|)
argument_list|,
operator|&
name|special_modetable
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|special_80x43
label|:
name|special_modetable
index|[
literal|28
index|]
operator|=
literal|87
expr_stmt|;
goto|goto
name|special_80x50
goto|;
case|case
name|M_VGA_M80x50
case|:
name|bcopyw
argument_list|(
name|video_mode_ptr
operator|+
operator|(
literal|64
operator|*
name|M_VGA_M80x25
operator|)
argument_list|,
operator|&
name|special_modetable
argument_list|,
literal|64
argument_list|)
expr_stmt|;
goto|goto
name|special_80x50
goto|;
case|case
name|M_VGA_C80x50
case|:
name|bcopyw
argument_list|(
name|video_mode_ptr
operator|+
operator|(
literal|64
operator|*
name|M_VGA_C80x25
operator|)
argument_list|,
operator|&
name|special_modetable
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|special_80x50
label|:
name|special_modetable
index|[
literal|2
index|]
operator|=
literal|8
expr_stmt|;
name|special_modetable
index|[
literal|19
index|]
operator|=
literal|7
expr_stmt|;
name|modetable
operator|=
name|special_modetable
expr_stmt|;
goto|goto
name|setup_mode
goto|;
case|case
name|M_VGA_C40x25
case|:
case|case
name|M_VGA_C80x25
case|:
case|case
name|M_VGA_M80x25
case|:
case|case
name|M_B40x25
case|:
case|case
name|M_C40x25
case|:
case|case
name|M_B80x25
case|:
case|case
name|M_C80x25
case|:
case|case
name|M_ENH_B40x25
case|:
case|case
name|M_ENH_C40x25
case|:
case|case
name|M_ENH_B80x25
case|:
case|case
name|M_ENH_C80x25
case|:
name|modetable
operator|=
name|video_mode_ptr
operator|+
operator|(
name|scp
operator|->
name|mode
operator|*
literal|64
operator|)
expr_stmt|;
name|setup_mode
label|:
name|set_vgaregs
argument_list|(
name|modetable
argument_list|)
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
operator|*
operator|(
name|modetable
operator|+
literal|2
operator|)
expr_stmt|;
comment|/* set font type (size) */
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<
name|FONT_14
condition|)
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_8
condition|)
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_8
argument_list|,
name|font_8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x0A
argument_list|)
expr_stmt|;
comment|/* font 2 */
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|font_size
operator|>=
name|FONT_16
condition|)
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_16
condition|)
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_16
argument_list|,
name|font_16
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* font 0 */
block|}
else|else
block|{
if|if
condition|(
name|fonts_loaded
operator|&
name|FONT_14
condition|)
name|copy_font
argument_list|(
name|LOAD
argument_list|,
name|FONT_14
argument_list|,
name|font_14
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* font 1 */
block|}
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|set_destructive_cursor
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_BG320
case|:
case|case
name|M_CG320
case|:
case|case
name|M_BG640
case|:
case|case
name|M_CG320_D
case|:
case|case
name|M_CG640_E
case|:
case|case
name|M_CG640x350
case|:
case|case
name|M_ENH_CG640
case|:
case|case
name|M_BG640x480
case|:
case|case
name|M_CG640x480
case|:
case|case
name|M_VGA_CG320
case|:
name|set_vgaregs
argument_list|(
name|video_mode_ptr
operator|+
operator|(
name|scp
operator|->
name|mode
operator|*
literal|64
operator|)
argument_list|)
expr_stmt|;
name|scp
operator|->
name|font_size
operator|=
name|FONT_NONE
expr_stmt|;
break|break;
default|default:
comment|/* call user defined function XXX */
break|break;
block|}
comment|/* set border color for this (virtual) console */
name|set_border
argument_list|(
name|scp
operator|->
name|border
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|set_border
parameter_list|(
name|u_char
name|color
parameter_list|)
block|{
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|color
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable Palette */
block|}
end_function

begin_function
specifier|static
name|void
name|set_vgaregs
parameter_list|(
name|char
modifier|*
name|modetable
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* stop sequencer */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* unlock registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|/* program sequencer */
name|outb
argument_list|(
name|TSIDX
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|modetable
index|[
name|i
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|MISC
argument_list|,
name|modetable
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/* set dot-clock */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* start sequencer */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|)
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
block|{
comment|/* program crtc */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|14
operator|||
name|i
operator|==
literal|15
condition|)
comment|/* no hardware cursor */
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
name|modetable
index|[
name|i
operator|+
literal|10
index|]
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
comment|/* program attribute ctrl */
name|outb
argument_list|(
name|ATC
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|modetable
index|[
name|i
operator|+
literal|35
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
comment|/* program graph data ctrl */
name|outb
argument_list|(
name|GDCIDX
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
name|modetable
index|[
name|i
operator|+
literal|55
index|]
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_font_mode
parameter_list|()
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
comment|/* setup vga for loading fonts (graphics plane mode) */
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
if|#
directive|if
name|SLOW_VGA
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
else|#
directive|else
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0402
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0604
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0204
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0506
argument_list|)
expr_stmt|;
comment|/* addr = a0000, 64kb */
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_normal_mode
parameter_list|()
block|{
name|char
modifier|*
name|modetable
decl_stmt|;
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|cur_console
operator|->
name|mode
condition|)
block|{
case|case
name|M_VGA_M80x60
case|:
case|case
name|M_VGA_M80x50
case|:
case|case
name|M_VGA_M80x30
case|:
name|modetable
operator|=
name|video_mode_ptr
operator|+
operator|(
literal|64
operator|*
name|M_VGA_M80x25
operator|)
expr_stmt|;
break|break;
case|case
name|M_VGA_C80x60
case|:
case|case
name|M_VGA_C80x50
case|:
case|case
name|M_VGA_C80x30
case|:
name|modetable
operator|=
name|video_mode_ptr
operator|+
operator|(
literal|64
operator|*
name|M_VGA_C80x25
operator|)
expr_stmt|;
break|break;
case|case
name|M_ENH_B80x43
case|:
name|modetable
operator|=
name|video_mode_ptr
operator|+
operator|(
literal|64
operator|*
name|M_ENH_B80x25
operator|)
expr_stmt|;
break|break;
case|case
name|M_ENH_C80x43
case|:
name|modetable
operator|=
name|video_mode_ptr
operator|+
operator|(
literal|64
operator|*
name|M_ENH_C80x25
operator|)
expr_stmt|;
break|break;
case|case
name|M_VGA_C40x25
case|:
case|case
name|M_VGA_C80x25
case|:
case|case
name|M_VGA_M80x25
case|:
case|case
name|M_B40x25
case|:
case|case
name|M_C40x25
case|:
case|case
name|M_B80x25
case|:
case|case
name|M_C80x25
case|:
case|case
name|M_ENH_B40x25
case|:
case|case
name|M_ENH_C40x25
case|:
case|case
name|M_ENH_B80x25
case|:
case|case
name|M_ENH_C80x25
case|:
case|case
name|M_BG320
case|:
case|case
name|M_CG320
case|:
case|case
name|M_BG640
case|:
case|case
name|M_CG320_D
case|:
case|case
name|M_CG640_E
case|:
case|case
name|M_CG640x350
case|:
case|case
name|M_ENH_CG640
case|:
case|case
name|M_BG640x480
case|:
case|case
name|M_CG640x480
case|:
case|case
name|M_VGA_CG320
case|:
name|modetable
operator|=
name|video_mode_ptr
operator|+
operator|(
name|cur_console
operator|->
name|mode
operator|*
literal|64
operator|)
expr_stmt|;
default|default:
name|modetable
operator|=
name|video_mode_ptr
operator|+
operator|(
literal|64
operator|*
name|M_VGA_C80x25
operator|)
expr_stmt|;
block|}
comment|/* setup vga for normal operation mode again */
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|modetable
index|[
literal|0x10
operator|+
literal|35
index|]
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
if|#
directive|if
name|SLOW_VGA
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|modetable
index|[
literal|0x02
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|modetable
index|[
literal|0x04
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
name|modetable
index|[
literal|0x04
operator|+
literal|55
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
name|modetable
index|[
literal|0x05
operator|+
literal|55
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
name|modetable
index|[
literal|0x06
operator|+
literal|55
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc_addr
operator|==
name|MONO_BASE
condition|)
block|{
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
operator|(
name|modetable
index|[
literal|0x06
operator|+
literal|55
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
operator|(
name|modetable
index|[
literal|0x06
operator|+
literal|55
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x0c
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0002
operator||
operator|(
name|modetable
index|[
literal|0x02
operator|+
literal|4
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0004
operator||
operator|(
name|modetable
index|[
literal|0x04
operator|+
literal|4
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0004
operator||
operator|(
name|modetable
index|[
literal|0x04
operator|+
literal|55
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0005
operator||
operator|(
name|modetable
index|[
literal|0x05
operator|+
literal|55
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|crtc_addr
operator|==
name|MONO_BASE
condition|)
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0006
operator||
operator|(
operator|(
operator|(
name|modetable
index|[
literal|0x06
operator|+
literal|55
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x08
operator|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
else|else
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0006
operator||
operator|(
operator|(
operator|(
name|modetable
index|[
literal|0x06
operator|+
literal|55
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x0c
operator|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|copy_font
parameter_list|(
name|int
name|operation
parameter_list|,
name|int
name|font_type
parameter_list|,
name|char
modifier|*
name|font_image
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|line
decl_stmt|,
name|segment
decl_stmt|,
name|fontsize
decl_stmt|;
name|u_char
name|val
decl_stmt|;
comment|/* dont mess with console we dont know video mode on */
if|if
condition|(
name|cur_console
operator|->
name|status
operator|&
name|UNKNOWN_MODE
condition|)
return|return;
switch|switch
condition|(
name|font_type
condition|)
block|{
default|default:
case|case
name|FONT_8
case|:
name|segment
operator|=
literal|0x8000
expr_stmt|;
name|fontsize
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FONT_14
case|:
name|segment
operator|=
literal|0x4000
expr_stmt|;
name|fontsize
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|FONT_16
case|:
name|segment
operator|=
literal|0x0000
expr_stmt|;
name|fontsize
operator|=
literal|16
expr_stmt|;
break|break;
block|}
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
comment|/* disable screen */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|val
operator||
literal|0x20
argument_list|)
expr_stmt|;
name|set_font_mode
argument_list|()
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
literal|256
condition|;
name|ch
operator|++
control|)
for|for
control|(
name|line
operator|=
literal|0
init|;
name|line
operator|<
name|fontsize
condition|;
name|line
operator|++
control|)
if|if
condition|(
name|operation
condition|)
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
name|VIDEOMEM
operator|+
operator|(
name|segment
operator|)
operator|+
operator|(
name|ch
operator|*
literal|32
operator|)
operator|+
name|line
argument_list|)
operator|=
name|font_image
index|[
operator|(
name|ch
operator|*
name|fontsize
operator|)
operator|+
name|line
index|]
expr_stmt|;
else|else
name|font_image
index|[
operator|(
name|ch
operator|*
name|fontsize
operator|)
operator|+
name|line
index|]
operator|=
operator|*
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
name|VIDEOMEM
operator|+
operator|(
name|segment
operator|)
operator|+
operator|(
name|ch
operator|*
literal|32
operator|)
operator|+
name|line
argument_list|)
expr_stmt|;
name|set_normal_mode
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|val
operator|&
literal|0xDF
argument_list|)
expr_stmt|;
comment|/* enable screen */
block|}
end_function

begin_function
specifier|static
name|void
name|set_destructive_cursor
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_char
name|cursor
index|[
literal|32
index|]
decl_stmt|;
name|caddr_t
name|address
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|font_buffer
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|font_size
operator|<
name|FONT_14
condition|)
block|{
name|font_buffer
operator|=
name|font_8
expr_stmt|;
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|VIDEOMEM
operator|+
literal|0x8000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scp
operator|->
name|font_size
operator|>=
name|FONT_16
condition|)
block|{
name|font_buffer
operator|=
name|font_16
expr_stmt|;
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|VIDEOMEM
expr_stmt|;
block|}
else|else
block|{
name|font_buffer
operator|=
name|font_14
expr_stmt|;
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|VIDEOMEM
operator|+
literal|0x4000
expr_stmt|;
block|}
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
literal|0xd0
condition|)
name|bcopyw
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|0
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
literal|0xd1
condition|)
name|bcopyw
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|32
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
literal|0xd2
condition|)
name|bcopyw
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|64
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|==
literal|0xd3
condition|)
name|bcopyw
argument_list|(
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|96
index|]
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
else|else
name|bcopyw
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|*
name|scp
operator|->
name|font_size
operator|)
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopyw
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
name|scp
operator|->
name|cursor_saveunder
operator|&
literal|0xff
operator|)
operator|*
name|scp
operator|->
name|font_size
operator|)
argument_list|,
name|cursor
argument_list|,
name|scp
operator|->
name|font_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|i
operator|>=
name|scp
operator|->
name|cursor_start
operator|&&
name|i
operator|<=
name|scp
operator|->
name|cursor_end
operator|)
operator|||
operator|(
name|scp
operator|->
name|cursor_start
operator|>=
name|scp
operator|->
name|font_size
operator|&&
name|i
operator|==
name|scp
operator|->
name|font_size
operator|-
literal|1
operator|)
condition|)
name|cursor
index|[
name|i
index|]
operator||=
literal|0xff
expr_stmt|;
if|#
directive|if
literal|1
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
comment|/* wait for vertical retrace */
empty_stmt|;
endif|#
directive|endif
name|set_font_mode
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|cursor
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
name|address
argument_list|)
operator|+
name|DEAD_CHAR
operator|*
literal|32
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_normal_mode
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mouse_pos
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
specifier|static
name|int
name|last_xpos
init|=
operator|-
literal|1
decl_stmt|,
name|last_ypos
init|=
operator|-
literal|1
decl_stmt|;
comment|/*       * the margins imposed here are not ideal, we loose      * a couble of pixels on the borders..      */
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|<
literal|0
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|<
literal|0
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|>
operator|(
name|scp
operator|->
name|xsize
operator|*
literal|8
operator|)
operator|-
literal|2
condition|)
name|scp
operator|->
name|mouse_xpos
operator|=
operator|(
name|scp
operator|->
name|xsize
operator|*
literal|8
operator|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_ypos
operator|>
operator|(
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
operator|)
operator|-
literal|2
condition|)
name|scp
operator|->
name|mouse_ypos
operator|=
operator|(
name|scp
operator|->
name|ysize
operator|*
name|scp
operator|->
name|font_size
operator|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|UNKNOWN_MODE
condition|)
return|return;
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|!=
name|last_xpos
operator|||
name|scp
operator|->
name|mouse_ypos
operator|!=
name|last_ypos
condition|)
block|{
name|scp
operator|->
name|status
operator||=
name|MOUSE_MOVED
expr_stmt|;
name|scp
operator|->
name|mouse_pos
operator|=
name|scp
operator|->
name|scr_buf
operator|+
operator|(
operator|(
name|scp
operator|->
name|mouse_ypos
operator|/
name|scp
operator|->
name|font_size
operator|)
operator|*
name|scp
operator|->
name|xsize
operator|+
name|scp
operator|->
name|mouse_xpos
operator|/
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
operator|)
operator|&&
operator|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_CUTTING
operator|)
condition|)
block|{
name|u_short
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_start
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_cut_end
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|scp
operator|->
name|mouse_cut_end
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
for|for
control|(
name|ptr
operator|=
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
condition|?
name|scp
operator|->
name|mouse_cut_end
else|:
name|scp
operator|->
name|mouse_cut_start
operator|)
init|;
name|ptr
operator|<=
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
condition|?
name|scp
operator|->
name|mouse_cut_start
else|:
name|scp
operator|->
name|mouse_cut_end
operator|)
condition|;
name|ptr
operator|++
control|)
block|{
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|ptr
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|%
name|scp
operator|->
name|xsize
operator|)
operator|==
operator|(
name|scp
operator|->
name|xsize
operator|-
literal|1
operator|)
condition|)
block|{
name|cut_buffer
index|[
name|i
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
name|cut_buffer
index|[
name|i
index|]
operator|=
literal|0x00
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut_start
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
if|if
condition|(
name|scp
operator|->
name|mouse_pos
operator|==
name|scp
operator|->
name|mouse_cut_start
operator|&&
name|scp
operator|->
name|mouse_cut_start
operator|==
name|scp
operator|->
name|mouse_cut_end
condition|)
block|{
name|cut_buffer
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|remove_cutmarking
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|mouse_cut_end
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
name|cut_buffer
index|[
literal|0
index|]
operator|=
operator|*
name|scp
operator|->
name|mouse_cut_start
operator|&
literal|0xff
expr_stmt|;
name|cut_buffer
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|MOUSE_CUTTING
expr_stmt|;
block|}
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* delete all other screens cut markings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCONS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|console
index|[
name|i
index|]
operator|==
name|NULL
operator|||
name|console
index|[
name|i
index|]
operator|==
name|scp
condition|)
continue|continue;
name|remove_cutmarking
argument_list|(
name|console
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_cut_end
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_CUTTING
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mouse_paste
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|scp
operator|->
name|status
operator|&
name|MOUSE_VISIBLE
condition|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|u_char
modifier|*
name|ptr
init|=
name|cut_buffer
decl_stmt|;
name|tp
operator|=
name|VIRTUAL_TTY
argument_list|(
name|get_scr_num
argument_list|()
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|scr_rmap
index|[
operator|*
name|ptr
operator|++
index|]
operator|,
name|tp
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|draw_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|caddr_t
name|address
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|font_buffer
decl_stmt|;
name|u_short
name|buffer
index|[
literal|32
index|]
decl_stmt|;
name|u_short
name|xoffset
decl_stmt|,
name|yoffset
decl_stmt|;
name|u_short
modifier|*
name|crt_pos
init|=
name|Crtat
operator|+
operator|(
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
decl_stmt|;
name|int
name|font_size
init|=
name|scp
operator|->
name|font_size
decl_stmt|;
if|if
condition|(
name|font_size
operator|<
name|FONT_14
condition|)
block|{
name|font_buffer
operator|=
name|font_8
expr_stmt|;
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|VIDEOMEM
operator|+
literal|0x8000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|font_size
operator|>=
name|FONT_16
condition|)
block|{
name|font_buffer
operator|=
name|font_16
expr_stmt|;
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|VIDEOMEM
expr_stmt|;
block|}
else|else
block|{
name|font_buffer
operator|=
name|font_14
expr_stmt|;
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|VIDEOMEM
operator|+
literal|0x4000
expr_stmt|;
block|}
name|xoffset
operator|=
name|scp
operator|->
name|mouse_xpos
operator|%
literal|8
expr_stmt|;
name|yoffset
operator|=
name|scp
operator|->
name|mouse_ypos
operator|%
name|font_size
expr_stmt|;
comment|/* prepare mousepointer char's bitmaps */
name|bcopyw
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|0
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
name|bcopyw
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|32
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
name|bcopyw
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|64
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
name|bcopyw
argument_list|(
name|font_buffer
operator|+
operator|(
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
operator|*
name|font_size
operator|)
argument_list|,
operator|&
name|scp
operator|->
name|mouse_cursor
index|[
literal|96
index|]
argument_list|,
name|font_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|font_size
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
index|]
operator|=
name|scp
operator|->
name|mouse_cursor
index|[
name|i
index|]
operator|<<
literal|8
operator||
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|32
index|]
expr_stmt|;
name|buffer
index|[
name|i
operator|+
name|font_size
index|]
operator|=
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|64
index|]
operator|<<
literal|8
operator||
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|96
index|]
expr_stmt|;
block|}
comment|/* now and-or in the mousepointer image */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|buffer
index|[
name|i
operator|+
name|yoffset
index|]
operator|=
operator|(
name|buffer
index|[
name|i
operator|+
name|yoffset
index|]
operator|&
operator|~
operator|(
name|mouse_and_mask
index|[
name|i
index|]
operator|>>
name|xoffset
operator|)
operator|)
operator||
operator|(
name|mouse_or_mask
index|[
name|i
index|]
operator|>>
name|xoffset
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|font_size
condition|;
name|i
operator|++
control|)
block|{
name|scp
operator|->
name|mouse_cursor
index|[
name|i
index|]
operator|=
operator|(
name|buffer
index|[
name|i
index|]
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|32
index|]
operator|=
name|buffer
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|64
index|]
operator|=
operator|(
name|buffer
index|[
name|i
operator|+
name|font_size
index|]
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|scp
operator|->
name|mouse_cursor
index|[
name|i
operator|+
literal|96
index|]
operator|=
name|buffer
index|[
name|i
operator|+
name|font_size
index|]
operator|&
literal|0xff
expr_stmt|;
block|}
name|scp
operator|->
name|mouse_oldpos
operator|=
name|scp
operator|->
name|mouse_pos
expr_stmt|;
comment|/* wait for vertical retrace to avoid jitter on some videocards */
if|#
directive|if
literal|1
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
comment|/* idle */
empty_stmt|;
endif|#
directive|endif
name|set_font_mode
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|scp
operator|->
name|mouse_cursor
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pa_to_va
argument_list|(
name|address
argument_list|)
operator|+
literal|0xd0
operator|*
literal|32
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|set_normal_mode
argument_list|()
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|)
operator|&
literal|0xff00
operator|)
operator||
literal|0xd0
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|&
literal|0xff00
operator|)
operator||
literal|0xd2
expr_stmt|;
if|if
condition|(
name|scp
operator|->
name|mouse_xpos
operator|<
operator|(
name|scp
operator|->
name|xsize
operator|-
literal|1
operator|)
operator|*
literal|8
condition|)
block|{
operator|*
operator|(
name|crt_pos
operator|+
literal|1
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
literal|1
operator|)
operator|&
literal|0xff00
operator|)
operator||
literal|0xd1
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|=
operator|(
operator|*
operator|(
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|&
literal|0xff00
operator|)
operator||
literal|0xd3
expr_stmt|;
block|}
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_mouse_image
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|crt_pos
init|=
name|Crtat
operator|+
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|-
name|scp
operator|->
name|scr_buf
operator|)
decl_stmt|;
operator|*
operator|(
name|crt_pos
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|+
name|scp
operator|->
name|xsize
operator|)
expr_stmt|;
operator|*
operator|(
name|crt_pos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
operator|=
operator|*
operator|(
name|scp
operator|->
name|mouse_oldpos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_oldpos
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
name|mark_for_update
argument_list|(
name|scp
argument_list|,
name|scp
operator|->
name|mouse_oldpos
operator|+
name|scp
operator|->
name|xsize
operator|+
literal|1
operator|-
name|scp
operator|->
name|scr_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|draw_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|u_short
modifier|*
name|ptr
decl_stmt|;
name|u_short
name|och
decl_stmt|,
name|nch
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|scp
operator|->
name|scr_buf
init|;
name|ptr
operator|<=
operator|(
name|scp
operator|->
name|scr_buf
operator|+
operator|(
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
operator|)
operator|)
condition|;
name|ptr
operator|++
control|)
block|{
name|nch
operator|=
name|och
operator|=
operator|*
operator|(
name|Crtat
operator|+
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
expr_stmt|;
comment|/* are we outside the selected area ? */
if|if
condition|(
name|ptr
operator|<
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
condition|?
name|scp
operator|->
name|mouse_cut_end
else|:
name|scp
operator|->
name|mouse_cut_start
operator|)
operator|||
name|ptr
operator|>
operator|(
name|scp
operator|->
name|mouse_cut_start
operator|>
name|scp
operator|->
name|mouse_cut_end
condition|?
name|scp
operator|->
name|mouse_cut_start
else|:
name|scp
operator|->
name|mouse_cut_end
operator|)
condition|)
block|{
if|if
condition|(
name|ptr
operator|!=
name|scp
operator|->
name|cursor_pos
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0xff00
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* are we clear of the cursor image ? */
if|if
condition|(
name|ptr
operator|!=
name|scp
operator|->
name|cursor_pos
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0x88ff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x7000
operator|)
operator|>>
literal|4
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x0700
operator|)
operator|<<
literal|4
expr_stmt|;
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|CHAR_CURSOR
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0x88ff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x7000
operator|)
operator|>>
literal|4
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0x0700
operator|)
operator|<<
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|BLINK_CURSOR
operator|)
condition|)
name|nch
operator|=
operator|(
name|och
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|*
name|ptr
operator|&
literal|0xff00
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nch
operator|!=
name|och
condition|)
operator|*
operator|(
name|Crtat
operator|+
operator|(
name|ptr
operator|-
name|scp
operator|->
name|scr_buf
operator|)
operator|)
operator|=
name|nch
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|remove_cutmarking
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
name|scp
operator|->
name|mouse_cut_start
operator|=
name|scp
operator|->
name|mouse_cut_end
operator|=
name|NULL
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|MOUSE_CUTTING
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|save_palette
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|outb
argument_list|(
name|PALRADR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x00
init|;
name|i
operator|<
literal|0x300
condition|;
name|i
operator|++
control|)
name|palette
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|PALDATA
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip/flop */
block|}
end_function

begin_function
name|void
name|load_palette
parameter_list|(
name|char
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|outb
argument_list|(
name|PIXMASK
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* no pixelmask */
name|outb
argument_list|(
name|PALWADR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x00
init|;
name|i
operator|<
literal|0x300
condition|;
name|i
operator|++
control|)
name|outb
argument_list|(
name|PALDATA
argument_list|,
name|palette
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip/flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
block|}
end_function

begin_function
specifier|static
name|void
name|do_bell
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|,
name|int
name|pitch
parameter_list|,
name|int
name|duration
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|VISUAL_BELL
condition|)
block|{
if|if
condition|(
name|blink_in_progress
condition|)
return|return;
name|blink_in_progress
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
name|blink_in_progress
operator|+=
literal|2
expr_stmt|;
name|blink_screen
argument_list|(
name|cur_console
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
operator|(
name|timeout_func_t
operator|)
name|blink_screen
argument_list|,
name|cur_console
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|scp
operator|!=
name|cur_console
condition|)
name|pitch
operator|*=
literal|2
expr_stmt|;
name|sysbeep
argument_list|(
name|pitch
argument_list|,
name|duration
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|blink_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
if|if
condition|(
name|blink_in_progress
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|blink_in_progress
operator|&
literal|1
condition|)
name|fillw
argument_list|(
name|kernel_default
operator|.
name|std_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|Crtat
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
else|else
name|fillw
argument_list|(
name|kernel_default
operator|.
name|rev_color
operator||
name|scr_map
index|[
literal|0x20
index|]
argument_list|,
name|Crtat
argument_list|,
name|scp
operator|->
name|xsize
operator|*
name|scp
operator|->
name|ysize
argument_list|)
expr_stmt|;
name|blink_in_progress
operator|--
expr_stmt|;
name|timeout
argument_list|(
operator|(
name|timeout_func_t
operator|)
name|blink_screen
argument_list|,
name|scp
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|blink_in_progress
operator|=
name|FALSE
expr_stmt|;
name|mark_all
argument_list|(
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|delayed_next_scr
condition|)
name|switch_scr
argument_list|(
name|scp
argument_list|,
name|delayed_next_scr
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SC_SPLASH_SCREEN
end_ifdef

begin_function
specifier|static
name|void
name|toggle_splash_screen
parameter_list|(
name|scr_stat
modifier|*
name|scp
parameter_list|)
block|{
specifier|static
name|int
name|toggle
init|=
literal|0
decl_stmt|;
specifier|static
name|u_char
name|save_mode
decl_stmt|;
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
if|if
condition|(
name|toggle
condition|)
block|{
name|scp
operator|->
name|mode
operator|=
name|save_mode
expr_stmt|;
name|scp
operator|->
name|status
operator|&=
operator|~
name|UNKNOWN_MODE
expr_stmt|;
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
name|load_palette
argument_list|(
name|palette
argument_list|)
expr_stmt|;
name|toggle
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|save_mode
operator|=
name|scp
operator|->
name|mode
expr_stmt|;
name|scp
operator|->
name|mode
operator|=
name|M_VGA_CG320
expr_stmt|;
name|scp
operator|->
name|status
operator||=
name|UNKNOWN_MODE
expr_stmt|;
name|set_mode
argument_list|(
name|scp
argument_list|)
expr_stmt|;
comment|/* load image */
name|toggle
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSC */
end_comment

end_unit

