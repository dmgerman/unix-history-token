begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 1998, Joerg Wunsch  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Device driver for RealTek RTL 8002 (`REDP') based pocket-ethernet  * adapters, hooked up to a printer port.  `rdp' is a shorthand for  * REDP since some tools like netstat work best if the interface name  * has no more than three letters.  *  * Driver configuration flags so far:  *   flags 0x1 -- assume 74S288 EEPROM (default 94C46)  *   flags 0x2 -- use `slow' mode (mode 3 of the packet driver, default 0)  *  * Maybe this driver will some day also work with the successor, RTL  * 8012 (`AREDP'), which is unfortunately not fully register-  * compatible with the 8002.  The 8012 offers support for faster  * transfer modi like bidirectional SPP and EPP, 64 K x 4 buffer  * memory as opposed to 16 K x 4 for the 8002, a multicast filter, and  * a builtin multiplexer that allows chaining a printer behind the  * ethernet adapter.  *  * About the only documentation i've been able to find about the RTL  * 8002 was the packet driver source code at ftp.realtek.com.tw, so  * this driver is somewhat based on the way the packet driver handles  * the chip.  The exact author of the packet driver is unknown, the  * only name that i could find in the source was someone called Chiu,  * supposedly an employee of RealTek.  So credits to them for that  * piece of code which has proven valuable to me.  *  * Later on, Leo kuo<leo@realtek.com.tw> has been very helpful to me  * by sending me a readable (PDF) file documenting the RTL 8012, which  * helped me to also understand the 8002, as well as by providing me  * with the source code of the 8012 packet driver that i haven't been  * able to find on the FTP site.  A big Thanks! goes here to RealTek  * for this kind of service.  */
end_comment

begin_include
include|#
directive|include
file|"rdp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_rdpreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/intr_machdep.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_OLDISA
end_ifndef

begin_error
error|#
directive|error
literal|"The rdp device requires the old isa compatibility shims"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IOCTL_CMD_T
value|u_long
end_define

begin_comment
comment|/*  * Debug levels (ORed together):  *  != 0 - general (bad packets etc.)  *  2 - debug EEPROM IO  *  4 - debug interrupt status  */
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_define
define|#
directive|define
name|DEBUG
value|0
end_define

begin_comment
comment|/*  * rdp_softc: per interface info and status  */
end_comment

begin_struct
struct|struct
name|rdp_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* 				 * Ethernet common, always goes first so 				 * a rdp_softc * can be cast into an 				 * arpcom * or into an ifnet *. 				 */
comment|/* 	 * local stuff, somewhat sorted by memory alignment class 	 */
name|u_short
name|baseaddr
decl_stmt|;
comment|/* IO port address */
name|u_short
name|txsize
decl_stmt|;
comment|/* tx size for next (buffered) packet, 				 * there's only one additional packet 				 * we can buffer, thus a single variable 				 * ought to be enough */
name|int
name|txbusy
decl_stmt|;
comment|/* tx is transmitting */
name|int
name|txbuffered
decl_stmt|;
comment|/* # of packets in tx buffer */
name|int
name|slow
decl_stmt|;
comment|/* use lpt_control to send data */
name|u_char
name|irqenbit
decl_stmt|;
comment|/* mirror of current Ctrl_IRQEN */
comment|/* 	 * type of parameter EEPROM; device flags 0x1 selects 74S288 	 */
enum|enum
block|{
name|EEPROM_93C46
block|,
name|EEPROM_74S288
comment|/* or 82S123 */
block|}
name|eeprom
enum|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|rdp_softc
name|rdp_softc
index|[
name|NRDP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Since there's no fixed location in the EEPROM about where to find  * the ethernet hardware address, we drop a table of valid OUIs here,  * and search through the EEPROM until we find a possible valid  * Ethernet address.  Only the first 16 bits of all possible OUIs are  * recorded in the table (as obtained from  * http://standards.ieee.org/regauth/oui/oui.txt).  */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|allowed_ouis
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0001
block|,
literal|0x0002
block|,
literal|0x0004
block|,
literal|0x0005
block|,
literal|0x0006
block|,
literal|0x0007
block|,
literal|0x0008
block|,
literal|0x0010
block|,
literal|0x001C
block|,
literal|0x0020
block|,
literal|0x0040
block|,
literal|0x0050
block|,
literal|0x0060
block|,
literal|0x0070
block|,
literal|0x0080
block|,
literal|0x0090
block|,
literal|0x009D
block|,
literal|0x00A0
block|,
literal|0x00AA
block|,
literal|0x00BB
block|,
literal|0x00C0
block|,
literal|0x00CF
block|,
literal|0x00DD
block|,
literal|0x00E0
block|,
literal|0x00E6
block|,
literal|0x0207
block|,
literal|0x021C
block|,
literal|0x0260
block|,
literal|0x0270
block|,
literal|0x029D
block|,
literal|0x02AA
block|,
literal|0x02BB
block|,
literal|0x02C0
block|,
literal|0x02CF
block|,
literal|0x02E6
block|,
literal|0x040A
block|,
literal|0x04E0
block|,
literal|0x0800
block|,
literal|0x08BB
block|,
literal|0x1000
block|,
literal|0x1100
block|,
literal|0x8000
block|,
literal|0xAA00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ISA bus support.  */
end_comment

begin_function_decl
specifier|static
name|int
name|rdp_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rdp_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Required entry points.  */
end_comment

begin_function_decl
specifier|static
name|void
name|rdp_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rdp_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|IOCTL_CMD_T
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdp_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdp_reset
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdp_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdpintr
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * REDP private functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|rdp_stop
parameter_list|(
name|struct
name|rdp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdp_rint
parameter_list|(
name|struct
name|rdp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdp_get_packet
parameter_list|(
name|struct
name|rdp_softc
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|rdp_write_mbufs
parameter_list|(
name|struct
name|rdp_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rdp_gethwaddr_93c46
parameter_list|(
name|struct
name|rdp_softc
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdp_gethwaddr_74s288
parameter_list|(
name|struct
name|rdp_softc
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rdp_93c46_cmd
parameter_list|(
name|struct
name|rdp_softc
modifier|*
parameter_list|,
name|u_short
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|rdp_93c46_read
parameter_list|(
name|struct
name|rdp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|rdpdriver
init|=
block|{
name|INTR_TYPE_NET
block|,
name|rdp_probe
block|,
name|rdp_attach
block|,
literal|"rdp"
block|,
literal|1
comment|/* we wanna get a chance before lptN */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|COMPAT_ISA_DRIVER
argument_list|(
name|rdp
argument_list|,
name|rdpdriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * REDP-specific functions.  *  * They are inlined, thus go first in this file.  Together with gcc's  * usual optimization, these functions probably come close to the  * packet driver's hand-optimized code. ;-)  *  * Comments are partially obtained from the packet driver as well.  * Some of the function names contain register names which don't make  * much sense for us, but i've kept them for easier reference in  * comparision to the packet driver.  *  * Some of the functions are currently not used by the driver; it's  * not quite clear whether we ever need them at all.  They are  * supposedly even slower than what is currently implemented as `slow'  * mode.  Right now, `fast' (default) mode is what the packet driver  * calls mode 0, slow mode is mode 3 (writing through lpt_control,  * reading twice).  *  * We should autoprobe the modi, as opposed to making them dependent  * on a kernel configuration flag.  */
end_comment

begin_comment
comment|/*  * read a nibble from rreg; end-of-data cmd is not issued;  * used for general register read.  *  * Unlike the packet driver's version, i'm shifting the result  * by 3 here (as opposed to within the caller's code) for clarity.  *  -- Joerg  */
end_comment

begin_function
specifier|static
name|__inline
name|u_char
name|RdNib
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|rreg
parameter_list|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|EOC
operator|+
name|rreg
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|RdAddr
operator|+
name|rreg
argument_list|)
expr_stmt|;
comment|/* write addr */
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_status
argument_list|)
expr_stmt|;
return|return
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_status
argument_list|)
operator|>>
literal|3
operator|)
operator|&
literal|0x0f
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * read a byte from MAR register through lpt_data; the low nibble is  * read prior to the high one; end-of-read command is not issued; used  * for remote DMA in mode 4 + 5  */
end_comment

begin_comment
unit|static __inline u_char RdByte(struct rdp_softc *sc) { 	u_char hinib, lonib;  	outb(sc->baseaddr + lpt_data, RdAddr + MAR);
comment|/* cmd for low nibble */
end_comment

begin_comment
unit|lonib = (inb(sc->baseaddr + lpt_status)>> 3)& 0x0f; 	outb(sc->baseaddr + lpt_data, RdAddr + MAR + HNib); 	hinib = (inb(sc->baseaddr + lpt_status)<< 1)& 0xf0; 	return hinib + lonib; }
comment|/*  * read a byte from MAR register through lpt_data; the low nibble is  * read prior to the high one; end-of-read command is not issued; used  * for remote DMA in mode 6 + 7  */
end_comment

begin_comment
unit|static __inline u_char RdByte1(struct rdp_softc *sc) { 	u_char hinib, lonib;  	outb(sc->baseaddr + lpt_data, RdAddr + MAR);
comment|/* cmd for low nibble */
end_comment

begin_endif
unit|(void)inb(sc->baseaddr + lpt_status); 	lonib = (inb(sc->baseaddr + lpt_status)>> 3)& 0x0f; 	outb(sc->baseaddr + lpt_data, RdAddr + MAR + HNib); 	(void)inb(sc->baseaddr + lpt_status); 	hinib = (inb(sc->baseaddr + lpt_status)<< 1)& 0xf0; 	return hinib + lonib; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * read a byte from MAR register through lpt_control; the low nibble is  * read prior to the high one; end-of-read command is not issued; used  * for remote DMA in mode 0 + 1  */
end_comment

begin_function
specifier|static
name|__inline
name|u_char
name|RdByteA1
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|hinib
decl_stmt|,
name|lonib
decl_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_LNibRead
argument_list|)
expr_stmt|;
name|lonib
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_status
argument_list|)
operator|>>
literal|3
operator|)
operator|&
literal|0x0f
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_HNibRead
argument_list|)
expr_stmt|;
name|hinib
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_status
argument_list|)
operator|<<
literal|1
operator|)
operator|&
literal|0xf0
expr_stmt|;
return|return
name|hinib
operator|+
name|lonib
return|;
block|}
end_function

begin_comment
comment|/*  * read a byte from MAR register through lpt_control; the low nibble is  * read prior to the high one; end-of-read command is not issued; used  * for remote DMA in mode 2 + 3  */
end_comment

begin_function
specifier|static
name|__inline
name|u_char
name|RdByteA2
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|hinib
decl_stmt|,
name|lonib
decl_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_LNibRead
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_status
argument_list|)
expr_stmt|;
name|lonib
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_status
argument_list|)
operator|>>
literal|3
operator|)
operator|&
literal|0x0f
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_HNibRead
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_status
argument_list|)
expr_stmt|;
name|hinib
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_status
argument_list|)
operator|<<
literal|1
operator|)
operator|&
literal|0xf0
expr_stmt|;
return|return
name|hinib
operator|+
name|lonib
return|;
block|}
end_function

begin_comment
comment|/*  * End-of-read cmd  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|RdEnd
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|rreg
parameter_list|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|EOC
operator|+
name|rreg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a nibble to a register; end-of-write is issued.  * Used for general register write.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|WrNib
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|wreg
parameter_list|,
name|u_char
name|wdata
parameter_list|)
block|{
comment|/* prepare and write address */
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|EOC
operator|+
name|wreg
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|WrAddr
operator|+
name|wreg
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|WrAddr
operator|+
name|wreg
argument_list|)
expr_stmt|;
comment|/* prepare and write data */
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|WrAddr
operator|+
name|wdata
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|wdata
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|wdata
argument_list|)
expr_stmt|;
comment|/* end-of-write */
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|EOC
operator|+
name|wdata
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a byte to a register; end-of-write is issued.  * Used for general register write.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|WrByte
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|wreg
parameter_list|,
name|u_char
name|wdata
parameter_list|)
block|{
comment|/* prepare and write address */
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|EOC
operator|+
name|wreg
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|WrAddr
operator|+
name|wreg
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|WrAddr
operator|+
name|wreg
argument_list|)
expr_stmt|;
comment|/* prepare and write low nibble */
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|WrAddr
operator|+
operator|(
name|wdata
operator|&
literal|0x0F
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
operator|(
name|wdata
operator|&
literal|0x0F
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
operator|(
name|wdata
operator|&
literal|0x0F
operator|)
argument_list|)
expr_stmt|;
comment|/* prepare and write high nibble */
name|wdata
operator|>>=
literal|4
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|wdata
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|wdata
operator|+
name|HNib
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|wdata
operator|+
name|HNib
argument_list|)
expr_stmt|;
comment|/* end-of-write */
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|EOC
operator|+
name|wdata
operator|+
name|HNib
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the byte to DRAM via lpt_data;  * used for remote DMA write in mode 0 / 2 / 4  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|WrByteALToDRAM
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|val
parameter_list|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|val
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|MkHi
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the byte to DRAM via lpt_control;  * used for remote DMA write in mode 1 / 3 / 5  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|WrByteALToDRAMA
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|val
parameter_list|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|val
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_LNibRead
operator||
name|sc
operator|->
name|irqenbit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|val
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_HNibRead
operator||
name|sc
operator|->
name|irqenbit
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* they could be used for the RAM test */
end_comment

begin_comment
comment|/*  * Write the u_short to DRAM via lpt_data;  * used for remote DMA write in mode 0 / 2 / 4  */
end_comment

begin_comment
unit|static __inline void WrWordbxToDRAM(struct rdp_softc *sc, u_short val) {  	outb(sc->baseaddr + lpt_data, val& 0x0F); 	val>>= 4; 	outb(sc->baseaddr + lpt_data, (val& 0x0F) + HNib); 	val>>= 4; 	outb(sc->baseaddr + lpt_data, val& 0x0F); 	val>>= 4; 	outb(sc->baseaddr + lpt_data, val + HNib); }
comment|/*  * Write the u_short to DRAM via lpt_control;  * used for remote DMA write in mode 1 / 3 / 5  */
end_comment

begin_endif
unit|static __inline void WrWordbxToDRAMA(struct rdp_softc *sc, u_short val) {  	outb(sc->baseaddr + lpt_data, val& 0x0F); 	outb(sc->baseaddr + lpt_control, Ctrl_LNibRead | sc->irqenbit); 	val>>= 4; 	outb(sc->baseaddr + lpt_data, (val& 0x0F) + HNib); 	outb(sc->baseaddr + lpt_control, Ctrl_HNibRead | sc->irqenbit); 	val>>= 4; 	outb(sc->baseaddr + lpt_data, val& 0x0F); 	outb(sc->baseaddr + lpt_control, Ctrl_LNibRead | sc->irqenbit); 	val>>= 4; 	outb(sc->baseaddr + lpt_data, val + HNib); 	outb(sc->baseaddr + lpt_control, Ctrl_HNibRead | sc->irqenbit); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Determine if the device is present  *  *   on entry:  * 	a pointer to an isa_device struct  *   on exit:  *	0 if device not found  *	or # of i/o addresses used (if found)  */
end_comment

begin_function
specifier|static
name|int
name|rdp_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|isa_dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|isa_dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|rdp_softc
modifier|*
name|sc
init|=
operator|&
name|rdp_softc
index|[
name|unit
index|]
decl_stmt|;
name|u_char
name|b1
decl_stmt|,
name|b2
decl_stmt|;
name|intrmask_t
name|irqmap
index|[
literal|3
index|]
decl_stmt|;
name|u_char
name|sval
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|unit
operator|<
literal|0
operator|||
name|unit
operator|>=
name|NRDP
condition|)
return|return
literal|0
return|;
name|sc
operator|->
name|baseaddr
operator|=
name|isa_dev
operator|->
name|id_iobase
expr_stmt|;
if|if
condition|(
name|isa_dev
operator|->
name|id_flags
operator|&
literal|1
condition|)
name|sc
operator|->
name|eeprom
operator|=
name|EEPROM_74S288
expr_stmt|;
comment|/* else defaults to 93C46 */
if|if
condition|(
name|isa_dev
operator|->
name|id_flags
operator|&
literal|2
condition|)
name|sc
operator|->
name|slow
operator|=
literal|1
expr_stmt|;
comment|/* let R/WB = A/DB = CSB = high to be ready for next r/w cycle */
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* DIR = 0 for write mode, IRQEN=0, SLCT=INIT=AUTOFEED=STB=high */
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_SelData
argument_list|)
expr_stmt|;
comment|/* software reset */
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR1
operator|+
name|HNib
argument_list|,
name|MkHi
argument_list|(
name|CMR1_RST
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
comment|/* is EPLC alive? */
name|b1
operator|=
name|RdNib
argument_list|(
name|sc
argument_list|,
name|CMR1
argument_list|)
expr_stmt|;
name|RdEnd
argument_list|(
name|sc
argument_list|,
name|CMR1
argument_list|)
expr_stmt|;
name|b2
operator|=
name|RdNib
argument_list|(
name|sc
argument_list|,
name|CMR2
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
name|b2
operator||=
name|RdNib
argument_list|(
name|sc
argument_list|,
name|CMR2
operator|+
name|HNib
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|RdEnd
argument_list|(
name|sc
argument_list|,
name|CMR2
operator|+
name|HNib
argument_list|)
expr_stmt|;
comment|/* 	 * After the reset, we expect CMR1& 7 to be 1 (rx buffer empty), 	 * and CMR2& 0xf7 to be 0x20 (receive mode set to physical and 	 * broadcasts). 	 */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"rdp%d: CMR1 = %#x, CMR2 = %#x\n"
argument_list|,
name|unit
argument_list|,
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|b1
operator|&
operator|(
name|CMR1_BUFE
operator||
name|CMR1_IRQ
operator||
name|CMR1_TRA
operator|)
operator|)
operator|!=
name|CMR1_BUFE
operator|||
operator|(
name|b2
operator|&
operator|~
name|CMR2_IRQINV
operator|)
operator|!=
name|CMR2_AM_PB
condition|)
return|return
literal|0
return|;
comment|/* 	 * We have found something that could be a RTL 80[01]2, now 	 * see whether we can generate an interrupt. 	 */
name|disable_intr
argument_list|()
expr_stmt|;
comment|/* 	 * Test whether our configured IRQ is working. 	 * 	 * Set to no acception mode + IRQout, then enable RxE + TxE, 	 * then cause RBER (by advancing the read pointer although 	 * the read buffer is empty) to generate an interrupt. 	 */
name|WrByte
argument_list|(
name|sc
argument_list|,
name|CMR2
argument_list|,
name|CMR2_IRQOUT
argument_list|)
expr_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR1
operator|+
name|HNib
argument_list|,
name|MkHi
argument_list|(
name|CMR1_TE
operator||
name|CMR1_RE
argument_list|)
argument_list|)
expr_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR1
argument_list|,
name|CMR1_RDPAC
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|irqmap
index|[
literal|0
index|]
operator|=
name|isa_irq_pending
argument_list|()
expr_stmt|;
name|sval
index|[
literal|0
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_status
argument_list|)
expr_stmt|;
comment|/* allow IRQs to pass the parallel interface */
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_IRQEN
operator|+
name|Ctrl_SelData
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* generate interrupt */
name|WrNib
argument_list|(
name|sc
argument_list|,
name|IMR
operator|+
name|HNib
argument_list|,
name|MkHi
argument_list|(
name|ISR_RBER
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|irqmap
index|[
literal|1
index|]
operator|=
name|isa_irq_pending
argument_list|()
expr_stmt|;
name|sval
index|[
literal|1
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_status
argument_list|)
expr_stmt|;
comment|/* de-assert and disable IRQ */
name|WrNib
argument_list|(
name|sc
argument_list|,
name|IMR
operator|+
name|HNib
argument_list|,
name|MkHi
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_status
argument_list|)
expr_stmt|;
comment|/* might be necessary to 						 clear IRQ */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|irqmap
index|[
literal|2
index|]
operator|=
name|isa_irq_pending
argument_list|()
expr_stmt|;
name|sval
index|[
literal|2
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_status
argument_list|)
expr_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR1
operator|+
name|HNib
argument_list|,
name|MkHi
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_SelData
argument_list|)
expr_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR2
argument_list|,
name|CMR2_IRQINV
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"rdp%d: irq maps / lpt status "
literal|"%#x/%#x - %#x/%#x - %#x/%#x (id_irq %#x)\n"
argument_list|,
name|unit
argument_list|,
name|irqmap
index|[
literal|0
index|]
argument_list|,
name|sval
index|[
literal|0
index|]
argument_list|,
name|irqmap
index|[
literal|1
index|]
argument_list|,
name|sval
index|[
literal|1
index|]
argument_list|,
name|irqmap
index|[
literal|2
index|]
argument_list|,
name|sval
index|[
literal|2
index|]
argument_list|,
name|isa_dev
operator|->
name|id_irq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|irqmap
index|[
literal|1
index|]
operator|&
name|isa_dev
operator|->
name|id_irq
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"rdp%d: configured IRQ (%d) cannot be asserted "
literal|"by device"
argument_list|,
name|unit
argument_list|,
name|ffs
argument_list|(
name|isa_dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|irqmap
index|[
literal|1
index|]
condition|)
name|printf
argument_list|(
literal|" (probable IRQ: %d)"
argument_list|,
name|ffs
argument_list|(
name|irqmap
index|[
literal|1
index|]
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * XXX should do RAMtest here 	 */
switch|switch
condition|(
name|sc
operator|->
name|eeprom
condition|)
block|{
case|case
name|EEPROM_93C46
case|:
if|if
condition|(
name|rdp_gethwaddr_93c46
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"rdp%d: failed to find a valid hardware "
literal|"address in EEPROM\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|EEPROM_74S288
case|:
name|rdp_gethwaddr_74s288
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|lpt_control
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Install interface into kernel networking data structures  */
end_comment

begin_function
specifier|static
name|int
name|rdp_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|isa_dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|isa_dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|rdp_softc
modifier|*
name|sc
init|=
operator|&
name|rdp_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|isa_dev
operator|->
name|id_ointr
operator|=
name|rdpintr
expr_stmt|;
comment|/* 	 * Reset interface 	 */
name|rdp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifp
operator|->
name|if_name
condition|)
block|{
comment|/* 		 * Initialize ifnet structure 		 */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"rdp"
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|rdp_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|rdp_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|rdp_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|rdp_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
comment|/* 		 * Attach the interface 		 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Print additional info when attached 	 */
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"RealTek RTL%s pocket ethernet, EEPROM %s, %s mode\n"
argument_list|,
literal|"8002"
argument_list|,
comment|/* hook for 8012 */
name|sc
operator|->
name|eeprom
operator|==
name|EEPROM_93C46
condition|?
literal|"93C46"
else|:
literal|"74S288"
argument_list|,
name|sc
operator|->
name|slow
condition|?
literal|"slow"
else|:
literal|"fast"
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"address %6D\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Reset interface.  */
end_comment

begin_function
specifier|static
name|void
name|rdp_reset
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|rdp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Stop interface and re-initialize. 	 */
name|rdp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|rdp_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take interface offline.  */
end_comment

begin_function
specifier|static
name|void
name|rdp_stop
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|txbusy
operator|=
name|sc
operator|->
name|txbusy
operator|=
literal|0
expr_stmt|;
comment|/* disable printer interface interrupts */
name|sc
operator|->
name|irqenbit
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_SelData
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* reset the RTL 8002 */
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR1
operator|+
name|HNib
argument_list|,
name|MkHi
argument_list|(
name|CMR1_RST
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Device timeout/watchdog routine. Entered if the device neglects to  * generate an interrupt after a transmit has been started on it.  */
end_comment

begin_function
specifier|static
name|void
name|rdp_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rdp%d: device timeout\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|rdp_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize device.  */
end_comment

begin_function
specifier|static
name|void
name|rdp_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|rdp_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|u_char
name|reg
decl_stmt|;
comment|/* address not known */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_addrhead
argument_list|)
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* program ethernet ID into the chip */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|reg
operator|=
name|IDR0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
operator|,
name|reg
operator|++
control|)
name|WrByte
argument_list|(
name|sc
argument_list|,
name|reg
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* set accept mode */
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR2
operator|+
name|HNib
argument_list|,
name|MkHi
argument_list|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
name|CMR2_AM_ALL
else|:
name|CMR2_AM_PB
argument_list|)
argument_list|)
expr_stmt|;
comment|/* enable tx and rx */
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR1
operator|+
name|HNib
argument_list|,
name|MkHi
argument_list|(
name|CMR1_TE
operator||
name|CMR1_RE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allow interrupts to happen */
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR2
argument_list|,
name|CMR2_IRQOUT
operator||
name|CMR2_IRQINV
argument_list|)
expr_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|IMR
argument_list|,
name|ISR_TOK
operator||
name|ISR_TER
operator||
name|ISR_ROK
operator||
name|ISR_RER
argument_list|)
expr_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|IMR
operator|+
name|HNib
argument_list|,
name|MkHi
argument_list|(
name|ISR_RBER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allow IRQs to pass the parallel interface */
name|sc
operator|->
name|irqenbit
operator|=
name|Ctrl_IRQEN
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|sc
operator|->
name|irqenbit
operator|+
name|Ctrl_SelData
argument_list|)
expr_stmt|;
comment|/* clear all flags */
name|sc
operator|->
name|txbusy
operator|=
name|sc
operator|->
name|txbuffered
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set 'running' flag, and clear output active flag. 	 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* 	 * ...and attempt to start output 	 */
name|rdp_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  * We make two assumptions here:  *  1) that the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) that the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
end_comment

begin_function
specifier|static
name|void
name|rdp_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|rdp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
name|outloop
label|:
comment|/* 	 * See if there is room to put another packet in the buffer. 	 */
if|if
condition|(
name|sc
operator|->
name|txbuffered
condition|)
block|{
comment|/* 		 * No room. Indicate this to the outside world and exit. 		 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We are using the !OACTIVE flag to indicate to the outside 		 * world that we can accept an additional packet rather than 		 * that the transmitter is _actually_ active. Indeed, the 		 * transmitter may be active, but if we haven't filled all the 		 * buffers with data then we still want to accept more. 		 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
comment|/* 	 * Copy the mbuf chain into the transmit buffer 	 */
name|len
operator|=
name|rdp_write_mbufs
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|outloop
goto|;
comment|/* ensure minimal valid ethernet length */
name|len
operator|=
name|max
argument_list|(
name|len
argument_list|,
operator|(
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Actually start the transceiver.  Set a timeout in case the 	 * Tx interrupt never arrives. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|txbusy
condition|)
block|{
name|WrNib
argument_list|(
name|sc
argument_list|,
name|TBCR1
argument_list|,
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|WrByte
argument_list|(
name|sc
argument_list|,
name|TBCR0
argument_list|,
name|len
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR1
argument_list|,
name|CMR1_TRA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txbusy
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|txbuffered
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|txsize
operator|=
name|len
expr_stmt|;
block|}
comment|/* 	 * Tap off here if there is a bpf listener. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Loop back to the top to possibly buffer more packets 	 */
goto|goto
name|outloop
goto|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|rdp_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|IOCTL_CMD_T
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|rdp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * If the interface is marked up and stopped, then start it. 		 * If it is marked down and running, then stop it. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|rdp_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|rdp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
block|}
comment|/* 		 * Promiscuous flag may have changed, propagage this 		 * to the NIC. 		 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR2
operator|+
name|HNib
argument_list|,
name|MkHi
argument_list|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
name|CMR2_AM_ALL
else|:
name|CMR2_AM_PB
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 		 * Multicast list has changed; we don't support it. 		 */
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * External interrupt service routine.  */
end_comment

begin_function
specifier|static
name|void
name|rdpintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|rdp_softc
modifier|*
name|sc
init|=
name|rdp_softc
operator|+
name|unit
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|sc
decl_stmt|;
name|u_char
name|isr
decl_stmt|,
name|tsr
decl_stmt|,
name|rsr
decl_stmt|,
name|colls
decl_stmt|;
comment|/* disable interrupts, so SD3 can be routed to the pin */
name|sc
operator|->
name|irqenbit
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_SelData
argument_list|)
expr_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR2
argument_list|,
name|CMR2_IRQINV
argument_list|)
expr_stmt|;
comment|/* 	 * loop until there are no more new interrupts 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|isr
operator|=
name|RdNib
argument_list|(
name|sc
argument_list|,
name|ISR
argument_list|)
expr_stmt|;
name|isr
operator||=
name|RdNib
argument_list|(
name|sc
argument_list|,
name|ISR
operator|+
name|HNib
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|RdEnd
argument_list|(
name|sc
argument_list|,
name|ISR
operator|+
name|HNib
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|==
literal|0
condition|)
break|break;
if|#
directive|if
name|DEBUG
operator|&
literal|4
name|printf
argument_list|(
literal|"rdp%d: ISR = %#x\n"
argument_list|,
name|unit
argument_list|,
name|isr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Clear the pending interrupt bits. 		 */
name|WrNib
argument_list|(
name|sc
argument_list|,
name|ISR
argument_list|,
name|isr
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
if|if
condition|(
name|isr
operator|&
literal|0xf0
condition|)
name|WrNib
argument_list|(
name|sc
argument_list|,
name|ISR
operator|+
name|HNib
argument_list|,
name|MkHi
argument_list|(
name|isr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Handle transmitter interrupts. 		 */
if|if
condition|(
name|isr
operator|&
operator|(
name|ISR_TOK
operator||
name|ISR_TER
operator|)
condition|)
block|{
name|tsr
operator|=
name|RdNib
argument_list|(
name|sc
argument_list|,
name|TSR
argument_list|)
expr_stmt|;
name|RdEnd
argument_list|(
name|sc
argument_list|,
name|TSR
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|&
literal|4
if|if
condition|(
name|isr
operator|&
name|ISR_TER
condition|)
name|printf
argument_list|(
literal|"rdp%d: tsr %#x\n"
argument_list|,
name|unit
argument_list|,
name|tsr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tsr
operator|&
name|TSR_TABT
condition|)
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
else|else
comment|/* 				 * Update total number of successfully 				 * transmitted packets. 				 */
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
if|if
condition|(
name|tsr
operator|&
name|TSR_COL
condition|)
block|{
name|colls
operator|=
name|RdNib
argument_list|(
name|sc
argument_list|,
name|COLR
argument_list|)
expr_stmt|;
name|RdEnd
argument_list|(
name|sc
argument_list|,
name|COLR
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_collisions
operator|+=
name|colls
expr_stmt|;
block|}
comment|/* 			 * reset tx busy and output active flags 			 */
name|sc
operator|->
name|txbusy
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* 			 * If we had already queued up another packet, 			 * start sending it now. 			 */
if|if
condition|(
name|sc
operator|->
name|txbuffered
condition|)
block|{
name|WrNib
argument_list|(
name|sc
argument_list|,
name|TBCR1
argument_list|,
name|sc
operator|->
name|txsize
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|WrByte
argument_list|(
name|sc
argument_list|,
name|TBCR0
argument_list|,
name|sc
operator|->
name|txsize
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR1
argument_list|,
name|CMR1_TRA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txbusy
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|txbuffered
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * clear watchdog timer 				 */
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * Handle receiver interrupts 		 */
if|if
condition|(
name|isr
operator|&
operator|(
name|ISR_ROK
operator||
name|ISR_RER
operator||
name|ISR_RBER
operator|)
condition|)
block|{
name|rsr
operator|=
name|RdNib
argument_list|(
name|sc
argument_list|,
name|RSR
argument_list|)
expr_stmt|;
name|rsr
operator||=
name|RdNib
argument_list|(
name|sc
argument_list|,
name|RSR
operator|+
name|HNib
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|RdEnd
argument_list|(
name|sc
argument_list|,
name|RSR
operator|+
name|HNib
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|&
literal|4
if|if
condition|(
name|isr
operator|&
operator|(
name|ISR_RER
operator||
name|ISR_RBER
operator|)
condition|)
name|printf
argument_list|(
literal|"rdp%d: rsr %#x\n"
argument_list|,
name|unit
argument_list|,
name|rsr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rsr
operator|&
operator|(
name|RSR_PUN
operator||
name|RSR_POV
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"rdp%d: rsr %#x, resetting\n"
argument_list|,
name|unit
argument_list|,
name|rsr
argument_list|)
expr_stmt|;
name|rdp_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rsr
operator|&
name|RSR_BUFO
condition|)
comment|/* 				 * CRC and FA errors are recorded in 				 * rdp_rint() on a per-packet basis 				 */
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|isr
operator|&
operator|(
name|ISR_ROK
operator||
name|ISR_RER
operator|)
condition|)
name|rdp_rint
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If it looks like the transmitter can take more data, 		 * attempt to start output on the interface. This is done 		 * after handling the receiver to give the receiver priority. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
name|rdp_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* re-enable interrupts */
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR2
argument_list|,
name|CMR2_IRQOUT
operator||
name|CMR2_IRQINV
argument_list|)
expr_stmt|;
name|sc
operator|->
name|irqenbit
operator|=
name|Ctrl_IRQEN
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_SelData
operator|+
name|sc
operator|->
name|irqenbit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|rdp_rint
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|rdphdr
name|rh
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|u_char
modifier|*
name|packet_ptr
decl_stmt|,
name|b
decl_stmt|,
name|status
decl_stmt|;
name|int
name|excessive_bad_pkts
init|=
literal|0
decl_stmt|;
comment|/* 	 * Fetch the packets from the NIC's buffer. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|b
operator|=
name|RdNib
argument_list|(
name|sc
argument_list|,
name|CMR1
argument_list|)
expr_stmt|;
name|RdEnd
argument_list|(
name|sc
argument_list|,
name|CMR1
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|&
name|CMR1_BUFE
condition|)
comment|/* no more packets */
break|break;
comment|/* first, obtain the buffer header */
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|MAR
operator|+
name|EOC
argument_list|)
expr_stmt|;
comment|/* prepare addr */
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_LNibRead
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|MAR
operator|+
name|RdAddr
operator|+
name|HNib
argument_list|)
expr_stmt|;
name|packet_ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rh
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|slow
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|rh
condition|;
name|i
operator|++
operator|,
name|packet_ptr
operator|++
control|)
operator|*
name|packet_ptr
operator|=
name|RdByteA2
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|rh
condition|;
name|i
operator|++
operator|,
name|packet_ptr
operator|++
control|)
operator|*
name|packet_ptr
operator|=
name|RdByteA1
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RdEnd
argument_list|(
name|sc
argument_list|,
name|MAR
operator|+
name|HNib
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_SelData
argument_list|)
expr_stmt|;
name|len
operator|=
name|rh
operator|.
name|pktlen
operator|-
name|ETHER_CRC_LEN
expr_stmt|;
name|status
operator|=
name|rh
operator|.
name|status
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|RSR_ROK
operator||
name|RSR_CRC
operator||
name|RSR_FA
operator|)
operator|)
operator|!=
name|RSR_ROK
operator|||
name|len
operator|>
operator|(
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
operator|)
operator|||
name|len
operator|<
operator|(
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|)
operator|||
name|len
operator|>
name|MCLBYTES
condition|)
block|{
if|#
directive|if
name|DEBUG
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bad packet in buffer, "
literal|"len %d, status %#x\n"
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
operator|(
name|int
operator|)
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
comment|/* rx jump packet */
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR1
argument_list|,
name|CMR1_RDPAC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|excessive_bad_pkts
operator|>
literal|5
condition|)
block|{
comment|/* 				 * the chip seems to be stuck, we are 				 * probably seeing the same bad packet 				 * over and over again 				 */
if|#
directive|if
name|DEBUG
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"resetting due to an "
literal|"excessive number of bad packets\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rdp_reset
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
continue|continue;
block|}
comment|/* 		 * Go get packet. 		 */
name|excessive_bad_pkts
operator|=
literal|0
expr_stmt|;
name|rdp_get_packet
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Retreive packet from NIC memory and send to the next level up via  * ether_input().  */
end_comment

begin_function
specifier|static
name|void
name|rdp_get_packet
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_char
modifier|*
name|packet_ptr
decl_stmt|;
name|size_t
name|s
decl_stmt|;
comment|/* Allocate a header mbuf */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* 	 * We always put the received packet in a single buffer - 	 * either with just an mbuf header or in a cluster attached 	 * to the header. The +2 is to compensate for the alignment 	 * fixup below. 	 */
if|if
condition|(
operator|(
name|len
operator|+
literal|2
operator|)
operator|>
name|MHLEN
condition|)
block|{
comment|/* Attach an mbuf cluster */
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
comment|/* Insist on getting a cluster */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * The +2 is to longword align the start of the real packet. 	 * This is important for NFS. 	 */
name|m
operator|->
name|m_data
operator|+=
literal|2
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Get packet, including link layer address, from interface. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_LNibRead
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|RdAddr
operator|+
name|MAR
argument_list|)
expr_stmt|;
name|packet_ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|eh
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|slow
condition|)
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|len
condition|;
name|s
operator|++
operator|,
name|packet_ptr
operator|++
control|)
operator|*
name|packet_ptr
operator|=
name|RdByteA2
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|len
condition|;
name|s
operator|++
operator|,
name|packet_ptr
operator|++
control|)
operator|*
name|packet_ptr
operator|=
name|RdByteA1
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|RdEnd
argument_list|(
name|sc
argument_list|,
name|MAR
operator|+
name|HNib
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_SelData
argument_list|)
expr_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR1
argument_list|,
name|CMR1_RDPAC
argument_list|)
expr_stmt|;
comment|/* 	 * Remove link layer address. 	 */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write an mbuf chain to the NIC's tx buffer.  */
end_comment

begin_function
specifier|static
name|u_short
name|rdp_write_mbufs
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|u_short
name|total_len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|u_char
modifier|*
name|dp
decl_stmt|,
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* First, count up the total number of bytes to copy */
for|for
control|(
name|total_len
operator|=
literal|0
operator|,
name|mp
operator|=
name|m
init|;
name|mp
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
name|total_len
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|total_len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|MAR
operator||
name|EOC
argument_list|)
expr_stmt|;
comment|/* 	 * Transfer the mbuf chain to the NIC memory. 	 */
if|if
condition|(
name|sc
operator|->
name|slow
condition|)
block|{
comment|/* writing the first byte is complicated */
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_LNibRead
operator||
name|sc
operator|->
name|irqenbit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|MAR
operator||
name|WrAddr
argument_list|)
expr_stmt|;
name|b
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|m
operator|->
name|m_data
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
operator|(
name|b
operator|&
literal|0x0f
operator|)
operator||
literal|0x40
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|b
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|b
operator|>>
literal|4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_HNibRead
operator||
name|sc
operator|->
name|irqenbit
argument_list|)
expr_stmt|;
comment|/* advance the mbuf pointer */
name|mp
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_len
operator|--
expr_stmt|;
name|m
operator|->
name|m_data
operator|++
expr_stmt|;
comment|/* write the remaining bytes */
while|while
condition|(
name|m
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|m
operator|->
name|m_data
init|;
name|i
operator|<
name|m
operator|->
name|m_len
condition|;
name|i
operator|++
operator|,
name|dp
operator|++
control|)
name|WrByteALToDRAMA
argument_list|(
name|sc
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* 		 * restore old mbuf in case we have to hand it off to 		 * BPF again 		 */
name|m
operator|=
name|mp
expr_stmt|;
name|m
operator|->
name|m_len
operator|++
expr_stmt|;
name|m
operator|->
name|m_data
operator|--
expr_stmt|;
comment|/* the RTL 8002 requires an even byte-count remote DMA */
if|if
condition|(
name|total_len
operator|&
literal|1
condition|)
name|WrByteALToDRAMA
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
name|MAR
operator||
name|WrAddr
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|m
operator|->
name|m_data
init|;
name|i
operator|<
name|m
operator|->
name|m_len
condition|;
name|i
operator|++
operator|,
name|dp
operator|++
control|)
name|WrByteALToDRAM
argument_list|(
name|sc
argument_list|,
operator|*
name|dp
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* the RTL 8002 requires an even byte-count remote DMA */
if|if
condition|(
name|total_len
operator|&
literal|1
condition|)
name|WrByteALToDRAM
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_data
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|baseaddr
operator|+
name|lpt_control
argument_list|,
name|Ctrl_HNibRead
operator||
name|Ctrl_SelData
operator||
name|sc
operator|->
name|irqenbit
argument_list|)
expr_stmt|;
return|return
name|total_len
return|;
block|}
end_function

begin_comment
comment|/*  * Read the designated ethernet hardware address out of a 93C46  * (serial) EEPROM.  * Note that the 93C46 uses 16-bit words in big-endian notation.  */
end_comment

begin_function
specifier|static
name|int
name|rdp_gethwaddr_93c46
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|etheraddr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|magic
decl_stmt|;
name|size_t
name|j
init|=
literal|0
decl_stmt|;
name|u_short
name|w
decl_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR2
argument_list|,
name|CMR2_PAGE
operator||
name|CMR2_IRQINV
argument_list|)
expr_stmt|;
comment|/* select page 1 */
comment|/* 	 * The original RealTek packet driver had the ethernet address 	 * starting at EEPROM address 0.  Other vendors seem to have 	 * gone `creative' here -- while they didn't do anything else 	 * than changing a few strings in the entire driver, compared 	 * to the RealTek version, they also moved out the ethernet 	 * address to a different location in the EEPROM, so the 	 * original RealTek driver won't work correctly with them, and 	 * vice versa.  Sounds pretty cool, eh?  $@%&! 	 * 	 * Anyway, we walk through the EEPROM, until we find some 	 * allowable value based upon our table of IEEE OUI assignments. 	 */
for|for
control|(
name|i
operator|=
name|magic
operator|=
literal|0
init|;
name|magic
operator|<
literal|3
operator|&&
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
comment|/* read cmd (+ 6 bit address) */
name|rdp_93c46_cmd
argument_list|(
name|sc
argument_list|,
literal|0x180
operator|+
name|i
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|w
operator|=
name|rdp_93c46_read
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|magic
condition|)
block|{
case|case
literal|0
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
sizeof|sizeof
name|allowed_ouis
operator|/
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|w
operator|==
name|allowed_ouis
index|[
name|j
index|]
condition|)
block|{
name|etheraddr
index|[
literal|0
index|]
operator|=
operator|(
name|w
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|etheraddr
index|[
literal|1
index|]
operator|=
name|w
operator|&
literal|0xff
expr_stmt|;
name|magic
operator|++
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|1
case|:
comment|/* 			 * If the first two bytes have been 00:00, we 			 * discard the match iff the next two bytes 			 * are also 00:00, so we won't get fooled by 			 * an EEPROM that has been filled with zeros. 			 * This in theory would disallow 64 K of legal 			 * addresses assigned to Xerox, but it's 			 * almost certain that those addresses haven't 			 * been used for RTL80[01]2 chips anyway. 			 */
if|if
condition|(
operator|(
name|etheraddr
index|[
literal|0
index|]
operator||
name|etheraddr
index|[
literal|1
index|]
operator|)
operator|==
literal|0
operator|&&
name|w
operator|==
literal|0
condition|)
block|{
name|magic
operator|--
expr_stmt|;
break|break;
block|}
name|etheraddr
index|[
literal|2
index|]
operator|=
operator|(
name|w
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|etheraddr
index|[
literal|3
index|]
operator|=
name|w
operator|&
literal|0xff
expr_stmt|;
name|magic
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|etheraddr
index|[
literal|4
index|]
operator|=
operator|(
name|w
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|etheraddr
index|[
literal|5
index|]
operator|=
name|w
operator|&
literal|0xff
expr_stmt|;
name|magic
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR2
argument_list|,
name|CMR2_IRQINV
argument_list|)
expr_stmt|;
comment|/* back to page 0 */
return|return
name|magic
operator|==
literal|3
return|;
block|}
end_function

begin_comment
comment|/*  * Read the designated ethernet hardware address out of a 74S288  * EEPROM.  *  * This is untested, since i haven't seen any adapter actually using  * a 74S288.  In the RTL 8012, only the serial EEPROM (94C46) is  * supported anymore.  */
end_comment

begin_function
specifier|static
name|void
name|rdp_gethwaddr_74s288
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|etheraddr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|b
decl_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR2
argument_list|,
name|CMR2_PAGE
operator||
name|CMR2_IRQINV
argument_list|)
expr_stmt|;
comment|/* select page 1 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|WrNib
argument_list|(
name|sc
argument_list|,
name|PCMR
argument_list|,
name|i
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* lower 4 bit of addr */
name|WrNib
argument_list|(
name|sc
argument_list|,
name|PCMR
operator|+
name|HNib
argument_list|,
name|HNib
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* upper 2 bit addr + /CS */
name|WrNib
argument_list|(
name|sc
argument_list|,
name|PCMR
operator|+
name|HNib
argument_list|,
name|HNib
argument_list|)
expr_stmt|;
comment|/* latch data now */
name|b
operator|=
name|RdNib
argument_list|(
name|sc
argument_list|,
name|PDR
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
name|b
operator||=
operator|(
name|RdNib
argument_list|(
name|sc
argument_list|,
name|PDR
operator|+
name|HNib
argument_list|)
operator|&
literal|0x0f
operator|)
operator|<<
literal|4
expr_stmt|;
name|etheraddr
index|[
name|i
index|]
operator|=
name|b
expr_stmt|;
block|}
name|RdEnd
argument_list|(
name|sc
argument_list|,
name|PDR
operator|+
name|HNib
argument_list|)
expr_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|CMR2
argument_list|,
name|CMR2_IRQINV
argument_list|)
expr_stmt|;
comment|/* reselect page 0 */
block|}
end_function

begin_comment
comment|/*  * Send nbits of data (starting with MSB) out to the 93c46 as a  * command.  Assumes register page 1 has already been selected.  */
end_comment

begin_function
specifier|static
name|void
name|rdp_93c46_cmd
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|data
parameter_list|,
name|unsigned
name|nbits
parameter_list|)
block|{
name|u_short
name|mask
init|=
literal|1
operator|<<
operator|(
name|nbits
operator|-
literal|1
operator|)
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|u_char
name|b
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|&
literal|2
name|printf
argument_list|(
literal|"rdp_93c46_cmd(): "
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbits
condition|;
name|i
operator|++
operator|,
name|mask
operator|>>=
literal|1
control|)
block|{
name|b
operator|=
name|HNib
operator|+
name|PCMR_SK
operator|+
name|PCMR_CS
expr_stmt|;
if|if
condition|(
name|data
operator|&
name|mask
condition|)
name|b
operator|+=
name|PCMR_DO
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|&
literal|2
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|b
operator|&
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|WrNib
argument_list|(
name|sc
argument_list|,
name|PCMR
operator|+
name|HNib
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|PCMR
operator|+
name|HNib
argument_list|,
name|b
operator|&
operator|~
name|PCMR_SK
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|&
literal|2
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Read one word of data from the 93c46.  Actually, we have to read  * 17 bits, and discard the very first bit.  Assumes register page 1  * to be selected as well.  */
end_comment

begin_function
specifier|static
name|u_short
name|rdp_93c46_read
parameter_list|(
name|struct
name|rdp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_short
name|data
init|=
literal|0
decl_stmt|;
name|u_char
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|DEBUG
operator|&
literal|2
name|printf
argument_list|(
literal|"rdp_93c46_read(): "
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|17
condition|;
name|i
operator|++
control|)
block|{
name|WrNib
argument_list|(
name|sc
argument_list|,
name|PCMR
operator|+
name|HNib
argument_list|,
name|PCMR_SK
operator|+
name|PCMR_CS
operator|+
name|HNib
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|WrNib
argument_list|(
name|sc
argument_list|,
name|PCMR
operator|+
name|HNib
argument_list|,
name|PCMR_CS
operator|+
name|HNib
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|b
operator|=
name|RdNib
argument_list|(
name|sc
argument_list|,
name|PDR
argument_list|)
expr_stmt|;
name|data
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|b
operator|&
literal|1
condition|)
name|data
operator||=
literal|1
expr_stmt|;
if|#
directive|if
name|DEBUG
operator|&
literal|2
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|b
operator|&
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RdEnd
argument_list|(
name|sc
argument_list|,
name|PDR
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
operator|&
literal|2
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* end of cycle */
name|WrNib
argument_list|(
name|sc
argument_list|,
name|PCMR
operator|+
name|HNib
argument_list|,
name|PCMR_SK
operator|+
name|HNib
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

end_unit

