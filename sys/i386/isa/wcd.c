begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * IDE CD-ROM driver for FreeBSD.  * Supports ATAPI-compatible drives.  *  * Copyright (C) 1995 Cronyx Ltd.  * Author Serge Vakulenko,<vak@cronyx.ru>  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations permission to use  * or modify this software as long as this message is kept with the software,  * all derivative works or modified versions.  *  * From: Version 1.9, Mon Oct  9 20:27:42 MSK 1995  * $Id: wcd.c,v 1.46 1997/10/29 22:11:00 sos Exp $  */
end_comment

begin_include
include|#
directive|include
file|"wdc.h"
end_include

begin_include
include|#
directive|include
file|"wcd.h"
end_include

begin_include
include|#
directive|include
file|"opt_atapi.h"
end_include

begin_if
if|#
directive|if
name|NWCD
operator|>
literal|0
operator|&&
name|NWDC
operator|>
literal|0
operator|&&
name|defined
argument_list|(
name|ATAPI
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<i386/isa/atapi.h>
end_include

begin_decl_stmt
specifier|static
name|d_open_t
name|wcdropen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|wcdbopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|wcdrclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|wcdbclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|wcdioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|wcdstrategy
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|69
end_define

begin_define
define|#
directive|define
name|BDEV_MAJOR
value|19
end_define

begin_decl_stmt
specifier|extern
name|struct
name|cdevsw
name|wcd_cdevsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bdevsw
name|wcd_bdevsw
init|=
block|{
name|wcdbopen
block|,
name|wcdbclose
block|,
name|wcdstrategy
block|,
name|wcdioctl
block|,
comment|/*19*/
name|nodump
block|,
name|nopsize
block|,
literal|0
block|,
literal|"wcd"
block|,
operator|&
name|wcd_cdevsw
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|wcd_cdevsw
init|=
block|{
name|wcdropen
block|,
name|wcdrclose
block|,
name|rawread
block|,
name|nowrite
block|,
comment|/*69*/
name|wcdioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
comment|/* atapi */
name|seltrue
block|,
name|nommap
block|,
name|wcdstrategy
block|,
literal|"wcd"
block|,
operator|&
name|wcd_bdevsw
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ATAPI_STATIC
end_ifndef

begin_function_decl
specifier|static
endif|#
directive|endif
name|int
name|wcdattach
parameter_list|(
name|struct
name|atapi
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|atapi_params
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NUNIT
value|16
end_define

begin_comment
comment|/* Max. number of devices */
end_comment

begin_define
define|#
directive|define
name|SECSIZE
value|2048
end_define

begin_comment
comment|/* CD-ROM sector size in bytes */
end_comment

begin_define
define|#
directive|define
name|F_BOPEN
value|0x0001
end_define

begin_comment
comment|/* The block device is opened */
end_comment

begin_define
define|#
directive|define
name|F_MEDIA_CHANGED
value|0x0002
end_define

begin_comment
comment|/* The media have changed since open */
end_comment

begin_define
define|#
directive|define
name|F_DEBUG
value|0x0004
end_define

begin_comment
comment|/* Print debug info */
end_comment

begin_define
define|#
directive|define
name|F_LOCKED
value|0x0008
end_define

begin_comment
comment|/* This unit is locked (or should be) */
end_comment

begin_comment
comment|/*  * Disc table of contents.  */
end_comment

begin_define
define|#
directive|define
name|MAXTRK
value|99
end_define

begin_struct
struct|struct
name|toc
block|{
name|struct
name|ioc_toc_header
name|hdr
decl_stmt|;
name|struct
name|cd_toc_entry
name|tab
index|[
name|MAXTRK
operator|+
literal|1
index|]
decl_stmt|;
comment|/* One extra for the leadout */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Volume size info.  */
end_comment

begin_struct
struct|struct
name|volinfo
block|{
name|u_long
name|volsize
decl_stmt|;
comment|/* Volume size in blocks */
name|u_long
name|blksize
decl_stmt|;
comment|/* Block size in bytes */
block|}
name|info
struct|;
end_struct

begin_comment
comment|/*  * Current subchannel status.  */
end_comment

begin_struct
struct|struct
name|subchan
block|{
name|u_char
name|void0
decl_stmt|;
name|u_char
name|audio_status
decl_stmt|;
name|u_short
name|data_length
decl_stmt|;
name|u_char
name|data_format
decl_stmt|;
name|u_char
name|control
decl_stmt|;
name|u_char
name|track
decl_stmt|;
name|u_char
name|indx
decl_stmt|;
name|u_long
name|abslba
decl_stmt|;
name|u_long
name|rellba
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Audio Control Parameters Page  */
end_comment

begin_struct
struct|struct
name|audiopage
block|{
comment|/* Mode data header */
name|u_short
name|data_length
decl_stmt|;
name|u_char
name|medium_type
decl_stmt|;
name|u_char
name|reserved1
index|[
literal|5
index|]
decl_stmt|;
comment|/* Audio control page */
name|u_char
name|page_code
decl_stmt|;
define|#
directive|define
name|AUDIO_PAGE
value|0x0e
define|#
directive|define
name|AUDIO_PAGE_MASK
value|0x4e
comment|/* changeable values */
name|u_char
name|param_len
decl_stmt|;
name|u_char
name|flags
decl_stmt|;
define|#
directive|define
name|CD_PA_SOTC
value|0x02
comment|/* mandatory */
define|#
directive|define
name|CD_PA_IMMED
value|0x04
comment|/* always 1 */
name|u_char
name|reserved3
index|[
literal|3
index|]
decl_stmt|;
name|u_short
name|lb_per_sec
decl_stmt|;
struct|struct
name|port_control
block|{
name|u_char
name|channels
range|:
literal|4
decl_stmt|;
define|#
directive|define
name|CHANNEL_0
value|1
comment|/* mandatory */
define|#
directive|define
name|CHANNEL_1
value|2
comment|/* mandatory */
define|#
directive|define
name|CHANNEL_2
value|4
comment|/* optional */
define|#
directive|define
name|CHANNEL_3
value|8
comment|/* optional */
name|u_char
name|volume
decl_stmt|;
block|}
name|port
index|[
literal|4
index|]
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * CD-ROM Capabilities and Mechanical Status Page  */
end_comment

begin_struct
struct|struct
name|cappage
block|{
comment|/* Mode data header */
name|u_short
name|data_length
decl_stmt|;
name|u_char
name|medium_type
decl_stmt|;
define|#
directive|define
name|MDT_UNKNOWN
value|0x00
define|#
directive|define
name|MDT_DATA_120
value|0x01
define|#
directive|define
name|MDT_AUDIO_120
value|0x02
define|#
directive|define
name|MDT_COMB_120
value|0x03
define|#
directive|define
name|MDT_PHOTO_120
value|0x04
define|#
directive|define
name|MDT_DATA_80
value|0x05
define|#
directive|define
name|MDT_AUDIO_80
value|0x06
define|#
directive|define
name|MDT_COMB_80
value|0x07
define|#
directive|define
name|MDT_PHOTO_80
value|0x08
define|#
directive|define
name|MDT_NO_DISC
value|0x70
define|#
directive|define
name|MDT_DOOR_OPEN
value|0x71
define|#
directive|define
name|MDT_FMT_ERROR
value|0x72
name|u_char
name|reserved1
index|[
literal|5
index|]
decl_stmt|;
comment|/* Capabilities page */
name|u_char
name|page_code
decl_stmt|;
define|#
directive|define
name|CAP_PAGE
value|0x2a
name|u_char
name|param_len
decl_stmt|;
name|u_char
name|reserved2
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|audio_play
range|:
literal|1
decl_stmt|;
comment|/* audio play supported */
name|u_char
name|composite
range|:
literal|1
decl_stmt|;
comment|/* composite audio/video supported */
name|u_char
name|dport1
range|:
literal|1
decl_stmt|;
comment|/* digital audio on port 1 */
name|u_char
name|dport2
range|:
literal|1
decl_stmt|;
comment|/* digital audio on port 2 */
name|u_char
name|mode2_form1
range|:
literal|1
decl_stmt|;
comment|/* mode 2 form 1 (XA) read */
name|u_char
name|mode2_form2
range|:
literal|1
decl_stmt|;
comment|/* mode 2 form 2 format */
name|u_char
name|multisession
range|:
literal|1
decl_stmt|;
comment|/* multi-session photo-CD */
name|u_char
label|:
literal|1
expr_stmt|;
name|u_char
name|cd_da
range|:
literal|1
decl_stmt|;
comment|/* audio-CD read supported */
name|u_char
name|cd_da_stream
range|:
literal|1
decl_stmt|;
comment|/* CD-DA streaming */
name|u_char
name|rw
range|:
literal|1
decl_stmt|;
comment|/* combined R-W subchannels */
name|u_char
name|rw_corr
range|:
literal|1
decl_stmt|;
comment|/* R-W subchannel data corrected */
name|u_char
name|c2
range|:
literal|1
decl_stmt|;
comment|/* C2 error pointers supported */
name|u_char
name|isrc
range|:
literal|1
decl_stmt|;
comment|/* can return the ISRC info */
name|u_char
name|upc
range|:
literal|1
decl_stmt|;
comment|/* can return the catalog number UPC */
name|u_char
label|:
literal|1
expr_stmt|;
name|u_char
name|lock
range|:
literal|1
decl_stmt|;
comment|/* could be locked */
name|u_char
name|locked
range|:
literal|1
decl_stmt|;
comment|/* current lock state */
name|u_char
name|prevent
range|:
literal|1
decl_stmt|;
comment|/* prevent jumper installed */
name|u_char
name|eject
range|:
literal|1
decl_stmt|;
comment|/* can eject */
name|u_char
label|:
literal|1
expr_stmt|;
name|u_char
name|mech
range|:
literal|3
decl_stmt|;
comment|/* loading mechanism type */
define|#
directive|define
name|MECH_CADDY
value|0
define|#
directive|define
name|MECH_TRAY
value|1
define|#
directive|define
name|MECH_POPUP
value|2
define|#
directive|define
name|MECH_CHANGER
value|4
define|#
directive|define
name|MECH_CARTRIDGE
value|5
name|u_char
name|sep_vol
range|:
literal|1
decl_stmt|;
comment|/* independent volume of channels */
name|u_char
name|sep_mute
range|:
literal|1
decl_stmt|;
comment|/* independent mute of channels */
name|u_char
label|:
literal|6
expr_stmt|;
name|u_short
name|max_speed
decl_stmt|;
comment|/* max raw data rate in bytes/1000 */
name|u_short
name|max_vol_levels
decl_stmt|;
comment|/* number of discrete volume levels */
name|u_short
name|buf_size
decl_stmt|;
comment|/* internal buffer size in bytes/1024 */
name|u_short
name|cur_speed
decl_stmt|;
comment|/* current data rate in bytes/1000  */
comment|/* Digital drive output format description (optional?) */
name|u_char
name|reserved3
decl_stmt|;
name|u_char
name|bckf
range|:
literal|1
decl_stmt|;
comment|/* data valid on failing edge of BCK */
name|u_char
name|rch
range|:
literal|1
decl_stmt|;
comment|/* high LRCK indicates left channel */
name|u_char
name|lsbf
range|:
literal|1
decl_stmt|;
comment|/* set if LSB first */
name|u_char
name|dlen
range|:
literal|2
decl_stmt|;
define|#
directive|define
name|DLEN_32
value|0
comment|/* 32 BCKs */
define|#
directive|define
name|DLEN_16
value|1
comment|/* 16 BCKs */
define|#
directive|define
name|DLEN_24
value|2
comment|/* 24 BCKs */
define|#
directive|define
name|DLEN_24_I2S
value|3
comment|/* 24 BCKs (I2S) */
name|u_char
label|:
literal|3
expr_stmt|;
name|u_char
name|reserved4
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * CDROM changer mechanism status structure  */
end_comment

begin_struct
struct|struct
name|changer
block|{
name|u_char
name|current_slot
range|:
literal|5
decl_stmt|;
comment|/* active changer slot */
name|u_char
name|mech_state
range|:
literal|2
decl_stmt|;
comment|/* current changer state */
define|#
directive|define
name|CH_READY
value|0
define|#
directive|define
name|CH_LOADING
value|1
define|#
directive|define
name|CH_UNLOADING
value|2
define|#
directive|define
name|CH_INITIALIZING
value|3
name|u_char
name|fault
range|:
literal|1
decl_stmt|;
comment|/* fault in last operation */
name|u_char
name|reserved0
range|:
literal|5
decl_stmt|;
name|u_char
name|cd_state
range|:
literal|3
decl_stmt|;
comment|/* current mechanism state */
define|#
directive|define
name|CD_IDLE
value|0
define|#
directive|define
name|CD_AUDIO_ACTIVE
value|1
define|#
directive|define
name|CD_AUDIO_SCAN
value|2
define|#
directive|define
name|CD_HOST_ACTIVE
value|3
define|#
directive|define
name|CD_NO_STATE
value|7
name|u_char
name|current_lba
index|[
literal|3
index|]
decl_stmt|;
comment|/* current LBA */
name|u_char
name|slots
decl_stmt|;
comment|/* number of available slots */
name|u_short
name|table_length
decl_stmt|;
comment|/* slot table length */
struct|struct
block|{
name|u_char
name|changed
range|:
literal|1
decl_stmt|;
comment|/* media has changed in this slot */
name|u_char
name|unused
range|:
literal|6
decl_stmt|;
name|u_char
name|present
range|:
literal|1
decl_stmt|;
comment|/* slot has a CD present */
name|u_char
name|reserved0
decl_stmt|;
name|u_char
name|reserved1
decl_stmt|;
name|u_char
name|reserved2
decl_stmt|;
block|}
name|slot
index|[
literal|32
index|]
struct|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|wcd
block|{
name|struct
name|atapi
modifier|*
name|ata
decl_stmt|;
comment|/* Controller structure */
name|int
name|unit
decl_stmt|;
comment|/* IDE bus drive unit */
name|int
name|lun
decl_stmt|;
comment|/* Logical device unit */
name|int
name|flags
decl_stmt|;
comment|/* Device state flags */
name|int
name|refcnt
decl_stmt|;
comment|/* The number of raw opens */
name|struct
name|buf_queue_head
name|buf_queue
decl_stmt|;
comment|/* Queue of i/o requests */
name|struct
name|atapi_params
modifier|*
name|param
decl_stmt|;
comment|/* Drive parameters table */
name|struct
name|toc
name|toc
decl_stmt|;
comment|/* Table of disc contents */
name|struct
name|volinfo
name|info
decl_stmt|;
comment|/* Volume size info */
name|struct
name|audiopage
name|au
decl_stmt|;
comment|/* Audio page info */
name|struct
name|cappage
name|cap
decl_stmt|;
comment|/* Capabilities page info */
name|struct
name|audiopage
name|aumask
decl_stmt|;
comment|/* Audio page mask */
name|struct
name|subchan
name|subchan
decl_stmt|;
comment|/* Subchannel info */
name|char
name|description
index|[
literal|80
index|]
decl_stmt|;
comment|/* Device description */
name|struct
name|changer
modifier|*
name|changer_info
decl_stmt|;
comment|/* changer info */
name|int
name|slot
decl_stmt|;
comment|/* this lun's slot number */
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|ra_devfs_token
decl_stmt|;
name|void
modifier|*
name|rc_devfs_token
decl_stmt|;
name|void
modifier|*
name|a_devfs_token
decl_stmt|;
name|void
modifier|*
name|c_devfs_token
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|wcd
modifier|*
name|wcdtab
index|[
name|NUNIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Drive info by unit number */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wcdnlun
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of configured drives */
end_comment

begin_function_decl
specifier|static
name|struct
name|wcd
modifier|*
name|wcd_init_lun
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|int
name|unit
parameter_list|,
name|struct
name|atapi_params
modifier|*
name|ap
parameter_list|,
name|int
name|lun
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wcd_start
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wcd_done
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|resid
parameter_list|,
name|struct
name|atapires
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wcd_error
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|struct
name|atapires
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wcd_read_toc
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wcd_request_wait
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|u_char
name|a1
parameter_list|,
name|u_char
name|a2
parameter_list|,
name|u_char
name|a3
parameter_list|,
name|u_char
name|a4
parameter_list|,
name|u_char
name|a5
parameter_list|,
name|u_char
name|a6
parameter_list|,
name|u_char
name|a7
parameter_list|,
name|u_char
name|a8
parameter_list|,
name|u_char
name|a9
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wcd_describe
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wcd_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|rawflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wcd_setchan
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|u_char
name|c0
parameter_list|,
name|u_char
name|c1
parameter_list|,
name|u_char
name|c2
parameter_list|,
name|u_char
name|c3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wcd_eject
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|int
name|closeit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wcd_select_slot
parameter_list|(
name|struct
name|wcd
modifier|*
name|cdp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Dump the array in hexadecimal format for debugging purposes.  */
end_comment

begin_function
specifier|static
name|void
name|wcd_dump
parameter_list|(
name|int
name|lun
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_char
modifier|*
name|p
init|=
name|data
decl_stmt|;
name|printf
argument_list|(
literal|"wcd%d: %s %x"
argument_list|,
name|lun
argument_list|,
name|label
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"-%x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|wcd
modifier|*
name|wcd_init_lun
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|int
name|unit
parameter_list|,
name|struct
name|atapi_params
modifier|*
name|ap
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
name|struct
name|wcd
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wcd
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptr
condition|)
return|return
name|NULL
return|;
name|bzero
argument_list|(
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wcd
argument_list|)
argument_list|)
expr_stmt|;
name|bufq_init
argument_list|(
operator|&
name|ptr
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|ata
operator|=
name|ata
expr_stmt|;
name|ptr
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|ptr
operator|->
name|lun
operator|=
name|lun
expr_stmt|;
name|ptr
operator|->
name|param
operator|=
name|ap
expr_stmt|;
name|ptr
operator|->
name|flags
operator|=
name|F_MEDIA_CHANGED
expr_stmt|;
name|ptr
operator|->
name|refcnt
operator|=
literal|0
expr_stmt|;
name|ptr
operator|->
name|slot
operator|=
operator|-
literal|1
expr_stmt|;
name|ptr
operator|->
name|changer_info
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|ptr
operator|->
name|ra_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|wcd_cdevsw
argument_list|,
name|dkmakeminor
argument_list|(
name|lun
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"rwcd%da"
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|rc_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|wcd_cdevsw
argument_list|,
name|dkmakeminor
argument_list|(
name|lun
argument_list|,
literal|0
argument_list|,
name|RAW_PART
argument_list|)
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"rwcd%dc"
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|a_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|wcd_bdevsw
argument_list|,
name|dkmakeminor
argument_list|(
name|lun
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|DV_BLK
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"wcd%da"
argument_list|,
name|lun
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|c_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|wcd_bdevsw
argument_list|,
name|dkmakeminor
argument_list|(
name|lun
argument_list|,
literal|0
argument_list|,
name|RAW_PART
argument_list|)
argument_list|,
name|DV_BLK
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"wcd%dc"
argument_list|,
name|lun
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ptr
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ATAPI_STATIC
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
name|int
name|wcdattach
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|int
name|unit
parameter_list|,
name|struct
name|atapi_params
modifier|*
name|ap
parameter_list|,
name|int
name|debug
parameter_list|)
block|{
name|struct
name|wcd
modifier|*
name|cdp
decl_stmt|;
name|struct
name|atapires
name|result
decl_stmt|;
name|struct
name|changer
modifier|*
name|chp
decl_stmt|;
name|int
name|lun
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|wcdnlun
operator|>=
name|NUNIT
condition|)
block|{
name|printf
argument_list|(
literal|"wcd: too many units\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|atapi_request_immediate
condition|)
block|{
name|printf
argument_list|(
literal|"wcd: configuration error, ATAPI core code not present!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wcd: check `options ATAPI_STATIC' in your kernel config file!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cdp
operator|=
name|wcd_init_lun
argument_list|(
name|ata
argument_list|,
name|unit
argument_list|,
name|ap
argument_list|,
name|wcdnlun
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"wcd: out of memory\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|wcdtab
index|[
name|wcdnlun
index|]
operator|=
name|cdp
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|cdp
operator|->
name|flags
operator||=
name|F_DEBUG
expr_stmt|;
comment|/* Print params. */
name|wcd_dump
argument_list|(
name|cdp
operator|->
name|lun
argument_list|,
literal|"info"
argument_list|,
name|ap
argument_list|,
sizeof|sizeof
expr|*
name|ap
argument_list|)
expr_stmt|;
block|}
comment|/* Get drive capabilities. */
name|result
operator|=
name|atapi_request_immediate
argument_list|(
name|ata
argument_list|,
name|unit
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|CAP_PAGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cdp
operator|->
name|cap
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|cdp
operator|->
name|cap
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cdp
operator|->
name|cap
argument_list|,
sizeof|sizeof
argument_list|(
name|cdp
operator|->
name|cap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do it twice to avoid the stale media changed state. */
if|if
condition|(
name|result
operator|.
name|code
operator|==
name|RES_ERR
operator|&&
operator|(
name|result
operator|.
name|error
operator|&
name|AER_SKEY
operator|)
operator|==
name|AER_SK_UNIT_ATTENTION
condition|)
name|result
operator|=
name|atapi_request_immediate
argument_list|(
name|ata
argument_list|,
name|unit
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|CAP_PAGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cdp
operator|->
name|cap
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|cdp
operator|->
name|cap
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cdp
operator|->
name|cap
argument_list|,
sizeof|sizeof
argument_list|(
name|cdp
operator|->
name|cap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some drives have shorter capabilities page. */
if|if
condition|(
name|result
operator|.
name|code
operator|==
name|RES_UNDERRUN
condition|)
name|result
operator|.
name|code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|code
operator|==
literal|0
condition|)
block|{
name|wcd_describe
argument_list|(
name|cdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|wcd_dump
argument_list|(
name|cdp
operator|->
name|lun
argument_list|,
literal|"cap"
argument_list|,
operator|&
name|cdp
operator|->
name|cap
argument_list|,
sizeof|sizeof
argument_list|(
name|cdp
operator|->
name|cap
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a changer device, allocate the neeeded lun's */
if|if
condition|(
name|cdp
operator|->
name|cap
operator|.
name|mech
operator|==
name|MECH_CHANGER
condition|)
block|{
name|chp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|changer
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|chp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"wcd: out of memory\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|chp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|changer
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|atapi_request_immediate
argument_list|(
name|ata
argument_list|,
name|unit
argument_list|,
name|ATAPI_MECH_STATUS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|changer
argument_list|)
operator|>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|changer
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|chp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|changer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"result.code=%d curr=%02x slots=%d len=%d\n"
argument_list|,
name|result
operator|.
name|code
argument_list|,
name|chp
operator|->
name|current_slot
argument_list|,
name|chp
operator|->
name|slots
argument_list|,
name|htons
argument_list|(
name|chp
operator|->
name|table_length
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|code
operator|==
name|RES_UNDERRUN
condition|)
name|result
operator|.
name|code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|code
operator|==
literal|0
condition|)
block|{
name|chp
operator|->
name|table_length
operator|=
name|htons
argument_list|(
name|chp
operator|->
name|table_length
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chp
operator|->
name|slots
operator|&&
name|wcdnlun
operator|<
name|NUNIT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|cdp
operator|=
name|wcd_init_lun
argument_list|(
name|ata
argument_list|,
name|unit
argument_list|,
name|ap
argument_list|,
name|wcdnlun
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"wcd: out of memory\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|cdp
operator|->
name|slot
operator|=
name|i
expr_stmt|;
name|cdp
operator|->
name|changer_info
operator|=
name|chp
expr_stmt|;
name|printf
argument_list|(
literal|"wcd%d: changer slot %d %s\n"
argument_list|,
name|wcdnlun
argument_list|,
name|i
argument_list|,
operator|(
name|chp
operator|->
name|slot
index|[
name|i
index|]
operator|.
name|present
condition|?
literal|"disk present"
else|:
literal|"no disk"
operator|)
argument_list|)
expr_stmt|;
name|wcdtab
index|[
name|wcdnlun
operator|++
index|]
operator|=
name|cdp
expr_stmt|;
block|}
if|if
condition|(
name|wcdnlun
operator|>=
name|NUNIT
condition|)
block|{
name|printf
argument_list|(
literal|"wcd: too many units\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
else|else
name|wcdnlun
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|wcd_describe
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|)
block|{
name|char
modifier|*
name|m
decl_stmt|;
name|t
operator|->
name|cap
operator|.
name|max_speed
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|cap
operator|.
name|max_speed
argument_list|)
expr_stmt|;
name|t
operator|->
name|cap
operator|.
name|max_vol_levels
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|cap
operator|.
name|max_vol_levels
argument_list|)
expr_stmt|;
name|t
operator|->
name|cap
operator|.
name|buf_size
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|cap
operator|.
name|buf_size
argument_list|)
expr_stmt|;
name|t
operator|->
name|cap
operator|.
name|cur_speed
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|cap
operator|.
name|cur_speed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wcd%d: "
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|cur_speed
operator|!=
name|t
operator|->
name|cap
operator|.
name|max_speed
condition|)
name|printf
argument_list|(
literal|"%d/"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|cur_speed
operator|*
literal|1000
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%dKb/sec"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|max_speed
operator|*
literal|1000
operator|/
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|buf_size
condition|)
name|printf
argument_list|(
literal|", %dKb cache"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|audio_play
condition|)
name|printf
argument_list|(
literal|", audio play"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|max_vol_levels
condition|)
name|printf
argument_list|(
literal|", %d volume levels"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|max_vol_levels
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|cap
operator|.
name|mech
condition|)
block|{
default|default:
name|m
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MECH_CADDY
case|:
name|m
operator|=
literal|"caddy"
expr_stmt|;
break|break;
case|case
name|MECH_TRAY
case|:
name|m
operator|=
literal|"tray"
expr_stmt|;
break|break;
case|case
name|MECH_POPUP
case|:
name|m
operator|=
literal|"popup"
expr_stmt|;
break|break;
case|case
name|MECH_CHANGER
case|:
name|m
operator|=
literal|"changer"
expr_stmt|;
break|break;
case|case
name|MECH_CARTRIDGE
case|:
name|m
operator|=
literal|"cartridge"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m
condition|)
name|printf
argument_list|(
literal|", %s%s"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|eject
condition|?
literal|"ejectable "
else|:
literal|""
argument_list|,
name|m
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|eject
condition|)
name|printf
argument_list|(
literal|", eject"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|mech
operator|!=
name|MECH_CHANGER
condition|)
block|{
name|printf
argument_list|(
literal|"wcd%d: "
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|cap
operator|.
name|medium_type
condition|)
block|{
case|case
name|MDT_UNKNOWN
case|:
name|printf
argument_list|(
literal|"medium type unknown"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_DATA_120
case|:
name|printf
argument_list|(
literal|"120mm data disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_AUDIO_120
case|:
name|printf
argument_list|(
literal|"120mm audio disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_COMB_120
case|:
name|printf
argument_list|(
literal|"120mm data/audio disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_PHOTO_120
case|:
name|printf
argument_list|(
literal|"120mm photo disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_DATA_80
case|:
name|printf
argument_list|(
literal|"80mm data disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_AUDIO_80
case|:
name|printf
argument_list|(
literal|"80mm audio disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_COMB_80
case|:
name|printf
argument_list|(
literal|"80mm data/audio disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_PHOTO_80
case|:
name|printf
argument_list|(
literal|"80mm photo disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_NO_DISC
case|:
name|printf
argument_list|(
literal|"no disc inside"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_DOOR_OPEN
case|:
name|printf
argument_list|(
literal|"door open"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_FMT_ERROR
case|:
name|printf
argument_list|(
literal|"medium format error"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"medium type=0x%x"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|medium_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|lock
condition|)
name|printf
argument_list|(
name|t
operator|->
name|cap
operator|.
name|locked
condition|?
literal|", locked"
else|:
literal|", unlocked"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|prevent
condition|)
name|printf
argument_list|(
literal|", lock protected"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wcd_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|rawflag
parameter_list|)
block|{
name|int
name|lun
init|=
name|dkunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|wcd
modifier|*
name|t
decl_stmt|;
comment|/* Check device number is legal and ATAPI driver is loaded. */
if|if
condition|(
name|lun
operator|>=
name|wcdnlun
operator|||
operator|!
name|atapi_request_immediate
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|t
operator|=
name|wcdtab
index|[
name|lun
index|]
expr_stmt|;
comment|/* On the first open, read the table of contents. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|F_BOPEN
operator|)
operator|&&
operator|!
name|t
operator|->
name|refcnt
condition|)
block|{
comment|/* Read table of contents. */
if|if
condition|(
name|wcd_read_toc
argument_list|(
name|t
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Lock the media. */
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|F_LOCKED
expr_stmt|;
block|}
if|if
condition|(
name|rawflag
condition|)
operator|++
name|t
operator|->
name|refcnt
expr_stmt|;
else|else
name|t
operator|->
name|flags
operator||=
name|F_BOPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wcdbopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
name|wcd_open
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|wcdropen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
name|wcd_open
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the device.  Only called if we are the LAST  * occurence of an open device.  */
end_comment

begin_function
name|int
name|wcdbclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|lun
init|=
name|dkunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|wcd
modifier|*
name|t
init|=
name|wcdtab
index|[
name|lun
index|]
decl_stmt|;
comment|/* If we were the last open of the entire device, release it. */
if|if
condition|(
operator|!
name|t
operator|->
name|refcnt
condition|)
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|F_BOPEN
operator||
name|F_LOCKED
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wcdrclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|lun
init|=
name|dkunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|wcd
modifier|*
name|t
init|=
name|wcdtab
index|[
name|lun
index|]
decl_stmt|;
comment|/* If we were the last open of the entire device, release it. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|F_BOPEN
operator|)
operator|&&
name|t
operator|->
name|refcnt
operator|==
literal|1
condition|)
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|F_LOCKED
expr_stmt|;
operator|--
name|t
operator|->
name|refcnt
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually translate the requested transfer into one the physical driver can  * understand. The transfer is described by a buf and will include only one  * physical transfer.  */
end_comment

begin_function
name|void
name|wcdstrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|lun
init|=
name|dkunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|struct
name|wcd
modifier|*
name|t
init|=
name|wcdtab
index|[
name|lun
index|]
decl_stmt|;
name|int
name|x
decl_stmt|;
comment|/* Can't ever write to a CD. */
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If it's a null transfer, return immediatly. */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Process transfer request. */
name|bp
operator|->
name|b_pblkno
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* Place it in the queue of disk activities for this disk. */
name|bufqdisksort
argument_list|(
operator|&
name|t
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* Tell the device to get going on the transfer if it's 	 * not doing anything, otherwise just wait for completion. */
name|wcd_start
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look to see if there is a buf waiting for the device  * and that the device is not already busy. If both are true,  * It dequeues the buf and creates an ATAPI command to perform the  * transfer in the buf.  * The bufs are queued by the strategy routine (wcdstrategy).  * Must be called at the correct (splbio) level.  */
end_comment

begin_function
specifier|static
name|void
name|wcd_start
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|bufq_first
argument_list|(
operator|&
name|t
operator|->
name|buf_queue
argument_list|)
decl_stmt|;
name|u_long
name|blkno
decl_stmt|,
name|nblk
decl_stmt|;
comment|/* See if there is a buf to do and we are not already doing one. */
if|if
condition|(
operator|!
name|bp
condition|)
return|return;
comment|/* Unqueue the request. */
name|bufq_remove
argument_list|(
operator|&
name|t
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* Should reject all queued entries if media have changed. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|wcd_select_slot
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* We have a buf, now we should make a command 	 * First, translate the block to absolute and put it in terms of the 	 * logical blocksize of the device. 	 * What if something asks for 512 bytes not on a 2k boundary? */
name|blkno
operator|=
name|bp
operator|->
name|b_blkno
operator|/
operator|(
name|SECSIZE
operator|/
literal|512
operator|)
expr_stmt|;
name|nblk
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
operator|(
name|SECSIZE
operator|-
literal|1
operator|)
operator|)
operator|/
name|SECSIZE
expr_stmt|;
name|atapi_request_callback
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|ATAPI_READ_BIG
argument_list|,
literal|0
argument_list|,
name|blkno
operator|>>
literal|24
argument_list|,
name|blkno
operator|>>
literal|16
argument_list|,
name|blkno
operator|>>
literal|8
argument_list|,
name|blkno
argument_list|,
literal|0
argument_list|,
name|nblk
operator|>>
literal|8
argument_list|,
name|nblk
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|wcd_done
argument_list|,
name|t
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wcd_done
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|resid
parameter_list|,
name|struct
name|atapires
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|.
name|code
condition|)
block|{
name|wcd_error
argument_list|(
name|t
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
else|else
name|bp
operator|->
name|b_resid
operator|=
name|resid
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|wcd_start
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wcd_error
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|struct
name|atapires
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|.
name|code
operator|!=
name|RES_ERR
condition|)
return|return;
switch|switch
condition|(
name|result
operator|.
name|error
operator|&
name|AER_SKEY
condition|)
block|{
case|case
name|AER_SK_NOT_READY
case|:
if|if
condition|(
name|result
operator|.
name|error
operator|&
operator|~
name|AER_SKEY
condition|)
block|{
comment|/* Audio disc. */
name|printf
argument_list|(
literal|"wcd%d: cannot read audio disc\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Tray open. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
operator|)
condition|)
name|printf
argument_list|(
literal|"wcd%d: tray open\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|F_MEDIA_CHANGED
expr_stmt|;
return|return;
case|case
name|AER_SK_UNIT_ATTENTION
case|:
comment|/* Media changed. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
operator|)
condition|)
name|printf
argument_list|(
literal|"wcd%d: media changed\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|F_MEDIA_CHANGED
expr_stmt|;
return|return;
case|case
name|AER_SK_ILLEGAL_REQUEST
case|:
comment|/* Unknown command or invalid command arguments. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|printf
argument_list|(
literal|"wcd%d: invalid command\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"wcd%d: i/o error, status=%b, error=%b\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|,
name|result
operator|.
name|status
argument_list|,
name|ARS_BITS
argument_list|,
name|result
operator|.
name|error
argument_list|,
name|AER_BITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wcd_request_wait
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|u_char
name|a1
parameter_list|,
name|u_char
name|a2
parameter_list|,
name|u_char
name|a3
parameter_list|,
name|u_char
name|a4
parameter_list|,
name|u_char
name|a5
parameter_list|,
name|u_char
name|a6
parameter_list|,
name|u_char
name|a7
parameter_list|,
name|u_char
name|a8
parameter_list|,
name|u_char
name|a9
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|atapires
name|result
decl_stmt|;
name|result
operator|=
name|atapi_request_wait
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|cmd
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|code
condition|)
block|{
name|wcd_error
argument_list|(
name|t
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|lba2msf
parameter_list|(
name|int
name|lba
parameter_list|,
name|u_char
modifier|*
name|m
parameter_list|,
name|u_char
modifier|*
name|s
parameter_list|,
name|u_char
modifier|*
name|f
parameter_list|)
block|{
name|lba
operator|+=
literal|150
expr_stmt|;
comment|/* offset of first logical frame */
name|lba
operator|&=
literal|0xffffff
expr_stmt|;
comment|/* negative lbas use only 24 bits */
operator|*
name|m
operator|=
name|lba
operator|/
operator|(
literal|60
operator|*
literal|75
operator|)
expr_stmt|;
name|lba
operator|%=
operator|(
literal|60
operator|*
literal|75
operator|)
expr_stmt|;
operator|*
name|s
operator|=
name|lba
operator|/
literal|75
expr_stmt|;
operator|*
name|f
operator|=
name|lba
operator|%
literal|75
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform special action on behalf of the user.  * Knows about the internals of this device  */
end_comment

begin_function
name|int
name|wcdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|lun
init|=
name|dkunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|wcd
modifier|*
name|t
init|=
name|wcdtab
index|[
name|lun
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
condition|)
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CDIOCSETDEBUG
case|:
case|case
name|CDIOCCLRDEBUG
case|:
case|case
name|CDIOCRESET
case|:
comment|/* These ops are media change transparent. */
break|break;
default|default:
comment|/* Read table of contents. */
name|wcd_read_toc
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Lock the media. */
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|F_LOCKED
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
case|case
name|CDIOCSETDEBUG
case|:
if|if
condition|(
name|p
operator|->
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|t
operator|->
name|flags
operator||=
name|F_DEBUG
expr_stmt|;
name|atapi_debug
argument_list|(
name|t
operator|->
name|ata
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CDIOCCLRDEBUG
case|:
if|if
condition|(
name|p
operator|->
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|F_DEBUG
expr_stmt|;
name|atapi_debug
argument_list|(
name|t
operator|->
name|ata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CDIOCRESUME
case|:
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PAUSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCPAUSE
case|:
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PAUSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCSTART
case|:
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_START_STOP
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCSTOP
case|:
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_START_STOP
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCALLOW
case|:
name|wcd_select_slot
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|F_LOCKED
expr_stmt|;
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCPREVENT
case|:
name|wcd_select_slot
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|F_LOCKED
expr_stmt|;
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCRESET
case|:
if|if
condition|(
name|p
operator|->
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_TEST_UNIT_READY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCEJECT
case|:
comment|/* Don't allow eject if the device is opened 		 * by somebody (not us) in block mode. */
if|if
condition|(
operator|(
name|t
operator|->
name|flags
operator|&
name|F_BOPEN
operator|)
operator|&&
name|t
operator|->
name|refcnt
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
return|return
name|wcd_eject
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCCLOSE
case|:
if|if
condition|(
operator|(
name|t
operator|->
name|flags
operator|&
name|F_BOPEN
operator|)
operator|&&
name|t
operator|->
name|refcnt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
name|wcd_eject
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
return|;
case|case
name|CDIOREADTOCHEADER
case|:
if|if
condition|(
operator|!
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|t
operator|->
name|toc
operator|.
name|hdr
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
name|t
operator|->
name|toc
operator|.
name|hdr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOREADTOCENTRYS
case|:
block|{
name|struct
name|ioc_read_toc_entry
modifier|*
name|te
init|=
operator|(
expr|struct
name|ioc_read_toc_entry
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|toc
modifier|*
name|toc
init|=
operator|&
name|t
operator|->
name|toc
decl_stmt|;
name|struct
name|toc
name|buf
decl_stmt|;
name|u_long
name|len
decl_stmt|;
name|u_char
name|starting_track
init|=
name|te
operator|->
name|starting_track
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|te
operator|->
name|data_len
operator|<
sizeof|sizeof
argument_list|(
name|toc
operator|->
name|tab
index|[
literal|0
index|]
argument_list|)
operator|||
operator|(
name|te
operator|->
name|data_len
operator|%
sizeof|sizeof
argument_list|(
name|toc
operator|->
name|tab
index|[
literal|0
index|]
argument_list|)
operator|)
operator|!=
literal|0
operator|||
name|te
operator|->
name|address_format
operator|!=
name|CD_MSF_FORMAT
operator|&&
name|te
operator|->
name|address_format
operator|!=
name|CD_LBA_FORMAT
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|starting_track
operator|==
literal|0
condition|)
name|starting_track
operator|=
name|toc
operator|->
name|hdr
operator|.
name|starting_track
expr_stmt|;
elseif|else
if|if
condition|(
name|starting_track
operator|==
literal|170
condition|)
comment|/* Handle leadout request */
name|starting_track
operator|=
name|toc
operator|->
name|hdr
operator|.
name|ending_track
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|starting_track
operator|<
name|toc
operator|->
name|hdr
operator|.
name|starting_track
operator|||
name|starting_track
operator|>
name|toc
operator|->
name|hdr
operator|.
name|ending_track
operator|+
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|len
operator|=
operator|(
operator|(
name|toc
operator|->
name|hdr
operator|.
name|ending_track
operator|+
literal|1
operator|-
name|starting_track
operator|)
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|toc
operator|->
name|tab
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|data_len
operator|<
name|len
condition|)
name|len
operator|=
name|te
operator|->
name|data_len
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|toc
operator|->
name|tab
argument_list|)
condition|)
return|return
name|EINVAL
return|;
comment|/* Convert to MSF format, if needed. */
if|if
condition|(
name|te
operator|->
name|address_format
operator|==
name|CD_MSF_FORMAT
condition|)
block|{
name|struct
name|cd_toc_entry
modifier|*
name|e
decl_stmt|;
name|buf
operator|=
name|t
operator|->
name|toc
expr_stmt|;
name|toc
operator|=
operator|&
name|buf
expr_stmt|;
name|e
operator|=
name|toc
operator|->
name|tab
operator|+
operator|(
name|toc
operator|->
name|hdr
operator|.
name|ending_track
operator|+
literal|1
operator|-
name|toc
operator|->
name|hdr
operator|.
name|starting_track
operator|)
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|--
name|e
operator|>=
name|toc
operator|->
name|tab
condition|)
name|lba2msf
argument_list|(
name|ntohl
argument_list|(
name|e
operator|->
name|addr
operator|.
name|lba
argument_list|)
argument_list|,
operator|&
name|e
operator|->
name|addr
operator|.
name|msf
operator|.
name|minute
argument_list|,
operator|&
name|e
operator|->
name|addr
operator|.
name|msf
operator|.
name|second
argument_list|,
operator|&
name|e
operator|->
name|addr
operator|.
name|msf
operator|.
name|frame
argument_list|)
expr_stmt|;
block|}
return|return
name|copyout
argument_list|(
name|toc
operator|->
name|tab
operator|+
name|starting_track
operator|-
name|toc
operator|->
name|hdr
operator|.
name|starting_track
argument_list|,
name|te
operator|->
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
case|case
name|CDIOREADTOCENTRY
case|:
block|{
name|struct
name|ioc_read_toc_single_entry
modifier|*
name|te
init|=
operator|(
expr|struct
name|ioc_read_toc_single_entry
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|toc
modifier|*
name|toc
init|=
operator|&
name|t
operator|->
name|toc
decl_stmt|;
name|struct
name|toc
name|buf
decl_stmt|;
name|u_char
name|track
init|=
name|te
operator|->
name|track
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|te
operator|->
name|address_format
operator|!=
name|CD_MSF_FORMAT
operator|&&
name|te
operator|->
name|address_format
operator|!=
name|CD_LBA_FORMAT
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|track
operator|==
literal|0
condition|)
name|track
operator|=
name|toc
operator|->
name|hdr
operator|.
name|starting_track
expr_stmt|;
elseif|else
if|if
condition|(
name|track
operator|==
literal|170
condition|)
comment|/* Handle leadout request */
name|track
operator|=
name|toc
operator|->
name|hdr
operator|.
name|ending_track
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|track
operator|<
name|toc
operator|->
name|hdr
operator|.
name|starting_track
operator|||
name|track
operator|>
name|toc
operator|->
name|hdr
operator|.
name|ending_track
operator|+
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Convert to MSF format, if needed. */
if|if
condition|(
name|te
operator|->
name|address_format
operator|==
name|CD_MSF_FORMAT
condition|)
block|{
name|struct
name|cd_toc_entry
modifier|*
name|e
decl_stmt|;
name|buf
operator|=
name|t
operator|->
name|toc
expr_stmt|;
name|toc
operator|=
operator|&
name|buf
expr_stmt|;
name|e
operator|=
name|toc
operator|->
name|tab
operator|+
operator|(
name|track
operator|-
name|toc
operator|->
name|hdr
operator|.
name|starting_track
operator|)
expr_stmt|;
name|lba2msf
argument_list|(
name|ntohl
argument_list|(
name|e
operator|->
name|addr
operator|.
name|lba
argument_list|)
argument_list|,
operator|&
name|e
operator|->
name|addr
operator|.
name|msf
operator|.
name|minute
argument_list|,
operator|&
name|e
operator|->
name|addr
operator|.
name|msf
operator|.
name|second
argument_list|,
operator|&
name|e
operator|->
name|addr
operator|.
name|msf
operator|.
name|frame
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|toc
operator|->
name|tab
operator|+
name|track
operator|-
name|toc
operator|->
name|hdr
operator|.
name|starting_track
argument_list|,
operator|&
name|te
operator|->
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
case|case
name|CDIOCREADSUBCHANNEL
case|:
block|{
name|struct
name|ioc_read_subchannel
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_read_subchannel
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_sub_channel_info
name|data
decl_stmt|;
name|u_long
name|len
init|=
name|args
operator|->
name|data_len
decl_stmt|;
name|int
name|abslba
decl_stmt|,
name|rellba
decl_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|||
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|cd_sub_channel_header
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_READ_SUBCHANNEL
argument_list|,
literal|0
argument_list|,
literal|0x40
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|subchan
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|subchan
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|subchan
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|subchan
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|wcd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"subchan"
argument_list|,
operator|&
name|t
operator|->
name|subchan
argument_list|,
sizeof|sizeof
name|t
operator|->
name|subchan
argument_list|)
expr_stmt|;
name|abslba
operator|=
name|t
operator|->
name|subchan
operator|.
name|abslba
expr_stmt|;
name|rellba
operator|=
name|t
operator|->
name|subchan
operator|.
name|rellba
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|address_format
operator|==
name|CD_MSF_FORMAT
condition|)
block|{
name|lba2msf
argument_list|(
name|ntohl
argument_list|(
name|abslba
argument_list|)
argument_list|,
operator|&
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|minute
argument_list|,
operator|&
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|second
argument_list|,
operator|&
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|frame
argument_list|)
expr_stmt|;
name|lba2msf
argument_list|(
name|ntohl
argument_list|(
name|rellba
argument_list|)
argument_list|,
operator|&
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|minute
argument_list|,
operator|&
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|second
argument_list|,
operator|&
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|lba
operator|=
name|abslba
expr_stmt|;
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|lba
operator|=
name|rellba
expr_stmt|;
block|}
name|data
operator|.
name|header
operator|.
name|audio_status
operator|=
name|t
operator|->
name|subchan
operator|.
name|audio_status
expr_stmt|;
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|control
operator|=
name|t
operator|->
name|subchan
operator|.
name|control
operator|&
literal|0xf
expr_stmt|;
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|addr_type
operator|=
name|t
operator|->
name|subchan
operator|.
name|control
operator|>>
literal|4
expr_stmt|;
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|track_number
operator|=
name|t
operator|->
name|subchan
operator|.
name|track
expr_stmt|;
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|index_number
operator|=
name|t
operator|->
name|subchan
operator|.
name|indx
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|data
argument_list|,
name|args
operator|->
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
case|case
name|CDIOCPLAYMSF
case|:
block|{
name|struct
name|ioc_play_msf
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_play_msf
operator|*
operator|)
name|addr
decl_stmt|;
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PLAY_MSF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|args
operator|->
name|start_m
argument_list|,
name|args
operator|->
name|start_s
argument_list|,
name|args
operator|->
name|start_f
argument_list|,
name|args
operator|->
name|end_m
argument_list|,
name|args
operator|->
name|end_s
argument_list|,
name|args
operator|->
name|end_f
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
case|case
name|CDIOCPLAYBLOCKS
case|:
block|{
name|struct
name|ioc_play_blocks
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_play_blocks
operator|*
operator|)
name|addr
decl_stmt|;
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PLAY_BIG
argument_list|,
literal|0
argument_list|,
name|args
operator|->
name|blk
operator|>>
literal|24
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|blk
operator|>>
literal|16
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|blk
operator|>>
literal|8
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|blk
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|len
operator|>>
literal|24
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|len
operator|>>
literal|16
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|len
operator|>>
literal|8
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|len
operator|&
literal|0xff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
case|case
name|CDIOCPLAYTRACKS
case|:
block|{
name|struct
name|ioc_play_track
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_play_track
operator|*
operator|)
name|addr
decl_stmt|;
name|u_long
name|start
decl_stmt|,
name|len
decl_stmt|;
name|int
name|t1
decl_stmt|,
name|t2
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Ignore index fields, 		 * play from start_track to end_track inclusive. */
if|if
condition|(
name|args
operator|->
name|end_track
operator|<
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
operator|+
literal|1
condition|)
operator|++
name|args
operator|->
name|end_track
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|end_track
operator|>
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
operator|+
literal|1
condition|)
name|args
operator|->
name|end_track
operator|=
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
operator|+
literal|1
expr_stmt|;
name|t1
operator|=
name|args
operator|->
name|start_track
operator|-
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|starting_track
expr_stmt|;
name|t2
operator|=
name|args
operator|->
name|end_track
operator|-
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|starting_track
expr_stmt|;
if|if
condition|(
name|t1
operator|<
literal|0
operator|||
name|t2
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|start
operator|=
name|ntohl
argument_list|(
name|t
operator|->
name|toc
operator|.
name|tab
index|[
name|t1
index|]
operator|.
name|addr
operator|.
name|lba
argument_list|)
expr_stmt|;
name|len
operator|=
name|ntohl
argument_list|(
name|t
operator|->
name|toc
operator|.
name|tab
index|[
name|t2
index|]
operator|.
name|addr
operator|.
name|lba
argument_list|)
operator|-
name|start
expr_stmt|;
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PLAY_BIG
argument_list|,
literal|0
argument_list|,
name|start
operator|>>
literal|24
operator|&
literal|0xff
argument_list|,
name|start
operator|>>
literal|16
operator|&
literal|0xff
argument_list|,
name|start
operator|>>
literal|8
operator|&
literal|0xff
argument_list|,
name|start
operator|&
literal|0xff
argument_list|,
name|len
operator|>>
literal|24
operator|&
literal|0xff
argument_list|,
name|len
operator|>>
literal|16
operator|&
literal|0xff
argument_list|,
name|len
operator|>>
literal|8
operator|&
literal|0xff
argument_list|,
name|len
operator|&
literal|0xff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
case|case
name|CDIOCGETVOL
case|:
block|{
name|struct
name|ioc_vol
modifier|*
name|arg
init|=
operator|(
expr|struct
name|ioc_vol
operator|*
operator|)
name|addr
decl_stmt|;
name|error
operator|=
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|AUDIO_PAGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|au
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|wcd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"au"
argument_list|,
operator|&
name|t
operator|->
name|au
argument_list|,
sizeof|sizeof
name|t
operator|->
name|au
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|au
operator|.
name|page_code
operator|!=
name|AUDIO_PAGE
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|arg
operator|->
name|vol
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|0
index|]
operator|.
name|volume
expr_stmt|;
name|arg
operator|->
name|vol
index|[
literal|1
index|]
operator|=
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|1
index|]
operator|.
name|volume
expr_stmt|;
name|arg
operator|->
name|vol
index|[
literal|2
index|]
operator|=
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|volume
expr_stmt|;
name|arg
operator|->
name|vol
index|[
literal|3
index|]
operator|=
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|volume
expr_stmt|;
break|break;
block|}
case|case
name|CDIOCSETVOL
case|:
block|{
name|struct
name|ioc_vol
modifier|*
name|arg
init|=
operator|(
expr|struct
name|ioc_vol
operator|*
operator|)
name|addr
decl_stmt|;
name|error
operator|=
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|AUDIO_PAGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|au
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|wcd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"au"
argument_list|,
operator|&
name|t
operator|->
name|au
argument_list|,
sizeof|sizeof
name|t
operator|->
name|au
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|au
operator|.
name|page_code
operator|!=
name|AUDIO_PAGE
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|error
operator|=
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|AUDIO_PAGE_MASK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|aumask
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|aumask
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|aumask
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|aumask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|wcd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"mask"
argument_list|,
operator|&
name|t
operator|->
name|aumask
argument_list|,
sizeof|sizeof
name|t
operator|->
name|aumask
argument_list|)
expr_stmt|;
comment|/* Sony-55E requires the data length field to be zeroed. */
name|t
operator|->
name|au
operator|.
name|data_length
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|0
index|]
operator|.
name|channels
operator|=
name|CHANNEL_0
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|1
index|]
operator|.
name|channels
operator|=
name|CHANNEL_1
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|0
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
literal|0
index|]
operator|&
name|t
operator|->
name|aumask
operator|.
name|port
index|[
literal|0
index|]
operator|.
name|volume
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|1
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
literal|1
index|]
operator|&
name|t
operator|->
name|aumask
operator|.
name|port
index|[
literal|1
index|]
operator|.
name|volume
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
literal|2
index|]
operator|&
name|t
operator|->
name|aumask
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|volume
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
literal|3
index|]
operator|&
name|t
operator|->
name|aumask
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|volume
expr_stmt|;
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_MODE_SELECT_BIG
argument_list|,
literal|0x10
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|au
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|)
return|;
block|}
case|case
name|CDIOCSETPATCH
case|:
block|{
name|struct
name|ioc_patch
modifier|*
name|arg
init|=
operator|(
expr|struct
name|ioc_patch
operator|*
operator|)
name|addr
decl_stmt|;
return|return
name|wcd_setchan
argument_list|(
name|t
argument_list|,
name|arg
operator|->
name|patch
index|[
literal|0
index|]
argument_list|,
name|arg
operator|->
name|patch
index|[
literal|1
index|]
argument_list|,
name|arg
operator|->
name|patch
index|[
literal|2
index|]
argument_list|,
name|arg
operator|->
name|patch
index|[
literal|3
index|]
argument_list|)
return|;
block|}
case|case
name|CDIOCSETMONO
case|:
return|return
name|wcd_setchan
argument_list|(
name|t
argument_list|,
name|CHANNEL_0
operator||
name|CHANNEL_1
argument_list|,
name|CHANNEL_0
operator||
name|CHANNEL_1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCSETSTERIO
case|:
return|return
name|wcd_setchan
argument_list|(
name|t
argument_list|,
name|CHANNEL_0
argument_list|,
name|CHANNEL_1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCSETMUTE
case|:
return|return
name|wcd_setchan
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCSETLEFT
case|:
return|return
name|wcd_setchan
argument_list|(
name|t
argument_list|,
name|CHANNEL_0
argument_list|,
name|CHANNEL_0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCSETRIGHT
case|:
return|return
name|wcd_setchan
argument_list|(
name|t
argument_list|,
name|CHANNEL_1
argument_list|,
name|CHANNEL_1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the entire TOC for the disc into our internal buffer.  */
end_comment

begin_function
specifier|static
name|int
name|wcd_read_toc
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|)
block|{
name|int
name|ntracks
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|atapires
name|result
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|t
operator|->
name|toc
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|toc
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|t
operator|->
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|wcd_select_slot
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Check for the media. 	 * Do it twice to avoid the stale media changed state. */
name|result
operator|=
name|atapi_request_wait
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|ATAPI_TEST_UNIT_READY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|code
operator|==
name|RES_ERR
operator|&&
operator|(
name|result
operator|.
name|error
operator|&
name|AER_SKEY
operator|)
operator|==
name|AER_SK_UNIT_ATTENTION
condition|)
block|{
name|t
operator|->
name|flags
operator||=
name|F_MEDIA_CHANGED
expr_stmt|;
name|result
operator|=
name|atapi_request_wait
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|ATAPI_TEST_UNIT_READY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|code
condition|)
block|{
name|wcd_error
argument_list|(
name|t
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|t
operator|->
name|flags
operator|&=
operator|~
name|F_MEDIA_CHANGED
expr_stmt|;
comment|/* First read just the header, so we know how long the TOC is. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ioc_toc_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_READ_TOC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|len
operator|>>
literal|8
argument_list|,
name|len
operator|&
literal|0xff
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|toc
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|err
label|:
name|bzero
argument_list|(
operator|&
name|t
operator|->
name|toc
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|toc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ntracks
operator|=
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
operator|-
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|starting_track
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ntracks
operator|<=
literal|0
operator|||
name|ntracks
operator|>
name|MAXTRK
condition|)
goto|goto
name|err
goto|;
comment|/* Now read the whole schmeer. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ioc_toc_header
argument_list|)
operator|+
name|ntracks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_READ_TOC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|len
operator|>>
literal|8
argument_list|,
name|len
operator|&
literal|0xff
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|toc
argument_list|,
name|len
argument_list|)
operator|&
literal|0xff
condition|)
goto|goto
name|err
goto|;
name|NTOHS
argument_list|(
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* Read disc capacity. */
if|if
condition|(
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_READ_CAPACITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|info
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|info
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
operator|&
name|t
operator|->
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make fake leadout entry */
name|t
operator|->
name|toc
operator|.
name|tab
index|[
name|ntracks
index|]
operator|.
name|control
operator|=
name|t
operator|->
name|toc
operator|.
name|tab
index|[
name|ntracks
operator|-
literal|1
index|]
operator|.
name|control
expr_stmt|;
name|t
operator|->
name|toc
operator|.
name|tab
index|[
name|ntracks
index|]
operator|.
name|addr_type
operator|=
name|t
operator|->
name|toc
operator|.
name|tab
index|[
name|ntracks
operator|-
literal|1
index|]
operator|.
name|addr_type
expr_stmt|;
name|t
operator|->
name|toc
operator|.
name|tab
index|[
name|ntracks
index|]
operator|.
name|track
operator|=
literal|170
expr_stmt|;
comment|/* magic */
name|t
operator|->
name|toc
operator|.
name|tab
index|[
name|ntracks
index|]
operator|.
name|addr
operator|.
name|lba
operator|=
name|t
operator|->
name|info
operator|.
name|volsize
expr_stmt|;
name|NTOHL
argument_list|(
name|t
operator|->
name|info
operator|.
name|volsize
argument_list|)
expr_stmt|;
name|NTOHL
argument_list|(
name|t
operator|->
name|info
operator|.
name|blksize
argument_list|)
expr_stmt|;
comment|/* Print the disc description string on every disc change. 	 * It would help to track the history of disc changes. */
if|if
condition|(
name|t
operator|->
name|info
operator|.
name|volsize
operator|&&
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
operator|&&
operator|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
operator|)
operator|&&
operator|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"wcd%d: "
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|toc
operator|.
name|tab
index|[
literal|0
index|]
operator|.
name|control
operator|&
literal|4
condition|)
name|printf
argument_list|(
literal|"%ldMB "
argument_list|,
name|t
operator|->
name|info
operator|.
name|volsize
operator|/
literal|512
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%ld:%ld audio "
argument_list|,
name|t
operator|->
name|info
operator|.
name|volsize
operator|/
literal|75
operator|/
literal|60
argument_list|,
name|t
operator|->
name|info
operator|.
name|volsize
operator|/
literal|75
operator|%
literal|60
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%ld sectors), %d tracks\n"
argument_list|,
name|t
operator|->
name|info
operator|.
name|volsize
argument_list|,
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
operator|-
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|starting_track
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up the audio channel masks.  */
end_comment

begin_function
specifier|static
name|int
name|wcd_setchan
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|u_char
name|c0
parameter_list|,
name|u_char
name|c1
parameter_list|,
name|u_char
name|c2
parameter_list|,
name|u_char
name|c3
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|AUDIO_PAGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|au
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|wcd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"au"
argument_list|,
operator|&
name|t
operator|->
name|au
argument_list|,
sizeof|sizeof
name|t
operator|->
name|au
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|au
operator|.
name|page_code
operator|!=
name|AUDIO_PAGE
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Sony-55E requires the data length field to be zeroed. */
name|t
operator|->
name|au
operator|.
name|data_length
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|0
index|]
operator|.
name|channels
operator|=
name|c0
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|1
index|]
operator|.
name|channels
operator|=
name|c1
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
name|c2
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
name|c3
expr_stmt|;
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_MODE_SELECT_BIG
argument_list|,
literal|0x10
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|au
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wcd_eject
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|int
name|closeit
parameter_list|)
block|{
name|struct
name|atapires
name|result
decl_stmt|;
name|wcd_select_slot
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Try to stop the disc. */
name|result
operator|=
name|atapi_request_wait
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|ATAPI_START_STOP
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|code
operator|==
name|RES_ERR
operator|&&
operator|(
operator|(
name|result
operator|.
name|error
operator|&
name|AER_SKEY
operator|)
operator|==
name|AER_SK_NOT_READY
operator|||
operator|(
name|result
operator|.
name|error
operator|&
name|AER_SKEY
operator|)
operator|==
name|AER_SK_UNIT_ATTENTION
operator|)
condition|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|closeit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * The disc was unloaded. 		 * Load it (close tray). 		 * Read the table of contents. 		 */
name|err
operator|=
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_START_STOP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Read table of contents. */
name|wcd_read_toc
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Lock the media. */
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|F_LOCKED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|.
name|code
condition|)
block|{
name|wcd_error
argument_list|(
name|t
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|closeit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Give it some time to stop spinning. */
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PRIBIO
argument_list|,
literal|"wcdej1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PRIBIO
argument_list|,
literal|"wcdej2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unlock. */
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|F_LOCKED
expr_stmt|;
comment|/* Eject. */
name|t
operator|->
name|flags
operator||=
name|F_MEDIA_CHANGED
expr_stmt|;
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_START_STOP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wcd_select_slot
parameter_list|(
name|struct
name|wcd
modifier|*
name|cdp
parameter_list|)
block|{
if|if
condition|(
name|cdp
operator|->
name|slot
operator|<
literal|0
operator|||
name|cdp
operator|->
name|changer_info
operator|->
name|current_slot
operator|==
name|cdp
operator|->
name|slot
condition|)
return|return;
comment|/* Unlock (might not be needed but its cheaper than asking) */
name|wcd_request_wait
argument_list|(
name|cdp
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unload the current media from player */
name|wcd_request_wait
argument_list|(
name|cdp
argument_list|,
name|ATAPI_LOAD_UNLOAD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cdp
operator|->
name|changer_info
operator|->
name|current_slot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* load the wanted slot */
name|wcd_request_wait
argument_list|(
name|cdp
argument_list|,
name|ATAPI_LOAD_UNLOAD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cdp
operator|->
name|slot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdp
operator|->
name|changer_info
operator|->
name|current_slot
operator|=
name|cdp
operator|->
name|slot
expr_stmt|;
comment|/* Lock the media if needed */
if|if
condition|(
name|cdp
operator|->
name|flags
operator|&
name|F_LOCKED
condition|)
block|{
name|wcd_request_wait
argument_list|(
name|cdp
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WCD_MODULE
end_ifdef

begin_comment
comment|/*  * Loadable ATAPI CD-ROM driver stubs.  */
end_comment

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/lkm.h>
end_include

begin_comment
comment|/*  * Construct lkm_dev structures (see lkm.h).  * Our bdevsw/cdevsw slot numbers are 19/69.  */
end_comment

begin_expr_stmt
name|MOD_DEV
argument_list|(
name|wcd
argument_list|,
name|LM_DT_BLOCK
argument_list|,
name|BDEV_MAJOR
argument_list|,
operator|&
name|wcd_bdevsw
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MOD_DEV
argument_list|(
name|rwcd
argument_list|,
name|LM_DT_CHAR
argument_list|,
name|CDEV_MAJOR
argument_list|,
operator|&
name|wcd_cdevsw
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Function called when loading the driver.  */
end_comment

begin_function
name|int
name|wcd_load
parameter_list|(
name|struct
name|lkm_table
modifier|*
name|lkmtp
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|struct
name|atapi
modifier|*
name|ata
decl_stmt|;
name|int
name|n
decl_stmt|,
name|u
decl_stmt|;
if|if
condition|(
operator|!
name|atapi_start
condition|)
comment|/* No ATAPI driver available. */
return|return
name|EPROTONOSUPPORT
return|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ata
operator|=
name|atapi_tab
init|;
name|ata
operator|<
name|atapi_tab
operator|+
literal|2
condition|;
operator|++
name|ata
control|)
if|if
condition|(
name|ata
operator|->
name|port
condition|)
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
literal|2
condition|;
operator|++
name|u
control|)
comment|/* Probing controller ata->ctrlr, unit u. */
if|if
condition|(
name|ata
operator|->
name|params
index|[
name|u
index|]
operator|&&
operator|!
name|ata
operator|->
name|attached
index|[
name|u
index|]
operator|&&
name|wcdattach
argument_list|(
name|ata
argument_list|,
name|u
argument_list|,
name|ata
operator|->
name|params
index|[
name|u
index|]
argument_list|,
name|ata
operator|->
name|debug
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Drive found. */
name|ata
operator|->
name|attached
index|[
name|u
index|]
operator|=
literal|1
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|n
condition|)
comment|/* No IDE CD-ROMs found. */
return|return
name|ENXIO
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Function called when unloading the driver.  */
end_comment

begin_function
name|int
name|wcd_unload
parameter_list|(
name|struct
name|lkm_table
modifier|*
name|lkmtp
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|struct
name|wcd
modifier|*
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|wcdtab
init|;
name|t
operator|<
name|wcdtab
operator|+
name|wcdnlun
condition|;
operator|++
name|t
control|)
if|if
condition|(
operator|(
operator|(
operator|*
name|t
operator|)
operator|->
name|flags
operator|&
name|F_BOPEN
operator|)
operator|||
operator|(
operator|*
name|t
operator|)
operator|->
name|refcnt
condition|)
comment|/* The device is opened, cannot unload the driver. */
return|return
name|EBUSY
return|;
for|for
control|(
name|t
operator|=
name|wcdtab
init|;
name|t
operator|<
name|wcdtab
operator|+
name|wcdnlun
condition|;
operator|++
name|t
control|)
block|{
operator|(
operator|*
name|t
operator|)
operator|->
name|ata
operator|->
name|attached
index|[
operator|(
operator|*
name|t
operator|)
operator|->
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|*
name|t
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|wcdnlun
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|wcdtab
argument_list|,
sizeof|sizeof
argument_list|(
name|wcdtab
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Dispatcher function for the module (load/unload/stat).  */
end_comment

begin_function
name|int
name|wcd_mod
parameter_list|(
name|struct
name|lkm_table
modifier|*
name|lkmtp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|ver
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ver
operator|!=
name|LKM_VERSION
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|cmd
operator|==
name|LKM_E_LOAD
condition|)
name|err
operator|=
name|wcd_load
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|LKM_E_UNLOAD
condition|)
name|err
operator|=
name|wcd_unload
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* XXX Poking around in the LKM internals like this is bad. 	 */
comment|/* Register the cdevsw entry. */
name|lkmtp
operator|->
name|private
operator|.
name|lkm_dev
operator|=
operator|&
name|MOD_PRIVATE
argument_list|(
name|rwcd
argument_list|)
expr_stmt|;
name|err
operator|=
name|lkmdispatch
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* Register the bdevsw entry. */
name|lkmtp
operator|->
name|private
operator|.
name|lkm_dev
operator|=
operator|&
name|MOD_PRIVATE
argument_list|(
name|wcd
argument_list|)
expr_stmt|;
return|return
name|lkmdispatch
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WCD_MODULE */
end_comment

begin_expr_stmt
specifier|static
name|wcd_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|wcd_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|wcd_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|wcd_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dev
operator|=
name|makedev
argument_list|(
name|BDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|wcd_bdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|wcd_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|wcddev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|wcd_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NWCD&& NWDC&& ATAPI */
end_comment

end_unit

