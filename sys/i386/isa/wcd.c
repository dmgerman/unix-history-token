begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * IDE CD-ROM driver for FreeBSD.  * Supports ATAPI-compatible drives.  *  * Copyright (C) 1995 Cronyx Ltd.  * Author Serge Vakulenko,<vak@cronyx.ru>  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations permission to use  * or modify this software as long as this message is kept with the software,  * all derivative works or modified versions.  *  * Version 1.8, Thu Sep 28 21:04:16 MSK 1995  */
end_comment

begin_include
include|#
directive|include
file|"wdc.h"
end_include

begin_include
include|#
directive|include
file|"wcd.h"
end_include

begin_if
if|#
directive|if
name|NWCD
operator|>
literal|0
operator|&&
name|NWDC
operator|>
literal|0
operator|&&
name|defined
argument_list|(
name|ATAPI
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdio.h>
end_include

begin_include
include|#
directive|include
file|<i386/include/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/atapi.h>
end_include

begin_define
define|#
directive|define
name|NUNIT
value|(NWDC*2)
end_define

begin_comment
comment|/* Max. number of devices */
end_comment

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|d
parameter_list|)
value|((minor(d)>> 3)& 3)
end_define

begin_comment
comment|/* Unit part of minor device number */
end_comment

begin_define
define|#
directive|define
name|SECSIZE
value|2048
end_define

begin_comment
comment|/* CD-ROM sector size in bytes */
end_comment

begin_define
define|#
directive|define
name|F_OPEN
value|0x0001
end_define

begin_comment
comment|/* The drive os opened */
end_comment

begin_define
define|#
directive|define
name|F_MEDIA_CHANGED
value|0x0002
end_define

begin_comment
comment|/* The media have changed since open */
end_comment

begin_define
define|#
directive|define
name|F_DEBUG
value|0x0004
end_define

begin_comment
comment|/* The media have changed since open */
end_comment

begin_define
define|#
directive|define
name|F_NOPLAYCD
value|0x0008
end_define

begin_comment
comment|/* The PLAY_CD op not supported */
end_comment

begin_comment
comment|/*  * Disc table of contents.  */
end_comment

begin_define
define|#
directive|define
name|MAXTRK
value|99
end_define

begin_struct
struct|struct
name|toc
block|{
name|struct
name|ioc_toc_header
name|hdr
decl_stmt|;
name|struct
name|cd_toc_entry
name|tab
index|[
name|MAXTRK
operator|+
literal|1
index|]
decl_stmt|;
comment|/* One extra for the leadout */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Volume size info.  */
end_comment

begin_struct
struct|struct
name|volinfo
block|{
name|u_long
name|volsize
decl_stmt|;
comment|/* Volume size in blocks */
name|u_long
name|blksize
decl_stmt|;
comment|/* Block size in bytes */
block|}
name|info
struct|;
end_struct

begin_comment
comment|/*  * Current subchannel status.  */
end_comment

begin_struct
struct|struct
name|subchan
block|{
name|u_char
name|void0
decl_stmt|;
name|u_char
name|audio_status
decl_stmt|;
name|u_short
name|data_length
decl_stmt|;
name|u_char
name|data_format
decl_stmt|;
name|u_char
name|control
decl_stmt|;
name|u_char
name|track
decl_stmt|;
name|u_char
name|indx
decl_stmt|;
name|u_long
name|abslba
decl_stmt|;
name|u_long
name|rellba
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Audio Control Parameters Page  */
end_comment

begin_struct
struct|struct
name|audiopage
block|{
comment|/* Mode data header */
name|u_short
name|data_length
decl_stmt|;
name|u_char
name|medium_type
decl_stmt|;
name|u_char
name|reserved1
index|[
literal|5
index|]
decl_stmt|;
comment|/* Audio control page */
name|u_char
name|page_code
decl_stmt|;
define|#
directive|define
name|AUDIO_PAGE
value|0x0e
define|#
directive|define
name|AUDIO_PAGE_MASK
value|0x4e
comment|/* changeable values */
name|u_char
name|param_len
decl_stmt|;
name|u_char
name|flags
decl_stmt|;
define|#
directive|define
name|CD_PA_SOTC
value|0x02
comment|/* mandatory */
define|#
directive|define
name|CD_PA_IMMED
value|0x04
comment|/* always 1 */
name|u_char
name|reserved3
index|[
literal|3
index|]
decl_stmt|;
name|u_short
name|lb_per_sec
decl_stmt|;
struct|struct
name|port_control
block|{
name|u_char
name|channels
range|:
literal|4
decl_stmt|;
define|#
directive|define
name|CHANNEL_0
value|1
comment|/* mandatory */
define|#
directive|define
name|CHANNEL_1
value|2
comment|/* mandatory */
define|#
directive|define
name|CHANNEL_2
value|4
comment|/* optional */
define|#
directive|define
name|CHANNEL_3
value|8
comment|/* optional */
name|u_char
name|volume
decl_stmt|;
block|}
name|port
index|[
literal|4
index|]
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * CD-ROM Capabilities and Mechanical Status Page  */
end_comment

begin_struct
struct|struct
name|cappage
block|{
comment|/* Mode data header */
name|u_short
name|data_length
decl_stmt|;
name|u_char
name|medium_type
decl_stmt|;
define|#
directive|define
name|MDT_UNKNOWN
value|0x00
define|#
directive|define
name|MDT_DATA_120
value|0x01
define|#
directive|define
name|MDT_AUDIO_120
value|0x02
define|#
directive|define
name|MDT_COMB_120
value|0x03
define|#
directive|define
name|MDT_PHOTO_120
value|0x04
define|#
directive|define
name|MDT_DATA_80
value|0x05
define|#
directive|define
name|MDT_AUDIO_80
value|0x06
define|#
directive|define
name|MDT_COMB_80
value|0x07
define|#
directive|define
name|MDT_PHOTO_80
value|0x08
define|#
directive|define
name|MDT_NO_DISC
value|0x70
define|#
directive|define
name|MDT_DOOR_OPEN
value|0x71
define|#
directive|define
name|MDT_FMT_ERROR
value|0x72
name|u_char
name|reserved1
index|[
literal|5
index|]
decl_stmt|;
comment|/* Capabilities page */
name|u_char
name|page_code
decl_stmt|;
define|#
directive|define
name|CAP_PAGE
value|0x2a
name|u_char
name|param_len
decl_stmt|;
name|u_char
name|reserved2
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|audio_play
range|:
literal|1
decl_stmt|;
comment|/* audio play supported */
name|u_char
name|composite
range|:
literal|1
decl_stmt|;
comment|/* composite audio/video supported */
name|u_char
name|dport1
range|:
literal|1
decl_stmt|;
comment|/* digital audio on port 1 */
name|u_char
name|dport2
range|:
literal|1
decl_stmt|;
comment|/* digital audio on port 2 */
name|u_char
name|mode2_form1
range|:
literal|1
decl_stmt|;
comment|/* mode 2 form 1 (XA) read */
name|u_char
name|mode2_form2
range|:
literal|1
decl_stmt|;
comment|/* mode 2 form 2 format */
name|u_char
name|multisession
range|:
literal|1
decl_stmt|;
comment|/* multi-session photo-CD */
name|u_char
label|:
literal|1
expr_stmt|;
name|u_char
name|cd_da
range|:
literal|1
decl_stmt|;
comment|/* audio-CD read supported */
name|u_char
name|cd_da_stream
range|:
literal|1
decl_stmt|;
comment|/* CD-DA streaming */
name|u_char
name|rw
range|:
literal|1
decl_stmt|;
comment|/* combined R-W subchannels */
name|u_char
name|rw_corr
range|:
literal|1
decl_stmt|;
comment|/* R-W subchannel data corrected */
name|u_char
name|c2
range|:
literal|1
decl_stmt|;
comment|/* C2 error pointers supported */
name|u_char
name|isrc
range|:
literal|1
decl_stmt|;
comment|/* can return the ISRC info */
name|u_char
name|upc
range|:
literal|1
decl_stmt|;
comment|/* can return the catalog number UPC */
name|u_char
label|:
literal|1
expr_stmt|;
name|u_char
name|lock
range|:
literal|1
decl_stmt|;
comment|/* could be locked */
name|u_char
name|locked
range|:
literal|1
decl_stmt|;
comment|/* current lock state */
name|u_char
name|prevent
range|:
literal|1
decl_stmt|;
comment|/* prevent jumper installed */
name|u_char
name|eject
range|:
literal|1
decl_stmt|;
comment|/* can eject */
name|u_char
label|:
literal|1
expr_stmt|;
name|u_char
name|mech
range|:
literal|3
decl_stmt|;
comment|/* loading mechanism type */
define|#
directive|define
name|MECH_CADDY
value|0
define|#
directive|define
name|MECH_TRAY
value|1
define|#
directive|define
name|MECH_POPUP
value|2
define|#
directive|define
name|MECH_CHANGER
value|4
define|#
directive|define
name|MECH_CARTRIDGE
value|5
name|u_char
name|sep_vol
range|:
literal|1
decl_stmt|;
comment|/* independent volume of channels */
name|u_char
name|sep_mute
range|:
literal|1
decl_stmt|;
comment|/* independent mute of channels */
name|u_char
label|:
literal|6
expr_stmt|;
name|u_short
name|max_speed
decl_stmt|;
comment|/* max raw data rate in bytes/1000 */
name|u_short
name|max_vol_levels
decl_stmt|;
comment|/* number of discrete volume levels */
name|u_short
name|buf_size
decl_stmt|;
comment|/* internal buffer size in bytes/1024 */
name|u_short
name|cur_speed
decl_stmt|;
comment|/* current data rate in bytes/1000  */
comment|/* Digital drive output format description (optional?) */
name|u_char
name|reserved3
decl_stmt|;
name|u_char
name|bckf
range|:
literal|1
decl_stmt|;
comment|/* data valid on failing edge of BCK */
name|u_char
name|rch
range|:
literal|1
decl_stmt|;
comment|/* high LRCK indicates left channel */
name|u_char
name|lsbf
range|:
literal|1
decl_stmt|;
comment|/* set if LSB first */
name|u_char
name|dlen
range|:
literal|2
decl_stmt|;
define|#
directive|define
name|DLEN_32
value|0
comment|/* 32 BCKs */
define|#
directive|define
name|DLEN_16
value|1
comment|/* 16 BCKs */
define|#
directive|define
name|DLEN_24
value|2
comment|/* 24 BCKs */
define|#
directive|define
name|DLEN_24_I2S
value|3
comment|/* 24 BCKs (I2S) */
name|u_char
label|:
literal|3
expr_stmt|;
name|u_char
name|reserved4
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|wcd
block|{
name|struct
name|atapi
modifier|*
name|ata
decl_stmt|;
comment|/* Controller structure */
name|int
name|unit
decl_stmt|;
comment|/* IDE bus drive unit */
name|int
name|lun
decl_stmt|;
comment|/* Logical device unit */
name|int
name|flags
decl_stmt|;
comment|/* Device state flags */
name|struct
name|buf
name|queue
decl_stmt|;
comment|/* Queue of i/o requests */
name|struct
name|atapi_params
modifier|*
name|param
decl_stmt|;
comment|/* Drive parameters table */
name|struct
name|toc
name|toc
decl_stmt|;
comment|/* Table of disc contents */
name|struct
name|volinfo
name|info
decl_stmt|;
comment|/* Volume size info */
name|struct
name|audiopage
name|au
decl_stmt|;
comment|/* Audio page info */
name|struct
name|cappage
name|cap
decl_stmt|;
comment|/* Capabilities page info */
name|struct
name|audiopage
name|aumask
decl_stmt|;
comment|/* Audio page mask */
name|struct
name|subchan
name|subchan
decl_stmt|;
comment|/* Subchannel info */
name|struct
name|kern_devconf
name|cf
decl_stmt|;
comment|/* Driver configuration info */
name|char
name|description
index|[
literal|80
index|]
decl_stmt|;
comment|/* Device description */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|wcd
modifier|*
name|wcdtab
index|[
name|NUNIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Drive info by unit number */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wcdnlun
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of configured drives */
end_comment

begin_function_decl
specifier|static
name|void
name|wcd_start
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wcd_done
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|resid
parameter_list|,
name|struct
name|atapires
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wcd_error
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|struct
name|atapires
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wcd_read_toc
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wcd_request_wait
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|u_char
name|a1
parameter_list|,
name|u_char
name|a2
parameter_list|,
name|u_char
name|a3
parameter_list|,
name|u_char
name|a4
parameter_list|,
name|u_char
name|a5
parameter_list|,
name|u_char
name|a6
parameter_list|,
name|u_char
name|a7
parameter_list|,
name|u_char
name|a8
parameter_list|,
name|u_char
name|a9
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wcd_externalize
parameter_list|(
name|struct
name|proc
modifier|*
parameter_list|,
name|struct
name|kern_devconf
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wcd_goaway
parameter_list|(
name|struct
name|kern_devconf
modifier|*
name|kdc
parameter_list|,
name|int
name|force
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wcd_describe
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wcd_setchan
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|u_char
name|c0
parameter_list|,
name|u_char
name|c1
parameter_list|,
name|u_char
name|c2
parameter_list|,
name|u_char
name|c3
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|cftemplate
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"wcd"
block|,
literal|0
block|,
block|{
name|MDDT_DISK
block|,
literal|0
block|}
block|,
name|wcd_externalize
block|,
literal|0
block|,
name|wcd_goaway
block|,
name|DISK_EXTERNALLEN
block|,
literal|0
block|,
literal|0
block|,
name|DC_IDLE
block|,
literal|"ATAPI compact disc"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Dump the array in hexadecimal format for debugging purposes.  */
end_comment

begin_function
specifier|static
name|void
name|wcd_dump
parameter_list|(
name|int
name|lun
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_char
modifier|*
name|p
init|=
name|data
decl_stmt|;
name|printf
argument_list|(
literal|"wcd%d: %s %x"
argument_list|,
name|lun
argument_list|,
name|label
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"-%x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wcd_externalize
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|kern_devconf
modifier|*
name|kdc
parameter_list|,
name|void
modifier|*
name|userp
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|disk_externalize
argument_list|(
name|wcdtab
index|[
name|kdc
operator|->
name|kdc_unit
index|]
operator|->
name|unit
argument_list|,
name|userp
argument_list|,
operator|&
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wcd_goaway
parameter_list|(
name|struct
name|kern_devconf
modifier|*
name|kdc
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|dev_detach
argument_list|(
name|kdc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|wcdattach
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|int
name|unit
parameter_list|,
name|struct
name|atapi_params
modifier|*
name|ap
parameter_list|,
name|int
name|debug
parameter_list|,
name|struct
name|kern_devconf
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|wcd
modifier|*
name|t
decl_stmt|;
name|struct
name|atapires
name|result
decl_stmt|;
if|if
condition|(
name|wcdnlun
operator|>=
name|NUNIT
condition|)
block|{
name|printf
argument_list|(
literal|"wcd: too many units\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wcd
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|printf
argument_list|(
literal|"wcd: out of memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|wcdtab
index|[
name|wcdnlun
index|]
operator|=
name|t
expr_stmt|;
name|bzero
argument_list|(
name|t
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wcd
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|ata
operator|=
name|ata
expr_stmt|;
name|t
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|t
operator|->
name|lun
operator|=
name|wcdnlun
operator|++
expr_stmt|;
name|t
operator|->
name|param
operator|=
name|ap
expr_stmt|;
name|t
operator|->
name|flags
operator|=
name|F_MEDIA_CHANGED
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|t
operator|->
name|flags
operator||=
name|F_DEBUG
expr_stmt|;
comment|/* Print params. */
name|wcd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"info"
argument_list|,
name|ap
argument_list|,
sizeof|sizeof
expr|*
name|ap
argument_list|)
expr_stmt|;
block|}
comment|/* Get drive capabilities. */
name|result
operator|=
name|atapi_request_immediate
argument_list|(
name|ata
argument_list|,
name|unit
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|CAP_PAGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|cap
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do it twice to avoid the stale media changed state. */
if|if
condition|(
name|result
operator|.
name|code
operator|==
name|RES_ERR
operator|&&
operator|(
name|result
operator|.
name|error
operator|&
name|AER_SKEY
operator|)
operator|==
name|AER_SK_UNIT_ATTENTION
condition|)
name|result
operator|=
name|atapi_request_immediate
argument_list|(
name|ata
argument_list|,
name|unit
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|CAP_PAGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|cap
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some drives have shorter capabilities page. */
if|if
condition|(
name|result
operator|.
name|code
operator|==
name|RES_UNDERRUN
condition|)
name|result
operator|.
name|code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|code
operator|==
literal|0
condition|)
block|{
name|wcd_describe
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|wcd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"cap"
argument_list|,
operator|&
name|t
operator|->
name|cap
argument_list|,
sizeof|sizeof
name|t
operator|->
name|cap
argument_list|)
expr_stmt|;
block|}
comment|/* Register driver */
name|t
operator|->
name|cf
operator|=
name|cftemplate
expr_stmt|;
name|t
operator|->
name|cf
operator|.
name|kdc_unit
operator|=
name|t
operator|->
name|lun
expr_stmt|;
name|t
operator|->
name|cf
operator|.
name|kdc_parent
operator|=
name|parent
expr_stmt|;
name|t
operator|->
name|cf
operator|.
name|kdc_description
operator|=
name|t
operator|->
name|description
expr_stmt|;
name|strcpy
argument_list|(
name|t
operator|->
name|description
argument_list|,
name|cftemplate
operator|.
name|kdc_description
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|t
operator|->
name|description
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|t
operator|->
name|description
operator|+
name|strlen
argument_list|(
name|t
operator|->
name|description
argument_list|)
argument_list|,
name|ap
operator|->
name|model
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|t
operator|->
name|cf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wcd_describe
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|)
block|{
name|char
modifier|*
name|m
decl_stmt|;
name|t
operator|->
name|cap
operator|.
name|max_speed
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|cap
operator|.
name|max_speed
argument_list|)
expr_stmt|;
name|t
operator|->
name|cap
operator|.
name|max_vol_levels
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|cap
operator|.
name|max_vol_levels
argument_list|)
expr_stmt|;
name|t
operator|->
name|cap
operator|.
name|buf_size
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|cap
operator|.
name|buf_size
argument_list|)
expr_stmt|;
name|t
operator|->
name|cap
operator|.
name|cur_speed
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|cap
operator|.
name|cur_speed
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wcd%d: "
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|cur_speed
operator|!=
name|t
operator|->
name|cap
operator|.
name|max_speed
condition|)
name|printf
argument_list|(
literal|"%d/"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|cur_speed
operator|*
literal|1000
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%dKb/sec"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|max_speed
operator|*
literal|1000
operator|/
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|buf_size
condition|)
name|printf
argument_list|(
literal|", %dKb cache"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|audio_play
condition|)
name|printf
argument_list|(
literal|", audio play"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|max_vol_levels
condition|)
name|printf
argument_list|(
literal|", %d volume levels"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|max_vol_levels
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|cap
operator|.
name|mech
condition|)
block|{
default|default:
name|m
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|MECH_CADDY
case|:
name|m
operator|=
literal|"caddy"
expr_stmt|;
break|break;
case|case
name|MECH_TRAY
case|:
name|m
operator|=
literal|"tray"
expr_stmt|;
break|break;
case|case
name|MECH_POPUP
case|:
name|m
operator|=
literal|"popup"
expr_stmt|;
break|break;
case|case
name|MECH_CHANGER
case|:
name|m
operator|=
literal|"changer"
expr_stmt|;
break|break;
case|case
name|MECH_CARTRIDGE
case|:
name|m
operator|=
literal|"cartridge"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m
condition|)
name|printf
argument_list|(
literal|", %s%s"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|eject
condition|?
literal|"ejectable "
else|:
literal|""
argument_list|,
name|m
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|eject
condition|)
name|printf
argument_list|(
literal|", eject"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wcd%d: "
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|cap
operator|.
name|medium_type
condition|)
block|{
case|case
name|MDT_UNKNOWN
case|:
name|printf
argument_list|(
literal|"medium type unknown"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_DATA_120
case|:
name|printf
argument_list|(
literal|"120mm data disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_AUDIO_120
case|:
name|printf
argument_list|(
literal|"120mm audio disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_COMB_120
case|:
name|printf
argument_list|(
literal|"120mm data/audio disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_PHOTO_120
case|:
name|printf
argument_list|(
literal|"120mm photo disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_DATA_80
case|:
name|printf
argument_list|(
literal|"80mm data disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_AUDIO_80
case|:
name|printf
argument_list|(
literal|"80mm audio disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_COMB_80
case|:
name|printf
argument_list|(
literal|"80mm data/audio disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_PHOTO_80
case|:
name|printf
argument_list|(
literal|"80mm photo disc loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_NO_DISC
case|:
name|printf
argument_list|(
literal|"no disc inside"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_DOOR_OPEN
case|:
name|printf
argument_list|(
literal|"door open"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_FMT_ERROR
case|:
name|printf
argument_list|(
literal|"medium format error"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"medium type=0x%x"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|medium_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|lock
condition|)
name|printf
argument_list|(
name|t
operator|->
name|cap
operator|.
name|locked
condition|?
literal|", locked"
else|:
literal|", unlocked"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|prevent
condition|)
name|printf
argument_list|(
literal|", lock protected"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|wcdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|lun
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|wcd
modifier|*
name|t
decl_stmt|;
name|struct
name|atapires
name|result
decl_stmt|;
comment|/* Check the unit is legal. */
if|if
condition|(
name|lun
operator|>=
name|wcdnlun
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|t
operator|=
name|wcdtab
index|[
name|lun
index|]
expr_stmt|;
comment|/* If already opened, that's all. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_OPEN
condition|)
block|{
comment|/* If it's been invalidated, forbid re-entry. 		 * (may have changed media) */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* On the first open: check for the media. 	 * Do it twice to avoid the stale media changed state. */
name|result
operator|=
name|atapi_request_wait
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|ATAPI_TEST_UNIT_READY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|code
operator|==
name|RES_ERR
operator|&&
operator|(
name|result
operator|.
name|error
operator|&
name|AER_SKEY
operator|)
operator|==
name|AER_SK_UNIT_ATTENTION
condition|)
block|{
name|t
operator|->
name|flags
operator||=
name|F_MEDIA_CHANGED
expr_stmt|;
name|result
operator|=
name|atapi_request_wait
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|ATAPI_TEST_UNIT_READY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|code
condition|)
block|{
name|wcd_error
argument_list|(
name|t
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Read table of contents. */
if|if
condition|(
name|wcd_read_toc
argument_list|(
name|t
argument_list|)
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
operator|&
name|t
operator|->
name|toc
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|toc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read disc capacity. */
if|if
condition|(
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_READ_CAPACITY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|info
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|info
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
operator|&
name|t
operator|->
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|info
operator|.
name|volsize
operator|=
name|ntohl
argument_list|(
name|t
operator|->
name|info
operator|.
name|volsize
argument_list|)
expr_stmt|;
name|t
operator|->
name|info
operator|.
name|blksize
operator|=
name|ntohl
argument_list|(
name|t
operator|->
name|info
operator|.
name|blksize
argument_list|)
expr_stmt|;
comment|/* Print the disc description string on every disc change. 	 * It would help to track the history of disc changes. */
if|if
condition|(
name|t
operator|->
name|info
operator|.
name|volsize
operator|&&
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
operator|&&
operator|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
operator|)
operator|&&
operator|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"wcd%d: "
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|toc
operator|.
name|tab
index|[
literal|0
index|]
operator|.
name|control
operator|&
literal|4
condition|)
name|printf
argument_list|(
literal|"%ldMB "
argument_list|,
name|t
operator|->
name|info
operator|.
name|volsize
operator|/
literal|512
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%ld:%ld audio "
argument_list|,
name|t
operator|->
name|info
operator|.
name|volsize
operator|/
literal|75
operator|/
literal|60
argument_list|,
name|t
operator|->
name|info
operator|.
name|volsize
operator|/
literal|75
operator|%
literal|60
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%ld sectors), %d tracks\n"
argument_list|,
name|t
operator|->
name|info
operator|.
name|volsize
argument_list|,
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
operator|-
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|starting_track
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Lock the media. */
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|F_MEDIA_CHANGED
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|F_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the device.  Only called if we are the LAST  * occurence of an open device.  */
end_comment

begin_function
name|int
name|wcdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|lun
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|wcd
modifier|*
name|t
init|=
name|wcdtab
index|[
name|lun
index|]
decl_stmt|;
comment|/* If we were the last open of the entire device, release it. */
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|F_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually translate the requested transfer into one the physical driver can  * understand. The transfer is described by a buf and will include only one  * physical transfer.  */
end_comment

begin_function
name|void
name|wcdstrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|lun
init|=
name|UNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|struct
name|wcd
modifier|*
name|t
init|=
name|wcdtab
index|[
name|lun
index|]
decl_stmt|;
name|int
name|x
decl_stmt|;
comment|/* If the device has been made invalid, error out 	 * maybe the media changed. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Can't ever write to a CD. */
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If it's a null transfer, return immediatly. */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Process transfer request. */
name|bp
operator|->
name|b_pblkno
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* Place it in the queue of disk activities for this disk. */
name|disksort
argument_list|(
operator|&
name|t
operator|->
name|queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* Tell the device to get going on the transfer if it's 	 * not doing anything, otherwise just wait for completion. */
name|wcd_start
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look to see if there is a buf waiting for the device  * and that the device is not already busy. If both are true,  * It dequeues the buf and creates an ATAPI command to perform the  * transfer in the buf.  * The bufs are queued by the strategy routine (wcdstrategy).  * Must be called at the correct (splbio) level.  */
end_comment

begin_function
specifier|static
name|void
name|wcd_start
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|t
operator|->
name|queue
operator|.
name|b_actf
decl_stmt|;
name|u_long
name|blkno
decl_stmt|,
name|nblk
decl_stmt|;
comment|/* See if there is a buf to do and we are not already doing one. */
if|if
condition|(
operator|!
name|bp
condition|)
return|return;
comment|/* Unqueue the request. */
name|t
operator|->
name|queue
operator|.
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
comment|/* Should reject all queued entries if media have changed. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We have a buf, now we should make a command 	 * First, translate the block to absolute and put it in terms of the 	 * logical blocksize of the device. 	 * What if something asks for 512 bytes not on a 2k boundary? */
name|blkno
operator|=
name|bp
operator|->
name|b_blkno
operator|/
operator|(
name|SECSIZE
operator|/
literal|512
operator|)
expr_stmt|;
name|nblk
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
operator|(
name|SECSIZE
operator|-
literal|1
operator|)
operator|)
operator|/
name|SECSIZE
expr_stmt|;
name|atapi_request_callback
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|ATAPI_READ_BIG
argument_list|,
literal|0
argument_list|,
name|blkno
operator|>>
literal|24
argument_list|,
name|blkno
operator|>>
literal|16
argument_list|,
name|blkno
operator|>>
literal|8
argument_list|,
name|blkno
argument_list|,
literal|0
argument_list|,
name|nblk
operator|>>
literal|8
argument_list|,
name|nblk
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|wcd_done
argument_list|,
name|t
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|t
operator|->
name|cf
operator|.
name|kdc_state
operator|=
name|DC_BUSY
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wcd_done
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|resid
parameter_list|,
name|struct
name|atapires
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|.
name|code
condition|)
block|{
name|wcd_error
argument_list|(
name|t
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
else|else
name|bp
operator|->
name|b_resid
operator|=
name|resid
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|t
operator|->
name|cf
operator|.
name|kdc_state
operator|=
name|DC_IDLE
expr_stmt|;
name|wcd_start
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wcd_error
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|struct
name|atapires
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|.
name|code
operator|!=
name|RES_ERR
condition|)
return|return;
switch|switch
condition|(
name|result
operator|.
name|error
operator|&
name|AER_SKEY
condition|)
block|{
case|case
name|AER_SK_NOT_READY
case|:
if|if
condition|(
name|result
operator|.
name|error
operator|&
operator|~
name|AER_SKEY
condition|)
block|{
comment|/* Audio disc. */
name|printf
argument_list|(
literal|"wcd%d: cannot read audio disc\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Tray open. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
operator|)
condition|)
name|printf
argument_list|(
literal|"wcd%d: tray open\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|F_MEDIA_CHANGED
expr_stmt|;
return|return;
case|case
name|AER_SK_UNIT_ATTENTION
case|:
comment|/* Media changed. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
operator|)
condition|)
name|printf
argument_list|(
literal|"wcd%d: media changed\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|F_MEDIA_CHANGED
expr_stmt|;
return|return;
case|case
name|AER_SK_ILLEGAL_REQUEST
case|:
comment|/* Unknown command or invalid command arguments. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|printf
argument_list|(
literal|"wcd%d: invalid command\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"wcd%d: i/o error, status=%b, error=%b\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|,
name|result
operator|.
name|status
argument_list|,
name|ARS_BITS
argument_list|,
name|result
operator|.
name|error
argument_list|,
name|AER_BITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wcd_request_wait
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|u_char
name|a1
parameter_list|,
name|u_char
name|a2
parameter_list|,
name|u_char
name|a3
parameter_list|,
name|u_char
name|a4
parameter_list|,
name|u_char
name|a5
parameter_list|,
name|u_char
name|a6
parameter_list|,
name|u_char
name|a7
parameter_list|,
name|u_char
name|a8
parameter_list|,
name|u_char
name|a9
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|atapires
name|result
decl_stmt|;
name|t
operator|->
name|cf
operator|.
name|kdc_state
operator|=
name|DC_BUSY
expr_stmt|;
name|result
operator|=
name|atapi_request_wait
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|cmd
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|t
operator|->
name|cf
operator|.
name|kdc_state
operator|=
name|DC_IDLE
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|code
condition|)
block|{
name|wcd_error
argument_list|(
name|t
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wcd_play
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|u_char
name|a1
parameter_list|,
name|u_char
name|a2
parameter_list|,
name|u_char
name|a3
parameter_list|,
name|u_char
name|a4
parameter_list|,
name|u_char
name|a5
parameter_list|,
name|u_char
name|a6
parameter_list|,
name|u_char
name|a7
parameter_list|,
name|u_char
name|a8
parameter_list|,
name|u_char
name|a9
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|atapires
name|result
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|F_NOPLAYCD
operator|)
condition|)
block|{
name|t
operator|->
name|cf
operator|.
name|kdc_state
operator|=
name|DC_BUSY
expr_stmt|;
name|result
operator|=
name|atapi_request_wait
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|ATAPI_PLAY_CD
argument_list|,
name|cmd
operator|==
name|ATAPI_PLAY_MSF
condition|?
literal|2
else|:
literal|0
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|t
operator|->
name|cf
operator|.
name|kdc_state
operator|=
name|DC_IDLE
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|code
operator|==
name|RES_ERR
operator|&&
operator|(
name|result
operator|.
name|error
operator|&
name|AER_SKEY
operator|)
operator|==
name|AER_SK_ILLEGAL_REQUEST
condition|)
block|{
comment|/* Some drives don't support a PLAY_CD command. 			 * Remember this and use PLAY_MSF instead. */
name|t
operator|->
name|flags
operator||=
name|F_NOPLAYCD
expr_stmt|;
name|result
operator|.
name|code
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|code
condition|)
block|{
name|wcd_error
argument_list|(
name|t
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|cmd
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|lba2msf
parameter_list|(
name|int
name|lba
parameter_list|,
name|u_char
modifier|*
name|m
parameter_list|,
name|u_char
modifier|*
name|s
parameter_list|,
name|u_char
modifier|*
name|f
parameter_list|)
block|{
name|lba
operator|+=
literal|150
expr_stmt|;
comment|/* offset of first logical frame */
name|lba
operator|&=
literal|0xffffff
expr_stmt|;
comment|/* negative lbas use only 24 bits */
operator|*
name|m
operator|=
name|lba
operator|/
operator|(
literal|60
operator|*
literal|75
operator|)
expr_stmt|;
name|lba
operator|%=
operator|(
literal|60
operator|*
literal|75
operator|)
expr_stmt|;
operator|*
name|s
operator|=
name|lba
operator|/
literal|75
expr_stmt|;
operator|*
name|f
operator|=
name|lba
operator|%
literal|75
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform special action on behalf of the user.  * Knows about the internals of this device  */
end_comment

begin_function
name|int
name|wcdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|lun
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|wcd
modifier|*
name|t
init|=
name|wcdtab
index|[
name|lun
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* If the device is not valid.. abandon ship.  */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
case|case
name|CDIOCSETDEBUG
case|:
if|if
condition|(
name|p
operator|->
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|t
operator|->
name|flags
operator||=
name|F_DEBUG
expr_stmt|;
name|atapi_debug
argument_list|(
name|t
operator|->
name|ata
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CDIOCCLRDEBUG
case|:
if|if
condition|(
name|p
operator|->
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|F_DEBUG
expr_stmt|;
name|atapi_debug
argument_list|(
name|t
operator|->
name|ata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CDIOCRESUME
case|:
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PAUSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCPAUSE
case|:
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PAUSE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCSTART
case|:
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_START_STOP
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCSTOP
case|:
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_START_STOP
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCALLOW
case|:
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCPREVENT
case|:
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCRESET
case|:
if|if
condition|(
name|p
operator|->
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_TEST_UNIT_READY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCEJECT
case|:
comment|/* Stop the disc. */
name|error
operator|=
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_START_STOP
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Give it some time to stop spinning. */
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PRIBIO
argument_list|,
literal|"wcdejct"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PRIBIO
argument_list|,
literal|"wcdejct"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Eject. */
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_START_STOP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOREADTOCHEADER
case|:
if|if
condition|(
operator|!
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|t
operator|->
name|toc
operator|.
name|hdr
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
name|t
operator|->
name|toc
operator|.
name|hdr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOREADTOCENTRYS
case|:
block|{
name|struct
name|ioc_read_toc_entry
modifier|*
name|te
init|=
operator|(
expr|struct
name|ioc_read_toc_entry
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|toc
modifier|*
name|toc
init|=
operator|&
name|t
operator|->
name|toc
decl_stmt|;
name|struct
name|toc
name|buf
decl_stmt|;
name|u_long
name|len
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|te
operator|->
name|starting_track
operator|<
name|toc
operator|->
name|hdr
operator|.
name|starting_track
operator|||
name|te
operator|->
name|starting_track
operator|>
name|toc
operator|->
name|hdr
operator|.
name|ending_track
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|len
operator|=
operator|(
name|toc
operator|->
name|hdr
operator|.
name|ending_track
operator|-
name|te
operator|->
name|starting_track
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|toc
operator|->
name|tab
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|te
operator|->
name|data_len
operator|<
name|len
condition|)
name|len
operator|=
name|te
operator|->
name|data_len
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Convert to MSF format, if needed. */
if|if
condition|(
name|te
operator|->
name|address_format
operator|==
name|CD_MSF_FORMAT
condition|)
block|{
name|struct
name|cd_toc_entry
modifier|*
name|e
decl_stmt|;
name|buf
operator|=
name|t
operator|->
name|toc
expr_stmt|;
name|toc
operator|=
operator|&
name|buf
expr_stmt|;
name|e
operator|=
name|toc
operator|->
name|tab
operator|+
name|toc
operator|->
name|hdr
operator|.
name|ending_track
operator|-
name|te
operator|->
name|starting_track
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|--
name|e
operator|>=
name|toc
operator|->
name|tab
condition|)
name|lba2msf
argument_list|(
name|e
operator|->
name|addr
operator|.
name|lba
argument_list|,
operator|&
name|e
operator|->
name|addr
operator|.
name|msf
operator|.
name|minute
argument_list|,
operator|&
name|e
operator|->
name|addr
operator|.
name|msf
operator|.
name|second
argument_list|,
operator|&
name|e
operator|->
name|addr
operator|.
name|msf
operator|.
name|frame
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copyout
argument_list|(
name|toc
operator|->
name|tab
operator|+
name|te
operator|->
name|starting_track
operator|-
name|toc
operator|->
name|hdr
operator|.
name|starting_track
argument_list|,
name|te
operator|->
name|data
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
case|case
name|CDIOCREADSUBCHANNEL
case|:
block|{
name|struct
name|ioc_read_subchannel
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_read_subchannel
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|cd_sub_channel_info
name|data
decl_stmt|;
name|u_long
name|len
init|=
name|args
operator|->
name|data_len
decl_stmt|;
name|int
name|abslba
decl_stmt|,
name|rellba
decl_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|||
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|cd_sub_channel_header
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_READ_SUBCHANNEL
argument_list|,
literal|0
argument_list|,
literal|0x40
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|subchan
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|subchan
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|subchan
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|subchan
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|wcd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"subchan"
argument_list|,
operator|&
name|t
operator|->
name|subchan
argument_list|,
sizeof|sizeof
name|t
operator|->
name|subchan
argument_list|)
expr_stmt|;
name|abslba
operator|=
name|ntohl
argument_list|(
name|t
operator|->
name|subchan
operator|.
name|abslba
argument_list|)
expr_stmt|;
name|rellba
operator|=
name|ntohl
argument_list|(
name|t
operator|->
name|subchan
operator|.
name|rellba
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|address_format
operator|==
name|CD_MSF_FORMAT
condition|)
block|{
name|lba2msf
argument_list|(
name|abslba
argument_list|,
operator|&
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|minute
argument_list|,
operator|&
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|second
argument_list|,
operator|&
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|frame
argument_list|)
expr_stmt|;
name|lba2msf
argument_list|(
name|rellba
argument_list|,
operator|&
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|minute
argument_list|,
operator|&
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|second
argument_list|,
operator|&
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|frame
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|lba
operator|=
name|abslba
expr_stmt|;
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|lba
operator|=
name|rellba
expr_stmt|;
block|}
name|data
operator|.
name|header
operator|.
name|audio_status
operator|=
name|t
operator|->
name|subchan
operator|.
name|audio_status
expr_stmt|;
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|control
operator|=
name|t
operator|->
name|subchan
operator|.
name|control
operator|&
literal|0xf
expr_stmt|;
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|track_number
operator|=
name|t
operator|->
name|subchan
operator|.
name|track
expr_stmt|;
name|data
operator|.
name|what
operator|.
name|position
operator|.
name|index_number
operator|=
name|t
operator|->
name|subchan
operator|.
name|indx
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|data
argument_list|,
name|args
operator|->
name|data
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
case|case
name|CDIOCPLAYMSF
case|:
block|{
name|struct
name|ioc_play_msf
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_play_msf
operator|*
operator|)
name|addr
decl_stmt|;
return|return
name|wcd_play
argument_list|(
name|t
argument_list|,
name|ATAPI_PLAY_MSF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|args
operator|->
name|start_m
argument_list|,
name|args
operator|->
name|start_s
argument_list|,
name|args
operator|->
name|start_f
argument_list|,
name|args
operator|->
name|end_m
argument_list|,
name|args
operator|->
name|end_s
argument_list|,
name|args
operator|->
name|end_f
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
case|case
name|CDIOCPLAYBLOCKS
case|:
block|{
name|struct
name|ioc_play_blocks
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_play_blocks
operator|*
operator|)
name|addr
decl_stmt|;
return|return
name|wcd_play
argument_list|(
name|t
argument_list|,
name|ATAPI_PLAY_BIG
argument_list|,
literal|0
argument_list|,
name|args
operator|->
name|blk
operator|>>
literal|24
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|blk
operator|>>
literal|16
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|blk
operator|>>
literal|8
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|blk
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|len
operator|>>
literal|24
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|len
operator|>>
literal|16
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|len
operator|>>
literal|8
operator|&
literal|0xff
argument_list|,
name|args
operator|->
name|len
operator|&
literal|0xff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
case|case
name|CDIOCPLAYTRACKS
case|:
block|{
name|struct
name|ioc_play_track
modifier|*
name|args
init|=
operator|(
expr|struct
name|ioc_play_track
operator|*
operator|)
name|addr
decl_stmt|;
name|u_long
name|start
decl_stmt|,
name|len
decl_stmt|;
name|int
name|t1
decl_stmt|,
name|t2
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Ignore index fields, 		 * play from start_track to end_track inclusive. */
if|if
condition|(
name|args
operator|->
name|end_track
operator|<
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
operator|+
literal|1
condition|)
operator|++
name|args
operator|->
name|end_track
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|end_track
operator|>
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
operator|+
literal|1
condition|)
name|args
operator|->
name|end_track
operator|=
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
operator|+
literal|1
expr_stmt|;
name|t1
operator|=
name|args
operator|->
name|start_track
operator|-
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|starting_track
expr_stmt|;
name|t2
operator|=
name|args
operator|->
name|end_track
operator|-
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|starting_track
expr_stmt|;
if|if
condition|(
name|t1
operator|<
literal|0
operator|||
name|t2
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|start
operator|=
name|t
operator|->
name|toc
operator|.
name|tab
index|[
name|t1
index|]
operator|.
name|addr
operator|.
name|lba
expr_stmt|;
name|len
operator|=
name|t
operator|->
name|toc
operator|.
name|tab
index|[
name|t2
index|]
operator|.
name|addr
operator|.
name|lba
operator|-
name|start
expr_stmt|;
return|return
name|wcd_play
argument_list|(
name|t
argument_list|,
name|ATAPI_PLAY_BIG
argument_list|,
literal|0
argument_list|,
name|start
operator|>>
literal|24
operator|&
literal|0xff
argument_list|,
name|start
operator|>>
literal|16
operator|&
literal|0xff
argument_list|,
name|start
operator|>>
literal|8
operator|&
literal|0xff
argument_list|,
name|start
operator|&
literal|0xff
argument_list|,
name|len
operator|>>
literal|24
operator|&
literal|0xff
argument_list|,
name|len
operator|>>
literal|16
operator|&
literal|0xff
argument_list|,
name|len
operator|>>
literal|8
operator|&
literal|0xff
argument_list|,
name|len
operator|&
literal|0xff
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
case|case
name|CDIOCGETVOL
case|:
block|{
name|struct
name|ioc_vol
modifier|*
name|arg
init|=
operator|(
expr|struct
name|ioc_vol
operator|*
operator|)
name|addr
decl_stmt|;
name|error
operator|=
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|AUDIO_PAGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|au
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|wcd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"au"
argument_list|,
operator|&
name|t
operator|->
name|au
argument_list|,
sizeof|sizeof
name|t
operator|->
name|au
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|au
operator|.
name|page_code
operator|!=
name|AUDIO_PAGE
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|arg
operator|->
name|vol
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|0
index|]
operator|.
name|volume
expr_stmt|;
name|arg
operator|->
name|vol
index|[
literal|1
index|]
operator|=
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|1
index|]
operator|.
name|volume
expr_stmt|;
name|arg
operator|->
name|vol
index|[
literal|2
index|]
operator|=
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|volume
expr_stmt|;
name|arg
operator|->
name|vol
index|[
literal|3
index|]
operator|=
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|volume
expr_stmt|;
break|break;
block|}
case|case
name|CDIOCSETVOL
case|:
block|{
name|struct
name|ioc_vol
modifier|*
name|arg
init|=
operator|(
expr|struct
name|ioc_vol
operator|*
operator|)
name|addr
decl_stmt|;
name|error
operator|=
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|AUDIO_PAGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|au
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|wcd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"au"
argument_list|,
operator|&
name|t
operator|->
name|au
argument_list|,
sizeof|sizeof
name|t
operator|->
name|au
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|au
operator|.
name|page_code
operator|!=
name|AUDIO_PAGE
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|error
operator|=
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|AUDIO_PAGE_MASK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|aumask
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|aumask
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|aumask
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|aumask
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|wcd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"mask"
argument_list|,
operator|&
name|t
operator|->
name|aumask
argument_list|,
sizeof|sizeof
name|t
operator|->
name|aumask
argument_list|)
expr_stmt|;
comment|/* Sony-55E requires the data length field to be zeroed. */
name|t
operator|->
name|au
operator|.
name|data_length
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|0
index|]
operator|.
name|channels
operator|=
name|CHANNEL_0
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|1
index|]
operator|.
name|channels
operator|=
name|CHANNEL_1
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|0
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
literal|0
index|]
operator|&
name|t
operator|->
name|aumask
operator|.
name|port
index|[
literal|0
index|]
operator|.
name|volume
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|1
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
literal|1
index|]
operator|&
name|t
operator|->
name|aumask
operator|.
name|port
index|[
literal|1
index|]
operator|.
name|volume
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
literal|2
index|]
operator|&
name|t
operator|->
name|aumask
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|volume
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|volume
operator|=
name|arg
operator|->
name|vol
index|[
literal|3
index|]
operator|&
name|t
operator|->
name|aumask
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|volume
expr_stmt|;
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_MODE_SELECT_BIG
argument_list|,
literal|0x10
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|au
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|)
return|;
block|}
case|case
name|CDIOCSETPATCH
case|:
block|{
name|struct
name|ioc_patch
modifier|*
name|arg
init|=
operator|(
expr|struct
name|ioc_patch
operator|*
operator|)
name|addr
decl_stmt|;
return|return
name|wcd_setchan
argument_list|(
name|t
argument_list|,
name|arg
operator|->
name|patch
index|[
literal|0
index|]
argument_list|,
name|arg
operator|->
name|patch
index|[
literal|1
index|]
argument_list|,
name|arg
operator|->
name|patch
index|[
literal|2
index|]
argument_list|,
name|arg
operator|->
name|patch
index|[
literal|3
index|]
argument_list|)
return|;
block|}
case|case
name|CDIOCSETMONO
case|:
return|return
name|wcd_setchan
argument_list|(
name|t
argument_list|,
name|CHANNEL_0
operator||
name|CHANNEL_1
argument_list|,
name|CHANNEL_0
operator||
name|CHANNEL_1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCSETSTERIO
case|:
return|return
name|wcd_setchan
argument_list|(
name|t
argument_list|,
name|CHANNEL_0
argument_list|,
name|CHANNEL_1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCSETMUTE
case|:
return|return
name|wcd_setchan
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCSETLEFT
case|:
return|return
name|wcd_setchan
argument_list|(
name|t
argument_list|,
name|CHANNEL_0
argument_list|,
name|CHANNEL_0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCSETRIGHT
case|:
return|return
name|wcd_setchan
argument_list|(
name|t
argument_list|,
name|CHANNEL_1
argument_list|,
name|CHANNEL_1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the entire TOC for the disc into our internal buffer.  */
end_comment

begin_function
specifier|static
name|int
name|wcd_read_toc
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|)
block|{
name|int
name|ntracks
decl_stmt|,
name|len
decl_stmt|,
name|i
decl_stmt|;
comment|/* First read just the header, so we know how long the TOC is. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ioc_toc_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_READ_TOC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|len
operator|>>
literal|8
argument_list|,
name|len
operator|&
literal|0xff
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|toc
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|ntracks
operator|=
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|ending_track
operator|-
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|starting_track
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ntracks
operator|<=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|ntracks
operator|>
name|MAXTRK
condition|)
name|ntracks
operator|=
name|MAXTRK
expr_stmt|;
comment|/* Now read the whole schmeer. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ioc_toc_header
argument_list|)
operator|+
operator|(
name|ntracks
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_READ_TOC
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|len
operator|>>
literal|8
argument_list|,
name|len
operator|&
literal|0xff
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|toc
argument_list|,
name|len
argument_list|)
operator|&
literal|0xff
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|len
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|toc
operator|.
name|hdr
operator|.
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ntracks
condition|;
name|i
operator|++
control|)
name|t
operator|->
name|toc
operator|.
name|tab
index|[
name|i
index|]
operator|.
name|addr
operator|.
name|lba
operator|=
name|ntohl
argument_list|(
name|t
operator|->
name|toc
operator|.
name|tab
index|[
name|i
index|]
operator|.
name|addr
operator|.
name|lba
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up the audio channel masks.  */
end_comment

begin_function
specifier|static
name|int
name|wcd_setchan
parameter_list|(
name|struct
name|wcd
modifier|*
name|t
parameter_list|,
name|u_char
name|c0
parameter_list|,
name|u_char
name|c1
parameter_list|,
name|u_char
name|c2
parameter_list|,
name|u_char
name|c3
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|AUDIO_PAGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|au
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|wcd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"au"
argument_list|,
operator|&
name|t
operator|->
name|au
argument_list|,
sizeof|sizeof
name|t
operator|->
name|au
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|au
operator|.
name|page_code
operator|!=
name|AUDIO_PAGE
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Sony-55E requires the data length field to be zeroed. */
name|t
operator|->
name|au
operator|.
name|data_length
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|0
index|]
operator|.
name|channels
operator|=
name|c0
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|1
index|]
operator|.
name|channels
operator|=
name|c1
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|2
index|]
operator|.
name|channels
operator|=
name|c2
expr_stmt|;
name|t
operator|->
name|au
operator|.
name|port
index|[
literal|3
index|]
operator|.
name|channels
operator|=
name|c3
expr_stmt|;
return|return
name|wcd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_MODE_SELECT_BIG
argument_list|,
literal|0x10
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|au
argument_list|,
operator|-
sizeof|sizeof
argument_list|(
name|t
operator|->
name|au
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NWCD&& NWDC&& ATAPI */
end_comment

end_unit

