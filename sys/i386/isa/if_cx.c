begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Cronyx-Sigma adapter driver for FreeBSD.  * Supports PPP/HDLC and Cisco/HDLC protocol in synchronous mode,  * and asyncronous channels with full modem control.  * Keepalive protocol implemented in both Cisco and PPP modes.  *  * Copyright (C) 1994 Cronyx Ltd.  * Author: Serge Vakulenko,<vak@zebub.msk.su>  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations permission to use  * or modify this software as long as this message is kept with the software,  * all derivative works or modified versions.  *  * Version 1.2, Tue Nov 22 18:57:27 MSK 1994  */
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_include
include|#
directive|include
file|"cx.h"
end_include

begin_if
if|#
directive|if
name|NCX
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD__
operator|<
literal|2
end_if

begin_include
include|#
directive|include
file|<machine/pio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|init_func_t
value|void(*)(int)
end_define

begin_define
define|#
directive|define
name|watchdog_func_t
value|void(*)(int)
end_define

begin_define
define|#
directive|define
name|start_func_t
value|void(*)(struct ifnet*)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__bsdi__
end_ifdef

begin_if
if|#
directive|if
name|INET
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<machine/inline.h>
end_include

begin_include
include|#
directive|include
file|<net/if_slvar.h>
end_include

begin_include
include|#
directive|include
file|<net/if_p2p.h>
end_include

begin_define
define|#
directive|define
name|timeout_func_t
value|void(*)()
end_define

begin_define
define|#
directive|define
name|init_func_t
value|int(*)()
end_define

begin_define
define|#
directive|define
name|watchdog_func_t
value|int(*)()
end_define

begin_define
define|#
directive|define
name|start_func_t
value|int(*)()
end_define

begin_struct
struct|struct
name|cxsoftc
block|{
name|struct
name|device
name|dev
decl_stmt|;
comment|/* base device */
name|struct
name|isadev
name|isadev
decl_stmt|;
comment|/* ISA device */
name|struct
name|intrhand
name|intr
decl_stmt|;
comment|/* interrupt vectoring */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if_sppp.h>
end_include

begin_include
include|#
directive|include
file|<machine/cronyx.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/cxreg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|print
parameter_list|(
name|s
parameter_list|)
value|printf s
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|print
parameter_list|(
name|s
parameter_list|)
end_define

begin_comment
comment|/*void*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TXTIMEOUT
value|2
end_define

begin_comment
comment|/* transmit timeout in seconds */
end_comment

begin_define
define|#
directive|define
name|DMABUFSZ
value|(6*256)
end_define

begin_comment
comment|/* buffer size */
end_comment

begin_define
define|#
directive|define
name|PPP_HEADER_LEN
value|4
end_define

begin_comment
comment|/* size of PPP header */
end_comment

begin_comment
comment|/*  * Under BSDI it's possible to use general p2p protocol scheme,  * as well as our own one.  Switching is done via IFF_ALTPHYS flag.  * Our ifnet pointer holds the buffer large enough to contain  * any of sppp and p2p structures.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__bsdi__
end_ifdef

begin_define
define|#
directive|define
name|SPPPSZ
value|(sizeof (struct sppp))
end_define

begin_define
define|#
directive|define
name|P2PSZ
value|(sizeof (struct p2pcom))
end_define

begin_define
define|#
directive|define
name|IFSTRUCTSZ
value|(SPPPSZ>P2PSZ ? SPPPSZ : P2PSZ)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IFSTRUCTSZ
value|(sizeof (struct sppp))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IFNETSZ
value|(sizeof (struct ifnet))
end_define

begin_function_decl
name|int
name|cxoutput
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cxsioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cxinit
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cxstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cxwatchdog
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cxinput
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cxrinta
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cxtinta
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cxmint
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cxtimeout
parameter_list|(
name|caddr_t
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|cx_board_t
name|cxboard
index|[
name|NCX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* adapter state structures */
end_comment

begin_decl_stmt
name|cx_chan_t
modifier|*
name|cxchan
index|[
name|NCX
operator|*
name|NCHAN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* unit to channel struct pointer */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|irq_valid_values
index|[]
init|=
block|{
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|15
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|drq_valid_values
index|[]
init|=
block|{
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|port_valid_values
index|[]
init|=
block|{
literal|0x240
block|,
literal|0x260
block|,
literal|0x280
block|,
literal|0x300
block|,
literal|0x320
block|,
literal|0x380
block|,
literal|0x3a0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__FreeBSD__
operator|>=
literal|2
end_if

begin_decl_stmt
specifier|static
name|char
name|cxdescription
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|kern_devconf
name|kdc_cx
index|[
name|NCX
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"cx"
block|,
literal|0
block|,
block|{
name|MDDT_ISA
block|,
literal|0
block|,
literal|"net"
block|}
block|,
name|isa_generic_externalize
block|,
literal|0
block|,
literal|0
block|,
name|ISA_EXTERNALLEN
block|,
operator|&
name|kdc_isa0
block|,
literal|0
block|,
name|DC_IDLE
block|,
name|cxdescription
block|, }
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Check that the value is contained in the list of correct values.  */
end_comment

begin_function
specifier|static
name|int
name|valid
parameter_list|(
name|unsigned
name|short
name|value
parameter_list|,
name|unsigned
name|short
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
operator|*
name|list
condition|)
if|if
condition|(
name|value
operator|==
operator|*
name|list
operator|++
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print the mbuf chain, for debug purposes only.  */
end_comment

begin_function
specifier|static
name|void
name|printmbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|printf
argument_list|(
literal|"mbuf:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|printf
argument_list|(
literal|" HDR %d:"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|printf
argument_list|(
literal|" EXT:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make an mbuf from data.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|makembuf
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|o
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|len
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|unsigned
name|n
init|=
name|M_TRAILINGSPACE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* Allocate new mbuf. */
name|o
operator|=
name|p
expr_stmt|;
name|MGET
argument_list|(
name|p
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|p
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|p
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|m_next
operator|=
name|p
expr_stmt|;
name|n
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|buf
argument_list|,
name|mtod
argument_list|(
name|p
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|p
operator|->
name|m_len
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|m_len
operator|+=
name|n
expr_stmt|;
name|buf
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test the presence of the adapter on the given i/o port.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_function
name|int
name|cxprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
name|int
name|unit
init|=
name|id
operator|->
name|id_unit
decl_stmt|;
name|int
name|iobase
init|=
name|id
operator|->
name|id_iobase
decl_stmt|;
name|int
name|irq
init|=
name|id
operator|->
name|id_irq
decl_stmt|;
name|int
name|drq
init|=
name|id
operator|->
name|id_drq
decl_stmt|;
name|int
name|irqnum
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__bsdi__
name|int
name|cxprobe
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|struct
name|cfdata
modifier|*
name|cf
parameter_list|,
name|void
modifier|*
name|aux
parameter_list|)
block|{
name|int
name|unit
init|=
name|cf
operator|->
name|cf_unit
decl_stmt|;
name|int
name|iobase
init|=
operator|(
operator|(
expr|struct
name|isa_attach_args
operator|*
operator|)
name|aux
operator|)
operator|->
name|ia_iobase
decl_stmt|;
name|int
name|irq
init|=
operator|(
operator|(
expr|struct
name|isa_attach_args
operator|*
operator|)
name|aux
operator|)
operator|->
name|ia_irq
decl_stmt|;
name|int
name|drq
init|=
operator|(
operator|(
expr|struct
name|isa_attach_args
operator|*
operator|)
name|aux
operator|)
operator|->
name|ia_drq
decl_stmt|;
name|int
name|irqnum
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCX
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|!=
name|unit
operator|&&
name|cxboard
index|[
name|i
index|]
operator|.
name|port
operator|==
name|iobase
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|irq
operator|==
name|IRQUNK
condition|)
block|{
name|irq
operator|=
name|isa_irqalloc
argument_list|(
name|IRQ3
operator||
name|IRQ5
operator||
name|IRQ7
operator||
name|IRQ10
operator||
name|IRQ11
operator||
name|IRQ12
operator||
name|IRQ15
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|irq
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
operator|(
expr|struct
name|isa_attach_args
operator|*
operator|)
name|aux
operator|)
operator|->
name|ia_irq
operator|=
name|irq
expr_stmt|;
block|}
endif|#
directive|endif
name|irqnum
operator|=
name|ffs
argument_list|(
name|irq
argument_list|)
operator|-
literal|1
expr_stmt|;
name|print
argument_list|(
operator|(
literal|"cx%d: probe iobase=0x%x irq=%d drq=%d\n"
operator|,
name|unit
operator|,
name|iobase
operator|,
name|irqnum
operator|,
name|drq
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid
argument_list|(
name|irqnum
argument_list|,
name|irq_valid_values
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: Incorrect IRQ: %d\n"
argument_list|,
name|unit
argument_list|,
name|irqnum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|valid
argument_list|(
name|iobase
argument_list|,
name|port_valid_values
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: Incorrect port address: 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|valid
argument_list|(
name|drq
argument_list|,
name|drq_valid_values
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: Incorrect DMA channel: %d\n"
argument_list|,
name|unit
argument_list|,
name|drq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|cx_probe_board
argument_list|(
name|iobase
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * The adapter is present, initialize the driver structures.  */
ifdef|#
directive|ifdef
name|__FreeBSD__
name|int
name|cxattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
name|int
name|unit
init|=
name|id
operator|->
name|id_unit
decl_stmt|;
name|int
name|iobase
init|=
name|id
operator|->
name|id_iobase
decl_stmt|;
name|int
name|irq
init|=
name|id
operator|->
name|id_irq
decl_stmt|;
name|int
name|drq
init|=
name|id
operator|->
name|id_drq
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__bsdi__
name|void
name|cxattach
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|struct
name|device
modifier|*
name|self
parameter_list|,
name|void
modifier|*
name|aux
parameter_list|)
block|{
name|int
name|unit
init|=
name|self
operator|->
name|dv_unit
decl_stmt|;
name|int
name|iobase
init|=
operator|(
operator|(
expr|struct
name|isa_attach_args
operator|*
operator|)
name|aux
operator|)
operator|->
name|ia_iobase
decl_stmt|;
name|int
name|irq
init|=
operator|(
operator|(
expr|struct
name|isa_attach_args
operator|*
operator|)
name|aux
operator|)
operator|->
name|ia_irq
decl_stmt|;
name|int
name|drq
init|=
operator|(
operator|(
expr|struct
name|isa_attach_args
operator|*
operator|)
name|aux
operator|)
operator|->
name|ia_drq
decl_stmt|;
name|struct
name|cxsoftc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|cxsoftc
operator|*
operator|)
name|self
decl_stmt|;
name|void
name|cxintr
argument_list|(
name|cx_board_t
operator|*
name|b
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|cx_board_t
modifier|*
name|b
init|=
name|cxboard
operator|+
name|unit
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Initialize the board structure. */
name|cx_init
argument_list|(
name|b
argument_list|,
name|unit
argument_list|,
name|iobase
argument_list|,
name|ffs
argument_list|(
name|irq
argument_list|)
operator|-
literal|1
argument_list|,
name|drq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
condition|;
operator|++
name|i
control|)
block|{
name|cx_chan_t
modifier|*
name|c
init|=
name|b
operator|->
name|chan
operator|+
name|i
decl_stmt|;
name|int
name|u
init|=
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|i
decl_stmt|;
name|cxchan
index|[
name|u
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_NONE
condition|)
continue|continue;
comment|/* Allocate the buffer memory. */
name|c
operator|->
name|arbuf
operator|=
name|malloc
argument_list|(
name|DMABUFSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|c
operator|->
name|brbuf
operator|=
name|malloc
argument_list|(
name|DMABUFSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|c
operator|->
name|atbuf
operator|=
name|malloc
argument_list|(
name|DMABUFSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|c
operator|->
name|btbuf
operator|=
name|malloc
argument_list|(
name|DMABUFSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
comment|/* All buffers should be located in lower 16M of memory! */
if|if
condition|(
operator|!
name|c
operator|->
name|arbuf
operator|||
operator|!
name|c
operator|->
name|brbuf
operator|||
operator|!
name|c
operator|->
name|atbuf
operator|||
operator|!
name|c
operator|->
name|btbuf
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d.%d: No memory for channel buffers\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|T_NONE
expr_stmt|;
block|}
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|T_SYNC_RS232
case|:
case|case
name|T_SYNC_V35
case|:
case|case
name|T_SYNC_RS449
case|:
case|case
name|T_UNIV_RS232
case|:
case|case
name|T_UNIV_RS449
case|:
case|case
name|T_UNIV_V35
case|:
name|c
operator|->
name|ifp
operator|=
name|malloc
argument_list|(
name|IFSTRUCTSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|ifp
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d.%d: No memory for ifnet buffer\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|T_NONE
expr_stmt|;
continue|continue;
block|}
name|c
operator|->
name|ifp
operator|->
name|if_unit
operator|=
name|u
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_name
operator|=
literal|"cx"
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_mtu
operator|=
name|PP_MTU
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_ioctl
operator|=
name|cxsioctl
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_start
operator|=
operator|(
name|start_func_t
operator|)
name|cxstart
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_watchdog
operator|=
operator|(
name|watchdog_func_t
operator|)
name|cxwatchdog
expr_stmt|;
comment|/* Init routine is never called by upper level? */
name|c
operator|->
name|ifp
operator|->
name|if_init
operator|=
operator|(
name|init_func_t
operator|)
name|cxinit
expr_stmt|;
name|sppp_attach
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* If BPF is in the kernel, call the attach for it. */
name|bpfattach
argument_list|(
operator|&
name|c
operator|->
name|bpf
argument_list|,
name|c
operator|->
name|ifp
argument_list|,
name|DLT_PPP
argument_list|,
name|PPP_HEADER_LEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Reset the adapter. */
name|cx_setup_board
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Activate the timeout routine. */
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
name|timeout
argument_list|(
operator|(
name|timeout_func_t
operator|)
name|cxtimeout
argument_list|,
literal|0
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD__
operator|>=
literal|2
if|if
condition|(
name|unit
operator|!=
literal|0
condition|)
name|kdc_cx
index|[
name|unit
index|]
operator|=
name|kdc_cx
index|[
literal|0
index|]
expr_stmt|;
name|kdc_cx
index|[
name|unit
index|]
operator|.
name|kdc_unit
operator|=
name|unit
expr_stmt|;
name|kdc_cx
index|[
name|unit
index|]
operator|.
name|kdc_isa
operator|=
name|id
expr_stmt|;
name|sprintf
argument_list|(
name|cxdescription
argument_list|,
literal|"Cronyx-Sigma-%s sync/async serial adapter"
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|kdc_cx
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__FreeBSD__
name|printf
argument_list|(
literal|"cx%d:<Cronyx-%s>\n"
argument_list|,
name|unit
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__bsdi__
name|printf
argument_list|(
literal|":<Cronyx-%s>\n"
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
name|isa_establish
argument_list|(
operator|&
name|sc
operator|->
name|isadev
argument_list|,
operator|&
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|intr
operator|.
name|ih_fun
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|cxintr
expr_stmt|;
name|sc
operator|->
name|intr
operator|.
name|ih_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|b
expr_stmt|;
name|intr_establish
argument_list|(
name|irq
argument_list|,
operator|&
name|sc
operator|->
name|intr
argument_list|,
name|DV_NET
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|struct
name|isa_driver
name|cxdriver
init|=
block|{
name|cxprobe
block|,
name|cxattach
block|,
literal|"cx"
block|}
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__bsdi__
name|struct
name|cfdriver
name|cxcd
init|=
block|{
literal|0
block|,
literal|"cx"
block|,
name|cxprobe
block|,
name|cxattach
block|,
expr|sizeof
operator|(
expr|struct
name|cxsoftc
operator|)
block|}
decl_stmt|;
endif|#
directive|endif
comment|/*  * Process an ioctl request.  */
name|int
name|cxsioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|cx_chan_t
modifier|*
name|c
init|=
name|cxchan
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_NONE
operator|||
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifdef|#
directive|ifdef
name|__bsdi__
if|if
condition|(
name|c
operator|->
name|sopt
operator|.
name|ext
condition|)
block|{
comment|/* Save RUNNING flag. */
name|int
name|running
init|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
decl_stmt|;
name|error
operator|=
name|p2p_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|running
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|sppp_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|cmd
operator|!=
name|SIOCSIFFLAGS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
comment|/* Interface is down and running -- stop it. */
name|cxinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
comment|/* Interface is up and not running -- start it. */
name|cxinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Initialization of interface.  */
name|void
name|cxinit
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|cx_chan_t
modifier|*
name|c
init|=
name|cxchan
index|[
name|unit
index|]
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|int
name|s
decl_stmt|;
name|print
argument_list|(
operator|(
literal|"cx%d.%d: cxinit\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|)
argument_list|)
expr_stmt|;
comment|/* Disable interrupts */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Reset the channel (for sync modes only) */
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
block|{
name|outb
argument_list|(
name|CAR
argument_list|(
name|port
argument_list|)
argument_list|,
name|c
operator|->
name|num
operator|&
literal|3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|STCR
argument_list|(
name|port
argument_list|)
argument_list|,
name|STC_ABORTTX
operator||
name|STC_SNDSPC
argument_list|)
expr_stmt|;
block|}
name|cx_setup_chan
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* The interface is up, start it */
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
if|#
directive|if
name|__FreeBSD__
operator|>=
literal|2
comment|/* Mark the board busy on the first startup. 		 * Never goes idle. */
name|kdc_cx
index|[
name|c
operator|->
name|board
operator|->
name|num
index|]
operator|.
name|kdc_state
operator|=
name|DC_BUSY
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize channel, enable receiver and transmitter */
name|cx_cmd
argument_list|(
name|port
argument_list|,
name|CCR_INITCH
operator||
name|CCR_ENRX
operator||
name|CCR_ENTX
argument_list|)
expr_stmt|;
comment|/* Repeat the command, to avoid the rev.H bug */
name|cx_cmd
argument_list|(
name|port
argument_list|,
name|CCR_INITCH
operator||
name|CCR_ENRX
operator||
name|CCR_ENTX
argument_list|)
expr_stmt|;
comment|/* Start receiver */
name|outw
argument_list|(
name|ARBCNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|DMABUFSZ
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|BSTS_OWN24
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BRBCNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|DMABUFSZ
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|BSTS_OWN24
argument_list|)
expr_stmt|;
comment|/* Raise DTR and RTS */
name|cx_chan_dtr
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cx_chan_rts
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable interrupts */
name|outb
argument_list|(
name|IER
argument_list|(
name|port
argument_list|)
argument_list|,
name|IER_RXD
operator||
name|IER_TXD
argument_list|)
expr_stmt|;
name|cxstart
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|c
operator|->
name|sopt
operator|.
name|ext
condition|)
comment|/* Flush the interface output queue, if it is down */
name|sppp_flush
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*  * Fill transmitter buffer with data.  */
name|void
name|cxput
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|char
name|b
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|,
name|len
decl_stmt|,
name|cnt_port
decl_stmt|,
name|sts_port
decl_stmt|;
comment|/* Choose the buffer. */
if|if
condition|(
name|b
operator|==
literal|'A'
condition|)
block|{
name|buf
operator|=
name|c
operator|->
name|atbuf
expr_stmt|;
name|cnt_port
operator|=
name|ATBCNT
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|sts_port
operator|=
name|ATBSTS
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|c
operator|->
name|btbuf
expr_stmt|;
name|cnt_port
operator|=
name|BTBCNT
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|sts_port
operator|=
name|BTBSTS
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
comment|/* Is it busy? */
if|if
condition|(
name|inb
argument_list|(
name|sts_port
argument_list|)
operator|&
name|BSTS_OWN24
condition|)
block|{
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
comment|/* Get the packet to send. */
ifdef|#
directive|ifdef
name|__bsdi__
if|if
condition|(
name|c
operator|->
name|sopt
operator|.
name|ext
condition|)
block|{
name|struct
name|p2pcom
modifier|*
name|p
init|=
operator|(
expr|struct
name|p2pcom
operator|*
operator|)
name|c
operator|->
name|ifp
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
argument|&p->p2p_isnd
argument_list|,
argument|m
argument_list|)
if|if
condition|(
operator|!
name|m
condition|)
name|IF_DEQUEUE
argument_list|(
argument|&c->ifp->if_snd
argument_list|,
argument|m
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|m
operator|=
name|sppp_dequeue
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|DMABUFSZ
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d.%d: too long packet: %d bytes\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printmbuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|c
operator|->
name|bpf
condition|)
name|bpf_mtap
argument_list|(
name|c
operator|->
name|bpf
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Start transmitter. */
name|outw
argument_list|(
name|cnt_port
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sts_port
argument_list|,
name|BSTS_EOFR
operator||
name|BSTS_INTR
operator||
name|BSTS_OWN24
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"cx%d.%d: enqueue %d bytes to %c\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|,
name|len
argument_list|,
name|buf
operator|==
name|c
operator|->
name|atbuf
condition|?
literal|'A'
else|:
literal|'B'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
block|}
comment|/*  * Start output on interface.  Get another datagram to send  * off of the interface queue, and copy it to the interface  * before starting the output.  */
name|void
name|cxstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|cx_chan_t
modifier|*
name|c
init|=
name|cxchan
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
comment|/* No output if the interface is down. */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
return|return;
comment|/* Set the current channel number. */
name|outb
argument_list|(
name|CAR
argument_list|(
name|port
argument_list|)
argument_list|,
name|c
operator|->
name|num
operator|&
literal|3
argument_list|)
expr_stmt|;
comment|/* Determine the buffer order. */
if|if
condition|(
name|inb
argument_list|(
name|DMABSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|DMABSTS_NTBUF
condition|)
block|{
name|cxput
argument_list|(
name|c
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
name|cxput
argument_list|(
name|c
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cxput
argument_list|(
name|c
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|cxput
argument_list|(
name|c
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
block|}
comment|/* Set up transmit timeout. */
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
name|c
operator|->
name|ifp
operator|->
name|if_timer
operator|=
name|TXTIMEOUT
expr_stmt|;
comment|/* 	 * Enable TXMPTY interrupt, 	 * to catch the case when the second buffer is empty. 	 */
if|if
condition|(
operator|(
name|inb
argument_list|(
name|ATBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
operator|&&
operator|(
name|inb
argument_list|(
name|BTBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
condition|)
block|{
name|outb
argument_list|(
name|IER
argument_list|(
name|port
argument_list|)
argument_list|,
name|IER_RXD
operator||
name|IER_TXD
operator||
name|IER_TXMPTY
argument_list|)
expr_stmt|;
block|}
else|else
name|outb
argument_list|(
name|IER
argument_list|(
name|port
argument_list|)
argument_list|,
name|IER_RXD
operator||
name|IER_TXD
argument_list|)
expr_stmt|;
block|}
comment|/*  * Handle transmit timeouts.  * Recover after lost transmit interrupts.  */
name|void
name|cxwatchdog
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|cx_chan_t
modifier|*
name|c
init|=
name|cxchan
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
block|{
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|cxstart
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Handle receive interrupts, including receive errors and  * receive timeout interrupt.  */
name|void
name|cxrinth
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|,
name|risr
init|=
name|inw
argument_list|(
name|RISR
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
name|print
argument_list|(
operator|(
literal|"cx%d.%d: hdlc receive interrupt, risr=%b, arbsts=%b, brbsts=%b\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|risr
operator|,
name|RISH_BITS
operator|,
name|inb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|,
name|inb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|)
argument_list|)
expr_stmt|;
comment|/* Receive errors. */
if|if
condition|(
name|risr
operator|&
operator|(
name|RIS_BUSERR
operator||
name|RIS_OVERRUN
operator||
name|RISH_CRCERR
operator||
name|RISH_RXABORT
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"cx%d.%d: receive error, risr=%b\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|,
name|risr
argument_list|,
name|RISH_BITS
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
if|if
condition|(
name|risr
operator|&
name|RIS_OVERRUN
condition|)
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_collisions
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|risr
operator|&
name|RIS_EOBUF
condition|)
block|{
comment|/* Handle received data. */
name|len
operator|=
operator|(
name|risr
operator|&
name|RIS_BB
operator|)
condition|?
name|inw
argument_list|(
name|BRBCNT
argument_list|(
name|port
argument_list|)
argument_list|)
else|:
name|inw
argument_list|(
name|ARBCNT
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|DMABUFSZ
condition|)
block|{
comment|/* Fatal error: actual DMA transfer size 			 * exceeds our buffer size.  It could be caused 			 * by incorrectly programmed DMA register or 			 * hardware fault.  Possibly, should panic here. */
name|printf
argument_list|(
literal|"cx%d.%d: panic! DMA buffer overflow: %d bytes\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|risr
operator|&
name|RIS_EOFR
operator|)
condition|)
block|{
comment|/* The received frame does not fit in the DMA buffer. 			 * It could be caused by serial lie noise, 			 * or if the peer has too big MTU. */
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"cx%d.%d: received frame length exceeds MTU, risr=%b\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|,
name|risr
argument_list|,
name|RISH_BITS
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
block|}
else|else
block|{
comment|/* Valid frame received. */
name|print
argument_list|(
operator|(
literal|"cx%d.%d: HDLC: %d bytes received\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|cxinput
argument_list|(
name|c
argument_list|,
operator|(
name|risr
operator|&
name|RIS_BB
operator|)
condition|?
name|c
operator|->
name|brbuf
else|:
name|c
operator|->
name|arbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_ipackets
expr_stmt|;
block|}
block|}
comment|/* Restart receiver. */
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
condition|)
block|{
name|outw
argument_list|(
name|ARBCNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|DMABUFSZ
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|BSTS_OWN24
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
condition|)
block|{
name|outw
argument_list|(
name|BRBCNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|DMABUFSZ
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|BSTS_OWN24
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Handle transmit interrupt.  */
name|int
name|cxtinth
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|unsigned
name|char
name|tisr
init|=
name|inb
argument_list|(
name|TISR
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|teoir
init|=
literal|0
decl_stmt|;
name|print
argument_list|(
operator|(
literal|"cx%d.%d: hdlc transmit interrupt, tisr=%b, atbsts=%b, btbsts=%b\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|tisr
operator|,
name|TIS_BITS
operator|,
name|inb
argument_list|(
name|ATBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|,
name|inb
argument_list|(
name|BTBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tisr
operator|&
operator|(
name|TIS_BUSERR
operator||
name|TIS_UNDERRUN
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"cx%d.%d: transmit error, tisr=%b\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|,
name|tisr
argument_list|,
name|TIS_BITS
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
comment|/* Terminate the failed buffer. */
name|teoir
operator||=
name|TEOI_TERMBUFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tisr
operator|&
operator|(
name|TIS_EOFR
operator|)
condition|)
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_opackets
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|cxstart
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|teoir
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|void
name|cxintr
parameter_list|(
name|int
name|bnum
parameter_list|)
block|{
name|cx_board_t
modifier|*
name|b
init|=
name|cxboard
operator|+
name|bnum
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__bsdi__
name|void
name|cxintr
parameter_list|(
name|cx_board_t
modifier|*
name|b
parameter_list|)
block|{
endif|#
directive|endif
while|while
condition|(
operator|!
operator|(
name|inw
argument_list|(
name|BSR
argument_list|(
name|b
operator|->
name|port
argument_list|)
argument_list|)
operator|&
name|BSR_NOINTR
operator|)
condition|)
block|{
comment|/* Acknowledge the interrupt to enter the interrupt context. */
comment|/* Read the local interrupt vector register. */
name|unsigned
name|char
name|livr
init|=
name|inb
argument_list|(
name|IACK
argument_list|(
name|b
operator|->
name|port
argument_list|,
name|BRD_INTR_LEVEL
argument_list|)
argument_list|)
decl_stmt|;
name|cx_chan_t
modifier|*
name|c
init|=
name|b
operator|->
name|chan
operator|+
operator|(
name|livr
operator|>>
literal|2
operator|&
literal|0xf
operator|)
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|unsigned
name|short
name|eoiport
init|=
name|REOIR
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|eoi
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_NONE
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d.%d: unexpected interrupt, livr=0x%x\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|,
name|livr
argument_list|)
expr_stmt|;
continue|continue;
comment|/* incorrect channel number? */
block|}
comment|/* print (("cx%d.%d: interrupt, livr=0x%x\n", 			c->board->num, c->num, livr)); */
comment|/* Clear RTS to stop receiver data flow while we are busy 		 * processing the interrupt, thus avoiding underruns. */
if|if
condition|(
operator|!
name|c
operator|->
name|sopt
operator|.
name|norts
condition|)
block|{
name|outb
argument_list|(
name|MSVR_RTS
argument_list|(
name|port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|rts
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|livr
operator|&
literal|3
condition|)
block|{
case|case
name|LIV_EXCEP
case|:
comment|/* receive exception */
case|case
name|LIV_RXDATA
case|:
comment|/* receive interrupt */
switch|switch
condition|(
name|c
operator|->
name|mode
condition|)
block|{
case|case
name|M_ASYNC
case|:
name|eoi
operator|=
name|cxrinta
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_HDLC
case|:
name|cxrinth
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
comment|/* No bisync and X.21 yet */
block|}
break|break;
case|case
name|LIV_TXDATA
case|:
comment|/* transmit interrupt */
name|eoiport
operator|=
name|TEOIR
argument_list|(
name|port
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|mode
condition|)
block|{
case|case
name|M_ASYNC
case|:
name|cxtinta
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_HDLC
case|:
name|eoi
operator|=
name|cxtinth
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
comment|/* No bisync and X.21 yet */
block|}
break|break;
case|case
name|LIV_MODEM
case|:
comment|/* modem/timer interrupt */
name|eoiport
operator|=
name|MEOIR
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|cxmint
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Raise RTS for this channel if and only if 		 * both receive buffers are empty. */
if|if
condition|(
operator|!
name|c
operator|->
name|sopt
operator|.
name|norts
operator|&&
operator|(
name|inb
argument_list|(
name|CSR
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|CSRA_RXEN
operator|)
operator|&&
operator|(
name|inb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
operator|&&
operator|(
name|inb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
condition|)
block|{
name|outb
argument_list|(
name|MSVR_RTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|MSV_RTS
argument_list|)
expr_stmt|;
name|c
operator|->
name|rts
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Exit from interrupt context. */
name|outb
argument_list|(
name|eoiport
argument_list|,
name|eoi
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Process the received packet.  */
name|void
name|cxinput
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
comment|/* Make an mbuf. */
name|struct
name|mbuf
modifier|*
name|m
init|=
name|makembuf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"cx%d.%d: no memory for packet\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_iqdrops
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|c
operator|->
name|ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printmbuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Check if there's a BPF listener on this interface. 	 * If so, hand off the raw packet to bpf.  	 */
if|if
condition|(
name|c
operator|->
name|bpf
condition|)
name|bpf_tap
argument_list|(
name|c
operator|->
name|bpf
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__bsdi__
if|if
condition|(
name|c
operator|->
name|sopt
operator|.
name|ext
condition|)
block|{
name|struct
name|p2pcom
modifier|*
name|p
init|=
operator|(
expr|struct
name|p2pcom
operator|*
operator|)
name|c
operator|->
name|ifp
decl_stmt|;
call|(
modifier|*
name|p
operator|->
name|p2p_input
call|)
argument_list|(
name|p
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|sppp_input
argument_list|(
name|c
operator|->
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|void
name|cxswitch
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|cx_soft_opt_t
name|new
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__bsdi__
if|if
condition|(
name|new
operator|.
name|ext
operator|&&
operator|!
name|c
operator|->
name|sopt
operator|.
name|ext
condition|)
block|{
comment|/* Switch to external ppp implementation (BSDI) */
name|sppp_detach
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|c
operator|->
name|ifp
operator|+
name|IFNETSZ
argument_list|,
name|IFSTRUCTSZ
operator|-
name|IFNETSZ
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|new
operator|.
name|ext
operator|&&
name|c
operator|->
name|sopt
operator|.
name|ext
condition|)
block|{
comment|/* Switch to built-in ppp implementation */
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|c
operator|->
name|ifp
operator|+
name|IFNETSZ
argument_list|,
name|IFSTRUCTSZ
operator|-
name|IFNETSZ
argument_list|)
expr_stmt|;
name|sppp_attach
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|new
operator|.
name|ext
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|new
operator|.
name|ext
condition|)
block|{
name|struct
name|sppp
modifier|*
name|sp
init|=
operator|(
expr|struct
name|sppp
operator|*
operator|)
name|c
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|new
operator|.
name|cisco
condition|)
name|sp
operator|->
name|pp_flags
operator||=
name|PP_CISCO
expr_stmt|;
else|else
name|sp
operator|->
name|pp_flags
operator|&=
operator|~
name|PP_CISCO
expr_stmt|;
if|if
condition|(
name|new
operator|.
name|keepalive
condition|)
name|sp
operator|->
name|pp_flags
operator||=
name|PP_KEEPALIVE
expr_stmt|;
else|else
name|sp
operator|->
name|pp_flags
operator|&=
operator|~
name|PP_KEEPALIVE
expr_stmt|;
block|}
name|c
operator|->
name|sopt
operator|=
name|new
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCX */
end_comment

end_unit

