begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Cronyx-Sigma adapter driver for FreeBSD.  * Supports PPP/HDLC and Cisco/HDLC protocol in synchronous mode,  * and asyncronous channels with full modem control.  * Keepalive protocol implemented in both Cisco and PPP modes.  *  * Copyright (C) 1994 Cronyx Ltd.  * Author: Serge Vakulenko,<vak@zebub.msk.su>  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations permission to use  * or modify this software as long as this message is kept with the software,  * all derivative works or modified versions.  *  * Version 1.9, Wed Oct  4 18:58:15 MSK 1995  */
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_include
include|#
directive|include
file|"cx.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|"sppp.h"
end_include

begin_if
if|#
directive|if
name|NSPPP
operator|<=
literal|0
end_if

begin_error
error|#
directive|error
error|The device 'cx' requires sppp.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|cdevsw
name|cx_cdevsw
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_define
define|#
directive|define
name|watchdog_func_t
value|void(*)(struct ifnet *)
end_define

begin_define
define|#
directive|define
name|start_func_t
value|void(*)(struct ifnet*)
end_define

begin_include
include|#
directive|include
file|<net/if_sppp.h>
end_include

begin_include
include|#
directive|include
file|<machine/cronyx.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/cxreg.h>
end_include

begin_comment
comment|/* XXX exported. */
end_comment

begin_function_decl
name|void
name|cxswitch
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|cx_soft_opt_t
name|new
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|cxprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|id
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cxattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|id
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cxput
name|__P
argument_list|(
operator|(
name|cx_chan_t
operator|*
name|c
operator|,
name|char
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cxsend
name|__P
argument_list|(
operator|(
name|cx_chan_t
operator|*
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cxrinth
name|__P
argument_list|(
operator|(
name|cx_chan_t
operator|*
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cxtinth
name|__P
argument_list|(
operator|(
name|cx_chan_t
operator|*
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|print
parameter_list|(
name|s
parameter_list|)
value|printf s
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|print
parameter_list|(
name|s
parameter_list|)
value|{
comment|/*void*/
value|}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TXTIMEOUT
value|10
end_define

begin_comment
comment|/* transmit timeout in seconds */
end_comment

begin_define
define|#
directive|define
name|DMABUFSZ
value|(6*256)
end_define

begin_comment
comment|/* buffer size */
end_comment

begin_define
define|#
directive|define
name|PPP_HEADER_LEN
value|4
end_define

begin_comment
comment|/* size of PPP header */
end_comment

begin_comment
comment|/*  * Under BSDI it's possible to use general p2p protocol scheme,  * as well as our own one.  Switching is done via IFF_ALTPHYS flag.  * Our ifnet pointer holds the buffer large enough to contain  * any of sppp and p2p structures.  */
end_comment

begin_define
define|#
directive|define
name|IFSTRUCTSZ
value|(sizeof (struct sppp))
end_define

begin_define
define|#
directive|define
name|IFNETSZ
value|(sizeof (struct ifnet))
end_define

begin_function_decl
specifier|static
name|int
name|cxsioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxinput
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cxrinta
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|cxtinta
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|cxmint
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|timeout_t
name|cxtimeout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|cxdown
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cxup
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|cx_board_t
name|cxboard
index|[
name|NCX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* adapter state structures */
end_comment

begin_decl_stmt
name|cx_chan_t
modifier|*
name|cxchan
index|[
name|NCX
operator|*
name|NCHAN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* unit to channel struct pointer */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|irq_valid_values
index|[]
init|=
block|{
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|15
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|drq_valid_values
index|[]
init|=
block|{
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|port_valid_values
index|[]
init|=
block|{
literal|0x240
block|,
literal|0x260
block|,
literal|0x280
block|,
literal|0x300
block|,
literal|0x320
block|,
literal|0x380
block|,
literal|0x3a0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check that the value is contained in the list of correct values.  */
end_comment

begin_function
specifier|static
name|int
name|valid
parameter_list|(
name|unsigned
name|short
name|value
parameter_list|,
name|unsigned
name|short
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
operator|*
name|list
condition|)
if|if
condition|(
name|value
operator|==
operator|*
name|list
operator|++
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print the mbuf chain, for debug purposes only.  */
end_comment

begin_function
specifier|static
name|void
name|printmbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|printf
argument_list|(
literal|"mbuf:"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|printf
argument_list|(
literal|" HDR %d:"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|printf
argument_list|(
literal|" EXT:"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make an mbuf from data.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|makembuf
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|o
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|len
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|unsigned
name|n
init|=
name|M_TRAILINGSPACE
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* Allocate new mbuf. */
name|o
operator|=
name|p
expr_stmt|;
name|MGET
argument_list|(
name|p
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|p
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|p
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|o
operator|->
name|m_next
operator|=
name|p
expr_stmt|;
name|n
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|len
condition|)
name|n
operator|=
name|len
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|buf
argument_list|,
name|mtod
argument_list|(
name|p
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|p
operator|->
name|m_len
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|->
name|m_len
operator|+=
name|n
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Test the presence of the adapter on the given i/o port.  */
end_comment

begin_function
specifier|static
name|int
name|cxprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
name|int
name|unit
init|=
name|id
operator|->
name|id_unit
decl_stmt|;
name|int
name|iobase
init|=
name|id
operator|->
name|id_iobase
decl_stmt|;
name|int
name|irq
init|=
name|id
operator|->
name|id_irq
decl_stmt|;
name|int
name|drq
init|=
name|id
operator|->
name|id_drq
decl_stmt|;
name|int
name|irqnum
decl_stmt|;
name|irqnum
operator|=
name|ffs
argument_list|(
name|irq
argument_list|)
operator|-
literal|1
expr_stmt|;
name|print
argument_list|(
operator|(
literal|"cx%d: probe iobase=0x%x irq=%d drq=%d\n"
operator|,
name|unit
operator|,
name|iobase
operator|,
name|irqnum
operator|,
name|drq
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid
argument_list|(
name|irqnum
argument_list|,
name|irq_valid_values
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: Incorrect IRQ: %d\n"
argument_list|,
name|unit
argument_list|,
name|irqnum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|valid
argument_list|(
name|iobase
argument_list|,
name|port_valid_values
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: Incorrect port address: 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|valid
argument_list|(
name|drq
argument_list|,
name|drq_valid_values
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d: Incorrect DMA channel: %d\n"
argument_list|,
name|unit
argument_list|,
name|drq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|cx_probe_board
argument_list|(
name|iobase
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The adapter is present, initialize the driver structures.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|cx_devfs_token
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|cxattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
name|int
name|unit
init|=
name|id
operator|->
name|id_unit
decl_stmt|;
name|int
name|iobase
init|=
name|id
operator|->
name|id_iobase
decl_stmt|;
name|int
name|irq
init|=
name|id
operator|->
name|id_irq
decl_stmt|;
name|int
name|drq
init|=
name|id
operator|->
name|id_drq
decl_stmt|;
name|cx_board_t
modifier|*
name|b
init|=
name|cxboard
operator|+
name|unit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sppp
modifier|*
name|sp
decl_stmt|;
comment|/* Initialize the board structure. */
name|cx_init
argument_list|(
name|b
argument_list|,
name|unit
argument_list|,
name|iobase
argument_list|,
name|ffs
argument_list|(
name|irq
argument_list|)
operator|-
literal|1
argument_list|,
name|drq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHAN
condition|;
operator|++
name|i
control|)
block|{
name|cx_chan_t
modifier|*
name|c
init|=
name|b
operator|->
name|chan
operator|+
name|i
decl_stmt|;
name|int
name|u
init|=
name|b
operator|->
name|num
operator|*
name|NCHAN
operator|+
name|i
decl_stmt|;
name|cxchan
index|[
name|u
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_NONE
condition|)
continue|continue;
comment|/* Allocate the buffer memory. */
name|c
operator|->
name|arbuf
operator|=
name|malloc
argument_list|(
name|DMABUFSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|c
operator|->
name|brbuf
operator|=
name|malloc
argument_list|(
name|DMABUFSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|c
operator|->
name|atbuf
operator|=
name|malloc
argument_list|(
name|DMABUFSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|c
operator|->
name|btbuf
operator|=
name|malloc
argument_list|(
name|DMABUFSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
comment|/* All buffers should be located in lower 16M of memory! */
if|if
condition|(
operator|!
name|c
operator|->
name|arbuf
operator|||
operator|!
name|c
operator|->
name|brbuf
operator|||
operator|!
name|c
operator|->
name|atbuf
operator|||
operator|!
name|c
operator|->
name|btbuf
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d.%d: No memory for channel buffers\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|T_NONE
expr_stmt|;
block|}
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|T_SYNC_RS232
case|:
case|case
name|T_SYNC_V35
case|:
case|case
name|T_SYNC_RS449
case|:
case|case
name|T_UNIV_RS232
case|:
case|case
name|T_UNIV_RS449
case|:
case|case
name|T_UNIV_V35
case|:
name|c
operator|->
name|ifp
operator|=
name|malloc
argument_list|(
name|IFSTRUCTSZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|ifp
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d.%d: No memory for ifnet buffer\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|T_NONE
expr_stmt|;
continue|continue;
block|}
name|bzero
argument_list|(
name|c
operator|->
name|ifp
argument_list|,
name|IFSTRUCTSZ
argument_list|)
expr_stmt|;
name|c
operator|->
name|master
operator|=
name|c
operator|->
name|ifp
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_softc
operator|=
name|c
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_unit
operator|=
name|u
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_name
operator|=
literal|"cx"
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_mtu
operator|=
name|PP_MTU
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_ioctl
operator|=
name|cxsioctl
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_start
operator|=
operator|(
name|start_func_t
operator|)
name|cxstart
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_watchdog
operator|=
operator|(
name|watchdog_func_t
operator|)
name|cxwatchdog
expr_stmt|;
comment|/* Init routine is never called by upper level? */
name|sppp_attach
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
expr_stmt|;
comment|/* 			 * Shortcut the sppp tls/tlf actions to up/down 			 * events since our lower layer is always ready. 			 */
name|sp
operator|=
operator|(
expr|struct
name|sppp
operator|*
operator|)
name|c
operator|->
name|ifp
expr_stmt|;
name|sp
operator|->
name|pp_tls
operator|=
name|sp
operator|->
name|pp_up
expr_stmt|;
name|sp
operator|->
name|pp_tlf
operator|=
name|sp
operator|->
name|pp_down
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* If BPF is in the kernel, call the attach for it. */
name|bpfattach
argument_list|(
name|c
operator|->
name|ifp
argument_list|,
name|DLT_PPP
argument_list|,
name|PPP_HEADER_LEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Reset the adapter. */
name|cx_setup_board
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Activate the timeout routine. */
if|if
condition|(
name|unit
operator|==
literal|0
condition|)
name|timeout
argument_list|(
name|cxtimeout
argument_list|,
literal|0
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cx%d:<Cronyx-%s>\n"
argument_list|,
name|unit
argument_list|,
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|cx_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|cx_cdevsw
argument_list|,
literal|0
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"cx"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|isa_driver
name|cxdriver
init|=
block|{
name|cxprobe
block|,
name|cxattach
block|,
literal|"cx"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|cxsioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|cx_chan_t
modifier|*
name|q
decl_stmt|,
modifier|*
name|c
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|,
name|was_up
decl_stmt|,
name|should_be_up
decl_stmt|;
comment|/* 	 * No socket ioctls while the channel is in async mode. 	 */
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_NONE
operator|||
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Socket ioctls on slave subchannels are not allowed. 	 */
if|if
condition|(
name|c
operator|->
name|master
operator|!=
name|c
operator|->
name|ifp
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|was_up
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
expr_stmt|;
name|error
operator|=
name|sppp_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|print
argument_list|(
operator|(
literal|"cxioctl (%d.%d, "
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|print
argument_list|(
operator|(
literal|"0x%x)\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SIOCADDMULTI
case|:
name|print
argument_list|(
operator|(
literal|"SIOCADDMULTI)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SIOCDELMULTI
case|:
name|print
argument_list|(
operator|(
literal|"SIOCDELMULTI)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SIOCSIFFLAGS
case|:
name|print
argument_list|(
operator|(
literal|"SIOCSIFFLAGS)\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
name|print
argument_list|(
operator|(
literal|"SIOCSIFADDR)\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* We get here only in case of SIFFLAGS or SIFADDR. */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|should_be_up
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|was_up
operator|&&
name|should_be_up
condition|)
block|{
comment|/* Interface goes up -- start it. */
name|cxup
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Start all slave subchannels. */
for|for
control|(
name|q
operator|=
name|c
operator|->
name|slaveq
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|slaveq
control|)
name|cxup
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|cxstart
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|was_up
operator|&&
operator|!
name|should_be_up
condition|)
block|{
comment|/* Interface is going down -- stop it. */
name|cxdown
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Stop all slave subchannels. */
for|for
control|(
name|q
operator|=
name|c
operator|->
name|slaveq
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|slaveq
control|)
name|cxdown
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* Flush the interface output queue */
if|if
condition|(
operator|!
name|c
operator|->
name|sopt
operator|.
name|ext
condition|)
name|sppp_flush
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop the interface.  Called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|cxdown
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|print
argument_list|(
operator|(
literal|"cx%d.%d: cxdown\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|)
argument_list|)
expr_stmt|;
comment|/* The interface is down, stop it */
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* Reset the channel (for sync modes only) */
name|outb
argument_list|(
name|CAR
argument_list|(
name|port
argument_list|)
argument_list|,
name|c
operator|->
name|num
operator|&
literal|3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|STCR
argument_list|(
name|port
argument_list|)
argument_list|,
name|STC_ABORTTX
operator||
name|STC_SNDSPC
argument_list|)
expr_stmt|;
name|cx_setup_chan
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start the interface.  Called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|cxup
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
comment|/* The interface is up, start it */
name|print
argument_list|(
operator|(
literal|"cx%d.%d: cxup\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|)
argument_list|)
expr_stmt|;
comment|/* Initialize channel, enable receiver and transmitter */
name|cx_cmd
argument_list|(
name|port
argument_list|,
name|CCR_INITCH
operator||
name|CCR_ENRX
operator||
name|CCR_ENTX
argument_list|)
expr_stmt|;
comment|/* Repeat the command, to avoid the rev.H bug */
name|cx_cmd
argument_list|(
name|port
argument_list|,
name|CCR_INITCH
operator||
name|CCR_ENRX
operator||
name|CCR_ENTX
argument_list|)
expr_stmt|;
comment|/* Start receiver */
name|outw
argument_list|(
name|ARBCNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|DMABUFSZ
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|BSTS_OWN24
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BRBCNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|DMABUFSZ
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|BSTS_OWN24
argument_list|)
expr_stmt|;
comment|/* Raise DTR and RTS */
name|cx_chan_dtr
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cx_chan_rts
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable interrupts */
name|outb
argument_list|(
name|IER
argument_list|(
name|port
argument_list|)
argument_list|,
name|IER_RXD
operator||
name|IER_TXD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fill transmitter buffer with data.  */
end_comment

begin_function
specifier|static
name|void
name|cxput
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|char
name|b
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|,
name|len
decl_stmt|,
name|cnt_port
decl_stmt|,
name|sts_port
decl_stmt|;
comment|/* Choose the buffer. */
if|if
condition|(
name|b
operator|==
literal|'A'
condition|)
block|{
name|buf
operator|=
name|c
operator|->
name|atbuf
expr_stmt|;
name|cnt_port
operator|=
name|ATBCNT
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|sts_port
operator|=
name|ATBSTS
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|c
operator|->
name|btbuf
expr_stmt|;
name|cnt_port
operator|=
name|BTBCNT
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|sts_port
operator|=
name|BTBSTS
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
comment|/* Is it busy? */
if|if
condition|(
name|inb
argument_list|(
name|sts_port
argument_list|)
operator|&
name|BSTS_OWN24
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|print
argument_list|(
operator|(
literal|"cx%d.%d: tbuf %c already busy, bsts=%b\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|b
operator|,
name|inb
argument_list|(
name|sts_port
argument_list|)
operator|,
name|BSTS_BITS
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* Get the packet to send. */
name|m
operator|=
name|sppp_dequeue
argument_list|(
name|c
operator|->
name|master
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Count the transmitted bytes to the subchannel, not the master. */
name|c
operator|->
name|master
operator|->
name|if_obytes
operator|-=
name|len
operator|+
literal|3
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_obytes
operator|+=
name|len
operator|+
literal|3
expr_stmt|;
name|c
operator|->
name|stat
operator|->
name|obytes
operator|+=
name|len
operator|+
literal|3
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|DMABUFSZ
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d.%d: too long packet: %d bytes: "
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printmbuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|c
operator|->
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Start transmitter. */
name|outw
argument_list|(
name|cnt_port
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sts_port
argument_list|,
name|BSTS_EOFR
operator||
name|BSTS_INTR
operator||
name|BSTS_OWN24
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|print
argument_list|(
operator|(
literal|"cx%d.%d: enqueue %d bytes to %c\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|len
operator|,
name|buf
operator|==
name|c
operator|->
name|atbuf
condition|?
literal|'A'
else|:
literal|'B'
operator|)
argument_list|)
expr_stmt|;
name|ret
label|:
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on the (slave) interface.  Get another datagram to send  * off of the interface queue, and copy it to the interface  * before starting the output.  */
end_comment

begin_function
specifier|static
name|void
name|cxsend
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|print
argument_list|(
operator|(
literal|"cx%d.%d: cxsend\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|)
argument_list|)
expr_stmt|;
comment|/* No output if the interface is down. */
if|if
condition|(
operator|!
operator|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
return|return;
comment|/* Set the current channel number. */
name|outb
argument_list|(
name|CAR
argument_list|(
name|port
argument_list|)
argument_list|,
name|c
operator|->
name|num
operator|&
literal|3
argument_list|)
expr_stmt|;
comment|/* Determine the buffer order. */
if|if
condition|(
name|inb
argument_list|(
name|DMABSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|DMABSTS_NTBUF
condition|)
block|{
name|cxput
argument_list|(
name|c
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
name|cxput
argument_list|(
name|c
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cxput
argument_list|(
name|c
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|cxput
argument_list|(
name|c
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
block|}
comment|/* Set up transmit timeout. */
if|if
condition|(
name|c
operator|->
name|master
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
name|c
operator|->
name|master
operator|->
name|if_timer
operator|=
name|TXTIMEOUT
expr_stmt|;
comment|/* 	 * Enable TXMPTY interrupt, 	 * to catch the case when the second buffer is empty. 	 */
if|if
condition|(
operator|(
name|inb
argument_list|(
name|ATBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
operator|&&
operator|(
name|inb
argument_list|(
name|BTBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
condition|)
block|{
name|outb
argument_list|(
name|IER
argument_list|(
name|port
argument_list|)
argument_list|,
name|IER_RXD
operator||
name|IER_TXD
operator||
name|IER_TXMPTY
argument_list|)
expr_stmt|;
block|}
else|else
name|outb
argument_list|(
name|IER
argument_list|(
name|port
argument_list|)
argument_list|,
name|IER_RXD
operator||
name|IER_TXD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on the (master) interface and all slave interfaces.  * Always called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|cxstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|cx_chan_t
modifier|*
name|q
decl_stmt|,
modifier|*
name|c
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|print
argument_list|(
operator|(
literal|"cx%d.%d: cxstart\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|)
argument_list|)
expr_stmt|;
comment|/* Start the master subchannel. */
name|cxsend
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* Start all slave subchannels. */
if|if
condition|(
name|c
operator|->
name|slaveq
operator|&&
operator|!
name|sppp_isempty
argument_list|(
name|c
operator|->
name|master
argument_list|)
condition|)
for|for
control|(
name|q
operator|=
name|c
operator|->
name|slaveq
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|slaveq
control|)
if|if
condition|(
operator|(
name|q
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|&&
operator|!
operator|(
name|q
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
condition|)
name|cxsend
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle transmit timeouts.  * Recover after lost transmit interrupts.  * Always called on splimp().  */
end_comment

begin_function
specifier|static
name|void
name|cxwatchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|cx_chan_t
modifier|*
name|q
decl_stmt|,
modifier|*
name|c
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
return|return;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"cx%d.%d: device timeout\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
name|cxdown
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|c
operator|->
name|slaveq
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|slaveq
control|)
name|cxdown
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|cxup
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|c
operator|->
name|slaveq
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|slaveq
control|)
name|cxup
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|cxstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle receive interrupts, including receive errors and  * receive timeout interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|cxrinth
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|,
name|risr
init|=
name|inw
argument_list|(
name|RISR
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Receive errors. */
if|if
condition|(
name|risr
operator|&
operator|(
name|RIS_BUSERR
operator||
name|RIS_OVERRUN
operator||
name|RISH_CRCERR
operator||
name|RISH_RXABORT
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"cx%d.%d: receive error, risr=%b\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|,
name|risr
argument_list|,
name|RISH_BITS
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
operator|++
name|c
operator|->
name|stat
operator|->
name|ierrs
expr_stmt|;
if|if
condition|(
name|risr
operator|&
name|RIS_OVERRUN
condition|)
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_collisions
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|risr
operator|&
name|RIS_EOBUF
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|print
argument_list|(
operator|(
literal|"cx%d.%d: hdlc receive interrupt, risr=%b, arbsts=%b, brbsts=%b\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|risr
operator|,
name|RISH_BITS
operator|,
name|inb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|,
name|inb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|)
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|stat
operator|->
name|ipkts
expr_stmt|;
comment|/* Handle received data. */
name|len
operator|=
operator|(
name|risr
operator|&
name|RIS_BB
operator|)
condition|?
name|inw
argument_list|(
name|BRBCNT
argument_list|(
name|port
argument_list|)
argument_list|)
else|:
name|inw
argument_list|(
name|ARBCNT
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|stat
operator|->
name|ibytes
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|DMABUFSZ
condition|)
block|{
comment|/* Fatal error: actual DMA transfer size 			 * exceeds our buffer size.  It could be caused 			 * by incorrectly programmed DMA register or 			 * hardware fault.  Possibly, should panic here. */
name|printf
argument_list|(
literal|"cx%d.%d: panic! DMA buffer overflow: %d bytes\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|risr
operator|&
name|RIS_EOFR
operator|)
condition|)
block|{
comment|/* The received frame does not fit in the DMA buffer. 			 * It could be caused by serial lie noise, 			 * or if the peer has too big MTU. */
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"cx%d.%d: received frame length exceeds MTU, risr=%b\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|,
name|risr
argument_list|,
name|RISH_BITS
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
block|}
else|else
block|{
comment|/* Valid frame received. */
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|print
argument_list|(
operator|(
literal|"cx%d.%d: hdlc received %d bytes\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|cxinput
argument_list|(
name|c
argument_list|,
operator|(
name|risr
operator|&
name|RIS_BB
operator|)
condition|?
name|c
operator|->
name|brbuf
else|:
name|c
operator|->
name|arbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_ipackets
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"cx%d.%d: unknown hdlc receive interrupt, risr=%b\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|risr
operator|,
name|RISH_BITS
operator|)
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|stat
operator|->
name|ierrs
expr_stmt|;
block|}
comment|/* Restart receiver. */
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
condition|)
block|{
name|outw
argument_list|(
name|ARBCNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|DMABUFSZ
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|BSTS_OWN24
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
condition|)
block|{
name|outw
argument_list|(
name|BRBCNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|DMABUFSZ
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|BSTS_OWN24
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle transmit interrupt.  */
end_comment

begin_function
specifier|static
name|int
name|cxtinth
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|unsigned
name|char
name|tisr
init|=
name|inb
argument_list|(
name|TISR
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|teoir
init|=
literal|0
decl_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ifp
operator|==
name|c
operator|->
name|master
condition|)
name|c
operator|->
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tisr
operator|&
operator|(
name|TIS_BUSERR
operator||
name|TIS_UNDERRUN
operator|)
condition|)
block|{
comment|/* if (c->ifp->if_flags& IFF_DEBUG) */
name|print
argument_list|(
operator|(
literal|"cx%d.%d: transmit error, tisr=%b, atbsts=%b, btbsts=%b\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|tisr
operator|,
name|TIS_BITS
operator|,
name|inb
argument_list|(
name|ATBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|,
name|inb
argument_list|(
name|BTBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|)
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_oerrors
expr_stmt|;
operator|++
name|c
operator|->
name|stat
operator|->
name|oerrs
expr_stmt|;
comment|/* Terminate the failed buffer. */
comment|/* teoir = TEOI_TERMBUFF; */
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|print
argument_list|(
operator|(
literal|"cx%d.%d: hdlc transmit interrupt, tisr=%b, atbsts=%b, btbsts=%b\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|tisr
operator|,
name|TIS_BITS
operator|,
name|inb
argument_list|(
name|ATBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|,
name|inb
argument_list|(
name|BTBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tisr
operator|&
name|TIS_EOFR
condition|)
block|{
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_opackets
expr_stmt|;
operator|++
name|c
operator|->
name|stat
operator|->
name|opkts
expr_stmt|;
block|}
comment|/* Start output on the (sub-) channel. */
name|cxsend
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|teoir
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cxintr
parameter_list|(
name|int
name|bnum
parameter_list|)
block|{
name|cx_board_t
modifier|*
name|b
init|=
name|cxboard
operator|+
name|bnum
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|inw
argument_list|(
name|BSR
argument_list|(
name|b
operator|->
name|port
argument_list|)
argument_list|)
operator|&
name|BSR_NOINTR
operator|)
condition|)
block|{
comment|/* Acknowledge the interrupt to enter the interrupt context. */
comment|/* Read the local interrupt vector register. */
name|unsigned
name|char
name|livr
init|=
name|inb
argument_list|(
name|IACK
argument_list|(
name|b
operator|->
name|port
argument_list|,
name|BRD_INTR_LEVEL
argument_list|)
argument_list|)
decl_stmt|;
name|cx_chan_t
modifier|*
name|c
init|=
name|b
operator|->
name|chan
operator|+
operator|(
name|livr
operator|>>
literal|2
operator|&
literal|0xf
operator|)
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|unsigned
name|short
name|eoiport
init|=
name|REOIR
argument_list|(
name|port
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|eoi
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_NONE
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d.%d: unexpected interrupt, livr=0x%x\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|,
name|livr
argument_list|)
expr_stmt|;
continue|continue;
comment|/* incorrect channel number? */
block|}
comment|/* print (("cx%d.%d: interrupt, livr=0x%x\n", 			c->board->num, c->num, livr)); */
comment|/* Clear RTS to stop receiver data flow while we are busy 		 * processing the interrupt, thus avoiding underruns. */
if|if
condition|(
operator|!
name|c
operator|->
name|sopt
operator|.
name|norts
condition|)
block|{
name|outb
argument_list|(
name|MSVR_RTS
argument_list|(
name|port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|rts
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|livr
operator|&
literal|3
condition|)
block|{
case|case
name|LIV_EXCEP
case|:
comment|/* receive exception */
case|case
name|LIV_RXDATA
case|:
comment|/* receive interrupt */
operator|++
name|c
operator|->
name|stat
operator|->
name|rintr
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|mode
condition|)
block|{
case|case
name|M_ASYNC
case|:
name|eoi
operator|=
name|cxrinta
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_HDLC
case|:
name|cxrinth
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
comment|/* No bisync and X.21 yet */
block|}
break|break;
case|case
name|LIV_TXDATA
case|:
comment|/* transmit interrupt */
operator|++
name|c
operator|->
name|stat
operator|->
name|tintr
expr_stmt|;
name|eoiport
operator|=
name|TEOIR
argument_list|(
name|port
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|mode
condition|)
block|{
case|case
name|M_ASYNC
case|:
name|cxtinta
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_HDLC
case|:
name|eoi
operator|=
name|cxtinth
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
comment|/* No bisync and X.21 yet */
block|}
break|break;
case|case
name|LIV_MODEM
case|:
comment|/* modem/timer interrupt */
operator|++
name|c
operator|->
name|stat
operator|->
name|mintr
expr_stmt|;
name|eoiport
operator|=
name|MEOIR
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|cxmint
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Raise RTS for this channel if and only if 		 * both receive buffers are empty. */
if|if
condition|(
operator|!
name|c
operator|->
name|sopt
operator|.
name|norts
operator|&&
operator|(
name|inb
argument_list|(
name|CSR
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|CSRA_RXEN
operator|)
operator|&&
operator|(
name|inb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
operator|&&
operator|(
name|inb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
condition|)
block|{
name|outb
argument_list|(
name|MSVR_RTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|MSV_RTS
argument_list|)
expr_stmt|;
name|c
operator|->
name|rts
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Exit from interrupt context. */
name|outb
argument_list|(
name|eoiport
argument_list|,
name|eoi
argument_list|)
expr_stmt|;
comment|/* Master channel - start output on all idle subchannels. */
if|if
condition|(
name|c
operator|->
name|master
operator|==
name|c
operator|->
name|ifp
operator|&&
name|c
operator|->
name|slaveq
operator|&&
operator|(
name|livr
operator|&
literal|3
operator|)
operator|==
name|LIV_TXDATA
operator|&&
name|c
operator|->
name|mode
operator|==
name|M_HDLC
operator|&&
operator|!
name|sppp_isempty
argument_list|(
name|c
operator|->
name|ifp
argument_list|)
condition|)
block|{
name|cx_chan_t
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|c
operator|->
name|slaveq
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|slaveq
control|)
if|if
condition|(
operator|(
name|q
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|&&
operator|!
operator|(
name|q
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
condition|)
name|cxsend
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Process the received packet.  */
end_comment

begin_function
specifier|static
name|void
name|cxinput
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
comment|/* Make an mbuf. */
name|struct
name|mbuf
modifier|*
name|m
init|=
name|makembuf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"cx%d.%d: no memory for packet\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|ifp
operator|->
name|if_iqdrops
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|c
operator|->
name|master
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printmbuf
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Check if there's a BPF listener on this interface. 	 * If so, hand off the raw packet to bpf. 	 */
if|if
condition|(
name|c
operator|->
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_tap
argument_list|(
name|c
operator|->
name|ifp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Count the received bytes to the subchannel, not the master. */
name|c
operator|->
name|master
operator|->
name|if_ibytes
operator|-=
name|len
operator|+
literal|3
expr_stmt|;
name|c
operator|->
name|ifp
operator|->
name|if_ibytes
operator|+=
name|len
operator|+
literal|3
expr_stmt|;
name|sppp_input
argument_list|(
name|c
operator|->
name|master
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cxswitch
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|cx_soft_opt_t
name|new
parameter_list|)
block|{
name|new
operator|.
name|ext
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|new
operator|.
name|ext
condition|)
block|{
name|struct
name|sppp
modifier|*
name|sp
init|=
operator|(
expr|struct
name|sppp
operator|*
operator|)
name|c
operator|->
name|ifp
decl_stmt|;
if|if
condition|(
name|new
operator|.
name|cisco
condition|)
name|sp
operator|->
name|pp_flags
operator||=
name|PP_CISCO
expr_stmt|;
else|else
name|sp
operator|->
name|pp_flags
operator|&=
operator|~
name|PP_CISCO
expr_stmt|;
if|if
condition|(
name|new
operator|.
name|keepalive
condition|)
name|sp
operator|->
name|pp_flags
operator||=
name|PP_KEEPALIVE
expr_stmt|;
else|else
name|sp
operator|->
name|pp_flags
operator|&=
operator|~
name|PP_KEEPALIVE
expr_stmt|;
block|}
name|c
operator|->
name|sopt
operator|=
name|new
expr_stmt|;
block|}
end_function

end_unit

