begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  * istallion.c  -- stallion intelligent multiport serial driver.  *  * Copyright (c) 1994-1996 Greg Ungerer (gerg@stallion.oz.au).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Greg Ungerer.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: istallion.c,v 1.19 1998/06/07 17:10:42 dfr Exp $  */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_define
define|#
directive|define
name|TTYDEFCHARS
value|1
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<machine/cdk.h>
end_include

begin_include
include|#
directive|include
file|<machine/comstats.h>
end_include

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Define the version level of the kernel - so we can compile in the  *	appropriate bits of code. By default this will compile for a 2.1  *	level kernel.  */
end_comment

begin_define
define|#
directive|define
name|VFREEBSD
value|220
end_define

begin_if
if|#
directive|if
name|VFREEBSD
operator|>=
literal|220
end_if

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STATIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Define different board types. Not all of the following board types  *	are supported by this driver. But I will use the standard "assigned"  *	board numbers. Currently supported boards are abbreviated as:  *	ECP = EasyConnection 8/64, ONB = ONboard, BBY = Brumby and  *	STAL = Stallion.  */
end_comment

begin_define
define|#
directive|define
name|BRD_UNKNOWN
value|0
end_define

begin_define
define|#
directive|define
name|BRD_STALLION
value|1
end_define

begin_define
define|#
directive|define
name|BRD_BRUMBY4
value|2
end_define

begin_define
define|#
directive|define
name|BRD_ONBOARD2
value|3
end_define

begin_define
define|#
directive|define
name|BRD_ONBOARD
value|4
end_define

begin_define
define|#
directive|define
name|BRD_BRUMBY8
value|5
end_define

begin_define
define|#
directive|define
name|BRD_BRUMBY16
value|6
end_define

begin_define
define|#
directive|define
name|BRD_ONBOARDE
value|7
end_define

begin_define
define|#
directive|define
name|BRD_ONBOARD32
value|9
end_define

begin_define
define|#
directive|define
name|BRD_ONBOARD2_32
value|10
end_define

begin_define
define|#
directive|define
name|BRD_ONBOARDRS
value|11
end_define

begin_define
define|#
directive|define
name|BRD_EASYIO
value|20
end_define

begin_define
define|#
directive|define
name|BRD_ECH
value|21
end_define

begin_define
define|#
directive|define
name|BRD_ECHMC
value|22
end_define

begin_define
define|#
directive|define
name|BRD_ECP
value|23
end_define

begin_define
define|#
directive|define
name|BRD_ECPE
value|24
end_define

begin_define
define|#
directive|define
name|BRD_ECPMC
value|25
end_define

begin_define
define|#
directive|define
name|BRD_ECHPCI
value|26
end_define

begin_define
define|#
directive|define
name|BRD_BRUMBY
value|BRD_BRUMBY4
end_define

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Define important driver limitations.  */
end_comment

begin_define
define|#
directive|define
name|STL_MAXBRDS
value|8
end_define

begin_define
define|#
directive|define
name|STL_MAXPANELS
value|4
end_define

begin_define
define|#
directive|define
name|STL_PORTSPERPANEL
value|16
end_define

begin_define
define|#
directive|define
name|STL_PORTSPERBRD
value|64
end_define

begin_define
define|#
directive|define
name|STL_MAXCHANS
value|STL_PORTSPERBRD
end_define

begin_comment
comment|/*  *	Define the important minor number break down bits. These have been  *	chosen to be "compatable" with the standard sio driver minor numbers.  *	Extra high bits are used to distinguish between boards and also for  *	really high port numbers (> 32).  */
end_comment

begin_define
define|#
directive|define
name|STL_CALLOUTDEV
value|0x80
end_define

begin_define
define|#
directive|define
name|STL_CTRLLOCK
value|0x40
end_define

begin_define
define|#
directive|define
name|STL_CTRLINIT
value|0x20
end_define

begin_define
define|#
directive|define
name|STL_CTRLDEV
value|(STL_CTRLLOCK | STL_CTRLINIT)
end_define

begin_define
define|#
directive|define
name|STL_MEMDEV
value|0x07000000
end_define

begin_define
define|#
directive|define
name|STL_DEFSPEED
value|9600
end_define

begin_define
define|#
directive|define
name|STL_DEFCFLAG
value|(CS8 | CREAD | HUPCL)
end_define

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Define our local driver identity first. Set up stuff to deal with  *	all the local structures required by a serial tty driver.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|stli_drvname
index|[]
init|=
literal|"stli"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|stli_longdrvname
index|[]
init|=
literal|"Stallion Multiport Serial Driver"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
specifier|const
name|stli_drvversion
index|[]
init|=
literal|"1.0.0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stli_nrbrds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stli_doingtimeout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|__file__
init|=
comment|/*__FILE__*/
literal|"istallion.c"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Define some macros to use to class define boards.  */
end_comment

begin_define
define|#
directive|define
name|BRD_ISA
value|0x1
end_define

begin_define
define|#
directive|define
name|BRD_EISA
value|0x2
end_define

begin_define
define|#
directive|define
name|BRD_MCA
value|0x4
end_define

begin_define
define|#
directive|define
name|BRD_PCI
value|0x8
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|stli_stliprobed
index|[
name|STL_MAXBRDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Define a set of structures to hold all the board/panel/port info  *	for our ports. These will be dynamically allocated as required at  *	driver initialization time.  */
end_comment

begin_comment
comment|/*  *	Port and board structures to hold status info about each object.  *	The board structure contains pointers to structures for each port  *	connected to it. Panels are not distinguished here, since  *	communication with the slave board will always be on a per port  *	basis.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|tty
name|tty
decl_stmt|;
name|int
name|portnr
decl_stmt|;
name|int
name|panelnr
decl_stmt|;
name|int
name|brdnr
decl_stmt|;
name|int
name|ioaddr
decl_stmt|;
name|int
name|callout
decl_stmt|;
name|int
name|devnr
decl_stmt|;
name|int
name|dtrwait
decl_stmt|;
name|int
name|dotimestamp
decl_stmt|;
name|int
name|waitopens
decl_stmt|;
name|int
name|hotchar
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|int
name|argsize
decl_stmt|;
name|void
modifier|*
name|argp
decl_stmt|;
name|unsigned
name|int
name|state
decl_stmt|;
name|unsigned
name|int
name|sigs
decl_stmt|;
name|struct
name|termios
name|initintios
decl_stmt|;
name|struct
name|termios
name|initouttios
decl_stmt|;
name|struct
name|termios
name|lockintios
decl_stmt|;
name|struct
name|termios
name|lockouttios
decl_stmt|;
name|struct
name|timeval
name|timestamp
decl_stmt|;
name|asysigs_t
name|asig
decl_stmt|;
name|unsigned
name|long
name|addr
decl_stmt|;
name|unsigned
name|long
name|rxlost
decl_stmt|;
name|unsigned
name|long
name|rxoffset
decl_stmt|;
name|unsigned
name|long
name|txoffset
decl_stmt|;
name|unsigned
name|long
name|pflag
decl_stmt|;
name|unsigned
name|int
name|rxsize
decl_stmt|;
name|unsigned
name|int
name|txsize
decl_stmt|;
name|unsigned
name|char
name|reqidx
decl_stmt|;
name|unsigned
name|char
name|reqbit
decl_stmt|;
name|unsigned
name|char
name|portidx
decl_stmt|;
name|unsigned
name|char
name|portbit
decl_stmt|;
block|}
name|stliport_t
typedef|;
end_typedef

begin_comment
comment|/*  *	Use a structure of function pointers to do board level operations.  *	These include, enable/disable, paging shared memory, interrupting, etc.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|stlibrd
block|{
name|int
name|brdnr
decl_stmt|;
name|int
name|brdtype
decl_stmt|;
name|int
name|unitid
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|nrpanels
decl_stmt|;
name|int
name|nrports
decl_stmt|;
name|int
name|nrdevs
decl_stmt|;
name|unsigned
name|int
name|iobase
decl_stmt|;
name|unsigned
name|long
name|paddr
decl_stmt|;
name|void
modifier|*
name|vaddr
decl_stmt|;
name|int
name|memsize
decl_stmt|;
name|int
name|pagesize
decl_stmt|;
name|int
name|hostoffset
decl_stmt|;
name|int
name|slaveoffset
decl_stmt|;
name|int
name|bitsize
decl_stmt|;
name|int
name|confbits
decl_stmt|;
name|void
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|(
name|struct
name|stlibrd
modifier|*
name|brdp
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|enable
function_decl|)
parameter_list|(
name|struct
name|stlibrd
modifier|*
name|brdp
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|reenable
function_decl|)
parameter_list|(
name|struct
name|stlibrd
modifier|*
name|brdp
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|disable
function_decl|)
parameter_list|(
name|struct
name|stlibrd
modifier|*
name|brdp
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|intr
function_decl|)
parameter_list|(
name|struct
name|stlibrd
modifier|*
name|brdp
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|reset
function_decl|)
parameter_list|(
name|struct
name|stlibrd
modifier|*
name|brdp
parameter_list|)
function_decl|;
name|char
modifier|*
function_decl|(
modifier|*
name|getmemptr
function_decl|)
parameter_list|(
name|struct
name|stlibrd
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
name|int
name|panels
index|[
name|STL_MAXPANELS
index|]
decl_stmt|;
name|int
name|panelids
index|[
name|STL_MAXPANELS
index|]
decl_stmt|;
name|stliport_t
modifier|*
name|ports
index|[
name|STL_PORTSPERBRD
index|]
decl_stmt|;
block|}
name|stlibrd_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|stlibrd_t
modifier|*
name|stli_brds
index|[
name|STL_MAXBRDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stli_shared
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Keep a local char buffer for processing chars into the LD. We  *	do this to avoid copying from the boards shared memory one char  *	at a time.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stli_rxtmplen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|stliport_t
modifier|*
name|stli_rxtmpport
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|stli_rxtmpbuf
index|[
name|TTYHOG
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Define global stats structures. Not used often, and can be re-used  *	for each stats call.  */
end_comment

begin_decl_stmt
specifier|static
name|comstats_t
name|stli_comstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|combrd_t
name|stli_brdstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|asystats_t
name|stli_cdkstats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Per board state flags. Used with the state field of the board struct.  *	Not really much here... All we need to do is keep track of whether  *	the board has been detected, and whether it is actully running a slave  *	or not.  */
end_comment

begin_define
define|#
directive|define
name|BST_FOUND
value|0x1
end_define

begin_define
define|#
directive|define
name|BST_STARTED
value|0x2
end_define

begin_comment
comment|/*  *	Define the set of port state flags. These are marked for internal  *	state purposes only, usually to do with the state of communications  *	with the slave. They need to be updated atomically.  */
end_comment

begin_define
define|#
directive|define
name|ST_INITIALIZING
value|0x1
end_define

begin_define
define|#
directive|define
name|ST_INITIALIZED
value|0x2
end_define

begin_define
define|#
directive|define
name|ST_OPENING
value|0x4
end_define

begin_define
define|#
directive|define
name|ST_CLOSING
value|0x8
end_define

begin_define
define|#
directive|define
name|ST_CMDING
value|0x10
end_define

begin_define
define|#
directive|define
name|ST_RXING
value|0x20
end_define

begin_define
define|#
directive|define
name|ST_TXBUSY
value|0x40
end_define

begin_define
define|#
directive|define
name|ST_DOFLUSHRX
value|0x80
end_define

begin_define
define|#
directive|define
name|ST_DOFLUSHTX
value|0x100
end_define

begin_define
define|#
directive|define
name|ST_DOSIGS
value|0x200
end_define

begin_define
define|#
directive|define
name|ST_GETSIGS
value|0x400
end_define

begin_define
define|#
directive|define
name|ST_DTRWAIT
value|0x800
end_define

begin_comment
comment|/*  *	Define an array of board names as printable strings. Handy for  *	referencing boards when printing trace and stuff.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stli_brdnames
index|[]
init|=
block|{
literal|"Unknown"
block|,
literal|"Stallion"
block|,
literal|"Brumby"
block|,
literal|"ONboard-MC"
block|,
literal|"ONboard"
block|,
literal|"Brumby"
block|,
literal|"Brumby"
block|,
literal|"ONboard-EI"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
literal|"ONboard"
block|,
literal|"ONboard-MC"
block|,
literal|"ONboard-MC"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
literal|"EasyIO"
block|,
literal|"EC8/32-AT"
block|,
literal|"EC8/32-MC"
block|,
literal|"EC8/64-AT"
block|,
literal|"EC8/64-EI"
block|,
literal|"EC8/64-MC"
block|,
literal|"EC8/32-PCI"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Hardware configuration info for ECP boards. These defines apply  *	to the directly accessable io ports of the ECP. There is a set of  *	defines for each ECP board type, ISA, EISA and MCA.  */
end_comment

begin_define
define|#
directive|define
name|ECP_IOSIZE
value|4
end_define

begin_define
define|#
directive|define
name|ECP_MEMSIZE
value|(128 * 1024)
end_define

begin_define
define|#
directive|define
name|ECP_ATPAGESIZE
value|(4 * 1024)
end_define

begin_define
define|#
directive|define
name|ECP_EIPAGESIZE
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|ECP_MCPAGESIZE
value|(4 * 1024)
end_define

begin_define
define|#
directive|define
name|STL_EISAID
value|0x8c4e
end_define

begin_comment
comment|/*  *	Important defines for the ISA class of ECP board.  */
end_comment

begin_define
define|#
directive|define
name|ECP_ATIREG
value|0
end_define

begin_define
define|#
directive|define
name|ECP_ATCONFR
value|1
end_define

begin_define
define|#
directive|define
name|ECP_ATMEMAR
value|2
end_define

begin_define
define|#
directive|define
name|ECP_ATMEMPR
value|3
end_define

begin_define
define|#
directive|define
name|ECP_ATSTOP
value|0x1
end_define

begin_define
define|#
directive|define
name|ECP_ATINTENAB
value|0x10
end_define

begin_define
define|#
directive|define
name|ECP_ATENABLE
value|0x20
end_define

begin_define
define|#
directive|define
name|ECP_ATDISABLE
value|0x00
end_define

begin_define
define|#
directive|define
name|ECP_ATADDRMASK
value|0x3f000
end_define

begin_define
define|#
directive|define
name|ECP_ATADDRSHFT
value|12
end_define

begin_comment
comment|/*  *	Important defines for the EISA class of ECP board.  */
end_comment

begin_define
define|#
directive|define
name|ECP_EIIREG
value|0
end_define

begin_define
define|#
directive|define
name|ECP_EIMEMARL
value|1
end_define

begin_define
define|#
directive|define
name|ECP_EICONFR
value|2
end_define

begin_define
define|#
directive|define
name|ECP_EIMEMARH
value|3
end_define

begin_define
define|#
directive|define
name|ECP_EIENABLE
value|0x1
end_define

begin_define
define|#
directive|define
name|ECP_EIDISABLE
value|0x0
end_define

begin_define
define|#
directive|define
name|ECP_EISTOP
value|0x4
end_define

begin_define
define|#
directive|define
name|ECP_EIEDGE
value|0x00
end_define

begin_define
define|#
directive|define
name|ECP_EILEVEL
value|0x80
end_define

begin_define
define|#
directive|define
name|ECP_EIADDRMASKL
value|0x00ff0000
end_define

begin_define
define|#
directive|define
name|ECP_EIADDRSHFTL
value|16
end_define

begin_define
define|#
directive|define
name|ECP_EIADDRMASKH
value|0xff000000
end_define

begin_define
define|#
directive|define
name|ECP_EIADDRSHFTH
value|24
end_define

begin_define
define|#
directive|define
name|ECP_EIBRDENAB
value|0xc84
end_define

begin_define
define|#
directive|define
name|ECP_EISAID
value|0x4
end_define

begin_comment
comment|/*  *	Important defines for the Micro-channel class of ECP board.  *	(It has a lot in common with the ISA boards.)  */
end_comment

begin_define
define|#
directive|define
name|ECP_MCIREG
value|0
end_define

begin_define
define|#
directive|define
name|ECP_MCCONFR
value|1
end_define

begin_define
define|#
directive|define
name|ECP_MCSTOP
value|0x20
end_define

begin_define
define|#
directive|define
name|ECP_MCENABLE
value|0x80
end_define

begin_define
define|#
directive|define
name|ECP_MCDISABLE
value|0x00
end_define

begin_comment
comment|/*  *	Hardware configuration info for ONboard and Brumby boards. These  *	defines apply to the directly accessable io ports of these boards.  */
end_comment

begin_define
define|#
directive|define
name|ONB_IOSIZE
value|16
end_define

begin_define
define|#
directive|define
name|ONB_MEMSIZE
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|ONB_ATPAGESIZE
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|ONB_MCPAGESIZE
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|ONB_EIMEMSIZE
value|(128 * 1024)
end_define

begin_define
define|#
directive|define
name|ONB_EIPAGESIZE
value|(64 * 1024)
end_define

begin_comment
comment|/*  *	Important defines for the ISA class of ONboard board.  */
end_comment

begin_define
define|#
directive|define
name|ONB_ATIREG
value|0
end_define

begin_define
define|#
directive|define
name|ONB_ATMEMAR
value|1
end_define

begin_define
define|#
directive|define
name|ONB_ATCONFR
value|2
end_define

begin_define
define|#
directive|define
name|ONB_ATSTOP
value|0x4
end_define

begin_define
define|#
directive|define
name|ONB_ATENABLE
value|0x01
end_define

begin_define
define|#
directive|define
name|ONB_ATDISABLE
value|0x00
end_define

begin_define
define|#
directive|define
name|ONB_ATADDRMASK
value|0xff0000
end_define

begin_define
define|#
directive|define
name|ONB_ATADDRSHFT
value|16
end_define

begin_define
define|#
directive|define
name|ONB_HIMEMENAB
value|0x02
end_define

begin_comment
comment|/*  *	Important defines for the EISA class of ONboard board.  */
end_comment

begin_define
define|#
directive|define
name|ONB_EIIREG
value|0
end_define

begin_define
define|#
directive|define
name|ONB_EIMEMARL
value|1
end_define

begin_define
define|#
directive|define
name|ONB_EICONFR
value|2
end_define

begin_define
define|#
directive|define
name|ONB_EIMEMARH
value|3
end_define

begin_define
define|#
directive|define
name|ONB_EIENABLE
value|0x1
end_define

begin_define
define|#
directive|define
name|ONB_EIDISABLE
value|0x0
end_define

begin_define
define|#
directive|define
name|ONB_EISTOP
value|0x4
end_define

begin_define
define|#
directive|define
name|ONB_EIEDGE
value|0x00
end_define

begin_define
define|#
directive|define
name|ONB_EILEVEL
value|0x80
end_define

begin_define
define|#
directive|define
name|ONB_EIADDRMASKL
value|0x00ff0000
end_define

begin_define
define|#
directive|define
name|ONB_EIADDRSHFTL
value|16
end_define

begin_define
define|#
directive|define
name|ONB_EIADDRMASKH
value|0xff000000
end_define

begin_define
define|#
directive|define
name|ONB_EIADDRSHFTH
value|24
end_define

begin_define
define|#
directive|define
name|ONB_EIBRDENAB
value|0xc84
end_define

begin_define
define|#
directive|define
name|ONB_EISAID
value|0x1
end_define

begin_comment
comment|/*  *	Important defines for the Brumby boards. They are pretty simple,  *	there is not much that is programmably configurable.  */
end_comment

begin_define
define|#
directive|define
name|BBY_IOSIZE
value|16
end_define

begin_define
define|#
directive|define
name|BBY_MEMSIZE
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|BBY_PAGESIZE
value|(16 * 1024)
end_define

begin_define
define|#
directive|define
name|BBY_ATIREG
value|0
end_define

begin_define
define|#
directive|define
name|BBY_ATCONFR
value|1
end_define

begin_define
define|#
directive|define
name|BBY_ATSTOP
value|0x4
end_define

begin_comment
comment|/*  *	Important defines for the Stallion boards. They are pretty simple,  *	there is not much that is programmably configurable.  */
end_comment

begin_define
define|#
directive|define
name|STAL_IOSIZE
value|16
end_define

begin_define
define|#
directive|define
name|STAL_MEMSIZE
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|STAL_PAGESIZE
value|(64 * 1024)
end_define

begin_comment
comment|/*  *	Define the set of status register values for EasyConnection panels.  *	The signature will return with the status value for each panel. From  *	this we can determine what is attached to the board - before we have  *	actually down loaded any code to it.  */
end_comment

begin_define
define|#
directive|define
name|ECH_PNLSTATUS
value|2
end_define

begin_define
define|#
directive|define
name|ECH_PNL16PORT
value|0x20
end_define

begin_define
define|#
directive|define
name|ECH_PNLIDMASK
value|0x07
end_define

begin_define
define|#
directive|define
name|ECH_PNLINTRPEND
value|0x80
end_define

begin_comment
comment|/*  *	Define some macros to do things to the board. Even those these boards  *	are somewhat related there is often significantly different ways of  *	doing some operation on it (like enable, paging, reset, etc). So each  *	board class has a set of functions which do the commonly required  *	operations. The macros below basically just call these functions,  *	generally checking for a NULL function - which means that the board  *	needs nothing done to it to achieve this operation!  */
end_comment

begin_define
define|#
directive|define
name|EBRDINIT
parameter_list|(
name|brdp
parameter_list|)
define|\
value|if (brdp->init != NULL)				\ 		(* brdp->init)(brdp)
end_define

begin_define
define|#
directive|define
name|EBRDENABLE
parameter_list|(
name|brdp
parameter_list|)
define|\
value|if (brdp->enable != NULL)			\ 		(* brdp->enable)(brdp);
end_define

begin_define
define|#
directive|define
name|EBRDDISABLE
parameter_list|(
name|brdp
parameter_list|)
define|\
value|if (brdp->disable != NULL)			\ 		(* brdp->disable)(brdp);
end_define

begin_define
define|#
directive|define
name|EBRDINTR
parameter_list|(
name|brdp
parameter_list|)
define|\
value|if (brdp->intr != NULL)				\ 		(* brdp->intr)(brdp);
end_define

begin_define
define|#
directive|define
name|EBRDRESET
parameter_list|(
name|brdp
parameter_list|)
define|\
value|if (brdp->reset != NULL)			\ 		(* brdp->reset)(brdp);
end_define

begin_define
define|#
directive|define
name|EBRDGETMEMPTR
parameter_list|(
name|brdp
parameter_list|,
name|offset
parameter_list|)
define|\
value|(* brdp->getmemptr)(brdp, offset, __LINE__)
end_define

begin_comment
comment|/*  *	Define the maximal baud rate.  */
end_comment

begin_define
define|#
directive|define
name|STL_MAXBAUD
value|230400
end_define

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Define macros to extract a brd and port number from a minor number.  *	This uses the extended minor number range in the upper 2 bytes of  *	the device number. This gives us plenty of minor numbers to play  *	with...  */
end_comment

begin_define
define|#
directive|define
name|MKDEV2BRD
parameter_list|(
name|m
parameter_list|)
value|(((m)& 0x00700000)>> 20)
end_define

begin_define
define|#
directive|define
name|MKDEV2PORT
parameter_list|(
name|m
parameter_list|)
value|(((m)& 0x1f) | (((m)& 0x00010000)>> 11))
end_define

begin_comment
comment|/*  *	Define some handy local macros...  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<= (b)) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Declare all those functions in this driver!  First up is the set of  *	externally visible functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|stliprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stliattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|STATIC
name|d_open_t
name|stliopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|d_close_t
name|stliclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|d_read_t
name|stliread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|d_write_t
name|stliwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|d_ioctl_t
name|stliioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|d_stop_t
name|stlistop
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|VFREEBSD
operator|>=
literal|220
end_if

begin_decl_stmt
name|STATIC
name|d_devtotty_t
name|stlidevtotty
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
name|struct
name|tty
modifier|*
name|stlidevtotty
parameter_list|(
name|dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	Internal function prototypes.  */
end_comment

begin_function_decl
specifier|static
name|stliport_t
modifier|*
name|stli_dev2port
parameter_list|(
name|dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_chksharemem
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_isaprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_eisaprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_mcaprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_brdinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_brdattach
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_initecp
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_initonb
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_initports
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_startbrd
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_poll
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|stli_brdpoll
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
specifier|volatile
name|cdkhdr_t
modifier|*
name|hdrp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|stli_hostcmd
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|stliport_t
modifier|*
name|portp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|stli_dodelaycmd
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|,
specifier|volatile
name|cdkctrl_t
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_mkasysigs
parameter_list|(
name|asysigs_t
modifier|*
name|sp
parameter_list|,
name|int
name|dtr
parameter_list|,
name|int
name|rts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|stli_mktiocm
parameter_list|(
name|unsigned
name|long
name|sigvalue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_rxprocess
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|stliport_t
modifier|*
name|portp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_flush
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_start
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_param
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|tiosp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_ttyoptim
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|struct
name|termios
modifier|*
name|tiosp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_dtrwakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_initopen
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_shutdownclose
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_rawopen
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|,
name|int
name|wait
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_rawclose
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|,
name|int
name|wait
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_cmdwait
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|copyback
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_sendcmd
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|copyback
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_mkasyport
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|asyport_t
modifier|*
name|pp
parameter_list|,
name|struct
name|termios
modifier|*
name|tiosp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_memrw
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_memioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_getbrdstats
parameter_list|(
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_getportstats
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stli_clrportstats
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|stliport_t
modifier|*
name|stli_getport
parameter_list|(
name|int
name|brdnr
parameter_list|,
name|int
name|panelnr
parameter_list|,
name|int
name|portnr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_ecpinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_ecpenable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_ecpdisable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_ecpreset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|stli_ecpgetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_ecpintr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_ecpeiinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_ecpeienable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_ecpeidisable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_ecpeireset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|stli_ecpeigetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_ecpmcenable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_ecpmcdisable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_ecpmcreset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|stli_ecpmcgetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_onbinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_onbenable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_onbdisable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_onbreset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|stli_onbgetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_onbeinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_onbeenable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_onbedisable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_onbereset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|stli_onbegetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_bbyinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_bbyreset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|stli_bbygetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_stalinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stli_stalreset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|stli_stalgetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Declare the driver isa structure.  */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|stlidriver
init|=
block|{
name|stliprobe
block|,
name|stliattach
block|,
name|stli_drvname
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|VFREEBSD
operator|>=
literal|220
end_if

begin_comment
comment|/*  *	FreeBSD-2.2+ kernel linkage.  */
end_comment

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|75
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|stli_cdevsw
init|=
block|{
name|stliopen
block|,
name|stliclose
block|,
name|stliread
block|,
name|stliwrite
block|,
name|stliioctl
block|,
name|stlistop
block|,
name|noreset
block|,
name|stlidevtotty
block|,
name|ttpoll
block|,
name|nommap
block|,
name|NULL
block|,
name|stli_drvname
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|stli_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|stli_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|stli_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|stli_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stli_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|sidev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|stli_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|stlibrd_t
modifier|*
name|stli_brdalloc
parameter_list|(
name|void
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|brdp
operator|=
operator|(
name|stlibrd_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|stlibrd_t
argument_list|)
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: failed to allocate memory (size=%d)\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|stlibrd_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|brdp
argument_list|,
sizeof|sizeof
argument_list|(
name|stlibrd_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|brdp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Find an available internal board number (unit number). The problem  *	is that the same unit numbers can be assigned to different class  *	boards - but we only want to maintain one setup board structures.  */
end_comment

begin_function
specifier|static
name|int
name|stli_findfreeunit
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|STL_MAXBRDS
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stli_brds
index|[
name|i
index|]
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
break|break;
return|return
operator|(
operator|(
name|i
operator|>=
name|STL_MAXBRDS
operator|)
condition|?
operator|-
literal|1
else|:
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Try and determine the ISA board type. Hopefully the board  *	configuration entry will help us out, using the flags field.  *	If not, we may ne be able to determine the board type...  */
end_comment

begin_function
specifier|static
name|int
name|stli_isaprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
block|{
name|int
name|btype
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_isaprobe(idp=%x): unit=%d iobase=%x flags=%x\n"
argument_list|,
operator|(
name|int
operator|)
name|idp
argument_list|,
name|idp
operator|->
name|id_unit
argument_list|,
name|idp
operator|->
name|id_iobase
argument_list|,
name|idp
operator|->
name|id_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|idp
operator|->
name|id_flags
condition|)
block|{
case|case
name|BRD_STALLION
case|:
case|case
name|BRD_BRUMBY4
case|:
case|case
name|BRD_BRUMBY8
case|:
case|case
name|BRD_BRUMBY16
case|:
case|case
name|BRD_ONBOARD
case|:
case|case
name|BRD_ONBOARD32
case|:
case|case
name|BRD_ECP
case|:
name|btype
operator|=
name|idp
operator|->
name|id_flags
expr_stmt|;
break|break;
default|default:
name|btype
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|btype
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Probe for an EISA board type. We should be able to read the EISA ID,  *	that will tell us if a board is present or not...  */
end_comment

begin_function
specifier|static
name|int
name|stli_eisaprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
block|{
name|int
name|btype
decl_stmt|,
name|eid
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_eisaprobe(idp=%x): unit=%d iobase=%x flags=%x\n"
argument_list|,
operator|(
name|int
operator|)
name|idp
argument_list|,
name|idp
operator|->
name|id_unit
argument_list|,
name|idp
operator|->
name|id_iobase
argument_list|,
name|idp
operator|->
name|id_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  *	Firstly check if this is an EISA system. Do this by probing for  *	the system board EISA ID. If this is not an EISA system then  *	don't bother going any further!  */
name|outb
argument_list|(
literal|0xc80
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
literal|0xc80
argument_list|)
operator|==
literal|0xff
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  *	Try and read the EISA ID from the board at specified address.  *	If one is present it will tell us the board type as well.  */
name|outb
argument_list|(
operator|(
name|idp
operator|->
name|id_iobase
operator|+
literal|0xc80
operator|)
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|eid
operator|=
name|inb
argument_list|(
name|idp
operator|->
name|id_iobase
operator|+
literal|0xc80
argument_list|)
expr_stmt|;
name|eid
operator||=
name|inb
argument_list|(
name|idp
operator|->
name|id_iobase
operator|+
literal|0xc81
argument_list|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|eid
operator|!=
name|STL_EISAID
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|btype
operator|=
literal|0
expr_stmt|;
name|eid
operator|=
name|inb
argument_list|(
name|idp
operator|->
name|id_iobase
operator|+
literal|0xc82
argument_list|)
expr_stmt|;
if|if
condition|(
name|eid
operator|==
name|ECP_EISAID
condition|)
name|btype
operator|=
name|BRD_ECPE
expr_stmt|;
elseif|else
if|if
condition|(
name|eid
operator|==
name|ONB_EISAID
condition|)
name|btype
operator|=
name|BRD_ONBOARDE
expr_stmt|;
name|outb
argument_list|(
operator|(
name|idp
operator|->
name|id_iobase
operator|+
literal|0xc84
operator|)
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
return|return
operator|(
name|btype
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Probe for an MCA board type. Not really sure how to do this yet,  *	so for now just use the supplied flag specifier as board type...  */
end_comment

begin_function
specifier|static
name|int
name|stli_mcaprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
block|{
name|int
name|btype
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_mcaprobe(idp=%x): unit=%d iobase=%x flags=%x\n"
argument_list|,
operator|(
name|int
operator|)
name|idp
argument_list|,
name|idp
operator|->
name|id_unit
argument_list|,
name|idp
operator|->
name|id_iobase
argument_list|,
name|idp
operator|->
name|id_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|idp
operator|->
name|id_flags
condition|)
block|{
case|case
name|BRD_ONBOARD2
case|:
case|case
name|BRD_ONBOARD2_32
case|:
case|case
name|BRD_ONBOARDRS
case|:
case|case
name|BRD_ECHMC
case|:
case|case
name|BRD_ECPMC
case|:
name|btype
operator|=
name|idp
operator|->
name|id_flags
expr_stmt|;
break|break;
default|default:
name|btype
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Probe for a board. This is involved, since we need to enable the  *	shared memory region to see if the board is really there or not...  */
end_comment

begin_function
specifier|static
name|int
name|stliprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|int
name|btype
decl_stmt|,
name|bclass
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stliprobe(idp=%x): unit=%d iobase=%x flags=%x\n"
argument_list|,
operator|(
name|int
operator|)
name|idp
argument_list|,
name|idp
operator|->
name|id_unit
argument_list|,
name|idp
operator|->
name|id_iobase
argument_list|,
name|idp
operator|->
name|id_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|idp
operator|->
name|id_unit
operator|>
name|STL_MAXBRDS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  *	First up determine what bus type of board we might be dealing  *	with. It is easy to separate out the ISA from the EISA and MCA  *	boards, based on their IO addresses. We may not be able to tell  *	the EISA and MCA apart on IO address alone...  */
name|bclass
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|idp
operator|->
name|id_iobase
operator|>
literal|0
operator|)
operator|&&
operator|(
name|idp
operator|->
name|id_iobase
operator|<
literal|0x400
operator|)
condition|)
block|{
name|bclass
operator||=
name|BRD_ISA
expr_stmt|;
block|}
else|else
block|{
comment|/* ONboard2 range */
if|if
condition|(
operator|(
name|idp
operator|->
name|id_iobase
operator|>=
literal|0x700
operator|)
operator|&&
operator|(
name|idp
operator|->
name|id_iobase
operator|<
literal|0x900
operator|)
condition|)
name|bclass
operator||=
name|BRD_MCA
expr_stmt|;
comment|/* EC-MCA ranges */
if|if
condition|(
operator|(
name|idp
operator|->
name|id_iobase
operator|>=
literal|0x7000
operator|)
operator|&&
operator|(
name|idp
operator|->
name|id_iobase
operator|<
literal|0x7400
operator|)
condition|)
name|bclass
operator||=
name|BRD_MCA
expr_stmt|;
if|if
condition|(
operator|(
name|idp
operator|->
name|id_iobase
operator|>=
literal|0x8000
operator|)
operator|&&
operator|(
name|idp
operator|->
name|id_iobase
operator|<
literal|0xc000
operator|)
condition|)
name|bclass
operator||=
name|BRD_MCA
expr_stmt|;
comment|/* EISA board range */
if|if
condition|(
operator|(
name|idp
operator|->
name|id_iobase
operator|&
operator|~
literal|0xf000
operator|)
operator|==
literal|0
condition|)
name|bclass
operator||=
name|BRD_EISA
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bclass
operator|==
literal|0
operator|)
operator|||
operator|(
name|idp
operator|->
name|id_iobase
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  *	Based on the board bus type, try and figure out what it might be...  */
name|btype
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bclass
operator|&
name|BRD_ISA
condition|)
name|btype
operator|=
name|stli_isaprobe
argument_list|(
name|idp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|btype
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bclass
operator|&
name|BRD_EISA
operator|)
condition|)
name|btype
operator|=
name|stli_eisaprobe
argument_list|(
name|idp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|btype
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bclass
operator|&
name|BRD_MCA
operator|)
condition|)
name|btype
operator|=
name|stli_mcaprobe
argument_list|(
name|idp
argument_list|)
expr_stmt|;
if|if
condition|(
name|btype
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  *	Go ahead and try probing for the shared memory region now.  *	This way we will really know if the board is here...  */
if|if
condition|(
operator|(
name|brdp
operator|=
name|stli_brdalloc
argument_list|()
operator|)
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|brdp
operator|->
name|brdnr
operator|=
name|stli_findfreeunit
argument_list|()
expr_stmt|;
name|brdp
operator|->
name|brdtype
operator|=
name|btype
expr_stmt|;
name|brdp
operator|->
name|unitid
operator|=
name|idp
operator|->
name|id_unit
expr_stmt|;
name|brdp
operator|->
name|iobase
operator|=
name|idp
operator|->
name|id_iobase
expr_stmt|;
name|brdp
operator|->
name|vaddr
operator|=
name|idp
operator|->
name|id_maddr
expr_stmt|;
name|brdp
operator|->
name|paddr
operator|=
name|vtophys
argument_list|(
name|idp
operator|->
name|id_maddr
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"%s(%d): btype=%x unit=%d brd=%d io=%x mem=%x(%x)\n"
argument_list|,
name|__file__
argument_list|,
name|__LINE__
argument_list|,
name|btype
argument_list|,
name|brdp
operator|->
name|unitid
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|,
name|brdp
operator|->
name|iobase
argument_list|,
name|brdp
operator|->
name|paddr
argument_list|,
name|brdp
operator|->
name|vaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stli_stliprobed
index|[
name|idp
operator|->
name|id_unit
index|]
operator|=
name|brdp
operator|->
name|brdnr
expr_stmt|;
name|stli_brdinit
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|brdp
operator|->
name|state
operator|&
name|BST_FOUND
operator|)
operator|==
literal|0
condition|)
block|{
name|stli_brds
index|[
name|brdp
operator|->
name|brdnr
index|]
operator|=
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|stli_nrbrds
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Allocate resources for and initialize a board.  */
end_comment

begin_function
specifier|static
name|int
name|stliattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|int
name|brdnr
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stliattach(idp=%x): unit=%d iobase=%x\n"
argument_list|,
name|idp
argument_list|,
name|idp
operator|->
name|id_unit
argument_list|,
name|idp
operator|->
name|id_iobase
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|brdnr
operator|=
name|stli_stliprobed
index|[
name|idp
operator|->
name|id_unit
index|]
expr_stmt|;
name|brdp
operator|=
name|stli_brds
index|[
name|brdnr
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|brdp
operator|->
name|state
operator|&
name|BST_FOUND
condition|)
name|stli_brdattach
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|stliopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|stliport_t
modifier|*
name|portp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|callout
decl_stmt|,
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stliopen(dev=%x,flag=%x,mode=%x,p=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|dev
argument_list|,
name|flag
argument_list|,
name|mode
argument_list|,
operator|(
name|int
operator|)
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  *	Firstly check if the supplied device number is a valid device.  */
if|if
condition|(
name|dev
operator|&
name|STL_MEMDEV
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|portp
operator|=
name|stli_dev2port
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
name|callout
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|STL_CALLOUTDEV
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|stliopen_restart
label|:
comment|/*  *	Wait here for the DTR drop timeout period to expire.  */
while|while
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_DTRWAIT
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|portp
operator|->
name|dtrwait
argument_list|,
operator|(
name|TTIPRI
operator||
name|PCATCH
operator|)
argument_list|,
literal|"stlidtr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|stliopen_end
goto|;
block|}
comment|/*  *	If the port is in its raw hardware initialization phase, then  *	hold up here 'till it is done.  */
while|while
condition|(
name|portp
operator|->
name|state
operator|&
operator|(
name|ST_INITIALIZING
operator||
name|ST_CLOSING
operator|)
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|portp
operator|->
name|state
argument_list|,
operator|(
name|TTIPRI
operator||
name|PCATCH
operator|)
argument_list|,
literal|"stliraw"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|stliopen_end
goto|;
block|}
comment|/*  *	We have a valid device, so now we check if it is already open.  *	If not then initialize the port hardware and set up the tty  *	struct as required.  */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_oproc
operator|=
name|stli_start
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|stli_param
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|=
name|callout
condition|?
name|portp
operator|->
name|initouttios
else|:
name|portp
operator|->
name|initintios
expr_stmt|;
name|stli_initopen
argument_list|(
name|portp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|portp
operator|->
name|state
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|portp
operator|->
name|sigs
operator|&
name|TIOCM_CD
operator|)
operator|||
name|callout
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|callout
condition|)
block|{
if|if
condition|(
name|portp
operator|->
name|callout
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|stliopen_end
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|portp
operator|->
name|callout
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|stliopen_end
goto|;
block|}
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|portp
operator|->
name|callout
argument_list|,
operator|(
name|TTIPRI
operator||
name|PCATCH
operator|)
argument_list|,
literal|"stlicall"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|stliopen_end
goto|;
goto|goto
name|stliopen_restart
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|stliopen_end
goto|;
block|}
block|}
comment|/*  *	If this port is not the callout device and we do not have carrier  *	then we need to sleep, waiting for it to be asserted.  */
if|if
condition|(
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|callout
operator|&&
operator|(
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|portp
operator|->
name|waitopens
operator|++
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|,
operator|(
name|TTIPRI
operator||
name|PCATCH
operator|)
argument_list|,
literal|"stlidcd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|portp
operator|->
name|waitopens
operator|--
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|stliopen_end
goto|;
goto|goto
name|stliopen_restart
goto|;
block|}
comment|/*  *	Open the line discipline.  */
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
name|stli_ttyoptim
argument_list|(
name|portp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
name|callout
condition|)
name|portp
operator|->
name|callout
operator|=
literal|1
expr_stmt|;
comment|/*  *	If for any reason we get to here and the port is not actually  *	open then close of the physical hardware - no point leaving it  *	active when the open failed...  */
name|stliopen_end
label|:
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|portp
operator|->
name|waitopens
operator|==
literal|0
operator|)
condition|)
name|stli_shutdownclose
argument_list|(
name|portp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|stliclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|stliport_t
modifier|*
name|portp
decl_stmt|;
name|int
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stliclose(dev=%x,flag=%x,mode=%x,p=%x)\n"
argument_list|,
name|dev
argument_list|,
name|flag
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dev
operator|&
name|STL_MEMDEV
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|portp
operator|=
name|stli_dev2port
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|stli_ttyoptim
argument_list|(
name|portp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|stli_shutdownclose
argument_list|(
name|portp
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|stliread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|stliport_t
modifier|*
name|portp
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stliread(dev=%x,uiop=%x,flag=%x)\n"
argument_list|,
name|dev
argument_list|,
name|uiop
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dev
operator|&
name|STL_MEMDEV
condition|)
return|return
operator|(
name|stli_memrw
argument_list|(
name|dev
argument_list|,
name|uiop
argument_list|,
name|flag
argument_list|)
operator|)
return|;
name|portp
operator|=
name|stli_dev2port
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|portp
operator|->
name|tty
operator|.
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
operator|&
name|portp
operator|->
name|tty
operator|,
name|uiop
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|VFREEBSD
operator|>=
literal|220
end_if

begin_function
name|STATIC
name|void
name|stlistop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlistop(tp=%x,rw=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|tp
argument_list|,
name|rw
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stli_flush
argument_list|(
operator|(
name|stliport_t
operator|*
operator|)
name|tp
argument_list|,
name|rw
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|STATIC
name|int
name|stlistop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlistop(tp=%x,rw=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|tp
argument_list|,
name|rw
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stli_flush
argument_list|(
operator|(
name|stliport_t
operator|*
operator|)
name|tp
argument_list|,
name|rw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|STATIC
name|struct
name|tty
modifier|*
name|stlidevtotty
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlidevtotty(dev=%x)\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
expr|struct
name|tty
operator|*
operator|)
name|stli_dev2port
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|stliwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|stliport_t
modifier|*
name|portp
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stliwrite(dev=%x,uiop=%x,flag=%x)\n"
argument_list|,
name|dev
argument_list|,
name|uiop
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dev
operator|&
name|STL_MEMDEV
condition|)
return|return
operator|(
name|stli_memrw
argument_list|(
name|dev
argument_list|,
name|uiop
argument_list|,
name|flag
argument_list|)
operator|)
return|;
name|portp
operator|=
name|stli_dev2port
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|portp
operator|->
name|tty
operator|.
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
operator|&
name|portp
operator|->
name|tty
operator|,
name|uiop
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|stliioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|termios
modifier|*
name|newtios
decl_stmt|,
modifier|*
name|localtios
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|stliport_t
modifier|*
name|portp
decl_stmt|;
name|long
name|arg
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stliioctl(dev=%x,cmd=%x,data=%x,flag=%x,p=%x)\n"
argument_list|,
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|&
name|STL_MEMDEV
condition|)
return|return
operator|(
name|stli_memioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
operator|)
return|;
name|portp
operator|=
name|stli_dev2port
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
operator|(
name|brdp
operator|=
name|stli_brds
index|[
name|portp
operator|->
name|brdnr
index|]
operator|)
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/*  *	First up handle ioctls on the control devices.  */
if|if
condition|(
name|dev
operator|&
name|STL_CTRLDEV
condition|)
block|{
if|if
condition|(
operator|(
name|dev
operator|&
name|STL_CTRLDEV
operator|)
operator|==
name|STL_CTRLINIT
condition|)
name|localtios
operator|=
operator|(
name|dev
operator|&
name|STL_CALLOUTDEV
operator|)
condition|?
operator|&
name|portp
operator|->
name|initouttios
else|:
operator|&
name|portp
operator|->
name|initintios
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dev
operator|&
name|STL_CTRLDEV
operator|)
operator|==
name|STL_CTRLLOCK
condition|)
name|localtios
operator|=
operator|(
name|dev
operator|&
name|STL_CALLOUTDEV
operator|)
condition|?
operator|&
name|portp
operator|->
name|lockouttios
else|:
operator|&
name|portp
operator|->
name|lockintios
expr_stmt|;
else|else
return|return
operator|(
name|ENODEV
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSETA
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
operator|==
literal|0
condition|)
operator|*
name|localtios
operator|=
operator|*
operator|(
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|TIOCGETA
case|:
operator|*
operator|(
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|)
operator|=
operator|*
name|localtios
expr_stmt|;
break|break;
case|case
name|TIOCGETD
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|=
name|TTYDISC
expr_stmt|;
break|break;
case|case
name|TIOCGWINSZ
case|:
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|winsize
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  *	Deal with 4.3 compatability issues if we have too...  */
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
if|if
condition|(
literal|1
condition|)
block|{
name|struct
name|termios
name|tios
decl_stmt|;
name|int
name|oldcmd
decl_stmt|;
name|tios
operator|=
name|tp
operator|->
name|t_termios
expr_stmt|;
name|oldcmd
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ttsetcompat
argument_list|(
name|tp
argument_list|,
operator|&
name|cmd
argument_list|,
name|data
argument_list|,
operator|&
name|tios
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|cmd
operator|!=
name|oldcmd
condition|)
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|tios
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  *	Carry out some pre-cmd processing work first...  *	Hmmm, not so sure we want this, disable for now...  */
if|if
condition|(
operator|(
name|cmd
operator|==
name|TIOCSETA
operator|)
operator|||
operator|(
name|cmd
operator|==
name|TIOCSETAW
operator|)
operator|||
operator|(
name|cmd
operator|==
name|TIOCSETAF
operator|)
condition|)
block|{
name|newtios
operator|=
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
expr_stmt|;
name|localtios
operator|=
operator|(
name|dev
operator|&
name|STL_CALLOUTDEV
operator|)
condition|?
operator|&
name|portp
operator|->
name|lockouttios
else|:
operator|&
name|portp
operator|->
name|lockintios
expr_stmt|;
name|newtios
operator|->
name|c_iflag
operator|=
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|localtios
operator|->
name|c_iflag
operator|)
operator||
operator|(
name|newtios
operator|->
name|c_iflag
operator|&
operator|~
name|localtios
operator|->
name|c_iflag
operator|)
expr_stmt|;
name|newtios
operator|->
name|c_oflag
operator|=
operator|(
name|tp
operator|->
name|t_oflag
operator|&
name|localtios
operator|->
name|c_oflag
operator|)
operator||
operator|(
name|newtios
operator|->
name|c_oflag
operator|&
operator|~
name|localtios
operator|->
name|c_oflag
operator|)
expr_stmt|;
name|newtios
operator|->
name|c_cflag
operator|=
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|localtios
operator|->
name|c_cflag
operator|)
operator||
operator|(
name|newtios
operator|->
name|c_cflag
operator|&
operator|~
name|localtios
operator|->
name|c_cflag
operator|)
expr_stmt|;
name|newtios
operator|->
name|c_lflag
operator|=
operator|(
name|tp
operator|->
name|t_lflag
operator|&
name|localtios
operator|->
name|c_lflag
operator|)
operator||
operator|(
name|newtios
operator|->
name|c_lflag
operator|&
operator|~
name|localtios
operator|->
name|c_lflag
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|NCCS
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|localtios
operator|->
name|c_cc
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|newtios
operator|->
name|c_cc
index|[
name|i
index|]
operator|=
name|tp
operator|->
name|t_cc
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|localtios
operator|->
name|c_ispeed
operator|!=
literal|0
condition|)
name|newtios
operator|->
name|c_ispeed
operator|=
name|tp
operator|->
name|t_ispeed
expr_stmt|;
if|if
condition|(
name|localtios
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
name|newtios
operator|->
name|c_ospeed
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
block|}
comment|/*  *	Call the line discipline and the common command processing to  *	process this command (if they can).  */
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|stli_ttyoptim
argument_list|(
name|portp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
comment|/*  *	Process local commands here. These are all commands that only we  *	can take care of (they all rely on actually doing something special  *	to the actual hardware).  */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
name|arg
operator|=
name|BREAKON
expr_stmt|;
name|error
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_BREAK
argument_list|,
operator|&
name|arg
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
name|arg
operator|=
name|BREAKOFF
expr_stmt|;
name|error
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_BREAK
argument_list|,
operator|&
name|arg
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCSDTR
case|:
name|stli_mkasysigs
argument_list|(
operator|&
name|portp
operator|->
name|asig
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_SETSIGNALS
argument_list|,
operator|&
name|portp
operator|->
name|asig
argument_list|,
sizeof|sizeof
argument_list|(
name|asysigs_t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
name|stli_mkasysigs
argument_list|(
operator|&
name|portp
operator|->
name|asig
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_SETSIGNALS
argument_list|,
operator|&
name|portp
operator|->
name|asig
argument_list|,
sizeof|sizeof
argument_list|(
name|asysigs_t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
name|i
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|stli_mkasysigs
argument_list|(
operator|&
name|portp
operator|->
name|asig
argument_list|,
operator|(
operator|(
name|i
operator|&
name|TIOCM_DTR
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
operator|(
operator|(
name|i
operator|&
name|TIOCM_RTS
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_SETSIGNALS
argument_list|,
operator|&
name|portp
operator|->
name|asig
argument_list|,
sizeof|sizeof
argument_list|(
name|asysigs_t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
name|i
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|stli_mkasysigs
argument_list|(
operator|&
name|portp
operator|->
name|asig
argument_list|,
operator|(
operator|(
name|i
operator|&
name|TIOCM_DTR
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|i
operator|&
name|TIOCM_RTS
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_SETSIGNALS
argument_list|,
operator|&
name|portp
operator|->
name|asig
argument_list|,
sizeof|sizeof
argument_list|(
name|asysigs_t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
name|i
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|stli_mkasysigs
argument_list|(
operator|&
name|portp
operator|->
name|asig
argument_list|,
operator|(
operator|(
name|i
operator|&
name|TIOCM_DTR
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|i
operator|&
name|TIOCM_RTS
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_SETSIGNALS
argument_list|,
operator|&
name|portp
operator|->
name|asig
argument_list|,
sizeof|sizeof
argument_list|(
name|asysigs_t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_GETSIGNALS
argument_list|,
operator|&
name|portp
operator|->
name|asig
argument_list|,
sizeof|sizeof
argument_list|(
name|asysigs_t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
name|portp
operator|->
name|sigs
operator|=
name|stli_mktiocm
argument_list|(
name|portp
operator|->
name|asig
operator|.
name|sigvalue
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|=
operator|(
name|portp
operator|->
name|sigs
operator||
name|TIOCM_LE
operator|)
expr_stmt|;
break|break;
case|case
name|TIOCMSDTRWAIT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|portp
operator|->
name|dtrwait
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|*
name|hz
operator|/
literal|100
expr_stmt|;
break|break;
case|case
name|TIOCMGDTRWAIT
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|=
name|portp
operator|->
name|dtrwait
operator|*
literal|100
operator|/
name|hz
expr_stmt|;
break|break;
case|case
name|TIOCTIMESTAMP
case|:
name|portp
operator|->
name|dotimestamp
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|data
operator|)
operator|=
name|portp
operator|->
name|timestamp
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Convert the specified minor device number into a port struct  *	pointer. Return NULL if the device number is not a valid port.  */
end_comment

begin_function
name|STATIC
name|stliport_t
modifier|*
name|stli_dev2port
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|brdp
operator|=
name|stli_brds
index|[
name|MKDEV2BRD
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|brdp
operator|->
name|state
operator|&
name|BST_STARTED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
operator|)
return|;
return|return
operator|(
name|brdp
operator|->
name|ports
index|[
name|MKDEV2PORT
argument_list|(
name|dev
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Carry out first open operations on a port. This involves a number of  *	commands to be sent to the slave. We need to open the port, set the  *	notification events, set the initial port settings, get and set the  *	initial signal values. We sleep and wait in between each one. But  *	this still all happens pretty quickly.  */
end_comment

begin_function
specifier|static
name|int
name|stli_initopen
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|asynotify_t
name|nt
decl_stmt|;
name|asyport_t
name|aport
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_initopen(portp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|brdp
operator|=
name|stli_brds
index|[
name|portp
operator|->
name|brdnr
index|]
operator|)
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_INITIALIZED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|portp
operator|->
name|state
operator||=
name|ST_INITIALIZED
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|stli_rawopen
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|nt
argument_list|,
sizeof|sizeof
argument_list|(
name|asynotify_t
argument_list|)
argument_list|)
expr_stmt|;
name|nt
operator|.
name|data
operator|=
operator|(
name|DT_TXLOW
operator||
name|DT_TXEMPTY
operator||
name|DT_RXBUSY
operator||
name|DT_RXBREAK
operator|)
expr_stmt|;
name|nt
operator|.
name|signal
operator|=
name|SG_DCD
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_SETNOTIFY
argument_list|,
operator|&
name|nt
argument_list|,
sizeof|sizeof
argument_list|(
name|asynotify_t
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|stli_mkasyport
argument_list|(
name|portp
argument_list|,
operator|&
name|aport
argument_list|,
operator|&
name|portp
operator|->
name|tty
operator|.
name|t_termios
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_SETPORT
argument_list|,
operator|&
name|aport
argument_list|,
sizeof|sizeof
argument_list|(
name|asyport_t
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|portp
operator|->
name|state
operator||=
name|ST_GETSIGS
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_GETSIGNALS
argument_list|,
operator|&
name|portp
operator|->
name|asig
argument_list|,
sizeof|sizeof
argument_list|(
name|asysigs_t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_GETSIGS
condition|)
block|{
name|portp
operator|->
name|sigs
operator|=
name|stli_mktiocm
argument_list|(
name|portp
operator|->
name|asig
operator|.
name|sigvalue
argument_list|)
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
name|ST_GETSIGS
expr_stmt|;
block|}
name|stli_mkasysigs
argument_list|(
operator|&
name|portp
operator|->
name|asig
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_SETSIGNALS
argument_list|,
operator|&
name|portp
operator|->
name|asig
argument_list|,
sizeof|sizeof
argument_list|(
name|asysigs_t
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Shutdown the hardware of a port.  */
end_comment

begin_function
specifier|static
name|int
name|stli_shutdownclose
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_shutdownclose(portp=%x): brdnr=%d panelnr=%d portnr=%d\n"
argument_list|,
name|portp
argument_list|,
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|panelnr
argument_list|,
name|portp
operator|->
name|portnr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|brdp
operator|=
name|stli_brds
index|[
name|portp
operator|->
name|brdnr
index|]
operator|)
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
name|stli_rawclose
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stli_flush
argument_list|(
name|portp
argument_list|,
operator|(
name|FWRITE
operator||
name|FREAD
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
condition|)
block|{
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|stli_mkasysigs
argument_list|(
operator|&
name|portp
operator|->
name|asig
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_CMDING
condition|)
block|{
name|portp
operator|->
name|state
operator||=
name|ST_DOSIGS
expr_stmt|;
block|}
else|else
block|{
name|stli_sendcmd
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_SETSIGNALS
argument_list|,
operator|&
name|portp
operator|->
name|asig
argument_list|,
sizeof|sizeof
argument_list|(
name|asysigs_t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|->
name|dtrwait
operator|!=
literal|0
condition|)
block|{
name|portp
operator|->
name|state
operator||=
name|ST_DTRWAIT
expr_stmt|;
name|timeout
argument_list|(
name|stli_dtrwakeup
argument_list|,
name|portp
argument_list|,
name|portp
operator|->
name|dtrwait
argument_list|)
expr_stmt|;
block|}
block|}
name|portp
operator|->
name|callout
operator|=
literal|0
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
name|ST_INITIALIZED
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|portp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Clear the DTR waiting flag, and wake up any sleepers waiting for  *	DTR wait period to finish.  */
end_comment

begin_function
specifier|static
name|void
name|stli_dtrwakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|stliport_t
modifier|*
name|portp
decl_stmt|;
name|portp
operator|=
operator|(
name|stliport_t
operator|*
operator|)
name|arg
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
name|ST_DTRWAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|portp
operator|->
name|dtrwait
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Send an open message to the slave. This will sleep waiting for the  *	acknowledgement, so must have user context. We need to co-ordinate  *	with close events here, since we don't want open and close events  *	to overlap.  */
end_comment

begin_function
specifier|static
name|int
name|stli_rawopen
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
specifier|volatile
name|cdkhdr_t
modifier|*
name|hdrp
decl_stmt|;
specifier|volatile
name|cdkctrl_t
modifier|*
name|cp
decl_stmt|;
specifier|volatile
name|unsigned
name|char
modifier|*
name|bits
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_rawopen(brdp=%x,portp=%x,arg=%x,wait=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|,
operator|(
name|int
operator|)
name|arg
argument_list|,
name|wait
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/*  *	Slave is already closing this port. This can happen if a hangup  *	occurs on this port. So we must wait until it is complete. The  *	order of opens and closes may not be preserved across shared  *	memory, so we must wait until it is complete.  */
while|while
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_CLOSING
condition|)
block|{
name|rc
operator|=
name|tsleep
argument_list|(
operator|&
name|portp
operator|->
name|state
argument_list|,
operator|(
name|TTIPRI
operator||
name|PCATCH
operator|)
argument_list|,
literal|"stliraw"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
comment|/*  *	Everything is ready now, so write the open message into shared  *	memory. Once the message is in set the service bits to say that  *	this port wants service.  */
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
operator|(
operator|(
specifier|volatile
name|cdkasy_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|portp
operator|->
name|addr
argument_list|)
operator|)
operator|->
name|ctrl
expr_stmt|;
name|cp
operator|->
name|openarg
operator|=
name|arg
expr_stmt|;
name|cp
operator|->
name|open
operator|=
literal|1
expr_stmt|;
name|hdrp
operator|=
operator|(
specifier|volatile
name|cdkhdr_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|CDK_CDKADDR
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|(
operator|(
specifier|volatile
name|unsigned
name|char
operator|*
operator|)
name|hdrp
operator|)
operator|+
name|brdp
operator|->
name|slaveoffset
operator|+
name|portp
operator|->
name|portidx
expr_stmt|;
operator|*
name|bits
operator||=
name|portp
operator|->
name|portbit
expr_stmt|;
name|EBRDDISABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  *	Slave is in action, so now we must wait for the open acknowledgment  *	to come back.  */
name|rc
operator|=
literal|0
expr_stmt|;
name|portp
operator|->
name|state
operator||=
name|ST_OPENING
expr_stmt|;
while|while
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_OPENING
condition|)
block|{
name|rc
operator|=
name|tsleep
argument_list|(
operator|&
name|portp
operator|->
name|state
argument_list|,
operator|(
name|TTIPRI
operator||
name|PCATCH
operator|)
argument_list|,
literal|"stliraw"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|==
literal|0
operator|)
operator|&&
operator|(
name|portp
operator|->
name|rc
operator|!=
literal|0
operator|)
condition|)
name|rc
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Send a close message to the slave. Normally this will sleep waiting  *	for the acknowledgement, but if wait parameter is 0 it will not. If  *	wait is true then must have user context (to sleep).  */
end_comment

begin_function
specifier|static
name|int
name|stli_rawclose
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
specifier|volatile
name|cdkhdr_t
modifier|*
name|hdrp
decl_stmt|;
specifier|volatile
name|cdkctrl_t
modifier|*
name|cp
decl_stmt|;
specifier|volatile
name|unsigned
name|char
modifier|*
name|bits
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_rawclose(brdp=%x,portp=%x,arg=%x,wait=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|,
operator|(
name|int
operator|)
name|arg
argument_list|,
name|wait
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/*  *	Slave is already closing this port. This can happen if a hangup  *	occurs on this port.  */
if|if
condition|(
name|wait
condition|)
block|{
while|while
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_CLOSING
condition|)
block|{
name|rc
operator|=
name|tsleep
argument_list|(
operator|&
name|portp
operator|->
name|state
argument_list|,
operator|(
name|TTIPRI
operator||
name|PCATCH
operator|)
argument_list|,
literal|"stliraw"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
block|}
comment|/*  *	Write the close command into shared memory.  */
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
operator|(
operator|(
specifier|volatile
name|cdkasy_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|portp
operator|->
name|addr
argument_list|)
operator|)
operator|->
name|ctrl
expr_stmt|;
name|cp
operator|->
name|closearg
operator|=
name|arg
expr_stmt|;
name|cp
operator|->
name|close
operator|=
literal|1
expr_stmt|;
name|hdrp
operator|=
operator|(
specifier|volatile
name|cdkhdr_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|CDK_CDKADDR
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|(
operator|(
specifier|volatile
name|unsigned
name|char
operator|*
operator|)
name|hdrp
operator|)
operator|+
name|brdp
operator|->
name|slaveoffset
operator|+
name|portp
operator|->
name|portidx
expr_stmt|;
operator|*
name|bits
operator||=
name|portp
operator|->
name|portbit
expr_stmt|;
name|EBRDDISABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|portp
operator|->
name|state
operator||=
name|ST_CLOSING
expr_stmt|;
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  *	Slave is in action, so now we must wait for the open acknowledgment  *	to come back.  */
name|rc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_CLOSING
condition|)
block|{
name|rc
operator|=
name|tsleep
argument_list|(
operator|&
name|portp
operator|->
name|state
argument_list|,
operator|(
name|TTIPRI
operator||
name|PCATCH
operator|)
argument_list|,
literal|"stliraw"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|==
literal|0
operator|)
operator|&&
operator|(
name|portp
operator|->
name|rc
operator|!=
literal|0
operator|)
condition|)
name|rc
operator|=
name|EIO
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Send a command to the slave and wait for the response. This must  *	have user context (it sleeps). This routine is generic in that it  *	can send any type of command. Its purpose is to wait for that command  *	to complete (as opposed to initiating the command then returning).  */
end_comment

begin_function
specifier|static
name|int
name|stli_cmdwait
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|copyback
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_cmdwait(brdp=%x,portp=%x,cmd=%x,arg=%x,size=%d,"
literal|"copyback=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|,
operator|(
name|int
operator|)
name|cmd
argument_list|,
operator|(
name|int
operator|)
name|arg
argument_list|,
name|size
argument_list|,
name|copyback
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_CMDING
condition|)
block|{
name|rc
operator|=
name|tsleep
argument_list|(
operator|&
name|portp
operator|->
name|state
argument_list|,
operator|(
name|TTIPRI
operator||
name|PCATCH
operator|)
argument_list|,
literal|"stliraw"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
name|stli_sendcmd
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|size
argument_list|,
name|copyback
argument_list|)
expr_stmt|;
while|while
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_CMDING
condition|)
block|{
name|rc
operator|=
name|tsleep
argument_list|(
operator|&
name|portp
operator|->
name|state
argument_list|,
operator|(
name|TTIPRI
operator||
name|PCATCH
operator|)
argument_list|,
literal|"stliraw"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|->
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Start (or continue) the transfer of TX data on this port. If the  *	port is not currently busy then load up the interrupt ring queue  *	buffer and kick of the transmitter. If the port is running low on  *	TX data then refill the ring queue. This routine is also used to  *	activate input flow control!  */
end_comment

begin_function
specifier|static
name|void
name|stli_start
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
specifier|volatile
name|cdkasy_t
modifier|*
name|ap
decl_stmt|;
specifier|volatile
name|cdkhdr_t
modifier|*
name|hdrp
decl_stmt|;
specifier|volatile
name|unsigned
name|char
modifier|*
name|bits
decl_stmt|;
name|unsigned
name|char
modifier|*
name|shbuf
decl_stmt|;
name|stliport_t
modifier|*
name|portp
decl_stmt|;
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|,
name|stlen
decl_stmt|,
name|head
decl_stmt|,
name|tail
decl_stmt|,
name|size
decl_stmt|;
name|int
name|count
decl_stmt|,
name|x
decl_stmt|;
name|portp
operator|=
operator|(
name|stliport_t
operator|*
operator|)
name|tp
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_start(tp=%x): brdnr=%d portnr=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|tp
argument_list|,
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|portnr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|#
directive|if
name|VFREEBSD
operator|==
literal|205
comment|/*  *	Check if the output cooked clist buffers are near empty, wake up  *	the line discipline to fill it up.  */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  *	Copy data from the clists into the interrupt ring queue. This will  *	require at most 2 copys... What we do is calculate how many chars  *	can fit into the ring queue, and how many can fit in 1 copy. If after  *	the first copy there is still more room then do the second copy.   */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
condition|)
block|{
name|brdp
operator|=
name|stli_brds
index|[
name|portp
operator|->
name|brdnr
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|ap
operator|=
operator|(
specifier|volatile
name|cdkasy_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|portp
operator|->
name|addr
argument_list|)
expr_stmt|;
name|head
operator|=
operator|(
name|unsigned
name|int
operator|)
name|ap
operator|->
name|txq
operator|.
name|head
expr_stmt|;
name|tail
operator|=
operator|(
name|unsigned
name|int
operator|)
name|ap
operator|->
name|txq
operator|.
name|tail
expr_stmt|;
if|if
condition|(
name|tail
operator|!=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|ap
operator|->
name|txq
operator|.
name|tail
operator|)
condition|)
name|tail
operator|=
operator|(
name|unsigned
name|int
operator|)
name|ap
operator|->
name|txq
operator|.
name|tail
expr_stmt|;
name|size
operator|=
name|portp
operator|->
name|txsize
expr_stmt|;
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
block|{
name|len
operator|=
name|size
operator|-
operator|(
name|head
operator|-
name|tail
operator|)
operator|-
literal|1
expr_stmt|;
name|stlen
operator|=
name|size
operator|-
name|head
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|tail
operator|-
name|head
operator|-
literal|1
expr_stmt|;
name|stlen
operator|=
name|len
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|shbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|portp
operator|->
name|txoffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|stlen
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|stlen
argument_list|)
expr_stmt|;
name|count
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
operator|(
name|shbuf
operator|+
name|head
operator|)
argument_list|,
name|stlen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
name|head
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|head
operator|>=
name|size
condition|)
block|{
name|head
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|stlen
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|shbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|head
operator|+=
name|stlen
expr_stmt|;
name|count
operator|+=
name|stlen
expr_stmt|;
block|}
block|}
block|}
name|ap
operator|=
operator|(
specifier|volatile
name|cdkasy_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|portp
operator|->
name|addr
argument_list|)
expr_stmt|;
name|ap
operator|->
name|txq
operator|.
name|head
operator|=
name|head
expr_stmt|;
name|hdrp
operator|=
operator|(
specifier|volatile
name|cdkhdr_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|CDK_CDKADDR
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|(
operator|(
specifier|volatile
name|unsigned
name|char
operator|*
operator|)
name|hdrp
operator|)
operator|+
name|brdp
operator|->
name|slaveoffset
operator|+
name|portp
operator|->
name|portidx
expr_stmt|;
operator|*
name|bits
operator||=
name|portp
operator|->
name|portbit
expr_stmt|;
name|portp
operator|->
name|state
operator||=
name|ST_TXBUSY
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|EBRDDISABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|VFREEBSD
operator|!=
literal|205
comment|/*  *	Do any writer wakeups.  */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Send a new port configuration to the slave.  */
end_comment

begin_function
specifier|static
name|int
name|stli_param
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|tiosp
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|stliport_t
modifier|*
name|portp
decl_stmt|;
name|asyport_t
name|aport
decl_stmt|;
name|int
name|x
decl_stmt|,
name|rc
decl_stmt|;
name|portp
operator|=
operator|(
name|stliport_t
operator|*
operator|)
name|tp
expr_stmt|;
if|if
condition|(
operator|(
name|brdp
operator|=
name|stli_brds
index|[
name|portp
operator|->
name|brdnr
index|]
operator|)
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|stli_mkasyport
argument_list|(
name|portp
argument_list|,
operator|&
name|aport
argument_list|,
name|tiosp
argument_list|)
expr_stmt|;
comment|/* can we sleep here? */
name|rc
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_SETPORT
argument_list|,
operator|&
name|aport
argument_list|,
sizeof|sizeof
argument_list|(
name|asyport_t
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stli_ttyoptim
argument_list|(
name|portp
argument_list|,
name|tiosp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Flush characters from the lower buffer. We may not have user context  *	so we cannot sleep waiting for it to complete. Also we need to check  *	if there is chars for this port in the TX cook buffer, and flush them  *	as well.  */
end_comment

begin_function
specifier|static
name|void
name|stli_flush
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|unsigned
name|long
name|ftype
decl_stmt|;
name|int
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_flush(portp=%x,flag=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|portp
operator|==
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|portp
operator|->
name|brdnr
operator|<
literal|0
operator|)
operator|||
operator|(
name|portp
operator|->
name|brdnr
operator|>=
name|stli_nrbrds
operator|)
condition|)
return|return;
name|brdp
operator|=
name|stli_brds
index|[
name|portp
operator|->
name|brdnr
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_CMDING
condition|)
block|{
name|portp
operator|->
name|state
operator||=
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|?
name|ST_DOFLUSHTX
else|:
literal|0
expr_stmt|;
name|portp
operator|->
name|state
operator||=
operator|(
name|flag
operator|&
name|FREAD
operator|)
condition|?
name|ST_DOFLUSHRX
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ftype
operator|=
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|?
name|FLUSHTX
else|:
literal|0
expr_stmt|;
name|ftype
operator||=
operator|(
name|flag
operator|&
name|FREAD
operator|)
condition|?
name|FLUSHRX
else|:
literal|0
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
operator|(
name|ST_DOFLUSHTX
operator||
name|ST_DOFLUSHRX
operator|)
expr_stmt|;
name|stli_sendcmd
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_FLUSH
argument_list|,
operator|&
name|ftype
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|FREAD
operator|)
operator|&&
operator|(
name|stli_rxtmpport
operator|==
name|portp
operator|)
condition|)
name|stli_rxtmplen
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Generic send command routine. This will send a message to the slave,  *	of the specified type with the specified argument. Must be very  *	carefull of data that will be copied out from shared memory -  *	containing command results. The command completion is all done from  *	a poll routine that does not have user coontext. Therefore you cannot  *	copy back directly into user space, or to the kernel stack of a  *	process. This routine does not sleep, so can be called from anywhere,  *	and must be called with interrupt locks set.  */
end_comment

begin_function
specifier|static
name|void
name|stli_sendcmd
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|copyback
parameter_list|)
block|{
specifier|volatile
name|cdkhdr_t
modifier|*
name|hdrp
decl_stmt|;
specifier|volatile
name|cdkctrl_t
modifier|*
name|cp
decl_stmt|;
specifier|volatile
name|unsigned
name|char
modifier|*
name|bits
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_sendcmd(brdp=%x,portp=%x,cmd=%x,arg=%x,size=%d,"
literal|"copyback=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|,
operator|(
name|int
operator|)
name|cmd
argument_list|,
operator|(
name|int
operator|)
name|arg
argument_list|,
name|size
argument_list|,
name|copyback
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_CMDING
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: command already busy, cmd=%x!\n"
argument_list|,
operator|(
name|int
operator|)
name|cmd
argument_list|)
expr_stmt|;
return|return;
block|}
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
operator|(
operator|(
specifier|volatile
name|cdkasy_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|portp
operator|->
name|addr
argument_list|)
operator|)
operator|->
name|ctrl
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|arg
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|cp
operator|->
name|args
index|[
literal|0
index|]
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyback
condition|)
block|{
name|portp
operator|->
name|argp
operator|=
name|arg
expr_stmt|;
name|portp
operator|->
name|argsize
operator|=
name|size
expr_stmt|;
block|}
block|}
name|cp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
name|hdrp
operator|=
operator|(
specifier|volatile
name|cdkhdr_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|CDK_CDKADDR
argument_list|)
expr_stmt|;
name|bits
operator|=
operator|(
operator|(
specifier|volatile
name|unsigned
name|char
operator|*
operator|)
name|hdrp
operator|)
operator|+
name|brdp
operator|->
name|slaveoffset
operator|+
name|portp
operator|->
name|portidx
expr_stmt|;
operator|*
name|bits
operator||=
name|portp
operator|->
name|portbit
expr_stmt|;
name|portp
operator|->
name|state
operator||=
name|ST_CMDING
expr_stmt|;
name|EBRDDISABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Read data from shared memory. This assumes that the shared memory  *	is enabled and that interrupts are off. Basically we just empty out  *	the shared memory buffer into the tty buffer. Must be carefull to  *	handle the case where we fill up the tty buffer, but still have  *	more chars to unload.  */
end_comment

begin_function
specifier|static
name|void
name|stli_rxprocess
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|stliport_t
modifier|*
name|portp
parameter_list|)
block|{
specifier|volatile
name|cdkasyrq_t
modifier|*
name|rp
decl_stmt|;
specifier|volatile
name|char
modifier|*
name|shbuf
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|,
name|size
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|,
name|stlen
decl_stmt|,
name|i
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_rxprocess(brdp=%x,portp=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|stli_flush
argument_list|(
name|portp
argument_list|,
name|FREAD
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
condition|)
return|return;
name|rp
operator|=
operator|&
operator|(
operator|(
specifier|volatile
name|cdkasy_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|portp
operator|->
name|addr
argument_list|)
operator|)
operator|->
name|rxq
expr_stmt|;
name|head
operator|=
operator|(
name|unsigned
name|int
operator|)
name|rp
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|head
operator|!=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|rp
operator|->
name|head
operator|)
condition|)
name|head
operator|=
operator|(
name|unsigned
name|int
operator|)
name|rp
operator|->
name|head
expr_stmt|;
name|tail
operator|=
operator|(
name|unsigned
name|int
operator|)
name|rp
operator|->
name|tail
expr_stmt|;
name|size
operator|=
name|portp
operator|->
name|rxsize
expr_stmt|;
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
block|{
name|len
operator|=
name|head
operator|-
name|tail
expr_stmt|;
name|stlen
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|size
operator|-
operator|(
name|tail
operator|-
name|head
operator|)
expr_stmt|;
name|stlen
operator|=
name|size
operator|-
name|tail
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
name|shbuf
operator|=
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|portp
operator|->
name|rxoffset
argument_list|)
expr_stmt|;
comment|/*  *	If we can bypass normal LD processing then just copy direct  *	from board shared memory into the tty buffers.  */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|len
operator|)
operator|>=
name|TTYHOG
operator|)
operator|&&
operator|(
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CRTS_IFLOW
operator|)
operator|||
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXOFF
operator|)
operator|)
operator|&&
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ch
operator|=
name|TTYHOG
operator|-
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|-
literal|1
expr_stmt|;
name|len
operator|=
operator|(
name|ch
operator|>
literal|0
operator|)
condition|?
name|ch
else|:
literal|0
expr_stmt|;
name|stlen
operator|=
name|MIN
argument_list|(
name|stlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_TBLOCK
expr_stmt|;
block|}
name|i
operator|=
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|shbuf
operator|+
name|tail
operator|)
argument_list|,
name|stlen
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|tail
operator|+=
name|stlen
expr_stmt|;
name|len
operator|-=
name|stlen
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|size
condition|)
block|{
name|tail
operator|=
literal|0
expr_stmt|;
name|i
operator|+=
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
name|shbuf
argument_list|,
name|len
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|tail
operator|+=
name|len
expr_stmt|;
block|}
name|portp
operator|->
name|rxlost
operator|+=
name|i
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|&
operator|(
operator|(
specifier|volatile
name|cdkasy_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|portp
operator|->
name|addr
argument_list|)
operator|)
operator|->
name|rxq
expr_stmt|;
name|rp
operator|->
name|tail
operator|=
name|tail
expr_stmt|;
block|}
else|else
block|{
comment|/*  *		Copy the data from board shared memory into a local  *		memory buffer. Then feed them from here into the LD.  *		We don't want to go into board shared memory one char  *		at a time, it is too slow...  */
if|if
condition|(
name|len
operator|>
name|TTYHOG
condition|)
block|{
name|len
operator|=
name|TTYHOG
operator|-
literal|1
expr_stmt|;
name|stlen
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|stlen
argument_list|)
expr_stmt|;
block|}
name|stli_rxtmpport
operator|=
name|portp
expr_stmt|;
name|stli_rxtmplen
operator|=
name|len
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|shbuf
operator|+
name|tail
operator|)
argument_list|,
operator|&
name|stli_rxtmpbuf
index|[
literal|0
index|]
argument_list|,
name|stlen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|stlen
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|shbuf
argument_list|,
operator|&
name|stli_rxtmpbuf
index|[
name|stlen
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|stli_rxtmplen
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
operator|(
name|unsigned
name|char
operator|)
name|stli_rxtmpbuf
index|[
name|i
index|]
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|ch
operator|,
name|tp
operator|)
expr_stmt|;
block|}
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|&
operator|(
operator|(
specifier|volatile
name|cdkasy_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|portp
operator|->
name|addr
argument_list|)
operator|)
operator|->
name|rxq
expr_stmt|;
if|if
condition|(
name|stli_rxtmplen
operator|==
literal|0
condition|)
block|{
name|head
operator|=
operator|(
name|unsigned
name|int
operator|)
name|rp
operator|->
name|head
expr_stmt|;
if|if
condition|(
name|head
operator|!=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|rp
operator|->
name|head
operator|)
condition|)
name|head
operator|=
operator|(
name|unsigned
name|int
operator|)
name|rp
operator|->
name|head
expr_stmt|;
name|tail
operator|=
name|head
expr_stmt|;
block|}
else|else
block|{
name|tail
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|size
condition|)
name|tail
operator|-=
name|size
expr_stmt|;
block|}
name|rp
operator|->
name|tail
operator|=
name|tail
expr_stmt|;
name|stli_rxtmpport
operator|=
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
expr_stmt|;
name|stli_rxtmplen
operator|=
literal|0
expr_stmt|;
block|}
name|portp
operator|->
name|state
operator||=
name|ST_RXING
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Set up and carry out any delayed commands. There is only a small set  *	of slave commands that can be done "off-level". So it is not too  *	difficult to deal with them as a special case here.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|stli_dodelaycmd
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|,
specifier|volatile
name|cdkctrl_t
modifier|*
name|cp
parameter_list|)
block|{
name|int
name|cmd
decl_stmt|;
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_DOSIGS
condition|)
block|{
if|if
condition|(
operator|(
name|portp
operator|->
name|state
operator|&
name|ST_DOFLUSHTX
operator|)
operator|&&
operator|(
name|portp
operator|->
name|state
operator|&
name|ST_DOFLUSHRX
operator|)
condition|)
name|cmd
operator|=
name|A_SETSIGNALSF
expr_stmt|;
elseif|else
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_DOFLUSHTX
condition|)
name|cmd
operator|=
name|A_SETSIGNALSFTX
expr_stmt|;
elseif|else
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_DOFLUSHRX
condition|)
name|cmd
operator|=
name|A_SETSIGNALSFRX
expr_stmt|;
else|else
name|cmd
operator|=
name|A_SETSIGNALS
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
operator|(
name|ST_DOFLUSHTX
operator||
name|ST_DOFLUSHRX
operator||
name|ST_DOSIGS
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|portp
operator|->
name|asig
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|cp
operator|->
name|args
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|asysigs_t
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
name|portp
operator|->
name|state
operator||=
name|ST_CMDING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|portp
operator|->
name|state
operator|&
name|ST_DOFLUSHTX
operator|)
operator|||
operator|(
name|portp
operator|->
name|state
operator|&
name|ST_DOFLUSHRX
operator|)
condition|)
block|{
name|cmd
operator|=
operator|(
operator|(
name|portp
operator|->
name|state
operator|&
name|ST_DOFLUSHTX
operator|)
condition|?
name|FLUSHTX
else|:
literal|0
operator|)
expr_stmt|;
name|cmd
operator||=
operator|(
operator|(
name|portp
operator|->
name|state
operator|&
name|ST_DOFLUSHRX
operator|)
condition|?
name|FLUSHRX
else|:
literal|0
operator|)
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
operator|(
name|ST_DOFLUSHTX
operator||
name|ST_DOFLUSHRX
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|cmd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|cp
operator|->
name|args
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|cmd
operator|=
name|A_FLUSH
expr_stmt|;
name|portp
operator|->
name|state
operator||=
name|ST_CMDING
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Host command service checking. This handles commands or messages  *	coming from the slave to the host. Must have board shared memory  *	enabled and interrupts off when called. Notice that by servicing the  *	read data last we don't need to change the shared memory pointer  *	during processing (which is a slow IO operation).  *	Return value indicates if this port is still awaiting actions from  *	the slave (like open, command, or even TX data being sent). If 0  *	then port is still busy, otherwise the port request bit flag is  *	returned.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|stli_hostcmd
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|stliport_t
modifier|*
name|portp
parameter_list|)
block|{
specifier|volatile
name|cdkasy_t
modifier|*
name|ap
decl_stmt|;
specifier|volatile
name|cdkctrl_t
modifier|*
name|cp
decl_stmt|;
name|asynotify_t
name|nt
decl_stmt|;
name|unsigned
name|long
name|oldsigs
decl_stmt|;
name|unsigned
name|int
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|donerx
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_hostcmd(brdp=%x,portp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ap
operator|=
operator|(
specifier|volatile
name|cdkasy_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|portp
operator|->
name|addr
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|ap
operator|->
name|ctrl
expr_stmt|;
comment|/*  *	Check if we are waiting for an open completion message.  */
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_OPENING
condition|)
block|{
name|rc
operator|=
operator|(
name|int
operator|)
name|cp
operator|->
name|openarg
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|->
name|open
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rc
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
name|rc
operator|--
expr_stmt|;
name|cp
operator|->
name|openarg
operator|=
literal|0
expr_stmt|;
name|portp
operator|->
name|rc
operator|=
name|rc
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
name|ST_OPENING
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|portp
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  *	Check if we are waiting for a close completion message.  */
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_CLOSING
condition|)
block|{
name|rc
operator|=
operator|(
name|int
operator|)
name|cp
operator|->
name|closearg
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|->
name|close
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rc
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
name|rc
operator|--
expr_stmt|;
name|cp
operator|->
name|closearg
operator|=
literal|0
expr_stmt|;
name|portp
operator|->
name|rc
operator|=
name|rc
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
name|ST_CLOSING
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|portp
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  *	Check if we are waiting for a command completion message. We may  *	need to copy out the command results associated with this command.  */
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ST_CMDING
condition|)
block|{
name|rc
operator|=
name|cp
operator|->
name|status
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|->
name|cmd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rc
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
name|rc
operator|--
expr_stmt|;
if|if
condition|(
name|portp
operator|->
name|argp
operator|!=
operator|(
name|void
operator|*
operator|)
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
name|cp
operator|->
name|args
index|[
literal|0
index|]
operator|)
argument_list|,
name|portp
operator|->
name|argp
argument_list|,
name|portp
operator|->
name|argsize
argument_list|)
expr_stmt|;
name|portp
operator|->
name|argp
operator|=
operator|(
name|void
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|cp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|portp
operator|->
name|rc
operator|=
name|rc
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
name|ST_CMDING
expr_stmt|;
name|stli_dodelaycmd
argument_list|(
name|portp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|portp
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  *	Check for any notification messages ready. This includes lots of  *	different types of events - RX chars ready, RX break received,  *	TX data low or empty in the slave, modem signals changed state.  *	Must be extremely carefull if we call to the LD, it may call  *	other routines of ours that will disable the memory...  *	Something else we need to be carefull of is race conditions on  *	marking the TX as empty...  */
name|donerx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|notify
condition|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|nt
operator|=
name|ap
operator|->
name|changed
expr_stmt|;
name|ap
operator|->
name|notify
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
if|if
condition|(
name|nt
operator|.
name|signal
operator|&
name|SG_DCD
condition|)
block|{
name|oldsigs
operator|=
name|portp
operator|->
name|sigs
expr_stmt|;
name|portp
operator|->
name|sigs
operator|=
name|stli_mktiocm
argument_list|(
name|nt
operator|.
name|sigvalue
argument_list|)
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
name|ST_GETSIGS
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
operator|(
name|portp
operator|->
name|sigs
operator|&
name|TIOCM_CD
operator|)
operator|)
expr_stmt|;
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nt
operator|.
name|data
operator|&
name|DT_RXBUSY
condition|)
block|{
name|donerx
operator|++
expr_stmt|;
name|stli_rxprocess
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nt
operator|.
name|data
operator|&
name|DT_RXBREAK
condition|)
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|TTY_BI
operator|,
name|tp
operator|)
expr_stmt|;
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nt
operator|.
name|data
operator|&
name|DT_TXEMPTY
condition|)
block|{
name|ap
operator|=
operator|(
specifier|volatile
name|cdkasy_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|portp
operator|->
name|addr
argument_list|)
expr_stmt|;
name|head
operator|=
operator|(
name|unsigned
name|int
operator|)
name|ap
operator|->
name|txq
operator|.
name|head
expr_stmt|;
name|tail
operator|=
operator|(
name|unsigned
name|int
operator|)
name|ap
operator|->
name|txq
operator|.
name|tail
expr_stmt|;
if|if
condition|(
name|tail
operator|!=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|ap
operator|->
name|txq
operator|.
name|tail
operator|)
condition|)
name|tail
operator|=
operator|(
name|unsigned
name|int
operator|)
name|ap
operator|->
name|txq
operator|.
name|tail
expr_stmt|;
name|head
operator|=
operator|(
name|head
operator|>=
name|tail
operator|)
condition|?
operator|(
name|head
operator|-
name|tail
operator|)
else|:
name|portp
operator|->
name|txsize
operator|-
operator|(
name|tail
operator|-
name|head
operator|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
literal|0
condition|)
block|{
name|portp
operator|->
name|state
operator|&=
operator|~
name|ST_TXBUSY
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nt
operator|.
name|data
operator|&
operator|(
name|DT_TXEMPTY
operator||
name|DT_TXLOW
operator|)
condition|)
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  *	It might seem odd that we are checking for more RX chars here.  *	But, we need to handle the case where the tty buffer was previously  *	filled, but we had more characters to pass up. The slave will not  *	send any more RX notify messages until the RX buffer has been emptied.  *	But it will leave the service bits on (since the buffer is not empty).  *	So from here we can try to process more RX chars.  */
if|if
condition|(
operator|(
operator|!
name|donerx
operator|)
operator|&&
operator|(
name|portp
operator|->
name|state
operator|&
name|ST_RXING
operator|)
condition|)
block|{
name|portp
operator|->
name|state
operator|&=
operator|~
name|ST_RXING
expr_stmt|;
name|stli_rxprocess
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|portp
operator|->
name|state
operator|&
operator|(
name|ST_OPENING
operator||
name|ST_CLOSING
operator||
name|ST_CMDING
operator||
name|ST_TXBUSY
operator||
name|ST_RXING
operator|)
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Service all ports on a particular board. Assumes that the boards  *	shared memory is enabled, and that the page pointer is pointed  *	at the cdk header structure.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|stli_brdpoll
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
specifier|volatile
name|cdkhdr_t
modifier|*
name|hdrp
parameter_list|)
block|{
name|stliport_t
modifier|*
name|portp
decl_stmt|;
name|unsigned
name|char
name|hostbits
index|[
operator|(
name|STL_MAXCHANS
operator|/
literal|8
operator|)
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
name|slavebits
index|[
operator|(
name|STL_MAXCHANS
operator|/
literal|8
operator|)
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|slavep
decl_stmt|;
name|int
name|bitpos
decl_stmt|,
name|bitat
decl_stmt|,
name|bitsize
decl_stmt|;
name|int
name|channr
decl_stmt|,
name|nrdevs
decl_stmt|,
name|slavebitchange
decl_stmt|;
name|bitsize
operator|=
name|brdp
operator|->
name|bitsize
expr_stmt|;
name|nrdevs
operator|=
name|brdp
operator|->
name|nrdevs
expr_stmt|;
comment|/*  *	Check if slave wants any service. Basically we try to do as  *	little work as possible here. There are 2 levels of service  *	bits. So if there is nothing to do we bail early. We check  *	8 service bits at a time in the inner loop, so we can bypass  *	the lot if none of them want service.  */
name|bcopy
argument_list|(
operator|(
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hdrp
operator|)
operator|+
name|brdp
operator|->
name|hostoffset
operator|)
argument_list|,
operator|&
name|hostbits
index|[
literal|0
index|]
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|slavebits
index|[
literal|0
index|]
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
name|slavebitchange
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bitpos
operator|=
literal|0
init|;
operator|(
name|bitpos
operator|<
name|bitsize
operator|)
condition|;
name|bitpos
operator|++
control|)
block|{
if|if
condition|(
name|hostbits
index|[
name|bitpos
index|]
operator|==
literal|0
condition|)
continue|continue;
name|channr
operator|=
name|bitpos
operator|*
literal|8
expr_stmt|;
name|bitat
operator|=
literal|0x1
expr_stmt|;
for|for
control|(
init|;
operator|(
name|channr
operator|<
name|nrdevs
operator|)
condition|;
name|channr
operator|++
operator|,
name|bitat
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|hostbits
index|[
name|bitpos
index|]
operator|&
name|bitat
condition|)
block|{
name|portp
operator|=
name|brdp
operator|->
name|ports
index|[
operator|(
name|channr
operator|-
literal|1
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|stli_hostcmd
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|)
condition|)
block|{
name|slavebitchange
operator|++
expr_stmt|;
name|slavebits
index|[
name|bitpos
index|]
operator||=
name|bitat
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*  *	If any of the ports are no longer busy then update them in the  *	slave request bits. We need to do this after, since a host port  *	service may initiate more slave requests...  */
if|if
condition|(
name|slavebitchange
condition|)
block|{
name|hdrp
operator|=
operator|(
specifier|volatile
name|cdkhdr_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|CDK_CDKADDR
argument_list|)
expr_stmt|;
name|slavep
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hdrp
operator|)
operator|+
name|brdp
operator|->
name|slaveoffset
expr_stmt|;
for|for
control|(
name|bitpos
operator|=
literal|0
init|;
operator|(
name|bitpos
operator|<
name|bitsize
operator|)
condition|;
name|bitpos
operator|++
control|)
block|{
if|if
condition|(
name|slavebits
index|[
name|bitpos
index|]
condition|)
name|slavep
index|[
name|bitpos
index|]
operator|&=
operator|~
name|slavebits
index|[
name|bitpos
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Driver poll routine. This routine polls the boards in use and passes  *	messages back up to host when neccesary. This is actually very  *	CPU efficient, since we will always have the kernel poll clock, it  *	adds only a few cycles when idle (since board service can be  *	determined very easily), but when loaded generates no interrupts  *	(with their expensive associated context change).  */
end_comment

begin_function
specifier|static
name|void
name|stli_poll
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|volatile
name|cdkhdr_t
modifier|*
name|hdrp
decl_stmt|;
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|int
name|brdnr
decl_stmt|,
name|x
decl_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/*  *	Check each board and do any servicing required.  */
for|for
control|(
name|brdnr
operator|=
literal|0
init|;
operator|(
name|brdnr
operator|<
name|stli_nrbrds
operator|)
condition|;
name|brdnr
operator|++
control|)
block|{
name|brdp
operator|=
name|stli_brds
index|[
name|brdnr
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|brdp
operator|->
name|state
operator|&
name|BST_STARTED
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|hdrp
operator|=
operator|(
specifier|volatile
name|cdkhdr_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|CDK_CDKADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrp
operator|->
name|hostreq
condition|)
name|stli_brdpoll
argument_list|(
name|brdp
argument_list|,
name|hdrp
argument_list|)
expr_stmt|;
name|EBRDDISABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|stli_poll
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Translate the termios settings into the port setting structure of  *	the slave.  */
end_comment

begin_function
specifier|static
name|void
name|stli_mkasyport
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|asyport_t
modifier|*
name|pp
parameter_list|,
name|struct
name|termios
modifier|*
name|tiosp
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_mkasyport(portp=%x,pp=%x,tiosp=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|,
operator|(
name|int
operator|)
name|pp
argument_list|,
operator|(
name|int
operator|)
name|tiosp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|pp
argument_list|,
sizeof|sizeof
argument_list|(
name|asyport_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  *	Start of by setting the baud, char size, parity and stop bit info.  */
if|if
condition|(
name|tiosp
operator|->
name|c_ispeed
operator|==
literal|0
condition|)
name|tiosp
operator|->
name|c_ispeed
operator|=
name|tiosp
operator|->
name|c_ospeed
expr_stmt|;
if|if
condition|(
operator|(
name|tiosp
operator|->
name|c_ospeed
operator|<
literal|0
operator|)
operator|||
operator|(
name|tiosp
operator|->
name|c_ospeed
operator|>
name|STL_MAXBAUD
operator|)
condition|)
name|tiosp
operator|->
name|c_ospeed
operator|=
name|STL_MAXBAUD
expr_stmt|;
name|pp
operator|->
name|baudout
operator|=
name|tiosp
operator|->
name|c_ospeed
expr_stmt|;
name|pp
operator|->
name|baudin
operator|=
name|pp
operator|->
name|baudout
expr_stmt|;
switch|switch
condition|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|pp
operator|->
name|csize
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|pp
operator|->
name|csize
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|pp
operator|->
name|csize
operator|=
literal|7
expr_stmt|;
break|break;
default|default:
name|pp
operator|->
name|csize
operator|=
literal|8
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|CSTOPB
condition|)
name|pp
operator|->
name|stopbs
operator|=
name|PT_STOP2
expr_stmt|;
else|else
name|pp
operator|->
name|stopbs
operator|=
name|PT_STOP1
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|PARENB
condition|)
block|{
if|if
condition|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|PARODD
condition|)
name|pp
operator|->
name|parity
operator|=
name|PT_ODDPARITY
expr_stmt|;
else|else
name|pp
operator|->
name|parity
operator|=
name|PT_EVENPARITY
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|parity
operator|=
name|PT_NOPARITY
expr_stmt|;
block|}
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|ISTRIP
condition|)
name|pp
operator|->
name|iflag
operator||=
name|FI_ISTRIP
expr_stmt|;
comment|/*  *	Set up any flow control options enabled.  */
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|IXON
condition|)
block|{
name|pp
operator|->
name|flow
operator||=
name|F_IXON
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|IXANY
condition|)
name|pp
operator|->
name|flow
operator||=
name|F_IXANY
expr_stmt|;
block|}
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|IXOFF
condition|)
name|pp
operator|->
name|flow
operator||=
name|F_IXOFF
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|CCTS_OFLOW
condition|)
name|pp
operator|->
name|flow
operator||=
name|F_CTSFLOW
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|CRTS_IFLOW
condition|)
name|pp
operator|->
name|flow
operator||=
name|F_RTSFLOW
expr_stmt|;
name|pp
operator|->
name|startin
operator|=
name|tiosp
operator|->
name|c_cc
index|[
name|VSTART
index|]
expr_stmt|;
name|pp
operator|->
name|stopin
operator|=
name|tiosp
operator|->
name|c_cc
index|[
name|VSTOP
index|]
expr_stmt|;
name|pp
operator|->
name|startout
operator|=
name|tiosp
operator|->
name|c_cc
index|[
name|VSTART
index|]
expr_stmt|;
name|pp
operator|->
name|stopout
operator|=
name|tiosp
operator|->
name|c_cc
index|[
name|VSTOP
index|]
expr_stmt|;
comment|/*  *	Set up the RX char marking mask with those RX error types we must  *	catch. We can get the slave to help us out a little here, it will  *	ignore parity errors and breaks for us, and mark parity errors in  *	the data stream.  */
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|IGNPAR
condition|)
name|pp
operator|->
name|iflag
operator||=
name|FI_IGNRXERRS
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|IGNBRK
condition|)
name|pp
operator|->
name|iflag
operator||=
name|FI_IGNBREAK
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
operator|(
name|INPCK
operator||
name|PARMRK
operator|)
condition|)
name|pp
operator|->
name|iflag
operator||=
name|FI_1MARKRXERRS
expr_stmt|;
comment|/*  *	Transfer any persistent flags into the asyport structure.  */
name|pp
operator|->
name|pflag
operator|=
name|portp
operator|->
name|pflag
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Construct a slave signals structure for setting the DTR and RTS  *	signals as specified.  */
end_comment

begin_function
specifier|static
name|void
name|stli_mkasysigs
parameter_list|(
name|asysigs_t
modifier|*
name|sp
parameter_list|,
name|int
name|dtr
parameter_list|,
name|int
name|rts
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_mkasysigs(sp=%x,dtr=%d,rts=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|sp
argument_list|,
name|dtr
argument_list|,
name|rts
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
name|asysigs_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtr
operator|>=
literal|0
condition|)
block|{
name|sp
operator|->
name|signal
operator||=
name|SG_DTR
expr_stmt|;
name|sp
operator|->
name|sigvalue
operator||=
operator|(
operator|(
name|dtr
operator|>
literal|0
operator|)
condition|?
name|SG_DTR
else|:
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|rts
operator|>=
literal|0
condition|)
block|{
name|sp
operator|->
name|signal
operator||=
name|SG_RTS
expr_stmt|;
name|sp
operator|->
name|sigvalue
operator||=
operator|(
operator|(
name|rts
operator|>
literal|0
operator|)
condition|?
name|SG_RTS
else|:
literal|0
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Convert the signals returned from the slave into a local TIOCM type  *	signals value. We keep them localy in TIOCM format.  */
end_comment

begin_function
specifier|static
name|long
name|stli_mktiocm
parameter_list|(
name|unsigned
name|long
name|sigvalue
parameter_list|)
block|{
name|long
name|tiocm
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_mktiocm(sigvalue=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|sigvalue
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tiocm
operator|=
literal|0
expr_stmt|;
name|tiocm
operator||=
operator|(
operator|(
name|sigvalue
operator|&
name|SG_DCD
operator|)
condition|?
name|TIOCM_CD
else|:
literal|0
operator|)
expr_stmt|;
name|tiocm
operator||=
operator|(
operator|(
name|sigvalue
operator|&
name|SG_CTS
operator|)
condition|?
name|TIOCM_CTS
else|:
literal|0
operator|)
expr_stmt|;
name|tiocm
operator||=
operator|(
operator|(
name|sigvalue
operator|&
name|SG_RI
operator|)
condition|?
name|TIOCM_RI
else|:
literal|0
operator|)
expr_stmt|;
name|tiocm
operator||=
operator|(
operator|(
name|sigvalue
operator|&
name|SG_DSR
operator|)
condition|?
name|TIOCM_DSR
else|:
literal|0
operator|)
expr_stmt|;
name|tiocm
operator||=
operator|(
operator|(
name|sigvalue
operator|&
name|SG_DTR
operator|)
condition|?
name|TIOCM_DTR
else|:
literal|0
operator|)
expr_stmt|;
name|tiocm
operator||=
operator|(
operator|(
name|sigvalue
operator|&
name|SG_RTS
operator|)
condition|?
name|TIOCM_RTS
else|:
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|tiocm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Enable l_rint processing bypass mode if tty modes allow it.  */
end_comment

begin_function
specifier|static
name|void
name|stli_ttyoptim
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|struct
name|termios
modifier|*
name|tiosp
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|tiosp
operator|->
name|c_iflag
operator|&
operator|(
name|ICRNL
operator||
name|IGNCR
operator||
name|IMAXBEL
operator||
name|INLCR
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|BRKINT
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|IGNBRK
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|PARMRK
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|tiosp
operator|->
name|c_iflag
operator|&
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|==
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|tiosp
operator|->
name|c_lflag
operator|&
operator|(
name|ECHO
operator||
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
operator||
name|PENDIN
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|==
name|ttyinput
operator|)
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
name|portp
operator|->
name|hotchar
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_hotchar
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	All panels and ports actually attached have been worked out. All  *	we need to do here is set up the appropriate per port data structures.  */
end_comment

begin_function
specifier|static
name|int
name|stli_initports
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|stliport_t
modifier|*
name|portp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|panelnr
decl_stmt|,
name|panelport
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_initports(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|panelnr
operator|=
literal|0
operator|,
name|panelport
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|brdp
operator|->
name|nrports
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|portp
operator|=
operator|(
name|stliport_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|stliport_t
argument_list|)
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: failed to allocate port structure\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bzero
argument_list|(
name|portp
argument_list|,
sizeof|sizeof
argument_list|(
name|stliport_t
argument_list|)
argument_list|)
expr_stmt|;
name|portp
operator|->
name|portnr
operator|=
name|i
expr_stmt|;
name|portp
operator|->
name|brdnr
operator|=
name|brdp
operator|->
name|brdnr
expr_stmt|;
name|portp
operator|->
name|panelnr
operator|=
name|panelnr
expr_stmt|;
name|portp
operator|->
name|initintios
operator|.
name|c_ispeed
operator|=
name|STL_DEFSPEED
expr_stmt|;
name|portp
operator|->
name|initintios
operator|.
name|c_ospeed
operator|=
name|STL_DEFSPEED
expr_stmt|;
name|portp
operator|->
name|initintios
operator|.
name|c_cflag
operator|=
name|STL_DEFCFLAG
expr_stmt|;
name|portp
operator|->
name|initintios
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|portp
operator|->
name|initintios
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|portp
operator|->
name|initintios
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ttydefchars
index|[
literal|0
index|]
argument_list|,
operator|&
name|portp
operator|->
name|initintios
operator|.
name|c_cc
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|portp
operator|->
name|initintios
operator|.
name|c_cc
argument_list|)
argument_list|)
expr_stmt|;
name|portp
operator|->
name|initouttios
operator|=
name|portp
operator|->
name|initintios
expr_stmt|;
name|portp
operator|->
name|dtrwait
operator|=
literal|3
operator|*
name|hz
expr_stmt|;
name|panelport
operator|++
expr_stmt|;
if|if
condition|(
name|panelport
operator|>=
name|brdp
operator|->
name|panels
index|[
name|panelnr
index|]
condition|)
block|{
name|panelport
operator|=
literal|0
expr_stmt|;
name|panelnr
operator|++
expr_stmt|;
block|}
name|brdp
operator|->
name|ports
index|[
name|i
index|]
operator|=
name|portp
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	All the following routines are board specific hardware operations.  */
end_comment

begin_function
specifier|static
name|void
name|stli_ecpinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|unsigned
name|long
name|memconf
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_ecpinit(brdp=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_ATCONFR
operator|)
argument_list|,
name|ECP_ATSTOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_ATCONFR
operator|)
argument_list|,
name|ECP_ATDISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|memconf
operator|=
operator|(
name|brdp
operator|->
name|paddr
operator|&
name|ECP_ATADDRMASK
operator|)
operator|>>
name|ECP_ATADDRSHFT
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_ATMEMAR
operator|)
argument_list|,
name|memconf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_ecpenable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_ecpenable(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_ATCONFR
operator|)
argument_list|,
name|ECP_ATENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_ecpdisable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_ecpdisable(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_ATCONFR
operator|)
argument_list|,
name|ECP_ATDISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|stli_ecpgetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_ecpgetmemptr(brdp=%x,offset=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|offset
operator|>
name|brdp
operator|->
name|memsize
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: shared memory pointer=%x out of range at "
literal|"line=%d(%d), brd=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|,
name|line
argument_list|,
name|__LINE__
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|brdp
operator|->
name|vaddr
operator|+
operator|(
name|offset
operator|%
name|ECP_ATPAGESIZE
operator|)
expr_stmt|;
name|val
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|offset
operator|/
name|ECP_ATPAGESIZE
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_ATMEMPR
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_ecpreset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_ecpreset(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_ATCONFR
operator|)
argument_list|,
name|ECP_ATSTOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_ATCONFR
operator|)
argument_list|,
name|ECP_ATDISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_ecpintr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_ecpintr(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|brdp
operator|->
name|iobase
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	The following set of functions act on ECP EISA boards.  */
end_comment

begin_function
specifier|static
name|void
name|stli_ecpeiinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|unsigned
name|long
name|memconf
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_ecpeiinit(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_EIBRDENAB
operator|)
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_EICONFR
operator|)
argument_list|,
name|ECP_EISTOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_EICONFR
operator|)
argument_list|,
name|ECP_EIDISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|memconf
operator|=
operator|(
name|brdp
operator|->
name|paddr
operator|&
name|ECP_EIADDRMASKL
operator|)
operator|>>
name|ECP_EIADDRSHFTL
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_EIMEMARL
operator|)
argument_list|,
name|memconf
argument_list|)
expr_stmt|;
name|memconf
operator|=
operator|(
name|brdp
operator|->
name|paddr
operator|&
name|ECP_EIADDRMASKH
operator|)
operator|>>
name|ECP_EIADDRSHFTH
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_EIMEMARH
operator|)
argument_list|,
name|memconf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_ecpeienable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_EICONFR
operator|)
argument_list|,
name|ECP_EIENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_ecpeidisable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_EICONFR
operator|)
argument_list|,
name|ECP_EIDISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|stli_ecpeigetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_ecpeigetmemptr(brdp=%x,offset=%x,line=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|offset
operator|>
name|brdp
operator|->
name|memsize
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: shared memory pointer=%x out of range at "
literal|"line=%d(%d), brd=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|,
name|line
argument_list|,
name|__LINE__
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|brdp
operator|->
name|vaddr
operator|+
operator|(
name|offset
operator|%
name|ECP_EIPAGESIZE
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|ECP_EIPAGESIZE
condition|)
name|val
operator|=
name|ECP_EIENABLE
expr_stmt|;
else|else
name|val
operator|=
name|ECP_EIENABLE
operator||
literal|0x40
expr_stmt|;
block|}
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_EICONFR
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_ecpeireset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_EICONFR
operator|)
argument_list|,
name|ECP_EISTOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_EICONFR
operator|)
argument_list|,
name|ECP_EIDISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	The following set of functions act on ECP MCA boards.  */
end_comment

begin_function
specifier|static
name|void
name|stli_ecpmcenable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_MCCONFR
operator|)
argument_list|,
name|ECP_MCENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_ecpmcdisable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_MCCONFR
operator|)
argument_list|,
name|ECP_MCDISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|stli_ecpmcgetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|;
if|if
condition|(
name|offset
operator|>
name|brdp
operator|->
name|memsize
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: shared memory pointer=%x out of range at "
literal|"line=%d(%d), brd=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|,
name|line
argument_list|,
name|__LINE__
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|brdp
operator|->
name|vaddr
operator|+
operator|(
name|offset
operator|%
name|ECP_MCPAGESIZE
operator|)
expr_stmt|;
name|val
operator|=
operator|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|offset
operator|/
name|ECP_MCPAGESIZE
argument_list|)
operator|)
operator||
name|ECP_MCENABLE
expr_stmt|;
block|}
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_MCCONFR
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_ecpmcreset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_MCCONFR
operator|)
argument_list|,
name|ECP_MCSTOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ECP_MCCONFR
operator|)
argument_list|,
name|ECP_MCDISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	The following routines act on ONboards.  */
end_comment

begin_function
specifier|static
name|void
name|stli_onbinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|unsigned
name|long
name|memconf
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_onbinit(brdp=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_ATCONFR
operator|)
argument_list|,
name|ONB_ATSTOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_ATCONFR
operator|)
argument_list|,
name|ONB_ATDISABLE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|1000
operator|)
condition|;
name|i
operator|++
control|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|memconf
operator|=
operator|(
name|brdp
operator|->
name|paddr
operator|&
name|ONB_ATADDRMASK
operator|)
operator|>>
name|ONB_ATADDRSHFT
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_ATMEMAR
operator|)
argument_list|,
name|memconf
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|brdp
operator|->
name|iobase
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_onbenable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_onbenable(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_ATCONFR
operator|)
argument_list|,
operator|(
name|ONB_ATENABLE
operator||
name|brdp
operator|->
name|confbits
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_onbdisable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_onbdisable(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_ATCONFR
operator|)
argument_list|,
operator|(
name|ONB_ATDISABLE
operator||
name|brdp
operator|->
name|confbits
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|stli_onbgetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_onbgetmemptr(brdp=%x,offset=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|offset
operator|>
name|brdp
operator|->
name|memsize
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: shared memory pointer=%x out of range at "
literal|"line=%d(%d), brd=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|,
name|line
argument_list|,
name|__LINE__
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|brdp
operator|->
name|vaddr
operator|+
operator|(
name|offset
operator|%
name|ONB_ATPAGESIZE
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_onbreset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_onbreset(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_ATCONFR
operator|)
argument_list|,
name|ONB_ATSTOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_ATCONFR
operator|)
argument_list|,
name|ONB_ATDISABLE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|1000
operator|)
condition|;
name|i
operator|++
control|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	The following routines act on ONboard EISA.  */
end_comment

begin_function
specifier|static
name|void
name|stli_onbeinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|unsigned
name|long
name|memconf
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_onbeinit(brdp=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_EIBRDENAB
operator|)
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_EICONFR
operator|)
argument_list|,
name|ONB_EISTOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_EICONFR
operator|)
argument_list|,
name|ONB_EIDISABLE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|1000
operator|)
condition|;
name|i
operator|++
control|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|memconf
operator|=
operator|(
name|brdp
operator|->
name|paddr
operator|&
name|ONB_EIADDRMASKL
operator|)
operator|>>
name|ONB_EIADDRSHFTL
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_EIMEMARL
operator|)
argument_list|,
name|memconf
argument_list|)
expr_stmt|;
name|memconf
operator|=
operator|(
name|brdp
operator|->
name|paddr
operator|&
name|ONB_EIADDRMASKH
operator|)
operator|>>
name|ONB_EIADDRSHFTH
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_EIMEMARH
operator|)
argument_list|,
name|memconf
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|brdp
operator|->
name|iobase
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_onbeenable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_onbeenable(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_EICONFR
operator|)
argument_list|,
name|ONB_EIENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_onbedisable
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_onbedisable(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_EICONFR
operator|)
argument_list|,
name|ONB_EIDISABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|stli_onbegetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_onbegetmemptr(brdp=%x,offset=%x,line=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|,
name|line
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|offset
operator|>
name|brdp
operator|->
name|memsize
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: shared memory pointer=%x out of range at "
literal|"line=%d(%d), brd=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|,
name|line
argument_list|,
name|__LINE__
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|brdp
operator|->
name|vaddr
operator|+
operator|(
name|offset
operator|%
name|ONB_EIPAGESIZE
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|ONB_EIPAGESIZE
condition|)
name|val
operator|=
name|ONB_EIENABLE
expr_stmt|;
else|else
name|val
operator|=
name|ONB_EIENABLE
operator||
literal|0x40
expr_stmt|;
block|}
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_EICONFR
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_onbereset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_onbereset(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_EICONFR
operator|)
argument_list|,
name|ONB_EISTOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|ONB_EICONFR
operator|)
argument_list|,
name|ONB_EIDISABLE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|1000
operator|)
condition|;
name|i
operator|++
control|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	The following routines act on Brumby boards.  */
end_comment

begin_function
specifier|static
name|void
name|stli_bbyinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_bbyinit(brdp=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|BBY_ATCONFR
operator|)
argument_list|,
name|BBY_ATSTOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|BBY_ATCONFR
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|1000
operator|)
condition|;
name|i
operator|++
control|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|brdp
operator|->
name|iobase
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|stli_bbygetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_bbygetmemptr(brdp=%x,offset=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|offset
operator|>
name|brdp
operator|->
name|memsize
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: shared memory pointer=%x out of range at "
literal|"line=%d(%d), brd=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|,
name|line
argument_list|,
name|__LINE__
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|brdp
operator|->
name|vaddr
operator|+
operator|(
name|offset
operator|%
name|BBY_PAGESIZE
operator|)
expr_stmt|;
name|val
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|offset
operator|/
name|BBY_PAGESIZE
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|BBY_ATCONFR
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_bbyreset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_bbyreset(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|BBY_ATCONFR
operator|)
argument_list|,
name|BBY_ATSTOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|brdp
operator|->
name|iobase
operator|+
name|BBY_ATCONFR
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|1000
operator|)
condition|;
name|i
operator|++
control|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	The following routines act on original old Stallion boards.  */
end_comment

begin_function
specifier|static
name|void
name|stli_stalinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_stalinit(brdp=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|brdp
operator|->
name|iobase
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|1000
operator|)
condition|;
name|i
operator|++
control|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|stli_stalgetmemptr
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_stalgetmemptr(brdp=%x,offset=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|offset
operator|>
name|brdp
operator|->
name|memsize
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: shared memory pointer=%x out of range at "
literal|"line=%d(%d), brd=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|offset
argument_list|,
name|line
argument_list|,
name|__LINE__
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|brdp
operator|->
name|vaddr
operator|+
operator|(
name|offset
operator|%
name|STAL_PAGESIZE
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stli_stalreset
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
specifier|volatile
name|unsigned
name|long
modifier|*
name|vecp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_stalreset(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vecp
operator|=
operator|(
specifier|volatile
name|unsigned
name|long
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|brdp
operator|->
name|vaddr
operator|+
literal|0x30
operator|)
expr_stmt|;
operator|*
name|vecp
operator|=
literal|0xffff0000
expr_stmt|;
name|outb
argument_list|(
name|brdp
operator|->
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|1000
operator|)
condition|;
name|i
operator|++
control|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Try to find an ECP board and initialize it. This handles only ECP  *	board types.  */
end_comment

begin_function
specifier|static
name|int
name|stli_initecp
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|cdkecpsig_t
name|sig
decl_stmt|;
name|cdkecpsig_t
modifier|*
name|sigsp
decl_stmt|;
name|unsigned
name|int
name|status
decl_stmt|,
name|nxtid
decl_stmt|;
name|int
name|panelnr
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_initecp(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  *	Do a basic sanity check on the IO and memory addresses.  */
if|if
condition|(
operator|(
name|brdp
operator|->
name|iobase
operator|==
literal|0
operator|)
operator|||
operator|(
name|brdp
operator|->
name|paddr
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*  *	Based on the specific board type setup the common vars to access  *	and enable shared memory. Set all board specific information now  *	as well.  */
switch|switch
condition|(
name|brdp
operator|->
name|brdtype
condition|)
block|{
case|case
name|BRD_ECP
case|:
name|brdp
operator|->
name|memsize
operator|=
name|ECP_MEMSIZE
expr_stmt|;
name|brdp
operator|->
name|pagesize
operator|=
name|ECP_ATPAGESIZE
expr_stmt|;
name|brdp
operator|->
name|init
operator|=
name|stli_ecpinit
expr_stmt|;
name|brdp
operator|->
name|enable
operator|=
name|stli_ecpenable
expr_stmt|;
name|brdp
operator|->
name|reenable
operator|=
name|stli_ecpenable
expr_stmt|;
name|brdp
operator|->
name|disable
operator|=
name|stli_ecpdisable
expr_stmt|;
name|brdp
operator|->
name|getmemptr
operator|=
name|stli_ecpgetmemptr
expr_stmt|;
name|brdp
operator|->
name|intr
operator|=
name|stli_ecpintr
expr_stmt|;
name|brdp
operator|->
name|reset
operator|=
name|stli_ecpreset
expr_stmt|;
break|break;
case|case
name|BRD_ECPE
case|:
name|brdp
operator|->
name|memsize
operator|=
name|ECP_MEMSIZE
expr_stmt|;
name|brdp
operator|->
name|pagesize
operator|=
name|ECP_EIPAGESIZE
expr_stmt|;
name|brdp
operator|->
name|init
operator|=
name|stli_ecpeiinit
expr_stmt|;
name|brdp
operator|->
name|enable
operator|=
name|stli_ecpeienable
expr_stmt|;
name|brdp
operator|->
name|reenable
operator|=
name|stli_ecpeienable
expr_stmt|;
name|brdp
operator|->
name|disable
operator|=
name|stli_ecpeidisable
expr_stmt|;
name|brdp
operator|->
name|getmemptr
operator|=
name|stli_ecpeigetmemptr
expr_stmt|;
name|brdp
operator|->
name|intr
operator|=
name|stli_ecpintr
expr_stmt|;
name|brdp
operator|->
name|reset
operator|=
name|stli_ecpeireset
expr_stmt|;
break|break;
case|case
name|BRD_ECPMC
case|:
name|brdp
operator|->
name|memsize
operator|=
name|ECP_MEMSIZE
expr_stmt|;
name|brdp
operator|->
name|pagesize
operator|=
name|ECP_MCPAGESIZE
expr_stmt|;
name|brdp
operator|->
name|init
operator|=
name|NULL
expr_stmt|;
name|brdp
operator|->
name|enable
operator|=
name|stli_ecpmcenable
expr_stmt|;
name|brdp
operator|->
name|reenable
operator|=
name|stli_ecpmcenable
expr_stmt|;
name|brdp
operator|->
name|disable
operator|=
name|stli_ecpmcdisable
expr_stmt|;
name|brdp
operator|->
name|getmemptr
operator|=
name|stli_ecpmcgetmemptr
expr_stmt|;
name|brdp
operator|->
name|intr
operator|=
name|stli_ecpintr
expr_stmt|;
name|brdp
operator|->
name|reset
operator|=
name|stli_ecpmcreset
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/*  *	The per-board operations structure is all setup, so now lets go  *	and get the board operational. Firstly initialize board configuration  *	registers.  */
name|EBRDINIT
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
comment|/*  *	Now that all specific code is set up, enable the shared memory and  *	look for the a signature area that will tell us exactly what board  *	this is, and what it is connected to it.  */
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|sigsp
operator|=
operator|(
name|cdkecpsig_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|CDK_SIGADDR
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sigsp
argument_list|,
operator|&
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|cdkecpsig_t
argument_list|)
argument_list|)
expr_stmt|;
name|EBRDDISABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s(%d): sig-> magic=%x rom=%x panel=%x,%x,%x,%x,%x,%x,%x,%x\n", 		__file__, __LINE__, (int) sig.magic, sig.romver, 		sig.panelid[0], (int) sig.panelid[1], (int) sig.panelid[2], 		(int) sig.panelid[3], (int) sig.panelid[4], 		(int) sig.panelid[5], (int) sig.panelid[6], 		(int) sig.panelid[7]);
endif|#
directive|endif
if|if
condition|(
name|sig
operator|.
name|magic
operator|!=
name|ECP_MAGIC
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*  *	Scan through the signature looking at the panels connected to the  *	board. Calculate the total number of ports as we go.  */
for|for
control|(
name|panelnr
operator|=
literal|0
operator|,
name|nxtid
operator|=
literal|0
init|;
operator|(
name|panelnr
operator|<
name|STL_MAXPANELS
operator|)
condition|;
name|panelnr
operator|++
control|)
block|{
name|status
operator|=
name|sig
operator|.
name|panelid
index|[
name|nxtid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|ECH_PNLIDMASK
operator|)
operator|!=
name|nxtid
condition|)
break|break;
name|brdp
operator|->
name|panelids
index|[
name|panelnr
index|]
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ECH_PNL16PORT
condition|)
block|{
name|brdp
operator|->
name|panels
index|[
name|panelnr
index|]
operator|=
literal|16
expr_stmt|;
name|brdp
operator|->
name|nrports
operator|+=
literal|16
expr_stmt|;
name|nxtid
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|brdp
operator|->
name|panels
index|[
name|panelnr
index|]
operator|=
literal|8
expr_stmt|;
name|brdp
operator|->
name|nrports
operator|+=
literal|8
expr_stmt|;
name|nxtid
operator|++
expr_stmt|;
block|}
name|brdp
operator|->
name|nrpanels
operator|++
expr_stmt|;
block|}
name|brdp
operator|->
name|state
operator||=
name|BST_FOUND
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Try to find an ONboard, Brumby or Stallion board and initialize it.  *	This handles only these board types.  */
end_comment

begin_function
specifier|static
name|int
name|stli_initonb
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|cdkonbsig_t
name|sig
decl_stmt|;
name|cdkonbsig_t
modifier|*
name|sigsp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_initonb(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  *	Do a basic sanity check on the IO and memory addresses.  */
if|if
condition|(
operator|(
name|brdp
operator|->
name|iobase
operator|==
literal|0
operator|)
operator|||
operator|(
name|brdp
operator|->
name|paddr
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*  *	Based on the specific board type setup the common vars to access  *	and enable shared memory. Set all board specific information now  *	as well.  */
switch|switch
condition|(
name|brdp
operator|->
name|brdtype
condition|)
block|{
case|case
name|BRD_ONBOARD
case|:
case|case
name|BRD_ONBOARD32
case|:
case|case
name|BRD_ONBOARD2
case|:
case|case
name|BRD_ONBOARD2_32
case|:
case|case
name|BRD_ONBOARDRS
case|:
name|brdp
operator|->
name|memsize
operator|=
name|ONB_MEMSIZE
expr_stmt|;
name|brdp
operator|->
name|pagesize
operator|=
name|ONB_ATPAGESIZE
expr_stmt|;
name|brdp
operator|->
name|init
operator|=
name|stli_onbinit
expr_stmt|;
name|brdp
operator|->
name|enable
operator|=
name|stli_onbenable
expr_stmt|;
name|brdp
operator|->
name|reenable
operator|=
name|stli_onbenable
expr_stmt|;
name|brdp
operator|->
name|disable
operator|=
name|stli_onbdisable
expr_stmt|;
name|brdp
operator|->
name|getmemptr
operator|=
name|stli_onbgetmemptr
expr_stmt|;
name|brdp
operator|->
name|intr
operator|=
name|stli_ecpintr
expr_stmt|;
name|brdp
operator|->
name|reset
operator|=
name|stli_onbreset
expr_stmt|;
name|brdp
operator|->
name|confbits
operator|=
operator|(
name|brdp
operator|->
name|paddr
operator|>
literal|0x100000
operator|)
condition|?
name|ONB_HIMEMENAB
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|BRD_ONBOARDE
case|:
name|brdp
operator|->
name|memsize
operator|=
name|ONB_EIMEMSIZE
expr_stmt|;
name|brdp
operator|->
name|pagesize
operator|=
name|ONB_EIPAGESIZE
expr_stmt|;
name|brdp
operator|->
name|init
operator|=
name|stli_onbeinit
expr_stmt|;
name|brdp
operator|->
name|enable
operator|=
name|stli_onbeenable
expr_stmt|;
name|brdp
operator|->
name|reenable
operator|=
name|stli_onbeenable
expr_stmt|;
name|brdp
operator|->
name|disable
operator|=
name|stli_onbedisable
expr_stmt|;
name|brdp
operator|->
name|getmemptr
operator|=
name|stli_onbegetmemptr
expr_stmt|;
name|brdp
operator|->
name|intr
operator|=
name|stli_ecpintr
expr_stmt|;
name|brdp
operator|->
name|reset
operator|=
name|stli_onbereset
expr_stmt|;
break|break;
case|case
name|BRD_BRUMBY4
case|:
case|case
name|BRD_BRUMBY8
case|:
case|case
name|BRD_BRUMBY16
case|:
name|brdp
operator|->
name|memsize
operator|=
name|BBY_MEMSIZE
expr_stmt|;
name|brdp
operator|->
name|pagesize
operator|=
name|BBY_PAGESIZE
expr_stmt|;
name|brdp
operator|->
name|init
operator|=
name|stli_bbyinit
expr_stmt|;
name|brdp
operator|->
name|enable
operator|=
name|NULL
expr_stmt|;
name|brdp
operator|->
name|reenable
operator|=
name|NULL
expr_stmt|;
name|brdp
operator|->
name|disable
operator|=
name|NULL
expr_stmt|;
name|brdp
operator|->
name|getmemptr
operator|=
name|stli_bbygetmemptr
expr_stmt|;
name|brdp
operator|->
name|intr
operator|=
name|stli_ecpintr
expr_stmt|;
name|brdp
operator|->
name|reset
operator|=
name|stli_bbyreset
expr_stmt|;
break|break;
case|case
name|BRD_STALLION
case|:
name|brdp
operator|->
name|memsize
operator|=
name|STAL_MEMSIZE
expr_stmt|;
name|brdp
operator|->
name|pagesize
operator|=
name|STAL_PAGESIZE
expr_stmt|;
name|brdp
operator|->
name|init
operator|=
name|stli_stalinit
expr_stmt|;
name|brdp
operator|->
name|enable
operator|=
name|NULL
expr_stmt|;
name|brdp
operator|->
name|reenable
operator|=
name|NULL
expr_stmt|;
name|brdp
operator|->
name|disable
operator|=
name|NULL
expr_stmt|;
name|brdp
operator|->
name|getmemptr
operator|=
name|stli_stalgetmemptr
expr_stmt|;
name|brdp
operator|->
name|intr
operator|=
name|stli_ecpintr
expr_stmt|;
name|brdp
operator|->
name|reset
operator|=
name|stli_stalreset
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/*  *	The per-board operations structure is all setup, so now lets go  *	and get the board operational. Firstly initialize board configuration  *	registers.  */
name|EBRDINIT
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
comment|/*  *	Now that all specific code is set up, enable the shared memory and  *	look for the a signature area that will tell us exactly what board  *	this is, and how many ports.  */
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|sigsp
operator|=
operator|(
name|cdkonbsig_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|CDK_SIGADDR
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sigsp
argument_list|,
operator|&
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|cdkonbsig_t
argument_list|)
argument_list|)
expr_stmt|;
name|EBRDDISABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s(%d): sig-> magic=%x:%x:%x:%x romver=%x amask=%x:%x:%x\n", 		__file__, __LINE__, sig.magic0, sig.magic1, sig.magic2, 		sig.magic3, sig.romver, sig.amask0, sig.amask1, sig.amask2);
endif|#
directive|endif
if|if
condition|(
operator|(
name|sig
operator|.
name|magic0
operator|!=
name|ONB_MAGIC0
operator|)
operator|||
operator|(
name|sig
operator|.
name|magic1
operator|!=
name|ONB_MAGIC1
operator|)
operator|||
operator|(
name|sig
operator|.
name|magic2
operator|!=
name|ONB_MAGIC2
operator|)
operator|||
operator|(
name|sig
operator|.
name|magic3
operator|!=
name|ONB_MAGIC3
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*  *	Scan through the signature alive mask and calculate how many ports  *	there are on this board.  */
name|brdp
operator|->
name|nrpanels
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sig
operator|.
name|amask1
condition|)
block|{
name|brdp
operator|->
name|nrports
operator|=
literal|32
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
literal|16
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|sig
operator|.
name|amask0
operator|<<
name|i
operator|)
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
name|brdp
operator|->
name|nrports
operator|=
name|i
expr_stmt|;
block|}
name|brdp
operator|->
name|panels
index|[
literal|0
index|]
operator|=
name|brdp
operator|->
name|nrports
expr_stmt|;
name|brdp
operator|->
name|state
operator||=
name|BST_FOUND
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Start up a running board. This routine is only called after the  *	code has been down loaded to the board and is operational. It will  *	read in the memory map, and get the show on the road...  */
end_comment

begin_function
specifier|static
name|int
name|stli_startbrd
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
specifier|volatile
name|cdkhdr_t
modifier|*
name|hdrp
decl_stmt|;
specifier|volatile
name|cdkmem_t
modifier|*
name|memp
decl_stmt|;
specifier|volatile
name|cdkasy_t
modifier|*
name|ap
decl_stmt|;
name|stliport_t
modifier|*
name|portp
decl_stmt|;
name|int
name|portnr
decl_stmt|,
name|nrdevs
decl_stmt|,
name|i
decl_stmt|,
name|rc
decl_stmt|,
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_startbrd(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rc
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|hdrp
operator|=
operator|(
specifier|volatile
name|cdkhdr_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|CDK_CDKADDR
argument_list|)
expr_stmt|;
name|nrdevs
operator|=
name|hdrp
operator|->
name|nrdevs
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s(%d): CDK version %d.%d.%d --> nrdevs=%d memp=%x hostp=%x " 		"slavep=%x\n", __file__, __LINE__, hdrp->ver_release, 		hdrp->ver_modification, hdrp->ver_fix, nrdevs, 		(int) hdrp->memp, (int) hdrp->hostp, (int) hdrp->slavep);
endif|#
directive|endif
if|if
condition|(
name|nrdevs
operator|<
operator|(
name|brdp
operator|->
name|nrports
operator|+
literal|1
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: slave failed to allocate memory for all "
literal|"devices, devices=%d\n"
argument_list|,
name|nrdevs
argument_list|)
expr_stmt|;
name|brdp
operator|->
name|nrports
operator|=
name|nrdevs
operator|-
literal|1
expr_stmt|;
block|}
name|brdp
operator|->
name|nrdevs
operator|=
name|nrdevs
expr_stmt|;
name|brdp
operator|->
name|hostoffset
operator|=
name|hdrp
operator|->
name|hostp
operator|-
name|CDK_CDKADDR
expr_stmt|;
name|brdp
operator|->
name|slaveoffset
operator|=
name|hdrp
operator|->
name|slavep
operator|-
name|CDK_CDKADDR
expr_stmt|;
name|brdp
operator|->
name|bitsize
operator|=
operator|(
name|nrdevs
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|memp
operator|=
operator|(
specifier|volatile
name|cdkmem_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|hdrp
operator|->
name|memp
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|memp
operator|)
operator|>
name|brdp
operator|->
name|memsize
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: corrupted shared memory region?\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|stli_donestartup
goto|;
block|}
name|memp
operator|=
operator|(
specifier|volatile
name|cdkmem_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|memp
argument_list|)
expr_stmt|;
if|if
condition|(
name|memp
operator|->
name|dtype
operator|!=
name|TYP_ASYNCTRL
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: no slave control device found\n"
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EIO
expr_stmt|;
goto|goto
name|stli_donestartup
goto|;
block|}
name|memp
operator|++
expr_stmt|;
comment|/*  *	Cycle through memory allocation of each port. We are guaranteed to  *	have all ports inside the first page of slave window, so no need to  *	change pages while reading memory map.  */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|portnr
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|nrdevs
operator|)
condition|;
name|i
operator|++
operator|,
name|portnr
operator|++
operator|,
name|memp
operator|++
control|)
block|{
if|if
condition|(
name|memp
operator|->
name|dtype
operator|!=
name|TYP_ASYNC
condition|)
break|break;
name|portp
operator|=
name|brdp
operator|->
name|ports
index|[
name|portnr
index|]
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
condition|)
break|break;
name|portp
operator|->
name|devnr
operator|=
name|i
expr_stmt|;
name|portp
operator|->
name|addr
operator|=
name|memp
operator|->
name|offset
expr_stmt|;
name|portp
operator|->
name|reqidx
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|i
operator|*
literal|8
operator|/
name|nrdevs
argument_list|)
expr_stmt|;
name|portp
operator|->
name|reqbit
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|0x1
operator|<<
name|portp
operator|->
name|reqidx
argument_list|)
expr_stmt|;
name|portp
operator|->
name|portidx
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|i
operator|/
literal|8
argument_list|)
expr_stmt|;
name|portp
operator|->
name|portbit
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|0x1
operator|<<
operator|(
name|i
operator|%
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
name|hdrp
operator|->
name|slavereq
operator|=
literal|0xff
expr_stmt|;
comment|/*  *	For each port setup a local copy of the RX and TX buffer offsets  *	and sizes. We do this separate from the above, because we need to  *	move the shared memory page...  */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|portnr
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|nrdevs
operator|)
condition|;
name|i
operator|++
operator|,
name|portnr
operator|++
control|)
block|{
name|portp
operator|=
name|brdp
operator|->
name|ports
index|[
name|portnr
index|]
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
condition|)
break|break;
if|if
condition|(
name|portp
operator|->
name|addr
operator|==
literal|0
condition|)
break|break;
name|ap
operator|=
operator|(
specifier|volatile
name|cdkasy_t
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|portp
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|!=
operator|(
specifier|volatile
name|cdkasy_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|portp
operator|->
name|rxsize
operator|=
name|ap
operator|->
name|rxq
operator|.
name|size
expr_stmt|;
name|portp
operator|->
name|txsize
operator|=
name|ap
operator|->
name|txq
operator|.
name|size
expr_stmt|;
name|portp
operator|->
name|rxoffset
operator|=
name|ap
operator|->
name|rxq
operator|.
name|offset
expr_stmt|;
name|portp
operator|->
name|txoffset
operator|=
name|ap
operator|->
name|txq
operator|.
name|offset
expr_stmt|;
block|}
block|}
name|stli_donestartup
label|:
name|EBRDDISABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
name|brdp
operator|->
name|state
operator||=
name|BST_STARTED
expr_stmt|;
if|if
condition|(
name|stli_doingtimeout
operator|==
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|stli_poll
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stli_doingtimeout
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Probe and initialize the specified board.  */
end_comment

begin_function
specifier|static
name|int
name|stli_brdinit
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_brdinit(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stli_brds
index|[
name|brdp
operator|->
name|brdnr
index|]
operator|=
name|brdp
expr_stmt|;
switch|switch
condition|(
name|brdp
operator|->
name|brdtype
condition|)
block|{
case|case
name|BRD_ECP
case|:
case|case
name|BRD_ECPE
case|:
case|case
name|BRD_ECPMC
case|:
name|stli_initecp
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|BRD_ONBOARD
case|:
case|case
name|BRD_ONBOARDE
case|:
case|case
name|BRD_ONBOARD2
case|:
case|case
name|BRD_ONBOARD32
case|:
case|case
name|BRD_ONBOARD2_32
case|:
case|case
name|BRD_ONBOARDRS
case|:
case|case
name|BRD_BRUMBY4
case|:
case|case
name|BRD_BRUMBY8
case|:
case|case
name|BRD_BRUMBY16
case|:
case|case
name|BRD_STALLION
case|:
name|stli_initonb
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|BRD_EASYIO
case|:
case|case
name|BRD_ECH
case|:
case|case
name|BRD_ECHMC
case|:
case|case
name|BRD_ECHPCI
case|:
name|printf
argument_list|(
literal|"STALLION: %s board type not supported in this driver\n"
argument_list|,
name|stli_brdnames
index|[
name|brdp
operator|->
name|brdtype
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"STALLION: unit=%d is unknown board type=%d\n"
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|,
name|brdp
operator|->
name|brdtype
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Finish off the remaining initialization for a board.  */
end_comment

begin_function
specifier|static
name|int
name|stli_brdattach
parameter_list|(
name|stlibrd_t
modifier|*
name|brdp
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_brdattach(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|if ((brdp->state& BST_FOUND) == 0) { 		printf("STALLION: %s board not found, unit=%d io=%x mem=%x\n", 			stli_brdnames[brdp->brdtype], brdp->brdnr, 			brdp->iobase, (int) brdp->paddr); 		return(ENXIO); 	}
endif|#
directive|endif
name|stli_initports
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"stli%d: %s (driver version %s), unit=%d nrpanels=%d "
literal|"nrports=%d\n"
argument_list|,
name|brdp
operator|->
name|unitid
argument_list|,
name|stli_brdnames
index|[
name|brdp
operator|->
name|brdtype
index|]
argument_list|,
name|stli_drvversion
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|,
name|brdp
operator|->
name|nrpanels
argument_list|,
name|brdp
operator|->
name|nrports
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Check for possible shared memory sharing between boards.  *	FIX: need to start this optimization somewhere...  */
end_comment

begin_function
specifier|static
name|int
name|stli_chksharemem
parameter_list|()
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|,
modifier|*
name|nxtbrdp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_chksharemem()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  *	All found boards are initialized. Now for a little optimization, if  *	no boards are sharing the "shared memory" regions then we can just  *	leave them all enabled. This is in fact the usual case.  */
name|stli_shared
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stli_nrbrds
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|stli_nrbrds
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|brdp
operator|=
name|stli_brds
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
operator|(
name|j
operator|<
name|stli_nrbrds
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|nxtbrdp
operator|=
name|stli_brds
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|nxtbrdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|brdp
operator|->
name|paddr
operator|>=
name|nxtbrdp
operator|->
name|paddr
operator|)
operator|&&
operator|(
name|brdp
operator|->
name|paddr
operator|<=
operator|(
name|nxtbrdp
operator|->
name|paddr
operator|+
name|nxtbrdp
operator|->
name|memsize
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|stli_shared
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|stli_shared
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|stli_nrbrds
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|brdp
operator|=
name|stli_brds
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|brdp
operator|->
name|state
operator|&
name|BST_FOUND
condition|)
block|{
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|brdp
operator|->
name|enable
operator|=
name|NULL
expr_stmt|;
name|brdp
operator|->
name|disable
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Return the board stats structure to user app.  */
end_comment

begin_function
specifier|static
name|int
name|stli_getbrdstats
parameter_list|(
name|caddr_t
name|data
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_getbrdstats(data=%x)\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stli_brdstats
operator|=
operator|*
operator|(
operator|(
name|combrd_t
operator|*
operator|)
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|stli_brdstats
operator|.
name|brd
operator|>=
name|STL_MAXBRDS
condition|)
return|return
operator|(
operator|-
name|ENODEV
operator|)
return|;
name|brdp
operator|=
name|stli_brds
index|[
name|stli_brdstats
operator|.
name|brd
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENODEV
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|stli_brdstats
argument_list|,
sizeof|sizeof
argument_list|(
name|combrd_t
argument_list|)
argument_list|)
expr_stmt|;
name|stli_brdstats
operator|.
name|brd
operator|=
name|brdp
operator|->
name|brdnr
expr_stmt|;
name|stli_brdstats
operator|.
name|type
operator|=
name|brdp
operator|->
name|brdtype
expr_stmt|;
name|stli_brdstats
operator|.
name|hwid
operator|=
literal|0
expr_stmt|;
name|stli_brdstats
operator|.
name|state
operator|=
name|brdp
operator|->
name|state
expr_stmt|;
name|stli_brdstats
operator|.
name|ioaddr
operator|=
name|brdp
operator|->
name|iobase
expr_stmt|;
name|stli_brdstats
operator|.
name|memaddr
operator|=
name|brdp
operator|->
name|paddr
expr_stmt|;
name|stli_brdstats
operator|.
name|nrpanels
operator|=
name|brdp
operator|->
name|nrpanels
expr_stmt|;
name|stli_brdstats
operator|.
name|nrports
operator|=
name|brdp
operator|->
name|nrports
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|brdp
operator|->
name|nrpanels
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|stli_brdstats
operator|.
name|panels
index|[
name|i
index|]
operator|.
name|panel
operator|=
name|i
expr_stmt|;
name|stli_brdstats
operator|.
name|panels
index|[
name|i
index|]
operator|.
name|hwid
operator|=
name|brdp
operator|->
name|panelids
index|[
name|i
index|]
expr_stmt|;
name|stli_brdstats
operator|.
name|panels
index|[
name|i
index|]
operator|.
name|nrports
operator|=
name|brdp
operator|->
name|panels
index|[
name|i
index|]
expr_stmt|;
block|}
operator|*
operator|(
operator|(
name|combrd_t
operator|*
operator|)
name|data
operator|)
operator|=
name|stli_brdstats
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Resolve the referenced port number into a port struct pointer.  */
end_comment

begin_function
specifier|static
name|stliport_t
modifier|*
name|stli_getport
parameter_list|(
name|int
name|brdnr
parameter_list|,
name|int
name|panelnr
parameter_list|,
name|int
name|portnr
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|brdnr
operator|<
literal|0
operator|)
operator|||
operator|(
name|brdnr
operator|>=
name|STL_MAXBRDS
operator|)
condition|)
return|return
operator|(
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
operator|)
return|;
name|brdp
operator|=
name|stli_brds
index|[
name|brdnr
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|panelnr
operator|)
condition|;
name|i
operator|++
control|)
name|portnr
operator|+=
name|brdp
operator|->
name|panels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|portnr
operator|<
literal|0
operator|)
operator|||
operator|(
name|portnr
operator|>=
name|brdp
operator|->
name|nrports
operator|)
condition|)
return|return
operator|(
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
operator|)
return|;
return|return
operator|(
name|brdp
operator|->
name|ports
index|[
name|portnr
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Return the port stats structure to user app. A NULL port struct  *	pointer passed in means that we need to find out from the app  *	what port to get stats for (used through board control device).  */
end_comment

begin_function
specifier|static
name|int
name|stli_getportstats
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|stli_comstats
operator|=
operator|*
operator|(
operator|(
name|comstats_t
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|portp
operator|=
name|stli_getport
argument_list|(
name|stli_comstats
operator|.
name|brd
argument_list|,
name|stli_comstats
operator|.
name|panel
argument_list|,
name|stli_comstats
operator|.
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENODEV
operator|)
return|;
block|}
name|brdp
operator|=
name|stli_brds
index|[
name|portp
operator|->
name|brdnr
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENODEV
operator|)
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_GETSTATS
argument_list|,
operator|&
name|stli_cdkstats
argument_list|,
sizeof|sizeof
argument_list|(
name|asystats_t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|stli_comstats
operator|.
name|brd
operator|=
name|portp
operator|->
name|brdnr
expr_stmt|;
name|stli_comstats
operator|.
name|panel
operator|=
name|portp
operator|->
name|panelnr
expr_stmt|;
name|stli_comstats
operator|.
name|port
operator|=
name|portp
operator|->
name|portnr
expr_stmt|;
name|stli_comstats
operator|.
name|state
operator|=
name|portp
operator|->
name|state
expr_stmt|;
comment|/*stli_comstats.flags = portp->flags;*/
name|stli_comstats
operator|.
name|ttystate
operator|=
name|portp
operator|->
name|tty
operator|.
name|t_state
expr_stmt|;
name|stli_comstats
operator|.
name|cflags
operator|=
name|portp
operator|->
name|tty
operator|.
name|t_cflag
expr_stmt|;
name|stli_comstats
operator|.
name|iflags
operator|=
name|portp
operator|->
name|tty
operator|.
name|t_iflag
expr_stmt|;
name|stli_comstats
operator|.
name|oflags
operator|=
name|portp
operator|->
name|tty
operator|.
name|t_oflag
expr_stmt|;
name|stli_comstats
operator|.
name|lflags
operator|=
name|portp
operator|->
name|tty
operator|.
name|t_lflag
expr_stmt|;
name|stli_comstats
operator|.
name|txtotal
operator|=
name|stli_cdkstats
operator|.
name|txchars
expr_stmt|;
name|stli_comstats
operator|.
name|rxtotal
operator|=
name|stli_cdkstats
operator|.
name|rxchars
operator|+
name|stli_cdkstats
operator|.
name|ringover
expr_stmt|;
name|stli_comstats
operator|.
name|txbuffered
operator|=
name|stli_cdkstats
operator|.
name|txringq
expr_stmt|;
name|stli_comstats
operator|.
name|rxbuffered
operator|=
name|stli_cdkstats
operator|.
name|rxringq
expr_stmt|;
name|stli_comstats
operator|.
name|rxoverrun
operator|=
name|stli_cdkstats
operator|.
name|overruns
expr_stmt|;
name|stli_comstats
operator|.
name|rxparity
operator|=
name|stli_cdkstats
operator|.
name|parity
expr_stmt|;
name|stli_comstats
operator|.
name|rxframing
operator|=
name|stli_cdkstats
operator|.
name|framing
expr_stmt|;
name|stli_comstats
operator|.
name|rxlost
operator|=
name|stli_cdkstats
operator|.
name|ringover
operator|+
name|portp
operator|->
name|rxlost
expr_stmt|;
name|stli_comstats
operator|.
name|rxbreaks
operator|=
name|stli_cdkstats
operator|.
name|rxbreaks
expr_stmt|;
name|stli_comstats
operator|.
name|txbreaks
operator|=
name|stli_cdkstats
operator|.
name|txbreaks
expr_stmt|;
name|stli_comstats
operator|.
name|txxon
operator|=
name|stli_cdkstats
operator|.
name|txstart
expr_stmt|;
name|stli_comstats
operator|.
name|txxoff
operator|=
name|stli_cdkstats
operator|.
name|txstop
expr_stmt|;
name|stli_comstats
operator|.
name|rxxon
operator|=
name|stli_cdkstats
operator|.
name|rxstart
expr_stmt|;
name|stli_comstats
operator|.
name|rxxoff
operator|=
name|stli_cdkstats
operator|.
name|rxstop
expr_stmt|;
name|stli_comstats
operator|.
name|rxrtsoff
operator|=
name|stli_cdkstats
operator|.
name|rtscnt
operator|/
literal|2
expr_stmt|;
name|stli_comstats
operator|.
name|rxrtson
operator|=
name|stli_cdkstats
operator|.
name|rtscnt
operator|-
name|stli_comstats
operator|.
name|rxrtsoff
expr_stmt|;
name|stli_comstats
operator|.
name|modem
operator|=
name|stli_cdkstats
operator|.
name|dcdcnt
expr_stmt|;
name|stli_comstats
operator|.
name|hwid
operator|=
name|stli_cdkstats
operator|.
name|hwid
expr_stmt|;
name|stli_comstats
operator|.
name|signals
operator|=
name|stli_mktiocm
argument_list|(
name|stli_cdkstats
operator|.
name|signals
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|comstats_t
operator|*
operator|)
name|data
operator|)
operator|=
name|stli_comstats
expr_stmt|;
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Clear the port stats structure. We also return it zeroed out...  */
end_comment

begin_function
specifier|static
name|int
name|stli_clrportstats
parameter_list|(
name|stliport_t
modifier|*
name|portp
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|stli_comstats
operator|=
operator|*
operator|(
operator|(
name|comstats_t
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|portp
operator|=
name|stli_getport
argument_list|(
name|stli_comstats
operator|.
name|brd
argument_list|,
name|stli_comstats
operator|.
name|panel
argument_list|,
name|stli_comstats
operator|.
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENODEV
operator|)
return|;
block|}
name|brdp
operator|=
name|stli_brds
index|[
name|portp
operator|->
name|brdnr
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENODEV
operator|)
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|stli_cmdwait
argument_list|(
name|brdp
argument_list|,
name|portp
argument_list|,
name|A_CLEARSTATS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|portp
operator|->
name|rxlost
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|stli_comstats
argument_list|,
sizeof|sizeof
argument_list|(
name|comstats_t
argument_list|)
argument_list|)
expr_stmt|;
name|stli_comstats
operator|.
name|brd
operator|=
name|portp
operator|->
name|brdnr
expr_stmt|;
name|stli_comstats
operator|.
name|panel
operator|=
name|portp
operator|->
name|panelnr
expr_stmt|;
name|stli_comstats
operator|.
name|port
operator|=
name|portp
operator|->
name|portnr
expr_stmt|;
operator|*
operator|(
operator|(
name|comstats_t
operator|*
operator|)
name|data
operator|)
operator|=
name|stli_comstats
expr_stmt|;
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Code to handle an "staliomem" read and write operations. This device  *	is the contents of the board shared memory. It is used for down  *	loading the slave image (and debugging :-)  */
end_comment

begin_function
name|STATIC
name|int
name|stli_memrw
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|void
modifier|*
name|memptr
decl_stmt|;
name|int
name|brdnr
decl_stmt|,
name|size
decl_stmt|,
name|n
decl_stmt|,
name|error
decl_stmt|,
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_memrw(dev=%x,uiop=%x,flag=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|dev
argument_list|,
operator|(
name|int
operator|)
name|uiop
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|brdnr
operator|=
name|dev
operator|&
literal|0x7
expr_stmt|;
name|brdp
operator|=
name|stli_brds
index|[
name|brdnr
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|brdp
operator|->
name|state
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|uiop
operator|->
name|uio_offset
operator|>=
name|brdp
operator|->
name|memsize
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|brdp
operator|->
name|memsize
operator|-
name|uiop
operator|->
name|uio_offset
expr_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|EBRDENABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|memptr
operator|=
operator|(
name|void
operator|*
operator|)
name|EBRDGETMEMPTR
argument_list|(
name|brdp
argument_list|,
name|uiop
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|size
argument_list|,
operator|(
name|brdp
operator|->
name|pagesize
operator|-
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|uiop
operator|->
name|uio_offset
operator|)
operator|%
name|brdp
operator|->
name|pagesize
operator|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|memptr
argument_list|,
name|n
argument_list|,
name|uiop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uiop
operator|->
name|uio_resid
operator|==
literal|0
operator|)
operator|||
name|error
condition|)
break|break;
block|}
name|EBRDDISABLE
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	The "staliomem" device is also required to do some special operations  *	on the board. We need to be able to send an interrupt to the board,  *	reset it, and start/stop it.  */
end_comment

begin_function
specifier|static
name|int
name|stli_memioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|stlibrd_t
modifier|*
name|brdp
decl_stmt|;
name|int
name|brdnr
decl_stmt|,
name|rc
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stli_memioctl(dev=%x,cmd=%x,data=%x,flag=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|dev
argument_list|,
name|cmd
argument_list|,
operator|(
name|int
operator|)
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|brdnr
operator|=
name|dev
operator|&
literal|0x7
expr_stmt|;
name|brdp
operator|=
name|stli_brds
index|[
name|brdnr
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlibrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|brdp
operator|->
name|state
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|rc
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|STL_BINTR
case|:
name|EBRDINTR
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|STL_BSTART
case|:
name|rc
operator|=
name|stli_startbrd
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|STL_BSTOP
case|:
name|brdp
operator|->
name|state
operator|&=
operator|~
name|BST_STARTED
expr_stmt|;
break|break;
case|case
name|STL_BRESET
case|:
name|brdp
operator|->
name|state
operator|&=
operator|~
name|BST_STARTED
expr_stmt|;
name|EBRDRESET
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stli_shared
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|brdp
operator|->
name|reenable
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|brdp
operator|->
name|reenable
call|)
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COM_GETPORTSTATS
case|:
name|rc
operator|=
name|stli_getportstats
argument_list|(
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|COM_CLRPORTSTATS
case|:
name|rc
operator|=
name|stli_clrportstats
argument_list|(
operator|(
name|stliport_t
operator|*
operator|)
name|NULL
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|COM_GETBRDSTATS
case|:
name|rc
operator|=
name|stli_getbrdstats
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

end_unit

