begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Streamer tape driver for 386bsd and FreeBSD.  * Supports Archive QIC-02 and Wangtek QIC-02/QIC-36 boards.  *  * Copyright (C) 1993 by:  *      Sergey Ryzhkov<sir@kiae.su>  *      Serge Vakulenko<vak@zebub.msk.su>  *  * Placed in the public domain with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations permission to use  * or modify this software as long as this message is kept with the software,  * all derivative works or modified versions.  *  * This driver is derived from the old 386bsd Wangtek streamer tape driver,  * made by Robert Baron at CMU, based on Intel sources.  * Authors thank Robert Baron, CMU and Intel and retain here  * the original CMU copyright notice.  *  *	from: Version 1.1, Fri Sep 24 02:14:31 MSD 1993  *	$Id$  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1989 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Robert Baron  *   * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND   * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|"wt.h"
end_include

begin_if
if|#
directive|if
name|NWT
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"sys/param.h"
end_include

begin_include
include|#
directive|include
file|"sys/buf.h"
end_include

begin_include
include|#
directive|include
file|"sys/fcntl.h"
end_include

begin_include
include|#
directive|include
file|"sys/malloc.h"
end_include

begin_include
include|#
directive|include
file|"sys/ioctl.h"
end_include

begin_include
include|#
directive|include
file|"sys/mtio.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_param.h"
end_include

begin_include
include|#
directive|include
file|"i386/include/pio.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/wtreg.h"
end_include

begin_define
define|#
directive|define
name|WTPRI
value|(PZERO+10)
end_define

begin_comment
comment|/* sleep priority */
end_comment

begin_define
define|#
directive|define
name|BLKSIZE
value|512
end_define

begin_comment
comment|/* streamer tape block size */
end_comment

begin_comment
comment|/*  * Wangtek controller ports  */
end_comment

begin_define
define|#
directive|define
name|WT_CTLPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+0)
end_define

begin_comment
comment|/* control, write only */
end_comment

begin_define
define|#
directive|define
name|WT_STATPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+0)
end_define

begin_comment
comment|/* status, read only */
end_comment

begin_define
define|#
directive|define
name|WT_CMDPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+1)
end_define

begin_comment
comment|/* command, write only */
end_comment

begin_define
define|#
directive|define
name|WT_DATAPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+1)
end_define

begin_comment
comment|/* data, read only */
end_comment

begin_define
define|#
directive|define
name|WT_NPORT
value|2
end_define

begin_comment
comment|/* 2 i/o ports */
end_comment

begin_comment
comment|/* status port bits */
end_comment

begin_define
define|#
directive|define
name|WT_BUSY
value|0x01
end_define

begin_comment
comment|/* not ready bit define */
end_comment

begin_define
define|#
directive|define
name|WT_NOEXCEP
value|0x02
end_define

begin_comment
comment|/* no exception bit define */
end_comment

begin_define
define|#
directive|define
name|WT_RESETMASK
value|0x07
end_define

begin_comment
comment|/* to check after reset */
end_comment

begin_define
define|#
directive|define
name|WT_RESETVAL
value|0x05
end_define

begin_comment
comment|/* state after reset */
end_comment

begin_comment
comment|/* control port bits */
end_comment

begin_define
define|#
directive|define
name|WT_ONLINE
value|0x01
end_define

begin_comment
comment|/* device selected */
end_comment

begin_define
define|#
directive|define
name|WT_RESET
value|0x02
end_define

begin_comment
comment|/* reset command */
end_comment

begin_define
define|#
directive|define
name|WT_REQUEST
value|0x04
end_define

begin_comment
comment|/* request command */
end_comment

begin_define
define|#
directive|define
name|WT_IEN
parameter_list|(
name|chan
parameter_list|)
value|((chan)>2 ? 0x10 : 0x8)
end_define

begin_comment
comment|/* enable intr */
end_comment

begin_comment
comment|/*  * Archive controller ports  */
end_comment

begin_define
define|#
directive|define
name|AV_DATAPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+0)
end_define

begin_comment
comment|/* data, read only */
end_comment

begin_define
define|#
directive|define
name|AV_CMDPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+0)
end_define

begin_comment
comment|/* command, write only */
end_comment

begin_define
define|#
directive|define
name|AV_STATPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+1)
end_define

begin_comment
comment|/* status, read only */
end_comment

begin_define
define|#
directive|define
name|AV_CTLPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+1)
end_define

begin_comment
comment|/* control, write only */
end_comment

begin_define
define|#
directive|define
name|AV_SDMAPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+2)
end_define

begin_comment
comment|/* start dma */
end_comment

begin_define
define|#
directive|define
name|AV_RDMAPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+3)
end_define

begin_comment
comment|/* reset dma */
end_comment

begin_define
define|#
directive|define
name|AV_NPORT
value|4
end_define

begin_comment
comment|/* 4 i/o ports */
end_comment

begin_comment
comment|/* status port bits */
end_comment

begin_define
define|#
directive|define
name|AV_BUSY
value|0x40
end_define

begin_comment
comment|/* not ready bit define */
end_comment

begin_define
define|#
directive|define
name|AV_NOEXCEP
value|0x20
end_define

begin_comment
comment|/* no exception bit define */
end_comment

begin_define
define|#
directive|define
name|AV_RESETMASK
value|0xf8
end_define

begin_comment
comment|/* to check after reset */
end_comment

begin_define
define|#
directive|define
name|AV_RESETVAL
value|0x50
end_define

begin_comment
comment|/* state after reset */
end_comment

begin_comment
comment|/* control port bits */
end_comment

begin_define
define|#
directive|define
name|AV_RESET
value|0x80
end_define

begin_comment
comment|/* reset command */
end_comment

begin_define
define|#
directive|define
name|AV_REQUEST
value|0x40
end_define

begin_comment
comment|/* request command */
end_comment

begin_define
define|#
directive|define
name|AV_IEN
value|0x20
end_define

begin_comment
comment|/* enable interrupts */
end_comment

begin_define
define|#
directive|define
name|DMA_STATUSREG
value|0x8
end_define

begin_define
define|#
directive|define
name|DMA_DONE
parameter_list|(
name|chan
parameter_list|)
value|(1<< (chan))
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|short
name|err
decl_stmt|;
comment|/* code for error encountered */
name|unsigned
name|short
name|ercnt
decl_stmt|;
comment|/* number of error blocks */
name|unsigned
name|short
name|urcnt
decl_stmt|;
comment|/* number of underruns */
block|}
name|wtstatus_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|unit
decl_stmt|;
comment|/* unit number */
name|unsigned
name|port
decl_stmt|;
comment|/* base i/o port */
name|unsigned
name|chan
decl_stmt|;
comment|/* dma channel number, 1..3 */
name|unsigned
name|flags
decl_stmt|;
comment|/* state of tape drive */
name|unsigned
name|dens
decl_stmt|;
comment|/* tape density */
name|void
modifier|*
name|buf
decl_stmt|;
comment|/* internal i/o buffer */
name|void
modifier|*
name|dmavaddr
decl_stmt|;
comment|/* virtual address of dma i/o buffer */
name|unsigned
name|dmatotal
decl_stmt|;
comment|/* size of i/o buffer */
name|unsigned
name|dmaflags
decl_stmt|;
comment|/* i/o direction, B_READ or B_WRITE */
name|unsigned
name|dmacount
decl_stmt|;
comment|/* resulting length of dma i/o */
name|wtstatus_t
name|error
decl_stmt|;
comment|/* status of controller */
name|unsigned
name|short
name|DATAPORT
decl_stmt|,
name|CMDPORT
decl_stmt|,
name|STATPORT
decl_stmt|,
name|CTLPORT
decl_stmt|,
name|SDMAPORT
decl_stmt|,
name|RDMAPORT
decl_stmt|;
name|unsigned
name|char
name|BUSY
decl_stmt|,
name|NOEXCEP
decl_stmt|,
name|RESETMASK
decl_stmt|,
name|RESETVAL
decl_stmt|;
name|unsigned
name|char
name|ONLINE
decl_stmt|,
name|RESET
decl_stmt|,
name|REQUEST
decl_stmt|,
name|IEN
decl_stmt|;
block|}
name|wtinfo_t
typedef|;
end_typedef

begin_decl_stmt
name|wtinfo_t
name|wttab
index|[
name|NWT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tape info by unit number */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of ticks per second */
end_comment

begin_function_decl
specifier|static
name|int
name|wtwait
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|catch
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtcmd
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtstart
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|unsigned
name|mode
parameter_list|,
name|void
modifier|*
name|vaddr
parameter_list|,
name|unsigned
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wtdma
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wtimer
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wtclock
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtreset
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtsense
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|ignor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtstatus
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wtrewind
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtreadfm
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtwritefm
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtpoll
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|DELAY
parameter_list|(
name|int
name|usec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|bcopy
parameter_list|(
name|void
modifier|*
name|from
parameter_list|,
name|void
modifier|*
name|to
parameter_list|,
name|unsigned
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|isa_dmastart
parameter_list|(
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|unsigned
name|len
parameter_list|,
name|unsigned
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|isa_dmadone
parameter_list|(
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|unsigned
name|len
parameter_list|,
name|int
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|printf
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|splbio
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|splx
parameter_list|(
name|int
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|timeout
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|timo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|tsleep
parameter_list|(
name|void
modifier|*
name|chan
parameter_list|,
name|int
name|priority
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|timo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|wakeup
parameter_list|(
name|void
modifier|*
name|chan
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Probe for the presence of the device.  */
end_comment

begin_function
name|int
name|wtprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|id
operator|->
name|id_unit
decl_stmt|;
name|t
operator|->
name|unit
operator|=
name|id
operator|->
name|id_unit
expr_stmt|;
name|t
operator|->
name|chan
operator|=
name|id
operator|->
name|id_drq
expr_stmt|;
name|t
operator|->
name|port
operator|=
literal|0
expr_stmt|;
comment|/* Mark it as not configured. */
if|if
condition|(
name|t
operator|->
name|chan
operator|<
literal|1
operator|||
name|t
operator|->
name|chan
operator|>
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"wt%d: Bad drq=%d, should be 1..3\n"
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|t
operator|->
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|t
operator|->
name|port
operator|=
name|id
operator|->
name|id_iobase
expr_stmt|;
comment|/* Try Wangtek. */
name|t
operator|->
name|CTLPORT
operator|=
name|WT_CTLPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|STATPORT
operator|=
name|WT_STATPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|CMDPORT
operator|=
name|WT_CMDPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|DATAPORT
operator|=
name|WT_DATAPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|SDMAPORT
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|RDMAPORT
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|BUSY
operator|=
name|WT_BUSY
expr_stmt|;
name|t
operator|->
name|NOEXCEP
operator|=
name|WT_NOEXCEP
expr_stmt|;
name|t
operator|->
name|RESETMASK
operator|=
name|WT_RESETMASK
expr_stmt|;
name|t
operator|->
name|RESETVAL
operator|=
name|WT_RESETVAL
expr_stmt|;
name|t
operator|->
name|ONLINE
operator|=
name|WT_ONLINE
expr_stmt|;
name|t
operator|->
name|RESET
operator|=
name|WT_RESET
expr_stmt|;
name|t
operator|->
name|REQUEST
operator|=
name|WT_REQUEST
expr_stmt|;
name|t
operator|->
name|IEN
operator|=
name|WT_IEN
argument_list|(
name|t
operator|->
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|wtreset
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|WT_NPORT
operator|)
return|;
comment|/* Try Archive. */
name|t
operator|->
name|CTLPORT
operator|=
name|AV_CTLPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|STATPORT
operator|=
name|AV_STATPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|CMDPORT
operator|=
name|AV_CMDPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|DATAPORT
operator|=
name|AV_DATAPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|SDMAPORT
operator|=
name|AV_SDMAPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|RDMAPORT
operator|=
name|AV_RDMAPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|BUSY
operator|=
name|AV_BUSY
expr_stmt|;
name|t
operator|->
name|NOEXCEP
operator|=
name|AV_NOEXCEP
expr_stmt|;
name|t
operator|->
name|RESETMASK
operator|=
name|AV_RESETMASK
expr_stmt|;
name|t
operator|->
name|RESETVAL
operator|=
name|AV_RESETVAL
expr_stmt|;
name|t
operator|->
name|ONLINE
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|RESET
operator|=
name|AV_RESET
expr_stmt|;
name|t
operator|->
name|REQUEST
operator|=
name|AV_REQUEST
expr_stmt|;
name|t
operator|->
name|IEN
operator|=
name|AV_IEN
expr_stmt|;
if|if
condition|(
name|wtreset
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|AV_NPORT
operator|)
return|;
comment|/* Tape controller not found. */
name|t
operator|->
name|port
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device is found, configure it.  */
end_comment

begin_function
name|int
name|wtattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|id
operator|->
name|id_unit
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|RDMAPORT
condition|)
block|{
name|printf
argument_list|(
literal|"wt%d: type<Archive>\n"
argument_list|,
name|t
operator|->
name|unit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|t
operator|->
name|RDMAPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reset dma */
block|}
else|else
name|printf
argument_list|(
literal|"wt%d: type<Wangtek>\n"
argument_list|,
name|t
operator|->
name|unit
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|=
name|TPSTART
expr_stmt|;
comment|/* tape is rewound */
name|t
operator|->
name|dens
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown density */
name|t
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|BLKSIZE
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|isa_driver
name|wtdriver
init|=
block|{
name|wtprobe
block|,
name|wtattach
block|,
literal|"wt"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|wtdump
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
comment|/* Not implemented */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wtsize
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
comment|/* Not implemented */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open routine, called on every device open.  */
end_comment

begin_function
name|int
name|wtopen
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|u
init|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_UNIT
decl_stmt|;
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|u
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|u
operator|>=
name|NWT
operator|||
operator|!
name|t
operator|->
name|port
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Check that device is not in use */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPINUSE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* If the tape is in rewound state, check the status and set density. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPSTART
condition|)
block|{
comment|/* If rewind is going on, wait */
name|error
operator|=
name|wtwait
argument_list|(
name|t
argument_list|,
name|PCATCH
argument_list|,
literal|"wtrew"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|wtsense
argument_list|(
name|t
argument_list|,
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|?
literal|0
else|:
name|TP_WRP
argument_list|)
condition|)
block|{
comment|/* Bad status. Reset the controller. */
if|if
condition|(
operator|!
name|wtreset
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|wtsense
argument_list|(
name|t
argument_list|,
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|?
literal|0
else|:
name|TP_WRP
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Set up tape density. */
if|if
condition|(
name|t
operator|->
name|dens
operator|!=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_DENSEL
operator|)
condition|)
block|{
name|int
name|d
decl_stmt|;
switch|switch
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_DENSEL
condition|)
block|{
default|default:
case|case
name|T_800BPI
case|:
name|d
operator|=
name|QIC_FMT150
expr_stmt|;
break|break;
comment|/* minor 000 */
case|case
name|T_1600BPI
case|:
name|d
operator|=
name|QIC_FMT120
expr_stmt|;
break|break;
comment|/* minor 010 */
case|case
name|T_6250BPI
case|:
name|d
operator|=
name|QIC_FMT24
expr_stmt|;
break|break;
comment|/* minor 020 */
case|case
name|T_BADBPI
case|:
name|d
operator|=
name|QIC_FMT11
expr_stmt|;
break|break;
comment|/* minor 030 */
block|}
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|d
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Check the status of the controller. */
if|if
condition|(
operator|!
name|wtsense
argument_list|(
name|t
argument_list|,
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|?
literal|0
else|:
name|TP_WRP
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|t
operator|->
name|dens
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_DENSEL
expr_stmt|;
block|}
name|t
operator|->
name|flags
operator|&=
operator|~
name|TPSTART
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|dens
operator|!=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_DENSEL
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|t
operator|->
name|flags
operator|=
name|TPINUSE
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|FREAD
condition|)
name|t
operator|->
name|flags
operator||=
name|TPREAD
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|FWRITE
condition|)
name|t
operator|->
name|flags
operator||=
name|TPWRITE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close routine, called on last device close.  */
end_comment

begin_function
name|int
name|wtclose
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|u
init|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_UNIT
decl_stmt|;
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|u
decl_stmt|;
if|if
condition|(
name|u
operator|>=
name|NWT
operator|||
operator|!
name|t
operator|->
name|port
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* If rewind is pending, do nothing */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPREW
condition|)
goto|goto
name|done
goto|;
comment|/* If seek forward is pending and no rewind on close, do nothing */
if|if
condition|(
operator|(
name|t
operator|->
name|flags
operator|&
name|TPRMARK
operator|)
operator|&&
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_NOREWIND
operator|)
condition|)
goto|goto
name|done
goto|;
comment|/* If file mark read is going on, wait */
name|wtwait
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|"wtrfm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPWANY
condition|)
comment|/* Tape was written.  Write file mark. */
name|wtwritefm
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_NOREWIND
operator|)
condition|)
block|{
comment|/* Rewind tape to beginning of tape. */
comment|/* Don't wait until rewind, though. */
name|wtrewind
argument_list|(
name|t
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|flags
operator|&
name|TPRANY
operator|)
operator|&&
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
operator|(
name|TPVOL
operator||
name|TPWANY
operator|)
operator|)
condition|)
comment|/* Space forward to after next file mark if no writing done. */
comment|/* Don't wait for completion. */
name|wtreadfm
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|done
label|:
name|t
operator|->
name|flags
operator|&=
name|TPREW
operator||
name|TPRMARK
operator||
name|TPSTART
operator||
name|TPTIMER
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ioctl routine.  Compatible with BSD ioctls.  * Direct QIC-02 commands ERASE and RETENSION added.  * There are three possible ioctls:  * ioctl (int fd, MTIOCGET, struct mtget *buf)  -- get status  * ioctl (int fd, MTIOCTOP, struct mtop *buf)   -- do BSD-like op  * ioctl (int fd, WTQICMD, int qicop)           -- do QIC op  */
end_comment

begin_function
name|int
name|wtioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|u
init|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_UNIT
decl_stmt|;
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|u
decl_stmt|;
name|int
name|error
decl_stmt|,
name|count
decl_stmt|,
name|op
decl_stmt|;
if|if
condition|(
name|u
operator|>=
name|NWT
operator|||
operator|!
name|t
operator|->
name|port
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|WTQICMD
case|:
comment|/* direct QIC command */
name|op
operator|=
operator|(
name|int
operator|)
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|arg
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|QIC_ERASE
case|:
comment|/* erase the whole tape */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWRITE
operator|)
operator|||
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWP
operator|)
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|wtwait
argument_list|(
name|t
argument_list|,
name|PCATCH
argument_list|,
literal|"wterase"
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
case|case
name|QIC_RETENS
case|:
comment|/* retension the tape */
if|if
condition|(
name|error
operator|=
name|wtwait
argument_list|(
name|t
argument_list|,
name|PCATCH
argument_list|,
literal|"wtretens"
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
block|}
comment|/* Both ERASE and RETENS operations work like REWIND. */
comment|/* Simulate the rewind operation here. */
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TPRO
operator||
name|TPWO
operator||
name|TPVOL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|op
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|t
operator|->
name|flags
operator||=
name|TPSTART
operator||
name|TPREW
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|QIC_ERASE
condition|)
name|t
operator|->
name|flags
operator||=
name|TPWANY
expr_stmt|;
name|wtclock
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MTIOCIEOT
case|:
comment|/* ignore EOT errors */
case|case
name|MTIOCEEOT
case|:
comment|/* enable EOT errors */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MTIOCGET
case|:
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_type
operator|=
name|t
operator|->
name|RDMAPORT
condition|?
name|MT_ISVIPER1
else|:
literal|0x11
expr_stmt|;
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_dsreg
operator|=
name|t
operator|->
name|flags
expr_stmt|;
comment|/* status */
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_erreg
operator|=
name|t
operator|->
name|error
operator|.
name|err
expr_stmt|;
comment|/* errors */
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_resid
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_fileno
operator|=
literal|0
expr_stmt|;
comment|/* file */
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_blkno
operator|=
literal|0
expr_stmt|;
comment|/* block */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MTIOCTOP
case|:
break|break;
block|}
switch|switch
condition|(
call|(
name|short
call|)
argument_list|(
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
argument_list|)
operator|->
name|mt_op
condition|)
block|{
default|default:
case|case
name|MTFSR
case|:
comment|/* forward space record */
case|case
name|MTBSR
case|:
comment|/* backward space record */
case|case
name|MTBSF
case|:
comment|/* backward space file */
break|break;
case|case
name|MTNOP
case|:
comment|/* no operation, sets status only */
case|case
name|MTCACHE
case|:
comment|/* enable controller cache */
case|case
name|MTNOCACHE
case|:
comment|/* disable controller cache */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MTREW
case|:
comment|/* rewind */
case|case
name|MTOFFL
case|:
comment|/* rewind and put the drive offline */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPREW
condition|)
comment|/* rewind is running */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|wtwait
argument_list|(
name|t
argument_list|,
name|PCATCH
argument_list|,
literal|"wtorew"
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|wtrewind
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MTFSF
case|:
comment|/* forward space file */
for|for
control|(
name|count
operator|=
operator|(
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_count
init|;
name|count
operator|>
literal|0
condition|;
operator|--
name|count
control|)
block|{
if|if
condition|(
name|error
operator|=
name|wtwait
argument_list|(
name|t
argument_list|,
name|PCATCH
argument_list|,
literal|"wtorfm"
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|wtreadfm
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MTWEOF
case|:
comment|/* write an end-of-file record */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWRITE
operator|)
operator|||
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWP
operator|)
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|wtwait
argument_list|(
name|t
argument_list|,
name|PCATCH
argument_list|,
literal|"wtowfm"
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|wtwritefm
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Strategy routine.  */
end_comment

begin_function
name|void
name|wtstrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|u
init|=
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
name|T_UNIT
decl_stmt|;
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|u
decl_stmt|;
name|int
name|s
decl_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|u
operator|>=
name|NWT
operator|||
operator|!
name|t
operator|->
name|port
condition|)
goto|goto
name|errxit
goto|;
comment|/* at file marks and end of tape, we just return '0 bytes available' */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPVOL
condition|)
goto|goto
name|xit
goto|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
comment|/* Check read access and no previous write to this tape. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPREAD
operator|)
operator|||
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWANY
operator|)
condition|)
goto|goto
name|errxit
goto|;
comment|/* For now, we assume that all data will be copied out */
comment|/* If read command outstanding, just skip down */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPRO
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|wtsense
argument_list|(
name|t
argument_list|,
name|TP_WRP
argument_list|)
condition|)
comment|/* clear status */
goto|goto
name|errxit
goto|;
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|QIC_RDDATA
argument_list|)
condition|)
block|{
comment|/* sed read mode */
name|wtsense
argument_list|(
name|t
argument_list|,
name|TP_WRP
argument_list|)
expr_stmt|;
goto|goto
name|errxit
goto|;
block|}
name|t
operator|->
name|flags
operator||=
name|TPRO
operator||
name|TPRANY
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Check write access and write protection. */
comment|/* No previous read from this tape allowed. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWRITE
operator|)
operator|||
operator|(
name|t
operator|->
name|flags
operator|&
operator|(
name|TPWP
operator||
name|TPRANY
operator|)
operator|)
condition|)
goto|goto
name|errxit
goto|;
comment|/* If write command outstanding, just skip down */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWO
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|wtsense
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* clear status */
goto|goto
name|errxit
goto|;
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|QIC_WRTDATA
argument_list|)
condition|)
block|{
comment|/* set write mode */
name|wtsense
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|errxit
goto|;
block|}
name|t
operator|->
name|flags
operator||=
name|TPWO
operator||
name|TPWANY
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bp
operator|->
name|b_bcount
condition|)
goto|goto
name|xit
goto|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|TPEXCEP
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|wtstart
argument_list|(
name|t
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
condition|)
block|{
name|wtwait
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"wtread"
else|:
literal|"wtwrite"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|-=
name|t
operator|->
name|dmacount
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPEXCEP
condition|)
block|{
name|errxit
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
block|}
name|xit
label|:
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Interrupt routine.  */
end_comment

begin_function
name|void
name|wtintr
parameter_list|(
name|int
name|u
parameter_list|)
block|{
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|u
decl_stmt|;
name|unsigned
name|char
name|s
decl_stmt|;
if|if
condition|(
name|u
operator|>=
name|NWT
operator|||
operator|!
name|t
operator|->
name|port
condition|)
return|return;
name|s
operator|=
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
expr_stmt|;
comment|/* get status */
if|if
condition|(
operator|(
name|s
operator|&
operator|(
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
operator|)
operator|)
operator|==
operator|(
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
return|return;
comment|/* device is busy */
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
comment|/* stop controller */
comment|/* 	 * Check if rewind finished. 	 */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPREW
condition|)
block|{
name|t
operator|->
name|flags
operator|&=
operator|~
name|TPREW
expr_stmt|;
comment|/* Rewind finished. */
name|wtsense
argument_list|(
name|t
argument_list|,
name|TP_WRP
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check if writing/reading of file mark finished. 	 */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
operator|(
name|TPRMARK
operator||
name|TPWMARK
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|&
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
comment|/* Operation failed. */
name|wtsense
argument_list|(
name|t
argument_list|,
operator|(
name|t
operator|->
name|flags
operator|&
name|TPRMARK
operator|)
condition|?
name|TP_WRP
else|:
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TPRMARK
operator||
name|TPWMARK
operator|)
expr_stmt|;
comment|/* Operation finished. */
name|wakeup
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Do we started any i/o?  If no, just return. 	 */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPACTIVE
operator|)
condition|)
return|return;
name|t
operator|->
name|flags
operator|&=
operator|~
name|TPACTIVE
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|DMA_STATUSREG
argument_list|)
operator|&
name|DMA_DONE
argument_list|(
name|t
operator|->
name|chan
argument_list|)
condition|)
comment|/* if dma finished */
name|t
operator|->
name|dmacount
operator|+=
name|BLKSIZE
expr_stmt|;
comment|/* increment counter */
comment|/* 	 * Clean up dma. 	 */
if|if
condition|(
operator|(
name|t
operator|->
name|dmaflags
operator|&
name|B_READ
operator|)
operator|&&
operator|(
name|t
operator|->
name|dmatotal
operator|-
name|t
operator|->
name|dmacount
operator|)
operator|<
name|BLKSIZE
condition|)
block|{
comment|/* If the address crosses 64-k boundary, or reading short block, 		 * copy the internal buffer to the user memory. */
name|isa_dmadone
argument_list|(
name|t
operator|->
name|dmaflags
argument_list|,
name|t
operator|->
name|buf
argument_list|,
name|BLKSIZE
argument_list|,
name|t
operator|->
name|chan
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|t
operator|->
name|buf
argument_list|,
name|t
operator|->
name|dmavaddr
argument_list|,
name|t
operator|->
name|dmatotal
operator|-
name|t
operator|->
name|dmacount
argument_list|)
expr_stmt|;
block|}
else|else
name|isa_dmadone
argument_list|(
name|t
operator|->
name|dmaflags
argument_list|,
name|t
operator|->
name|dmavaddr
argument_list|,
name|BLKSIZE
argument_list|,
name|t
operator|->
name|chan
argument_list|)
expr_stmt|;
comment|/* 	 * On exception, check for end of file and end of volume. 	 */
if|if
condition|(
operator|!
operator|(
name|s
operator|&
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
block|{
name|wtsense
argument_list|(
name|t
argument_list|,
operator|(
name|t
operator|->
name|dmaflags
operator|&
name|B_READ
operator|)
condition|?
name|TP_WRP
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|error
operator|.
name|err
operator|&
operator|(
name|TP_EOM
operator||
name|TP_FIL
operator|)
condition|)
name|t
operator|->
name|flags
operator||=
name|TPVOL
expr_stmt|;
comment|/* end of file */
else|else
name|t
operator|->
name|flags
operator||=
name|TPEXCEP
expr_stmt|;
comment|/* i/o error */
name|wakeup
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|t
operator|->
name|dmacount
operator|<
name|t
operator|->
name|dmatotal
condition|)
block|{
comment|/* continue i/o */
name|t
operator|->
name|dmavaddr
operator|+=
name|BLKSIZE
expr_stmt|;
name|wtdma
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|t
operator|->
name|dmacount
operator|>
name|t
operator|->
name|dmatotal
condition|)
comment|/* short last block */
name|t
operator|->
name|dmacount
operator|=
name|t
operator|->
name|dmatotal
expr_stmt|;
name|wakeup
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* wake up user level */
block|}
end_function

begin_comment
comment|/* start the rewind operation */
end_comment

begin_function
specifier|static
name|void
name|wtrewind
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TPRO
operator||
name|TPWO
operator||
name|TPVOL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|QIC_REWIND
argument_list|)
condition|)
return|return;
name|t
operator|->
name|flags
operator||=
name|TPSTART
operator||
name|TPREW
expr_stmt|;
name|wtclock
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* start the `read marker' operation */
end_comment

begin_function
specifier|static
name|int
name|wtreadfm
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TPRO
operator||
name|TPWO
operator||
name|TPVOL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|QIC_READFM
argument_list|)
condition|)
block|{
name|wtsense
argument_list|(
name|t
argument_list|,
name|TP_WRP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|t
operator|->
name|flags
operator||=
name|TPRMARK
operator||
name|TPRANY
expr_stmt|;
name|wtclock
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Don't wait for completion here. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* write marker to the tape */
end_comment

begin_function
specifier|static
name|int
name|wtwritefm
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
name|tsleep
argument_list|(
name|wtwritefm
argument_list|,
name|WTPRI
argument_list|,
literal|"wtwfm"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* timeout: 1 second */
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TPRO
operator||
name|TPWO
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|QIC_WRITEFM
argument_list|)
condition|)
block|{
name|wtsense
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|t
operator|->
name|flags
operator||=
name|TPWMARK
operator||
name|TPWANY
expr_stmt|;
name|wtclock
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|wtwait
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|"wtwfm"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* wait for controller ready or exception */
end_comment

begin_function
specifier|static
name|int
name|wtpoll
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|NOTREADY
init|=
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
decl_stmt|;
comment|/* Poll status port, waiting for ready or exception. */
do|do
name|s
operator|=
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
expr_stmt|;
do|while
condition|(
operator|(
name|s
operator|&
name|NOTREADY
operator|)
operator|==
name|NOTREADY
condition|)
do|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* execute QIC command */
end_comment

begin_function
specifier|static
name|int
name|wtcmd
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|wtpoll
argument_list|(
name|t
argument_list|)
operator|&
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
comment|/* wait for ready */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* error */
name|outb
argument_list|(
name|t
operator|->
name|CMDPORT
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* output the command */
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|REQUEST
operator||
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
comment|/* set request */
while|while
condition|(
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
operator|&
name|t
operator|->
name|BUSY
condition|)
comment|/* wait for ready */
continue|continue;
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|IEN
operator||
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
comment|/* reset request */
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
operator|&
name|t
operator|->
name|BUSY
operator|)
condition|)
comment|/* wait for not ready */
continue|continue;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* wait for the end of i/o, seeking marker or rewind operation */
end_comment

begin_function
specifier|static
name|int
name|wtwait
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|catch
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
while|while
condition|(
name|t
operator|->
name|flags
operator|&
operator|(
name|TPACTIVE
operator||
name|TPREW
operator||
name|TPRMARK
operator||
name|TPWMARK
operator|)
condition|)
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
name|t
argument_list|,
name|WTPRI
operator||
name|catch
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* initialize dma for the i/o operation */
end_comment

begin_function
specifier|static
name|void
name|wtdma
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|flags
operator||=
name|TPACTIVE
expr_stmt|;
name|wtclock
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|SDMAPORT
condition|)
name|outb
argument_list|(
name|t
operator|->
name|SDMAPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set dma */
if|if
condition|(
operator|(
name|t
operator|->
name|dmaflags
operator|&
name|B_READ
operator|)
operator|&&
operator|(
name|t
operator|->
name|dmatotal
operator|-
name|t
operator|->
name|dmacount
operator|)
operator|<
name|BLKSIZE
condition|)
comment|/* Reading short block.  Do it through the internal buffer. */
name|isa_dmastart
argument_list|(
name|t
operator|->
name|dmaflags
argument_list|,
name|t
operator|->
name|buf
argument_list|,
name|BLKSIZE
argument_list|,
name|t
operator|->
name|chan
argument_list|)
expr_stmt|;
else|else
name|isa_dmastart
argument_list|(
name|t
operator|->
name|dmaflags
argument_list|,
name|t
operator|->
name|dmavaddr
argument_list|,
name|BLKSIZE
argument_list|,
name|t
operator|->
name|chan
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|IEN
operator||
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* start i/o operation */
end_comment

begin_function
specifier|static
name|int
name|wtstart
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|void
modifier|*
name|vaddr
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|wtpoll
argument_list|(
name|t
argument_list|)
operator|&
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
block|{
comment|/* wait for ready or error */
name|t
operator|->
name|flags
operator||=
name|TPEXCEP
expr_stmt|;
comment|/* error */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|t
operator|->
name|flags
operator|&=
operator|~
name|TPEXCEP
expr_stmt|;
comment|/* clear exception flag */
name|t
operator|->
name|dmavaddr
operator|=
name|vaddr
expr_stmt|;
name|t
operator|->
name|dmatotal
operator|=
name|len
expr_stmt|;
name|t
operator|->
name|dmacount
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|dmaflags
operator|=
name|flags
expr_stmt|;
name|wtdma
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* start timer */
end_comment

begin_function
specifier|static
name|void
name|wtclock
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPTIMER
operator|)
condition|)
block|{
name|t
operator|->
name|flags
operator||=
name|TPTIMER
expr_stmt|;
name|timeout
argument_list|(
name|wtimer
argument_list|,
name|t
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Simulate an interrupt periodically while i/o is going.  * This is necessary in case interrupts get eaten due to  * multiple devices on a single IRQ line.  */
end_comment

begin_function
specifier|static
name|void
name|wtimer
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|TPTIMER
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
operator|(
name|TPACTIVE
operator||
name|TPREW
operator||
name|TPRMARK
operator||
name|TPWMARK
operator|)
operator|)
condition|)
return|return;
comment|/* If i/o going, simulate interrupt. */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|wtintr
argument_list|(
name|t
operator|->
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Restart timer if i/o pending. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
operator|(
name|TPACTIVE
operator||
name|TPREW
operator||
name|TPRMARK
operator||
name|TPWMARK
operator|)
condition|)
name|wtclock
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* reset the controller */
end_comment

begin_function
specifier|static
name|int
name|wtreset
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|RESET
argument_list|)
expr_stmt|;
comment|/* send reset */
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* turn off reset */
if|if
condition|(
operator|(
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
operator|&
name|t
operator|->
name|RESETMASK
operator|)
operator|!=
name|t
operator|->
name|RESETVAL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get controller status information */
end_comment

begin_comment
comment|/* return 0 if user i/o request should receive an i/o error code */
end_comment

begin_function
specifier|static
name|int
name|wtsense
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|ignor
parameter_list|)
block|{
name|char
modifier|*
name|msg
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TPRO
operator||
name|TPWO
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|wtstatus
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|error
operator|.
name|err
operator|&
name|TP_ST0
operator|)
condition|)
name|t
operator|->
name|error
operator|.
name|err
operator|&=
operator|~
name|TP_ST0MASK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|error
operator|.
name|err
operator|&
name|TP_ST1
operator|)
condition|)
name|t
operator|->
name|error
operator|.
name|err
operator|&=
operator|~
name|TP_ST1MASK
expr_stmt|;
name|t
operator|->
name|error
operator|.
name|err
operator|&=
operator|~
name|ignor
expr_stmt|;
comment|/* ignore certain errors */
name|err
operator|=
name|t
operator|->
name|error
operator|.
name|err
operator|&
operator|(
name|TP_FIL
operator||
name|TP_BNL
operator||
name|TP_UDA
operator||
name|TP_EOM
operator||
name|TP_WRP
operator||
name|TP_USL
operator||
name|TP_CNI
operator||
name|TP_MBD
operator||
name|TP_NDT
operator||
name|TP_ILL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* lifted from tdriver.c from Wangtek */
if|if
condition|(
name|err
operator|&
name|TP_USL
condition|)
name|msg
operator|=
literal|"Drive not online"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_CNI
condition|)
name|msg
operator|=
literal|"No cartridge"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|err
operator|&
name|TP_WRP
operator|)
operator|&&
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWP
operator|)
condition|)
block|{
name|msg
operator|=
literal|"Tape is write protected"
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|TPWP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_FIL
condition|)
name|msg
operator|=
literal|0
comment|/*"Filemark detected"*/
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_EOM
condition|)
name|msg
operator|=
literal|0
comment|/*"End of tape"*/
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_BNL
condition|)
name|msg
operator|=
literal|"Block not located"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_UDA
condition|)
name|msg
operator|=
literal|"Unrecoverable data error"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_NDT
condition|)
name|msg
operator|=
literal|"No data detected"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_ILL
condition|)
name|msg
operator|=
literal|"Illegal command"
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|printf
argument_list|(
literal|"wt%d: %s\n"
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get controller status information */
end_comment

begin_function
specifier|static
name|int
name|wtstatus
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|wtpoll
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* wait for ready or exception */
name|outb
argument_list|(
name|t
operator|->
name|CMDPORT
argument_list|,
name|QIC_RDSTAT
argument_list|)
expr_stmt|;
comment|/* send `read status' command */
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|REQUEST
operator||
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
comment|/* set request */
while|while
condition|(
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
operator|&
name|t
operator|->
name|BUSY
condition|)
comment|/* wait for ready */
continue|continue;
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
comment|/* reset request */
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
operator|&
name|t
operator|->
name|BUSY
operator|)
condition|)
comment|/* wait for not ready */
continue|continue;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|error
expr_stmt|;
while|while
condition|(
name|p
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|error
operator|+
literal|6
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|wtpoll
argument_list|(
name|t
argument_list|)
operator|&
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
comment|/* wait for ready */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* error */
operator|*
name|p
operator|++
operator|=
name|inb
argument_list|(
name|t
operator|->
name|DATAPORT
argument_list|)
expr_stmt|;
comment|/* read status byte */
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|REQUEST
argument_list|)
expr_stmt|;
comment|/* set request */
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
operator|&
name|t
operator|->
name|BUSY
operator|)
condition|)
comment|/* wait for not ready */
continue|continue;
comment|/* DELAY (50); */
comment|/* wait 50 usec */
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unset request */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NWT */
end_comment

end_unit

