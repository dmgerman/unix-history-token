begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Streamer tape driver for 386bsd and FreeBSD.  * Supports Archive and Wangtek compatible QIC-02/QIC-36 boards.  *  * Copyright (C) 1993 by:  *      Sergey Ryzhkov<sir@kiae.su>  *      Serge Vakulenko<vak@zebub.msk.su>  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations permission to use  * or modify this software as long as this message is kept with the software,  * all derivative works or modified versions.  *  * This driver is derived from the old 386bsd Wangtek streamer tape driver,  * made by Robert Baron at CMU, based on Intel sources.  * Authors thank Robert Baron, CMU and Intel and retain here  * the original CMU copyright notice.  *  * Version 1.3, Thu Nov 11 12:09:13 MSK 1993  * $FreeBSD$  *  */
end_comment

begin_comment
comment|/*  * Code for MTERASE added by John Lind (john@starfire.mn.org) 95/09/02.  * This was very easy due to the excellent structure and clear coding  * of the original driver.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1989 Carnegie-Mellon University.  * All rights reserved.  *  * Authors: Robert Baron  *  * Permission to use, copy, modify and distribute this software and  * its documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND  * FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|"wt.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/wtreg.h>
end_include

begin_comment
comment|/*  * Uncomment this to enable internal device tracing.  */
end_comment

begin_define
define|#
directive|define
name|TRACE
parameter_list|(
name|s
parameter_list|)
end_define

begin_comment
comment|/* printf s */
end_comment

begin_define
define|#
directive|define
name|WTPRI
value|(PZERO+10)
end_define

begin_comment
comment|/* sleep priority */
end_comment

begin_comment
comment|/*  * Wangtek controller ports  */
end_comment

begin_define
define|#
directive|define
name|WT_CTLPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+0)
end_define

begin_comment
comment|/* control, write only */
end_comment

begin_define
define|#
directive|define
name|WT_STATPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+0)
end_define

begin_comment
comment|/* status, read only */
end_comment

begin_define
define|#
directive|define
name|WT_CMDPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+1)
end_define

begin_comment
comment|/* command, write only */
end_comment

begin_define
define|#
directive|define
name|WT_DATAPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+1)
end_define

begin_comment
comment|/* data, read only */
end_comment

begin_define
define|#
directive|define
name|WT_NPORT
value|2
end_define

begin_comment
comment|/* 2 i/o ports */
end_comment

begin_comment
comment|/* status port bits */
end_comment

begin_define
define|#
directive|define
name|WT_BUSY
value|0x01
end_define

begin_comment
comment|/* not ready bit define */
end_comment

begin_define
define|#
directive|define
name|WT_NOEXCEP
value|0x02
end_define

begin_comment
comment|/* no exception bit define */
end_comment

begin_define
define|#
directive|define
name|WT_RESETMASK
value|0x07
end_define

begin_comment
comment|/* to check after reset */
end_comment

begin_define
define|#
directive|define
name|WT_RESETVAL
value|0x05
end_define

begin_comment
comment|/* state after reset */
end_comment

begin_comment
comment|/* control port bits */
end_comment

begin_define
define|#
directive|define
name|WT_ONLINE
value|0x01
end_define

begin_comment
comment|/* device selected */
end_comment

begin_define
define|#
directive|define
name|WT_RESET
value|0x02
end_define

begin_comment
comment|/* reset command */
end_comment

begin_define
define|#
directive|define
name|WT_REQUEST
value|0x04
end_define

begin_comment
comment|/* request command */
end_comment

begin_define
define|#
directive|define
name|WT_IEN
value|0x08
end_define

begin_comment
comment|/* enable dma */
end_comment

begin_comment
comment|/*  * Archive controller ports  */
end_comment

begin_define
define|#
directive|define
name|AV_DATAPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+0)
end_define

begin_comment
comment|/* data, read only */
end_comment

begin_define
define|#
directive|define
name|AV_CMDPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+0)
end_define

begin_comment
comment|/* command, write only */
end_comment

begin_define
define|#
directive|define
name|AV_STATPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+1)
end_define

begin_comment
comment|/* status, read only */
end_comment

begin_define
define|#
directive|define
name|AV_CTLPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+1)
end_define

begin_comment
comment|/* control, write only */
end_comment

begin_define
define|#
directive|define
name|AV_SDMAPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+2)
end_define

begin_comment
comment|/* start dma */
end_comment

begin_define
define|#
directive|define
name|AV_RDMAPORT
parameter_list|(
name|base
parameter_list|)
value|((base)+3)
end_define

begin_comment
comment|/* reset dma */
end_comment

begin_define
define|#
directive|define
name|AV_NPORT
value|4
end_define

begin_comment
comment|/* 4 i/o ports */
end_comment

begin_comment
comment|/* status port bits */
end_comment

begin_define
define|#
directive|define
name|AV_BUSY
value|0x40
end_define

begin_comment
comment|/* not ready bit define */
end_comment

begin_define
define|#
directive|define
name|AV_NOEXCEP
value|0x20
end_define

begin_comment
comment|/* no exception bit define */
end_comment

begin_define
define|#
directive|define
name|AV_RESETMASK
value|0xf8
end_define

begin_comment
comment|/* to check after reset */
end_comment

begin_define
define|#
directive|define
name|AV_RESETVAL
value|0x50
end_define

begin_comment
comment|/* state after reset */
end_comment

begin_comment
comment|/* control port bits */
end_comment

begin_define
define|#
directive|define
name|AV_RESET
value|0x80
end_define

begin_comment
comment|/* reset command */
end_comment

begin_define
define|#
directive|define
name|AV_REQUEST
value|0x40
end_define

begin_comment
comment|/* request command */
end_comment

begin_define
define|#
directive|define
name|AV_IEN
value|0x20
end_define

begin_comment
comment|/* enable interrupts */
end_comment

begin_enum
enum|enum
name|wttype
block|{
name|UNKNOWN
init|=
literal|0
block|,
comment|/* unknown type, driver disabled */
name|ARCHIVE
block|,
comment|/* Archive Viper SC499, SC402 etc */
name|WANGTEK
comment|/* Wangtek */
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|short
name|err
decl_stmt|;
comment|/* code for error encountered */
name|unsigned
name|short
name|ercnt
decl_stmt|;
comment|/* number of error blocks */
name|unsigned
name|short
name|urcnt
decl_stmt|;
comment|/* number of underruns */
block|}
name|wtstatus_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|enum
name|wttype
name|type
decl_stmt|;
comment|/* type of controller */
name|unsigned
name|unit
decl_stmt|;
comment|/* unit number */
name|unsigned
name|port
decl_stmt|;
comment|/* base i/o port */
name|unsigned
name|chan
decl_stmt|;
comment|/* dma channel number, 1..3 */
name|unsigned
name|flags
decl_stmt|;
comment|/* state of tape drive */
name|unsigned
name|dens
decl_stmt|;
comment|/* tape density */
name|int
name|bsize
decl_stmt|;
comment|/* tape block size */
name|void
modifier|*
name|buf
decl_stmt|;
comment|/* internal i/o buffer */
name|void
modifier|*
name|dmavaddr
decl_stmt|;
comment|/* virtual address of dma i/o buffer */
name|unsigned
name|dmatotal
decl_stmt|;
comment|/* size of i/o buffer */
name|unsigned
name|dmaflags
decl_stmt|;
comment|/* i/o direction, ISADMA_READ or ISADMA_WRITE */
name|unsigned
name|dmacount
decl_stmt|;
comment|/* resulting length of dma i/o */
name|wtstatus_t
name|error
decl_stmt|;
comment|/* status of controller */
name|unsigned
name|short
name|DATAPORT
decl_stmt|,
name|CMDPORT
decl_stmt|,
name|STATPORT
decl_stmt|,
name|CTLPORT
decl_stmt|,
name|SDMAPORT
decl_stmt|,
name|RDMAPORT
decl_stmt|;
name|unsigned
name|char
name|BUSY
decl_stmt|,
name|NOEXCEP
decl_stmt|,
name|RESETMASK
decl_stmt|,
name|RESETVAL
decl_stmt|;
name|unsigned
name|char
name|ONLINE
decl_stmt|,
name|RESET
decl_stmt|,
name|REQUEST
decl_stmt|,
name|IEN
decl_stmt|;
block|}
name|wtinfo_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|wtinfo_t
name|wttab
index|[
name|NWT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tape info by unit number */
end_comment

begin_function_decl
specifier|static
name|int
name|wtwait
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|catch
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtcmd
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtstart
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|unsigned
name|mode
parameter_list|,
name|void
modifier|*
name|vaddr
parameter_list|,
name|unsigned
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wtdma
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|wtimer
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|wtclock
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtreset
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtsense
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|verb
parameter_list|,
name|int
name|ignor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtstatus
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ointhand2_t
name|wtintr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|wtrewind
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtreadfm
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtwritefm
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wtpoll
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|mask
parameter_list|,
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|wtopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|wtclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|wtioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|wtstrategy
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|10
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|wt_cdevsw
init|=
block|{
comment|/* open */
name|wtopen
block|,
comment|/* close */
name|wtclose
block|,
comment|/* read */
name|physread
block|,
comment|/* write */
name|physwrite
block|,
comment|/* ioctl */
name|wtioctl
block|,
comment|/* poll */
name|nopoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|wtstrategy
block|,
comment|/* name */
literal|"wt"
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|,
comment|/* bmaj */
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Probe for the presence of the device.  */
end_comment

begin_function
specifier|static
name|int
name|wtprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|id
operator|->
name|id_unit
decl_stmt|;
specifier|static
name|int
name|once
decl_stmt|;
if|if
condition|(
operator|!
name|once
operator|++
condition|)
name|cdevsw_add
argument_list|(
operator|&
name|wt_cdevsw
argument_list|)
expr_stmt|;
name|t
operator|->
name|unit
operator|=
name|id
operator|->
name|id_unit
expr_stmt|;
name|t
operator|->
name|chan
operator|=
name|id
operator|->
name|id_drq
expr_stmt|;
name|t
operator|->
name|port
operator|=
name|id
operator|->
name|id_iobase
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|chan
operator|<
literal|1
operator|||
name|t
operator|->
name|chan
operator|>
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"wt%d: Bad drq=%d, should be 1..3\n"
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|t
operator|->
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Try Wangtek. */
name|t
operator|->
name|type
operator|=
name|WANGTEK
expr_stmt|;
name|t
operator|->
name|CTLPORT
operator|=
name|WT_CTLPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|STATPORT
operator|=
name|WT_STATPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|CMDPORT
operator|=
name|WT_CMDPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|DATAPORT
operator|=
name|WT_DATAPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|SDMAPORT
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|RDMAPORT
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|BUSY
operator|=
name|WT_BUSY
expr_stmt|;
name|t
operator|->
name|NOEXCEP
operator|=
name|WT_NOEXCEP
expr_stmt|;
name|t
operator|->
name|RESETMASK
operator|=
name|WT_RESETMASK
expr_stmt|;
name|t
operator|->
name|RESETVAL
operator|=
name|WT_RESETVAL
expr_stmt|;
name|t
operator|->
name|ONLINE
operator|=
name|WT_ONLINE
expr_stmt|;
name|t
operator|->
name|RESET
operator|=
name|WT_RESET
expr_stmt|;
name|t
operator|->
name|REQUEST
operator|=
name|WT_REQUEST
expr_stmt|;
name|t
operator|->
name|IEN
operator|=
name|WT_IEN
expr_stmt|;
if|if
condition|(
name|wtreset
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|WT_NPORT
operator|)
return|;
comment|/* Try Archive. */
name|t
operator|->
name|type
operator|=
name|ARCHIVE
expr_stmt|;
name|t
operator|->
name|CTLPORT
operator|=
name|AV_CTLPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|STATPORT
operator|=
name|AV_STATPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|CMDPORT
operator|=
name|AV_CMDPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|DATAPORT
operator|=
name|AV_DATAPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|SDMAPORT
operator|=
name|AV_SDMAPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|RDMAPORT
operator|=
name|AV_RDMAPORT
argument_list|(
name|t
operator|->
name|port
argument_list|)
expr_stmt|;
name|t
operator|->
name|BUSY
operator|=
name|AV_BUSY
expr_stmt|;
name|t
operator|->
name|NOEXCEP
operator|=
name|AV_NOEXCEP
expr_stmt|;
name|t
operator|->
name|RESETMASK
operator|=
name|AV_RESETMASK
expr_stmt|;
name|t
operator|->
name|RESETVAL
operator|=
name|AV_RESETVAL
expr_stmt|;
name|t
operator|->
name|ONLINE
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|RESET
operator|=
name|AV_RESET
expr_stmt|;
name|t
operator|->
name|REQUEST
operator|=
name|AV_REQUEST
expr_stmt|;
name|t
operator|->
name|IEN
operator|=
name|AV_IEN
expr_stmt|;
if|if
condition|(
name|wtreset
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|AV_NPORT
operator|)
return|;
comment|/* Tape controller not found. */
name|t
operator|->
name|type
operator|=
name|UNKNOWN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Device is found, configure it.  */
end_comment

begin_function
specifier|static
name|int
name|wtattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|id
operator|->
name|id_unit
decl_stmt|;
name|id
operator|->
name|id_ointr
operator|=
name|wtintr
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|ARCHIVE
condition|)
block|{
name|printf
argument_list|(
literal|"wt%d: type<Archive>\n"
argument_list|,
name|t
operator|->
name|unit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|t
operator|->
name|RDMAPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reset dma */
block|}
else|else
name|printf
argument_list|(
literal|"wt%d: type<Wangtek>\n"
argument_list|,
name|t
operator|->
name|unit
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|=
name|TPSTART
expr_stmt|;
comment|/* tape is rewound */
name|t
operator|->
name|dens
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* unknown density */
name|isa_dmainit
argument_list|(
name|t
operator|->
name|chan
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|wt_cdevsw
argument_list|,
name|id
operator|->
name|id_unit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"rwt%d"
argument_list|,
name|id
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|isa_driver
name|wtdriver
init|=
block|{
name|wtprobe
block|,
name|wtattach
block|,
literal|"wt"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Open routine, called on every device open.  */
end_comment

begin_function
specifier|static
name|int
name|wtopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|u
init|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_UNIT
decl_stmt|;
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|u
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|u
operator|>=
name|NWT
operator|||
name|t
operator|->
name|type
operator|==
name|UNKNOWN
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Check that device is not in use */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPINUSE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* If the tape is in rewound state, check the status and set density. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPSTART
condition|)
block|{
comment|/* If rewind is going on, wait */
name|error
operator|=
name|wtwait
argument_list|(
name|t
argument_list|,
name|PCATCH
argument_list|,
literal|"wtrew"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Check the controller status */
if|if
condition|(
operator|!
name|wtsense
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|?
literal|0
else|:
name|TP_WRP
argument_list|)
condition|)
block|{
comment|/* Bad status, reset the controller */
if|if
condition|(
operator|!
name|wtreset
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|!
name|wtsense
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|?
literal|0
else|:
name|TP_WRP
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Set up tape density. */
if|if
condition|(
name|t
operator|->
name|dens
operator|!=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|WT_DENSEL
operator|)
condition|)
block|{
name|int
name|d
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|WT_DENSEL
condition|)
block|{
case|case
name|WT_DENSDFLT
case|:
default|default:
break|break;
comment|/* default density */
case|case
name|WT_QIC11
case|:
name|d
operator|=
name|QIC_FMT11
expr_stmt|;
break|break;
comment|/* minor 010 */
case|case
name|WT_QIC24
case|:
name|d
operator|=
name|QIC_FMT24
expr_stmt|;
break|break;
comment|/* minor 020 */
case|case
name|WT_QIC120
case|:
name|d
operator|=
name|QIC_FMT120
expr_stmt|;
break|break;
comment|/* minor 030 */
case|case
name|WT_QIC150
case|:
name|d
operator|=
name|QIC_FMT150
expr_stmt|;
break|break;
comment|/* minor 040 */
case|case
name|WT_QIC300
case|:
name|d
operator|=
name|QIC_FMT300
expr_stmt|;
break|break;
comment|/* minor 050 */
case|case
name|WT_QIC600
case|:
name|d
operator|=
name|QIC_FMT600
expr_stmt|;
break|break;
comment|/* minor 060 */
block|}
if|if
condition|(
name|d
condition|)
block|{
comment|/* Change tape density. */
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|d
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|!
name|wtsense
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|TP_WRP
operator||
name|TP_ILL
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Check the status of the controller. */
if|if
condition|(
name|t
operator|->
name|error
operator|.
name|err
operator|&
name|TP_ILL
condition|)
block|{
name|printf
argument_list|(
literal|"wt%d: invalid tape density\n"
argument_list|,
name|t
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
block|}
name|t
operator|->
name|dens
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|WT_DENSEL
expr_stmt|;
block|}
name|t
operator|->
name|flags
operator|&=
operator|~
name|TPSTART
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|dens
operator|!=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|WT_DENSEL
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|t
operator|->
name|bsize
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|WT_BSIZE
operator|)
condition|?
literal|1024
else|:
literal|512
expr_stmt|;
name|t
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|t
operator|->
name|bsize
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|buf
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|isa_dma_acquire
argument_list|(
name|t
operator|->
name|chan
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|t
operator|->
name|flags
operator|=
name|TPINUSE
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|FREAD
condition|)
name|t
operator|->
name|flags
operator||=
name|TPREAD
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|FWRITE
condition|)
name|t
operator|->
name|flags
operator||=
name|TPWRITE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close routine, called on last device close.  */
end_comment

begin_function
specifier|static
name|int
name|wtclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|u
init|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_UNIT
decl_stmt|;
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|u
decl_stmt|;
if|if
condition|(
name|u
operator|>=
name|NWT
operator|||
name|t
operator|->
name|type
operator|==
name|UNKNOWN
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* If rewind is pending, do nothing */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPREW
condition|)
goto|goto
name|done
goto|;
comment|/* If seek forward is pending and no rewind on close, do nothing */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPRMARK
condition|)
block|{
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_NOREWIND
condition|)
goto|goto
name|done
goto|;
comment|/* If read file mark is going on, wait */
name|wtwait
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|"wtrfm"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPWANY
condition|)
comment|/* Tape was written.  Write file mark. */
name|wtwritefm
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_NOREWIND
operator|)
condition|)
block|{
comment|/* Rewind tape to beginning of tape. */
comment|/* Don't wait until rewind, though. */
name|wtrewind
argument_list|(
name|t
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|t
operator|->
name|flags
operator|&
name|TPRANY
operator|)
operator|&&
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
operator|(
name|TPVOL
operator||
name|TPWANY
operator|)
operator|)
condition|)
comment|/* Space forward to after next file mark if no writing done. */
comment|/* Don't wait for completion. */
name|wtreadfm
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|done
label|:
name|t
operator|->
name|flags
operator|&=
name|TPREW
operator||
name|TPRMARK
operator||
name|TPSTART
operator||
name|TPTIMER
expr_stmt|;
name|free
argument_list|(
name|t
operator|->
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|isa_dma_release
argument_list|(
name|t
operator|->
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ioctl routine.  Compatible with BSD ioctls.  * There are two possible ioctls:  * ioctl (int fd, MTIOCGET, struct mtget *buf)  -- get status  * ioctl (int fd, MTIOCTOP, struct mtop *buf)   -- do BSD-like op  */
end_comment

begin_function
specifier|static
name|int
name|wtioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|u
init|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|T_UNIT
decl_stmt|;
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|u
decl_stmt|;
name|int
name|error
decl_stmt|,
name|count
decl_stmt|,
name|op
decl_stmt|;
if|if
condition|(
name|u
operator|>=
name|NWT
operator|||
name|t
operator|->
name|type
operator|==
name|UNKNOWN
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|MTIOCIEOT
case|:
comment|/* ignore EOT errors */
case|case
name|MTIOCEEOT
case|:
comment|/* enable EOT errors */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MTIOCGET
case|:
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_type
operator|=
name|t
operator|->
name|type
operator|==
name|ARCHIVE
condition|?
name|MT_ISVIPER1
else|:
literal|0x11
expr_stmt|;
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_dsreg
operator|=
name|t
operator|->
name|flags
expr_stmt|;
comment|/* status */
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_erreg
operator|=
name|t
operator|->
name|error
operator|.
name|err
expr_stmt|;
comment|/* errors */
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_resid
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_fileno
operator|=
literal|0
expr_stmt|;
comment|/* file */
operator|(
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_blkno
operator|=
literal|0
expr_stmt|;
comment|/* block */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MTIOCTOP
case|:
break|break;
block|}
switch|switch
condition|(
call|(
name|short
call|)
argument_list|(
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
argument_list|)
operator|->
name|mt_op
condition|)
block|{
default|default:
case|case
name|MTFSR
case|:
comment|/* forward space record */
case|case
name|MTBSR
case|:
comment|/* backward space record */
case|case
name|MTBSF
case|:
comment|/* backward space file */
break|break;
case|case
name|MTNOP
case|:
comment|/* no operation, sets status only */
case|case
name|MTCACHE
case|:
comment|/* enable controller cache */
case|case
name|MTNOCACHE
case|:
comment|/* disable controller cache */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MTREW
case|:
comment|/* rewind */
case|case
name|MTOFFL
case|:
comment|/* rewind and put the drive offline */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPREW
condition|)
comment|/* rewind is running */
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|wtwait
argument_list|(
name|t
argument_list|,
name|PCATCH
argument_list|,
literal|"wtorew"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|wtrewind
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MTFSF
case|:
comment|/* forward space file */
for|for
control|(
name|count
operator|=
operator|(
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
operator|)
operator|->
name|mt_count
init|;
name|count
operator|>
literal|0
condition|;
operator|--
name|count
control|)
block|{
name|error
operator|=
name|wtwait
argument_list|(
name|t
argument_list|,
name|PCATCH
argument_list|,
literal|"wtorfm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|wtreadfm
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MTWEOF
case|:
comment|/* write an end-of-file record */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWRITE
operator|)
operator|||
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWP
operator|)
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
name|error
operator|=
name|wtwait
argument_list|(
name|t
argument_list|,
name|PCATCH
argument_list|,
literal|"wtowfm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|wtwritefm
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|MTRETENS
case|:
comment|/* re-tension tape */
name|error
operator|=
name|wtwait
argument_list|(
name|t
argument_list|,
name|PCATCH
argument_list|,
literal|"wtretens"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|op
operator|=
name|QIC_RETENS
expr_stmt|;
goto|goto
name|erase_retens
goto|;
case|case
name|MTERASE
case|:
comment|/* erase to EOM */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWRITE
operator|)
operator|||
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWP
operator|)
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
name|error
operator|=
name|wtwait
argument_list|(
name|t
argument_list|,
name|PCATCH
argument_list|,
literal|"wterase"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|op
operator|=
name|QIC_ERASE
expr_stmt|;
name|erase_retens
label|:
comment|/* ERASE and RETENS operations work like REWIND. */
comment|/* Simulate the rewind operation here. */
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TPRO
operator||
name|TPWO
operator||
name|TPVOL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|op
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|t
operator|->
name|flags
operator||=
name|TPSTART
operator||
name|TPREW
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|TPWANY
expr_stmt|;
name|wtclock
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Strategy routine.  */
end_comment

begin_function
specifier|static
name|void
name|wtstrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|u
init|=
name|minor
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|&
name|T_UNIT
decl_stmt|;
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|u
decl_stmt|;
name|int
name|s
decl_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|u
operator|>=
name|NWT
operator|||
name|t
operator|->
name|type
operator|==
name|UNKNOWN
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err2xit
goto|;
block|}
comment|/* at file marks and end of tape, we just return '0 bytes available' */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPVOL
condition|)
goto|goto
name|xit
goto|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|%
name|t
operator|->
name|bsize
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err2xit
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
comment|/* Check read access and no previous write to this tape. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPREAD
operator|)
operator|||
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWANY
operator|)
condition|)
goto|goto
name|errxit
goto|;
comment|/* For now, we assume that all data will be copied out */
comment|/* If read command outstanding, just skip down */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPRO
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|wtsense
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|TP_WRP
argument_list|)
condition|)
comment|/* clear status */
goto|goto
name|errxit
goto|;
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|QIC_RDDATA
argument_list|)
condition|)
block|{
comment|/* sed read mode */
name|wtsense
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|TP_WRP
argument_list|)
expr_stmt|;
goto|goto
name|errxit
goto|;
block|}
name|t
operator|->
name|flags
operator||=
name|TPRO
operator||
name|TPRANY
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Check write access and write protection. */
comment|/* No previous read from this tape allowed. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWRITE
operator|)
operator|||
operator|(
name|t
operator|->
name|flags
operator|&
operator|(
name|TPWP
operator||
name|TPRANY
operator|)
operator|)
condition|)
goto|goto
name|errxit
goto|;
comment|/* If write command outstanding, just skip down */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWO
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|wtsense
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* clear status */
goto|goto
name|errxit
goto|;
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|QIC_WRTDATA
argument_list|)
condition|)
block|{
comment|/* set write mode */
name|wtsense
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|errxit
goto|;
block|}
name|t
operator|->
name|flags
operator||=
name|TPWO
operator||
name|TPWANY
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|bp
operator|->
name|b_bcount
condition|)
goto|goto
name|xit
goto|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|TPEXCEP
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|wtstart
argument_list|(
name|t
argument_list|,
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
name|ISADMA_READ
else|:
name|ISADMA_WRITE
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
condition|)
block|{
name|wtwait
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"wtread"
else|:
literal|"wtwrite"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|-=
name|t
operator|->
name|dmacount
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPEXCEP
condition|)
block|{
name|errxit
label|:
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|err2xit
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
name|xit
label|:
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Interrupt routine.  */
end_comment

begin_function
specifier|static
name|void
name|wtintr
parameter_list|(
name|int
name|u
parameter_list|)
block|{
name|wtinfo_t
modifier|*
name|t
init|=
name|wttab
operator|+
name|u
decl_stmt|;
name|unsigned
name|char
name|s
decl_stmt|;
if|if
condition|(
name|u
operator|>=
name|NWT
operator|||
name|t
operator|->
name|type
operator|==
name|UNKNOWN
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"wtintr() -- device not configured\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
expr_stmt|;
comment|/* get status */
name|TRACE
argument_list|(
operator|(
literal|"wtintr() status=0x%x -- "
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
operator|(
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
operator|)
operator|)
operator|==
operator|(
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"busy\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
comment|/* device is busy */
block|}
comment|/* 	 * Check if rewind finished. 	 */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|TPREW
condition|)
block|{
name|TRACE
argument_list|(
operator|(
operator|(
name|s
operator|&
operator|(
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
operator|)
operator|)
operator|==
operator|(
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
operator|)
condition|?
literal|"rewind busy?\n"
else|:
literal|"rewind finished\n"
operator|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|TPREW
expr_stmt|;
comment|/* Rewind finished. */
name|wtsense
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|TP_WRP
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check if writing/reading of file mark finished. 	 */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
operator|(
name|TPRMARK
operator||
name|TPWMARK
operator|)
condition|)
block|{
name|TRACE
argument_list|(
operator|(
operator|(
name|s
operator|&
operator|(
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
operator|)
operator|)
operator|==
operator|(
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
operator|)
condition|?
literal|"marker r/w busy?\n"
else|:
literal|"marker r/w finished\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|&
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
comment|/* operation failed */
name|wtsense
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
operator|(
name|t
operator|->
name|flags
operator|&
name|TPRMARK
operator|)
condition|?
name|TP_WRP
else|:
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TPRMARK
operator||
name|TPWMARK
operator|)
expr_stmt|;
comment|/* operation finished */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Do we started any i/o?  If no, just return. 	 */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPACTIVE
operator|)
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"unexpected interrupt\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Clean up dma. 	 */
if|if
condition|(
operator|(
name|t
operator|->
name|dmaflags
operator|&
name|ISADMA_READ
operator|)
operator|&&
operator|(
name|t
operator|->
name|dmatotal
operator|-
name|t
operator|->
name|dmacount
operator|)
operator|<
name|t
operator|->
name|bsize
condition|)
block|{
comment|/* If reading short block, copy the internal buffer 		 * to the user memory. */
name|isa_dmadone
argument_list|(
name|t
operator|->
name|dmaflags
argument_list|,
name|t
operator|->
name|buf
argument_list|,
name|t
operator|->
name|bsize
argument_list|,
name|t
operator|->
name|chan
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|t
operator|->
name|buf
argument_list|,
name|t
operator|->
name|dmavaddr
argument_list|,
name|t
operator|->
name|dmatotal
operator|-
name|t
operator|->
name|dmacount
argument_list|)
expr_stmt|;
block|}
else|else
name|isa_dmadone
argument_list|(
name|t
operator|->
name|dmaflags
argument_list|,
name|t
operator|->
name|dmavaddr
argument_list|,
name|t
operator|->
name|bsize
argument_list|,
name|t
operator|->
name|chan
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|TPACTIVE
expr_stmt|;
name|t
operator|->
name|dmacount
operator|+=
name|t
operator|->
name|bsize
expr_stmt|;
name|t
operator|->
name|dmavaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|t
operator|->
name|dmavaddr
operator|+
name|t
operator|->
name|bsize
expr_stmt|;
comment|/* 	 * On exception, check for end of file and end of volume. 	 */
if|if
condition|(
operator|!
operator|(
name|s
operator|&
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"i/o exception\n"
operator|)
argument_list|)
expr_stmt|;
name|wtsense
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
operator|(
name|t
operator|->
name|dmaflags
operator|&
name|ISADMA_READ
operator|)
condition|?
name|TP_WRP
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|error
operator|.
name|err
operator|&
operator|(
name|TP_EOM
operator||
name|TP_FIL
operator|)
condition|)
name|t
operator|->
name|flags
operator||=
name|TPVOL
expr_stmt|;
comment|/* end of file */
else|else
name|t
operator|->
name|flags
operator||=
name|TPEXCEP
expr_stmt|;
comment|/* i/o error */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|t
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|t
operator|->
name|dmacount
operator|<
name|t
operator|->
name|dmatotal
condition|)
block|{
comment|/* continue i/o */
name|wtdma
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"continue i/o, %d\n"
operator|,
name|t
operator|->
name|dmacount
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|t
operator|->
name|dmacount
operator|>
name|t
operator|->
name|dmatotal
condition|)
comment|/* short last block */
name|t
operator|->
name|dmacount
operator|=
name|t
operator|->
name|dmatotal
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|t
argument_list|)
expr_stmt|;
comment|/* wake up user level */
name|TRACE
argument_list|(
operator|(
literal|"i/o finished, %d\n"
operator|,
name|t
operator|->
name|dmacount
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* start the rewind operation */
end_comment

begin_function
specifier|static
name|void
name|wtrewind
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
name|int
name|rwmode
init|=
operator|(
name|t
operator|->
name|flags
operator|&
operator|(
name|TPRO
operator||
name|TPWO
operator|)
operator|)
decl_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TPRO
operator||
name|TPWO
operator||
name|TPVOL
operator|)
expr_stmt|;
comment|/* 	 * Wangtek strictly follows QIC-02 standard: 	 * clearing ONLINE in read/write modes causes rewind. 	 * REWIND command is not allowed in read/write mode 	 * and gives `illegal command' error. 	 */
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|WANGTEK
operator|&&
name|rwmode
condition|)
block|{
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|QIC_REWIND
argument_list|)
condition|)
return|return;
name|t
operator|->
name|flags
operator||=
name|TPSTART
operator||
name|TPREW
expr_stmt|;
name|wtclock
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* start the `read marker' operation */
end_comment

begin_function
specifier|static
name|int
name|wtreadfm
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TPRO
operator||
name|TPWO
operator||
name|TPVOL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|QIC_READFM
argument_list|)
condition|)
block|{
name|wtsense
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
name|TP_WRP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|t
operator|->
name|flags
operator||=
name|TPRMARK
operator||
name|TPRANY
expr_stmt|;
name|wtclock
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Don't wait for completion here. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* write marker to the tape */
end_comment

begin_function
specifier|static
name|int
name|wtwritefm
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|wtwritefm
argument_list|,
name|WTPRI
argument_list|,
literal|"wtwfm"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* timeout: 1 second */
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TPRO
operator||
name|TPWO
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|wtcmd
argument_list|(
name|t
argument_list|,
name|QIC_WRITEFM
argument_list|)
condition|)
block|{
name|wtsense
argument_list|(
name|t
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|t
operator|->
name|flags
operator||=
name|TPWMARK
operator||
name|TPWANY
expr_stmt|;
name|wtclock
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|wtwait
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
literal|"wtwfm"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* while controller status& mask == bits continue waiting */
end_comment

begin_function
specifier|static
name|int
name|wtpoll
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|mask
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
comment|/* Poll status port, waiting for specified bits. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
operator|++
name|i
control|)
block|{
comment|/* up to 1 msec */
name|s
operator|=
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
name|mask
operator|)
operator|!=
name|bits
condition|)
return|return
operator|(
name|s
operator|)
return|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
operator|++
name|i
control|)
block|{
comment|/* up to 10 msec */
name|s
operator|=
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
name|mask
operator|)
operator|!=
name|bits
condition|)
return|return
operator|(
name|s
operator|)
return|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* forever */
name|s
operator|=
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
name|mask
operator|)
operator|!=
name|bits
condition|)
return|return
operator|(
name|s
operator|)
return|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|wtpoll
argument_list|,
name|WTPRI
argument_list|,
literal|"wtpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* timeout: 1 tick */
block|}
block|}
end_function

begin_comment
comment|/* execute QIC command */
end_comment

begin_function
specifier|static
name|int
name|wtcmd
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|x
decl_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"wtcmd() cmd=0x%x\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|s
operator|=
name|wtpoll
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
argument_list|,
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
argument_list|)
expr_stmt|;
comment|/* ready? */
if|if
condition|(
operator|!
operator|(
name|s
operator|&
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
block|{
comment|/* error */
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|outb
argument_list|(
name|t
operator|->
name|CMDPORT
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* output the command */
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|REQUEST
operator||
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
comment|/* set request */
name|wtpoll
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|BUSY
argument_list|,
name|t
operator|->
name|BUSY
argument_list|)
expr_stmt|;
comment|/* wait for ready */
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|IEN
operator||
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
comment|/* reset request */
name|wtpoll
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|BUSY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* wait for not ready */
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* wait for the end of i/o, seeking marker or rewind operation */
end_comment

begin_function
specifier|static
name|int
name|wtwait
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|catch
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"wtwait() `%s'\n"
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|t
operator|->
name|flags
operator|&
operator|(
name|TPACTIVE
operator||
name|TPREW
operator||
name|TPRMARK
operator||
name|TPWMARK
operator|)
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|t
argument_list|,
name|WTPRI
operator||
name|catch
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* initialize dma for the i/o operation */
end_comment

begin_function
specifier|static
name|void
name|wtdma
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|flags
operator||=
name|TPACTIVE
expr_stmt|;
name|wtclock
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|type
operator|==
name|ARCHIVE
condition|)
name|outb
argument_list|(
name|t
operator|->
name|SDMAPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set dma */
if|if
condition|(
operator|(
name|t
operator|->
name|dmaflags
operator|&
name|ISADMA_READ
operator|)
operator|&&
operator|(
name|t
operator|->
name|dmatotal
operator|-
name|t
operator|->
name|dmacount
operator|)
operator|<
name|t
operator|->
name|bsize
condition|)
comment|/* Reading short block.  Do it through the internal buffer. */
name|isa_dmastart
argument_list|(
name|t
operator|->
name|dmaflags
argument_list|,
name|t
operator|->
name|buf
argument_list|,
name|t
operator|->
name|bsize
argument_list|,
name|t
operator|->
name|chan
argument_list|)
expr_stmt|;
else|else
name|isa_dmastart
argument_list|(
name|t
operator|->
name|dmaflags
argument_list|,
name|t
operator|->
name|dmavaddr
argument_list|,
name|t
operator|->
name|bsize
argument_list|,
name|t
operator|->
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* start i/o operation */
end_comment

begin_function
specifier|static
name|int
name|wtstart
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|unsigned
name|flags
parameter_list|,
name|void
modifier|*
name|vaddr
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|x
decl_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"wtstart()\n"
operator|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|s
operator|=
name|wtpoll
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
argument_list|,
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
argument_list|)
expr_stmt|;
comment|/* ready? */
if|if
condition|(
operator|!
operator|(
name|s
operator|&
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
block|{
name|t
operator|->
name|flags
operator||=
name|TPEXCEP
expr_stmt|;
comment|/* error */
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|t
operator|->
name|flags
operator|&=
operator|~
name|TPEXCEP
expr_stmt|;
comment|/* clear exception flag */
name|t
operator|->
name|dmavaddr
operator|=
name|vaddr
expr_stmt|;
name|t
operator|->
name|dmatotal
operator|=
name|len
expr_stmt|;
name|t
operator|->
name|dmacount
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|dmaflags
operator|=
name|flags
expr_stmt|;
name|wtdma
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* start timer */
end_comment

begin_function
specifier|static
name|void
name|wtclock
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPTIMER
operator|)
condition|)
block|{
name|t
operator|->
name|flags
operator||=
name|TPTIMER
expr_stmt|;
comment|/* Some controllers seem to lose dma interrupts too often. 		 * To make the tape stream we need 1 tick timeout. */
name|timeout
argument_list|(
name|wtimer
argument_list|,
operator|(
name|caddr_t
operator|)
name|t
argument_list|,
operator|(
name|t
operator|->
name|flags
operator|&
name|TPACTIVE
operator|)
condition|?
literal|1
else|:
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Simulate an interrupt periodically while i/o is going.  * This is necessary in case interrupts get eaten due to  * multiple devices on a single IRQ line.  */
end_comment

begin_function
specifier|static
name|void
name|wtimer
parameter_list|(
name|void
modifier|*
name|xt
parameter_list|)
block|{
name|wtinfo_t
modifier|*
name|t
init|=
operator|(
name|wtinfo_t
operator|*
operator|)
name|xt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|TPTIMER
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
operator|(
name|TPACTIVE
operator||
name|TPREW
operator||
name|TPRMARK
operator||
name|TPWMARK
operator|)
operator|)
condition|)
return|return;
comment|/* If i/o going, simulate interrupt. */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
operator|&
operator|(
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
operator|)
operator|)
operator|!=
operator|(
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
block|{
name|TRACE
argument_list|(
operator|(
literal|"wtimer() -- "
operator|)
argument_list|)
expr_stmt|;
name|wtintr
argument_list|(
name|t
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Restart timer if i/o pending. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
operator|(
name|TPACTIVE
operator||
name|TPREW
operator||
name|TPRMARK
operator||
name|TPWMARK
operator|)
condition|)
name|wtclock
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* reset the controller */
end_comment

begin_function
specifier|static
name|int
name|wtreset
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
comment|/* Perform QIC-02 and QIC-36 compatible reset sequence. */
comment|/* Thanks to Mikael Hybsch<micke@dynas.se>. */
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|RESET
operator||
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
comment|/* send reset */
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
comment|/* turn off reset */
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
comment|/* Read the controller status. */
name|s
operator|=
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0xff
condition|)
comment|/* no port at this address? */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Wait 3 sec for reset to complete. Needed for QIC-36 boards? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3000
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|&
name|t
operator|->
name|BUSY
operator|)
operator|||
operator|!
operator|(
name|s
operator|&
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|s
operator|=
name|inb
argument_list|(
name|t
operator|->
name|STATPORT
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|s
operator|&
name|t
operator|->
name|RESETMASK
operator|)
operator|==
name|t
operator|->
name|RESETVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get controller status information */
end_comment

begin_comment
comment|/* return 0 if user i/o request should receive an i/o error code */
end_comment

begin_function
specifier|static
name|int
name|wtsense
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|,
name|int
name|verb
parameter_list|,
name|int
name|ignor
parameter_list|)
block|{
name|char
modifier|*
name|msg
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
name|TRACE
argument_list|(
operator|(
literal|"wtsense() ignor=0x%x\n"
operator|,
name|ignor
operator|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
operator|(
name|TPRO
operator||
name|TPWO
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|wtstatus
argument_list|(
name|t
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|error
operator|.
name|err
operator|&
name|TP_ST0
operator|)
condition|)
name|t
operator|->
name|error
operator|.
name|err
operator|&=
operator|~
name|TP_ST0MASK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|error
operator|.
name|err
operator|&
name|TP_ST1
operator|)
condition|)
name|t
operator|->
name|error
operator|.
name|err
operator|&=
operator|~
name|TP_ST1MASK
expr_stmt|;
name|t
operator|->
name|error
operator|.
name|err
operator|&=
operator|~
name|ignor
expr_stmt|;
comment|/* ignore certain errors */
name|err
operator|=
name|t
operator|->
name|error
operator|.
name|err
operator|&
operator|(
name|TP_FIL
operator||
name|TP_BNL
operator||
name|TP_UDA
operator||
name|TP_EOM
operator||
name|TP_WRP
operator||
name|TP_USL
operator||
name|TP_CNI
operator||
name|TP_MBD
operator||
name|TP_NDT
operator||
name|TP_ILL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|verb
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* lifted from tdriver.c from Wangtek */
if|if
condition|(
name|err
operator|&
name|TP_USL
condition|)
name|msg
operator|=
literal|"Drive not online"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_CNI
condition|)
name|msg
operator|=
literal|"No cartridge"
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|err
operator|&
name|TP_WRP
operator|)
operator|&&
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|TPWP
operator|)
condition|)
block|{
name|msg
operator|=
literal|"Tape is write protected"
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|TPWP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_FIL
condition|)
name|msg
operator|=
literal|0
comment|/*"Filemark detected"*/
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_EOM
condition|)
name|msg
operator|=
literal|0
comment|/*"End of tape"*/
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_BNL
condition|)
name|msg
operator|=
literal|"Block not located"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_UDA
condition|)
name|msg
operator|=
literal|"Unrecoverable data error"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_NDT
condition|)
name|msg
operator|=
literal|"No data detected"
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|&
name|TP_ILL
condition|)
name|msg
operator|=
literal|"Illegal command"
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|printf
argument_list|(
literal|"wt%d: %s\n"
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get controller status information */
end_comment

begin_function
specifier|static
name|int
name|wtstatus
parameter_list|(
name|wtinfo_t
modifier|*
name|t
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|x
decl_stmt|;
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|wtpoll
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
argument_list|,
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
argument_list|)
expr_stmt|;
comment|/* ready? */
name|outb
argument_list|(
name|t
operator|->
name|CMDPORT
argument_list|,
name|QIC_RDSTAT
argument_list|)
expr_stmt|;
comment|/* send `read status' command */
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|REQUEST
operator||
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
comment|/* set request */
name|wtpoll
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|BUSY
argument_list|,
name|t
operator|->
name|BUSY
argument_list|)
expr_stmt|;
comment|/* wait for ready */
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
comment|/* reset request */
name|wtpoll
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|BUSY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* wait for not ready */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|error
expr_stmt|;
while|while
condition|(
name|p
operator|<
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|error
operator|+
literal|6
condition|)
block|{
name|int
name|s
init|=
name|wtpoll
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
argument_list|,
name|t
operator|->
name|BUSY
operator||
name|t
operator|->
name|NOEXCEP
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|&
name|t
operator|->
name|NOEXCEP
operator|)
condition|)
block|{
comment|/* error */
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|p
operator|++
operator|=
name|inb
argument_list|(
name|t
operator|->
name|DATAPORT
argument_list|)
expr_stmt|;
comment|/* read status byte */
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|REQUEST
operator||
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
comment|/* set request */
name|wtpoll
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|BUSY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* wait for not ready */
name|DELAY
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|t
operator|->
name|CTLPORT
argument_list|,
name|t
operator|->
name|ONLINE
argument_list|)
expr_stmt|;
comment|/* unset request */
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

