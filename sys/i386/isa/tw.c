begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1995 Eugene W. Stark  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Eugene W. Stark.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY EUGENE W. STARK (THE AUTHOR) ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"tw.h"
end_include

begin_if
if|#
directive|if
name|NTW
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_comment
comment|/*  * Driver configuration parameters  */
end_comment

begin_comment
comment|/*  * Time for 1/2 of a power line cycle, in microseconds.  * Change this to 10000 for 50Hz power.  Phil Sampson  * (vk2jnt@gw.vk2jnt.ampr.org OR sampson@gidday.enet.dec.com)  * reports that this works (at least in Australia) using a  * TW7223 module (a local version of the TW523).  */
end_comment

begin_define
define|#
directive|define
name|HALFCYCLE
value|8333
end_define

begin_comment
comment|/* 1/2 cycle = 8333us at 60Hz */
end_comment

begin_comment
comment|/*  * Undefine the following if you don't have the high-resolution "microtime"  * routines (leave defined for FreeBSD, which has them).  */
end_comment

begin_define
define|#
directive|define
name|HIRESTIME
end_define

begin_comment
comment|/*  * End of driver configuration parameters  */
end_comment

begin_comment
comment|/*  * FreeBSD Device Driver for X-10 POWERHOUSE (tm)  * Two-Way Power Line Interface, Model #TW523  *  * written by Eugene W. Stark (stark@cs.sunysb.edu)  * December 2, 1992  *  * NOTES:  *  * The TW523 is a carrier-current modem for home control/automation purposes.  * It is made by:  *  * 	X-10 Inc.  * 	185A LeGrand Ave.  * 	Northvale, NJ 07647  * 	USA  * 	(201) 784-9700 or 1-800-526-0027  *  * 	X-10 Home Controls Inc.  * 	1200 Aerowood Drive, Unit 20  * 	Mississauga, Ontario  *	(416) 624-4446 or 1-800-387-3346  *  * The TW523 is designed for communications using the X-10 protocol,  * which is compatible with a number of home control systems, including  * Radio Shack "Plug 'n Power(tm)" and Stanley "Lightmaker(tm)."  * I bought my TW523 from:  *  *	Home Control Concepts  *	9353-C Activity Road  *	San Diego, CA 92126  *	(619) 693-8887  *  * They supplied me with the TW523 (which has an RJ-11 four-wire modular  * telephone connector), a modular cable, an RJ-11 to DB-25 connector with  * internal wiring, documentation from X-10 on the TW523 (very good),  * an instruction manual by Home Control Concepts (not very informative),  * and a floppy disk containing binary object code of some demonstration/test  * programs and of a C function library suitable for controlling the TW523  * by an IBM PC under MS-DOS (not useful to me other than to verify that  * the unit worked).  I suggest saving money and buying the bare TW523  * rather than the TW523 development kit (what I bought), because if you  * are running FreeBSD you don't really care about the DOS binaries.  *  * The interface to the TW-523 consists of four wires on the RJ-11 connector,  * which are jumpered to somewhat more wires on the DB-25 connector, which  * in turn is intended to plug into the PC parallel printer port.  I dismantled  * the DB-25 connector to find out what they had done:  *  *	Signal		RJ-11 pin	DB-25 pin(s)	Parallel Port  *	Transmit TX	  4 (Y)		2, 4, 6, 8	Data out  *	Receive RX	  3 (G)		10, 14		-ACK, -AutoFeed  *	Common		  2 (R)		25		Common  *	Zero crossing	  1 (B)		17 or 12	-Select or +PaperEnd  *  * NOTE: In the original cable I have (which I am still using, May, 1997)  * the Zero crossing signal goes to pin 17 (-Select) on the parallel port.  * In retrospect, this doesn't make a whole lot of sense, given that the  * -Select signal propagates the other direction.  Indeed, some people have  * reported problems with this, and have had success using pin 12 (+PaperEnd)  * instead.  This driver searches for the zero crossing signal on either  * pin 17 or pin 12, so it should work with either cable configuration.  * My suggestion would be to start by making the cable so that the zero  * crossing signal goes to pin 12 on the parallel port.  *  * The zero crossing signal is used to synchronize transmission to the  * zero crossings of the AC line, as detailed in the X-10 documentation.  * It would be nice if one could generate interrupts with this signal,  * however one needs interrupts on both the rising and falling edges,  * and the -ACK signal to the parallel port interrupts only on the falling  * edge, so it can't be done without additional hardware.  *  * In this driver, the transmit function is performed in a non-interrupt-driven  * fashion, by polling the zero crossing signal to determine when a transition  * has occurred.  This wastes CPU time during transmission, but it seems like  * the best that can be done without additional hardware.  One problem with  * the scheme is that preemption of the CPU during transmission can cause loss  * of sync.  The driver tries to catch this, by noticing that a long delay  * loop has somehow become foreshortened, and the transmission is aborted with  * an error return.  It is up to the user level software to handle this  * situation (most likely by retrying the transmission).  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b)?(a):(b))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HIRESTIME
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HIRESTIME */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_comment
comment|/*  * Transmission is done by calling write() to send three byte packets of data.  * The first byte contains a four bit house code (0=A to 15=P).  * The second byte contains five bit unit/key code (0=unit 1 to 15=unit 16,  * 16=All Units Off to 31 = Status Request).  The third byte specifies  * the number of times the packet is to be transmitted without any  * gaps between successive transmissions.  Normally this is 2, as per  * the X-10 documentation, but sometimes (e.g. for bright and dim codes)  * it can be another value.  Each call to write can specify an arbitrary  * number of data bytes.  An incomplete packet is buffered until a subsequent  * call to write() provides data to complete it.  At most one packet will  * actually be processed in any call to write().  Successive calls to write()  * leave a three-cycle gap between transmissions, per the X-10 documentation.  *  * Reception is done using read().  * The driver produces a series of three-character packets.  * In each packet, the first character consists of flags,  * the second character is a four bit house code (0-15),  * and the third character is a five bit key/function code (0-31).  * The flags are the following:  */
end_comment

begin_define
define|#
directive|define
name|TW_RCV_LOCAL
value|1
end_define

begin_comment
comment|/* The packet arrived during a local transmission */
end_comment

begin_define
define|#
directive|define
name|TW_RCV_ERROR
value|2
end_define

begin_comment
comment|/* An invalid/corrupted packet was received */
end_comment

begin_comment
comment|/*  * IBM PC parallel port definitions relevant to TW523  */
end_comment

begin_define
define|#
directive|define
name|tw_data
value|0
end_define

begin_comment
comment|/* Data to tw523 (R/W) */
end_comment

begin_define
define|#
directive|define
name|tw_status
value|1
end_define

begin_comment
comment|/* Status of tw523 (R) */
end_comment

begin_define
define|#
directive|define
name|TWS_RDATA
value|0x40
end_define

begin_comment
comment|/* tw523 receive data */
end_comment

begin_define
define|#
directive|define
name|TWS_OUT
value|0x20
end_define

begin_comment
comment|/* pin 12, out of paper */
end_comment

begin_define
define|#
directive|define
name|tw_control
value|2
end_define

begin_comment
comment|/* Control tw523 (R/W) */
end_comment

begin_define
define|#
directive|define
name|TWC_SYNC
value|0x08
end_define

begin_comment
comment|/* tw523 sync (pin 17) */
end_comment

begin_define
define|#
directive|define
name|TWC_ENA
value|0x10
end_define

begin_comment
comment|/* tw523 interrupt enable */
end_comment

begin_comment
comment|/*  * Miscellaneous defines  */
end_comment

begin_define
define|#
directive|define
name|TWUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev))
end_define

begin_comment
comment|/* Extract unit number from device */
end_comment

begin_define
define|#
directive|define
name|TWPRI
value|(PZERO+8)
end_define

begin_comment
comment|/* I don't know any better, so let's */
end_comment

begin_comment
comment|/* use the same as the line printer */
end_comment

begin_function_decl
specifier|static
name|int
name|twprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|twdriver
init|=
block|{
name|twprobe
block|,
name|twattach
block|,
literal|"tw"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|twopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|twclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|twread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|twwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|twpoll
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|19
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|tw_cdevsw
init|=
block|{
name|twopen
block|,
name|twclose
block|,
name|twread
block|,
name|twwrite
block|,
comment|/*19*/
name|noioc
block|,
name|nullstop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
comment|/* tw */
name|twpoll
block|,
name|nommap
block|,
name|nostrat
block|,
literal|"tw"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Software control structure for TW523  */
end_comment

begin_define
define|#
directive|define
name|TWS_XMITTING
value|1
end_define

begin_comment
comment|/* Transmission in progress */
end_comment

begin_define
define|#
directive|define
name|TWS_RCVING
value|2
end_define

begin_comment
comment|/* Reception in progress */
end_comment

begin_define
define|#
directive|define
name|TWS_WANT
value|4
end_define

begin_comment
comment|/* A process wants received data */
end_comment

begin_define
define|#
directive|define
name|TWS_OPEN
value|8
end_define

begin_comment
comment|/* Is it currently open? */
end_comment

begin_define
define|#
directive|define
name|TW_SIZE
value|3*60
end_define

begin_comment
comment|/* Enough for about 10 sec. of input */
end_comment

begin_define
define|#
directive|define
name|TW_MIN_DELAY
value|1500
end_define

begin_comment
comment|/* Ignore interrupts of lesser latency */
end_comment

begin_struct
specifier|static
struct|struct
name|tw_sc
block|{
name|u_int
name|sc_port
decl_stmt|;
comment|/* I/O Port */
name|u_int
name|sc_state
decl_stmt|;
comment|/* Current software control state */
name|struct
name|selinfo
name|sc_selp
decl_stmt|;
comment|/* Information for select() */
name|u_char
name|sc_xphase
decl_stmt|;
comment|/* Current state of sync (for transmitter) */
name|u_char
name|sc_rphase
decl_stmt|;
comment|/* Current state of sync (for receiver) */
name|u_char
name|sc_flags
decl_stmt|;
comment|/* Flags for current reception */
name|short
name|sc_rcount
decl_stmt|;
comment|/* Number of bits received so far */
name|int
name|sc_bits
decl_stmt|;
comment|/* Bits received so far */
name|u_char
name|sc_pkt
index|[
literal|3
index|]
decl_stmt|;
comment|/* Packet not yet transmitted */
name|short
name|sc_pktsize
decl_stmt|;
comment|/* How many bytes in the packet? */
name|u_char
name|sc_buf
index|[
name|TW_SIZE
index|]
decl_stmt|;
comment|/* We buffer our own input */
name|int
name|sc_nextin
decl_stmt|;
comment|/* Next free slot in circular buffer */
name|int
name|sc_nextout
decl_stmt|;
comment|/* First used slot in circular buffer */
comment|/* Callout for canceling our abortrcv timeout */
name|struct
name|callout_handle
name|abortrcv_ch
decl_stmt|;
ifdef|#
directive|ifdef
name|HIRESTIME
name|int
name|sc_xtimes
index|[
literal|22
index|]
decl_stmt|;
comment|/* Times for bits in current xmit packet */
name|int
name|sc_rtimes
index|[
literal|22
index|]
decl_stmt|;
comment|/* Times for bits in current rcv packet */
name|int
name|sc_no_rcv
decl_stmt|;
comment|/* number of interrupts received */
define|#
directive|define
name|SC_RCV_TIME_LEN
value|128
name|int
name|sc_rcv_time
index|[
name|SC_RCV_TIME_LEN
index|]
decl_stmt|;
comment|/* usec time stamp on interrupt */
endif|#
directive|endif
comment|/* HIRESTIME */
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|devfs_token
decl_stmt|;
comment|/* store the devfs handle */
endif|#
directive|endif
block|}
name|tw_sc
index|[
name|NTW
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|tw_zcport
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* offset of port for zero crossing signal */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tw_zcmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mask for the zero crossing signal */
end_comment

begin_function_decl
specifier|static
name|void
name|twdelay25
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twdelayn
parameter_list|(
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twsetuptimes
parameter_list|(
name|int
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wait_for_zero
parameter_list|(
name|struct
name|tw_sc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twputpkt
parameter_list|(
name|struct
name|tw_sc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twgetbytes
parameter_list|(
name|struct
name|tw_sc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|twabortrcv
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|twsend
parameter_list|(
name|struct
name|tw_sc
modifier|*
name|sc
parameter_list|,
name|int
name|h
parameter_list|,
name|int
name|k
parameter_list|,
name|int
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|next_zero
parameter_list|(
name|struct
name|tw_sc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|twchecktime
parameter_list|(
name|int
name|target
parameter_list|,
name|int
name|tol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|twdebugtimes
parameter_list|(
name|struct
name|tw_sc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Counter value for delay loop.  * It is adjusted by twprobe so that the delay loop takes about 25us.  */
end_comment

begin_define
define|#
directive|define
name|TWDELAYCOUNT
value|161
end_define

begin_comment
comment|/* Works on my 486DX/33 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|twdelaycount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Twdelay25 is used for very short delays of about 25us.  * It is implemented with a calibrated delay loop, and should be  * fairly accurate ... unless we are preempted by an interrupt.  *  * We use this to wait for zero crossings because the X-10 specs say we  * are supposed to assert carrier within 25us when one happens.  * I don't really believe we can do this, but the X-10 devices seem to be  * fairly forgiving.  */
end_comment

begin_function
specifier|static
name|void
name|twdelay25
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
for|for
control|(
name|cnt
operator|=
name|twdelaycount
init|;
name|cnt
condition|;
name|cnt
operator|--
control|)
empty_stmt|;
comment|/* Should take about 25us */
block|}
end_function

begin_comment
comment|/*  * Twdelayn is used to time the length of the 1ms carrier pulse.  * This is not very critical, but if we have high-resolution time-of-day  * we check it every apparent 200us to make sure we don't get too far off  * if we happen to be interrupted during the delay.  */
end_comment

begin_function
specifier|static
name|void
name|twdelayn
parameter_list|(
name|int
name|n
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HIRESTIME
name|int
name|t
decl_stmt|,
name|d
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|t
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
name|t
operator|+=
name|n
expr_stmt|;
endif|#
directive|endif
comment|/* HIRESTIME */
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|twdelay25
argument_list|()
expr_stmt|;
name|n
operator|-=
literal|25
expr_stmt|;
ifdef|#
directive|ifdef
name|HIRESTIME
if|if
condition|(
operator|(
name|n
operator|&
literal|0x7
operator|)
operator|==
literal|0
condition|)
block|{
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|d
operator|=
name|tv
operator|.
name|tv_usec
operator|-
name|t
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|0
operator|&&
name|d
operator|<
literal|1000000
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* HIRESTIME */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|twprobe
parameter_list|(
name|idp
parameter_list|)
name|struct
name|isa_device
modifier|*
name|idp
decl_stmt|;
block|{
name|struct
name|tw_sc
name|sc
decl_stmt|;
name|int
name|d
decl_stmt|;
name|int
name|tries
decl_stmt|;
name|sc
operator|.
name|sc_port
operator|=
name|idp
operator|->
name|id_iobase
expr_stmt|;
comment|/* Search for the zero crossing signal at ports, bit combinations. */
name|tw_zcport
operator|=
name|tw_control
expr_stmt|;
name|tw_zcmask
operator|=
name|TWC_SYNC
expr_stmt|;
name|sc
operator|.
name|sc_xphase
operator|=
name|inb
argument_list|(
name|idp
operator|->
name|id_iobase
operator|+
name|tw_zcport
argument_list|)
operator|&
name|tw_zcmask
expr_stmt|;
if|if
condition|(
name|wait_for_zero
argument_list|(
operator|&
name|sc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|tw_zcport
operator|=
name|tw_status
expr_stmt|;
name|tw_zcmask
operator|=
name|TWS_OUT
expr_stmt|;
name|sc
operator|.
name|sc_xphase
operator|=
name|inb
argument_list|(
name|idp
operator|->
name|id_iobase
operator|+
name|tw_zcport
argument_list|)
operator|&
name|tw_zcmask
expr_stmt|;
block|}
if|if
condition|(
name|wait_for_zero
argument_list|(
operator|&
name|sc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*    * Iteratively check the timing of a few sync transitions, and adjust    * the loop delay counter, if necessary, to bring the timing reported    * by wait_for_zero() close to HALFCYCLE.  Give up if anything    * ridiculous happens.    */
if|if
condition|(
name|twdelaycount
operator|==
literal|0
condition|)
block|{
comment|/* Only adjust timing for first unit */
name|twdelaycount
operator|=
name|TWDELAYCOUNT
expr_stmt|;
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
literal|10
condition|;
name|tries
operator|++
control|)
block|{
name|sc
operator|.
name|sc_xphase
operator|=
name|inb
argument_list|(
name|idp
operator|->
name|id_iobase
operator|+
name|tw_zcport
argument_list|)
operator|&
name|tw_zcmask
expr_stmt|;
if|if
condition|(
name|wait_for_zero
argument_list|(
operator|&
name|sc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|d
operator|=
name|wait_for_zero
argument_list|(
operator|&
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<=
name|HALFCYCLE
operator|/
literal|100
operator|||
name|d
operator|>=
name|HALFCYCLE
operator|*
literal|100
condition|)
block|{
name|twdelaycount
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|twdelaycount
operator|=
operator|(
name|twdelaycount
operator|*
name|d
operator|)
operator|/
name|HALFCYCLE
expr_stmt|;
block|}
block|}
block|}
comment|/*    * Now do a final check, just to make sure    */
name|sc
operator|.
name|sc_xphase
operator|=
name|inb
argument_list|(
name|idp
operator|->
name|id_iobase
operator|+
name|tw_zcport
argument_list|)
operator|&
name|tw_zcmask
expr_stmt|;
if|if
condition|(
name|wait_for_zero
argument_list|(
operator|&
name|sc
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|d
operator|=
name|wait_for_zero
argument_list|(
operator|&
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<=
operator|(
name|HALFCYCLE
operator|*
literal|110
operator|)
operator|/
literal|100
operator|&&
name|d
operator|>=
operator|(
name|HALFCYCLE
operator|*
literal|90
operator|)
operator|/
literal|100
condition|)
return|return
operator|(
literal|8
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|twattach
parameter_list|(
name|idp
parameter_list|)
name|struct
name|isa_device
modifier|*
name|idp
decl_stmt|;
block|{
name|struct
name|tw_sc
modifier|*
name|sc
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|sc
operator|=
operator|&
name|tw_sc
index|[
name|unit
operator|=
name|idp
operator|->
name|id_unit
index|]
expr_stmt|;
name|sc
operator|->
name|sc_port
operator|=
name|idp
operator|->
name|id_iobase
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rcount
operator|=
literal|0
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|abortrcv_ch
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|sc
operator|->
name|devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|tw_cdevsw
argument_list|,
name|unit
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"tw%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|twopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|tw_sc
modifier|*
name|sc
init|=
operator|&
name|tw_sc
index|[
name|TWUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|port
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_state
operator|=
name|TWS_OPEN
expr_stmt|;
name|sc
operator|->
name|sc_nextin
operator|=
name|sc
operator|->
name|sc_nextout
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_pktsize
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|tw_control
argument_list|,
name|TWC_ENA
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|twclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|tw_sc
modifier|*
name|sc
init|=
operator|&
name|tw_sc
index|[
name|TWUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|port
init|=
name|sc
operator|->
name|sc_port
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|sc_port
operator|+
name|tw_control
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|twread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|ioflag
decl_stmt|;
block|{
name|u_char
name|buf
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|tw_sc
modifier|*
name|sc
init|=
operator|&
name|tw_sc
index|[
name|TWUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cnt
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|cnt
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|twgetbytes
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|cnt
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|twwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|ioflag
decl_stmt|;
block|{
name|struct
name|tw_sc
modifier|*
name|sc
decl_stmt|;
name|int
name|house
decl_stmt|,
name|key
decl_stmt|,
name|reps
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|sc
operator|=
operator|&
name|tw_sc
index|[
name|TWUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
comment|/*    * Note: Although I had intended to allow concurrent transmitters,    * there is a potential problem here if two processes both write    * into the sc_pkt buffer at the same time.  The following code    * is an additional critical section that needs to be synchronized.    */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|cnt
operator|=
name|MIN
argument_list|(
literal|3
operator|-
name|sc
operator|->
name|sc_pktsize
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|uiomove
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|sc_pkt
index|[
name|sc
operator|->
name|sc_pktsize
index|]
operator|)
argument_list|,
name|cnt
argument_list|,
name|uio
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|sc_pktsize
operator|+=
name|cnt
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_pktsize
operator|<
literal|3
condition|)
block|{
comment|/* Only transmit 3-byte packets */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_pktsize
operator|=
literal|0
expr_stmt|;
comment|/*    * Collect house code, key code, and rep count, and check for sanity.    */
name|house
operator|=
name|sc
operator|->
name|sc_pkt
index|[
literal|0
index|]
expr_stmt|;
name|key
operator|=
name|sc
operator|->
name|sc_pkt
index|[
literal|1
index|]
expr_stmt|;
name|reps
operator|=
name|sc
operator|->
name|sc_pkt
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|house
operator|>=
literal|16
operator|||
name|key
operator|>=
literal|32
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/*    * Synchronize with the receiver operating in the bottom half, and    * also with concurrent transmitters.    * We don't want to interfere with a packet currently being received,    * and we would like the receiver to recognize when a packet has    * originated locally.    */
while|while
condition|(
name|sc
operator|->
name|sc_state
operator|&
operator|(
name|TWS_RCVING
operator||
name|TWS_XMITTING
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|TWPRI
operator||
name|PCATCH
argument_list|,
literal|"twwrite"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|sc_state
operator||=
name|TWS_XMITTING
expr_stmt|;
comment|/*    * Everything looks OK, let's do the transmission.    */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Enable interrupts because this takes a LONG time */
name|error
operator|=
name|twsend
argument_list|(
name|sc
argument_list|,
name|house
argument_list|,
name|key
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|TWS_XMITTING
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if there is data available for reading  */
end_comment

begin_function
name|int
name|twpoll
parameter_list|(
name|dev
parameter_list|,
name|events
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|events
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|tw_sc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|sc
operator|=
operator|&
name|tw_sc
index|[
name|TWUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* XXX is this correct?  the original code didn't test select rw mode!! */
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
if|if
condition|(
name|sc
operator|->
name|sc_nextin
operator|!=
name|sc
operator|->
name|sc_nextout
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|sc_selp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * X-10 Protocol  */
end_comment

begin_define
define|#
directive|define
name|X10_START_LENGTH
value|4
end_define

begin_decl_stmt
specifier|static
name|char
name|X10_START
index|[]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Each bit of the 4-bit house code and 5-bit key code  * is transmitted twice, once in true form, and then in  * complemented form.  This is already taken into account  * in the following tables.  */
end_comment

begin_define
define|#
directive|define
name|X10_HOUSE_LENGTH
value|8
end_define

begin_decl_stmt
specifier|static
name|char
name|X10_HOUSE
index|[
literal|16
index|]
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* A = 0110 */
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* B = 1110 */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* C = 0010 */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* D = 1010 */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* E = 0001 */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* F = 1001 */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* G = 0101 */
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* H = 1101 */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* I = 0111 */
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* J = 1111 */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* K = 0011 */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* L = 1011 */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
comment|/* M = 0000 */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
comment|/* N = 1000 */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
comment|/* O = 0100 */
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
comment|/* P = 1100 */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|X10_KEY_LENGTH
value|10
end_define

begin_decl_stmt
specifier|static
name|char
name|X10_KEY
index|[
literal|32
index|]
index|[
literal|10
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
comment|/* 01100 => 1 */
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
comment|/* 11100 => 2 */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
comment|/* 00100 => 3 */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
comment|/* 10100 => 4 */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 00010 => 5 */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 10010 => 6 */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 01010 => 7 */
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 11010 => 8 */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 01110 => 9 */
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 11110 => 10 */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 00110 => 11 */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
comment|/* 10110 => 12 */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
comment|/* 00000 => 13 */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
comment|/* 10000 => 14 */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
comment|/* 01000 => 15 */
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
comment|/* 11000 => 16 */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 00001 => All Units Off */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 00011 => All Units On */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 00101 => On */
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 00111 => Off */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 01001 => Dim */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 01011 => Bright */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 01101 => All LIGHTS Off */
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 01111 => Extended Code */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 10001 => Hail Request */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 10011 => Hail Acknowledge */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 10101 => Preset Dim 0 */
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 10111 => Preset Dim 1 */
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
comment|/* 11000 => Extended Data (analog) */
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 11011 => Status = on */
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 11101 => Status = off */
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
comment|/* 11111 => Status request */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Tables for mapping received X-10 code back to house/key number.  */
end_comment

begin_decl_stmt
specifier|static
name|short
name|X10_HOUSE_INV
index|[
literal|16
index|]
init|=
block|{
literal|12
block|,
literal|4
block|,
literal|2
block|,
literal|10
block|,
literal|14
block|,
literal|6
block|,
literal|0
block|,
literal|8
block|,
literal|13
block|,
literal|5
block|,
literal|3
block|,
literal|11
block|,
literal|15
block|,
literal|7
block|,
literal|1
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|X10_KEY_INV
index|[
literal|32
index|]
init|=
block|{
literal|12
block|,
literal|16
block|,
literal|4
block|,
literal|17
block|,
literal|2
block|,
literal|18
block|,
literal|10
block|,
literal|19
block|,
literal|14
block|,
literal|20
block|,
literal|6
block|,
literal|21
block|,
literal|0
block|,
literal|22
block|,
literal|8
block|,
literal|23
block|,
literal|13
block|,
literal|24
block|,
literal|5
block|,
literal|25
block|,
literal|3
block|,
literal|26
block|,
literal|11
block|,
literal|27
block|,
literal|15
block|,
literal|28
block|,
literal|7
block|,
literal|29
block|,
literal|1
block|,
literal|30
block|,
literal|9
block|,
literal|31
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|X10_KEY_LABEL
index|[
literal|32
index|]
init|=
block|{
literal|"1"
block|,
literal|"2"
block|,
literal|"3"
block|,
literal|"4"
block|,
literal|"5"
block|,
literal|"6"
block|,
literal|"7"
block|,
literal|"8"
block|,
literal|"9"
block|,
literal|"10"
block|,
literal|"11"
block|,
literal|"12"
block|,
literal|"13"
block|,
literal|"14"
block|,
literal|"15"
block|,
literal|"16"
block|,
literal|"All Units Off"
block|,
literal|"All Units On"
block|,
literal|"On"
block|,
literal|"Off"
block|,
literal|"Dim"
block|,
literal|"Bright"
block|,
literal|"All LIGHTS Off"
block|,
literal|"Extended Code"
block|,
literal|"Hail Request"
block|,
literal|"Hail Acknowledge"
block|,
literal|"Preset Dim 0"
block|,
literal|"Preset Dim 1"
block|,
literal|"Extended Data (analog)"
block|,
literal|"Status = on"
block|,
literal|"Status = off"
block|,
literal|"Status request"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Transmit a packet containing house code h and key code k  */
end_comment

begin_define
define|#
directive|define
name|TWRETRY
value|10
end_define

begin_comment
comment|/* Try 10 times to sync with AC line */
end_comment

begin_function
specifier|static
name|int
name|twsend
parameter_list|(
name|sc
parameter_list|,
name|h
parameter_list|,
name|k
parameter_list|,
name|cnt
parameter_list|)
name|struct
name|tw_sc
modifier|*
name|sc
decl_stmt|;
name|int
name|h
decl_stmt|,
name|k
decl_stmt|,
name|cnt
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|port
init|=
name|sc
operator|->
name|sc_port
decl_stmt|;
comment|/*    * Make sure we get a reliable sync with a power line zero crossing    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TWRETRY
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wait_for_zero
argument_list|(
name|sc
argument_list|)
operator|>
literal|100
condition|)
goto|goto
name|insync
goto|;
block|}
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TWXMIT: failed to sync.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|insync
label|:
comment|/*    * Be sure to leave 3 cycles space between transmissions    */
for|for
control|(
name|i
operator|=
literal|6
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|next_zero
argument_list|(
name|sc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*    * The packet is transmitted cnt times, with no gaps.    */
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
comment|/*      * Transmit the start code      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|X10_START_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|port
operator|+
name|tw_data
argument_list|,
name|X10_START
index|[
name|i
index|]
condition|?
literal|0xff
else|:
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Waste no time! */
ifdef|#
directive|ifdef
name|HIRESTIME
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|twsetuptimes
argument_list|(
name|sc
operator|->
name|sc_xtimes
argument_list|)
expr_stmt|;
if|if
condition|(
name|twchecktime
argument_list|(
name|sc
operator|->
name|sc_xtimes
index|[
name|i
index|]
argument_list|,
name|HALFCYCLE
operator|/
literal|20
argument_list|)
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
name|port
operator|+
name|tw_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HIRESTIME */
name|twdelayn
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 1ms pulse width */
name|outb
argument_list|(
name|port
operator|+
name|tw_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_zero
argument_list|(
name|sc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*      * Transmit the house code      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|X10_HOUSE_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|port
operator|+
name|tw_data
argument_list|,
name|X10_HOUSE
index|[
name|h
index|]
index|[
name|i
index|]
condition|?
literal|0xff
else|:
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Waste no time! */
ifdef|#
directive|ifdef
name|HIRESTIME
if|if
condition|(
name|twchecktime
argument_list|(
name|sc
operator|->
name|sc_xtimes
index|[
name|i
operator|+
name|X10_START_LENGTH
index|]
argument_list|,
name|HALFCYCLE
operator|/
literal|20
argument_list|)
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
name|port
operator|+
name|tw_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HIRESTIME */
name|twdelayn
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 1ms pulse width */
name|outb
argument_list|(
name|port
operator|+
name|tw_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_zero
argument_list|(
name|sc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*      * Transmit the unit/key code      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|X10_KEY_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|port
operator|+
name|tw_data
argument_list|,
name|X10_KEY
index|[
name|k
index|]
index|[
name|i
index|]
condition|?
literal|0xff
else|:
literal|0x00
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HIRESTIME
if|if
condition|(
name|twchecktime
argument_list|(
name|sc
operator|->
name|sc_xtimes
index|[
name|i
operator|+
name|X10_START_LENGTH
operator|+
name|X10_HOUSE_LENGTH
index|]
argument_list|,
name|HALFCYCLE
operator|/
literal|20
argument_list|)
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
name|port
operator|+
name|tw_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HIRESTIME */
name|twdelayn
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 1ms pulse width */
name|outb
argument_list|(
name|port
operator|+
name|tw_data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_zero
argument_list|(
name|sc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Waste CPU cycles to get in sync with a power line zero crossing.  * The value returned is roughly how many microseconds we wasted before  * seeing the transition.  To avoid wasting time forever, we give up after  * waiting patiently for 1/4 sec (15 power line cycles at 60 Hz),  * which is more than the 11 cycles it takes to transmit a full  * X-10 packet.  */
end_comment

begin_function
specifier|static
name|int
name|wait_for_zero
parameter_list|(
name|sc
parameter_list|)
name|struct
name|tw_sc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|old
decl_stmt|,
name|new
decl_stmt|,
name|max
decl_stmt|;
name|int
name|port
init|=
name|sc
operator|->
name|sc_port
operator|+
name|tw_zcport
decl_stmt|;
name|old
operator|=
name|sc
operator|->
name|sc_xphase
expr_stmt|;
name|max
operator|=
literal|10000
expr_stmt|;
comment|/* 10000 * 25us = 0.25 sec */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|max
operator|--
condition|)
block|{
name|new
operator|=
name|inb
argument_list|(
name|port
argument_list|)
operator|&
name|tw_zcmask
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|old
condition|)
block|{
name|sc
operator|->
name|sc_xphase
operator|=
name|new
expr_stmt|;
return|return
operator|(
name|i
operator|*
literal|25
operator|)
return|;
block|}
name|i
operator|++
expr_stmt|;
name|twdelay25
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for the next zero crossing transition, and if we don't have  * high-resolution time-of-day, check to see that the zero crossing  * appears to be arriving on schedule.  * We expect to be waiting almost a full half-cycle (8.333ms-1ms = 7.333ms).  * If we don't seem to wait very long, something is wrong (like we got  * preempted!) and we should abort the transmission because  * there's no telling how long it's really been since the  * last bit was transmitted.  */
end_comment

begin_function
specifier|static
name|int
name|next_zero
parameter_list|(
name|sc
parameter_list|)
name|struct
name|tw_sc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|d
decl_stmt|;
ifdef|#
directive|ifdef
name|HIRESTIME
if|if
condition|(
operator|(
name|d
operator|=
name|wait_for_zero
argument_list|(
name|sc
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|d
operator|=
name|wait_for_zero
argument_list|(
name|sc
argument_list|)
operator|)
operator|<
literal|6000
operator|||
name|d
operator|>
literal|8500
condition|)
block|{
comment|/* No less than 6.0ms, no more than 8.5ms */
endif|#
directive|endif
comment|/* HIRESTIME */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TWXMIT framing error: %d\n"
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Put a three-byte packet into the circular buffer  * Should be called at priority spltty()  */
specifier|static
name|int
name|twputpkt
parameter_list|(
name|sc
parameter_list|,
name|p
parameter_list|)
name|struct
name|tw_sc
modifier|*
name|sc
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|next
operator|=
name|sc
operator|->
name|sc_nextin
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|next
operator|>=
name|TW_SIZE
condition|)
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|sc
operator|->
name|sc_nextout
condition|)
block|{
comment|/* Buffer full */
comment|/*       log(LOG_ERR, "TWRCV: Buffer overrun\n");  */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sc
operator|->
name|sc_buf
index|[
name|sc
operator|->
name|sc_nextin
index|]
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_nextin
operator|=
name|next
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|&
name|TWS_WANT
condition|)
block|{
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|TWS_WANT
expr_stmt|;
name|wakeup
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
operator|&
name|sc
operator|->
name|sc_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_selp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Get bytes from the circular buffer  * Should be called at priority spltty()  */
specifier|static
name|int
name|twgetbytes
parameter_list|(
name|sc
parameter_list|,
name|p
parameter_list|,
name|cnt
parameter_list|)
name|struct
name|tw_sc
modifier|*
name|sc
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
while|while
condition|(
name|sc
operator|->
name|sc_nextin
operator|==
name|sc
operator|->
name|sc_nextout
condition|)
block|{
comment|/* Buffer empty */
name|sc
operator|->
name|sc_state
operator||=
name|TWS_WANT
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|tsleep
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
operator|&
name|sc
operator|->
name|sc_buf
argument_list|)
argument_list|,
name|TWPRI
operator||
name|PCATCH
argument_list|,
literal|"twread"
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
operator|*
name|p
operator|++
operator|=
name|sc
operator|->
name|sc_buf
index|[
name|sc
operator|->
name|sc_nextout
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_nextout
operator|>=
name|TW_SIZE
condition|)
name|sc
operator|->
name|sc_nextout
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Abort reception that has failed to complete in the required time.  */
specifier|static
name|void
name|twabortrcv
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|tw_sc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_char
name|pkt
index|[
literal|3
index|]
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|TWS_RCVING
expr_stmt|;
comment|/* simply ignore single isolated interrupts. */
if|if
condition|(
name|sc
operator|->
name|sc_no_rcv
operator|>
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|TW_RCV_ERROR
expr_stmt|;
name|pkt
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_flags
expr_stmt|;
name|pkt
index|[
literal|1
index|]
operator|=
name|pkt
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|twputpkt
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TWRCV: aborting (%x, %d)\n"
argument_list|,
name|sc
operator|->
name|sc_bits
argument_list|,
name|sc
operator|->
name|sc_rcount
argument_list|)
expr_stmt|;
name|twdebugtimes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|tw_is_within
parameter_list|(
name|int
name|value
parameter_list|,
name|int
name|expected
parameter_list|,
name|int
name|tolerance
parameter_list|)
block|{
name|int
name|diff
decl_stmt|;
name|diff
operator|=
name|value
operator|-
name|expected
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|*=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|tolerance
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
comment|/*  * This routine handles interrupts that occur when there is a falling  * transition on the RX input.  There isn't going to be a transition  * on every bit (some are zero), but if we are smart and keep track of  * how long it's been since the last interrupt (via the zero crossing  * detect line and/or high-resolution time-of-day routine), we can  * reconstruct the transmission without having to poll.  */
name|void
name|twintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|tw_sc
modifier|*
name|sc
init|=
operator|&
name|tw_sc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|newphase
decl_stmt|;
name|u_char
name|pkt
index|[
literal|3
index|]
decl_stmt|;
name|int
name|delay
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|port
operator|=
name|sc
operator|->
name|sc_port
expr_stmt|;
comment|/*    * Ignore any interrupts that occur if the device is not open.    */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
literal|0
condition|)
return|return;
name|newphase
operator|=
name|inb
argument_list|(
name|port
operator|+
name|tw_zcport
argument_list|)
operator|&
name|tw_zcmask
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
comment|/*    * NEW PACKET:    * If we aren't currently receiving a packet, set up a new packet    * and put in the first "1" bit that has just arrived.    * Arrange for the reception to be aborted if too much time goes by.    */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_state
operator|&
name|TWS_RCVING
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HIRESTIME
name|twsetuptimes
argument_list|(
name|sc
operator|->
name|sc_rtimes
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HIRESTIME */
name|sc
operator|->
name|sc_state
operator||=
name|TWS_RCVING
expr_stmt|;
name|sc
operator|->
name|sc_rcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|&
name|TWS_XMITTING
condition|)
name|sc
operator|->
name|sc_flags
operator|=
name|TW_RCV_LOCAL
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_bits
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_rphase
operator|=
name|newphase
expr_stmt|;
comment|/* 3 cycles of silence = 3/60 = 1/20 = 50 msec */
name|sc
operator|->
name|abortrcv_ch
operator|=
name|timeout
argument_list|(
name|twabortrcv
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rcv_time
index|[
literal|0
index|]
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
name|sc
operator|->
name|sc_no_rcv
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|untimeout
argument_list|(
name|twabortrcv
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|sc
operator|->
name|abortrcv_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|abortrcv_ch
operator|=
name|timeout
argument_list|(
name|twabortrcv
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|hz
operator|/
literal|20
argument_list|)
expr_stmt|;
name|newphase
operator|=
name|inb
argument_list|(
name|port
operator|+
name|tw_zcport
argument_list|)
operator|&
name|tw_zcmask
expr_stmt|;
comment|/* enforce a minimum delay since the last interrupt */
name|delay
operator|=
name|tv
operator|.
name|tv_usec
operator|-
name|sc
operator|->
name|sc_rcv_time
index|[
name|sc
operator|->
name|sc_no_rcv
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|delay
operator|<
literal|0
condition|)
name|delay
operator|+=
literal|1000000
expr_stmt|;
if|if
condition|(
name|delay
operator|<
name|TW_MIN_DELAY
condition|)
return|return;
name|sc
operator|->
name|sc_rcv_time
index|[
name|sc
operator|->
name|sc_no_rcv
index|]
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rcv_time
index|[
name|sc
operator|->
name|sc_no_rcv
index|]
operator|<
name|sc
operator|->
name|sc_rcv_time
index|[
literal|0
index|]
condition|)
name|sc
operator|->
name|sc_rcv_time
index|[
name|sc
operator|->
name|sc_no_rcv
index|]
operator|+=
literal|1000000
expr_stmt|;
name|sc
operator|->
name|sc_no_rcv
operator|++
expr_stmt|;
comment|/*    * START CODE:    * The second and third bits are a special case.    */
if|if
condition|(
name|sc
operator|->
name|sc_rcount
operator|<
literal|3
condition|)
block|{
if|if
condition|(
ifdef|#
directive|ifdef
name|HIRESTIME
name|tw_is_within
argument_list|(
argument|delay
argument_list|,
argument|HALFCYCLE
argument_list|,
argument|HALFCYCLE /
literal|6
argument_list|)
else|#
directive|else
name|newphase
operator|!=
name|sc
operator|->
name|sc_rphase
endif|#
directive|endif
condition|)
block|{
name|sc
operator|->
name|sc_rcount
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/*        * Invalid start code -- abort reception.        */
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|TWS_RCVING
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|TW_RCV_ERROR
expr_stmt|;
name|untimeout
argument_list|(
name|twabortrcv
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|sc
operator|->
name|abortrcv_ch
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TWRCV: Invalid start code\n"
argument_list|)
expr_stmt|;
name|twdebugtimes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_no_rcv
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rcount
operator|==
literal|3
condition|)
block|{
comment|/*        * We've gotten three "1" bits in a row.  The start code        * is really 1110, but this might be followed by a zero        * bit from the house code, so if we wait any longer we        * might be confused about the first house code bit.        * So, we guess that the start code is correct and insert        * the trailing zero without actually having seen it.        * We don't change sc_rphase in this case, because two        * bit arrivals in a row preserve parity.        */
name|sc
operator|->
name|sc_rcount
operator|++
expr_stmt|;
return|return;
block|}
comment|/*      * Update sc_rphase to the current phase before returning.      */
name|sc
operator|->
name|sc_rphase
operator|=
name|newphase
expr_stmt|;
return|return;
block|}
comment|/*    * GENERAL CASE:    * Now figure out what the current bit is that just arrived.    * The X-10 protocol transmits each data bit twice: once in    * true form and once in complemented form on the next half    * cycle.  So, there will be at least one interrupt per bit.    * By comparing the phase we see at the time of the interrupt    * with the saved sc_rphase, we can tell on which half cycle    * the interrupt occrred.  This assumes, of course, that the    * packet is well-formed.  We do the best we can at trying to    * catch errors by aborting if too much time has gone by, and    * by tossing out a packet if too many bits arrive, but the    * whole scheme is probably not as robust as if we had a nice    * interrupt on every half cycle of the power line.    * If we have high-resolution time-of-day routines, then we    * can do a bit more sanity checking.    */
comment|/*    * A complete packet is 22 half cycles.    */
if|if
condition|(
name|sc
operator|->
name|sc_rcount
operator|<=
literal|20
condition|)
block|{
ifdef|#
directive|ifdef
name|HIRESTIME
name|int
name|bit
init|=
literal|0
decl_stmt|,
name|last_bit
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rcount
operator|==
literal|4
condition|)
name|last_bit
operator|=
literal|1
expr_stmt|;
comment|/* Start (1110) ends in 10, a 'one' code. */
else|else
name|last_bit
operator|=
name|sc
operator|->
name|sc_bits
operator|&
literal|0x1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|last_bit
operator|==
literal|1
operator|)
operator|&&
operator|(
name|tw_is_within
argument_list|(
name|delay
argument_list|,
name|HALFCYCLE
operator|*
literal|2
argument_list|,
name|HALFCYCLE
operator|/
literal|6
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|last_bit
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tw_is_within
argument_list|(
name|delay
argument_list|,
name|HALFCYCLE
operator|*
literal|1
argument_list|,
name|HALFCYCLE
operator|/
literal|6
argument_list|)
operator|)
operator|)
condition|)
name|bit
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|last_bit
operator|==
literal|1
operator|)
operator|&&
operator|(
name|tw_is_within
argument_list|(
name|delay
argument_list|,
name|HALFCYCLE
operator|*
literal|3
argument_list|,
name|HALFCYCLE
operator|/
literal|6
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|last_bit
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tw_is_within
argument_list|(
name|delay
argument_list|,
name|HALFCYCLE
operator|*
literal|2
argument_list|,
name|HALFCYCLE
operator|/
literal|6
argument_list|)
operator|)
operator|)
condition|)
name|bit
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|TW_RCV_ERROR
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TWRCV: %d cycle after %d bit, delay %d%%\n"
argument_list|,
name|sc
operator|->
name|sc_rcount
argument_list|,
name|last_bit
argument_list|,
literal|100
operator|*
name|delay
operator|/
name|HALFCYCLE
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_bits
operator|=
operator|(
name|sc
operator|->
name|sc_bits
operator|<<
literal|1
operator|)
operator||
name|bit
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|sc_bits
operator|=
operator|(
name|sc
operator|->
name|sc_bits
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|newphase
operator|==
name|sc
operator|->
name|sc_rphase
operator|)
condition|?
literal|0x0
else|:
literal|0x1
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* HIRESTIME */
name|sc
operator|->
name|sc_rcount
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rcount
operator|>=
literal|22
operator|||
name|sc
operator|->
name|sc_flags
operator|&
name|TW_RCV_ERROR
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rcount
operator|!=
literal|22
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|TW_RCV_ERROR
expr_stmt|;
name|pkt
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_flags
expr_stmt|;
name|pkt
index|[
literal|1
index|]
operator|=
name|pkt
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pkt
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_flags
expr_stmt|;
name|pkt
index|[
literal|1
index|]
operator|=
name|X10_HOUSE_INV
index|[
operator|(
name|sc
operator|->
name|sc_bits
operator|&
literal|0x1e0
operator|)
operator|>>
literal|5
index|]
expr_stmt|;
name|pkt
index|[
literal|2
index|]
operator|=
name|X10_KEY_INV
index|[
name|sc
operator|->
name|sc_bits
operator|&
literal|0x1f
index|]
expr_stmt|;
block|}
name|sc
operator|->
name|sc_state
operator|&=
operator|~
name|TWS_RCVING
expr_stmt|;
name|twputpkt
argument_list|(
name|sc
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|twabortrcv
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|sc
operator|->
name|abortrcv_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|TW_RCV_ERROR
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TWRCV: invalid packet: (%d, %x) %c %s\n"
argument_list|,
name|sc
operator|->
name|sc_rcount
argument_list|,
name|sc
operator|->
name|sc_bits
argument_list|,
literal|'A'
operator|+
name|pkt
index|[
literal|1
index|]
argument_list|,
name|X10_KEY_LABEL
index|[
name|pkt
index|[
literal|2
index|]
index|]
argument_list|)
expr_stmt|;
name|twdebugtimes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*      log(LOG_ERR, "TWRCV: valid packet: (%d, %x) %c %s\n", 	  sc->sc_rcount, sc->sc_bits, 'A' + pkt[1], X10_KEY_LABEL[pkt[2]]); */
block|}
name|sc
operator|->
name|sc_rcount
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|twdebugtimes
parameter_list|(
name|struct
name|tw_sc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|sc
operator|->
name|sc_no_rcv
operator|)
operator|&&
operator|(
name|i
operator|<
name|SC_RCV_TIME_LEN
operator|)
condition|;
name|i
operator|++
control|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"TWRCV: interrupt %2d: %d\t%d%%\n"
argument_list|,
name|i
argument_list|,
name|sc
operator|->
name|sc_rcv_time
index|[
name|i
index|]
argument_list|,
operator|(
name|sc
operator|->
name|sc_rcv_time
index|[
name|i
index|]
operator|-
name|sc
operator|->
name|sc_rcv_time
index|[
operator|(
name|i
condition|?
name|i
operator|-
literal|1
else|:
literal|0
operator|)
index|]
operator|)
operator|*
literal|100
operator|/
name|HALFCYCLE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HIRESTIME
comment|/*  * Initialize an array of 22 times, starting from the current  * microtime and continuing for the next 21 half cycles.  * We use the times as a reference to make sure transmission  * or reception is on schedule.  */
specifier|static
name|void
name|twsetuptimes
parameter_list|(
name|int
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|t
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|t
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|22
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|a
operator|++
operator|=
name|t
expr_stmt|;
name|t
operator|+=
name|HALFCYCLE
expr_stmt|;
if|if
condition|(
name|t
operator|>=
literal|1000000
condition|)
name|t
operator|-=
literal|1000000
expr_stmt|;
block|}
block|}
comment|/*  * Check the current time against a slot in a previously set up  * timing array, and make sure that it looks like we are still  * on schedule.  */
specifier|static
name|int
name|twchecktime
parameter_list|(
name|int
name|target
parameter_list|,
name|int
name|tol
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|t
decl_stmt|,
name|d
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|t
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
name|d
operator|=
operator|(
name|target
operator|-
name|t
operator|)
operator|>=
literal|0
condition|?
operator|(
name|target
operator|-
name|t
operator|)
else|:
operator|(
name|t
operator|-
name|target
operator|)
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|500000
condition|)
name|d
operator|=
literal|1000000
operator|-
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|<=
name|tol
operator|&&
name|d
operator|>=
operator|-
name|tol
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* HIRESTIME */
specifier|static
name|tw_devsw_installed
operator|=
literal|0
expr_stmt|;
specifier|static
name|void
name|tw_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|tw_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|tw_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tw_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|SYSINIT
argument_list|(
argument|twdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|tw_drvinit
argument_list|,
argument|NULL
argument_list|)
end_function

begin_endif
endif|#
directive|endif
endif|NTW
end_endif

end_unit

