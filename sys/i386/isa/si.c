begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Device driver for Specialix range (SI/XIO) of serial line multiplexors.  *  * Copyright (C) 1990, 1992 Specialix International,  * Copyright (C) 1993, Andy Rutter<andy@acronym.co.uk>  * Copyright (C) 1995, Peter Wemm<peter@haywire.dialix.com>  *  * Originally derived from:	SunOS 4.x version  * Ported from BSDI version to FreeBSD by Peter Wemm.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notices, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notices, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Andy Rutter of  *	Advanced Methods and Tools Ltd. based on original information  *	from Specialix International.  * 4. Neither the name of Advanced Methods and Tools, nor Specialix  *    International may be used to endorse or promote products derived from  *    this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN  * NO EVENT SHALL THE AUTHORS BE LIABLE.  *  *	$Id: si.c,v 1.65 1998/01/31 07:23:09 eivind Exp $  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|si_copyright1
index|[]
init|=
literal|"@(#) (C) Specialix International, 1990,1992"
decl_stmt|,
name|si_copyright2
index|[]
init|=
literal|"@(#) (C) Andy Rutter 1993"
decl_stmt|,
name|si_copyright3
index|[]
init|=
literal|"@(#) (C) Peter Wemm 1995"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_debug_si.h"
end_include

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/ioctl_compat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/sireg.h>
end_include

begin_include
include|#
directive|include
file|<machine/si.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|"si.h"
end_include

begin_comment
comment|/*  * This device driver is designed to interface the Specialix International  * range of serial multiplexor cards (SI/XIO) to BSDI/386 on an ISA bus machine.  *  * The controller is interfaced to the host via dual port ram  * and a (programmable - SIHOST2) interrupt at IRQ 11,12 or 15.  */
end_comment

begin_define
define|#
directive|define
name|POLL
end_define

begin_comment
comment|/* turn on poller to scan for lost interrupts */
end_comment

begin_define
define|#
directive|define
name|REALPOLL
end_define

begin_comment
comment|/* on each poll, scan for work regardless */
end_comment

begin_define
define|#
directive|define
name|POLLHZ
value|(hz/10)
end_define

begin_comment
comment|/* 10 times per second */
end_comment

begin_define
define|#
directive|define
name|SI_DEF_HWFLOW
end_define

begin_comment
comment|/* turn on default CRTSCTS flow control */
end_comment

begin_define
define|#
directive|define
name|SI_I_HIGH_WATER
value|(TTYHOG - 2 * SI_BUFFERSIZE)
end_define

begin_define
define|#
directive|define
name|INT_COUNT
value|25000
end_define

begin_comment
comment|/* max of 125 ints per second */
end_comment

begin_define
define|#
directive|define
name|RXINT_COUNT
value|1
end_define

begin_comment
comment|/* one rxint per 10 milliseconds */
end_comment

begin_enum
enum|enum
name|si_mctl
block|{
name|GET
block|,
name|SET
block|,
name|BIS
block|,
name|BIC
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|void
name|si_command
name|__P
argument_list|(
operator|(
expr|struct
name|si_port
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|si_modem
name|__P
argument_list|(
operator|(
expr|struct
name|si_port
operator|*
operator|,
expr|enum
name|si_mctl
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|si_write_enable
name|__P
argument_list|(
operator|(
expr|struct
name|si_port
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|si_Sioctl
name|__P
argument_list|(
operator|(
name|dev_t
operator|,
name|int
operator|,
name|caddr_t
operator|,
name|int
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|si_start
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|si_lstart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|si_disc_optim
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|termios
operator|*
name|t
operator|,
expr|struct
name|si_port
operator|*
name|pp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sihardclose
name|__P
argument_list|(
operator|(
expr|struct
name|si_port
operator|*
name|pp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sidtrwakeup
name|__P
argument_list|(
operator|(
name|void
operator|*
name|chan
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|siparam
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|,
expr|struct
name|termios
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|siprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|id
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|siattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|id
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|si_modem_state
name|__P
argument_list|(
operator|(
expr|struct
name|si_port
operator|*
name|pp
operator|,
expr|struct
name|tty
operator|*
name|tp
operator|,
name|int
name|hi_ip
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|sidriver
init|=
block|{
name|siprobe
block|,
name|siattach
block|,
literal|"si"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|siopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|siclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|siread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|siwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|siioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_stop_t
name|sistop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_devtotty_t
name|sidevtotty
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|68
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|si_cdevsw
init|=
block|{
name|siopen
block|,
name|siclose
block|,
name|siread
block|,
name|siwrite
block|,
comment|/*68*/
name|siioctl
block|,
name|sistop
block|,
name|noreset
block|,
name|sidevtotty
block|,
comment|/* si */
name|ttpoll
block|,
name|nommap
block|,
name|NULL
block|,
literal|"si"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SI_DEBUG
end_ifdef

begin_comment
comment|/* use: ``options "SI_DEBUG"'' in your config file */
end_comment

begin_decl_stmt
specifier|static
name|void
name|si_dprintf
name|__P
argument_list|(
operator|(
expr|struct
name|si_port
operator|*
name|pp
operator|,
name|int
name|flags
operator|,
specifier|const
name|char
operator|*
name|fmt
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|si_mctl2str
name|__P
argument_list|(
operator|(
expr|enum
name|si_mctl
name|cmd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DPRINT
parameter_list|(
name|x
parameter_list|)
value|si_dprintf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINT
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|/* void */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|si_Nports
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|si_Nmodules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|si_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data, not bss, so it's patchable */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tty
modifier|*
name|si_tty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where the firmware lives; defined in si_code.c */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|si_dsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|char
name|si_download
index|[]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|si_softc
block|{
name|int
name|sc_type
decl_stmt|;
comment|/* adapter type */
name|char
modifier|*
name|sc_typename
decl_stmt|;
comment|/* adapter type string */
name|struct
name|si_port
modifier|*
name|sc_ports
decl_stmt|;
comment|/* port structures for this card */
name|caddr_t
name|sc_paddr
decl_stmt|;
comment|/* physical addr of iomem */
name|caddr_t
name|sc_maddr
decl_stmt|;
comment|/* kvaddr of iomem */
name|int
name|sc_nport
decl_stmt|;
comment|/* # ports on this card */
name|int
name|sc_irq
decl_stmt|;
comment|/* copy of attach irq */
name|int
name|sc_eisa_iobase
decl_stmt|;
comment|/* EISA io port address */
name|int
name|sc_eisa_irqbits
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
struct|struct
block|{
name|void
modifier|*
name|ttyd
decl_stmt|;
name|void
modifier|*
name|cuaa
decl_stmt|;
name|void
modifier|*
name|ttyl
decl_stmt|;
name|void
modifier|*
name|ttyi
decl_stmt|;
block|}
name|devfs_token
index|[
literal|32
index|]
struct|;
comment|/* what is the max per card? */
name|void
modifier|*
name|control_token
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|si_softc
name|si_softc
index|[
name|NSI
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* up to 4 elements */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|B2000
end_ifndef

begin_comment
comment|/* not standard, but the hardware knows it. */
end_comment

begin_define
define|#
directive|define
name|B2000
value|2000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|speedtab
name|bdrates
index|[]
init|=
block|{
name|B75
block|,
name|CLK75
block|,
comment|/* 0x0 */
name|B110
block|,
name|CLK110
block|,
comment|/* 0x1 */
name|B150
block|,
name|CLK150
block|,
comment|/* 0x3 */
name|B300
block|,
name|CLK300
block|,
comment|/* 0x4 */
name|B600
block|,
name|CLK600
block|,
comment|/* 0x5 */
name|B1200
block|,
name|CLK1200
block|,
comment|/* 0x6 */
name|B2000
block|,
name|CLK2000
block|,
comment|/* 0x7 */
name|B2400
block|,
name|CLK2400
block|,
comment|/* 0x8 */
name|B4800
block|,
name|CLK4800
block|,
comment|/* 0x9 */
name|B9600
block|,
name|CLK9600
block|,
comment|/* 0xb */
name|B19200
block|,
name|CLK19200
block|,
comment|/* 0xc */
name|B38400
block|,
name|CLK38400
block|,
comment|/* 0x2 (out of order!) */
name|B57600
block|,
name|CLK57600
block|,
comment|/* 0xd */
name|B115200
block|,
name|CLK110
block|,
comment|/* 0x1 (dupe!, 110 baud on "si") */
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* populated with approx character/sec rates - translated at card  * initialisation time to chars per tick of the clock */
end_comment

begin_decl_stmt
specifier|static
name|int
name|done_chartimes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|speedtab
name|chartimes
index|[]
init|=
block|{
name|B75
block|,
literal|8
block|,
name|B110
block|,
literal|11
block|,
name|B150
block|,
literal|15
block|,
name|B300
block|,
literal|30
block|,
name|B600
block|,
literal|60
block|,
name|B1200
block|,
literal|120
block|,
name|B2000
block|,
literal|200
block|,
name|B2400
block|,
literal|240
block|,
name|B4800
block|,
literal|480
block|,
name|B9600
block|,
literal|960
block|,
name|B19200
block|,
literal|1920
block|,
name|B38400
block|,
literal|3840
block|,
name|B57600
block|,
literal|5760
block|,
name|B115200
block|,
literal|11520
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|in_intr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Inside interrupt handler? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|si_default_rate
init|=
name|TTYDEF_SPEED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|si_default_iflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|si_default_oflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|si_default_lflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SI_DEF_HWFLOW
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|si_default_cflag
init|=
name|TTYDEF_CFLAG
operator||
name|CRTSCTS
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|si_default_cflag
init|=
name|TTYDEF_CFLAG
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|POLL
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|si_pollrate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in addition to irq */
end_comment

begin_decl_stmt
specifier|static
name|int
name|si_realpoll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* poll HW on timer */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|si_pollrate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|si_pollrate
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|si_realpoll
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|si_realpoll
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|init_finished
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|si_poll
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Array of adapter types and the corresponding RAM size. The order of  * entries here MUST match the ordinal of the adapter type.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|si_type
index|[]
init|=
block|{
literal|"EMPTY"
block|,
literal|"SIHOST"
block|,
literal|"SI2"
block|,
comment|/* MCA */
literal|"SIHOST2"
block|,
literal|"SIEISA"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look for a valid board at the given mem addr */
end_comment

begin_function
specifier|static
name|int
name|siprobe
parameter_list|(
name|id
parameter_list|)
name|struct
name|isa_device
modifier|*
name|id
decl_stmt|;
block|{
name|struct
name|si_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|type
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|ramsize
decl_stmt|;
specifier|volatile
name|BYTE
name|was
decl_stmt|,
modifier|*
name|ux
decl_stmt|;
specifier|volatile
name|unsigned
name|char
modifier|*
name|maddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|paddr
decl_stmt|;
name|si_pollrate
operator|=
name|POLLHZ
expr_stmt|;
comment|/* default 10 per second */
ifdef|#
directive|ifdef
name|REALPOLL
name|si_realpoll
operator|=
literal|1
expr_stmt|;
comment|/* scan always */
endif|#
directive|endif
name|maddr
operator|=
name|id
operator|->
name|id_maddr
expr_stmt|;
comment|/* virtual address... */
name|paddr
operator|=
operator|(
name|caddr_t
operator|)
name|vtophys
argument_list|(
name|id
operator|->
name|id_maddr
argument_list|)
expr_stmt|;
comment|/* physical address... */
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator|,
literal|"si%d: probe at virtual=0x%x physical=0x%x\n"
operator|,
name|id
operator|->
name|id_unit
operator|,
name|id
operator|->
name|id_maddr
operator|,
name|paddr
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * this is a lie, but it's easier than trying to handle caching 	 * and ram conflicts in the>1M and<16M region. 	 */
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|paddr
operator|<
operator|(
name|caddr_t
operator|)
name|IOM_BEGIN
operator|||
operator|(
name|caddr_t
operator|)
name|paddr
operator|>=
operator|(
name|caddr_t
operator|)
name|IOM_END
condition|)
block|{
name|printf
argument_list|(
literal|"si%d: iomem (%lx) out of range\n"
argument_list|,
name|id
operator|->
name|id_unit
argument_list|,
operator|(
name|long
operator|)
name|paddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|id
operator|->
name|id_unit
operator|>=
name|NSI
condition|)
block|{
comment|/* THIS IS IMPOSSIBLE */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|u_int
operator|)
name|paddr
operator|&
literal|0x7fff
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator||
name|DBG_FAIL
operator|,
literal|"si%d: iomem (%x) not on 32k boundary\n"
operator|,
name|id
operator|->
name|id_unit
operator|,
name|paddr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sc
operator|=
operator|&
name|si_softc
index|[
name|i
index|]
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_paddr
operator|==
operator|(
name|caddr_t
operator|)
name|paddr
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator||
name|DBG_FAIL
operator|,
literal|"si%d: iomem (%x) already configured to si%d\n"
operator|,
name|id
operator|->
name|id_unit
operator|,
name|sc
operator|->
name|sc_paddr
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|#
directive|if
name|NEISA
operator|>
literal|0
if|if
condition|(
name|id
operator|->
name|id_iobase
operator|>
literal|0x0fff
condition|)
block|{
comment|/* EISA card */
name|int
name|irq
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|long
name|base
decl_stmt|;
name|int
name|eisa_irqs
index|[]
init|=
block|{
literal|0
block|,
name|IRQ1
block|,
name|IRQ2
block|,
name|IRQ3
block|,
name|IRQ4
block|,
name|IRQ5
block|,
name|IRQ6
block|,
name|IRQ7
block|,
name|IRQ8
block|,
name|IRQ9
block|,
name|IRQ10
block|,
name|IRQ11
block|,
name|IRQ12
block|,
name|IRQ13
block|,
name|IRQ14
block|,
name|IRQ15
block|}
decl_stmt|;
name|port
operator|=
name|id
operator|->
name|id_iobase
expr_stmt|;
name|base
operator|=
operator|(
name|inb
argument_list|(
name|port
operator|+
literal|1
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|inb
argument_list|(
name|port
argument_list|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|irq
operator|=
operator|(
operator|(
name|inb
argument_list|(
name|port
operator|+
literal|2
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
name|id
operator|->
name|id_irq
operator|=
name|eisa_irqs
index|[
name|irq
index|]
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator|,
literal|"si%d: EISA base %x, irq %x, id_irq %x, port %x\n"
operator|,
name|id
operator|->
name|id_unit
operator|,
name|base
operator|,
name|irq
operator|,
name|id
operator|->
name|id_irq
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|->
name|id_irq
operator|&
operator|(
name|IRQ1
operator||
name|IRQ2
operator||
name|IRQ8
operator||
name|IRQ13
operator|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bad_irq
goto|;
name|id
operator|->
name|id_iobase
operator|&=
literal|0xf000
expr_stmt|;
name|id
operator|->
name|id_iosize
operator|=
literal|0x0fff
expr_stmt|;
name|type
operator|=
name|EISA
expr_stmt|;
name|outb
argument_list|(
name|p
operator|+
literal|2
argument_list|,
operator|(
name|BYTE
operator|)
name|irq
operator|<<
literal|4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_eisa_iobase
operator|=
name|p
expr_stmt|;
name|sc
operator|->
name|sc_eisa_irqbits
operator|=
name|irq
operator|<<
literal|4
expr_stmt|;
name|ramsize
operator|=
name|SIEISA_RAMSIZE
expr_stmt|;
goto|goto
name|got_card
goto|;
block|}
endif|#
directive|endif
comment|/* Is there anything out there? (0x17 is just an arbitrary number) */
operator|*
name|maddr
operator|=
literal|0x17
expr_stmt|;
if|if
condition|(
operator|*
name|maddr
operator|!=
literal|0x17
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator||
name|DBG_FAIL
operator|,
literal|"si%d: 0x17 check fail at phys 0x%x\n"
operator|,
name|id
operator|->
name|id_unit
operator|,
name|paddr
operator|)
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * OK, now to see if whatever responded is really an SI card. 	 * Try for a MK II first (SIHOST2) 	 */
for|for
control|(
name|i
operator|=
name|SIPLSIG
init|;
name|i
operator|<
name|SIPLSIG
operator|+
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|*
operator|(
name|maddr
operator|+
name|i
operator|)
operator|&
literal|7
operator|)
operator|!=
operator|(
operator|~
operator|(
name|BYTE
operator|)
name|i
operator|&
literal|7
operator|)
condition|)
goto|goto
name|try_mk1
goto|;
comment|/* It must be an SIHOST2 */
operator|*
operator|(
name|maddr
operator|+
name|SIPLRESET
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQCLR
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQSET
operator|)
operator|=
literal|0x10
expr_stmt|;
name|type
operator|=
name|SIHOST2
expr_stmt|;
name|ramsize
operator|=
name|SIHOST2_RAMSIZE
expr_stmt|;
goto|goto
name|got_card
goto|;
comment|/* 	 * Its not a MK II, so try for a MK I (SIHOST) 	 */
name|try_mk1
label|:
operator|*
operator|(
name|maddr
operator|+
name|SIRESET
operator|)
operator|=
literal|0x0
expr_stmt|;
comment|/* reset the card */
operator|*
operator|(
name|maddr
operator|+
name|SIINTCL
operator|)
operator|=
literal|0x0
expr_stmt|;
comment|/* clear int */
operator|*
operator|(
name|maddr
operator|+
name|SIRAM
operator|)
operator|=
literal|0x17
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|maddr
operator|+
name|SIRAM
operator|)
operator|!=
operator|(
name|BYTE
operator|)
literal|0x17
condition|)
goto|goto
name|fail
goto|;
operator|*
operator|(
name|maddr
operator|+
literal|0x7ff8
operator|)
operator|=
literal|0x17
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|maddr
operator|+
literal|0x7ff8
operator|)
operator|!=
operator|(
name|BYTE
operator|)
literal|0x17
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator||
name|DBG_FAIL
operator|,
literal|"si%d: 0x17 check fail at phys 0x%x = 0x%x\n"
operator|,
name|id
operator|->
name|id_unit
operator|,
name|paddr
operator|+
literal|0x77f8
operator|,
operator|*
operator|(
name|maddr
operator|+
literal|0x77f8
operator|)
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* It must be an SIHOST (maybe?) - there must be a better way XXXX */
name|type
operator|=
name|SIHOST
expr_stmt|;
name|ramsize
operator|=
name|SIHOST_RAMSIZE
expr_stmt|;
name|got_card
label|:
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator|,
literal|"si%d: found type %d card, try memory test\n"
operator|,
name|id
operator|->
name|id_unit
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
comment|/* Try the acid test */
name|ux
operator|=
name|maddr
operator|+
name|SIRAM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ramsize
condition|;
name|i
operator|++
operator|,
name|ux
operator|++
control|)
operator|*
name|ux
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|i
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ux
operator|=
name|maddr
operator|+
name|SIRAM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ramsize
condition|;
name|i
operator|++
operator|,
name|ux
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|was
operator|=
operator|*
name|ux
operator|)
operator|!=
call|(
name|BYTE
call|)
argument_list|(
name|i
operator|&
literal|0xff
argument_list|)
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator||
name|DBG_FAIL
operator|,
literal|"si%d: match fail at phys 0x%x, was %x should be %x\n"
operator|,
name|id
operator|->
name|id_unit
operator|,
name|paddr
operator|+
name|i
operator|,
name|was
operator|,
name|i
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* clear out the RAM */
name|ux
operator|=
name|maddr
operator|+
name|SIRAM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ramsize
condition|;
name|i
operator|++
control|)
operator|*
name|ux
operator|++
operator|=
literal|0
expr_stmt|;
name|ux
operator|=
name|maddr
operator|+
name|SIRAM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ramsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|was
operator|=
operator|*
name|ux
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator||
name|DBG_FAIL
operator|,
literal|"si%d: clear fail at phys 0x%x, was %x\n"
operator|,
name|id
operator|->
name|id_unit
operator|,
name|paddr
operator|+
name|i
operator|,
name|was
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* 	 * Success, we've found a valid board, now fill in 	 * the adapter structure. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SIHOST2
case|:
if|if
condition|(
operator|(
name|id
operator|->
name|id_irq
operator|&
operator|(
name|IRQ11
operator||
name|IRQ12
operator||
name|IRQ15
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bad_irq
label|:
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator||
name|DBG_FAIL
operator|,
literal|"si%d: bad IRQ value - %d\n"
operator|,
name|id
operator|->
name|id_unit
operator|,
name|id
operator|->
name|id_irq
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|id
operator|->
name|id_msize
operator|=
name|SIHOST2_MEMSIZE
expr_stmt|;
break|break;
case|case
name|SIHOST
case|:
if|if
condition|(
operator|(
name|id
operator|->
name|id_irq
operator|&
operator|(
name|IRQ11
operator||
name|IRQ12
operator||
name|IRQ15
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|bad_irq
goto|;
block|}
name|id
operator|->
name|id_msize
operator|=
name|SIHOST_MEMSIZE
expr_stmt|;
break|break;
case|case
name|SIEISA
case|:
name|id
operator|->
name|id_msize
operator|=
name|SIEISA_MEMSIZE
expr_stmt|;
break|break;
case|case
name|SI2
case|:
comment|/* MCA */
default|default:
name|printf
argument_list|(
literal|"si%d: %s not supported\n"
argument_list|,
name|id
operator|->
name|id_unit
argument_list|,
name|si_type
index|[
name|type
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|si_softc
index|[
name|id
operator|->
name|id_unit
index|]
operator|.
name|sc_type
operator|=
name|type
expr_stmt|;
name|si_softc
index|[
name|id
operator|->
name|id_unit
index|]
operator|.
name|sc_typename
operator|=
name|si_type
index|[
name|type
index|]
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* -1 == found */
block|}
end_function

begin_comment
comment|/*  * Attach the device.  Initialize the card.  */
end_comment

begin_function
specifier|static
name|int
name|siattach
parameter_list|(
name|id
parameter_list|)
name|struct
name|isa_device
modifier|*
name|id
decl_stmt|;
block|{
name|int
name|unit
init|=
name|id
operator|->
name|id_unit
decl_stmt|;
name|struct
name|si_softc
modifier|*
name|sc
init|=
operator|&
name|si_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
specifier|volatile
name|struct
name|si_reg
modifier|*
name|regp
decl_stmt|;
specifier|volatile
name|caddr_t
name|maddr
decl_stmt|;
name|struct
name|si_module
modifier|*
name|modp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|speedtab
modifier|*
name|spt
decl_stmt|;
name|int
name|nmodule
decl_stmt|,
name|nport
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|uart_type
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_AUTOBOOT
operator|,
literal|"si%d: siattach\n"
operator|,
name|id
operator|->
name|id_unit
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_paddr
operator|=
operator|(
name|caddr_t
operator|)
name|vtophys
argument_list|(
name|id
operator|->
name|id_maddr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_maddr
operator|=
name|id
operator|->
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|sc_irq
operator|=
name|id
operator|->
name|id_irq
expr_stmt|;
name|sc
operator|->
name|sc_ports
operator|=
name|NULL
expr_stmt|;
comment|/* mark as uninitialised */
name|maddr
operator|=
name|sc
operator|->
name|sc_maddr
expr_stmt|;
comment|/* 	 * OK, now lets download the firmware and try and boot the CPU.. 	 */
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_DOWNLOAD
operator|,
literal|"si%d: si_download: nbytes %d\n"
operator|,
name|id
operator|->
name|id_unit
operator|,
name|si_dsize
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|si_download
argument_list|,
name|maddr
argument_list|,
name|si_dsize
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_type
condition|)
block|{
case|case
name|SIEISA
case|:
if|#
directive|if
name|NEISA
operator|>
literal|0
comment|/* modify the Z280 firmware to tell it that it's on an EISA */
operator|*
operator|(
name|maddr
operator|+
literal|0x42
operator|)
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|sc_eisa_iobase
operator|+
literal|2
argument_list|,
name|sc
operator|->
name|sc_eisa_irqbits
operator||
literal|4
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|sc_eisa_iobase
operator|+
literal|3
argument_list|)
expr_stmt|;
comment|/* reset interrupt */
break|break;
endif|#
directive|endif
comment|/* fall-through if not EISA */
case|case
name|SI2
case|:
comment|/* 		 * must get around to converting the code for 		 * these one day, if FreeBSD ever supports it. 		 */
return|return
literal|0
return|;
case|case
name|SIHOST
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIRESET_CL
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|maddr
operator|+
name|SIINTCL_CL
operator|)
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIHOST2
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIPLRESET
operator|)
operator|=
literal|0x10
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_irq
condition|)
block|{
case|case
name|IRQ11
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQ11
operator|)
operator|=
literal|0x10
expr_stmt|;
break|break;
case|case
name|IRQ12
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQ12
operator|)
operator|=
literal|0x10
expr_stmt|;
break|break;
case|case
name|IRQ15
case|:
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQ15
operator|)
operator|=
literal|0x10
expr_stmt|;
break|break;
block|}
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQCLR
operator|)
operator|=
literal|0x10
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
comment|/* wait around for a second */
name|regp
operator|=
operator|(
expr|struct
name|si_reg
operator|*
operator|)
name|maddr
expr_stmt|;
name|y
operator|=
literal|0
expr_stmt|;
comment|/* wait max of 5 sec for init OK */
while|while
condition|(
name|regp
operator|->
name|initstat
operator|==
literal|0
operator|&&
name|y
operator|++
operator|<
literal|10
condition|)
block|{
name|DELAY
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|regp
operator|->
name|initstat
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"si%d: startup timeout - aborting\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_type
operator|=
name|SIEMPTY
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|1
case|:
comment|/* set throttle to 125 intr per second */
name|regp
operator|->
name|int_count
operator|=
name|INT_COUNT
expr_stmt|;
comment|/* rx intr max of 25 timer per second */
name|regp
operator|->
name|rx_int_count
operator|=
name|RXINT_COUNT
expr_stmt|;
name|regp
operator|->
name|int_pending
operator|=
literal|0
expr_stmt|;
comment|/* no intr pending */
name|regp
operator|->
name|int_scounter
operator|=
literal|0
expr_stmt|;
comment|/* reset counter */
break|break;
case|case
literal|0xff
case|:
comment|/* 		 * No modules found, so give up on this one. 		 */
name|printf
argument_list|(
literal|"si%d: %s - no ports found\n"
argument_list|,
name|unit
argument_list|,
name|si_type
index|[
name|sc
operator|->
name|sc_type
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
name|printf
argument_list|(
literal|"si%d: Z280 version error - initstat %x\n"
argument_list|,
name|unit
argument_list|,
name|regp
operator|->
name|initstat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * First time around the ports just count them in order 	 * to allocate some memory. 	 */
name|nport
operator|=
literal|0
expr_stmt|;
name|modp
operator|=
operator|(
expr|struct
name|si_module
operator|*
operator|)
operator|(
name|maddr
operator|+
literal|0x80
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_DOWNLOAD
operator|,
literal|"si%d: ccb addr 0x%x\n"
operator|,
name|unit
operator|,
name|modp
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|modp
operator|->
name|sm_type
operator|&
operator|(
operator|~
name|MMASK
operator|)
condition|)
block|{
case|case
name|M232
case|:
case|case
name|M422
case|:
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_DOWNLOAD
operator|,
literal|"si%d: Found 232/422 module, %d ports\n"
operator|,
name|unit
operator|,
call|(
name|int
call|)
argument_list|(
name|modp
operator|->
name|sm_type
operator|&
name|MMASK
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* this is a firmware issue */
if|if
condition|(
name|si_Nports
operator|==
name|SI_MAXPORTPERCARD
condition|)
block|{
name|printf
argument_list|(
literal|"si%d: extra ports ignored\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|x
operator|=
name|modp
operator|->
name|sm_type
operator|&
name|MMASK
expr_stmt|;
name|nport
operator|+=
name|x
expr_stmt|;
name|si_Nports
operator|+=
name|x
expr_stmt|;
name|si_Nmodules
operator|++
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"si%d: unknown module type %d\n"
argument_list|,
name|unit
argument_list|,
name|modp
operator|->
name|sm_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|modp
operator|->
name|sm_next
operator|==
literal|0
condition|)
break|break;
name|modp
operator|=
operator|(
expr|struct
name|si_module
operator|*
operator|)
operator|(
name|maddr
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|modp
operator|->
name|sm_next
operator|&
literal|0x7fff
argument_list|)
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_ports
operator|=
operator|(
expr|struct
name|si_port
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|si_port
argument_list|)
operator|*
name|nport
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ports
operator|==
literal|0
condition|)
block|{
name|mem_fail
label|:
name|printf
argument_list|(
literal|"si%d: fail to malloc memory for port structs\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|sc
operator|->
name|sc_ports
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|si_port
argument_list|)
operator|*
name|nport
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_nport
operator|=
name|nport
expr_stmt|;
comment|/* 	 * allocate tty structures for ports 	 */
name|tp
operator|=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tp
argument_list|)
operator|*
name|nport
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
literal|0
condition|)
goto|goto
name|mem_fail
goto|;
name|bzero
argument_list|(
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tp
argument_list|)
operator|*
name|nport
argument_list|)
expr_stmt|;
name|si_tty
operator|=
name|tp
expr_stmt|;
comment|/* 	 * Scan round the ports again, this time initialising. 	 */
name|pp
operator|=
name|sc
operator|->
name|sc_ports
expr_stmt|;
name|nmodule
operator|=
literal|0
expr_stmt|;
name|modp
operator|=
operator|(
expr|struct
name|si_module
operator|*
operator|)
operator|(
name|maddr
operator|+
literal|0x80
operator|)
expr_stmt|;
name|uart_type
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|modp
operator|->
name|sm_type
operator|&
operator|(
operator|~
name|MMASK
operator|)
condition|)
block|{
case|case
name|M232
case|:
case|case
name|M422
case|:
name|nmodule
operator|++
expr_stmt|;
name|nport
operator|=
operator|(
name|modp
operator|->
name|sm_type
operator|&
name|MMASK
operator|)
expr_stmt|;
name|ccbp
operator|=
operator|(
expr|struct
name|si_channel
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|modp
operator|+
literal|0x100
operator|)
expr_stmt|;
if|if
condition|(
name|uart_type
operator|==
literal|0
condition|)
name|uart_type
operator|=
name|ccbp
operator|->
name|type
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nport
condition|;
name|x
operator|++
operator|,
name|pp
operator|++
operator|,
name|ccbp
operator|++
control|)
block|{
name|pp
operator|->
name|sp_ccb
operator|=
name|ccbp
expr_stmt|;
comment|/* save the address */
name|pp
operator|->
name|sp_tty
operator|=
name|tp
operator|++
expr_stmt|;
name|pp
operator|->
name|sp_pend
operator|=
name|IDLE_CLOSE
expr_stmt|;
name|pp
operator|->
name|sp_state
operator|=
literal|0
expr_stmt|;
comment|/* internal flag */
name|pp
operator|->
name|sp_dtr_wait
operator|=
literal|3
operator|*
name|hz
expr_stmt|;
name|pp
operator|->
name|sp_iin
operator|.
name|c_iflag
operator|=
name|si_default_iflag
expr_stmt|;
name|pp
operator|->
name|sp_iin
operator|.
name|c_oflag
operator|=
name|si_default_oflag
expr_stmt|;
name|pp
operator|->
name|sp_iin
operator|.
name|c_cflag
operator|=
name|si_default_cflag
expr_stmt|;
name|pp
operator|->
name|sp_iin
operator|.
name|c_lflag
operator|=
name|si_default_lflag
expr_stmt|;
name|termioschars
argument_list|(
operator|&
name|pp
operator|->
name|sp_iin
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_iin
operator|.
name|c_ispeed
operator|=
name|pp
operator|->
name|sp_iin
operator|.
name|c_ospeed
operator|=
name|si_default_rate
expr_stmt|;
name|pp
operator|->
name|sp_iout
operator|=
name|pp
operator|->
name|sp_iin
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|modp
operator|->
name|sm_next
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"si%d: card: %s, ports: %d, modules: %d (type: %d)\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|sc_typename
argument_list|,
name|sc
operator|->
name|sc_nport
argument_list|,
name|nmodule
argument_list|,
name|uart_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|modp
operator|=
operator|(
expr|struct
name|si_module
operator|*
operator|)
operator|(
name|maddr
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|modp
operator|->
name|sm_next
operator|&
literal|0x7fff
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|done_chartimes
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|spt
operator|=
name|chartimes
init|;
name|spt
operator|->
name|sp_speed
operator|!=
operator|-
literal|1
condition|;
name|spt
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|spt
operator|->
name|sp_code
operator|/=
name|hz
operator|)
operator|==
literal|0
condition|)
name|spt
operator|->
name|sp_code
operator|=
literal|1
expr_stmt|;
block|}
name|done_chartimes
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVFS
comment|/*	path	name	devsw		minor	type   uid gid perm*/
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|sc
operator|->
name|sc_nport
condition|;
name|x
operator|++
control|)
block|{
name|y
operator|=
name|x
operator|+
literal|1
expr_stmt|;
comment|/* For sync with the manuals that start at 1 */
name|sc
operator|->
name|devfs_token
index|[
name|x
index|]
operator|.
name|ttyd
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|si_cdevsw
argument_list|,
name|x
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"ttyA%02d"
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devfs_token
index|[
name|x
index|]
operator|.
name|cuaa
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|si_cdevsw
argument_list|,
name|x
operator|+
literal|128
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"cuaA%02d"
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devfs_token
index|[
name|x
index|]
operator|.
name|ttyi
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|si_cdevsw
argument_list|,
name|x
operator|+
literal|0x10000
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"ttyiA%02d"
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|sc
operator|->
name|devfs_token
index|[
name|x
index|]
operator|.
name|ttyl
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|si_cdevsw
argument_list|,
name|x
operator|+
literal|0x20000
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"ttylA%02d"
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|control_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|si_cdevsw
argument_list|,
literal|0x40000
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"si_control"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|siopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|oldspl
decl_stmt|,
name|error
decl_stmt|;
name|int
name|card
decl_stmt|,
name|port
decl_stmt|;
specifier|register
name|struct
name|si_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
name|int
name|mynor
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* quickly let in /dev/si_control */
if|if
condition|(
name|IS_CONTROLDEV
argument_list|(
name|mynor
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|card
operator|=
name|SI_CARD
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
if|if
condition|(
name|card
operator|>=
name|NSI
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
operator|&
name|si_softc
index|[
name|card
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_type
operator|==
name|SIEMPTY
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_OPEN
operator||
name|DBG_FAIL
operator|,
literal|"si%d: type %s??\n"
operator|,
name|card
operator|,
name|sc
operator|->
name|sc_typename
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|port
operator|=
name|SI_PORT
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|>=
name|sc
operator|->
name|sc_nport
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_OPEN
operator||
name|DBG_FAIL
operator|,
literal|"si%d: nports %d\n"
operator|,
name|card
operator|,
name|sc
operator|->
name|sc_nport
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|POLL
comment|/* 	 * We've now got a device, so start the poller. 	 */
if|if
condition|(
name|init_finished
operator|==
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|si_poll
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0L
argument_list|,
name|si_pollrate
argument_list|)
expr_stmt|;
name|init_finished
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* initial/lock device */
if|if
condition|(
name|IS_STATE
argument_list|(
name|mynor
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|=
name|sc
operator|->
name|sc_ports
operator|+
name|port
expr_stmt|;
name|tp
operator|=
name|pp
operator|->
name|sp_tty
expr_stmt|;
comment|/* the "real" tty */
name|ccbp
operator|=
name|pp
operator|->
name|sp_ccb
expr_stmt|;
comment|/* Find control block */
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_OPEN
operator|,
literal|"siopen(%x,%x,%x,%x)\n"
operator|,
name|dev
operator|,
name|flag
operator|,
name|mode
operator|,
name|p
operator|)
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* Keep others out */
name|error
operator|=
literal|0
expr_stmt|;
name|open_top
label|:
while|while
condition|(
name|pp
operator|->
name|sp_state
operator|&
name|SS_DTR_OFF
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|pp
operator|->
name|sp_dtr_wait
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"sidtr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
comment|/* 		 * The device is open, so everything has been initialised. 		 * handle conflicts. 		 */
if|if
condition|(
name|IS_CALLOUT
argument_list|(
name|mynor
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|pp
operator|->
name|sp_active_out
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pp
operator|->
name|sp_active_out
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|pp
operator|->
name|sp_active_out
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"sibi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
goto|goto
name|open_top
goto|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_OPEN
operator||
name|DBG_FAIL
operator|,
literal|"already open and EXCLUSIVE set\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * The device isn't open, so there are no conflicts. 		 * Initialize it. Avoid sleep... :-) 		 */
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_OPEN
operator|,
literal|"first open\n"
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|si_start
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|siparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|=
name|mynor
operator|&
name|SI_CALLOUT_MASK
condition|?
name|pp
operator|->
name|sp_iout
else|:
name|pp
operator|->
name|sp_iin
expr_stmt|;
operator|(
name|void
operator|)
name|si_modem
argument_list|(
name|pp
argument_list|,
name|SET
argument_list|,
name|TIOCM_DTR
operator||
name|TIOCM_RTS
argument_list|)
expr_stmt|;
operator|++
name|pp
operator|->
name|sp_wopeners
expr_stmt|;
comment|/* in case of sleep in siparam */
name|error
operator|=
name|siparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
operator|--
name|pp
operator|->
name|sp_wopeners
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* XXX: we should goto_top if siparam slept */
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* set initial DCD state */
name|pp
operator|->
name|sp_last_hi_ip
operator|=
name|ccbp
operator|->
name|hi_ip
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|->
name|sp_last_hi_ip
operator|&
name|IP_DCD
operator|)
operator|||
name|IS_CALLOUT
argument_list|(
name|mynor
argument_list|)
condition|)
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|1
operator|)
expr_stmt|;
block|}
block|}
comment|/* whoops! we beat the close! */
if|if
condition|(
name|pp
operator|->
name|sp_state
operator|&
name|SS_CLOSING
condition|)
block|{
comment|/* try and stop it from proceeding to bash the hardware */
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SS_CLOSING
expr_stmt|;
block|}
comment|/* 	 * Wait for DCD if necessary 	 */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|&&
operator|!
name|IS_CALLOUT
argument_list|(
name|mynor
argument_list|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
condition|)
block|{
operator|++
name|pp
operator|->
name|sp_wopeners
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_OPEN
operator|,
literal|"sleeping for carrier\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"sidcd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|pp
operator|->
name|sp_wopeners
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
goto|goto
name|open_top
goto|;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
name|si_disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|&&
name|IS_CALLOUT
argument_list|(
name|mynor
argument_list|)
condition|)
name|pp
operator|->
name|sp_active_out
operator|=
name|TRUE
expr_stmt|;
name|pp
operator|->
name|sp_state
operator||=
name|SS_OPEN
expr_stmt|;
comment|/* made it! */
name|out
label|:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_OPEN
operator|,
literal|"leaving siopen\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
name|pp
operator|->
name|sp_wopeners
operator|==
literal|0
condition|)
name|sihardclose
argument_list|(
name|pp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|siclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|oldspl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|mynor
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_SPECIAL
argument_list|(
name|mynor
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|pp
operator|=
name|MINOR2PP
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|tp
operator|=
name|pp
operator|->
name|sp_tty
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_CLOSE
operator|,
literal|"siclose(%x,%x,%x,%x) sp_state:%x\n"
operator|,
name|dev
operator|,
name|flag
operator|,
name|mode
operator|,
name|p
operator|,
name|pp
operator|->
name|sp_state
operator|)
argument_list|)
expr_stmt|;
comment|/* did we sleep and loose a race? */
if|if
condition|(
name|pp
operator|->
name|sp_state
operator|&
name|SS_CLOSING
condition|)
block|{
comment|/* error = ESOMETING? */
goto|goto
name|out
goto|;
block|}
comment|/* begin race detection.. */
name|pp
operator|->
name|sp_state
operator||=
name|SS_CLOSING
expr_stmt|;
name|si_write_enable
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* block writes for ttywait() */
comment|/* THIS MAY SLEEP IN TTYWAIT!!! */
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|si_write_enable
argument_list|(
name|pp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* did we sleep and somebody started another open? */
if|if
condition|(
operator|!
operator|(
name|pp
operator|->
name|sp_state
operator|&
name|SS_CLOSING
operator|)
condition|)
block|{
comment|/* error = ESOMETING? */
goto|goto
name|out
goto|;
block|}
comment|/* ok. we are now still on the right track.. nuke the hardware */
if|if
condition|(
name|pp
operator|->
name|sp_state
operator|&
name|SS_LSTART
condition|)
block|{
name|untimeout
argument_list|(
name|si_lstart
argument_list|,
operator|(
name|caddr_t
operator|)
name|pp
argument_list|,
name|pp
operator|->
name|lstart_ch
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SS_LSTART
expr_stmt|;
block|}
name|sistop
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|sihardclose
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SS_OPEN
expr_stmt|;
name|out
label|:
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_CLOSE
operator||
name|DBG_EXIT
operator|,
literal|"close done, returning\n"
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sihardclose
parameter_list|(
name|pp
parameter_list|)
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
block|{
name|int
name|oldspl
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|tp
operator|=
name|pp
operator|->
name|sp_tty
expr_stmt|;
name|ccbp
operator|=
name|pp
operator|->
name|sp_ccb
expr_stmt|;
comment|/* Find control block */
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|||
operator|(
operator|!
name|pp
operator|->
name|sp_active_out
operator|&&
operator|!
operator|(
name|ccbp
operator|->
name|hi_ip
operator|&
name|IP_DCD
operator|)
operator|&&
operator|!
operator|(
name|pp
operator|->
name|sp_iin
operator|.
name|c_cflag
operator|&&
name|CLOCAL
operator|)
operator|)
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|si_modem
argument_list|(
name|pp
argument_list|,
name|BIC
argument_list|,
name|TIOCM_DTR
operator||
name|TIOCM_RTS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|si_command
argument_list|(
name|pp
argument_list|,
name|FCLOSE
argument_list|,
name|SI_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sp_dtr_wait
operator|!=
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|sidtrwakeup
argument_list|,
name|pp
argument_list|,
name|pp
operator|->
name|sp_dtr_wait
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_state
operator||=
name|SS_DTR_OFF
expr_stmt|;
block|}
block|}
name|pp
operator|->
name|sp_active_out
operator|=
name|FALSE
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|pp
operator|->
name|sp_active_out
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * called at splsoftclock()...  */
end_comment

begin_function
specifier|static
name|void
name|sidtrwakeup
parameter_list|(
name|chan
parameter_list|)
name|void
modifier|*
name|chan
decl_stmt|;
block|{
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
name|int
name|oldspl
decl_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|pp
operator|=
operator|(
expr|struct
name|si_port
operator|*
operator|)
name|chan
expr_stmt|;
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SS_DTR_OFF
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|pp
operator|->
name|sp_dtr_wait
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * User level stuff - read and write  */
end_comment

begin_function
specifier|static
name|int
name|siread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|mynor
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|IS_SPECIAL
argument_list|(
name|mynor
argument_list|)
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_ENTRY
operator||
name|DBG_FAIL
operator||
name|DBG_READ
operator|,
literal|"siread(CONTROLDEV!!)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|tp
operator|=
name|MINOR2TP
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|TP2PP
argument_list|(
name|tp
argument_list|)
operator|,
name|DBG_ENTRY
operator||
name|DBG_READ
operator|,
literal|"siread(%x,%x,%x)\n"
operator|,
name|dev
operator|,
name|uio
operator|,
name|flag
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|siwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|mynor
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|oldspl
decl_stmt|;
if|if
condition|(
name|IS_SPECIAL
argument_list|(
name|mynor
argument_list|)
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_ENTRY
operator||
name|DBG_FAIL
operator||
name|DBG_WRITE
operator|,
literal|"siwrite(CONTROLDEV!!)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|pp
operator|=
name|MINOR2PP
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|tp
operator|=
name|pp
operator|->
name|sp_tty
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_WRITE
operator|,
literal|"siwrite(%x,%x,%x)\n"
operator|,
name|dev
operator|,
name|uio
operator|,
name|flag
operator|)
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* 	 * If writes are currently blocked, wait on the "real" tty 	 */
while|while
condition|(
name|pp
operator|->
name|sp_state
operator|&
name|SS_BLOCKWRITE
condition|)
block|{
name|pp
operator|->
name|sp_state
operator||=
name|SS_WAITWRITE
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_WRITE
operator|,
literal|"in siwrite, wait for SS_BLOCKWRITE to clear\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ttysleep
argument_list|(
name|tp
argument_list|,
operator|(
name|caddr_t
operator|)
name|pp
argument_list|,
name|TTOPRI
operator||
name|PCATCH
argument_list|,
literal|"siwrite"
argument_list|,
name|tp
operator|->
name|t_timeout
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
expr_stmt|;
name|out
label|:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|tty
modifier|*
name|sidevtotty
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
name|int
name|mynor
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|si_softc
modifier|*
name|sc
init|=
operator|&
name|si_softc
index|[
name|SI_CARD
argument_list|(
name|mynor
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|IS_SPECIAL
argument_list|(
name|mynor
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|SI_PORT
argument_list|(
name|mynor
argument_list|)
operator|>=
name|sc
operator|->
name|sc_nport
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|pp
operator|=
name|MINOR2PP
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
return|return
operator|(
name|pp
operator|->
name|sp_tty
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|siioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|mynor
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|oldspl
decl_stmt|;
name|int
name|blocked
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
name|int
name|oldcmd
decl_stmt|;
name|struct
name|termios
name|term
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|IS_SI_IOCTL
argument_list|(
name|cmd
argument_list|)
condition|)
return|return
operator|(
name|si_Sioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
operator|)
return|;
name|pp
operator|=
name|MINOR2PP
argument_list|(
name|mynor
argument_list|)
expr_stmt|;
name|tp
operator|=
name|pp
operator|->
name|sp_tty
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_IOCTL
operator|,
literal|"siioctl(%x,%x,%x,%x)\n"
operator|,
name|dev
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_STATE
argument_list|(
name|mynor
argument_list|)
condition|)
block|{
name|struct
name|termios
modifier|*
name|ct
decl_stmt|;
switch|switch
condition|(
name|mynor
operator|&
name|SI_STATE_MASK
condition|)
block|{
case|case
name|SI_INIT_STATE_MASK
case|:
name|ct
operator|=
name|IS_CALLOUT
argument_list|(
name|mynor
argument_list|)
condition|?
operator|&
name|pp
operator|->
name|sp_iout
else|:
operator|&
name|pp
operator|->
name|sp_iin
expr_stmt|;
break|break;
case|case
name|SI_LOCK_STATE_MASK
case|:
name|ct
operator|=
name|IS_CALLOUT
argument_list|(
name|mynor
argument_list|)
condition|?
operator|&
name|pp
operator|->
name|sp_lout
else|:
operator|&
name|pp
operator|->
name|sp_lin
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSETA
case|:
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|ct
operator|=
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETA
case|:
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|=
operator|*
name|ct
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TTYDISC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGWINSZ
case|:
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|winsize
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
comment|/* 	 * Do the old-style ioctl compat routines... 	 */
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
name|term
operator|=
name|tp
operator|->
name|t_termios
expr_stmt|;
name|oldcmd
operator|=
name|cmd
expr_stmt|;
name|error
operator|=
name|ttsetcompat
argument_list|(
name|tp
argument_list|,
operator|&
name|cmd
argument_list|,
name|data
argument_list|,
operator|&
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|cmd
operator|!=
name|oldcmd
condition|)
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|term
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Do the initial / lock state business 	 */
if|if
condition|(
name|cmd
operator|==
name|TIOCSETA
operator|||
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|termios
modifier|*
name|dt
init|=
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|termios
modifier|*
name|lt
init|=
name|mynor
operator|&
name|SI_CALLOUT_MASK
condition|?
operator|&
name|pp
operator|->
name|sp_lout
else|:
operator|&
name|pp
operator|->
name|sp_lin
decl_stmt|;
name|dt
operator|->
name|c_iflag
operator|=
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|lt
operator|->
name|c_iflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_iflag
operator|&
operator|~
name|lt
operator|->
name|c_iflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_oflag
operator|=
operator|(
name|tp
operator|->
name|t_oflag
operator|&
name|lt
operator|->
name|c_oflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_oflag
operator|&
operator|~
name|lt
operator|->
name|c_oflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_cflag
operator|=
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|lt
operator|->
name|c_cflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_cflag
operator|&
operator|~
name|lt
operator|->
name|c_cflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_lflag
operator|=
operator|(
name|tp
operator|->
name|t_lflag
operator|&
name|lt
operator|->
name|c_lflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_lflag
operator|&
operator|~
name|lt
operator|->
name|c_lflag
operator|)
expr_stmt|;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
name|NCCS
condition|;
operator|++
name|cc
control|)
if|if
condition|(
name|lt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|=
name|tp
operator|->
name|t_cc
index|[
name|cc
index|]
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ispeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ispeed
operator|=
name|tp
operator|->
name|t_ispeed
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ospeed
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
block|}
comment|/* 	 * Block user-level writes to give the ttywait() 	 * a chance to completely drain for commands 	 * that require the port to be in a quiescent state. 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSETAW
case|:
case|case
name|TIOCSETAF
case|:
case|case
name|TIOCDRAIN
case|:
ifdef|#
directive|ifdef
name|COMPAT_43
case|case
name|TIOCSETP
case|:
endif|#
directive|endif
name|blocked
operator|++
expr_stmt|;
comment|/* block writes for ttywait() and siparam() */
name|si_write_enable
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
goto|goto
name|out
goto|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|si_disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
goto|goto
name|outspl
goto|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
name|si_command
argument_list|(
name|pp
argument_list|,
name|SBREAK
argument_list|,
name|SI_WAIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
name|si_command
argument_list|(
name|pp
argument_list|,
name|EBREAK
argument_list|,
name|SI_WAIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCSDTR
case|:
operator|(
name|void
operator|)
name|si_modem
argument_list|(
name|pp
argument_list|,
name|SET
argument_list|,
name|TIOCM_DTR
operator||
name|TIOCM_RTS
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
operator|(
name|void
operator|)
name|si_modem
argument_list|(
name|pp
argument_list|,
name|SET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
operator|(
name|void
operator|)
name|si_modem
argument_list|(
name|pp
argument_list|,
name|SET
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
operator|(
name|void
operator|)
name|si_modem
argument_list|(
name|pp
argument_list|,
name|BIS
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
operator|(
name|void
operator|)
name|si_modem
argument_list|(
name|pp
argument_list|,
name|BIC
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|si_modem
argument_list|(
name|pp
argument_list|,
name|GET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSDTRWAIT
case|:
comment|/* must be root since the wait applies to following logins */
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
goto|goto
name|outspl
goto|;
block|}
name|pp
operator|->
name|sp_dtr_wait
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|*
name|hz
operator|/
literal|100
expr_stmt|;
break|break;
case|case
name|TIOCMGDTRWAIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|pp
operator|->
name|sp_dtr_wait
operator|*
literal|100
operator|/
name|hz
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|outspl
label|:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|out
label|:
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_IOCTL
operator||
name|DBG_EXIT
operator|,
literal|"siioctl ret %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocked
condition|)
name|si_write_enable
argument_list|(
name|pp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle the Specialix ioctls. All MUST be called via the CONTROL device  */
end_comment

begin_function
specifier|static
name|int
name|si_Sioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|si_softc
modifier|*
name|xsc
decl_stmt|;
specifier|register
name|struct
name|si_port
modifier|*
name|xpp
decl_stmt|;
specifier|volatile
name|struct
name|si_reg
modifier|*
name|regp
decl_stmt|;
name|struct
name|si_tcsi
modifier|*
name|dp
decl_stmt|;
name|struct
name|si_pstat
modifier|*
name|sps
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|oldspl
decl_stmt|;
name|int
name|card
decl_stmt|,
name|port
decl_stmt|;
name|int
name|mynor
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_ENTRY
operator||
name|DBG_IOCTL
operator|,
literal|"si_Sioctl(%x,%x,%x,%x)\n"
operator|,
name|dev
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_IOCTL
operator|,
literal|"TCSI_PORT=%x\n"
operator|,
name|TCSI_PORT
operator|)
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_IOCTL
operator|,
literal|"TCSI_CCB=%x\n"
operator|,
name|TCSI_CCB
operator|)
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_IOCTL
operator|,
literal|"TCSI_TTY=%x\n"
operator|,
name|TCSI_TTY
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|IS_CONTROLDEV
argument_list|(
name|mynor
argument_list|)
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_IOCTL
operator||
name|DBG_FAIL
operator|,
literal|"not called from control device!\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* better safe than sorry */
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
define|#
directive|define
name|SUCHECK
value|if ((error = suser(p->p_ucred,&p->p_acflag))) goto out
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TCSIPORTS
case|:
operator|*
name|ip
operator|=
name|si_Nports
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|TCSIMODULES
case|:
operator|*
name|ip
operator|=
name|si_Nmodules
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|TCSISDBG_ALL
case|:
name|SUCHECK
expr_stmt|;
name|si_debug
operator|=
operator|*
name|ip
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|TCSIGDBG_ALL
case|:
operator|*
name|ip
operator|=
name|si_debug
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
comment|/* 		 * Check that a controller for this port exists 		 */
comment|/* may also be a struct si_pstat, a superset of si_tcsi */
name|dp
operator|=
operator|(
expr|struct
name|si_tcsi
operator|*
operator|)
name|data
expr_stmt|;
name|sps
operator|=
operator|(
expr|struct
name|si_pstat
operator|*
operator|)
name|data
expr_stmt|;
name|card
operator|=
name|dp
operator|->
name|tc_card
expr_stmt|;
name|xsc
operator|=
operator|&
name|si_softc
index|[
name|card
index|]
expr_stmt|;
comment|/* check.. */
if|if
condition|(
name|card
operator|<
literal|0
operator|||
name|card
operator|>=
name|NSI
operator|||
name|xsc
operator|->
name|sc_type
operator|==
name|SIEMPTY
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * And check that a port exists 		 */
name|port
operator|=
name|dp
operator|->
name|tc_port
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
operator|||
name|port
operator|>=
name|xsc
operator|->
name|sc_nport
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|xpp
operator|=
name|xsc
operator|->
name|sc_ports
operator|+
name|port
expr_stmt|;
name|regp
operator|=
operator|(
expr|struct
name|si_reg
operator|*
operator|)
name|xsc
operator|->
name|sc_maddr
expr_stmt|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TCSIDEBUG
case|:
ifdef|#
directive|ifdef
name|SI_DEBUG
name|SUCHECK
expr_stmt|;
if|if
condition|(
name|xpp
operator|->
name|sp_debug
condition|)
name|xpp
operator|->
name|sp_debug
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|xpp
operator|->
name|sp_debug
operator|=
name|DBG_ALL
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|xpp
operator|,
name|DBG_IOCTL
operator|,
literal|"debug toggled %s\n"
operator|,
operator|(
name|xpp
operator|->
name|sp_debug
operator|&
name|DBG_ALL
operator|)
condition|?
literal|"ON"
else|:
literal|"OFF"
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
else|#
directive|else
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
endif|#
directive|endif
case|case
name|TCSISDBG_LEVEL
case|:
case|case
name|TCSIGDBG_LEVEL
case|:
ifdef|#
directive|ifdef
name|SI_DEBUG
if|if
condition|(
name|cmd
operator|==
name|TCSIGDBG_LEVEL
condition|)
block|{
name|dp
operator|->
name|tc_dbglvl
operator|=
name|xpp
operator|->
name|sp_debug
expr_stmt|;
block|}
else|else
block|{
name|SUCHECK
expr_stmt|;
name|xpp
operator|->
name|sp_debug
operator|=
name|dp
operator|->
name|tc_dbglvl
expr_stmt|;
block|}
break|break;
else|#
directive|else
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
endif|#
directive|endif
case|case
name|TCSIGRXIT
case|:
name|dp
operator|->
name|tc_int
operator|=
name|regp
operator|->
name|rx_int_count
expr_stmt|;
break|break;
case|case
name|TCSIRXIT
case|:
name|SUCHECK
expr_stmt|;
name|regp
operator|->
name|rx_int_count
operator|=
name|dp
operator|->
name|tc_int
expr_stmt|;
break|break;
case|case
name|TCSIGIT
case|:
name|dp
operator|->
name|tc_int
operator|=
name|regp
operator|->
name|int_count
expr_stmt|;
break|break;
case|case
name|TCSIIT
case|:
name|SUCHECK
expr_stmt|;
name|regp
operator|->
name|int_count
operator|=
name|dp
operator|->
name|tc_int
expr_stmt|;
break|break;
case|case
name|TCSISTATE
case|:
name|dp
operator|->
name|tc_int
operator|=
name|xpp
operator|->
name|sp_ccb
operator|->
name|hi_ip
expr_stmt|;
break|break;
comment|/* these next three use a different structure */
case|case
name|TCSI_PORT
case|:
name|SUCHECK
expr_stmt|;
name|bcopy
argument_list|(
name|xpp
argument_list|,
operator|&
name|sps
operator|->
name|tc_siport
argument_list|,
sizeof|sizeof
argument_list|(
name|sps
operator|->
name|tc_siport
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCSI_CCB
case|:
name|SUCHECK
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|xpp
operator|->
name|sp_ccb
argument_list|,
operator|&
name|sps
operator|->
name|tc_ccb
argument_list|,
sizeof|sizeof
argument_list|(
name|sps
operator|->
name|tc_ccb
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCSI_TTY
case|:
name|SUCHECK
expr_stmt|;
name|bcopy
argument_list|(
name|xpp
operator|->
name|sp_tty
argument_list|,
operator|&
name|sps
operator|->
name|tc_tty
argument_list|,
sizeof|sizeof
argument_list|(
name|sps
operator|->
name|tc_tty
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*  *	siparam()	: Configure line params  *	called at spltty();  *	this may sleep, does not flush, nor wait for drain, nor block writes  *	caller must arrange this if it's important..  */
end_comment

begin_function
specifier|static
name|int
name|siparam
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|struct
name|si_port
modifier|*
name|pp
init|=
name|TP2PP
argument_list|(
name|tp
argument_list|)
decl_stmt|;
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
name|int
name|oldspl
decl_stmt|,
name|cflag
decl_stmt|,
name|iflag
decl_stmt|,
name|oflag
decl_stmt|,
name|lflag
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* shutup gcc */
name|int
name|ispeed
init|=
literal|0
decl_stmt|;
comment|/* shutup gcc */
name|int
name|ospeed
init|=
literal|0
decl_stmt|;
comment|/* shutup gcc */
name|BYTE
name|val
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_PARAM
operator|,
literal|"siparam(%x,%x)\n"
operator|,
name|tp
operator|,
name|t
operator|)
argument_list|)
expr_stmt|;
name|cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
name|iflag
operator|=
name|t
operator|->
name|c_iflag
expr_stmt|;
name|oflag
operator|=
name|t
operator|->
name|c_oflag
expr_stmt|;
name|lflag
operator|=
name|t
operator|->
name|c_lflag
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_PARAM
operator|,
literal|"OFLAG 0x%x CFLAG 0x%x IFLAG 0x%x LFLAG 0x%x\n"
operator|,
name|oflag
operator|,
name|cflag
operator|,
name|iflag
operator|,
name|lflag
operator|)
argument_list|)
expr_stmt|;
comment|/* if not hung up.. */
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
block|{
comment|/* translate baud rate to firmware values */
name|ospeed
operator|=
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
name|bdrates
argument_list|)
expr_stmt|;
name|ispeed
operator|=
name|t
operator|->
name|c_ispeed
condition|?
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ispeed
argument_list|,
name|bdrates
argument_list|)
else|:
name|ospeed
expr_stmt|;
comment|/* enforce legit baud rate */
if|if
condition|(
name|ospeed
operator|<
literal|0
operator|||
name|ispeed
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|ccbp
operator|=
name|pp
operator|->
name|sp_ccb
expr_stmt|;
comment|/* ========== set hi_break ========== */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IGNBRK
condition|)
comment|/* Breaks */
name|val
operator||=
name|BR_IGN
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|BRKINT
condition|)
comment|/* Interrupt on break? */
name|val
operator||=
name|BR_INT
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|PARMRK
condition|)
comment|/* Parity mark? */
name|val
operator||=
name|BR_PARMRK
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IGNPAR
condition|)
comment|/* Ignore chars with parity errors? */
name|val
operator||=
name|BR_PARIGN
expr_stmt|;
name|ccbp
operator|->
name|hi_break
operator|=
name|val
expr_stmt|;
comment|/* ========== set hi_csr ========== */
comment|/* if not hung up.. */
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
block|{
comment|/* Set I/O speeds */
name|val
operator|=
operator|(
name|ispeed
operator|<<
literal|4
operator|)
operator||
name|ospeed
expr_stmt|;
block|}
name|ccbp
operator|->
name|hi_csr
operator|=
name|val
expr_stmt|;
comment|/* ========== set hi_mr2 ========== */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
comment|/* Stop bits */
name|val
operator||=
name|MR2_2_STOP
expr_stmt|;
else|else
name|val
operator||=
name|MR2_1_STOP
expr_stmt|;
comment|/* 	 * Enable H/W RTS/CTS handshaking. The default TA/MTA is 	 * a DCE, hence the reverse sense of RTS and CTS 	 */
comment|/* Output Flow - RTS must be raised before data can be sent */
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
name|val
operator||=
name|MR2_RTSCONT
expr_stmt|;
name|ccbp
operator|->
name|hi_mr2
operator|=
name|val
expr_stmt|;
comment|/* ========== set hi_mr1 ========== */
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cflag
operator|&
name|PARENB
operator|)
condition|)
comment|/* Parity */
name|val
operator||=
name|MR1_NONE
expr_stmt|;
else|else
name|val
operator||=
name|MR1_WITH
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|PARODD
condition|)
name|val
operator||=
name|MR1_ODD
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS8
operator|)
operator|==
name|CS8
condition|)
block|{
comment|/* 8 data bits? */
name|val
operator||=
name|MR1_8_BITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS7
operator|)
operator|==
name|CS7
condition|)
block|{
comment|/* 7 data bits? */
name|val
operator||=
name|MR1_7_BITS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS6
operator|)
operator|==
name|CS6
condition|)
block|{
comment|/* 6 data bits? */
name|val
operator||=
name|MR1_6_BITS
expr_stmt|;
block|}
else|else
block|{
comment|/* Must be 5 */
name|val
operator||=
name|MR1_5_BITS
expr_stmt|;
block|}
comment|/* 	 * Enable H/W RTS/CTS handshaking. The default TA/MTA is 	 * a DCE, hence the reverse sense of RTS and CTS 	 */
comment|/* Input Flow - CTS is raised when port is ready to receive data */
if|if
condition|(
name|cflag
operator|&
name|CRTS_IFLOW
condition|)
name|val
operator||=
name|MR1_CTSCONT
expr_stmt|;
name|ccbp
operator|->
name|hi_mr1
operator|=
name|val
expr_stmt|;
comment|/* ========== set hi_mask ========== */
name|val
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS8
operator|)
operator|==
name|CS8
condition|)
block|{
comment|/* 8 data bits? */
name|val
operator|&=
literal|0xFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS7
operator|)
operator|==
name|CS7
condition|)
block|{
comment|/* 7 data bits? */
name|val
operator|&=
literal|0x7F
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cflag
operator|&
name|CS6
operator|)
operator|==
name|CS6
condition|)
block|{
comment|/* 6 data bits? */
name|val
operator|&=
literal|0x3F
expr_stmt|;
block|}
else|else
block|{
comment|/* Must be 5 */
name|val
operator|&=
literal|0x1F
expr_stmt|;
block|}
if|if
condition|(
name|iflag
operator|&
name|ISTRIP
condition|)
name|val
operator|&=
literal|0x7F
expr_stmt|;
name|ccbp
operator|->
name|hi_mask
operator|=
name|val
expr_stmt|;
comment|/* ========== set hi_prtcl ========== */
name|val
operator|=
literal|0
expr_stmt|;
comment|/* Monitor DCD etc. if a modem */
if|if
condition|(
operator|!
operator|(
name|cflag
operator|&
name|CLOCAL
operator|)
condition|)
name|val
operator||=
name|SP_DCEN
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IXANY
condition|)
name|val
operator||=
name|SP_TANY
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IXON
condition|)
name|val
operator||=
name|SP_TXEN
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IXOFF
condition|)
name|val
operator||=
name|SP_RXEN
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|INPCK
condition|)
name|val
operator||=
name|SP_PAEN
expr_stmt|;
name|ccbp
operator|->
name|hi_prtcl
operator|=
name|val
expr_stmt|;
comment|/* ========== set hi_{rx|tx}{on|off} ========== */
comment|/* XXX: the card TOTALLY shields us from the flow control... */
name|ccbp
operator|->
name|hi_txon
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
expr_stmt|;
name|ccbp
operator|->
name|hi_txoff
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
expr_stmt|;
name|ccbp
operator|->
name|hi_rxon
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
expr_stmt|;
name|ccbp
operator|->
name|hi_rxoff
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
expr_stmt|;
comment|/* ========== send settings to the card ========== */
comment|/* potential sleep here */
if|if
condition|(
name|ccbp
operator|->
name|hi_stat
operator|==
name|IDLE_CLOSE
condition|)
comment|/* Not yet open */
name|si_command
argument_list|(
name|pp
argument_list|,
name|LOPEN
argument_list|,
name|SI_WAIT
argument_list|)
expr_stmt|;
comment|/* open it */
else|else
name|si_command
argument_list|(
name|pp
argument_list|,
name|CONFIG
argument_list|,
name|SI_WAIT
argument_list|)
expr_stmt|;
comment|/* change params */
comment|/* ========== set DTR etc ========== */
comment|/* Hangup if ospeed == 0 */
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|si_modem
argument_list|(
name|pp
argument_list|,
name|BIC
argument_list|,
name|TIOCM_DTR
operator||
name|TIOCM_RTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If the previous speed was 0, may need to re-enable 	 	 * the modem signals 	 	 */
operator|(
name|void
operator|)
name|si_modem
argument_list|(
name|pp
argument_list|,
name|SET
argument_list|,
name|TIOCM_DTR
operator||
name|TIOCM_RTS
argument_list|)
expr_stmt|;
block|}
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_PARAM
operator|,
literal|"siparam, complete: MR1 %x MR2 %x HI_MASK %x PRTCL %x HI_BREAK %x\n"
operator|,
name|ccbp
operator|->
name|hi_mr1
operator|,
name|ccbp
operator|->
name|hi_mr2
operator|,
name|ccbp
operator|->
name|hi_mask
operator|,
name|ccbp
operator|->
name|hi_prtcl
operator|,
name|ccbp
operator|->
name|hi_break
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable or Disable the writes to this channel...  * "state" ->  enabled = 1; disabled = 0;  */
end_comment

begin_function
specifier|static
name|void
name|si_write_enable
parameter_list|(
name|pp
parameter_list|,
name|state
parameter_list|)
specifier|register
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
name|int
name|state
decl_stmt|;
block|{
name|int
name|oldspl
decl_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SS_BLOCKWRITE
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sp_state
operator|&
name|SS_WAITWRITE
condition|)
block|{
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SS_WAITWRITE
expr_stmt|;
comment|/* thunder away! */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pp
operator|->
name|sp_state
operator||=
name|SS_BLOCKWRITE
expr_stmt|;
block|}
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set/Get state of modem control lines.  * Due to DCE-like behaviour of the adapter, some signals need translation:  *	TIOCM_DTR	DSR  *	TIOCM_RTS	CTS  */
end_comment

begin_function
specifier|static
name|int
name|si_modem
parameter_list|(
name|pp
parameter_list|,
name|cmd
parameter_list|,
name|bits
parameter_list|)
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
name|enum
name|si_mctl
name|cmd
decl_stmt|;
name|int
name|bits
decl_stmt|;
block|{
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
name|int
name|x
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_MODEM
operator|,
literal|"si_modem(%x,%s,%x)\n"
operator|,
name|pp
operator|,
name|si_mctl2str
argument_list|(
name|cmd
argument_list|)
operator|,
name|bits
operator|)
argument_list|)
expr_stmt|;
name|ccbp
operator|=
name|pp
operator|->
name|sp_ccb
expr_stmt|;
comment|/* Find channel address */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|GET
case|:
name|x
operator|=
name|ccbp
operator|->
name|hi_ip
expr_stmt|;
name|bits
operator|=
name|TIOCM_LE
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|IP_DCD
condition|)
name|bits
operator||=
name|TIOCM_CAR
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|IP_DTR
condition|)
name|bits
operator||=
name|TIOCM_DTR
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|IP_RTS
condition|)
name|bits
operator||=
name|TIOCM_RTS
expr_stmt|;
if|if
condition|(
name|x
operator|&
name|IP_RI
condition|)
name|bits
operator||=
name|TIOCM_RI
expr_stmt|;
return|return
operator|(
name|bits
operator|)
return|;
case|case
name|SET
case|:
name|ccbp
operator|->
name|hi_op
operator|&=
operator|~
operator|(
name|OP_DSR
operator||
name|OP_CTS
operator|)
expr_stmt|;
comment|/* fall through */
case|case
name|BIS
case|:
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|TIOCM_DTR
condition|)
name|x
operator||=
name|OP_DSR
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|TIOCM_RTS
condition|)
name|x
operator||=
name|OP_CTS
expr_stmt|;
name|ccbp
operator|->
name|hi_op
operator||=
name|x
expr_stmt|;
break|break;
case|case
name|BIC
case|:
if|if
condition|(
name|bits
operator|&
name|TIOCM_DTR
condition|)
name|ccbp
operator|->
name|hi_op
operator|&=
operator|~
name|OP_DSR
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|TIOCM_RTS
condition|)
name|ccbp
operator|->
name|hi_op
operator|&=
operator|~
name|OP_CTS
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Handle change of modem state  */
end_comment

begin_function
specifier|static
name|void
name|si_modem_state
parameter_list|(
name|pp
parameter_list|,
name|tp
parameter_list|,
name|hi_ip
parameter_list|)
specifier|register
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|hi_ip
decl_stmt|;
block|{
comment|/* if a modem dev */
if|if
condition|(
name|hi_ip
operator|&
name|IP_DCD
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|pp
operator|->
name|sp_last_hi_ip
operator|&
name|IP_DCD
operator|)
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"modem carr on t_line %d\n"
operator|,
name|tp
operator|->
name|t_line
operator|)
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pp
operator|->
name|sp_last_hi_ip
operator|&
name|IP_DCD
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"modem carr off\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|0
operator|)
condition|)
operator|(
name|void
operator|)
name|si_modem
argument_list|(
name|pp
argument_list|,
name|SET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|pp
operator|->
name|sp_last_hi_ip
operator|=
name|hi_ip
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Poller to catch missed interrupts.  *  * Note that the SYSV Specialix drivers poll at 100 times per second to get  * better response.  We could really use a "periodic" version timeout(). :-)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|POLL
end_ifdef

begin_function
specifier|static
name|void
name|si_poll
parameter_list|(
name|void
modifier|*
name|nothing
parameter_list|)
block|{
specifier|register
name|struct
name|si_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|volatile
name|struct
name|si_reg
modifier|*
name|regp
decl_stmt|;
specifier|register
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
name|int
name|lost
decl_stmt|,
name|oldspl
decl_stmt|,
name|port
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
name|DBG_POLL
operator|,
literal|"si_poll()\n"
operator|)
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|in_intr
condition|)
goto|goto
name|out
goto|;
name|lost
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NSI
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|=
operator|&
name|si_softc
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_type
operator|==
name|SIEMPTY
condition|)
continue|continue;
name|regp
operator|=
operator|(
expr|struct
name|si_reg
operator|*
operator|)
name|sc
operator|->
name|sc_maddr
expr_stmt|;
comment|/* 		 * See if there has been a pending interrupt for 2 seconds 		 * or so. The test<int_scounter>= 200) won't correspond 		 * to 2 seconds if int_count gets changed. 		 */
if|if
condition|(
name|regp
operator|->
name|int_pending
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|regp
operator|->
name|int_scounter
operator|>=
literal|200
operator|&&
name|regp
operator|->
name|initstat
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"si%d: lost intr\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lost
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|regp
operator|->
name|int_scounter
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * gripe about no input flow control.. 		 */
name|pp
operator|=
name|sc
operator|->
name|sc_ports
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|sc
operator|->
name|sc_nport
condition|;
name|pp
operator|++
operator|,
name|port
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|sp_delta_overflows
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"si%d: %d tty level buffer overflows\n"
argument_list|,
name|i
argument_list|,
name|pp
operator|->
name|sp_delta_overflows
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sp_delta_overflows
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lost
operator|||
name|si_realpoll
condition|)
name|siintr
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* call intr with fake vector */
name|out
label|:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|si_poll
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0L
argument_list|,
name|si_pollrate
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ifdef POLL */
end_comment

begin_comment
comment|/*  * The interrupt handler polls ALL ports on ALL adapters each time  * it is called.  */
end_comment

begin_decl_stmt
specifier|static
name|BYTE
name|si_rxbuf
index|[
name|SI_BUFFERSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input staging area */
end_comment

begin_function
name|void
name|siintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|si_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|volatile
name|caddr_t
name|maddr
decl_stmt|;
name|BYTE
name|op
decl_stmt|,
name|ip
decl_stmt|;
name|int
name|x
decl_stmt|,
name|card
decl_stmt|,
name|port
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|,
name|isopen
decl_stmt|;
specifier|volatile
name|BYTE
modifier|*
name|z
decl_stmt|;
name|BYTE
name|c
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
operator|(
name|unit
operator|<
literal|0
operator|)
condition|?
name|DBG_POLL
else|:
name|DBG_INTR
operator|,
literal|"siintr(%d)\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_intr
condition|)
block|{
if|if
condition|(
name|unit
operator|<
literal|0
condition|)
comment|/* should never happen */
return|return;
name|printf
argument_list|(
literal|"si%d: Warning interrupt handler re-entered\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|in_intr
operator|=
literal|1
expr_stmt|;
comment|/* 	 * When we get an int we poll all the channels and do ALL pending 	 * work, not just the first one we find. This allows all cards to 	 * share the same vector. 	 */
for|for
control|(
name|card
operator|=
literal|0
init|;
name|card
operator|<
name|NSI
condition|;
name|card
operator|++
control|)
block|{
name|sc
operator|=
operator|&
name|si_softc
index|[
name|card
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_type
operator|==
name|SIEMPTY
condition|)
continue|continue;
comment|/* 		 * First, clear the interrupt 		 */
switch|switch
condition|(
name|sc
operator|->
name|sc_type
condition|)
block|{
case|case
name|SIHOST
case|:
name|maddr
operator|=
name|sc
operator|->
name|sc_maddr
expr_stmt|;
operator|(
operator|(
specifier|volatile
expr|struct
name|si_reg
operator|*
operator|)
name|maddr
operator|)
operator|->
name|int_pending
operator|=
literal|0
expr_stmt|;
comment|/* flag nothing pending */
operator|*
operator|(
name|maddr
operator|+
name|SIINTCL
operator|)
operator|=
literal|0x00
expr_stmt|;
comment|/* Set IRQ clear */
operator|*
operator|(
name|maddr
operator|+
name|SIINTCL_CL
operator|)
operator|=
literal|0x00
expr_stmt|;
comment|/* Clear IRQ clear */
break|break;
case|case
name|SIHOST2
case|:
name|maddr
operator|=
name|sc
operator|->
name|sc_maddr
expr_stmt|;
operator|(
operator|(
specifier|volatile
expr|struct
name|si_reg
operator|*
operator|)
name|maddr
operator|)
operator|->
name|int_pending
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQCLR
operator|)
operator|=
literal|0x00
expr_stmt|;
operator|*
operator|(
name|maddr
operator|+
name|SIPLIRQCLR
operator|)
operator|=
literal|0x10
expr_stmt|;
break|break;
case|case
name|SIEISA
case|:
if|#
directive|if
name|NEISA
operator|>
literal|0
name|maddr
operator|=
name|sc
operator|->
name|sc_maddr
expr_stmt|;
operator|(
operator|(
specifier|volatile
expr|struct
name|si_reg
operator|*
operator|)
name|maddr
operator|)
operator|->
name|int_pending
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|sc_eisa_iobase
operator|+
literal|3
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* fall through if not EISA kernel */
case|case
name|SIEMPTY
case|:
default|default:
continue|continue;
block|}
operator|(
operator|(
specifier|volatile
expr|struct
name|si_reg
operator|*
operator|)
name|maddr
operator|)
operator|->
name|int_scounter
operator|=
literal|0
expr_stmt|;
comment|/* 		 * check each port 		 */
for|for
control|(
name|pp
operator|=
name|sc
operator|->
name|sc_ports
operator|,
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|sc
operator|->
name|sc_nport
condition|;
name|pp
operator|++
operator|,
name|port
operator|++
control|)
block|{
name|ccbp
operator|=
name|pp
operator|->
name|sp_ccb
expr_stmt|;
name|tp
operator|=
name|pp
operator|->
name|sp_tty
expr_stmt|;
comment|/* 			 * See if a command has completed ? 			 */
if|if
condition|(
name|ccbp
operator|->
name|hi_stat
operator|!=
name|pp
operator|->
name|sp_pend
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"siintr hi_stat = 0x%x, pend = %d\n"
operator|,
name|ccbp
operator|->
name|hi_stat
operator|,
name|pp
operator|->
name|sp_pend
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pp
operator|->
name|sp_pend
condition|)
block|{
case|case
name|LOPEN
case|:
case|case
name|MPEND
case|:
case|case
name|MOPEN
case|:
case|case
name|CONFIG
case|:
case|case
name|SBREAK
case|:
case|case
name|EBREAK
case|:
name|pp
operator|->
name|sp_pend
operator|=
name|ccbp
operator|->
name|hi_stat
expr_stmt|;
comment|/* sleeping in si_command */
name|wakeup
argument_list|(
operator|&
name|pp
operator|->
name|sp_state
argument_list|)
expr_stmt|;
break|break;
default|default:
name|pp
operator|->
name|sp_pend
operator|=
name|ccbp
operator|->
name|hi_stat
expr_stmt|;
block|}
block|}
comment|/* 			 * Continue on if it's closed 			 */
if|if
condition|(
name|ccbp
operator|->
name|hi_stat
operator|==
name|IDLE_CLOSE
condition|)
block|{
continue|continue;
block|}
comment|/* 			 * Do modem state change if not a local device 			 */
name|si_modem_state
argument_list|(
name|pp
argument_list|,
name|tp
argument_list|,
name|ccbp
operator|->
name|hi_ip
argument_list|)
expr_stmt|;
comment|/* 			 * Check to see if there's we should 'receive' 			 * characters. 			 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CONNECTED
operator|&&
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
name|isopen
operator|=
literal|1
expr_stmt|;
else|else
name|isopen
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Do input break processing 			 */
if|if
condition|(
name|ccbp
operator|->
name|hi_state
operator|&
name|ST_BREAK
condition|)
block|{
if|if
condition|(
name|isopen
condition|)
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|TTY_BI
operator|,
name|tp
operator|)
expr_stmt|;
block|}
name|ccbp
operator|->
name|hi_state
operator|&=
operator|~
name|ST_BREAK
expr_stmt|;
comment|/* A Bit iffy this */
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"si_intr break\n"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Do RX stuff - if not open then dump any characters. 			 * XXX: This is VERY messy and needs to be cleaned up. 			 * 			 * XXX: can we leave data in the host adapter buffer 			 * when the clists are full?  That may be dangerous 			 * if the user cannot get an interrupt signal through. 			 */
name|more_rx
label|:
comment|/* XXX Sorry. the nesting was driving me bats! :-( */
if|if
condition|(
operator|!
name|isopen
condition|)
block|{
name|ccbp
operator|->
name|hi_rxopos
operator|=
name|ccbp
operator|->
name|hi_rxipos
expr_stmt|;
goto|goto
name|end_rx
goto|;
block|}
comment|/* 			 * If the tty input buffers are blocked, stop emptying 			 * the incoming buffers and let the auto flow control 			 * assert.. 			 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
condition|)
block|{
goto|goto
name|end_rx
goto|;
block|}
comment|/* 			 * Process read characters if not skipped above 			 */
name|op
operator|=
name|ccbp
operator|->
name|hi_rxopos
expr_stmt|;
name|ip
operator|=
name|ccbp
operator|->
name|hi_rxipos
expr_stmt|;
name|c
operator|=
name|ip
operator|-
name|op
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
goto|goto
name|end_rx
goto|;
block|}
name|n
operator|=
name|c
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|250
condition|)
name|n
operator|=
literal|250
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"n = %d, op = %d, ip = %d\n"
operator|,
name|n
operator|,
name|op
operator|,
name|ip
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Suck characters out of host card buffer into the 			 * "input staging buffer" - so that we dont leave the 			 * host card in limbo while we're possibly echoing 			 * characters and possibly flushing input inside the 			 * ldisc l_rint() routine. 			 */
if|if
condition|(
name|n
operator|<=
name|SI_BUFFERSIZE
operator|-
name|op
condition|)
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"\tsingle copy\n"
operator|)
argument_list|)
expr_stmt|;
name|z
operator|=
name|ccbp
operator|->
name|hi_rxbuf
operator|+
name|op
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|z
argument_list|,
name|si_rxbuf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|op
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|SI_BUFFERSIZE
operator|-
name|op
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"\tdouble part 1 %d\n"
operator|,
name|x
operator|)
argument_list|)
expr_stmt|;
name|z
operator|=
name|ccbp
operator|->
name|hi_rxbuf
operator|+
name|op
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|z
argument_list|,
name|si_rxbuf
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"\tdouble part 2 %d\n"
operator|,
name|n
operator|-
name|x
operator|)
argument_list|)
expr_stmt|;
name|z
operator|=
name|ccbp
operator|->
name|hi_rxbuf
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|z
argument_list|,
name|si_rxbuf
operator|+
name|x
argument_list|,
name|n
operator|-
name|x
argument_list|)
expr_stmt|;
name|op
operator|+=
name|n
expr_stmt|;
block|}
comment|/* clear collected characters from buffer */
name|ccbp
operator|->
name|hi_rxopos
operator|=
name|op
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_INTR
operator|,
literal|"n = %d, op = %d, ip = %d\n"
operator|,
name|n
operator|,
name|op
operator|,
name|ip
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * at this point... 			 * n = number of chars placed in si_rxbuf 			 */
comment|/* 			 * Avoid the grotesquely inefficient lineswitch 			 * routine (ttyinput) in "raw" mode. It usually 			 * takes about 450 instructions (that's without 			 * canonical processing or echo!). slinput is 			 * reasonably fast (usually 40 instructions 			 * plus call overhead). 			 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
condition|)
block|{
comment|/* block if the driver supports it */
if|if
condition|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|n
operator|>=
name|SI_I_HIGH_WATER
operator|&&
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CRTS_IFLOW
operator|||
name|tp
operator|->
name|t_iflag
operator|&
name|IXOFF
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
condition|)
name|ttyblock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tk_nin
operator|+=
name|n
expr_stmt|;
name|tk_rawcc
operator|+=
name|n
expr_stmt|;
name|tp
operator|->
name|t_rawcc
operator|+=
name|n
expr_stmt|;
name|pp
operator|->
name|sp_delta_overflows
operator|+=
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
name|si_rxbuf
argument_list|,
name|n
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|&&
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXANY
operator|||
name|tp
operator|->
name|t_cc
index|[
name|VSTART
index|]
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VSTOP
index|]
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_TTSTOP
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|&=
operator|~
name|FLUSHO
expr_stmt|;
name|si_start
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * It'd be nice to not have to go through the 				 * function call overhead for each char here. 				 * It'd be nice to block input it, saving a 				 * loop here and the call/return overhead. 				 */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|n
condition|;
name|x
operator|++
control|)
block|{
name|i
operator|=
name|si_rxbuf
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|i
operator|,
name|tp
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pp
operator|->
name|sp_delta_overflows
operator|++
expr_stmt|;
block|}
comment|/* 					 * doesn't seem to be much point doing 					 * this here.. this driver has no 					 * softtty processing! ?? 					 */
if|if
condition|(
name|pp
operator|->
name|sp_hotchar
operator|&&
name|i
operator|==
name|pp
operator|->
name|sp_hotchar
condition|)
block|{
name|setsofttty
argument_list|()
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|more_rx
goto|;
comment|/* try for more until RXbuf is empty */
name|end_rx
label|:
comment|/* XXX: Again, sorry about the gotos.. :-) */
comment|/* 			 * Do TX stuff 			 */
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
block|}
comment|/* end of for (all ports on this controller) */
block|}
comment|/* end of for (all controllers) */
name|in_intr
operator|=
literal|0
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|0
operator|,
operator|(
name|unit
operator|<
literal|0
operator|)
condition|?
name|DBG_POLL
else|:
name|DBG_INTR
operator|,
literal|"end siintr(%d)\n"
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Nudge the transmitter...  *  * XXX: I inherited some funny code here.  It implies the host card only  * interrupts when the transmit buffer reaches the low-water-mark, and does  * not interrupt when it's actually hits empty.  In some cases, we have  * processes waiting for complete drain, and we need to simulate an interrupt  * about when we think the buffer is going to be empty (and retry if not).  * I really am not certain about this...  I *need* the hardware manuals.  */
end_comment

begin_function
specifier|static
name|void
name|si_start
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
specifier|register
name|struct
name|clist
modifier|*
name|qp
decl_stmt|;
name|BYTE
name|ipos
decl_stmt|;
name|int
name|nchar
decl_stmt|;
name|int
name|oldspl
decl_stmt|,
name|count
decl_stmt|,
name|n
decl_stmt|,
name|amount
decl_stmt|,
name|buffer_full
decl_stmt|;
name|int
name|do_exitproc
decl_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|qp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
name|pp
operator|=
name|TP2PP
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_START
operator|,
literal|"si_start(%x) t_state %x sp_state %x t_outq.c_cc %d\n"
operator|,
name|tp
operator|,
name|tp
operator|->
name|t_state
operator|,
name|pp
operator|->
name|sp_state
operator|,
name|qp
operator|->
name|c_cc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
name|do_exitproc
operator|=
literal|0
expr_stmt|;
name|buffer_full
operator|=
literal|0
expr_stmt|;
name|ccbp
operator|=
name|pp
operator|->
name|sp_ccb
expr_stmt|;
comment|/* 	 * Handle the case where ttywait() is called on process exit 	 * this may be BSDI specific, I dont know... 	 */
if|if
condition|(
name|tp
operator|->
name|t_session
operator|!=
name|NULL
operator|&&
name|tp
operator|->
name|t_session
operator|->
name|s_leader
operator|!=
name|NULL
operator|&&
operator|(
name|tp
operator|->
name|t_session
operator|->
name|s_leader
operator|->
name|p_flag
operator|&
name|P_WEXIT
operator|)
condition|)
block|{
name|do_exitproc
operator|++
expr_stmt|;
block|}
name|count
operator|=
operator|(
name|int
operator|)
name|ccbp
operator|->
name|hi_txipos
operator|-
operator|(
name|int
operator|)
name|ccbp
operator|->
name|hi_txopos
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_START
operator|,
literal|"count %d\n"
operator|,
operator|(
name|BYTE
operator|)
name|count
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nchar
operator|=
name|qp
operator|->
name|c_cc
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|BYTE
operator|)
name|count
operator|>=
literal|255
condition|)
block|{
name|buffer_full
operator|++
expr_stmt|;
break|break;
block|}
name|amount
operator|=
name|min
argument_list|(
name|nchar
argument_list|,
operator|(
literal|255
operator|-
operator|(
name|BYTE
operator|)
name|count
operator|)
argument_list|)
expr_stmt|;
name|ipos
operator|=
operator|(
name|unsigned
name|int
operator|)
name|ccbp
operator|->
name|hi_txipos
expr_stmt|;
comment|/* will it fit in one lump? */
if|if
condition|(
operator|(
name|SI_BUFFERSIZE
operator|-
name|ipos
operator|)
operator|>=
name|amount
condition|)
block|{
name|n
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ccbp
operator|->
name|hi_txbuf
index|[
name|ipos
index|]
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ccbp
operator|->
name|hi_txbuf
index|[
name|ipos
index|]
argument_list|,
name|SI_BUFFERSIZE
operator|-
name|ipos
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|SI_BUFFERSIZE
operator|-
name|ipos
condition|)
block|{
name|n
operator|+=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ccbp
operator|->
name|hi_txbuf
index|[
literal|0
index|]
argument_list|,
name|amount
operator|-
operator|(
name|SI_BUFFERSIZE
operator|-
name|ipos
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ccbp
operator|->
name|hi_txipos
operator|+=
name|n
expr_stmt|;
name|count
operator|=
operator|(
name|int
operator|)
name|ccbp
operator|->
name|hi_txipos
operator|-
operator|(
name|int
operator|)
name|ccbp
operator|->
name|hi_txopos
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
name|nchar
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
block|}
comment|/* wakeup time? */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_START
operator|,
literal|"count %d, nchar %d, tp->t_state 0x%x\n"
operator|,
operator|(
name|BYTE
operator|)
name|count
operator|,
name|nchar
operator|,
name|tp
operator|->
name|t_state
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
operator|)
operator|||
name|do_exitproc
condition|)
block|{
name|int
name|time
decl_stmt|;
if|if
condition|(
name|do_exitproc
operator|!=
literal|0
condition|)
block|{
name|time
operator|=
name|hz
operator|/
literal|10
expr_stmt|;
block|}
else|else
block|{
name|time
operator|=
name|ttspeedtab
argument_list|(
name|tp
operator|->
name|t_ospeed
argument_list|,
name|chartimes
argument_list|)
expr_stmt|;
if|if
condition|(
name|time
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|time
operator|<
name|nchar
condition|)
name|time
operator|=
name|nchar
operator|/
name|time
expr_stmt|;
else|else
name|time
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_START
operator|,
literal|"bad char time value! %d\n"
operator|,
name|time
operator|)
argument_list|)
expr_stmt|;
name|time
operator|=
name|hz
operator|/
literal|10
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|pp
operator|->
name|sp_state
operator|&
operator|(
name|SS_LSTART
operator||
name|SS_INLSTART
operator|)
operator|)
operator|==
name|SS_LSTART
condition|)
block|{
name|untimeout
argument_list|(
name|si_lstart
argument_list|,
operator|(
name|caddr_t
operator|)
name|pp
argument_list|,
name|pp
operator|->
name|lstart_ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|sp_state
operator||=
name|SS_LSTART
expr_stmt|;
block|}
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_START
operator|,
literal|"arming lstart, time=%d\n"
operator|,
name|time
operator|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|lstart_ch
operator|=
name|timeout
argument_list|(
name|si_lstart
argument_list|,
operator|(
name|caddr_t
operator|)
name|pp
argument_list|,
name|time
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_EXIT
operator||
name|DBG_START
operator|,
literal|"leave si_start()\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note: called at splsoftclock from the timeout code  * This has to deal with two things...  cause wakeups while waiting for  * tty drains on last process exit, and call l_start at about the right  * time for protocols like ppp.  */
end_comment

begin_function
specifier|static
name|void
name|si_lstart
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|register
name|struct
name|si_port
modifier|*
name|pp
init|=
name|arg
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|oldspl
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_LSTART
operator|,
literal|"si_lstart(%x) sp_state %x\n"
operator|,
name|pp
operator|,
name|pp
operator|->
name|sp_state
operator|)
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|->
name|sp_state
operator|&
name|SS_OPEN
operator|)
operator|==
literal|0
operator|||
operator|(
name|pp
operator|->
name|sp_state
operator|&
name|SS_LSTART
operator|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SS_LSTART
expr_stmt|;
name|pp
operator|->
name|sp_state
operator||=
name|SS_INLSTART
expr_stmt|;
name|tp
operator|=
name|pp
operator|->
name|sp_tty
expr_stmt|;
comment|/* deal with the process exit case */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* nudge protocols - eg: ppp */
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
name|pp
operator|->
name|sp_state
operator|&=
operator|~
name|SS_INLSTART
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop output on a line. called at spltty();  */
end_comment

begin_function
name|void
name|sistop
parameter_list|(
name|tp
parameter_list|,
name|rw
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|rw
decl_stmt|;
block|{
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
decl_stmt|;
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|TP2PP
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ccbp
operator|=
name|pp
operator|->
name|sp_ccb
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|TP2PP
argument_list|(
name|tp
argument_list|)
operator|,
name|DBG_ENTRY
operator||
name|DBG_STOP
operator|,
literal|"sistop(%x,%x)\n"
operator|,
name|tp
operator|,
name|rw
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX: must check (rw& FWRITE | FREAD) etc flushing... */
if|if
condition|(
name|rw
operator|&
name|FWRITE
condition|)
block|{
comment|/* what level are we meant to be flushing anyway? */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|si_command
argument_list|(
name|TP2PP
argument_list|(
name|tp
argument_list|)
argument_list|,
name|WFLUSH
argument_list|,
name|SI_NOWAIT
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Bruce???? */
block|}
block|}
if|#
directive|if
literal|1
comment|/* XXX: this doesn't work right yet.. */
comment|/* XXX: this may have been failing because we used to call l_rint() 	 * while we were looping based on these two counters. Now, we collect 	 * the data and then loop stuffing it into l_rint(), making this 	 * useless.  Should we cause this to blow away the staging buffer? 	 */
if|if
condition|(
name|rw
operator|&
name|FREAD
condition|)
block|{
name|ccbp
operator|->
name|hi_rxopos
operator|=
name|ccbp
operator|->
name|hi_rxipos
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Issue a command to the Z280 host card CPU.  */
end_comment

begin_function
specifier|static
name|void
name|si_command
parameter_list|(
name|pp
parameter_list|,
name|cmd
parameter_list|,
name|waitflag
parameter_list|)
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
comment|/* port control block (local) */
name|int
name|cmd
decl_stmt|;
name|int
name|waitflag
decl_stmt|;
block|{
name|int
name|oldspl
decl_stmt|;
specifier|volatile
name|struct
name|si_channel
modifier|*
name|ccbp
init|=
name|pp
operator|->
name|sp_ccb
decl_stmt|;
name|int
name|x
decl_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_ENTRY
operator||
name|DBG_PARAM
operator|,
literal|"si_command(%x,%x,%d): hi_stat 0x%x\n"
operator|,
name|pp
operator|,
name|cmd
operator|,
name|waitflag
operator|,
name|ccbp
operator|->
name|hi_stat
operator|)
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* Keep others out */
comment|/* wait until it's finished what it was doing.. */
comment|/* XXX: sits in IDLE_BREAK until something disturbs it or break 	 * is turned off. */
while|while
condition|(
operator|(
name|x
operator|=
name|ccbp
operator|->
name|hi_stat
operator|)
operator|!=
name|IDLE_OPEN
operator|&&
name|x
operator|!=
name|IDLE_CLOSE
operator|&&
name|x
operator|!=
name|IDLE_BREAK
operator|&&
name|x
operator|!=
name|cmd
condition|)
block|{
if|if
condition|(
name|in_intr
condition|)
block|{
comment|/* Prevent sleep in intr */
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_PARAM
operator|,
literal|"cmd intr collision - completing %d\trequested %d\n"
operator|,
name|x
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|ttysleep
argument_list|(
name|pp
operator|->
name|sp_tty
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|pp
operator|->
name|sp_state
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"sicmd1"
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* it should now be in IDLE_{OPEN|CLOSE|BREAK}, or "cmd" */
comment|/* if there was a pending command, cause a state-change wakeup */
switch|switch
condition|(
name|pp
operator|->
name|sp_pend
condition|)
block|{
case|case
name|LOPEN
case|:
case|case
name|MPEND
case|:
case|case
name|MOPEN
case|:
case|case
name|CONFIG
case|:
case|case
name|SBREAK
case|:
case|case
name|EBREAK
case|:
name|wakeup
argument_list|(
operator|&
name|pp
operator|->
name|sp_state
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|pp
operator|->
name|sp_pend
operator|=
name|cmd
expr_stmt|;
comment|/* New command pending */
name|ccbp
operator|->
name|hi_stat
operator|=
name|cmd
expr_stmt|;
comment|/* Post it */
if|if
condition|(
name|waitflag
condition|)
block|{
if|if
condition|(
name|in_intr
condition|)
block|{
comment|/* If in interrupt handler */
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_PARAM
operator|,
literal|"attempt to sleep in si_intr - cmd req %d\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
while|while
condition|(
name|ccbp
operator|->
name|hi_stat
operator|!=
name|IDLE_OPEN
operator|&&
name|ccbp
operator|->
name|hi_stat
operator|!=
name|IDLE_BREAK
condition|)
block|{
if|if
condition|(
name|ttysleep
argument_list|(
name|pp
operator|->
name|sp_tty
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|pp
operator|->
name|sp_state
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"sicmd2"
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
block|}
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|si_disc_optim
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|,
name|pp
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
block|{
comment|/* 	 * XXX can skip a lot more cases if Smarts.  Maybe 	 * (IGNCR | ISTRIP | IXON) in c_iflag.  But perhaps we 	 * shouldn't skip if (TS_CNTTB | TS_LNCH) is set in t_state. 	 */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|ICRNL
operator||
name|IGNCR
operator||
name|IMAXBEL
operator||
name|INLCR
operator||
name|ISTRIP
operator||
name|IXON
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|BRKINT
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|IGNBRK
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|PARMRK
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|==
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|&&
operator|!
operator|(
name|t
operator|->
name|c_lflag
operator|&
operator|(
name|ECHO
operator||
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
operator||
name|PENDIN
operator|)
operator|)
operator|&&
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|==
name|ttyinput
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
name|pp
operator|->
name|sp_hotchar
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_hotchar
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
name|pp
operator|,
name|DBG_OPTIM
operator|,
literal|"bypass: %s, hotchar: %x\n"
operator|,
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
operator|)
condition|?
literal|"on"
else|:
literal|"off"
operator|,
name|pp
operator|->
name|sp_hotchar
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SI_DEBUG
end_ifdef

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|si_dprintf
parameter_list|(
name|struct
name|si_port
modifier|*
name|pp
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|si_dprintf
parameter_list|(
name|pp
parameter_list|,
name|flags
parameter_list|,
name|fmt
parameter_list|,
name|va_alist
parameter_list|)
name|struct
name|si_port
modifier|*
name|pp
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
modifier|*
name|fmt
decl_stmt|;
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|(
name|pp
operator|==
name|NULL
operator|&&
operator|(
name|si_debug
operator|&
name|flags
operator|)
operator|)
operator|||
operator|(
name|pp
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|pp
operator|->
name|sp_debug
operator|&
name|flags
operator|)
operator|||
operator|(
name|si_debug
operator|&
name|flags
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%ci%d(%d): "
argument_list|,
literal|'s'
argument_list|,
operator|(
name|int
operator|)
name|SI_CARD
argument_list|(
name|pp
operator|->
name|sp_tty
operator|->
name|t_dev
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|SI_PORT
argument_list|(
name|pp
operator|->
name|sp_tty
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|si_mctl2str
parameter_list|(
name|cmd
parameter_list|)
name|enum
name|si_mctl
name|cmd
decl_stmt|;
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|GET
case|:
return|return
operator|(
literal|"GET"
operator|)
return|;
case|case
name|SET
case|:
return|return
operator|(
literal|"SET"
operator|)
return|;
case|case
name|BIS
case|:
return|return
operator|(
literal|"BIS"
operator|)
return|;
case|case
name|BIC
case|:
return|return
operator|(
literal|"BIC"
operator|)
return|;
block|}
return|return
operator|(
literal|"BAD"
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_expr_stmt
specifier|static
name|si_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|si_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|si_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|si_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|si_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|sidev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|si_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

end_unit

