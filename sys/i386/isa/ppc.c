begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 1998 Nicolas Souchu  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: ppc.c,v 1.4 1998/08/03 19:14:32 msmith Exp $  *  */
end_comment

begin_include
include|#
directive|include
file|"ppc.h"
end_include

begin_if
if|#
directive|if
name|NPPC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppbconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppb_msq.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ppcreg.h>
end_include

begin_function_decl
specifier|static
name|int
name|ppcprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ppcattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|ppcdriver
init|=
block|{
name|ppcprobe
block|,
name|ppcattach
block|,
literal|"ppc"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ppc_data
modifier|*
name|ppcdata
index|[
name|NPPC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nppc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_types
index|[]
init|=
block|{
literal|"SMC-like"
block|,
literal|"SMC FDC37C665GT"
block|,
literal|"SMC FDC37C666GT"
block|,
literal|"PC87332"
block|,
literal|"PC87306"
block|,
literal|"82091AA"
block|,
literal|"Generic"
block|,
literal|"W83877F"
block|,
literal|"W83877AF"
block|,
literal|"Winbond"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of available modes */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_avms
index|[]
init|=
block|{
literal|"COMPATIBLE"
block|,
literal|"NIBBLE-only"
block|,
literal|"PS2-only"
block|,
literal|"PS2/NIBBLE"
block|,
literal|"EPP-only"
block|,
literal|"EPP/NIBBLE"
block|,
literal|"EPP/PS2"
block|,
literal|"EPP/PS2/NIBBLE"
block|,
literal|"ECP-only"
block|,
literal|"ECP/NIBBLE"
block|,
literal|"ECP/PS2"
block|,
literal|"ECP/PS2/NIBBLE"
block|,
literal|"ECP/EPP"
block|,
literal|"ECP/EPP/NIBBLE"
block|,
literal|"ECP/EPP/PS2"
block|,
literal|"ECP/EPP/PS2/NIBBLE"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of current executing modes  * Note that few modes do not actually exist.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_modes
index|[]
init|=
block|{
literal|"COMPATIBLE"
block|,
literal|"NIBBLE"
block|,
literal|"PS/2"
block|,
literal|"PS/2"
block|,
literal|"EPP"
block|,
literal|"EPP"
block|,
literal|"EPP"
block|,
literal|"EPP"
block|,
literal|"ECP"
block|,
literal|"ECP"
block|,
literal|"ECP+PS2"
block|,
literal|"ECP+PS2"
block|,
literal|"ECP+EPP"
block|,
literal|"ECP+EPP"
block|,
literal|"ECP+EPP"
block|,
literal|"ECP+EPP"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_epp_protocol
index|[]
init|=
block|{
literal|" (EPP 1.9)"
block|,
literal|" (EPP 1.7)"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * BIOS printer list - used by BIOS probe.  */
end_comment

begin_define
define|#
directive|define
name|BIOS_PPC_PORTS
value|0x408
end_define

begin_define
define|#
directive|define
name|BIOS_PORTS
value|(short *)(KERNBASE+BIOS_PPC_PORTS)
end_define

begin_define
define|#
directive|define
name|BIOS_MAX_PPC
value|4
end_define

begin_comment
comment|/*  * All these functions are default actions for IN/OUT operations.  * They may be redefined if needed.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_outsb_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|outsb
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_outsw_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|outsw
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_outsl_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|outsl
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_insb_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|insb
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_insw_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|insw
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_insl_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|insl
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
name|ppc_rdtr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_dtr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|ppc_rstr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_str
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|ppc_rctr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_ctr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|ppc_repp
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_epp
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|ppc_recr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_ecr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|ppc_rfifo
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_fifo
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wdtr
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_dtr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wstr
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_str
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wctr
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_ctr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wepp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_epp
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wecr
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_ecr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wfifo
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_fifo
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|ppc_reset_epp_timeout
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ppc_ecp_sync
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ppc_exec_microseq
parameter_list|(
name|int
parameter_list|,
name|struct
name|ppb_microseq
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ppc_generic_setmode
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ppb_adapter
name|ppc_adapter
init|=
block|{
literal|0
block|,
comment|/* no intr handler, filled by chipset dependent code */
name|ppc_reset_epp_timeout
block|,
name|ppc_ecp_sync
block|,
name|ppc_exec_microseq
block|,
name|ppc_generic_setmode
block|,
name|ppc_outsb_epp
block|,
name|ppc_outsw_epp
block|,
name|ppc_outsl_epp
block|,
name|ppc_insb_epp
block|,
name|ppc_insw_epp
block|,
name|ppc_insl_epp
block|,
name|ppc_rdtr
block|,
name|ppc_rstr
block|,
name|ppc_rctr
block|,
name|ppc_repp
block|,
name|ppc_recr
block|,
name|ppc_rfifo
block|,
name|ppc_wdtr
block|,
name|ppc_wstr
block|,
name|ppc_wctr
block|,
name|ppc_wepp
block|,
name|ppc_wecr
block|,
name|ppc_wfifo
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ppc_ecp_sync()		XXX  */
end_comment

begin_function
specifier|static
name|void
name|ppc_ecp_sync
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
name|r
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
literal|0xe0
operator|)
operator|!=
literal|0x80
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
literal|0x1
condition|)
return|return;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ppc%d: ECP sync failed as data still "
expr|\
literal|"present in FIFO.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ppcintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
comment|/* call directly upper code */
name|ppb_intr
argument_list|(
operator|&
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_link
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_ecp_config
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
comment|/* XXX disable DMA, enable interrupts */
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_EPP
condition|)
comment|/* select EPP mode */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_PS2
condition|)
comment|/* select PS2 mode with ECP */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
else|else
comment|/* keep ECP mode alone, default for NIBBLE */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ppc_detect_port
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|)
block|{
name|w_ctr
argument_list|(
name|ppc
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
comment|/* To avoid missing PS2 ports */
name|w_dtr
argument_list|(
name|ppc
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_dtr
argument_list|(
name|ppc
argument_list|)
operator|!=
operator|(
name|char
operator|)
literal|0xaa
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppc_pc873xx_detect  *  * Probe for a Natsemi PC873xx-family part.  *  * References in this function are to the National Semiconductor  * PC87332 datasheet TL/C/11930, May 1995 revision.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pc873xx_basetab
index|[]
init|=
block|{
literal|0x0398
block|,
literal|0x026e
block|,
literal|0x015c
block|,
literal|0x002e
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pc873xx_porttab
index|[]
init|=
block|{
literal|0x0378
block|,
literal|0x03bc
block|,
literal|0x0278
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ppc_pc873xx_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
comment|/* XXX mode never forced */
block|{
specifier|static
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|base
decl_stmt|,
name|idport
decl_stmt|;
name|int
name|val
decl_stmt|;
while|while
condition|(
operator|(
name|idport
operator|=
name|pc873xx_basetab
index|[
name|index
operator|++
index|]
operator|)
condition|)
block|{
comment|/* XXX should check first to see if this location is already claimed */
comment|/* 	 * Pull the 873xx through the power-on ID cycle (2.2,1.).  We can't use this 	 * to locate the chip as it may already have been used by the BIOS. 	 */
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
comment|/* 	 * Read the SID byte.  Possible values are : 	 * 	 * 0001xxxx	PC87332 	 * 01110xxx	PC87306 	 */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_SID
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0xf0
operator|)
operator|==
literal|0x10
condition|)
block|{
name|ppc
operator|->
name|ppc_type
operator|=
name|NS_PC87332
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0xf8
operator|)
operator|==
literal|0x70
condition|)
block|{
name|ppc
operator|->
name|ppc_type
operator|=
name|NS_PC87306
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
operator|&&
operator|(
name|val
operator|!=
literal|0xff
operator|)
condition|)
name|printf
argument_list|(
literal|"PC873xx probe at 0x%x got unknown ID 0x%x\n"
argument_list|,
name|idport
argument_list|,
name|val
argument_list|)
expr_stmt|;
continue|continue ;
comment|/* not recognised */
block|}
comment|/* 	 * We think we have one.  Is it enabled and where we want it to be?	  	 */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_FER
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PC873_PPENABLE
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx parallel port disabled\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_FAR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
operator|&
literal|0x3
expr_stmt|;
comment|/* XXX we should create a driver instance for every port found */
if|if
condition|(
name|pc873xx_porttab
index|[
name|val
index|]
operator|!=
name|ppc
operator|->
name|ppc_base
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx at 0x%x not for driver at port 0x%x\n"
argument_list|,
name|pc873xx_porttab
index|[
name|val
index|]
argument_list|,
name|ppc
operator|->
name|ppc_base
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*  	 * This is the port we want.  Can we dink with it to improve 	 * our chances? 	 */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PC873_CFGLOCK
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx locked\n"
argument_list|)
expr_stmt|;
comment|/* work out what mode we're in */
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_NIBBLE
expr_stmt|;
comment|/* worst case */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PCR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
name|PC873_EPPEN
operator|)
operator|&&
operator|(
name|val
operator|&
name|PC873_EPP19
operator|)
condition|)
block|{
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PC873_EPPRDIR
operator|)
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_EPP
expr_stmt|;
comment|/* As we would have done it anwyay */
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
name|PC873_ECPEN
operator|)
operator|&&
operator|(
name|val
operator|&
name|PC873_ECPCLK
operator|)
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_PS2
expr_stmt|;
comment|/* tolerable alternative */
block|}
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx unlocked, "
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* broken */
comment|/* 	     * Frob the zero-wait-state option if possible; it causes 	     * unreliable operation. 	     */
block|outb(idport, PC873_FCR); 	    val = inb(idport + 1); 	    if ((ppc->ppc_type == NS_PC87306) ||
comment|/* we are a '306 */
block|!(val& PC873_ZWSPWDN)) {
comment|/* or pin _is_ ZWS */
block|val&= ~PC873_ZWS; 		outb(idport + 1, val);
comment|/* must disable ZWS */
block|outb(idport + 1, val); 		 		if (bootverbose) 		    printf("ZWS %s, ", (val& PC873_ZWS) ? "enabled" : "disabled"); 	    }
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"reconfiguring for "
argument_list|)
expr_stmt|;
comment|/*  	     * if the chip is at 0x3bc, we can't use EPP as there's no room 	     * for the extra registers. 	     * 	     * XXX should we use ECP mode always and use the EPP submode? 	     */
if|if
condition|(
name|ppc
operator|->
name|ppc_base
operator|!=
literal|0x3bc
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"EPP 1.9\n"
argument_list|)
expr_stmt|;
comment|/* configure for EPP 1.9 operation XXX should be configurable */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PCR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
operator|(
name|PC873_ECPEN
operator||
name|PC873_ECPCLK
operator|)
expr_stmt|;
comment|/* disable ECP */
name|val
operator||=
operator|(
name|PC873_EPPEN
operator||
name|PC873_EPP19
operator|)
expr_stmt|;
comment|/* enable EPP */
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* enable automatic direction turnover */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
name|val
operator|&=
operator|~
name|PC873_EPPRDIR
expr_stmt|;
comment|/* disable "regular" direction change */
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* we are an EPP-32 port */
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_EPP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ECP\n"
argument_list|)
expr_stmt|;
comment|/* configure as an ECP port to get bidirectional operation for now */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PCR
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
operator||
name|PC873_ECPEN
operator||
name|PC873_ECPCLK
argument_list|)
expr_stmt|;
comment|/* we look like a PS/2 port */
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_PS2
expr_stmt|;
block|}
block|}
return|return
operator|(
name|chipset_mode
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppc_check_epp_timeout
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|)
block|{
name|ppc_reset_epp_timeout
argument_list|(
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|r_str
argument_list|(
name|ppc
argument_list|)
operator|&
name|TIMEOUT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppc_smc37c66xgt_detect  *  * SMC FDC37C66xGT configuration.  */
end_comment

begin_function
specifier|static
name|int
name|ppc_smc37c66xgt_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|char
name|r
decl_stmt|;
name|int
name|type
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|csr
init|=
name|SMC66x_CSR
decl_stmt|;
comment|/* initial value is 0x3F0 */
name|int
name|port_address
index|[]
init|=
block|{
operator|-
literal|1
comment|/* disabled */
block|,
literal|0x3bc
block|,
literal|0x378
block|,
literal|0x278
block|}
decl_stmt|;
define|#
directive|define
name|cio
value|csr+1
comment|/* config IO port is either 0x3F1 or 0x371 */
comment|/* 	 * Detection: enter configuration mode and read CRD register. 	 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC665_iCODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC665_iCODE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|==
literal|0x65
condition|)
block|{
name|type
operator|=
name|SMC_37C665GT
expr_stmt|;
goto|goto
name|config
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC666_iCODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC666_iCODE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|==
literal|0x66
condition|)
block|{
name|type
operator|=
name|SMC_37C666GT
expr_stmt|;
break|break;
block|}
comment|/* Another chance, CSR may be hard-configured to be at 0x370 */
name|csr
operator|=
name|SMC666_CSR
expr_stmt|;
block|}
name|config
label|:
comment|/* 	 * If chipset not found, do not continue. 	 */
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* select CR1 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* read the port's address: bits 0 and 1 of CR1 */
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
name|SMC_CR1_ADDR
expr_stmt|;
if|if
condition|(
name|port_address
index|[
name|r
index|]
operator|!=
name|ppc
operator|->
name|ppc_base
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ppc
operator|->
name|ppc_type
operator|=
name|type
expr_stmt|;
comment|/* 	 * CR1 and CR4 registers bits 3 and 0/1 for mode configuration 	 * If SPP mode is detected, try to set ECP+EPP mode 	 */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMC registers CR1=0x%x"
argument_list|,
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" CR4=0x%x"
argument_list|,
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
comment|/* select CR1 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chipset_mode
condition|)
block|{
comment|/* autodetect mode */
comment|/* 666GT is ~certainly~ hardwired to an extended ECP+EPP mode */
if|if
condition|(
name|type
operator|==
name|SMC_37C666GT
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
name|SMC_CR1_MODE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* already in extended parallel port mode, read CR4 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
name|SMC_CR4_EMODE
operator|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|SMC_SPP
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_SPP
expr_stmt|;
break|break;
case|case
name|SMC_EPPSPP
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
break|break;
case|case
name|SMC_ECP
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_SPP
expr_stmt|;
break|break;
case|case
name|SMC_ECPEPP
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* not an extended port mode */
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_SPP
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* mode forced */
comment|/* 666GT is ~certainly~ hardwired to an extended ECP+EPP mode */
if|if
condition|(
name|type
operator|==
name|SMC_37C666GT
condition|)
goto|goto
name|end_detect
goto|;
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chipset_mode
operator|&
operator|(
name|PPB_ECP
operator||
name|PPB_EPP
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* do not use ECP when the mode is not forced to */
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_CR1_MODE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* an extended mode is selected */
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator|&
operator|~
name|SMC_CR1_MODE
argument_list|)
expr_stmt|;
comment|/* read CR4 register and reset mode field */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
operator|~
name|SMC_CR4_EMODE
expr_stmt|;
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_ECP
condition|)
block|{
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_EPP
condition|)
block|{
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_ECPEPP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_ECP
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* PPB_EPP is set */
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_EPPSPP
argument_list|)
expr_stmt|;
block|}
block|}
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
block|}
name|end_detect
label|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_EPP
condition|)
block|{
comment|/* select CR4 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
expr_stmt|;
comment|/* 		 * Set the EPP protocol... 		 * Low=EPP 1.9 (1284 standard) and High=EPP 1.7 		 */
if|if
condition|(
name|ppc
operator|->
name|ppc_epp
operator|==
name|EPP_1_9
condition|)
name|outb
argument_list|(
name|cio
argument_list|,
operator|(
name|r
operator|&
operator|~
name|SMC_CR4_EPPTYPE
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|cio
argument_list|,
operator|(
name|r
operator||
name|SMC_CR4_EPPTYPE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* end config mode */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
condition|)
name|ppc_ecp_config
argument_list|(
name|ppc
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|chipset_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Winbond W83877F stuff  *  * EFER: extended function enable register  * EFIR: extended function index register  * EFDR: extended function data register  */
end_comment

begin_define
define|#
directive|define
name|efir
value|((efer == 0x250) ? 0x251 : 0x3f0)
end_define

begin_define
define|#
directive|define
name|efdr
value|((efer == 0x250) ? 0x252 : 0x3f1)
end_define

begin_decl_stmt
specifier|static
name|int
name|w83877f_efers
index|[]
init|=
block|{
literal|0x250
block|,
literal|0x3f0
block|,
literal|0x3f0
block|,
literal|0x250
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|w83877f_keys
index|[]
init|=
block|{
literal|0x89
block|,
literal|0x86
block|,
literal|0x87
block|,
literal|0x88
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|w83877f_keyiter
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|w83877f_hefs
index|[]
init|=
block|{
name|WINB_HEFERE
block|,
name|WINB_HEFRAS
block|,
name|WINB_HEFERE
operator||
name|WINB_HEFRAS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ppc_w83877f_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|efer
decl_stmt|,
name|base
decl_stmt|;
name|unsigned
name|char
name|r
decl_stmt|,
name|hefere
decl_stmt|,
name|hefras
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|/* first try to enable configuration registers */
name|efer
operator|=
name|w83877f_efers
index|[
name|i
index|]
expr_stmt|;
comment|/* write the key to the EFER */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w83877f_keyiter
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
name|outb
argument_list|(
name|efer
argument_list|,
name|w83877f_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* then check HEFERE and HEFRAS bits */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
name|hefere
operator|=
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
name|WINB_HEFERE
expr_stmt|;
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
name|hefras
operator|=
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
name|WINB_HEFRAS
expr_stmt|;
comment|/* 		 * HEFRAS	HEFERE 		 *   0		   1	write 89h to 250h (power-on default) 		 *   1		   0	write 86h twice to 3f0h 		 *   1		   1	write 87h twice to 3f0h 		 *   0		   0	write 88h to 250h 		 */
if|if
condition|(
operator|(
name|hefere
operator||
name|hefras
operator|)
operator|==
name|w83877f_hefs
index|[
name|i
index|]
condition|)
goto|goto
name|found
goto|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* failed */
name|found
label|:
comment|/* check base port address - read from CR23 */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x23
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_base
operator|!=
name|inb
argument_list|(
name|efdr
argument_list|)
operator|*
literal|4
condition|)
comment|/* 4 bytes boundaries */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* read CHIP ID from CR9/bits0-3 */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x9
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
name|WINB_CHIPID
condition|)
block|{
case|case
name|WINB_W83877F_ID
case|:
name|ppc
operator|->
name|ppc_type
operator|=
name|WINB_W83877F
expr_stmt|;
break|break;
case|case
name|WINB_W83877AF_ID
case|:
name|ppc
operator|->
name|ppc_type
operator|=
name|WINB_W83877AF
expr_stmt|;
break|break;
default|default:
name|ppc
operator|->
name|ppc_type
operator|=
name|WINB_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
comment|/* dump of registers */
name|printf
argument_list|(
literal|"ppc%d: 0x%x - "
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|,
name|w83877f_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|0xd
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|efir
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0x10
init|;
name|i
operator|<=
literal|0x17
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|efir
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x1e
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x20
init|;
name|i
operator|<=
literal|0x29
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|efir
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|chipset_mode
condition|)
block|{
comment|/* autodetect mode */
comment|/* select CR0 */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|r
operator|=
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
operator|(
name|WINB_PRTMODS0
operator||
name|WINB_PRTMODS1
operator|)
expr_stmt|;
comment|/* select CR9 */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x9
argument_list|)
expr_stmt|;
name|r
operator||=
operator|(
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
name|WINB_PRTMODS2
operator|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|WINB_W83757
case|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ppc%d: W83757 compatible mode\n"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* generic or SMC-like */
case|case
name|WINB_EXTFDC
case|:
case|case
name|WINB_EXTADP
case|:
case|case
name|WINB_EXT2FDD
case|:
case|case
name|WINB_JOYSTICK
case|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ppc%d: not in parallel port mode\n"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
operator|(
name|WINB_PARALLEL
operator||
name|WINB_EPP_SPP
operator|)
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
break|break;
case|case
operator|(
name|WINB_PARALLEL
operator||
name|WINB_ECP
operator|)
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_SPP
expr_stmt|;
break|break;
case|case
operator|(
name|WINB_PARALLEL
operator||
name|WINB_ECP_EPP
operator|)
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: unknown case (0x%x)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* mode forced */
comment|/* select CR9 and set PRTMODS2 bit */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x9
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
operator|~
name|WINB_PRTMODS2
argument_list|)
expr_stmt|;
comment|/* select CR0 and reset PRTMODSx bits */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
operator|~
operator|(
name|WINB_PRTMODS0
operator||
name|WINB_PRTMODS1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_ECP
condition|)
block|{
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_EPP
condition|)
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator||
name|WINB_ECP_EPP
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator||
name|WINB_ECP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* select EPP_SPP otherwise */
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator||
name|WINB_EPP_SPP
argument_list|)
expr_stmt|;
block|}
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
block|}
comment|/* exit configuration mode */
name|outb
argument_list|(
name|efer
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
condition|)
name|ppc_ecp_config
argument_list|(
name|ppc
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|chipset_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppc_generic_detect  */
end_comment

begin_function
specifier|static
name|int
name|ppc_generic_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
name|char
name|save_control
decl_stmt|;
if|if
condition|(
operator|!
name|chipset_mode
condition|)
block|{
comment|/* first, check for ECP */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
literal|0xe0
operator|)
operator|==
literal|0x20
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_SPP
expr_stmt|;
comment|/* search for SMC style ECP+EPP mode */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
block|}
comment|/* try to reset EPP timeout bit */
if|if
condition|(
name|ppc_check_epp_timeout
argument_list|(
name|ppc
argument_list|)
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_EPP
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
condition|)
comment|/* SMC like chipset found */
name|ppc
operator|->
name|ppc_type
operator|=
name|SMC_LIKE
expr_stmt|;
block|}
comment|/* XXX try to detect NIBBLE mode */
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_NIBBLE
expr_stmt|;
block|}
else|else
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
condition|)
name|ppc_ecp_config
argument_list|(
name|ppc
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|chipset_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppc_detect()  *  * mode is the mode suggested at boot  */
end_comment

begin_function
specifier|static
name|int
name|ppc_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* list of supported chipsets */
name|int
function_decl|(
modifier|*
name|chipset_detect
index|[]
function_decl|)
parameter_list|(
name|struct
name|ppc_data
modifier|*
parameter_list|,
name|int
parameter_list|)
init|=
block|{
name|ppc_pc873xx_detect
operator|,
function_decl|ppc_smc37c66xgt_detect
operator|,
function_decl|ppc_w83877f_detect
operator|,
function_decl|ppc_generic_detect
operator|,
function_decl|NULL
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* if can't find the port and mode not forced return error */
end_comment

begin_if
if|if
condition|(
operator|!
name|ppc_detect_port
argument_list|(
name|ppc
argument_list|)
operator|&&
name|chipset_mode
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
end_if

begin_comment
comment|/* failed, port not present */
end_comment

begin_comment
comment|/* assume centronics compatible mode is supported */
end_comment

begin_expr_stmt
name|ppc
operator|->
name|ppc_avm
operator|=
name|PPB_COMPATIBLE
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* we have to differenciate available chipset modes, 	 * chipset running modes and IEEE-1284 operating modes 	 * 	 * after detection, the port must support running in compatible mode 	 */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|chipset_detect
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mode
operator|=
name|chipset_detect
index|[
name|i
index|]
operator|(
name|ppc
operator|,
name|chipset_mode
operator|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ppc
operator|->
name|ppc_mode
operator|=
name|mode
expr_stmt|;
break|break;
block|}
block|}
end_for

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * ppc_exec_microseq()  *  * Execute a microsequence.  * Microsequence mechanism is supposed to handle fast I/O operations.  */
end_comment

begin_function
unit|static
name|int
name|ppc_exec_microseq
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ppb_microseq
modifier|*
name|msq
parameter_list|,
name|int
modifier|*
name|ppbpc
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ppb_microseq
modifier|*
name|pc
decl_stmt|;
name|char
name|cc
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|iter
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* static to be reused after few ppc_exec_microseq()/return calls 	 * XXX should be in a context variable shared with ppb level */
specifier|static
name|int
name|accum
decl_stmt|;
specifier|static
name|char
modifier|*
name|ptr
decl_stmt|;
name|struct
name|ppb_microseq
modifier|*
name|microseq_stack
init|=
literal|0
decl_stmt|;
name|struct
name|ppb_microseq
modifier|*
name|pc_stack
init|=
literal|0
decl_stmt|;
comment|/* microsequence registers are equivalent to PC-like port registers */
define|#
directive|define
name|r_reg
parameter_list|(
specifier|register
parameter_list|,
name|ppc
parameter_list|)
value|((char)inb((ppc)->ppc_base + register))
define|#
directive|define
name|w_reg
parameter_list|(
specifier|register
parameter_list|,
name|ppc
parameter_list|,
name|byte
parameter_list|)
value|outb((ppc)->ppc_base + register, byte)
define|#
directive|define
name|INCR_PC
value|(pc ++)
comment|/* increment program counter */
define|#
directive|define
name|mi
value|pc
comment|/* microinstruction currently executed */
comment|/* get the state of pc from ppb level of execution */
name|pc
operator|=
operator|&
name|msq
index|[
operator|*
name|ppbpc
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|mi
operator|->
name|opcode
condition|)
block|{
case|case
name|MS_OP_RSET
case|:
name|cc
operator|=
name|r_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|)
expr_stmt|;
name|cc
operator|&=
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|c
expr_stmt|;
comment|/* clear mask */
name|cc
operator||=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|c
expr_stmt|;
comment|/* assert mask */
name|w_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_RASSERT_P
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
condition|;
name|i
operator|++
control|)
name|w_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_RFETCH_P
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
name|r_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|)
operator|&
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|c
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_RFETCH
case|:
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|p
operator|)
operator|=
name|r_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|)
operator|&
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|c
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_RASSERT
case|:
comment|/* let's suppose the next instr. is the same */
name|prefetch
label|:
for|for
control|(
init|;
name|mi
operator|->
name|opcode
operator|==
name|MS_OP_RASSERT
condition|;
name|INCR_PC
control|)
name|w_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|,
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|opcode
operator|==
name|MS_OP_DELAY
condition|)
block|{
name|DELAY
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
name|INCR_PC
expr_stmt|;
goto|goto
name|prefetch
goto|;
block|}
break|break;
case|case
name|MS_OP_DELAY
case|:
name|DELAY
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_TRIG
case|:
name|reg
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
expr_stmt|;
name|iter
operator|=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iter
condition|;
name|i
operator|++
control|)
block|{
name|w_reg
argument_list|(
name|reg
argument_list|,
name|ppc
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_SET
case|:
name|accum
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_DBRA
case|:
if|if
condition|(
operator|--
name|accum
operator|>
literal|0
condition|)
name|pc
operator|+=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
expr_stmt|;
else|else
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_BRSET
case|:
name|cc
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|&
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|c
operator|)
operator|==
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|c
condition|)
name|pc
operator|+=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
else|else
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_BRCLEAR
case|:
name|cc
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|&
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|c
operator|)
operator|==
literal|0
condition|)
name|pc
operator|+=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
else|else
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_C_CALL
case|:
comment|/* 			 * If the C call returns !0 then end the microseq. 			 * The current state of ptr is passed to the C function 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|f
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|ptr
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_PTR
case|:
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|p
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_CALL
case|:
if|if
condition|(
name|microseq_stack
condition|)
name|panic
argument_list|(
literal|"%s: too much calls"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|p
condition|)
block|{
comment|/* store the state of the actual 				 * microsequence 				 */
name|microseq_stack
operator|=
name|msq
expr_stmt|;
name|pc_stack
operator|=
name|pc
expr_stmt|;
comment|/* jump to the new microsequence */
name|msq
operator|=
operator|(
expr|struct
name|ppb_microseq
operator|*
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|p
expr_stmt|;
name|pc
operator|=
name|msq
expr_stmt|;
block|}
else|else
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_SUBRET
case|:
comment|/* retrieve microseq and pc state before the call */
name|msq
operator|=
name|microseq_stack
expr_stmt|;
name|pc
operator|=
name|pc_stack
expr_stmt|;
comment|/* reset the stack */
name|microseq_stack
operator|=
literal|0
expr_stmt|;
comment|/* XXX return code */
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_PUT
case|:
case|case
name|MS_OP_GET
case|:
case|case
name|MS_OP_RET
case|:
comment|/* can't return to ppb level during the execution 			 * of a submicrosequence */
if|if
condition|(
name|microseq_stack
condition|)
name|panic
argument_list|(
literal|"%s: can't return to ppb level"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* update pc for ppb level of execution */
operator|*
name|ppbpc
operator|=
call|(
name|int
call|)
argument_list|(
name|pc
operator|-
name|msq
argument_list|)
expr_stmt|;
comment|/* return to ppb level of execution */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"%s: unknown microsequence opcode 0x%x"
argument_list|,
name|__FUNCTION__
argument_list|,
name|mi
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* unreached */
block|}
end_function

begin_comment
comment|/*  * Configure current operating mode  */
end_comment

begin_function
specifier|static
name|int
name|ppc_generic_setmode
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|unit
index|]
decl_stmt|;
comment|/* back to compatible mode, XXX don't know yet what to do here */
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
block|{
name|ppc
operator|->
name|ppc_mode
operator|=
name|PPB_COMPATIBLE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* check if mode is available */
if|if
condition|(
operator|!
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|mode
operator|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* if ECP mode, configure ecr register */
if|if
condition|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
condition|)
name|ppc_ecp_config
argument_list|(
name|ppc
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_mode
operator|=
name|mode
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * EPP timeout, according to the PC87332 manual  * Semantics of clearing EPP timeout bit.  * PC87332	- reading SPP_STR does it...  * SMC		- write 1 to EPP timeout bit			XXX  * Others	- (???) write 0 to EPP timeout bit  */
end_comment

begin_function
specifier|static
name|void
name|ppc_reset_epp_timeout
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|char
name|r
decl_stmt|;
name|r
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|w_str
argument_list|(
name|ppc
argument_list|,
name|r
operator||
literal|0x1
argument_list|)
expr_stmt|;
name|w_str
argument_list|(
name|ppc
argument_list|,
name|r
operator|&
literal|0xfe
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ppcprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
specifier|static
name|short
name|next_bios_ppc
init|=
literal|0
decl_stmt|;
name|struct
name|ppc_data
modifier|*
name|ppc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * If port not specified, use bios list. 	 */
if|if
condition|(
name|dvp
operator|->
name|id_iobase
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|next_bios_ppc
operator|<
name|BIOS_MAX_PPC
operator|)
operator|&&
operator|(
operator|*
operator|(
name|BIOS_PORTS
operator|+
name|next_bios_ppc
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|dvp
operator|->
name|id_iobase
operator|=
operator|*
operator|(
name|BIOS_PORTS
operator|+
name|next_bios_ppc
operator|++
operator|)
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Port was explicitly specified. 	 * This allows probing of ports unknown to the BIOS. 	 */
comment|/* 	 * Allocate the ppc_data structure. 	 */
name|ppc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ppc
condition|)
block|{
name|printf
argument_list|(
literal|"ppc: cannot malloc!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|bzero
argument_list|(
name|ppc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_data
argument_list|)
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_base
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|ppc
operator|->
name|ppc_unit
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
name|ppc
operator|->
name|ppc_type
operator|=
name|GENERIC
expr_stmt|;
name|ppc
operator|->
name|ppc_mode
operator|=
name|PPB_COMPATIBLE
expr_stmt|;
name|ppc
operator|->
name|ppc_epp
operator|=
operator|(
name|dvp
operator|->
name|id_flags
operator|&
literal|0x10
operator|)
operator|>>
literal|4
expr_stmt|;
comment|/* 	 * XXX 	 * Try and detect if interrupts are working. 	 */
if|if
condition|(
operator|!
operator|(
name|dvp
operator|->
name|id_flags
operator|&
literal|0x20
operator|)
condition|)
name|ppc
operator|->
name|ppc_irq
operator|=
operator|(
name|dvp
operator|->
name|id_irq
operator|)
expr_stmt|;
name|ppcdata
index|[
name|ppc
operator|->
name|ppc_unit
index|]
operator|=
name|ppc
expr_stmt|;
name|nppc
operator|++
expr_stmt|;
comment|/* 	 * Try to detect the chipset and its mode. 	 */
if|if
condition|(
name|ppc_detect
argument_list|(
name|ppc
argument_list|,
name|dvp
operator|->
name|id_flags
operator|&
literal|0xf
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|end_probe
label|:
return|return
operator|(
literal|1
operator|)
return|;
name|error
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppcattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|isdp
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|isdp
operator|->
name|id_unit
index|]
decl_stmt|;
name|struct
name|ppb_data
modifier|*
name|ppbus
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
comment|/* 	 * Link the Parallel Port Chipset (adapter) to 	 * the future ppbus. 	 */
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter_unit
operator|=
name|ppc
operator|->
name|ppc_unit
expr_stmt|;
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter
operator|=
operator|&
name|ppc_adapter
expr_stmt|;
name|printf
argument_list|(
literal|"ppc%d: %s chipset (%s) in %s mode%s\n"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|,
name|ppc_types
index|[
name|ppc
operator|->
name|ppc_type
index|]
argument_list|,
name|ppc_avms
index|[
name|ppc
operator|->
name|ppc_avm
index|]
argument_list|,
name|ppc_modes
index|[
name|ppc
operator|->
name|ppc_mode
index|]
argument_list|,
operator|(
name|PPB_IS_EPP
argument_list|(
name|ppc
operator|->
name|ppc_mode
argument_list|)
operator|)
condition|?
name|ppc_epp_protocol
index|[
name|ppc
operator|->
name|ppc_epp
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* 	 * Prepare ppbus data area for upper level code. 	 */
name|ppbus
operator|=
name|ppb_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ppbus
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ppc
operator|->
name|ppc_link
operator|.
name|ppbus
operator|=
name|ppbus
expr_stmt|;
name|ppbus
operator|->
name|ppb_link
operator|=
operator|&
name|ppc
operator|->
name|ppc_link
expr_stmt|;
comment|/* 	 * Probe the ppbus and attach devices found. 	 */
name|ppb_attachdevs
argument_list|(
name|ppbus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

