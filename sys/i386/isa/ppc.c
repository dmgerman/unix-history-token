begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 1998 Nicolas Souchu  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: ppc.c,v 1.15 1999/01/10 16:41:13 nsouch Exp $  *  */
end_comment

begin_include
include|#
directive|include
file|"ppc.h"
end_include

begin_if
if|#
directive|if
name|NPPC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppbconf.h>
end_include

begin_include
include|#
directive|include
file|<dev/ppbus/ppb_msq.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ppcreg.h>
end_include

begin_include
include|#
directive|include
file|"opt_ppc.h"
end_include

begin_define
define|#
directive|define
name|LOG_PPC
parameter_list|(
name|function
parameter_list|,
name|ppc
parameter_list|,
name|string
parameter_list|)
define|\
value|if (bootverbose) printf("%s: %s\n", function, string)
end_define

begin_function_decl
specifier|static
name|int
name|ppcprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ppcattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|ppcdriver
init|=
block|{
name|ppcprobe
block|,
name|ppcattach
block|,
literal|"ppc"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ppc_data
modifier|*
name|ppcdata
index|[
name|NPPC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nppc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_types
index|[]
init|=
block|{
literal|"SMC-like"
block|,
literal|"SMC FDC37C665GT"
block|,
literal|"SMC FDC37C666GT"
block|,
literal|"PC87332"
block|,
literal|"PC87306"
block|,
literal|"82091AA"
block|,
literal|"Generic"
block|,
literal|"W83877F"
block|,
literal|"W83877AF"
block|,
literal|"Winbond"
block|,
literal|"PC87334"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of available modes */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_avms
index|[]
init|=
block|{
literal|"COMPATIBLE"
block|,
literal|"NIBBLE-only"
block|,
literal|"PS2-only"
block|,
literal|"PS2/NIBBLE"
block|,
literal|"EPP-only"
block|,
literal|"EPP/NIBBLE"
block|,
literal|"EPP/PS2"
block|,
literal|"EPP/PS2/NIBBLE"
block|,
literal|"ECP-only"
block|,
literal|"ECP/NIBBLE"
block|,
literal|"ECP/PS2"
block|,
literal|"ECP/PS2/NIBBLE"
block|,
literal|"ECP/EPP"
block|,
literal|"ECP/EPP/NIBBLE"
block|,
literal|"ECP/EPP/PS2"
block|,
literal|"ECP/EPP/PS2/NIBBLE"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of current executing modes  * Note that few modes do not actually exist.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_modes
index|[]
init|=
block|{
literal|"COMPATIBLE"
block|,
literal|"NIBBLE"
block|,
literal|"PS/2"
block|,
literal|"PS/2"
block|,
literal|"EPP"
block|,
literal|"EPP"
block|,
literal|"EPP"
block|,
literal|"EPP"
block|,
literal|"ECP"
block|,
literal|"ECP"
block|,
literal|"ECP+PS2"
block|,
literal|"ECP+PS2"
block|,
literal|"ECP+EPP"
block|,
literal|"ECP+EPP"
block|,
literal|"ECP+EPP"
block|,
literal|"ECP+EPP"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ppc_epp_protocol
index|[]
init|=
block|{
literal|" (EPP 1.9)"
block|,
literal|" (EPP 1.7)"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * BIOS printer list - used by BIOS probe.  */
end_comment

begin_define
define|#
directive|define
name|BIOS_PPC_PORTS
value|0x408
end_define

begin_define
define|#
directive|define
name|BIOS_PORTS
value|(short *)(KERNBASE+BIOS_PPC_PORTS)
end_define

begin_define
define|#
directive|define
name|BIOS_MAX_PPC
value|4
end_define

begin_comment
comment|/*  * All these functions are default actions for IN/OUT operations.  * They may be redefined if needed.  */
end_comment

begin_function
specifier|static
name|void
name|ppc_outsb_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|outsb
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_outsw_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|outsw
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_outsl_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|outsl
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_insb_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|insb
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_insw_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|insw
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_insl_epp
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|insl
argument_list|(
name|ppcdata
index|[
name|unit
index|]
operator|->
name|ppc_base
operator|+
name|PPC_EPP_DATA
argument_list|,
name|addr
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_char
name|ppc_rdtr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_dtr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_char
name|ppc_rstr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_str
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_char
name|ppc_rctr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_ctr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_char
name|ppc_repp_A
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_epp_A
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_char
name|ppc_repp_D
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_epp_D
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_char
name|ppc_recr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_ecr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_char
name|ppc_rfifo
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
name|r_fifo
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wdtr
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_dtr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wstr
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_str
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wctr
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_ctr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wepp_A
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_epp_A
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wepp_D
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_epp_D
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wecr
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_ecr
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppc_wfifo
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
name|byte
parameter_list|)
block|{
name|w_fifo
argument_list|(
name|ppcdata
index|[
name|unit
index|]
argument_list|,
name|byte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|ppc_reset_epp_timeout
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ppc_ecp_sync
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ointhand2_t
name|ppcintr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ppc_exec_microseq
parameter_list|(
name|int
parameter_list|,
name|struct
name|ppb_microseq
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ppc_generic_setmode
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ppc_smclike_setmode
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ppc_read
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ppc_write
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ppb_adapter
name|ppc_smclike_adapter
init|=
block|{
literal|0
block|,
comment|/* no intr handler, filled by chipset dependent code */
name|ppc_reset_epp_timeout
block|,
name|ppc_ecp_sync
block|,
name|ppc_exec_microseq
block|,
name|ppc_smclike_setmode
block|,
name|ppc_read
block|,
name|ppc_write
block|,
name|ppc_outsb_epp
block|,
name|ppc_outsw_epp
block|,
name|ppc_outsl_epp
block|,
name|ppc_insb_epp
block|,
name|ppc_insw_epp
block|,
name|ppc_insl_epp
block|,
name|ppc_rdtr
block|,
name|ppc_rstr
block|,
name|ppc_rctr
block|,
name|ppc_repp_A
block|,
name|ppc_repp_D
block|,
name|ppc_recr
block|,
name|ppc_rfifo
block|,
name|ppc_wdtr
block|,
name|ppc_wstr
block|,
name|ppc_wctr
block|,
name|ppc_wepp_A
block|,
name|ppc_wepp_D
block|,
name|ppc_wecr
block|,
name|ppc_wfifo
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ppb_adapter
name|ppc_generic_adapter
init|=
block|{
literal|0
block|,
comment|/* no intr handler, filled by chipset dependent code */
name|ppc_reset_epp_timeout
block|,
name|ppc_ecp_sync
block|,
name|ppc_exec_microseq
block|,
name|ppc_generic_setmode
block|,
name|ppc_read
block|,
name|ppc_write
block|,
name|ppc_outsb_epp
block|,
name|ppc_outsw_epp
block|,
name|ppc_outsl_epp
block|,
name|ppc_insb_epp
block|,
name|ppc_insw_epp
block|,
name|ppc_insl_epp
block|,
name|ppc_rdtr
block|,
name|ppc_rstr
block|,
name|ppc_rctr
block|,
name|ppc_repp_A
block|,
name|ppc_repp_D
block|,
name|ppc_recr
block|,
name|ppc_rfifo
block|,
name|ppc_wdtr
block|,
name|ppc_wstr
block|,
name|ppc_wctr
block|,
name|ppc_wepp_A
block|,
name|ppc_wepp_D
block|,
name|ppc_wecr
block|,
name|ppc_wfifo
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ppc_ecp_sync()		XXX  */
end_comment

begin_function
specifier|static
name|void
name|ppc_ecp_sync
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
operator|)
condition|)
return|return;
name|r
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
literal|0xe0
operator|)
operator|!=
name|PPC_ECR_EPP
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|&
literal|0x1
condition|)
return|return;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ppc%d: ECP sync failed as data still "
expr|\
literal|"present in FIFO.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ppc_detect_fifo()  *  * Detect parallel port FIFO  */
end_comment

begin_function
specifier|static
name|int
name|ppc_detect_fifo
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|)
block|{
name|char
name|ecr_sav
decl_stmt|;
name|char
name|ctr_sav
decl_stmt|,
name|ctr
decl_stmt|,
name|cc
decl_stmt|;
name|short
name|i
decl_stmt|;
comment|/* save registers */
name|ecr_sav
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|ctr_sav
operator|=
name|r_ctr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
comment|/* enter ECP configuration mode, no interrupt, no DMA */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0xf4
argument_list|)
expr_stmt|;
comment|/* read PWord size - transfers in FIFO mode must be PWord aligned */
name|ppc
operator|->
name|ppc_pword
operator|=
operator|(
name|r_cnfgA
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_PWORD_MASK
operator|)
expr_stmt|;
comment|/* XXX 16 and 32 bits implementations not supported */
if|if
condition|(
name|ppc
operator|->
name|ppc_pword
operator|!=
name|PPC_PWORD_8
condition|)
block|{
name|LOG_PPC
argument_list|(
name|__FUNCTION__
argument_list|,
name|ppc
argument_list|,
literal|"PWord not supported"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0x34
argument_list|)
expr_stmt|;
comment|/* byte mode, no interrupt, no DMA */
name|ctr
operator|=
name|r_ctr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|w_ctr
argument_list|(
name|ppc
argument_list|,
name|ctr
operator||
name|PCD
argument_list|)
expr_stmt|;
comment|/* set direction to 1 */
comment|/* enter ECP test mode, no interrupt, no DMA */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0xd4
argument_list|)
expr_stmt|;
comment|/* flush the FIFO */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_FIFO_EMPTY
condition|)
break|break;
name|cc
operator|=
name|r_fifo
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
literal|1024
condition|)
block|{
name|LOG_PPC
argument_list|(
name|__FUNCTION__
argument_list|,
name|ppc
argument_list|,
literal|"can't flush FIFO"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* enable interrupts, no DMA */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0xd0
argument_list|)
expr_stmt|;
comment|/* determine readIntrThreshold 	 * fill the FIFO until serviceIntr is set 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
block|{
name|w_fifo
argument_list|(
name|ppc
argument_list|,
operator|(
name|char
operator|)
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ppc
operator|->
name|ppc_rthr
operator|&&
operator|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_SERVICE_INTR
operator|)
condition|)
block|{
comment|/* readThreshold reached */
name|ppc
operator|->
name|ppc_rthr
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_FIFO_FULL
condition|)
block|{
name|ppc
operator|->
name|ppc_fifo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|>=
literal|1024
condition|)
block|{
name|LOG_PPC
argument_list|(
name|__FUNCTION__
argument_list|,
name|ppc
argument_list|,
literal|"can't fill FIFO"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0xd4
argument_list|)
expr_stmt|;
comment|/* test mode, no interrupt, no DMA */
name|w_ctr
argument_list|(
name|ppc
argument_list|,
name|ctr
operator|&
operator|~
name|PCD
argument_list|)
expr_stmt|;
comment|/* set direction to 0 */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
literal|0xd0
argument_list|)
expr_stmt|;
comment|/* enable interrupts */
comment|/* determine writeIntrThreshold 	 * empty the FIFO until serviceIntr is set 	 */
for|for
control|(
name|i
operator|=
name|ppc
operator|->
name|ppc_fifo
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|r_fifo
argument_list|(
name|ppc
argument_list|)
operator|!=
call|(
name|char
call|)
argument_list|(
name|ppc
operator|->
name|ppc_fifo
operator|-
name|i
argument_list|)
condition|)
block|{
name|LOG_PPC
argument_list|(
name|__FUNCTION__
argument_list|,
name|ppc
argument_list|,
literal|"invalid data in FIFO"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_SERVICE_INTR
condition|)
block|{
comment|/* writeIntrThreshold reached */
name|ppc
operator|->
name|ppc_wthr
operator|=
name|ppc
operator|->
name|ppc_fifo
operator|-
name|i
operator|+
literal|1
expr_stmt|;
block|}
comment|/* if FIFO empty before the last byte, error */
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
operator|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_FIFO_EMPTY
operator|)
condition|)
block|{
name|LOG_PPC
argument_list|(
name|__FUNCTION__
argument_list|,
name|ppc
argument_list|,
literal|"data lost in FIFO"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/* FIFO must be empty after the last byte */
if|if
condition|(
operator|!
operator|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_FIFO_EMPTY
operator|)
condition|)
block|{
name|LOG_PPC
argument_list|(
name|__FUNCTION__
argument_list|,
name|ppc
argument_list|,
literal|"can't empty the FIFO"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|w_ctr
argument_list|(
name|ppc
argument_list|,
name|ctr_sav
argument_list|)
expr_stmt|;
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr_sav
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|w_ctr
argument_list|(
name|ppc
argument_list|,
name|ctr_sav
argument_list|)
expr_stmt|;
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr_sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppc_detect_port
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|)
block|{
name|w_ctr
argument_list|(
name|ppc
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
comment|/* To avoid missing PS2 ports */
name|w_dtr
argument_list|(
name|ppc
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_dtr
argument_list|(
name|ppc
argument_list|)
operator|!=
literal|0xaa
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppc_pc873xx_detect  *  * Probe for a Natsemi PC873xx-family part.  *  * References in this function are to the National Semiconductor  * PC87332 datasheet TL/C/11930, May 1995 revision.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pc873xx_basetab
index|[]
init|=
block|{
literal|0x0398
block|,
literal|0x026e
block|,
literal|0x015c
block|,
literal|0x002e
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pc873xx_porttab
index|[]
init|=
block|{
literal|0x0378
block|,
literal|0x03bc
block|,
literal|0x0278
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pc873xx_irqtab
index|[]
init|=
block|{
literal|5
block|,
literal|7
block|,
literal|5
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pc873xx_regstab
index|[]
init|=
block|{
name|PC873_FER
block|,
name|PC873_FAR
block|,
name|PC873_PTR
block|,
name|PC873_FCR
block|,
name|PC873_PCR
block|,
name|PC873_PMC
block|,
name|PC873_TUP
block|,
name|PC873_SID
block|,
name|PC873_PNP0
block|,
name|PC873_PNP1
block|,
name|PC873_LPTBA
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pc873xx_rnametab
index|[]
init|=
block|{
literal|"FER"
block|,
literal|"FAR"
block|,
literal|"PTR"
block|,
literal|"FCR"
block|,
literal|"PCR"
block|,
literal|"PMC"
block|,
literal|"TUP"
block|,
literal|"SID"
block|,
literal|"PNP0"
block|,
literal|"PNP1"
block|,
literal|"LPTBA"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ppc_pc873xx_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
comment|/* XXX mode never forced */
block|{
specifier|static
name|int
name|index
init|=
literal|0
decl_stmt|;
name|int
name|idport
decl_stmt|,
name|irq
decl_stmt|;
name|int
name|ptr
decl_stmt|,
name|pcr
decl_stmt|,
name|val
decl_stmt|,
name|i
decl_stmt|;
while|while
condition|(
operator|(
name|idport
operator|=
name|pc873xx_basetab
index|[
name|index
operator|++
index|]
operator|)
condition|)
block|{
comment|/* XXX should check first to see if this location is already claimed */
comment|/* 	 * Pull the 873xx through the power-on ID cycle (2.2,1.). 	 * We can't use this to locate the chip as it may already have 	 * been used by the BIOS. 	 */
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|idport
argument_list|)
expr_stmt|;
comment|/* 	 * Read the SID byte.  Possible values are : 	 * 	 * 01010xxx	PC87334 	 * 0001xxxx	PC87332 	 * 01110xxx	PC87306 	 */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_SID
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|&
literal|0xf0
operator|)
operator|==
literal|0x10
condition|)
block|{
name|ppc
operator|->
name|ppc_type
operator|=
name|NS_PC87332
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0xf8
operator|)
operator|==
literal|0x70
condition|)
block|{
name|ppc
operator|->
name|ppc_type
operator|=
name|NS_PC87306
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|val
operator|&
literal|0xf8
operator|)
operator|==
literal|0x50
condition|)
block|{
name|ppc
operator|->
name|ppc_type
operator|=
name|NS_PC87334
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
operator|&&
operator|(
name|val
operator|!=
literal|0xff
operator|)
condition|)
name|printf
argument_list|(
literal|"PC873xx probe at 0x%x got unknown ID 0x%x\n"
argument_list|,
name|idport
argument_list|,
name|val
argument_list|)
expr_stmt|;
continue|continue ;
comment|/* not recognised */
block|}
comment|/* print registers */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"PC873xx"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pc873xx_regstab
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|idport
argument_list|,
name|pc873xx_regstab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s=0x%x"
argument_list|,
name|pc873xx_rnametab
index|[
name|i
index|]
argument_list|,
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We think we have one.  Is it enabled and where we want it to be? 	 */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_FER
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|&
name|PC873_PPENABLE
operator|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx parallel port disabled\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_FAR
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
operator|&
literal|0x3
expr_stmt|;
comment|/* XXX we should create a driver instance for every port found */
if|if
condition|(
name|pc873xx_porttab
index|[
name|val
index|]
operator|!=
name|ppc
operator|->
name|ppc_base
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx at 0x%x not for driver at port 0x%x\n"
argument_list|,
name|pc873xx_porttab
index|[
name|val
index|]
argument_list|,
name|ppc
operator|->
name|ppc_base
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* get irq settings */
if|if
condition|(
name|ppc
operator|->
name|ppc_base
operator|==
literal|0x378
condition|)
name|irq
operator|=
operator|(
name|ptr
operator|&
name|PC873_LPTBIRQ7
operator|)
condition|?
literal|7
else|:
literal|5
expr_stmt|;
else|else
name|irq
operator|=
name|pc873xx_irqtab
index|[
name|val
index|]
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx irq %d at 0x%x\n"
argument_list|,
name|irq
argument_list|,
name|ppc
operator|->
name|ppc_base
argument_list|)
expr_stmt|;
comment|/* 	 * Check if irq settings are correct 	 */
if|if
condition|(
name|irq
operator|!=
name|ppc
operator|->
name|ppc_irq
condition|)
block|{
comment|/* 		 * If the chipset is not locked and base address is 0x378, 		 * we have another chance 		 */
if|if
condition|(
name|ppc
operator|->
name|ppc_base
operator|==
literal|0x378
operator|&&
operator|!
operator|(
name|ptr
operator|&
name|PC873_CFGLOCK
operator|)
condition|)
block|{
if|if
condition|(
name|ppc
operator|->
name|ppc_irq
operator|==
literal|7
condition|)
block|{
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
operator|(
name|ptr
operator||
name|PC873_LPTBIRQ7
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
operator|(
name|ptr
operator||
name|PC873_LPTBIRQ7
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
operator|(
name|ptr
operator|&
operator|~
name|PC873_LPTBIRQ7
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
operator|(
name|ptr
operator|&
operator|~
name|PC873_LPTBIRQ7
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx irq set to %d\n"
argument_list|,
name|ppc
operator|->
name|ppc_irq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx sorry, can't change irq setting\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx irq settings are correct\n"
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PCR
argument_list|)
expr_stmt|;
name|pcr
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|&
name|PC873_CFGLOCK
operator|)
operator|||
operator|!
name|chipset_mode
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx %s"
argument_list|,
operator|(
name|ptr
operator|&
name|PC873_CFGLOCK
operator|)
condition|?
literal|"locked"
else|:
literal|"unlocked"
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_NIBBLE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", NIBBLE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr
operator|&
name|PC873_EPPEN
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_EPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", EPP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr
operator|&
name|PC873_EPP19
condition|)
name|ppc
operator|->
name|ppc_epp
operator|=
name|EPP_1_9
expr_stmt|;
else|else
name|ppc
operator|->
name|ppc_epp
operator|=
name|EPP_1_7
expr_stmt|;
if|if
condition|(
operator|(
name|ppc
operator|->
name|ppc_type
operator|==
name|NS_PC87332
operator|)
operator|&&
name|bootverbose
condition|)
block|{
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|&
name|PC873_EPPRDIR
condition|)
name|printf
argument_list|(
literal|", Regular mode"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", Automatic mode"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pcr
operator|&
name|PC873_ECPEN
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", ECP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr
operator|&
name|PC873_ECPCLK
condition|)
block|{
comment|/* XXX */
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_PS2
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", PS/2"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|&
name|PC873_EXTENDED
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", SPP"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PC873xx unlocked"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_ECP
condition|)
block|{
if|if
condition|(
operator|(
name|chipset_mode
operator|&
name|PPB_EPP
operator|)
operator|&&
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", ECP+EPP not supported"
argument_list|)
expr_stmt|;
name|pcr
operator|&=
operator|~
name|PC873_EPPEN
expr_stmt|;
name|pcr
operator||=
operator|(
name|PC873_ECPEN
operator||
name|PC873_ECPCLK
operator|)
expr_stmt|;
comment|/* XXX */
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", ECP"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_EPP
condition|)
block|{
name|pcr
operator|&=
operator|~
operator|(
name|PC873_ECPEN
operator||
name|PC873_ECPCLK
operator|)
expr_stmt|;
name|pcr
operator||=
operator|(
name|PC873_EPPEN
operator||
name|PC873_EPP19
operator|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_epp
operator|=
name|EPP_1_9
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", EPP1.9"
argument_list|)
expr_stmt|;
comment|/* enable automatic direction turnover */
if|if
condition|(
name|ppc
operator|->
name|ppc_type
operator|==
name|NS_PC87332
condition|)
block|{
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|&=
operator|~
name|PC873_EPPRDIR
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", Automatic mode"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pcr
operator|&=
operator|~
operator|(
name|PC873_ECPEN
operator||
name|PC873_ECPCLK
operator||
name|PC873_EPPEN
operator|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|pcr
argument_list|)
expr_stmt|;
comment|/* configure extended bit in PTR */
name|outb
argument_list|(
name|idport
argument_list|,
name|PC873_PTR
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|inb
argument_list|(
name|idport
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_PS2
condition|)
block|{
name|ptr
operator||=
name|PC873_EXTENDED
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", PS/2"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* default to NIBBLE mode */
name|ptr
operator|&=
operator|~
name|PC873_EXTENDED
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|", NIBBLE"
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|idport
operator|+
literal|1
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter
operator|=
operator|&
name|ppc_generic_adapter
expr_stmt|;
name|ppc_generic_setmode
argument_list|(
name|ppc
operator|->
name|ppc_unit
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|chipset_mode
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppc_check_epp_timeout
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|)
block|{
name|ppc_reset_epp_timeout
argument_list|(
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|(
name|r_str
argument_list|(
name|ppc
argument_list|)
operator|&
name|TIMEOUT
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppc_smc37c66xgt_detect  *  * SMC FDC37C66xGT configuration.  */
end_comment

begin_function
specifier|static
name|int
name|ppc_smc37c66xgt_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|char
name|r
decl_stmt|;
name|int
name|type
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|csr
init|=
name|SMC66x_CSR
decl_stmt|;
comment|/* initial value is 0x3F0 */
name|int
name|port_address
index|[]
init|=
block|{
operator|-
literal|1
comment|/* disabled */
block|,
literal|0x3bc
block|,
literal|0x378
block|,
literal|0x278
block|}
decl_stmt|;
define|#
directive|define
name|cio
value|csr+1
comment|/* config IO port is either 0x3F1 or 0x371 */
comment|/* 	 * Detection: enter configuration mode and read CRD register. 	 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC665_iCODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC665_iCODE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|==
literal|0x65
condition|)
block|{
name|type
operator|=
name|SMC_37C665GT
expr_stmt|;
goto|goto
name|config
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC666_iCODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
name|SMC666_iCODE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|==
literal|0x66
condition|)
block|{
name|type
operator|=
name|SMC_37C666GT
expr_stmt|;
break|break;
block|}
comment|/* Another chance, CSR may be hard-configured to be at 0x370 */
name|csr
operator|=
name|SMC666_CSR
expr_stmt|;
block|}
name|config
label|:
comment|/* 	 * If chipset not found, do not continue. 	 */
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* select CR1 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
comment|/* read the port's address: bits 0 and 1 of CR1 */
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
name|SMC_CR1_ADDR
expr_stmt|;
if|if
condition|(
name|port_address
index|[
name|r
index|]
operator|!=
name|ppc
operator|->
name|ppc_base
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ppc
operator|->
name|ppc_type
operator|=
name|type
expr_stmt|;
comment|/* 	 * CR1 and CR4 registers bits 3 and 0/1 for mode configuration 	 * If SPP mode is detected, try to set ECP+EPP mode 	 */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ppc%d: SMC registers CR1=0x%x"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|,
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" CR4=0x%x"
argument_list|,
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
comment|/* select CR1 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chipset_mode
condition|)
block|{
comment|/* autodetect mode */
comment|/* 666GT is ~certainly~ hardwired to an extended ECP+EPP mode */
if|if
condition|(
name|type
operator|==
name|SMC_37C666GT
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" configuration hardwired, supposing "
expr|\
literal|"ECP+EPP SPP"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
name|SMC_CR1_MODE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* already in extended parallel port mode, read CR4 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
name|SMC_CR4_EMODE
operator|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|SMC_SPP
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" SPP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMC_EPPSPP
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" EPP SPP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMC_ECP
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP SPP"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMC_ECPEPP
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP+EPP SPP"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* not an extended port mode */
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" SPP"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* mode forced */
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
comment|/* 666GT is ~certainly~ hardwired to an extended ECP+EPP mode */
if|if
condition|(
name|type
operator|==
name|SMC_37C666GT
condition|)
goto|goto
name|end_detect
goto|;
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chipset_mode
operator|&
operator|(
name|PPB_ECP
operator||
name|PPB_EPP
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* do not use ECP when the mode is not forced to */
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_CR1_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" SPP"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* an extended mode is selected */
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator|&
operator|~
name|SMC_CR1_MODE
argument_list|)
expr_stmt|;
comment|/* read CR4 register and reset mode field */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
operator|&
operator|~
name|SMC_CR4_EMODE
expr_stmt|;
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_ECP
condition|)
block|{
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_EPP
condition|)
block|{
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_ECPEPP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP+EPP"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_ECP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* PPB_EPP is set */
name|outb
argument_list|(
name|cio
argument_list|,
name|r
operator||
name|SMC_EPPSPP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" EPP SPP"
argument_list|)
expr_stmt|;
block|}
block|}
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
block|}
comment|/* set FIFO threshold to 16 */
if|if
condition|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
condition|)
block|{
comment|/* select CRA */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xa
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|cio
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
name|end_detect
label|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_EPP
condition|)
block|{
comment|/* select CR4 */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0x4
argument_list|)
expr_stmt|;
name|r
operator|=
name|inb
argument_list|(
name|cio
argument_list|)
expr_stmt|;
comment|/* 		 * Set the EPP protocol... 		 * Low=EPP 1.9 (1284 standard) and High=EPP 1.7 		 */
if|if
condition|(
name|ppc
operator|->
name|ppc_epp
operator|==
name|EPP_1_9
condition|)
name|outb
argument_list|(
name|cio
argument_list|,
operator|(
name|r
operator|&
operator|~
name|SMC_CR4_EPPTYPE
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|cio
argument_list|,
operator|(
name|r
operator||
name|SMC_CR4_EPPTYPE
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* end config mode */
name|outb
argument_list|(
name|csr
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter
operator|=
operator|&
name|ppc_smclike_adapter
expr_stmt|;
name|ppc_smclike_setmode
argument_list|(
name|ppc
operator|->
name|ppc_unit
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|chipset_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Winbond W83877F stuff  *  * EFER: extended function enable register  * EFIR: extended function index register  * EFDR: extended function data register  */
end_comment

begin_define
define|#
directive|define
name|efir
value|((efer == 0x250) ? 0x251 : 0x3f0)
end_define

begin_define
define|#
directive|define
name|efdr
value|((efer == 0x250) ? 0x252 : 0x3f1)
end_define

begin_decl_stmt
specifier|static
name|int
name|w83877f_efers
index|[]
init|=
block|{
literal|0x250
block|,
literal|0x3f0
block|,
literal|0x3f0
block|,
literal|0x250
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|w83877f_keys
index|[]
init|=
block|{
literal|0x89
block|,
literal|0x86
block|,
literal|0x87
block|,
literal|0x88
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|w83877f_keyiter
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|w83877f_hefs
index|[]
init|=
block|{
name|WINB_HEFERE
block|,
name|WINB_HEFRAS
block|,
name|WINB_HEFERE
operator||
name|WINB_HEFRAS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ppc_w83877f_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|efer
decl_stmt|;
name|unsigned
name|char
name|r
decl_stmt|,
name|hefere
decl_stmt|,
name|hefras
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
comment|/* first try to enable configuration registers */
name|efer
operator|=
name|w83877f_efers
index|[
name|i
index|]
expr_stmt|;
comment|/* write the key to the EFER */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|w83877f_keyiter
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
name|outb
argument_list|(
name|efer
argument_list|,
name|w83877f_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* then check HEFERE and HEFRAS bits */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
name|hefere
operator|=
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
name|WINB_HEFERE
expr_stmt|;
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
name|hefras
operator|=
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
name|WINB_HEFRAS
expr_stmt|;
comment|/* 		 * HEFRAS	HEFERE 		 *   0		   1	write 89h to 250h (power-on default) 		 *   1		   0	write 86h twice to 3f0h 		 *   1		   1	write 87h twice to 3f0h 		 *   0		   0	write 88h to 250h 		 */
if|if
condition|(
operator|(
name|hefere
operator||
name|hefras
operator|)
operator|==
name|w83877f_hefs
index|[
name|i
index|]
condition|)
goto|goto
name|found
goto|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* failed */
name|found
label|:
comment|/* check base port address - read from CR23 */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x23
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_base
operator|!=
name|inb
argument_list|(
name|efdr
argument_list|)
operator|*
literal|4
condition|)
comment|/* 4 bytes boundaries */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* read CHIP ID from CR9/bits0-3 */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x9
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
name|WINB_CHIPID
condition|)
block|{
case|case
name|WINB_W83877F_ID
case|:
name|ppc
operator|->
name|ppc_type
operator|=
name|WINB_W83877F
expr_stmt|;
break|break;
case|case
name|WINB_W83877AF_ID
case|:
name|ppc
operator|->
name|ppc_type
operator|=
name|WINB_W83877AF
expr_stmt|;
break|break;
default|default:
name|ppc
operator|->
name|ppc_type
operator|=
name|WINB_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
comment|/* dump of registers */
name|printf
argument_list|(
literal|"ppc%d: 0x%x - "
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|,
name|w83877f_keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|0xd
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|efir
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0x10
init|;
name|i
operator|<=
literal|0x17
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|efir
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x1e
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x20
init|;
name|i
operator|<=
literal|0x29
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|efir
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ppc%d:"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
block|}
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter
operator|=
operator|&
name|ppc_generic_adapter
expr_stmt|;
if|if
condition|(
operator|!
name|chipset_mode
condition|)
block|{
comment|/* autodetect mode */
comment|/* select CR0 */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|r
operator|=
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
operator|(
name|WINB_PRTMODS0
operator||
name|WINB_PRTMODS1
operator|)
expr_stmt|;
comment|/* select CR9 */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x9
argument_list|)
expr_stmt|;
name|r
operator||=
operator|(
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
name|WINB_PRTMODS2
operator|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|WINB_W83757
case|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ppc%d: W83757 compatible mode\n"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* generic or SMC-like */
case|case
name|WINB_EXTFDC
case|:
case|case
name|WINB_EXTADP
case|:
case|case
name|WINB_EXT2FDD
case|:
case|case
name|WINB_JOYSTICK
case|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" not in parallel port mode\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
operator|(
name|WINB_PARALLEL
operator||
name|WINB_EPP_SPP
operator|)
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" EPP SPP"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|WINB_PARALLEL
operator||
name|WINB_ECP
operator|)
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP SPP"
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|WINB_PARALLEL
operator||
name|WINB_ECP_EPP
operator|)
case|:
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_EPP
operator||
name|PPB_SPP
expr_stmt|;
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter
operator|=
operator|&
name|ppc_smclike_adapter
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP+EPP SPP"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: unknown case (0x%x)!\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* mode forced */
comment|/* select CR9 and set PRTMODS2 bit */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x9
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
operator|~
name|WINB_PRTMODS2
argument_list|)
expr_stmt|;
comment|/* select CR0 and reset PRTMODSx bits */
name|outb
argument_list|(
name|efir
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator|&
operator|~
operator|(
name|WINB_PRTMODS0
operator||
name|WINB_PRTMODS1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_ECP
condition|)
block|{
if|if
condition|(
name|chipset_mode
operator|&
name|PPB_EPP
condition|)
block|{
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator||
name|WINB_ECP_EPP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP+EPP"
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter
operator|=
operator|&
name|ppc_smclike_adapter
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator||
name|WINB_ECP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* select EPP_SPP otherwise */
name|outb
argument_list|(
name|efdr
argument_list|,
name|inb
argument_list|(
name|efdr
argument_list|)
operator||
name|WINB_EPP_SPP
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" EPP SPP"
argument_list|)
expr_stmt|;
block|}
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* exit configuration mode */
name|outb
argument_list|(
name|efer
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter
operator|->
name|setmode
argument_list|(
name|ppc
operator|->
name|ppc_unit
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|chipset_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppc_generic_detect  */
end_comment

begin_function
specifier|static
name|int
name|ppc_generic_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
comment|/* default to generic */
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter
operator|=
operator|&
name|ppc_generic_adapter
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ppc%d:"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chipset_mode
condition|)
block|{
comment|/* first, check for ECP */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|PPC_ECR_PS2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
literal|0xe0
operator|)
operator|==
name|PPC_ECR_PS2
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_ECP
operator||
name|PPB_SPP
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP SPP"
argument_list|)
expr_stmt|;
comment|/* search for SMC style ECP+EPP mode */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|PPC_ECR_EPP
argument_list|)
expr_stmt|;
block|}
comment|/* try to reset EPP timeout bit */
if|if
condition|(
name|ppc_check_epp_timeout
argument_list|(
name|ppc
argument_list|)
condition|)
block|{
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_EPP
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
condition|)
block|{
comment|/* SMC like chipset found */
name|ppc
operator|->
name|ppc_type
operator|=
name|SMC_LIKE
expr_stmt|;
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter
operator|=
operator|&
name|ppc_smclike_adapter
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" ECP+EPP"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" EPP"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* restore to standard mode */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|PPC_ECR_STD
argument_list|)
expr_stmt|;
block|}
comment|/* XXX try to detect NIBBLE and PS2 modes */
name|ppc
operator|->
name|ppc_avm
operator||=
name|PPB_NIBBLE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" SPP"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ppc
operator|->
name|ppc_avm
operator|=
name|chipset_mode
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter
operator|->
name|setmode
argument_list|(
name|ppc
operator|->
name|ppc_unit
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|chipset_mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ppc_detect()  *  * mode is the mode suggested at boot  */
end_comment

begin_function
specifier|static
name|int
name|ppc_detect
parameter_list|(
name|struct
name|ppc_data
modifier|*
name|ppc
parameter_list|,
name|int
name|chipset_mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|mode
decl_stmt|;
comment|/* list of supported chipsets */
name|int
function_decl|(
modifier|*
name|chipset_detect
index|[]
function_decl|)
parameter_list|(
name|struct
name|ppc_data
modifier|*
parameter_list|,
name|int
parameter_list|)
init|=
block|{
name|ppc_pc873xx_detect
operator|,
function_decl|ppc_smc37c66xgt_detect
operator|,
function_decl|ppc_w83877f_detect
operator|,
function_decl|ppc_generic_detect
operator|,
function_decl|NULL
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/* if can't find the port and mode not forced return error */
end_comment

begin_if
if|if
condition|(
operator|!
name|ppc_detect_port
argument_list|(
name|ppc
argument_list|)
operator|&&
name|chipset_mode
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
end_if

begin_comment
comment|/* failed, port not present */
end_comment

begin_comment
comment|/* assume centronics compatible mode is supported */
end_comment

begin_expr_stmt
name|ppc
operator|->
name|ppc_avm
operator|=
name|PPB_COMPATIBLE
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* we have to differenciate available chipset modes, 	 * chipset running modes and IEEE-1284 operating modes 	 * 	 * after detection, the port must support running in compatible mode 	 */
end_comment

begin_if
if|if
condition|(
name|ppc
operator|->
name|ppc_flags
operator|&
literal|0x40
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ppc: chipset forced to generic\n"
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_mode
operator|=
name|ppc_generic_detect
argument_list|(
name|ppc
argument_list|,
name|chipset_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|chipset_detect
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mode
operator|=
name|chipset_detect
index|[
name|i
index|]
operator|(
name|ppc
operator|,
name|chipset_mode
operator|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ppc
operator|->
name|ppc_mode
operator|=
name|mode
expr_stmt|;
break|break;
block|}
block|}
block|}
end_if

begin_comment
comment|/* configure/detect ECP FIFO */
end_comment

begin_if
if|if
condition|(
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
operator|)
operator|&&
operator|!
operator|(
name|ppc
operator|->
name|ppc_flags
operator|&
literal|0x80
operator|)
condition|)
name|ppc_detect_fifo
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * ppc_exec_microseq()  *  * Execute a microsequence.  * Microsequence mechanism is supposed to handle fast I/O operations.  */
end_comment

begin_function
unit|static
name|int
name|ppc_exec_microseq
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ppb_microseq
modifier|*
modifier|*
name|p_msq
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ppb_microseq
modifier|*
name|mi
decl_stmt|;
name|char
name|cc
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|iter
decl_stmt|,
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
specifier|register
name|int
name|reg
decl_stmt|;
specifier|register
name|char
name|mask
decl_stmt|;
specifier|register
name|int
name|accum
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
init|=
literal|0
decl_stmt|;
name|struct
name|ppb_microseq
modifier|*
name|stack
init|=
literal|0
decl_stmt|;
comment|/* microsequence registers are equivalent to PC-like port registers */
define|#
directive|define
name|r_reg
parameter_list|(
specifier|register
parameter_list|,
name|ppc
parameter_list|)
value|(inb((ppc)->ppc_base + register))
define|#
directive|define
name|w_reg
parameter_list|(
specifier|register
parameter_list|,
name|ppc
parameter_list|,
name|byte
parameter_list|)
value|outb((ppc)->ppc_base + register, byte)
define|#
directive|define
name|INCR_PC
value|(mi ++)
comment|/* increment program counter */
name|mi
operator|=
operator|*
name|p_msq
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|mi
operator|->
name|opcode
condition|)
block|{
case|case
name|MS_OP_RSET
case|:
name|cc
operator|=
name|r_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|)
expr_stmt|;
name|cc
operator|&=
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|i
expr_stmt|;
comment|/* clear mask */
name|cc
operator||=
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
comment|/* assert mask */
name|w_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_RASSERT_P
case|:
name|reg
operator|=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
name|ptr
operator|=
name|ppc
operator|->
name|ppc_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator|)
operator|==
name|MS_ACCUM
condition|)
block|{
name|accum
operator|=
name|ppc
operator|->
name|ppc_accum
expr_stmt|;
for|for
control|(
init|;
name|accum
condition|;
name|accum
operator|--
control|)
name|w_reg
argument_list|(
name|reg
argument_list|,
name|ppc
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_accum
operator|=
name|accum
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|w_reg
argument_list|(
name|reg
argument_list|,
name|ppc
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_ptr
operator|=
name|ptr
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_RFETCH_P
case|:
name|reg
operator|=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
name|mask
operator|=
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|i
expr_stmt|;
name|ptr
operator|=
name|ppc
operator|->
name|ppc_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator|)
operator|==
name|MS_ACCUM
condition|)
block|{
name|accum
operator|=
name|ppc
operator|->
name|ppc_accum
expr_stmt|;
for|for
control|(
init|;
name|accum
condition|;
name|accum
operator|--
control|)
operator|*
name|ptr
operator|++
operator|=
name|r_reg
argument_list|(
name|reg
argument_list|,
name|ppc
argument_list|)
operator|&
name|mask
expr_stmt|;
name|ppc
operator|->
name|ppc_accum
operator|=
name|accum
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
name|r_reg
argument_list|(
name|reg
argument_list|,
name|ppc
argument_list|)
operator|&
name|mask
expr_stmt|;
name|ppc
operator|->
name|ppc_ptr
operator|=
name|ptr
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_RFETCH
case|:
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|p
operator|)
operator|=
name|r_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|)
operator|&
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_RASSERT
case|:
case|case
name|MS_OP_DELAY
case|:
comment|/* let's suppose the next instr. is the same */
name|prefetch
label|:
for|for
control|(
init|;
name|mi
operator|->
name|opcode
operator|==
name|MS_OP_RASSERT
condition|;
name|INCR_PC
control|)
name|w_reg
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|,
name|ppc
argument_list|,
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|opcode
operator|==
name|MS_OP_DELAY
condition|)
block|{
name|DELAY
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
argument_list|)
expr_stmt|;
name|INCR_PC
expr_stmt|;
goto|goto
name|prefetch
goto|;
block|}
break|break;
case|case
name|MS_OP_ADELAY
case|:
if|if
condition|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
condition|)
name|tsleep
argument_list|(
name|NULL
argument_list|,
name|PPBPRI
argument_list|,
literal|"ppbdelay"
argument_list|,
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator|*
operator|(
name|hz
operator|/
literal|1000
operator|)
argument_list|)
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_TRIG
case|:
name|reg
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
expr_stmt|;
name|iter
operator|=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|p
expr_stmt|;
comment|/* XXX delay limited to 255 us */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iter
condition|;
name|i
operator|++
control|)
block|{
name|w_reg
argument_list|(
name|reg
argument_list|,
name|ppc
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
block|}
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_SET
case|:
name|ppc
operator|->
name|ppc_accum
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_DBRA
case|:
if|if
condition|(
operator|--
name|ppc
operator|->
name|ppc_accum
operator|>
literal|0
condition|)
name|mi
operator|+=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_BRSET
case|:
name|cc
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|&
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator|)
operator|==
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
condition|)
name|mi
operator|+=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_BRCLEAR
case|:
name|cc
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|&
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator|)
operator|==
literal|0
condition|)
name|mi
operator|+=
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_BRSTAT
case|:
name|cc
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cc
operator|&
operator|(
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
operator||
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|i
operator|)
operator|)
operator|==
operator|(
name|char
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|i
condition|)
name|mi
operator|+=
name|mi
operator|->
name|arg
index|[
literal|2
index|]
operator|.
name|i
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_C_CALL
case|:
comment|/* 			 * If the C call returns !0 then end the microseq. 			 * The current state of ptr is passed to the C function 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|f
argument_list|(
name|mi
operator|->
name|arg
index|[
literal|1
index|]
operator|.
name|p
argument_list|,
name|ppc
operator|->
name|ppc_ptr
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_PTR
case|:
name|ppc
operator|->
name|ppc_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|p
expr_stmt|;
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_CALL
case|:
if|if
condition|(
name|stack
condition|)
name|panic
argument_list|(
literal|"%s: too much calls"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|p
condition|)
block|{
comment|/* store the state of the actual 				 * microsequence 				 */
name|stack
operator|=
name|mi
expr_stmt|;
comment|/* jump to the new microsequence */
name|mi
operator|=
operator|(
expr|struct
name|ppb_microseq
operator|*
operator|)
name|mi
operator|->
name|arg
index|[
literal|0
index|]
operator|.
name|p
expr_stmt|;
block|}
else|else
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_SUBRET
case|:
comment|/* retrieve microseq and pc state before the call */
name|mi
operator|=
name|stack
expr_stmt|;
comment|/* reset the stack */
name|stack
operator|=
literal|0
expr_stmt|;
comment|/* XXX return code */
name|INCR_PC
expr_stmt|;
break|break;
case|case
name|MS_OP_PUT
case|:
case|case
name|MS_OP_GET
case|:
case|case
name|MS_OP_RET
case|:
comment|/* can't return to ppb level during the execution 			 * of a submicrosequence */
if|if
condition|(
name|stack
condition|)
name|panic
argument_list|(
literal|"%s: can't return to ppb level"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* update pc for ppb level of execution */
operator|*
name|p_msq
operator|=
name|mi
expr_stmt|;
comment|/* return to ppb level of execution */
return|return
operator|(
literal|0
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"%s: unknown microsequence opcode 0x%x"
argument_list|,
name|__FUNCTION__
argument_list|,
name|mi
operator|->
name|opcode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* unreached */
block|}
end_function

begin_function
specifier|static
name|void
name|ppcintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|unit
index|]
decl_stmt|;
name|char
name|ctr
decl_stmt|,
name|ecr
decl_stmt|;
name|ctr
operator|=
name|r_ctr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|ecr
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PPC_DEBUG
name|printf
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* don't use ecp mode with IRQENABLE set */
if|if
condition|(
name|ctr
operator|&
name|IRQENABLE
condition|)
block|{
comment|/* call upper code */
name|ppb_intr
argument_list|(
operator|&
name|ppc
operator|->
name|ppc_link
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ctr
operator|&
name|nFAULT
condition|)
block|{
if|if
condition|(
name|ppc
operator|->
name|ppc_irqstat
operator|&
name|PPC_IRQ_nFAULT
condition|)
block|{
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr
operator||
name|PPC_nFAULT_INTR
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_irqstat
operator|&=
operator|~
name|PPC_IRQ_nFAULT
expr_stmt|;
block|}
else|else
block|{
comment|/* call upper code */
name|ppb_intr
argument_list|(
operator|&
name|ppc
operator|->
name|ppc_link
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|ppc
operator|->
name|ppc_irqstat
operator|&
name|PPC_IRQ_DMA
condition|)
block|{
comment|/* disable interrupts (should be done by hardware though) */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr
operator||
name|PPC_SERVICE_INTR
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_irqstat
operator|&=
operator|~
name|PPC_IRQ_DMA
expr_stmt|;
name|ecr
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
comment|/* check if DMA completed */
if|if
condition|(
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
operator|)
operator|&&
operator|(
name|ecr
operator|&
name|PPC_ENABLE_DMA
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PPC_DEBUG
name|printf
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* stop DMA */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr
operator|&
operator|~
name|PPC_ENABLE_DMA
argument_list|)
expr_stmt|;
name|ecr
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_dmastat
operator|==
name|PPC_DMA_STARTED
condition|)
block|{
ifdef|#
directive|ifdef
name|PPC_DEBUG
name|printf
argument_list|(
literal|"d"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isa_dmadone
argument_list|(
name|ppc
operator|->
name|ppc_dmaflags
argument_list|,
name|ppc
operator|->
name|ppc_dmaddr
argument_list|,
name|ppc
operator|->
name|ppc_dmacnt
argument_list|,
name|ppc
operator|->
name|ppc_dmachan
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_dmastat
operator|=
name|PPC_DMA_COMPLETE
expr_stmt|;
comment|/* wakeup the waiting process */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|ppc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ppc
operator|->
name|ppc_irqstat
operator|&
name|PPC_IRQ_FIFO
condition|)
block|{
comment|/* classic interrupt I/O */
name|ppc
operator|->
name|ppc_irqstat
operator|&=
operator|~
name|PPC_IRQ_FIFO
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ppc_read
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Call this function if you want to send data in any advanced mode  * of your parallel port: FIFO, DMA  *  * If what you want is not possible (no ECP, no DMA...),  * EINVAL is returned  */
end_comment

begin_function
specifier|static
name|int
name|ppc_write
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|unit
index|]
decl_stmt|;
name|char
name|ecr
decl_stmt|,
name|ecr_sav
decl_stmt|,
name|ctr
decl_stmt|,
name|ctr_sav
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|spin
decl_stmt|;
ifdef|#
directive|ifdef
name|PPC_DEBUG
name|printf
argument_list|(
literal|"w"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ecr_sav
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|ctr_sav
operator|=
name|r_ctr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
comment|/* 	 * Send buffer with DMA, FIFO and interrupts 	 */
if|if
condition|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
condition|)
block|{
if|if
condition|(
name|ppc
operator|->
name|ppc_dmachan
operator|>=
literal|0
condition|)
block|{
comment|/* byte mode, no intr, no DMA, dir=0, flush fifo 		 */
name|ecr
operator|=
name|PPC_ECR_STD
operator||
name|PPC_DISABLE_INTR
expr_stmt|;
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr
argument_list|)
expr_stmt|;
comment|/* disable nAck interrupts */
name|ctr
operator|=
name|r_ctr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|ctr
operator|&=
operator|~
name|IRQENABLE
expr_stmt|;
name|w_ctr
argument_list|(
name|ppc
argument_list|,
name|ctr
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_dmaflags
operator|=
literal|0
expr_stmt|;
name|ppc
operator|->
name|ppc_dmaddr
operator|=
operator|(
name|caddr_t
operator|)
name|buf
expr_stmt|;
name|ppc
operator|->
name|ppc_dmacnt
operator|=
operator|(
name|u_int
operator|)
name|len
expr_stmt|;
switch|switch
condition|(
name|ppc
operator|->
name|ppc_mode
condition|)
block|{
case|case
name|PPB_COMPATIBLE
case|:
comment|/* compatible mode with FIFO, no intr, DMA, dir=0 */
name|ecr
operator|=
name|PPC_ECR_FIFO
operator||
name|PPC_DISABLE_INTR
operator||
name|PPC_ENABLE_DMA
expr_stmt|;
break|break;
case|case
name|PPB_ECP
case|:
name|ecr
operator|=
name|PPC_ECR_ECP
operator||
name|PPC_DISABLE_INTR
operator||
name|PPC_ENABLE_DMA
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr
argument_list|)
expr_stmt|;
name|ecr
operator|=
name|r_ecr
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
comment|/* enter splhigh() not to be preempted 		 * by the dma interrupt, we may miss 		 * the wakeup otherwise 		 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|ppc
operator|->
name|ppc_dmastat
operator|=
name|PPC_DMA_INIT
expr_stmt|;
comment|/* enable interrupts */
name|ecr
operator|&=
operator|~
name|PPC_SERVICE_INTR
expr_stmt|;
name|ppc
operator|->
name|ppc_irqstat
operator|=
name|PPC_IRQ_DMA
expr_stmt|;
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr
argument_list|)
expr_stmt|;
name|isa_dmastart
argument_list|(
name|ppc
operator|->
name|ppc_dmaflags
argument_list|,
name|ppc
operator|->
name|ppc_dmaddr
argument_list|,
name|ppc
operator|->
name|ppc_dmacnt
argument_list|,
name|ppc
operator|->
name|ppc_dmachan
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PPC_DEBUG
name|printf
argument_list|(
literal|"s%d"
argument_list|,
name|ppc
operator|->
name|ppc_dmacnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ppc
operator|->
name|ppc_dmastat
operator|=
name|PPC_DMA_STARTED
expr_stmt|;
comment|/* Wait for the DMA completed interrupt. We hope we won't 		 * miss it, otherwise a signal will be necessary to unlock the 		 * process. 		 */
do|do
block|{
comment|/* release CPU */
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|ppc
argument_list|,
name|PPBPRI
operator||
name|PCATCH
argument_list|,
literal|"ppcdma"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|PPC_DEBUG
name|printf
argument_list|(
literal|"i"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* stop DMA */
name|isa_dmadone
argument_list|(
name|ppc
operator|->
name|ppc_dmaflags
argument_list|,
name|ppc
operator|->
name|ppc_dmaddr
argument_list|,
name|ppc
operator|->
name|ppc_dmacnt
argument_list|,
name|ppc
operator|->
name|ppc_dmachan
argument_list|)
expr_stmt|;
comment|/* no dma, no interrupt, flush the fifo */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|PPC_ECR_RESET
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_dmastat
operator|=
name|PPC_DMA_INTERRUPTED
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* wait for an empty fifo */
while|while
condition|(
operator|!
operator|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_FIFO_EMPTY
operator|)
condition|)
block|{
for|for
control|(
name|spin
operator|=
literal|100
init|;
name|spin
condition|;
name|spin
operator|--
control|)
if|if
condition|(
name|r_ecr
argument_list|(
name|ppc
argument_list|)
operator|&
name|PPC_FIFO_EMPTY
condition|)
goto|goto
name|fifo_empty
goto|;
ifdef|#
directive|ifdef
name|PPC_DEBUG
name|printf
argument_list|(
literal|"Z"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|ppc
argument_list|,
name|PPBPRI
operator||
name|PCATCH
argument_list|,
literal|"ppcfifo"
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EWOULDBLOCK
condition|)
block|{
ifdef|#
directive|ifdef
name|PPC_DEBUG
name|printf
argument_list|(
literal|"I"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no dma, no interrupt, flush the fifo */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|PPC_ECR_RESET
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_dmastat
operator|=
name|PPC_DMA_INTERRUPTED
expr_stmt|;
name|error
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|fifo_empty
label|:
comment|/* no dma, no interrupt, flush the fifo */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|PPC_ECR_RESET
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* XXX we should FIFO and 						 * interrupts */
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
name|error
label|:
comment|/* PDRQ must be kept unasserted until nPDACK is 	 * deasserted for a minimum of 350ns (SMC datasheet) 	 * 	 * Consequence may be a FIFO that never empty 	 */
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr_sav
argument_list|)
expr_stmt|;
name|w_ctr
argument_list|(
name|ppc
argument_list|,
name|ctr_sav
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Configure current operating mode  */
end_comment

begin_function
specifier|static
name|int
name|ppc_generic_setmode
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|unit
index|]
decl_stmt|;
name|u_char
name|ecr
init|=
literal|0
decl_stmt|;
comment|/* check if mode is available */
if|if
condition|(
name|mode
operator|&&
operator|!
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|mode
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* if ECP mode, configure ecr register */
if|if
condition|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
condition|)
block|{
comment|/* return to byte mode (keeping direction bit), 		 * no interrupt, no DMA to be able to change to 		 * ECP 		 */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|PPC_ECR_RESET
argument_list|)
expr_stmt|;
name|ecr
operator|=
name|PPC_DISABLE_INTR
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|PPB_EPP
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
elseif|else
if|if
condition|(
name|mode
operator|&
name|PPB_ECP
condition|)
comment|/* select ECP mode */
name|ecr
operator||=
name|PPC_ECR_ECP
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|&
name|PPB_PS2
condition|)
comment|/* select PS2 mode with ECP */
name|ecr
operator||=
name|PPC_ECR_PS2
expr_stmt|;
else|else
comment|/* select COMPATIBLE/NIBBLE mode */
name|ecr
operator||=
name|PPC_ECR_STD
expr_stmt|;
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr
argument_list|)
expr_stmt|;
block|}
name|ppc
operator|->
name|ppc_mode
operator|=
name|mode
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The ppc driver is free to choose options like FIFO or DMA  * if ECP mode is available.  *  * The 'RAW' option allows the upper drivers to force the ppc mode  * even with FIFO, DMA available.  */
end_comment

begin_function
name|int
name|ppc_smclike_setmode
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|unit
index|]
decl_stmt|;
name|u_char
name|ecr
init|=
literal|0
decl_stmt|;
comment|/* check if mode is available */
if|if
condition|(
name|mode
operator|&&
operator|!
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|mode
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* if ECP mode, configure ecr register */
if|if
condition|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
condition|)
block|{
comment|/* return to byte mode (keeping direction bit), 		 * no interrupt, no DMA to be able to change to 		 * ECP or EPP mode 		 */
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|PPC_ECR_RESET
argument_list|)
expr_stmt|;
name|ecr
operator|=
name|PPC_DISABLE_INTR
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|PPB_EPP
condition|)
comment|/* select EPP mode */
name|ecr
operator||=
name|PPC_ECR_EPP
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|&
name|PPB_ECP
condition|)
comment|/* select ECP mode */
name|ecr
operator||=
name|PPC_ECR_ECP
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|&
name|PPB_PS2
condition|)
comment|/* select PS2 mode with ECP */
name|ecr
operator||=
name|PPC_ECR_PS2
expr_stmt|;
else|else
comment|/* select COMPATIBLE/NIBBLE mode */
name|ecr
operator||=
name|PPC_ECR_STD
expr_stmt|;
name|w_ecr
argument_list|(
name|ppc
argument_list|,
name|ecr
argument_list|)
expr_stmt|;
block|}
name|ppc
operator|->
name|ppc_mode
operator|=
name|mode
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * EPP timeout, according to the PC87332 manual  * Semantics of clearing EPP timeout bit.  * PC87332	- reading SPP_STR does it...  * SMC		- write 1 to EPP timeout bit			XXX  * Others	- (?) write 0 to EPP timeout bit  */
end_comment

begin_function
specifier|static
name|void
name|ppc_reset_epp_timeout
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|char
name|r
decl_stmt|;
name|r
operator|=
name|r_str
argument_list|(
name|ppc
argument_list|)
expr_stmt|;
name|w_str
argument_list|(
name|ppc
argument_list|,
name|r
operator||
literal|0x1
argument_list|)
expr_stmt|;
name|w_str
argument_list|(
name|ppc
argument_list|,
name|r
operator|&
literal|0xfe
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ppcprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
specifier|static
name|short
name|next_bios_ppc
init|=
literal|0
decl_stmt|;
name|struct
name|ppc_data
modifier|*
name|ppc
decl_stmt|;
comment|/* 	 * If port not specified, use bios list. 	 */
if|if
condition|(
name|dvp
operator|->
name|id_iobase
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|next_bios_ppc
operator|<
name|BIOS_MAX_PPC
operator|)
operator|&&
operator|(
operator|*
operator|(
name|BIOS_PORTS
operator|+
name|next_bios_ppc
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|dvp
operator|->
name|id_iobase
operator|=
operator|*
operator|(
name|BIOS_PORTS
operator|+
name|next_bios_ppc
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ppc: parallel port found at 0x%x\n"
argument_list|,
name|dvp
operator|->
name|id_iobase
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Port was explicitly specified. 	 * This allows probing of ports unknown to the BIOS. 	 */
comment|/* 	 * Allocate the ppc_data structure. 	 */
name|ppc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ppc
condition|)
block|{
name|printf
argument_list|(
literal|"ppc: cannot malloc!\n"
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|bzero
argument_list|(
name|ppc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppc_data
argument_list|)
argument_list|)
expr_stmt|;
name|ppc
operator|->
name|ppc_base
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|ppc
operator|->
name|ppc_unit
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
name|ppc
operator|->
name|ppc_type
operator|=
name|GENERIC
expr_stmt|;
comment|/* store boot flags */
name|ppc
operator|->
name|ppc_flags
operator|=
name|dvp
operator|->
name|id_flags
expr_stmt|;
name|ppc
operator|->
name|ppc_mode
operator|=
name|PPB_COMPATIBLE
expr_stmt|;
name|ppc
operator|->
name|ppc_epp
operator|=
operator|(
name|dvp
operator|->
name|id_flags
operator|&
literal|0x10
operator|)
operator|>>
literal|4
expr_stmt|;
comment|/* 	 * XXX Try and detect if interrupts are working 	 */
if|if
condition|(
operator|!
operator|(
name|dvp
operator|->
name|id_flags
operator|&
literal|0x20
operator|)
condition|)
name|ppc
operator|->
name|ppc_irq
operator|=
name|ffs
argument_list|(
name|dvp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ppc
operator|->
name|ppc_dmachan
operator|=
name|dvp
operator|->
name|id_drq
expr_stmt|;
name|ppcdata
index|[
name|ppc
operator|->
name|ppc_unit
index|]
operator|=
name|ppc
expr_stmt|;
name|nppc
operator|++
expr_stmt|;
comment|/* 	 * Link the Parallel Port Chipset (adapter) to 	 * the future ppbus. Default to a generic chipset 	 */
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter_unit
operator|=
name|ppc
operator|->
name|ppc_unit
expr_stmt|;
name|ppc
operator|->
name|ppc_link
operator|.
name|adapter
operator|=
operator|&
name|ppc_generic_adapter
expr_stmt|;
comment|/* 	 * Try to detect the chipset and its mode. 	 */
if|if
condition|(
name|ppc_detect
argument_list|(
name|ppc
argument_list|,
name|dvp
operator|->
name|id_flags
operator|&
literal|0xf
argument_list|)
condition|)
goto|goto
name|error
goto|;
return|return
operator|(
literal|1
operator|)
return|;
name|error
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppcattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|isdp
parameter_list|)
block|{
name|struct
name|ppc_data
modifier|*
name|ppc
init|=
name|ppcdata
index|[
name|isdp
operator|->
name|id_unit
index|]
decl_stmt|;
name|struct
name|ppb_data
modifier|*
name|ppbus
decl_stmt|;
name|printf
argument_list|(
literal|"ppc%d: %s chipset (%s) in %s mode%s\n"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|,
name|ppc_types
index|[
name|ppc
operator|->
name|ppc_type
index|]
argument_list|,
name|ppc_avms
index|[
name|ppc
operator|->
name|ppc_avm
index|]
argument_list|,
name|ppc_modes
index|[
name|ppc
operator|->
name|ppc_mode
index|]
argument_list|,
operator|(
name|PPB_IS_EPP
argument_list|(
name|ppc
operator|->
name|ppc_mode
argument_list|)
operator|)
condition|?
name|ppc_epp_protocol
index|[
name|ppc
operator|->
name|ppc_epp
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppc
operator|->
name|ppc_fifo
condition|)
name|printf
argument_list|(
literal|"ppc%d: FIFO with %d/%d/%d bytes threshold\n"
argument_list|,
name|ppc
operator|->
name|ppc_unit
argument_list|,
name|ppc
operator|->
name|ppc_fifo
argument_list|,
name|ppc
operator|->
name|ppc_wthr
argument_list|,
name|ppc
operator|->
name|ppc_rthr
argument_list|)
expr_stmt|;
name|isdp
operator|->
name|id_ointr
operator|=
name|ppcintr
expr_stmt|;
comment|/* 	 * Prepare ppbus data area for upper level code. 	 */
name|ppbus
operator|=
name|ppb_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ppbus
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ppc
operator|->
name|ppc_link
operator|.
name|ppbus
operator|=
name|ppbus
expr_stmt|;
name|ppbus
operator|->
name|ppb_link
operator|=
operator|&
name|ppc
operator|->
name|ppc_link
expr_stmt|;
if|if
condition|(
operator|(
name|ppc
operator|->
name|ppc_avm
operator|&
name|PPB_ECP
operator|)
operator|&&
operator|(
name|ppc
operator|->
name|ppc_dmachan
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* acquire the DMA channel forever */
name|isa_dma_acquire
argument_list|(
name|ppc
operator|->
name|ppc_dmachan
argument_list|)
expr_stmt|;
name|isa_dmainit
argument_list|(
name|ppc
operator|->
name|ppc_dmachan
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
comment|/* nlpt.BUFSIZE */
block|}
comment|/* 	 * Probe the ppbus and attach devices found. 	 */
name|ppb_attachdevs
argument_list|(
name|ppbus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

