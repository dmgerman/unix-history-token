begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993 Erik Forsberg.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN  * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Id: psm.c,v 1.25.2.7 1997/03/09 06:32:25 yokota Exp $  */
end_comment

begin_comment
comment|/*  *  Ported to 386bsd Oct 17, 1992  *  Sandi Donno, Computer Science, University of Cape Town, South Africa  *  Please send bug reports to sandi@cs.uct.ac.za  *  *  Thanks are also due to Rick Macklem, rick@snowhite.cis.uoguelph.ca -  *  although I was only partially successful in getting the alpha release  *  of his "driver for the Logitech and ATI Inport Bus mice for use with  *  386bsd and the X386 port" to work with my Microsoft mouse, I nevertheless  *  found his code to be an invaluable reference when porting this driver  *  to 386bsd.  *  *  Further modifications for latest 386BSD+patchkit and port to NetBSD,  *  Andrew Herbert<andrew@werple.apana.org.au> - 8 June 1993  *  *  Cloned from the Microsoft Bus Mouse driver, also by Erik Forsberg, by  *  Andrew Herbert - 12 June 1993  *  *  Modified for PS/2 mouse by Charles Hannum<mycroft@ai.mit.edu>  *  - 13 June 1993  *  *  Modified for PS/2 AUX mouse by Shoji Yuen<yuen@nuie.nagoya-u.ac.jp>  *  - 24 October 1993  *  *  Hardware access routines and probe logic rewritten by  *  Kazutaka Yokota<yokota@zodiac.mech.utsunomiya-u.ac.jp>  *  - 3 October 1996.  *  - 14 October 1996.  *  - 22 October 1996.  *  - 12 November 1996. IOCTLs and rearranging `psmread', `psmioctl'...  *  - 14 November 1996. Uses `kbdio.c'.  *  - 30 November 1996. More fixes.  *  - 13 December 1996. Uses queuing version of `kbdio.c'.  */
end_comment

begin_include
include|#
directive|include
file|"psm.h"
end_include

begin_include
include|#
directive|include
file|"opt_psm.h"
end_include

begin_if
if|#
directive|if
name|NPSM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/include/mouse.h>
end_include

begin_include
include|#
directive|include
file|<i386/include/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/kbdio.h>
end_include

begin_comment
comment|/*  * driver specific options: the following options may be set by  * `options' statements in the kernel configuration file.  */
end_comment

begin_comment
comment|/* debugging */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|PSM_DEBUG
value|0
end_define

begin_comment
comment|/* logging: 0: none, 1: brief, 2: verbose */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #define PSM_CHECKSYNC	   if defined, check the header data byte */
end_comment

begin_comment
comment|/* features */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_ACCEL
end_ifndef

begin_define
define|#
directive|define
name|PSM_ACCEL
value|0
end_define

begin_comment
comment|/* must be one or greater; acceleration will be 				 * disabled if zero */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #define PSM_EMULATION	   enables protocol emulation */
end_comment

begin_comment
comment|/* end of driver specific options */
end_comment

begin_comment
comment|/* some macros */
end_comment

begin_define
define|#
directive|define
name|PSM_UNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>> 1)
end_define

begin_define
define|#
directive|define
name|PSM_NBLOCKIO
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 1)
end_define

begin_define
define|#
directive|define
name|PSM_MKMINOR
parameter_list|(
name|unit
parameter_list|,
name|block
parameter_list|)
value|(((unit)<< 1) | ((block) ? 0:1))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|max
end_ifndef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)> (y) ? (x) : (y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)< (y) ? (x) : (y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ring buffer */
end_comment

begin_define
define|#
directive|define
name|PSM_BUFSIZE
value|256
end_define

begin_typedef
typedef|typedef
struct|struct
name|ringbuf
block|{
name|int
name|count
decl_stmt|;
name|int
name|head
decl_stmt|;
name|int
name|tail
decl_stmt|;
name|mousestatus_t
name|buf
index|[
name|PSM_BUFSIZE
index|]
decl_stmt|;
block|}
name|ringbuf_t
typedef|;
end_typedef

begin_comment
comment|/* driver control block */
end_comment

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|*packetfunc_t
argument_list|)
name|__P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|mousestatus_t
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_struct
specifier|static
struct|struct
name|psm_softc
block|{
comment|/* Driver status information */
name|struct
name|selinfo
name|rsel
decl_stmt|;
comment|/* Process selecting for Input */
name|unsigned
name|char
name|state
decl_stmt|;
comment|/* Mouse driver state */
name|KBDC
name|kbdc
decl_stmt|;
name|int
name|addr
decl_stmt|;
comment|/* I/O port address */
name|mousehw_t
name|hw
decl_stmt|;
comment|/* hardware information */
name|mousemode_t
name|mode
decl_stmt|;
comment|/* operation mode */
name|mousemode_t
name|dflt_mode
decl_stmt|;
comment|/* default operation mode */
name|ringbuf_t
name|queue
decl_stmt|;
comment|/* mouse status queue */
name|packetfunc_t
name|mkpacket
decl_stmt|;
comment|/* func. to turn queued data into output format */
name|unsigned
name|char
name|ipacket
index|[
name|MOUSE_PS2_PACKETSIZE
index|]
decl_stmt|;
comment|/* interim input buffer */
name|unsigned
name|char
name|opacket
index|[
name|PSM_BUFSIZE
index|]
decl_stmt|;
comment|/* output buffer */
name|int
name|inputbytes
decl_stmt|;
comment|/* # of bytes in the input buffer */
name|int
name|outputbytes
decl_stmt|;
comment|/* # of bytes in the output buffer */
name|int
name|outputhead
decl_stmt|;
comment|/* points the head of the output buffer */
name|int
name|button
decl_stmt|;
comment|/* the latest button state */
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|devfs_token
decl_stmt|;
name|void
modifier|*
name|n_devfs_token
decl_stmt|;
endif|#
directive|endif
block|}
modifier|*
name|psm_softc
index|[
name|NPSM
index|]
struct|;
end_struct

begin_comment
comment|/* driver state flags (state) */
end_comment

begin_define
define|#
directive|define
name|PSM_VALID
value|0x80
end_define

begin_define
define|#
directive|define
name|PSM_OPEN
value|1
end_define

begin_comment
comment|/* Device is open */
end_comment

begin_define
define|#
directive|define
name|PSM_ASLP
value|2
end_define

begin_comment
comment|/* Waiting for mouse data */
end_comment

begin_comment
comment|/* function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|int
name|psmprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|psmattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mkms
name|__P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|mousestatus_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mkman
name|__P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|mousestatus_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mkmsc
name|__P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|mousestatus_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mkmm
name|__P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|mousestatus_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mkps2
name|__P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|mousestatus_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|psmopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|psmclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|psmread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|psmioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_select_t
name|psmselect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device driver declarateion */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|psmdriver
init|=
block|{
name|psmprobe
block|,
name|psmattach
block|,
literal|"psm"
block|,
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|21
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|psm_cdevsw
init|=
block|{
name|psmopen
block|,
name|psmclose
block|,
name|psmread
block|,
name|nowrite
block|,
comment|/* 21 */
name|psmioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|psmselect
block|,
name|nommap
block|,
name|NULL
block|,
literal|"psm"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug message level */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose
init|=
name|PSM_DEBUG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device I/O routines */
end_comment

begin_function
specifier|static
name|int
name|enable_aux_dev
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_ENABLE_DEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: ENABLE_DEV return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|disable_aux_dev
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_DISABLE_DEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: DISABLE_DEV return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_mouse_status
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|empty_aux_buffer
argument_list|(
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SEND_DEV_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SEND_AUX_STATUS return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|PSM_ACK
condition|)
return|return
name|FALSE
return|;
name|status
index|[
literal|0
index|]
operator|=
name|read_aux_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|status
index|[
literal|1
index|]
operator|=
name|read_aux_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|status
index|[
literal|2
index|]
operator|=
name|read_aux_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_aux_id
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|int
name|id
decl_stmt|;
name|empty_aux_buffer
argument_list|(
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SEND_DEV_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SEND_DEV_ID return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|PSM_ACK
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 10ms delay */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|id
operator|=
name|read_aux_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: device ID: %04x\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_mouse_sampling_rate
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command_and_data
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SET_SAMPLING_RATE
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_SAMPLING_RATE (%d) %04x\n"
argument_list|,
name|rate
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
condition|?
name|rate
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_mouse_scaling
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SET_SCALING11
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_SCALING11 return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* `val' must be 0 through PSMD_MAX_RESOLUTION */
end_comment

begin_function
specifier|static
name|int
name|set_mouse_resolution
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command_and_data
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SET_RESOLUTION
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_RESOLUTION (%d) %04x\n"
argument_list|,
name|val
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
condition|?
name|val
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE: once `set_mouse_mode()' is called, the mouse device must be  * re-enabled by calling `enable_aux_dev()'  */
end_comment

begin_function
specifier|static
name|int
name|set_mouse_mode
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SET_STREAM_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_STREAM_MODE return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_mouse_buttons
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|c
init|=
literal|2
decl_stmt|;
comment|/* assume two buttons by default */
name|int
name|res
decl_stmt|;
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/*      * NOTE: a special sequence to obtain Logitech-Mouse-specific      * information: set resolution to 25 ppi, set scaling to 1:1, set      * scaling to 1:1, set scaling to 1:1. Then the second byte of the      * mouse status bytes is the number of available buttons.      */
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|PSMD_RES_LOW
argument_list|)
operator|!=
name|PSMD_RES_LOW
condition|)
return|return
name|c
return|;
if|if
condition|(
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|)
operator|&&
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: status %02x %02x %02x (get_mouse_buttons)\n"
argument_list|,
name|status
index|[
literal|0
index|]
argument_list|,
name|status
index|[
literal|1
index|]
argument_list|,
name|status
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
return|return
name|status
index|[
literal|1
index|]
return|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/*  * FIXME:XXX  * someday, I will get the list of valid pointing devices and  * their IDs...  */
end_comment

begin_function
specifier|static
name|int
name|is_a_mouse
parameter_list|(
name|int
name|id
parameter_list|)
block|{
specifier|static
name|int
name|valid_ids
index|[]
init|=
block|{
name|PSM_MOUSE_ID
block|,
comment|/* mouse */
name|PSM_BALLPOINT_ID
block|,
comment|/* ballpoint device */
operator|-
literal|1
comment|/* end of table */
block|}
decl_stmt|;
if|#
directive|if
literal|0
block|int i;      for (i = 0; valid_ids[i]>= 0; ++i)         if (valid_ids[i] == id)             return TRUE;     return FALSE;
else|#
directive|else
return|return
name|TRUE
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|recover_from_error
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
comment|/* discard anything left in the output buffer */
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/*      * NOTE: KBDC_RESET_KBD may not restore the communication between the      * keyboard and the controller.      */
block|reset_kbd(kbdc);
else|#
directive|else
comment|/*      * NOTE: somehow diagnostic and keyboard port test commands bring the      * keyboard back.      */
if|if
condition|(
operator|!
name|test_controller
argument_list|(
name|kbdc
argument_list|)
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm: keyboard controller failed.\n"
argument_list|)
expr_stmt|;
comment|/* if there isn't a keyboard in the system, the following error is OK */
if|if
condition|(
name|test_kbd_port
argument_list|(
name|kbdc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm: keyboard port failed.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|restore_controller
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|command_byte
parameter_list|)
block|{
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
literal|0xff
argument_list|,
name|command_byte
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm: failed to restore the keyboard controller "
literal|"command byte.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/*   * Re-initialize the aux port and device. The aux port must be enabled  * and its interrupt must be disabled before calling this routine.   * The aux device will be disabled before returning.  * The keyboard controller must be locked via `kbdc_lock()' before  * calling this routine.  */
end_comment

begin_function
specifier|static
name|int
name|reinitialize
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|mousemode_t
modifier|*
name|mode
parameter_list|)
block|{
name|KBDC
name|kbdc
init|=
name|psm_softc
index|[
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|kbdc
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
operator|(
name|i
operator|=
name|test_aux_port
argument_list|(
name|kbdc
argument_list|)
operator|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* ignore this error */
if|if
condition|(
name|verbose
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: strange result for test aux port (%d).\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* fall though */
case|case
literal|0
case|:
comment|/* no error */
break|break;
case|case
operator|-
literal|1
case|:
comment|/* time out */
default|default:
comment|/* error */
name|recover_from_error
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: the aux port is not functioning (%d).\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/*       * NOTE: some controllers appears to hang the `keyboard' when      * the aux port doesn't exist and `PSMC_RESET_DEV' is issued.       */
if|if
condition|(
operator|!
name|reset_aux_dev
argument_list|(
name|kbdc
argument_list|)
condition|)
block|{
name|recover_from_error
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to reset the aux device.\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/*       * both the aux port and the aux device is functioning, see      * if the device can be enabled.       */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|kbdc
argument_list|)
operator|||
operator|!
name|disable_aux_dev
argument_list|(
name|kbdc
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the aux device.\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* remove stray data if any */
comment|/* set mouse parameters */
if|if
condition|(
name|mode
operator|!=
operator|(
name|mousemode_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|mode
operator|->
name|rate
operator|>
literal|0
condition|)
name|mode
operator|->
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|mode
operator|->
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|resolution
operator|>=
literal|0
condition|)
name|mode
operator|->
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|mode
operator|->
name|resolution
argument_list|)
expr_stmt|;
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|set_mouse_mode
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
block|}
comment|/* just check the status of the mouse */
name|i
operator|=
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get status.\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: status %02x %02x %02x\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|stat
index|[
literal|0
index|]
argument_list|,
name|stat
index|[
literal|1
index|]
argument_list|,
name|stat
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* psm driver entry points */
end_comment

begin_define
define|#
directive|define
name|endprobe
parameter_list|(
name|v
parameter_list|)
value|{   if (bootverbose) 				\ 				--verbose;   				\                             kbdc_set_device_mask(sc->kbdc, mask);	\ 			    kbdc_lock(sc->kbdc, FALSE);			\  	                    free(sc, M_DEVBUF);                         \ 			    return (v);	     				\ 			}
end_define

begin_function
specifier|static
name|int
name|psmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* validate unit number */
if|if
condition|(
name|unit
operator|>=
name|NPSM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|psm_softc
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
expr|*
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|addr
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|sc
operator|->
name|kbdc
operator|=
name|kbdc_open
argument_list|(
name|sc
operator|->
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|++
name|verbose
expr_stmt|;
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"psm%d: unable to lock the controller.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|--
name|verbose
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * NOTE: two bits in the command byte controls the operation of the      * aux port (mouse port): the aux port disable bit (bit 5) and the aux      * port interrupt (IRQ 12) enable bit (bit 2). When this probe routine      * is called, there are following possibilities about the presence of      * the aux port and the PS/2 mouse.      *       * Case 1: aux port disabled (bit 5:1), aux int. disabled (bit 2:0) The      * aux port most certainly exists. A device may or may not be      * connected to the port. No driver is probably installed yet.      *       * Case 2: aux port enabled (bit 5:0), aux int. disabled (bit 2:0) Three      * possibile situations here:      *       * Case 2a: The aux port does not exist, therefore, is not explicitly      * disabled. Case 2b: The aux port exists. A device and a driver may      * exist, using the device in the polling(remote) mode. Case 2c: The      * aux port exists. A device may exist, but someone who knows nothing      * about the aux port has set the command byte this way.      *       * Case 3: aux port disabled (bit 5:1), aux int. enabled (bit 2:1) The      * aux port exists, but someone is controlloing the device and      * temporalily disabled the port.      *       * Case 4: aux port enabled (bit 5:0), aux int. enabled (bit 2:1) The aux      * port exists, a device is attached to the port, and someone is      * controlling the device. Some BIOS set the bits this way after boot.      *       * All in all, it is no use examing the bits for detecting the presence      * of the port and the mouse device.      */
comment|/* discard anything left after the keyboard initialization */
name|empty_both_buffers
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* save the current command byte; it will be used later */
name|mask
operator|=
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|&
operator|~
name|KBD_AUX_CONTROL_BITS
expr_stmt|;
name|command_byte
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: current command byte:%04x\n"
argument_list|,
name|unit
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_byte
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|printf
argument_list|(
literal|"psm%d: unable to get the current command byte value.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * disable the keyboard port while probing the aux port, which must be      * enabled during this routine      */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/*  	 * this is CONTROLLER ERROR; I don't know how to recover           * from this error...  	 */
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: unable to set the command byte.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * NOTE: `test_aux_port()' is designed to return with zero if the aux      * port exists and is functioning. However, some controllers appears      * to respond with zero even when the aux port doesn't exist. (It may      * be that this is only the case when the controller DOES have the aux      * port but the port is not wired on the motherboard.) The keyboard      * controllers without the port, such as the original AT, are      * supporsed to return with an error code or simply time out. In any      * case, we have to continue probing the port even when the controller      * passes this test.      *      * XXX: some controllers erroneously return the error code 1 when      * it has the perfectly functional aux port. We have to ignore this      * error code. Even if the controller HAS error with the aux port,      * it will be detected later...      */
switch|switch
condition|(
operator|(
name|i
operator|=
name|test_aux_port
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* ignore this error */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: strange result for test aux port (%d).\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* fall though */
case|case
literal|0
case|:
comment|/* no error */
break|break;
case|case
operator|-
literal|1
case|:
comment|/* time out */
default|default:
comment|/* error */
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: the aux port is not functioning (%d).\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * NOTE: some controllers appears to hang the `keyboard' when the aux      * port doesn't exist and `PSMC_RESET_DEV' is issued.      */
if|if
condition|(
operator|!
name|reset_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: failed to reset the aux device.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * both the aux port and the aux device is functioning, see if the      * device can be enabled. NOTE: when enabled, the device will start      * sending data; we shall immediately disable the device once we know      * the device can be enabled.      */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|||
operator|!
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
comment|/* MOUSE ERROR */
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: failed to enable the aux device.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* save the default values after reset */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: status after reset %02x %02x %02x\n"
argument_list|,
name|unit
argument_list|,
name|stat
index|[
literal|0
index|]
argument_list|,
name|stat
index|[
literal|1
index|]
argument_list|,
name|stat
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|stat
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|stat
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* hardware information */
name|sc
operator|->
name|hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_PS2
expr_stmt|;
comment|/* verify the device is a mouse */
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|get_aux_id
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_a_mouse
argument_list|(
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|)
condition|)
block|{
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: unknown device type (%d).\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sc
operator|->
name|hw
operator|.
name|hwid
condition|)
block|{
case|case
name|PSM_BALLPOINT_ID
case|:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_TRACKBALL
expr_stmt|;
break|break;
case|case
name|PSM_MOUSE_ID
case|:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_MOUSE
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_UNKNOWN
expr_stmt|;
break|break;
block|}
comment|/* # of buttons */
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|get_mouse_buttons
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* set mouse parameters */
comment|/* FIXME:XXX should we set them in `psmattach()' rather than here? */
comment|/* FIXME:XXX I don't know if these parameters are reasonable */
name|i
operator|=
name|send_aux_command
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|PSMC_SET_DEFAULTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: SET_DEFAULTS return code:%04x\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|set_mouse_scaling(sc->kbdc);
comment|/* 1:1 scaling */
block|set_mouse_mode(sc->kbdc);
comment|/* stream mode */
endif|#
directive|endif
comment|/* just check the status of the mouse */
comment|/*       * NOTE: XXX there are some arcane controller/mouse combinations out       * there, which hung the controller unless there is data transmission       * after ACK from the mouse.      */
name|i
operator|=
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get status.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: status %02x %02x %02x\n"
argument_list|,
name|unit
argument_list|,
name|stat
index|[
literal|0
index|]
argument_list|,
name|stat
index|[
literal|1
index|]
argument_list|,
name|stat
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* disable the aux port for now... */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
argument_list|,
operator|(
name|command_byte
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/*  	 * this is CONTROLLER ERROR; I don't know the proper way to           * recover from this error...  	 */
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: unable to set the command byte.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* done */
name|psm_softc
index|[
name|unit
index|]
operator|=
name|sc
expr_stmt|;
name|kbdc_set_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mask
operator||
name|KBD_AUX_CONTROL_BITS
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|IO_PSMSIZE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
comment|/* shouldn't happen */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* initial operation mode */
name|sc
operator|->
name|dflt_mode
operator|.
name|accelfactor
operator|=
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|=
name|PSM_ACCEL
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|protocol
operator|=
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
name|sc
operator|->
name|mkpacket
operator|=
name|mkps2
expr_stmt|;
comment|/* Setup initial state */
name|sc
operator|->
name|state
operator|=
name|PSM_VALID
expr_stmt|;
comment|/* Done */
ifdef|#
directive|ifdef
name|DEVFS
name|sc
operator|->
name|devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|psm_cdevsw
argument_list|,
name|PSM_MKMINOR
argument_list|(
name|unit
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0666
argument_list|,
literal|"psm%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|n_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|psm_cdevsw
argument_list|,
name|PSM_MKMINOR
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|)
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0666
argument_list|,
literal|"npsm%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: device ID %d, %d buttons\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|buttons
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"psm%d: device ID %d\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|--
name|verbose
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Validate unit number */
if|if
condition|(
name|unit
operator|>=
name|NPSM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Get device data */
name|sc
operator|=
name|psm_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
operator|==
literal|0
condition|)
comment|/* the device is no longer valid/functioning */
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Disallow multiple opens */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Initialize state */
name|sc
operator|->
name|rsel
operator|.
name|si_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rsel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
comment|/* flush the event queue */
name|sc
operator|->
name|queue
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|button
operator|=
literal|0
expr_stmt|;
comment|/* empty input/output buffers */
name|sc
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|outputbytes
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|outputhead
operator|=
literal|0
expr_stmt|;
comment|/* don't let timeout routines in the keyboard driver to poll the kbdc */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* save the current controller command byte */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|command_byte
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* enable the aux port and temporalily disable the keyboard */
if|if
condition|(
operator|(
name|command_byte
operator|==
operator|-
literal|1
operator|)
operator|||
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR; do you know how to get out of this? */
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: unable to set the command byte (psmopen).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/*       * Now that the keyboard controller is told not to generate       * the keyboard and mouse interrupts, call `splx()' to allow       * the other tty interrupts. The clock interrupt may also occur,       * but timeout routines will be blocked by the poll flag set       * via `kbdc_lock()'      */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* enable the mouse device */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
comment|/* MOUSE ERROR: failed to enable the mouse because: 	 * 1) the mouse is faulty, 	 * 2) the mouse has been removed(!?) 	 * In the latter case, the keyboard may have hung, and need  	 * recovery procedure... 	 */
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME: we could reset the mouse here and try to enable 	 * it again. But it will take long time and it's not a good 	 * idea to disable the keyboard that long... 	 */
block|if (!reinitialize(dev,&sc->mode) || !enable_aux_dev(sc->kbdc))  	    recover_from_error(sc->kbdc);
endif|#
directive|endif
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
comment|/* mark this device is no longer available */
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_VALID
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the device (psmopen).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ret
operator|=
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get status (psmopen).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: status %02x %02x %02x (psmopen)\n"
argument_list|,
name|unit
argument_list|,
name|stat
index|[
literal|0
index|]
argument_list|,
name|stat
index|[
literal|1
index|]
argument_list|,
name|stat
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* enable the aux port and interrupt */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
operator|(
name|command_byte
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_ENABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the aux interrupt (psmopen).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* done */
name|sc
operator|->
name|state
operator||=
name|PSM_OPEN
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* don't let timeout routines in the keyboard driver to poll the kbdc */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* save the current controller command byte */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|command_byte
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_byte
operator|==
operator|-
literal|1
condition|)
block|{
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* disable the aux interrupt and temporalily disable the keyboard */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the aux int (psmclose).\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* CONTROLLER ERROR; 	 * NOTE: we shall force our way through. Because the only 	 * ill effect we shall see is that we may not be able 	 * to read ACK from the mouse, and it doesn't matter much  	 * so long as the mouse will accept the DISABLE command. 	 */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* remove anything left in the output buffer */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* disable the aux device, port and interrupt */
if|if
condition|(
operator|!
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
comment|/* MOUSE ERROR;  	 * NOTE: we don't return error and continue, pretending  	 * we have successfully disabled the device. It's OK because  	 * the interrupt routine will discard any data from the mouse 	 * hereafter.  	 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the device (psmclose).\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get status (psmclose).\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: status %02x %02x %02x (psmclose)\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|,
name|stat
index|[
literal|0
index|]
argument_list|,
name|stat
index|[
literal|1
index|]
argument_list|,
name|stat
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
operator|(
name|command_byte
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR;  	 * we shall ignore this error; see the above comment. 	 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the aux port (psmclose).\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* remove anything left in the output buffer */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* close is almost always successful */
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_OPEN
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PSM_EMULATION
end_ifdef

begin_function
specifier|static
name|int
name|mkms
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|len
parameter_list|,
name|int
name|maxlen
parameter_list|,
specifier|register
name|mousestatus_t
modifier|*
name|status
parameter_list|)
block|{
specifier|static
name|int
name|butmap
index|[]
init|=
block|{
literal|0
block|,
name|MOUSE_MSS_BUTTON1DOWN
block|,
literal|0
block|,
name|MOUSE_MSS_BUTTON1DOWN
block|,
name|MOUSE_MSS_BUTTON3DOWN
block|,
name|MOUSE_MSS_BUTTON1DOWN
operator||
name|MOUSE_MSS_BUTTON3DOWN
block|,
name|MOUSE_MSS_BUTTON3DOWN
block|,
name|MOUSE_MSS_BUTTON1DOWN
operator||
name|MOUSE_MSS_BUTTON3DOWN
block|,     }
decl_stmt|;
name|unsigned
name|char
name|delta
decl_stmt|;
if|if
condition|(
name|maxlen
operator|-
operator|*
name|len
operator|<
name|MOUSE_MSS_PACKETSIZE
condition|)
return|return
name|FALSE
return|;
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSS_SYNC
operator||
name|butmap
index|[
name|status
operator|->
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dx
operator|<
operator|-
literal|128
condition|)
name|delta
operator|=
literal|0x80
expr_stmt|;
comment|/* -128 */
elseif|else
if|if
condition|(
name|status
operator|->
name|dx
operator|>
literal|127
condition|)
name|delta
operator|=
literal|0x7f
expr_stmt|;
comment|/* 127 */
else|else
name|delta
operator|=
operator|(
name|unsigned
name|char
operator|)
name|status
operator|->
name|dx
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|delta
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
expr_stmt|;
comment|/* bit 6-7 */
name|buf
index|[
literal|1
index|]
operator|=
name|delta
operator|&
literal|0x3f
expr_stmt|;
comment|/* bit 0-5 */
if|if
condition|(
name|status
operator|->
name|dy
operator|<
operator|-
literal|128
condition|)
name|delta
operator|=
literal|0x80
expr_stmt|;
comment|/* -128 */
elseif|else
if|if
condition|(
name|status
operator|->
name|dy
operator|>
literal|127
condition|)
name|delta
operator|=
literal|0x7f
expr_stmt|;
comment|/* 127 */
else|else
name|delta
operator|=
operator|(
name|unsigned
name|char
operator|)
name|status
operator|->
name|dy
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|delta
operator|&
literal|0xc0
operator|)
operator|>>
literal|4
expr_stmt|;
comment|/* bit 6-7 */
name|buf
index|[
literal|2
index|]
operator|=
name|delta
operator|&
literal|0x3f
expr_stmt|;
comment|/* bit 0-5 */
operator|*
name|len
operator|+=
name|MOUSE_MSS_PACKETSIZE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mkman
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|len
parameter_list|,
name|int
name|maxlen
parameter_list|,
specifier|register
name|mousestatus_t
modifier|*
name|status
parameter_list|)
block|{
specifier|static
name|int
name|butmap
index|[]
init|=
block|{
literal|0
block|,
name|MOUSE_MSS_BUTTON1DOWN
block|,
literal|0
block|,
name|MOUSE_MSS_BUTTON1DOWN
block|,
name|MOUSE_MSS_BUTTON3DOWN
block|,
name|MOUSE_MSS_BUTTON1DOWN
operator||
name|MOUSE_MSS_BUTTON3DOWN
block|,
name|MOUSE_MSS_BUTTON3DOWN
block|,
name|MOUSE_MSS_BUTTON1DOWN
operator||
name|MOUSE_MSS_BUTTON3DOWN
block|,     }
decl_stmt|;
name|unsigned
name|char
name|delta
decl_stmt|;
name|int
name|l
decl_stmt|;
name|l
operator|=
operator|(
operator|(
name|status
operator|->
name|button
operator|^
name|status
operator|->
name|obutton
operator|)
operator|&
name|MOUSE_BUTTON2DOWN
operator|)
condition|?
name|MOUSE_MSS_PACKETSIZE
operator|+
literal|1
else|:
name|MOUSE_MSS_PACKETSIZE
expr_stmt|;
if|if
condition|(
name|maxlen
operator|-
operator|*
name|len
operator|<
name|l
condition|)
return|return
name|FALSE
return|;
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSS_SYNC
operator||
name|butmap
index|[
name|status
operator|->
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dx
operator|<
operator|-
literal|128
condition|)
name|delta
operator|=
literal|0x80
expr_stmt|;
comment|/* -128 */
elseif|else
if|if
condition|(
name|status
operator|->
name|dx
operator|>
literal|127
condition|)
name|delta
operator|=
literal|0x7f
expr_stmt|;
comment|/* 127 */
else|else
name|delta
operator|=
operator|(
name|unsigned
name|char
operator|)
name|status
operator|->
name|dx
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|delta
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
expr_stmt|;
comment|/* bit 6-7 */
name|buf
index|[
literal|1
index|]
operator|=
name|delta
operator|&
literal|0x3f
expr_stmt|;
comment|/* bit 0-5 */
if|if
condition|(
name|status
operator|->
name|dy
operator|<
operator|-
literal|128
condition|)
name|delta
operator|=
literal|0x80
expr_stmt|;
comment|/* -128 */
elseif|else
if|if
condition|(
name|status
operator|->
name|dy
operator|>
literal|127
condition|)
name|delta
operator|=
literal|0x7f
expr_stmt|;
comment|/* 127 */
else|else
name|delta
operator|=
operator|(
name|unsigned
name|char
operator|)
name|status
operator|->
name|dy
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|delta
operator|&
literal|0xc0
operator|)
operator|>>
literal|4
expr_stmt|;
comment|/* bit 6-7 */
name|buf
index|[
literal|2
index|]
operator|=
name|delta
operator|&
literal|0x3f
expr_stmt|;
comment|/* bit 0-5 */
if|if
condition|(
name|l
operator|>
name|MOUSE_MSS_PACKETSIZE
condition|)
name|buf
index|[
literal|3
index|]
operator|=
operator|(
name|status
operator|->
name|button
operator|&
name|MOUSE_BUTTON2DOWN
operator|)
condition|?
name|MOUSE_LMAN_BUTTON2DOWN
else|:
literal|0
expr_stmt|;
operator|*
name|len
operator|+=
name|l
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mkmsc
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|len
parameter_list|,
name|int
name|maxlen
parameter_list|,
specifier|register
name|mousestatus_t
modifier|*
name|status
parameter_list|)
block|{
specifier|static
name|int
name|butmap
index|[]
init|=
block|{
literal|0
block|,
name|MOUSE_MSC_BUTTON1UP
block|,
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,     }
decl_stmt|;
specifier|register
name|int
name|delta
decl_stmt|;
if|if
condition|(
name|maxlen
operator|-
operator|*
name|len
operator|<
name|MOUSE_MSC_PACKETSIZE
condition|)
return|return
name|FALSE
return|;
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNC
operator||
operator|(
operator|~
name|butmap
index|[
name|status
operator|->
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
operator|&
name|MOUSE_MSC_BUTTONS
operator|)
expr_stmt|;
comment|/* data bytes cannot be between 80h (-128) and 87h (-120).      * values we can return is 255 (0ffh) through -251 (10fh = 87h*2 + 1).      */
if|if
condition|(
name|status
operator|->
name|dx
operator|<
operator|-
literal|251
condition|)
name|delta
operator|=
operator|-
literal|251
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|->
name|dx
operator|>
literal|255
condition|)
name|delta
operator|=
literal|255
expr_stmt|;
else|else
name|delta
operator|=
name|status
operator|->
name|dx
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|delta
operator|/
literal|2
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|delta
operator|-
name|buf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dy
operator|<
operator|-
literal|251
condition|)
name|delta
operator|=
operator|-
literal|251
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|->
name|dy
operator|>
literal|255
condition|)
name|delta
operator|=
literal|255
expr_stmt|;
else|else
name|delta
operator|=
name|status
operator|->
name|dy
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|delta
operator|/
literal|2
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|delta
operator|-
name|buf
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|len
operator|+=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mkmm
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|len
parameter_list|,
name|int
name|maxlen
parameter_list|,
specifier|register
name|mousestatus_t
modifier|*
name|status
parameter_list|)
block|{
specifier|static
name|int
name|butmap
index|[]
init|=
block|{
literal|0
block|,
name|MOUSE_MM_BUTTON1DOWN
block|,
name|MOUSE_MM_BUTTON2DOWN
block|,
name|MOUSE_MM_BUTTON1DOWN
operator||
name|MOUSE_MM_BUTTON2DOWN
block|,
name|MOUSE_MM_BUTTON3DOWN
block|,
name|MOUSE_MM_BUTTON1DOWN
operator||
name|MOUSE_MM_BUTTON3DOWN
block|,
name|MOUSE_MM_BUTTON2DOWN
operator||
name|MOUSE_MM_BUTTON3DOWN
block|,
name|MOUSE_MM_BUTTON1DOWN
operator||
name|MOUSE_MM_BUTTON2DOWN
operator||
name|MOUSE_MM_BUTTON3DOWN
block|,     }
decl_stmt|;
name|int
name|delta
decl_stmt|;
if|if
condition|(
name|maxlen
operator|-
operator|*
name|len
operator|<
name|MOUSE_MM_PACKETSIZE
condition|)
return|return
name|FALSE
return|;
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MM_SYNC
operator||
name|butmap
index|[
name|status
operator|->
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
operator||
operator|(
operator|(
name|status
operator|->
name|dx
operator|>
literal|0
operator|)
condition|?
name|MOUSE_MM_XPOSITIVE
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|status
operator|->
name|dy
operator|>
literal|0
operator|)
condition|?
name|MOUSE_MM_YPOSITIVE
else|:
literal|0
operator|)
expr_stmt|;
name|delta
operator|=
operator|(
name|status
operator|->
name|dx
operator|<
literal|0
operator|)
condition|?
operator|-
name|status
operator|->
name|dx
else|:
name|status
operator|->
name|dx
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|min
argument_list|(
name|delta
argument_list|,
literal|127
argument_list|)
expr_stmt|;
name|delta
operator|=
operator|(
name|status
operator|->
name|dy
operator|<
literal|0
operator|)
condition|?
operator|-
name|status
operator|->
name|dy
else|:
name|status
operator|->
name|dy
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|min
argument_list|(
name|delta
argument_list|,
literal|127
argument_list|)
expr_stmt|;
operator|*
name|len
operator|+=
name|MOUSE_MM_PACKETSIZE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PSM_EMULATION */
end_comment

begin_function
specifier|static
name|int
name|mkps2
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|len
parameter_list|,
name|int
name|maxlen
parameter_list|,
specifier|register
name|mousestatus_t
modifier|*
name|status
parameter_list|)
block|{
specifier|static
name|int
name|butmap
index|[]
init|=
block|{
literal|0
block|,
name|MOUSE_PS2_BUTTON1DOWN
block|,
name|MOUSE_PS2_BUTTON2DOWN
block|,
name|MOUSE_PS2_BUTTON1DOWN
operator||
name|MOUSE_PS2_BUTTON2DOWN
block|,
name|MOUSE_PS2_BUTTON3DOWN
block|,
name|MOUSE_PS2_BUTTON1DOWN
operator||
name|MOUSE_PS2_BUTTON3DOWN
block|,
name|MOUSE_PS2_BUTTON2DOWN
operator||
name|MOUSE_PS2_BUTTON3DOWN
block|,
name|MOUSE_PS2_BUTTON1DOWN
operator||
name|MOUSE_PS2_BUTTON2DOWN
operator||
name|MOUSE_PS2_BUTTON3DOWN
block|,     }
decl_stmt|;
specifier|register
name|int
name|delta
decl_stmt|;
if|if
condition|(
name|maxlen
operator|-
operator|*
name|len
operator|<
name|MOUSE_PS2_PACKETSIZE
condition|)
return|return
name|FALSE
return|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|status
operator|->
name|button
operator|&
name|MOUSE_BUTTON4DOWN
operator|)
condition|?
literal|0
else|:
name|MOUSE_PS2_BUTTON4UP
operator|)
operator||
name|butmap
index|[
name|status
operator|->
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|verbose
operator|>=
literal|2
operator|)
operator|&&
operator|(
operator|(
name|buf
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_BUTTON4UP
operator|)
operator|==
literal|0
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: button 4 down (%04x) (mkps2)\n"
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dx
operator|<
operator|-
literal|256
condition|)
name|delta
operator|=
operator|-
literal|256
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|->
name|dx
operator|>
literal|255
condition|)
name|delta
operator|=
literal|255
expr_stmt|;
else|else
name|delta
operator|=
name|status
operator|->
name|dx
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|buf
index|[
literal|0
index|]
operator||=
name|MOUSE_PS2_XNEG
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|delta
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dy
operator|<
operator|-
literal|256
condition|)
name|delta
operator|=
operator|-
literal|256
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|->
name|dy
operator|>
literal|255
condition|)
name|delta
operator|=
literal|255
expr_stmt|;
else|else
name|delta
operator|=
name|status
operator|->
name|dy
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|buf
index|[
literal|0
index|]
operator||=
name|MOUSE_PS2_YNEG
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|delta
expr_stmt|;
operator|*
name|len
operator|+=
name|MOUSE_PS2_PACKETSIZE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* block until mouse activity occured */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|outputbytes
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|<=
literal|0
operator|)
condition|)
block|{
while|while
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|PSM_NBLOCKIO
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|sc
operator|->
name|state
operator||=
name|PSM_ASLP
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"psmread"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_ASLP
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|outputbytes
operator|>=
name|uio
operator|->
name|uio_resid
condition|)
block|{
comment|/* nothing to be done */
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|outputbytes
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|opacket
index|[
name|sc
operator|->
name|outputhead
index|]
argument_list|,
name|sc
operator|->
name|opacket
argument_list|,
name|sc
operator|->
name|outputbytes
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|outputhead
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|queue
operator|.
name|head
init|;
name|sc
operator|->
name|queue
operator|.
name|count
operator|>
literal|0
condition|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|PSM_BUFSIZE
operator|,
operator|--
name|sc
operator|->
name|queue
operator|.
name|count
control|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|sc
operator|->
name|mkpacket
call|)
argument_list|(
operator|&
name|sc
operator|->
name|opacket
index|[
name|sc
operator|->
name|outputbytes
index|]
argument_list|,
operator|&
name|sc
operator|->
name|outputbytes
argument_list|,
name|PSM_BUFSIZE
argument_list|,
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
block|}
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
name|i
expr_stmt|;
block|}
comment|/* allow interrupts again */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* copy data to user process */
name|length
operator|=
name|min
argument_list|(
name|sc
operator|->
name|outputbytes
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|sc
operator|->
name|opacket
index|[
name|sc
operator|->
name|outputhead
index|]
argument_list|,
name|length
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|outputhead
operator|+=
name|length
expr_stmt|;
name|sc
operator|->
name|outputbytes
operator|-=
name|length
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|mousemode_t
name|mode
decl_stmt|;
name|mousestatus_t
name|status
decl_stmt|;
name|packetfunc_t
name|func
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Perform IOCTL command */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOUSE_GETINFO
case|:
operator|*
operator|(
name|mousehw_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|hw
expr_stmt|;
break|break;
case|case
name|MOUSE_GETMODE
case|:
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|>=
literal|0
condition|)
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|MOUSE_SETMODE
case|:
name|mode
operator|=
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|rate
operator|==
literal|0
condition|)
block|{
name|mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|.
name|rate
operator|>
literal|0
condition|)
block|{
name|mode
operator|.
name|rate
operator|=
name|min
argument_list|(
name|mode
operator|.
name|rate
argument_list|,
name|PSMD_MAX_RATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* mode.rate< 0 */
name|mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|.
name|resolution
operator|==
literal|0
condition|)
block|{
name|mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>
literal|0
condition|)
block|{
name|mode
operator|.
name|resolution
operator|=
name|min
argument_list|(
name|mode
operator|.
name|resolution
operator|-
literal|1
argument_list|,
name|PSMD_MAX_RESOLUTION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* mode.resolution< 0 */
name|mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PSM_EMULATION
switch|switch
condition|(
name|mode
operator|.
name|protocol
condition|)
block|{
case|case
name|MOUSE_PROTO_MS
case|:
name|func
operator|=
name|mkms
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_LOGIMOUSEMAN
case|:
name|func
operator|=
name|mkman
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_MSC
case|:
name|func
operator|=
name|mkmsc
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_MM
case|:
name|func
operator|=
name|mkmm
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_PS2
case|:
name|func
operator|=
name|mkps2
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
name|func
operator|=
operator|(
name|packetfunc_t
operator|)
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
break|break;
else|#
directive|else
name|mode
operator|.
name|protocol
operator|=
name|sc
operator|->
name|mode
operator|.
name|protocol
expr_stmt|;
endif|#
directive|endif
comment|/* PSM_EMULATION */
if|if
condition|(
name|mode
operator|.
name|accelfactor
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* don't allow anybody to poll the keyboard controller */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
comment|/* temporalily disable the keyboard */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|command_byte
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|command_byte
operator|==
operator|-
literal|1
operator|)
operator|||
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* this is CONTROLLER ERROR; I don't know how to recover  	     * from this error.  	     */
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to set the command byte (psmioctl).\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
comment|/*  	 * The device may be in the middle of status data transmission. 	 * The transmission will be interrupted, thus, incomplete status  	 * data must be discarded. Although the aux interrupt is disabled  	 * at the keyboard controller level, at most one aux interrupt  	 * may have already been pending and a data byte is in the  	 * output buffer; throw it away. Note that the second argument  	 * to `empty_aux_buffer()' is zero, so that the call will just  	 * flush the internal queue. 	 * `psmintr()' will be invoked after `splx()' if an interrupt is 	 * pending; it will see no data and returns immediately. 	 */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* flush the queue */
name|read_aux_data_no_wait
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* throw away data if any */
name|sc
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|rate
operator|>
literal|0
condition|)
name|mode
operator|.
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|0
condition|)
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|resolution
argument_list|)
expr_stmt|;
comment|/*  	 * We may have seen a part of status data, which is queued,  	 * during `set_mouse_XXX()'; flush it. 	 */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* restore ports and interrupt */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|command_byte
operator|&
operator|(
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
operator|)
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR; this is serious, we may have 	     * been left with the unaccessible keyboard and 	     * the disabled mouse interrupt.  	     */
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to re-enable "
literal|"the aux port and int (psmioctl).\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
ifdef|#
directive|ifdef
name|PSM_EMULATION
name|sc
operator|->
name|mkpacket
operator|=
name|func
expr_stmt|;
name|sc
operator|->
name|outputbytes
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|outputhead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* PSM_EMULATION */
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSEIOCREAD
case|:
comment|/* FIXME:XXX this should go... */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|MOUSE_GETSTATE
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|>
literal|0
condition|)
block|{
name|status
operator|=
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|sc
operator|->
name|queue
operator|.
name|head
index|]
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
operator|(
name|sc
operator|->
name|queue
operator|.
name|head
operator|+
literal|1
operator|)
operator|%
name|PSM_BUFSIZE
expr_stmt|;
operator|--
name|sc
operator|->
name|queue
operator|.
name|count
expr_stmt|;
block|}
else|else
block|{
name|status
operator|.
name|button
operator|=
name|status
operator|.
name|obutton
operator|=
name|sc
operator|->
name|button
expr_stmt|;
name|status
operator|.
name|dx
operator|=
name|status
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
operator|(
name|mousestatus_t
operator|*
operator|)
name|addr
operator|=
name|status
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Return error code */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|psmintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
comment|/*      * the table to turn PS/2 mouse button bits (MOUSE_PS2_BUTTON?DOWN)      * into `mousestatus' button bits (MOUSE_BUTTON?DOWN).      */
specifier|static
name|int
name|butmap
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|}
decl_stmt|;
specifier|register
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|unit
index|]
decl_stmt|;
name|mousestatus_t
modifier|*
name|ms
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* read until there is nothing to read */
while|while
condition|(
operator|(
name|c
operator|=
name|read_aux_data_no_wait
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* discard the byte if the device is not open */
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/*          * FIXME: there seems no way to reliably          * re-synchronize with the PS/2 mouse once we are out of sync. Sure,          * there is a sync bit in the first data byte, but the second and the          * third bytes may have these bits on (oh, it's not functioning as          * sync bit then!). There need to be two consequtive bytes with this          * bit off to re-sync. (This can be done if the user clicks buttons          * without moving the mouse?)          */
if|if
condition|(
name|sc
operator|->
name|inputbytes
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PSM_CHECKSYNC
if|if
condition|(
operator|(
name|c
operator|&
name|MOUSE_PS2_SYNCMASK
operator|)
operator|==
name|MOUSE_PS2_SYNC
condition|)
name|sc
operator|->
name|ipacket
index|[
name|sc
operator|->
name|inputbytes
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psmintr: sync. bit is off (%04x).\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|#
directive|else
name|sc
operator|->
name|ipacket
index|[
name|sc
operator|->
name|inputbytes
operator|++
index|]
operator|=
name|c
expr_stmt|;
endif|#
directive|endif
comment|/* PSM_CHECKSYNC */
block|}
else|else
block|{
name|sc
operator|->
name|ipacket
index|[
name|sc
operator|->
name|inputbytes
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|inputbytes
operator|>=
name|MOUSE_PS2_PACKETSIZE
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|>=
name|PSM_BUFSIZE
condition|)
block|{
comment|/* no room in the queue */
name|sc
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|x = (sc->ipacket[0]& MOUSE_PS2_XOVERFLOW) ?                     ((sc->ipacket[0]& MOUSE_PS2_XNEG) ? -256 : 255) :                     ((sc->ipacket[0]& MOUSE_PS2_XNEG) ?     		    sc->ipacket[1] - 256 : sc->ipacket[1]);                 y = (sc->ipacket[0]& MOUSE_PS2_YOVERFLOW) ?                     ((sc->ipacket[0]& MOUSE_PS2_YNEG) ? -256 : 255) :                     ((sc->ipacket[0]& MOUSE_PS2_YNEG) ?     		    sc->ipacket[2] - 256 : sc->ipacket[2]);
else|#
directive|else
comment|/* it seems OK to ignore the OVERFLOW bits... */
name|x
operator|=
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_XNEG
operator|)
condition|?
name|sc
operator|->
name|ipacket
index|[
literal|1
index|]
operator|-
literal|256
else|:
name|sc
operator|->
name|ipacket
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|=
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_YNEG
operator|)
condition|?
name|sc
operator|->
name|ipacket
index|[
literal|2
index|]
operator|-
literal|256
else|:
name|sc
operator|->
name|ipacket
index|[
literal|2
index|]
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|x
operator|*
name|x
operator|/
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
name|x
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_XNEG
condition|)
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|y
operator|=
name|y
operator|*
name|y
operator|/
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
name|y
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_YNEG
condition|)
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
block|}
comment|/*                  * FIXME:XXX                  * we shouldn't store data if no movement and                  * no button status change is detected?                  */
name|ms
operator|=
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|sc
operator|->
name|queue
operator|.
name|tail
index|]
expr_stmt|;
name|ms
operator|->
name|dx
operator|=
name|x
expr_stmt|;
name|ms
operator|->
name|dy
operator|=
name|y
expr_stmt|;
name|ms
operator|->
name|obutton
operator|=
name|sc
operator|->
name|button
expr_stmt|;
comment|/* previous button state */
name|sc
operator|->
name|button
operator|=
name|ms
operator|->
name|button
operator|=
comment|/* latest button state */
name|butmap
index|[
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_BUTTONS
index|]
operator||
operator|(
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_BUTTON4UP
operator|)
condition|?
literal|0
else|:
name|MOUSE_BUTTON4DOWN
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|if ((verbose>= 2)&& ((sc->ipacket[0]& MOUSE_PS2_BUTTON4UP) == 0))     		    log(LOG_DEBUG, "psm%d: button 4 down (%04x) (psmintr)\n",     		        unit, sc->ipacket[0]);
endif|#
directive|endif
name|sc
operator|->
name|queue
operator|.
name|tail
operator|=
operator|(
name|sc
operator|->
name|queue
operator|.
name|tail
operator|+
literal|1
operator|)
operator|%
name|PSM_BUFSIZE
expr_stmt|;
operator|++
name|sc
operator|->
name|queue
operator|.
name|count
expr_stmt|;
name|sc
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_ASLP
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_ASLP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|psmselect
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|rw
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Silly to select for output */
if|if
condition|(
name|rw
operator|==
name|FWRITE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Return true if a mouse event available */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|outputbytes
operator|>
literal|0
operator|)
operator|||
operator|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|>
literal|0
operator|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|psm_devsw_installed
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|psm_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|psm_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|psm_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|psm_devsw_installed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|psmdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE + CDEV_MAJOR
argument_list|,
argument|psm_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPSM> 0 */
end_comment

end_unit

