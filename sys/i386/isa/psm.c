begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993 Erik Forsberg.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN  * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  *  Ported to 386bsd Oct 17, 1992  *  Sandi Donno, Computer Science, University of Cape Town, South Africa  *  Please send bug reports to sandi@cs.uct.ac.za  *  *  Thanks are also due to Rick Macklem, rick@snowhite.cis.uoguelph.ca -  *  although I was only partially successful in getting the alpha release  *  of his "driver for the Logitech and ATI Inport Bus mice for use with  *  386bsd and the X386 port" to work with my Microsoft mouse, I nevertheless  *  found his code to be an invaluable reference when porting this driver  *  to 386bsd.  *  *  Further modifications for latest 386BSD+patchkit and port to NetBSD,  *  Andrew Herbert<andrew@werple.apana.org.au> - 8 June 1993  *  *  Cloned from the Microsoft Bus Mouse driver, also by Erik Forsberg, by  *  Andrew Herbert - 12 June 1993  *  *  Modified for PS/2 mouse by Charles Hannum<mycroft@ai.mit.edu>  *  - 13 June 1993  *  *  Modified for PS/2 AUX mouse by Shoji Yuen<yuen@nuie.nagoya-u.ac.jp>  *  - 24 October 1993  */
end_comment

begin_include
include|#
directive|include
file|"psm.h"
end_include

begin_if
if|#
directive|if
name|NPSM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_comment
comment|/* For debugging */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/mouse.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|JREMOD
end_ifdef

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|21
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*JREMOD*/
end_comment

begin_define
define|#
directive|define
name|DATA
value|0
end_define

begin_comment
comment|/* Offset for data port, read-write */
end_comment

begin_define
define|#
directive|define
name|CNTRL
value|4
end_define

begin_comment
comment|/* Offset for control port, write-only */
end_comment

begin_define
define|#
directive|define
name|STATUS
value|4
end_define

begin_comment
comment|/* Offset for status port, read-only */
end_comment

begin_comment
comment|/* status bits */
end_comment

begin_define
define|#
directive|define
name|PSM_OUTPUT_ACK
value|0x02
end_define

begin_comment
comment|/* output acknowledge */
end_comment

begin_comment
comment|/* controller commands */
end_comment

begin_define
define|#
directive|define
name|PSM_ENABLE
value|0xa8
end_define

begin_comment
comment|/* enable auxiliary port */
end_comment

begin_define
define|#
directive|define
name|PSM_DISABLE
value|0xa7
end_define

begin_comment
comment|/* disable auxiliary port */
end_comment

begin_define
define|#
directive|define
name|PSM_INT_ENABLE
value|0x47
end_define

begin_comment
comment|/* enable controller interrupts */
end_comment

begin_define
define|#
directive|define
name|PSM_INT_DISABLE
value|0x65
end_define

begin_comment
comment|/* disable controller interrupts */
end_comment

begin_comment
comment|/* m+use commands */
end_comment

begin_define
define|#
directive|define
name|PSM_SET_SCALE11
value|0xe6
end_define

begin_comment
comment|/* set 1:1 scaling */
end_comment

begin_define
define|#
directive|define
name|PSM_SET_SCALE21
value|0xe7
end_define

begin_comment
comment|/* set 2:1 scaling */
end_comment

begin_define
define|#
directive|define
name|PSM_SET_RES
value|0xe8
end_define

begin_comment
comment|/* set resolution */
end_comment

begin_define
define|#
directive|define
name|PSM_GET_SCALE
value|0xe9
end_define

begin_comment
comment|/* set scaling factor */
end_comment

begin_define
define|#
directive|define
name|PSM_SET_STREAM
value|0xea
end_define

begin_comment
comment|/* set streaming mode */
end_comment

begin_define
define|#
directive|define
name|PSM_SET_SAMPLE
value|0xf3
end_define

begin_comment
comment|/* set sampling rate */
end_comment

begin_define
define|#
directive|define
name|PSM_DEV_ENABLE
value|0xf4
end_define

begin_comment
comment|/* mouse on */
end_comment

begin_define
define|#
directive|define
name|PSM_DEV_DISABLE
value|0xf5
end_define

begin_comment
comment|/* mouse off */
end_comment

begin_define
define|#
directive|define
name|PSM_RESET
value|0xff
end_define

begin_comment
comment|/* reset */
end_comment

begin_define
define|#
directive|define
name|PSMUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>> 1)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(x< y ? x : y)
end_define

begin_endif
endif|#
directive|endif
endif|min
end_endif

begin_function_decl
name|int
name|psmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|psmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|psm_poll_status
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|psmaddr
index|[
name|NPSM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base I/O port addresses per unit */
end_comment

begin_define
define|#
directive|define
name|MSBSZ
value|1024
end_define

begin_comment
comment|/* Output queue size (pwr of 2 is best) */
end_comment

begin_struct
struct|struct
name|ringbuf
block|{
name|int
name|count
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
name|char
name|queue
index|[
name|MSBSZ
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|psm_softc
block|{
comment|/* Driver status information */
name|struct
name|ringbuf
name|inq
decl_stmt|;
comment|/* Input queue */
name|struct
name|selinfo
name|rsel
decl_stmt|;
comment|/* Process selecting for Input */
name|unsigned
name|char
name|state
decl_stmt|;
comment|/* Mouse driver state */
name|unsigned
name|char
name|status
decl_stmt|;
comment|/* Mouse button status */
name|unsigned
name|char
name|button
decl_stmt|;
comment|/* Previous mouse button status bits */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* accumulated motion in the X,Y axis */
block|}
name|psm_softc
index|[
name|NPSM
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|OPEN
value|1
end_define

begin_comment
comment|/* Device is open */
end_comment

begin_define
define|#
directive|define
name|ASLP
value|2
end_define

begin_comment
comment|/* Waiting for mouse data */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|psmdriver
init|=
block|{
name|psmprobe
block|,
name|psmattach
block|,
literal|"psm"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AUX_PORT
value|0x60
end_define

begin_comment
comment|/* AUX_PORT base (S.Yuen) */
end_comment

begin_function
specifier|static
name|void
name|psm_write_dev
parameter_list|(
name|int
name|inport
parameter_list|,
name|u_char
name|value
parameter_list|)
block|{
name|psm_poll_status
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|inport
operator|+
name|CNTRL
argument_list|,
literal|0xd4
argument_list|)
expr_stmt|;
name|psm_poll_status
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|inport
operator|+
name|DATA
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|psm_command
parameter_list|(
name|int
name|ioport
parameter_list|,
name|u_char
name|value
parameter_list|)
block|{
name|psm_poll_status
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|CNTRL
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
name|psm_poll_status
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|DATA
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|psmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
comment|/* XXX: Needs a real probe routine. */
name|int
name|ioport
decl_stmt|,
name|c
decl_stmt|,
name|unit
decl_stmt|;
name|ioport
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|unit
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
ifndef|#
directive|ifndef
name|PSM_NO_RESET
name|psm_write_dev
argument_list|(
name|ioport
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Reset aux device */
name|psm_poll_status
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|ioport
operator|+
name|CNTRL
argument_list|,
literal|0xa9
argument_list|)
expr_stmt|;
name|psm_poll_status
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|CNTRL
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|c
operator|=
name|inb
argument_list|(
name|ioport
operator|+
name|DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0x04
condition|)
block|{
comment|/*		printf("PS/2 AUX mouse is not found\n");*/
name|psm_command
argument_list|(
name|ioport
argument_list|,
literal|0x65
argument_list|)
expr_stmt|;
name|psmaddr
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Device not found */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*	printf("PS/2 AUX mouse found.  Installing driver\n");*/
return|return
operator|(
literal|4
operator|)
return|;
block|}
end_function

begin_function
name|int
name|psmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|int
name|ioport
init|=
name|dvp
operator|->
name|id_iobase
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
init|=
operator|&
name|psm_softc
index|[
name|unit
index|]
decl_stmt|;
comment|/* Save I/O base address */
name|psmaddr
index|[
name|unit
index|]
operator|=
name|ioport
expr_stmt|;
comment|/* Disable mouse interrupts */
name|psm_poll_status
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|CNTRL
argument_list|,
name|PSM_ENABLE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|0
name|psm_write
argument_list|(
name|ioport
argument_list|,
name|PSM_SET_RES
argument_list|)
expr_stmt|;
name|psm_write
argument_list|(
name|ioport
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* 8 counts/mm */
name|psm_write
argument_list|(
name|ioport
argument_list|,
name|PSM_SET_SCALE
argument_list|)
expr_stmt|;
name|psm_write
argument_list|(
name|ioport
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* 2:1 */
name|psm_write
argument_list|(
name|ioport
argument_list|,
name|PSM_SET_SCALE21
argument_list|)
expr_stmt|;
name|psm_write
argument_list|(
name|ioport
argument_list|,
name|PSM_SET_SAMPLE
argument_list|)
expr_stmt|;
name|psm_write
argument_list|(
name|ioport
argument_list|,
literal|0x64
argument_list|)
expr_stmt|;
comment|/* 100 samples/sec */
name|psm_write
argument_list|(
name|ioport
argument_list|,
name|PSM_SET_STREAM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|psm_poll_status
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|CNTRL
argument_list|,
name|PSM_DISABLE
argument_list|)
expr_stmt|;
name|psm_command
argument_list|(
name|ioport
argument_list|,
name|PSM_INT_DISABLE
argument_list|)
expr_stmt|;
comment|/* Setup initial state */
name|sc
operator|->
name|state
operator|=
literal|0
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX eh? usually 1 indicates success */
block|}
end_function

begin_function
name|int
name|psmopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|PSMUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ioport
decl_stmt|;
comment|/* Validate unit number */
if|if
condition|(
name|unit
operator|>=
name|NPSM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Get device data */
name|sc
operator|=
operator|&
name|psm_softc
index|[
name|unit
index|]
expr_stmt|;
name|ioport
operator|=
name|psmaddr
index|[
name|unit
index|]
expr_stmt|;
comment|/* If device does not exist */
if|if
condition|(
name|ioport
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Disallow multiple opens */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Initialize state */
name|sc
operator|->
name|state
operator||=
name|OPEN
expr_stmt|;
name|sc
operator|->
name|rsel
operator|.
name|si_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rsel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|x
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|y
operator|=
literal|0
expr_stmt|;
comment|/* Allocate and initialize a ring buffer */
name|sc
operator|->
name|inq
operator|.
name|count
operator|=
name|sc
operator|->
name|inq
operator|.
name|first
operator|=
name|sc
operator|->
name|inq
operator|.
name|last
operator|=
literal|0
expr_stmt|;
comment|/* Enable Bus Mouse interrupts */
name|psm_write_dev
argument_list|(
name|ioport
argument_list|,
name|PSM_DEV_ENABLE
argument_list|)
expr_stmt|;
name|psm_poll_status
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|CNTRL
argument_list|,
name|PSM_ENABLE
argument_list|)
expr_stmt|;
name|psm_command
argument_list|(
name|ioport
argument_list|,
name|PSM_INT_ENABLE
argument_list|)
expr_stmt|;
comment|/* Successful open */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|psm_poll_status
parameter_list|(
name|void
parameter_list|)
block|{
while|while
condition|(
name|inb
argument_list|(
name|AUX_PORT
operator|+
name|STATUS
argument_list|)
operator|&
literal|0x03
condition|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|AUX_PORT
operator|+
name|STATUS
argument_list|)
operator|&
literal|0x2
operator|==
literal|0x2
condition|)
name|inb
argument_list|(
name|AUX_PORT
operator|+
name|DATA
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|int
name|psmclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|ioport
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
comment|/* Get unit and associated info */
name|unit
operator|=
name|PSMUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|psm_softc
index|[
name|unit
index|]
expr_stmt|;
name|ioport
operator|=
name|psmaddr
index|[
name|unit
index|]
expr_stmt|;
comment|/* Disable further mouse interrupts */
name|psm_command
argument_list|(
name|ioport
argument_list|,
name|PSM_INT_DISABLE
argument_list|)
expr_stmt|;
name|psm_poll_status
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|CNTRL
argument_list|,
name|PSM_DISABLE
argument_list|)
expr_stmt|;
comment|/* Complete the close */
name|sc
operator|->
name|state
operator|&=
operator|~
name|OPEN
expr_stmt|;
comment|/* close is almost always successful */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|psmread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* keep compiler quiet, even though initialisation 			   is unnecessary */
name|unsigned
name|length
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
comment|/* Get device information */
name|sc
operator|=
operator|&
name|psm_softc
index|[
name|PSMUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
comment|/* Block until mouse activity occured */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|inq
operator|.
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x1
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|sc
operator|->
name|state
operator||=
name|ASLP
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"psmrea"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Transfer as many chunks as possible */
while|while
condition|(
name|sc
operator|->
name|inq
operator|.
name|count
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|length
operator|=
name|min
argument_list|(
name|sc
operator|->
name|inq
operator|.
name|count
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|)
name|length
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Remove a small chunk from input queue */
if|if
condition|(
name|sc
operator|->
name|inq
operator|.
name|first
operator|+
name|length
operator|>=
name|MSBSZ
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|inq
operator|.
name|queue
index|[
name|sc
operator|->
name|inq
operator|.
name|first
index|]
argument_list|,
name|buffer
argument_list|,
name|MSBSZ
operator|-
name|sc
operator|->
name|inq
operator|.
name|first
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|inq
operator|.
name|queue
argument_list|,
operator|&
name|buffer
index|[
name|MSBSZ
operator|-
name|sc
operator|->
name|inq
operator|.
name|first
index|]
argument_list|,
name|length
operator|-
operator|(
name|MSBSZ
operator|-
name|sc
operator|->
name|inq
operator|.
name|first
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|inq
operator|.
name|queue
index|[
name|sc
operator|->
name|inq
operator|.
name|first
index|]
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sc
operator|->
name|inq
operator|.
name|first
operator|=
operator|(
name|sc
operator|->
name|inq
operator|.
name|first
operator|+
name|length
operator|)
operator|%
name|MSBSZ
expr_stmt|;
name|sc
operator|->
name|inq
operator|.
name|count
operator|-=
name|length
expr_stmt|;
comment|/* Copy data to user process */
name|error
operator|=
name|uiomove
argument_list|(
name|buffer
argument_list|,
name|length
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|sc
operator|->
name|x
operator|=
name|sc
operator|->
name|y
operator|=
literal|0
expr_stmt|;
comment|/* Allow interrupts again */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|psmioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mouseinfo
name|info
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
comment|/* Get device information */
name|sc
operator|=
operator|&
name|psm_softc
index|[
name|PSMUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
comment|/* Perform IOCTL command */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOUSEIOCREAD
case|:
comment|/* Don't modify info while calculating */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* Build mouse status octet */
name|info
operator|.
name|status
operator|=
name|sc
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|x
operator|||
name|sc
operator|->
name|y
condition|)
name|info
operator|.
name|status
operator||=
name|MOVEMENT
expr_stmt|;
comment|/* Encode X and Y motion as good as we can */
if|if
condition|(
name|sc
operator|->
name|x
operator|>
literal|127
condition|)
name|info
operator|.
name|xmotion
operator|=
literal|127
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|x
operator|<
operator|-
literal|128
condition|)
name|info
operator|.
name|xmotion
operator|=
operator|-
literal|128
expr_stmt|;
else|else
name|info
operator|.
name|xmotion
operator|=
name|sc
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|y
operator|>
literal|127
condition|)
name|info
operator|.
name|ymotion
operator|=
literal|127
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|y
operator|<
operator|-
literal|128
condition|)
name|info
operator|.
name|ymotion
operator|=
operator|-
literal|128
expr_stmt|;
else|else
name|info
operator|.
name|ymotion
operator|=
name|sc
operator|->
name|y
expr_stmt|;
comment|/* Reset historical information */
name|sc
operator|->
name|x
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|&=
operator|~
name|BUTCHNGMASK
expr_stmt|;
comment|/* Allow interrupts and copy result buffer */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|info
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mouseinfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Return error code */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|psmintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
operator|&
name|psm_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|ioport
init|=
name|psmaddr
index|[
name|unit
index|]
decl_stmt|;
name|sc
operator|->
name|inq
operator|.
name|queue
index|[
name|sc
operator|->
name|inq
operator|.
name|last
operator|++
operator|%
name|MSBSZ
index|]
operator|=
name|inb
argument_list|(
name|ioport
operator|+
name|DATA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|inq
operator|.
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|ASLP
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|ASLP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|psmselect
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|rw
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
init|=
operator|&
name|psm_softc
index|[
name|PSMUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
comment|/* Silly to select for output */
if|if
condition|(
name|rw
operator|==
name|FWRITE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Return true if a mouse event available */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|inq
operator|.
name|count
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|JREMOD
end_ifdef

begin_decl_stmt
name|struct
name|cdevsw
name|psm_cdevsw
init|=
block|{
name|psmopen
block|,
name|psmclose
block|,
name|psmread
block|,
name|nowrite
block|,
comment|/*21*/
name|psmioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
comment|/* psm mice */
name|psmselect
block|,
name|nommap
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|psm_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|psm_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|psm_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|psm_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|psm_devsw_installed
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
block|{
name|int
name|x
decl_stmt|;
comment|/* default for a simple device with no probe routine (usually delete this) */
name|x
operator|=
name|devfs_add_devsw
argument_list|(
comment|/*	path	name	devsw		minor	type   uid gid perm*/
literal|"/"
argument_list|,
literal|"psm"
argument_list|,
name|major
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|0
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|psmdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|psm_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* JREMOD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

