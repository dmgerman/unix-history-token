begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993 Erik Forsberg.  * Copyright (c) 1996, 1997 Kazutaka YOKOTA.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN  * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Id: psm.c,v 1.25.2.11 1998/01/20 03:51:28 yokota Exp $  */
end_comment

begin_comment
comment|/*  *  Ported to 386bsd Oct 17, 1992  *  Sandi Donno, Computer Science, University of Cape Town, South Africa  *  Please send bug reports to sandi@cs.uct.ac.za  *  *  Thanks are also due to Rick Macklem, rick@snowhite.cis.uoguelph.ca -  *  although I was only partially successful in getting the alpha release  *  of his "driver for the Logitech and ATI Inport Bus mice for use with  *  386bsd and the X386 port" to work with my Microsoft mouse, I nevertheless  *  found his code to be an invaluable reference when porting this driver  *  to 386bsd.  *  *  Further modifications for latest 386BSD+patchkit and port to NetBSD,  *  Andrew Herbert<andrew@werple.apana.org.au> - 8 June 1993  *  *  Cloned from the Microsoft Bus Mouse driver, also by Erik Forsberg, by  *  Andrew Herbert - 12 June 1993  *  *  Modified for PS/2 mouse by Charles Hannum<mycroft@ai.mit.edu>  *  - 13 June 1993  *  *  Modified for PS/2 AUX mouse by Shoji Yuen<yuen@nuie.nagoya-u.ac.jp>  *  - 24 October 1993  *  *  Hardware access routines and probe logic rewritten by  *  Kazutaka Yokota<yokota@zodiac.mech.utsunomiya-u.ac.jp>  *  - 3, 14, 22 October 1996.  *  - 12 November 1996. IOCTLs and rearranging `psmread', `psmioctl'...  *  - 14, 30 November 1996. Uses `kbdio.c'.  *  - 13 December 1996. Uses queuing version of `kbdio.c'.  *  - January/February 1997. Tweaked probe logic for   *    HiNote UltraII/Latitude/Armada laptops.  *  - 30 July 1997. Added APM support.  *  - 5 March 1997. Defined driver configuration flags (PSM_CONFIG_XXX).   *    Improved sync check logic.  *    Vender specific support routines.  */
end_comment

begin_include
include|#
directive|include
file|"psm.h"
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_include
include|#
directive|include
file|"opt_psm.h"
end_include

begin_if
if|#
directive|if
name|NPSM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/include/mouse.h>
end_include

begin_include
include|#
directive|include
file|<i386/include/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/include/apm_bios.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/kbdio.h>
end_include

begin_comment
comment|/*  * Driver specific options: the following options may be set by  * `options' statements in the kernel configuration file.  */
end_comment

begin_comment
comment|/* debugging */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|PSM_DEBUG
value|0
end_define

begin_comment
comment|/* logging: 0: none, 1: brief, 2: verbose */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* features */
end_comment

begin_comment
comment|/* #define PSM_HOOKAPM	   	   hook the APM resume event */
end_comment

begin_comment
comment|/* #define PSM_RESETAFTERSUSPEND   reset the device at the resume event */
end_comment

begin_if
if|#
directive|if
name|NAPM
operator|<=
literal|0
end_if

begin_undef
undef|#
directive|undef
name|PSM_HOOKAPM
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_HOOKAPM
end_ifndef

begin_undef
undef|#
directive|undef
name|PSM_RESETAFTERSUSPEND
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PSM_HOOKAPM */
end_comment

begin_comment
comment|/* end of driver specific options */
end_comment

begin_comment
comment|/* input queue */
end_comment

begin_define
define|#
directive|define
name|PSM_BUFSIZE
value|960
end_define

begin_define
define|#
directive|define
name|PSM_SMALLBUFSIZE
value|240
end_define

begin_comment
comment|/* operation levels */
end_comment

begin_define
define|#
directive|define
name|PSM_LEVEL_BASE
value|0
end_define

begin_define
define|#
directive|define
name|PSM_LEVEL_STANDARD
value|1
end_define

begin_define
define|#
directive|define
name|PSM_LEVEL_NATIVE
value|2
end_define

begin_define
define|#
directive|define
name|PSM_LEVEL_MIN
value|PSM_LEVEL_BASE
end_define

begin_define
define|#
directive|define
name|PSM_LEVEL_MAX
value|PSM_LEVEL_NATIVE
end_define

begin_comment
comment|/* some macros */
end_comment

begin_define
define|#
directive|define
name|PSM_UNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>> 1)
end_define

begin_define
define|#
directive|define
name|PSM_NBLOCKIO
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 1)
end_define

begin_define
define|#
directive|define
name|PSM_MKMINOR
parameter_list|(
name|unit
parameter_list|,
name|block
parameter_list|)
value|(((unit)<< 1) | ((block) ? 0:1))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|max
end_ifndef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)> (y) ? (x) : (y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)< (y) ? (x) : (y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ring buffer */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ringbuf
block|{
name|int
name|count
decl_stmt|;
comment|/* # of valid elements in the buffer */
name|int
name|head
decl_stmt|;
comment|/* head pointer */
name|int
name|tail
decl_stmt|;
comment|/* tail poiner */
name|unsigned
name|char
name|buf
index|[
name|PSM_BUFSIZE
index|]
decl_stmt|;
block|}
name|ringbuf_t
typedef|;
end_typedef

begin_comment
comment|/* driver control block */
end_comment

begin_struct
specifier|static
struct|struct
name|psm_softc
block|{
comment|/* Driver status information */
name|struct
name|selinfo
name|rsel
decl_stmt|;
comment|/* Process selecting for Input */
name|unsigned
name|char
name|state
decl_stmt|;
comment|/* Mouse driver state */
name|int
name|config
decl_stmt|;
comment|/* driver configuration flags */
name|int
name|flags
decl_stmt|;
comment|/* other flags */
name|KBDC
name|kbdc
decl_stmt|;
comment|/* handle to access the keyboard controller */
name|int
name|addr
decl_stmt|;
comment|/* I/O port address */
name|mousehw_t
name|hw
decl_stmt|;
comment|/* hardware information */
name|mousemode_t
name|mode
decl_stmt|;
comment|/* operation mode */
name|mousemode_t
name|dflt_mode
decl_stmt|;
comment|/* default operation mode */
name|mousestatus_t
name|status
decl_stmt|;
comment|/* accumulated mouse movement */
name|ringbuf_t
name|queue
decl_stmt|;
comment|/* mouse status queue */
name|unsigned
name|char
name|ipacket
index|[
literal|16
index|]
decl_stmt|;
comment|/* interim input buffer */
name|int
name|inputbytes
decl_stmt|;
comment|/* # of bytes in the input buffer */
name|int
name|button
decl_stmt|;
comment|/* the latest button state */
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|devfs_token
decl_stmt|;
name|void
modifier|*
name|n_devfs_token
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PSM_HOOKAPM
name|struct
name|apmhook
name|resumehook
decl_stmt|;
endif|#
directive|endif
block|}
modifier|*
name|psm_softc
index|[
name|NPSM
index|]
struct|;
end_struct

begin_comment
comment|/* driver state flags (state) */
end_comment

begin_define
define|#
directive|define
name|PSM_VALID
value|0x80
end_define

begin_define
define|#
directive|define
name|PSM_OPEN
value|1
end_define

begin_comment
comment|/* Device is open */
end_comment

begin_define
define|#
directive|define
name|PSM_ASLP
value|2
end_define

begin_comment
comment|/* Waiting for mouse data */
end_comment

begin_comment
comment|/* driver configuration flags (config) */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_RESOLUTION
value|0x000f
end_define

begin_comment
comment|/* resolution */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_ACCEL
value|0x00f0
end_define

begin_comment
comment|/* acceleration factor */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_NOCHECKSYNC
value|0x0100
end_define

begin_comment
comment|/* disable sync. test */
end_comment

begin_define
define|#
directive|define
name|PSM_CONFIG_FLAGS
value|(PSM_CONFIG_RESOLUTION 		\ 				    | PSM_CONFIG_ACCEL		\ 				    | PSM_CONFIG_NOCHECKSYNC)
end_define

begin_comment
comment|/* other flags (flags) */
end_comment

begin_comment
comment|/*  * Pass mouse data packet to the user land program `as is', even if   * the mouse has vender-specific enhanced features and uses non-standard   * packet format.  Otherwise manipulate the mouse data packet so that   * it can be recognized by the programs which can only understand   * the standard packet format. */
end_comment

begin_define
define|#
directive|define
name|PSM_FLAGS_NATIVEMODE
value|0x0200
end_define

begin_comment
comment|/* for backward compatibility */
end_comment

begin_define
define|#
directive|define
name|OLD_MOUSE_GETHWINFO
value|_IOR('M', 1, old_mousehw_t)
end_define

begin_define
define|#
directive|define
name|OLD_MOUSE_GETMODE
value|_IOR('M', 2, old_mousemode_t)
end_define

begin_define
define|#
directive|define
name|OLD_MOUSE_SETMODE
value|_IOW('M', 3, old_mousemode_t)
end_define

begin_typedef
typedef|typedef
struct|struct
name|old_mousehw
block|{
name|int
name|buttons
decl_stmt|;
name|int
name|iftype
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|hwid
decl_stmt|;
block|}
name|old_mousehw_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|old_mousemode
block|{
name|int
name|protocol
decl_stmt|;
name|int
name|rate
decl_stmt|;
name|int
name|resolution
decl_stmt|;
name|int
name|accelfactor
decl_stmt|;
block|}
name|old_mousemode_t
typedef|;
end_typedef

begin_comment
comment|/* packet formatting function */
end_comment

begin_typedef
typedef|typedef
name|int
name|packetfunc_t
name|__P
typedef|((struct
name|psm_softc
modifier|*
typedef|,
name|unsigned
name|char
modifier|*
typedef|,
name|int
modifier|*
typedef|,
name|int
typedef|,
name|mousestatus_t
modifier|*
typedef|));
end_typedef

begin_comment
comment|/* function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|int
name|psmprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|psmattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|psm_drvinit
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PSM_HOOKAPM
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|psmresume
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|d_open_t
name|psmopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|psmclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|psmread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|psmioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_select_t
name|psmselect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|enable_aux_dev
name|__P
argument_list|(
operator|(
name|KBDC
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|disable_aux_dev
name|__P
argument_list|(
operator|(
name|KBDC
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_mouse_status
name|__P
argument_list|(
operator|(
name|KBDC
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_aux_id
name|__P
argument_list|(
operator|(
name|KBDC
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_mouse_sampling_rate
name|__P
argument_list|(
operator|(
name|KBDC
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_mouse_scaling
name|__P
argument_list|(
operator|(
name|KBDC
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_mouse_resolution
name|__P
argument_list|(
operator|(
name|KBDC
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|set_mouse_mode
name|__P
argument_list|(
operator|(
name|KBDC
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_mouse_buttons
name|__P
argument_list|(
operator|(
name|KBDC
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|is_a_mouse
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|recover_from_error
name|__P
argument_list|(
operator|(
name|KBDC
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|restore_controller
name|__P
argument_list|(
operator|(
name|KBDC
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|reinitialize
name|__P
argument_list|(
operator|(
name|int
operator|,
name|mousemode_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|doopen
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|model_name
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* vender specific features */
end_comment

begin_typedef
typedef|typedef
name|int
name|probefunc_t
name|__P
typedef|((struct
name|psm_softc
modifier|*
typedef|));
end_typedef

begin_decl_stmt
specifier|static
name|int
name|mouse_id_proc1
name|__P
argument_list|(
operator|(
name|KBDC
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_groller
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_gmouse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_aglide
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_kmouse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_msintelli
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|probefunc_t
name|enable_mmanplus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tame_mouse
name|__P
argument_list|(
operator|(
expr|struct
name|psm_softc
operator|*
operator|,
name|mousestatus_t
operator|*
operator|,
name|unsigned
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|int
name|model
decl_stmt|;
name|unsigned
name|char
name|syncmask
decl_stmt|;
name|int
name|packetsize
decl_stmt|;
name|probefunc_t
modifier|*
name|probefunc
decl_stmt|;
block|}
name|vendertype
index|[]
init|=
block|{
block|{
name|MOUSE_MODEL_NET
block|,
comment|/* Genius NetMouse */
literal|0xc8
block|,
name|MOUSE_INTELLI_PACKETSIZE
block|,
name|enable_gmouse
block|, }
block|,
block|{
name|MOUSE_MODEL_NETSCROLL
block|,
comment|/* Genius NetScroll */
literal|0xc8
block|,
literal|6
block|,
name|enable_groller
block|, }
block|,
block|{
name|MOUSE_MODEL_GLIDEPOINT
block|,
comment|/* ALPS GlidePoint */
literal|0xc0
block|,
name|MOUSE_PS2_PACKETSIZE
block|,
name|enable_aglide
block|, }
block|,
block|{
name|MOUSE_MODEL_MOUSEMANPLUS
block|,
comment|/* Logitech MouseMan+ */
literal|0x08
block|,
name|MOUSE_PS2_PACKETSIZE
block|,
name|enable_mmanplus
block|, }
block|,
block|{
name|MOUSE_MODEL_THINK
block|,
comment|/* Kensignton ThinkingMouse */
literal|0x80
block|,
name|MOUSE_PS2_PACKETSIZE
block|,
name|enable_kmouse
block|, }
block|,
block|{
name|MOUSE_MODEL_INTELLI
block|,
comment|/* Microsoft IntelliMouse */
literal|0xc8
block|,
name|MOUSE_INTELLI_PACKETSIZE
block|,
name|enable_msintelli
block|, }
block|,
block|{
name|MOUSE_MODEL_GENERIC
block|,
literal|0xc0
block|,
name|MOUSE_PS2_PACKETSIZE
block|,
name|NULL
block|, }
block|, }
struct|;
end_struct

begin_comment
comment|/* device driver declarateion */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|psmdriver
init|=
block|{
name|psmprobe
block|,
name|psmattach
block|,
literal|"psm"
block|,
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|21
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|psm_cdevsw
init|=
block|{
name|psmopen
block|,
name|psmclose
block|,
name|psmread
block|,
name|nowrite
block|,
comment|/* 21 */
name|psmioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|psmselect
block|,
name|nommap
block|,
name|NULL
block|,
literal|"psm"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug message level */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose
init|=
name|PSM_DEBUG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device I/O routines */
end_comment

begin_function
specifier|static
name|int
name|enable_aux_dev
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_ENABLE_DEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: ENABLE_DEV return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|disable_aux_dev
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_DISABLE_DEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: DISABLE_DEV return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_mouse_status
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|cmd
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
literal|0
case|:
default|default:
name|cmd
operator|=
name|PSMC_SEND_DEV_STATUS
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|cmd
operator|=
name|PSMC_SEND_DEV_DATA
expr_stmt|;
break|break;
block|}
name|empty_aux_buffer
argument_list|(
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SEND_AUX_DEV_%s return code:%04x\n"
argument_list|,
operator|(
name|flag
operator|==
literal|1
operator|)
condition|?
literal|"DATA"
else|:
literal|"STATUS"
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|PSM_ACK
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|status
index|[
name|i
index|]
operator|=
name|read_aux_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
index|[
name|i
index|]
operator|<
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: %s %02x %02x %02x\n"
argument_list|,
operator|(
name|flag
operator|==
literal|1
operator|)
condition|?
literal|"data"
else|:
literal|"status"
argument_list|,
name|status
index|[
literal|0
index|]
argument_list|,
name|status
index|[
literal|1
index|]
argument_list|,
name|status
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_aux_id
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|int
name|id
decl_stmt|;
name|empty_aux_buffer
argument_list|(
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SEND_DEV_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SEND_DEV_ID return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|PSM_ACK
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 10ms delay */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|id
operator|=
name|read_aux_data
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: device ID: %04x\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_mouse_sampling_rate
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command_and_data
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SET_SAMPLING_RATE
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_SAMPLING_RATE (%d) %04x\n"
argument_list|,
name|rate
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
condition|?
name|rate
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_mouse_scaling
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|scale
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
switch|switch
condition|(
name|scale
condition|)
block|{
case|case
literal|1
case|:
default|default:
name|scale
operator|=
name|PSMC_SET_SCALING11
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|scale
operator|=
name|PSMC_SET_SCALING21
expr_stmt|;
break|break;
block|}
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_SCALING%s return code:%04x\n"
argument_list|,
operator|(
name|scale
operator|==
name|PSMC_SET_SCALING21
operator|)
condition|?
literal|"21"
else|:
literal|"11"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* `val' must be 0 through PSMD_MAX_RESOLUTION */
end_comment

begin_function
specifier|static
name|int
name|set_mouse_resolution
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command_and_data
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SET_RESOLUTION
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_RESOLUTION (%d) %04x\n"
argument_list|,
name|val
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
condition|?
name|val
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE: once `set_mouse_mode()' is called, the mouse device must be  * re-enabled by calling `enable_aux_dev()'  */
end_comment

begin_function
specifier|static
name|int
name|set_mouse_mode
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|kbdc
argument_list|,
name|PSMC_SET_STREAM_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_STREAM_MODE return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_mouse_buttons
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
name|int
name|c
init|=
literal|2
decl_stmt|;
comment|/* assume two buttons by default */
name|int
name|res
decl_stmt|;
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/*      * NOTE: a special sequence to obtain Logitech Mouse specific      * information: set resolution to 25 ppi, set scaling to 1:1, set      * scaling to 1:1, set scaling to 1:1. Then the second byte of the      * mouse status bytes is the number of available buttons.      * Some manufactures also support this sequence.      */
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|PSMD_RES_LOW
argument_list|)
operator|!=
name|PSMD_RES_LOW
condition|)
return|return
name|c
return|;
if|if
condition|(
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
operator|&&
operator|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|>=
literal|3
operator|)
condition|)
block|{
if|if
condition|(
name|status
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
return|return
name|status
index|[
literal|1
index|]
return|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* misc subroutines */
end_comment

begin_comment
comment|/*  * Someday, I will get the complete list of valid pointing devices and  * their IDs... XXX  */
end_comment

begin_function
specifier|static
name|int
name|is_a_mouse
parameter_list|(
name|int
name|id
parameter_list|)
block|{
specifier|static
name|int
name|valid_ids
index|[]
init|=
block|{
name|PSM_MOUSE_ID
block|,
comment|/* mouse */
name|PSM_BALLPOINT_ID
block|,
comment|/* ballpoint device */
name|PSM_INTELLI_ID
block|,
comment|/* Intellimouse */
operator|-
literal|1
comment|/* end of table */
block|}
decl_stmt|;
if|#
directive|if
literal|0
block|int i;      for (i = 0; valid_ids[i]>= 0; ++i)         if (valid_ids[i] == id)             return TRUE;     return FALSE;
else|#
directive|else
return|return
name|TRUE
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|model_name
parameter_list|(
name|int
name|model
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|model_code
decl_stmt|;
name|char
modifier|*
name|model_name
decl_stmt|;
block|}
name|models
index|[]
init|=
block|{
block|{
name|MOUSE_MODEL_NETSCROLL
block|,
literal|"NetScroll Mouse"
block|}
block|,
block|{
name|MOUSE_MODEL_NET
block|,
literal|"NetMouse"
block|}
block|,
block|{
name|MOUSE_MODEL_GLIDEPOINT
block|,
literal|"GlidePoint"
block|}
block|,
block|{
name|MOUSE_MODEL_THINK
block|,
literal|"ThinkingMouse"
block|}
block|,
block|{
name|MOUSE_MODEL_INTELLI
block|,
literal|"IntelliMouse"
block|}
block|,
block|{
name|MOUSE_MODEL_MOUSEMANPLUS
block|,
literal|"MouseMan+"
block|}
block|,
block|{
name|MOUSE_MODEL_GENERIC
block|,
literal|"Generic PS/2 mouse"
block|}
block|,
block|{
name|MOUSE_MODEL_UNKNOWN
block|,
name|NULL
block|}
block|,     }
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|models
index|[
name|i
index|]
operator|.
name|model_code
operator|!=
name|MOUSE_MODEL_UNKNOWN
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|models
index|[
name|i
index|]
operator|.
name|model_code
operator|==
name|model
condition|)
return|return
name|models
index|[
name|i
index|]
operator|.
name|model_name
return|;
block|}
return|return
literal|"Unknown"
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|recover_from_error
parameter_list|(
name|KBDC
name|kbdc
parameter_list|)
block|{
comment|/* discard anything left in the output buffer */
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/*      * NOTE: KBDC_RESET_KBD may not restore the communication between the      * keyboard and the controller.      */
block|reset_kbd(kbdc);
else|#
directive|else
comment|/*      * NOTE: somehow diagnostic and keyboard port test commands bring the      * keyboard back.      */
if|if
condition|(
operator|!
name|test_controller
argument_list|(
name|kbdc
argument_list|)
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm: keyboard controller failed.\n"
argument_list|)
expr_stmt|;
comment|/* if there isn't a keyboard in the system, the following error is OK */
if|if
condition|(
name|test_kbd_port
argument_list|(
name|kbdc
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm: keyboard port failed.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|restore_controller
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|command_byte
parameter_list|)
block|{
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
literal|0xff
argument_list|,
name|command_byte
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm: failed to restore the keyboard controller "
literal|"command byte.\n"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
else|else
block|{
return|return
name|TRUE
return|;
block|}
block|}
end_function

begin_comment
comment|/*   * Re-initialize the aux port and device. The aux port must be enabled  * and its interrupt must be disabled before calling this routine.   * The aux device will be disabled before returning.  * The keyboard controller must be locked via `kbdc_lock()' before  * calling this routine.  */
end_comment

begin_function
specifier|static
name|int
name|reinitialize
parameter_list|(
name|int
name|unit
parameter_list|,
name|mousemode_t
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|unit
index|]
decl_stmt|;
name|KBDC
name|kbdc
init|=
name|psm_softc
index|[
name|unit
index|]
operator|->
name|kbdc
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
operator|(
name|i
operator|=
name|test_aux_port
argument_list|(
name|kbdc
argument_list|)
operator|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* ignore this error */
if|if
condition|(
name|verbose
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: strange result for test aux port (%d).\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* fall though */
case|case
literal|0
case|:
comment|/* no error */
break|break;
case|case
operator|-
literal|1
case|:
comment|/* time out */
default|default:
comment|/* error */
name|recover_from_error
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: the aux port is not functioning (%d).\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/*       * NOTE: some controllers appears to hang the `keyboard' when      * the aux port doesn't exist and `PSMC_RESET_DEV' is issued.       */
if|if
condition|(
operator|!
name|reset_aux_dev
argument_list|(
name|kbdc
argument_list|)
condition|)
block|{
name|recover_from_error
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to reset the aux device.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/*       * both the aux port and the aux device is functioning, see      * if the device can be enabled.       */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|kbdc
argument_list|)
operator|||
operator|!
name|disable_aux_dev
argument_list|(
name|kbdc
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the aux device.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* remove stray data if any */
comment|/* FIXME: hardware ID, mouse buttons? */
comment|/* other parameters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vendertype
index|[
name|i
index|]
operator|.
name|probefunc
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|vendertype
index|[
name|i
index|]
operator|.
name|probefunc
operator|)
operator|(
name|sc
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: found %s\n"
argument_list|,
name|unit
argument_list|,
name|model_name
argument_list|(
name|vendertype
index|[
name|i
index|]
operator|.
name|model
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|sc
operator|->
name|hw
operator|.
name|model
operator|=
name|vendertype
index|[
name|i
index|]
operator|.
name|model
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|vendertype
index|[
name|i
index|]
operator|.
name|packetsize
expr_stmt|;
comment|/* set mouse parameters */
if|if
condition|(
name|mode
operator|!=
operator|(
name|mousemode_t
operator|*
operator|)
name|NULL
condition|)
block|{
if|if
condition|(
name|mode
operator|->
name|rate
operator|>
literal|0
condition|)
name|mode
operator|->
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|mode
operator|->
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|resolution
operator|>=
literal|0
condition|)
name|mode
operator|->
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|mode
operator|->
name|resolution
argument_list|)
expr_stmt|;
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_mouse_mode
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
block|}
comment|/* request a data packet and extract sync. bits */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get data (reinitialize).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|stat
index|[
literal|0
index|]
operator|&
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
expr_stmt|;
comment|/* syncbits */
comment|/* the NetScroll Mouse will send three more bytes... Ignore them */
name|empty_aux_buffer
argument_list|(
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* just check the status of the mouse */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get status (reinitialize).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|doopen
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|command_byte
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
comment|/* enable the mouse device */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
comment|/* MOUSE ERROR: failed to enable the mouse because: 	 * 1) the mouse is faulty, 	 * 2) the mouse has been removed(!?) 	 * In the latter case, the keyboard may have hung, and need  	 * recovery procedure... 	 */
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME: we could reset the mouse here and try to enable 	 * it again. But it will take long time and it's not a good 	 * idea to disable the keyboard that long... 	 */
block|if (!reinitialize(unit,&sc->mode) || !enable_aux_dev(sc->kbdc)) { 	    recover_from_error(sc->kbdc);
else|#
directive|else
block|{
endif|#
directive|endif
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
comment|/* mark this device is no longer available */
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_VALID
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the device (doopen).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get status (doopen).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* enable the aux port and interrupt */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
operator|(
name|command_byte
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_ENABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the aux interrupt (doopen).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* psm driver entry points */
end_comment

begin_define
define|#
directive|define
name|endprobe
parameter_list|(
name|v
parameter_list|)
value|{   if (bootverbose) 				\ 				--verbose;   				\                             kbdc_set_device_mask(sc->kbdc, mask);	\ 			    kbdc_lock(sc->kbdc, FALSE);			\  	                    free(sc, M_DEVBUF);                         \ 			    return (v);	     				\ 			}
end_define

begin_function
specifier|static
name|int
name|psmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* validate unit number */
if|if
condition|(
name|unit
operator|>=
name|NPSM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|psm_softc
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sc
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
expr|*
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|kbdc_debug(TRUE);
endif|#
directive|endif
name|sc
operator|->
name|addr
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|sc
operator|->
name|kbdc
operator|=
name|kbdc_open
argument_list|(
name|sc
operator|->
name|addr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|config
operator|=
name|dvp
operator|->
name|id_flags
operator|&
name|PSM_CONFIG_FLAGS
expr_stmt|;
name|sc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|++
name|verbose
expr_stmt|;
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"psm%d: unable to lock the controller.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|--
name|verbose
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * NOTE: two bits in the command byte controls the operation of the      * aux port (mouse port): the aux port disable bit (bit 5) and the aux      * port interrupt (IRQ 12) enable bit (bit 2).      */
comment|/* discard anything left after the keyboard initialization */
name|empty_both_buffers
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* save the current command byte; it will be used later */
name|mask
operator|=
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|&
operator|~
name|KBD_AUX_CONTROL_BITS
expr_stmt|;
name|command_byte
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: current command byte:%04x\n"
argument_list|,
name|unit
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_byte
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|printf
argument_list|(
literal|"psm%d: unable to get the current command byte value.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * disable the keyboard port while probing the aux port, which must be      * enabled during this routine      */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/*  	 * this is CONTROLLER ERROR; I don't know how to recover           * from this error...  	 */
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: unable to set the command byte.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * NOTE: `test_aux_port()' is designed to return with zero if the aux      * port exists and is functioning. However, some controllers appears      * to respond with zero even when the aux port doesn't exist. (It may      * be that this is only the case when the controller DOES have the aux      * port but the port is not wired on the motherboard.) The keyboard      * controllers without the port, such as the original AT, are      * supporsed to return with an error code or simply time out. In any      * case, we have to continue probing the port even when the controller      * passes this test.      *      * XXX: some controllers erroneously return the error code 1 when      * it has the perfectly functional aux port. We have to ignore this      * error code. Even if the controller HAS error with the aux port,      * it will be detected later...      */
switch|switch
condition|(
operator|(
name|i
operator|=
name|test_aux_port
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* ignore this error */
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: strange result for test aux port (%d).\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* fall though */
case|case
literal|0
case|:
comment|/* no error */
break|break;
case|case
operator|-
literal|1
case|:
comment|/* time out */
default|default:
comment|/* error */
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: the aux port is not functioning (%d).\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * NOTE: some controllers appears to hang the `keyboard' when the aux      * port doesn't exist and `PSMC_RESET_DEV' is issued.      */
if|if
condition|(
operator|!
name|reset_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
name|recover_from_error
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: failed to reset the aux device.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*      * both the aux port and the aux device is functioning, see if the      * device can be enabled. NOTE: when enabled, the device will start      * sending data; we shall immediately disable the device once we know      * the device can be enabled.      */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|||
operator|!
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
comment|/* MOUSE ERROR */
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: failed to enable the aux device.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* save the default values after reset */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|>=
literal|3
condition|)
block|{
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|stat
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|stat
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* hardware information */
name|sc
operator|->
name|hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_PS2
expr_stmt|;
comment|/* verify the device is a mouse */
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|get_aux_id
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_a_mouse
argument_list|(
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|)
condition|)
block|{
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: unknown device type (%d).\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sc
operator|->
name|hw
operator|.
name|hwid
condition|)
block|{
case|case
name|PSM_BALLPOINT_ID
case|:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_TRACKBALL
expr_stmt|;
break|break;
case|case
name|PSM_MOUSE_ID
case|:
case|case
name|PSM_INTELLI_ID
case|:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_MOUSE
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_UNKNOWN
expr_stmt|;
break|break;
block|}
comment|/* # of buttons */
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|get_mouse_buttons
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* other parameters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vendertype
index|[
name|i
index|]
operator|.
name|probefunc
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|vendertype
index|[
name|i
index|]
operator|.
name|probefunc
operator|)
operator|(
name|sc
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"psm%d: found %s\n"
argument_list|,
name|unit
argument_list|,
name|model_name
argument_list|(
name|vendertype
index|[
name|i
index|]
operator|.
name|model
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|sc
operator|->
name|hw
operator|.
name|model
operator|=
name|vendertype
index|[
name|i
index|]
operator|.
name|model
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|level
operator|=
name|PSM_LEVEL_BASE
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|packetsize
operator|=
name|MOUSE_PS2_PACKETSIZE
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|accelfactor
operator|=
operator|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_ACCEL
operator|)
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_NOCHECKSYNC
condition|)
name|sc
operator|->
name|dflt_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|dflt_mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
name|vendertype
index|[
name|i
index|]
operator|.
name|syncmask
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* syncbits */
name|sc
operator|->
name|mode
operator|=
name|sc
operator|->
name|dflt_mode
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|packetsize
operator|=
name|vendertype
index|[
name|i
index|]
operator|.
name|packetsize
expr_stmt|;
comment|/* set mouse parameters */
name|i
operator|=
name|send_aux_command
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|PSMC_SET_DEFAULTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|printf
argument_list|(
literal|"psm%d: SET_DEFAULTS return code:%04x\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_RESOLUTION
condition|)
block|{
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
operator|(
name|sc
operator|->
name|config
operator|&
name|PSM_CONFIG_RESOLUTION
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* request a data packet and extract sync. bits */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"psm%d: failed to get data.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|=
name|stat
index|[
literal|0
index|]
operator|&
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
expr_stmt|;
comment|/* syncbits */
comment|/* the NetScroll Mouse will send three more bytes... Ignore them */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* just check the status of the mouse */
comment|/*       * NOTE: XXX there are some arcane controller/mouse combinations out       * there, which hung the controller unless there is data transmission       * after ACK from the mouse.      */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"psm%d: failed to get status.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  	 * When in its native mode, some mice operate with different  	 * default parameters than in the PS/2 compatible mode. 	 */
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|stat
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|stat
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* disable the aux port for now... */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
argument_list|,
operator|(
name|command_byte
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/*  	 * this is CONTROLLER ERROR; I don't know the proper way to           * recover from this error...  	 */
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: unable to set the command byte.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|endprobe
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* done */
name|psm_softc
index|[
name|unit
index|]
operator|=
name|sc
expr_stmt|;
name|kbdc_set_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mask
operator||
name|KBD_AUX_CONTROL_BITS
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|IO_PSMSIZE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
comment|/* shouldn't happen */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Setup initial state */
name|sc
operator|->
name|state
operator|=
name|PSM_VALID
expr_stmt|;
comment|/* Done */
ifdef|#
directive|ifdef
name|DEVFS
name|sc
operator|->
name|devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|psm_cdevsw
argument_list|,
name|PSM_MKMINOR
argument_list|(
name|unit
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0666
argument_list|,
literal|"psm%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|n_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|psm_cdevsw
argument_list|,
name|PSM_MKMINOR
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|)
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0666
argument_list|,
literal|"npsm%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEVFS */
ifdef|#
directive|ifdef
name|PSM_HOOKAPM
name|sc
operator|->
name|resumehook
operator|.
name|ah_name
operator|=
literal|"PS/2 mouse"
expr_stmt|;
name|sc
operator|->
name|resumehook
operator|.
name|ah_fun
operator|=
name|psmresume
expr_stmt|;
name|sc
operator|->
name|resumehook
operator|.
name|ah_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|unit
expr_stmt|;
name|sc
operator|->
name|resumehook
operator|.
name|ah_order
operator|=
name|APM_MID_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_RESUME
argument_list|,
operator|&
name|sc
operator|->
name|resumehook
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: APM hooks installed.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PSM_HOOKAPM */
if|if
condition|(
operator|!
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"psm%d: model %s, device ID %d\n"
argument_list|,
name|unit
argument_list|,
name|model_name
argument_list|(
name|sc
operator|->
name|hw
operator|.
name|model
argument_list|)
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"psm%d: model %s, device ID %d, %d buttons\n"
argument_list|,
name|unit
argument_list|,
name|model_name
argument_list|(
name|sc
operator|->
name|hw
operator|.
name|model
argument_list|)
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|buttons
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: config:%08x, flags:%08x, packet size:%d\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|config
argument_list|,
name|sc
operator|->
name|flags
argument_list|,
name|sc
operator|->
name|mode
operator|.
name|packetsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"psm%d: syncmask:%02x, syncbits:%02x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
operator|--
name|verbose
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Validate unit number */
if|if
condition|(
name|unit
operator|>=
name|NPSM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Get device data */
name|sc
operator|=
name|psm_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
operator|==
literal|0
condition|)
comment|/* the device is no longer valid/functioning */
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Disallow multiple opens */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Initialize state */
name|sc
operator|->
name|rsel
operator|.
name|si_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rsel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|level
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|protocol
expr_stmt|;
comment|/* flush the event queue */
name|sc
operator|->
name|queue
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|obutton
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|button
operator|=
literal|0
expr_stmt|;
comment|/* empty input buffer */
name|bzero
argument_list|(
name|sc
operator|->
name|ipacket
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|ipacket
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
comment|/* don't let timeout routines in the keyboard driver to poll the kbdc */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* save the current controller command byte */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|command_byte
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* enable the aux port and temporalily disable the keyboard */
if|if
condition|(
operator|(
name|command_byte
operator|==
operator|-
literal|1
operator|)
operator|||
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR; do you know how to get out of this? */
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: unable to set the command byte (psmopen).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/*       * Now that the keyboard controller is told not to generate       * the keyboard and mouse interrupts, call `splx()' to allow       * the other tty interrupts. The clock interrupt may also occur,       * but timeout routines will be blocked by the poll flag set       * via `kbdc_lock()'      */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* enable the mouse device */
name|err
operator|=
name|doopen
argument_list|(
name|unit
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
comment|/* done */
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|sc
operator|->
name|state
operator||=
name|PSM_OPEN
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* don't let timeout routines in the keyboard driver to poll the kbdc */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* save the current controller command byte */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|command_byte
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_byte
operator|==
operator|-
literal|1
condition|)
block|{
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* disable the aux interrupt and temporalily disable the keyboard */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the aux int (psmclose).\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* CONTROLLER ERROR; 	 * NOTE: we shall force our way through. Because the only 	 * ill effect we shall see is that we may not be able 	 * to read ACK from the mouse, and it doesn't matter much  	 * so long as the mouse will accept the DISABLE command. 	 */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* remove anything left in the output buffer */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* disable the aux device, port and interrupt */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
condition|)
block|{
if|if
condition|(
operator|!
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
condition|)
block|{
comment|/* MOUSE ERROR;  	     * NOTE: we don't return error and continue, pretending  	     * we have successfully disabled the device. It's OK because  	     * the interrupt routine will discard any data from the mouse 	     * hereafter.  	     */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the device (psmclose).\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: failed to get status (psmclose).\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
operator|(
name|command_byte
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR;  	 * we shall ignore this error; see the above comment. 	 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the aux port (psmclose).\n"
argument_list|,
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* remove anything left in the output buffer */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* close is almost always successful */
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_OPEN
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tame_mouse
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|mousestatus_t
modifier|*
name|status
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|butmapps2
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
name|MOUSE_PS2_BUTTON1DOWN
block|,
name|MOUSE_PS2_BUTTON2DOWN
block|,
name|MOUSE_PS2_BUTTON1DOWN
operator||
name|MOUSE_PS2_BUTTON2DOWN
block|,
name|MOUSE_PS2_BUTTON3DOWN
block|,
name|MOUSE_PS2_BUTTON1DOWN
operator||
name|MOUSE_PS2_BUTTON3DOWN
block|,
name|MOUSE_PS2_BUTTON2DOWN
operator||
name|MOUSE_PS2_BUTTON3DOWN
block|,
name|MOUSE_PS2_BUTTON1DOWN
operator||
name|MOUSE_PS2_BUTTON2DOWN
operator||
name|MOUSE_PS2_BUTTON3DOWN
block|,     }
decl_stmt|;
specifier|static
name|unsigned
name|char
name|butmapmsc
index|[
literal|8
index|]
init|=
block|{
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON1UP
operator||
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON1UP
block|,
literal|0
block|,     }
decl_stmt|;
name|int
name|mapped
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
name|PSM_LEVEL_BASE
condition|)
block|{
name|mapped
operator|=
name|status
operator|->
name|button
operator|&
operator|~
name|MOUSE_BUTTON4DOWN
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|button
operator|&
name|MOUSE_BUTTON4DOWN
condition|)
name|mapped
operator||=
name|MOUSE_BUTTON1DOWN
expr_stmt|;
name|status
operator|->
name|button
operator|=
name|mapped
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_PS2_SYNC
operator||
name|butmapps2
index|[
name|mapped
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
name|i
operator|=
name|max
argument_list|(
name|min
argument_list|(
name|status
operator|->
name|dx
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|buf
index|[
literal|0
index|]
operator||=
name|MOUSE_PS2_XNEG
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|i
expr_stmt|;
name|i
operator|=
name|max
argument_list|(
name|min
argument_list|(
name|status
operator|->
name|dy
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|buf
index|[
literal|0
index|]
operator||=
name|MOUSE_PS2_YNEG
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|i
expr_stmt|;
return|return
name|MOUSE_PS2_PACKETSIZE
return|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
name|PSM_LEVEL_STANDARD
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNC
operator||
name|butmapmsc
index|[
name|status
operator|->
name|button
operator|&
name|MOUSE_STDBUTTONS
index|]
expr_stmt|;
name|i
operator|=
name|max
argument_list|(
name|min
argument_list|(
name|status
operator|->
name|dx
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|i
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|i
operator|-
name|buf
index|[
literal|1
index|]
expr_stmt|;
name|i
operator|=
name|max
argument_list|(
name|min
argument_list|(
name|status
operator|->
name|dy
argument_list|,
literal|255
argument_list|)
argument_list|,
operator|-
literal|256
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|i
operator|>>
literal|1
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|i
operator|-
name|buf
index|[
literal|2
index|]
expr_stmt|;
name|i
operator|=
name|max
argument_list|(
name|min
argument_list|(
name|status
operator|->
name|dz
argument_list|,
literal|127
argument_list|)
argument_list|,
operator|-
literal|128
argument_list|)
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
operator|(
name|i
operator|>>
literal|1
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
operator|(
name|i
operator|-
operator|(
name|i
operator|>>
literal|1
operator|)
operator|)
operator|&
literal|0x7f
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
operator|(
operator|~
name|status
operator|->
name|button
operator|>>
literal|3
operator|)
operator|&
literal|0x7f
expr_stmt|;
return|return
name|MOUSE_SYS_PACKETSIZE
return|;
block|}
return|return
name|sc
operator|->
name|inputbytes
return|;
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|PSM_SMALLBUFSIZE
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|l
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
operator|==
literal|0
condition|)
return|return
name|EIO
return|;
comment|/* block until mouse activity occured */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|PSM_NBLOCKIO
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EWOULDBLOCK
return|;
block|}
name|sc
operator|->
name|state
operator||=
name|PSM_ASLP
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"psmrea"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_ASLP
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* the device disappeared! */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* copy data to the user land */
while|while
condition|(
operator|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|)
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|count
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|head
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|sc
operator|->
name|queue
operator|.
name|head
index|]
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|head
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|buf
index|[
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|head
index|]
argument_list|,
name|l
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|head
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|sc
operator|->
name|queue
operator|.
name|head
index|]
argument_list|,
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|queue
operator|.
name|count
operator|-=
name|l
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
operator|(
name|sc
operator|->
name|queue
operator|.
name|head
operator|+
name|l
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|buf
argument_list|,
name|l
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|block_mouse_data
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
name|EIO
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
name|c
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|c
operator|==
operator|-
literal|1
operator|)
operator|||
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* this is CONTROLLER ERROR */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
comment|/*       * The device may be in the middle of status data transmission.      * The transmission will be interrupted, thus, incomplete status       * data must be discarded. Although the aux interrupt is disabled       * at the keyboard controller level, at most one aux interrupt       * may have already been pending and a data byte is in the       * output buffer; throw it away. Note that the second argument       * to `empty_aux_buffer()' is zero, so that the call will just       * flush the internal queue.      * `psmintr()' will be invoked after `splx()' if an interrupt is      * pending; it will see no data and returns immediately.      */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* flush the queue */
name|read_aux_data_no_wait
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* throw away data if any */
name|sc
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unblock_mouse_data
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/*       * We may have seen a part of status data during `set_mouse_XXX()'.      * they have been queued; flush it.      */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* restore ports and interrupt */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|c
operator|&
operator|(
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
operator|)
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR; this is serious, we may have          * been left with the inaccessible keyboard and          * the disabled mouse interrupt.           */
name|error
operator|=
name|EIO
expr_stmt|;
block|}
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|mousemode_t
name|mode
decl_stmt|;
name|mousestatus_t
name|status
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_GETVARS
argument_list|)
operator|)
name|mousevar_t
modifier|*
name|var
decl_stmt|;
endif|#
directive|endif
name|mousedata_t
modifier|*
name|data
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|command_byte
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Perform IOCTL command */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|OLD_MOUSE_GETHWINFO
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|(
name|old_mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|buttons
operator|=
name|sc
operator|->
name|hw
operator|.
name|buttons
expr_stmt|;
operator|(
operator|(
name|old_mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|iftype
operator|=
name|sc
operator|->
name|hw
operator|.
name|iftype
expr_stmt|;
operator|(
operator|(
name|old_mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|type
operator|=
name|sc
operator|->
name|hw
operator|.
name|type
expr_stmt|;
operator|(
operator|(
name|old_mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|hwid
operator|=
name|sc
operator|->
name|hw
operator|.
name|hwid
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETHWINFO
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
operator|(
name|mousehw_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|hw
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|==
name|PSM_LEVEL_BASE
condition|)
operator|(
operator|(
name|mousehw_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|model
operator|=
name|MOUSE_MODEL_GENERIC
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|OLD_MOUSE_GETMODE
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
condition|)
block|{
case|case
name|PSM_LEVEL_BASE
case|:
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
break|break;
case|case
name|PSM_LEVEL_STANDARD
case|:
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
break|break;
case|case
name|PSM_LEVEL_NATIVE
case|:
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
break|break;
block|}
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
expr_stmt|;
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
expr_stmt|;
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|accelfactor
operator|=
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETMODE
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|mode
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|=
name|MOUSE_RES_LOW
operator|-
name|sc
operator|->
name|mode
operator|.
name|resolution
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
condition|)
block|{
case|case
name|PSM_LEVEL_BASE
case|:
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|packetsize
operator|=
name|MOUSE_PS2_PACKETSIZE
expr_stmt|;
break|break;
case|case
name|PSM_LEVEL_STANDARD
case|:
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_SYSMOUSE
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|packetsize
operator|=
name|MOUSE_SYS_PACKETSIZE
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|syncmask
index|[
literal|0
index|]
operator|=
name|MOUSE_SYS_SYNCMASK
expr_stmt|;
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|syncmask
index|[
literal|1
index|]
operator|=
name|MOUSE_SYS_SYNC
expr_stmt|;
break|break;
case|case
name|PSM_LEVEL_NATIVE
case|:
comment|/* FIXME: this isn't quite correct... XXX */
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|OLD_MOUSE_SETMODE
case|:
case|case
name|MOUSE_SETMODE
case|:
if|if
condition|(
name|cmd
operator|==
name|OLD_MOUSE_SETMODE
condition|)
block|{
name|mode
operator|.
name|rate
operator|=
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|rate
expr_stmt|;
comment|/* 	     * resolution  old I/F   new I/F 	     * default        0         0 	     * low            1        -2 	     * medium low     2        -3 	     * medium high    3        -4 	     * high           4        -5 	     */
if|if
condition|(
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|>
literal|0
condition|)
name|mode
operator|.
name|resolution
operator|=
operator|-
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|-
literal|1
expr_stmt|;
name|mode
operator|.
name|accelfactor
operator|=
operator|(
operator|(
name|old_mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|accelfactor
expr_stmt|;
name|mode
operator|.
name|level
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
expr_stmt|;
block|}
comment|/* adjust and validate parameters. */
if|if
condition|(
name|mode
operator|.
name|rate
operator|>
name|UCHAR_MAX
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mode
operator|.
name|rate
operator|==
literal|0
condition|)
name|mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|rate
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
empty_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|rate
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
name|UCHAR_MAX
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|200
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|100
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMHIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|50
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMLOW
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>
literal|0
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|==
name|MOUSE_RES_DEFAULT
condition|)
name|mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
empty_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|<
literal|0
condition|)
comment|/* MOUSE_RES_LOW/MEDIUM/HIGH */
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
operator|-
name|mode
operator|.
name|resolution
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|level
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
name|mode
operator|.
name|level
operator|=
name|sc
operator|->
name|mode
operator|.
name|level
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|mode
operator|.
name|level
operator|<
name|PSM_LEVEL_MIN
operator|)
operator|||
operator|(
name|mode
operator|.
name|level
operator|>
name|PSM_LEVEL_MAX
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mode
operator|.
name|accelfactor
operator|==
operator|-
literal|1
condition|)
comment|/* don't change the current setting */
name|mode
operator|.
name|accelfactor
operator|=
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|accelfactor
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
comment|/* don't allow anybody to poll the keyboard controller */
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* set mouse parameters */
if|if
condition|(
name|mode
operator|.
name|rate
operator|>
literal|0
condition|)
name|mode
operator|.
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|0
condition|)
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|resolution
argument_list|)
expr_stmt|;
name|set_mouse_scaling
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|stat
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|mode
operator|.
name|rate
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|mode
operator|.
name|resolution
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|=
name|mode
operator|.
name|accelfactor
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
name|mode
operator|.
name|level
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_GETLEVEL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|mode
operator|.
name|level
expr_stmt|;
break|break;
case|case
name|MOUSE_SETLEVEL
case|:
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|<
name|PSM_LEVEL_MIN
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|>
name|PSM_LEVEL_MAX
operator|)
condition|)
return|return
name|EINVAL
return|;
name|sc
operator|->
name|mode
operator|.
name|level
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|MOUSE_GETSTATUS
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|status
operator|=
name|sc
operator|->
name|status
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|obutton
operator|=
name|sc
operator|->
name|status
operator|.
name|button
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dz
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
operator|(
name|mousestatus_t
operator|*
operator|)
name|addr
operator|=
name|status
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_GETVARS
argument_list|)
operator|)
case|case
name|MOUSE_GETVARS
case|:
name|var
operator|=
operator|(
name|mousevar_t
operator|*
operator|)
name|addr
expr_stmt|;
name|bzero
argument_list|(
name|var
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|var
operator|->
name|var
index|[
literal|0
index|]
operator|=
name|MOUSE_VARS_PS2_SIG
expr_stmt|;
name|var
operator|->
name|var
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|config
expr_stmt|;
name|var
operator|->
name|var
index|[
literal|2
index|]
operator|=
name|sc
operator|->
name|flags
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSE_SETVARS
case|:
return|return
name|ENODEV
return|;
endif|#
directive|endif
comment|/* MOUSE_GETVARS */
case|case
name|MOUSE_READSTATE
case|:
case|case
name|MOUSE_READDATA
case|:
name|data
operator|=
operator|(
name|mousedata_t
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|len
operator|>
sizeof|sizeof
argument_list|(
name|data
operator|->
name|buf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|data
operator|->
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|data
operator|->
name|len
operator|=
name|get_mouse_status
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|data
operator|->
name|buf
argument_list|,
operator|(
name|cmd
operator|==
name|MOUSE_READDATA
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|data
operator|->
name|len
argument_list|)
operator|)
operator|<=
literal|0
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_SETRESOLUTION
argument_list|)
operator|)
case|case
name|MOUSE_SETRESOLUTION
case|:
name|mode
operator|.
name|resolution
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
name|UCHAR_MAX
condition|)
return|return
name|EINVAL
return|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|200
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_HIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|100
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMHIGH
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>=
literal|50
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_MEDIUMLOW
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|>
literal|0
condition|)
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|resolution
operator|==
name|MOUSE_RES_DEFAULT
condition|)
name|mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|resolution
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|==
operator|-
literal|1
condition|)
name|mode
operator|.
name|resolution
operator|=
name|sc
operator|->
name|mode
operator|.
name|resolution
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|resolution
operator|<
literal|0
condition|)
comment|/* MOUSE_RES_LOW/MEDIUM/HIGH */
name|mode
operator|.
name|resolution
operator|=
name|MOUSE_RES_LOW
operator|-
name|mode
operator|.
name|resolution
expr_stmt|;
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|resolution
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|!=
name|mode
operator|.
name|resolution
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MOUSE_SETRESOLUTION */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_SETRATE
argument_list|)
operator|)
case|case
name|MOUSE_SETRATE
case|:
name|mode
operator|.
name|rate
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|mode
operator|.
name|rate
operator|>
name|UCHAR_MAX
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|mode
operator|.
name|rate
operator|==
literal|0
condition|)
name|mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|dflt_mode
operator|.
name|rate
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|.
name|rate
operator|<
literal|0
condition|)
name|mode
operator|.
name|rate
operator|=
name|sc
operator|->
name|mode
operator|.
name|rate
expr_stmt|;
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|mode
operator|.
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|rate
operator|!=
name|mode
operator|.
name|rate
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MOUSE_SETRATE */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_SETSCALING
argument_list|)
operator|)
case|case
name|MOUSE_SETSCALING
case|:
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|>
literal|2
operator|)
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|!
name|set_mouse_scaling
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MOUSE_SETSCALING */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MOUSE_GETHWID
argument_list|)
operator|)
case|case
name|MOUSE_GETHWID
case|:
name|error
operator|=
name|block_mouse_data
argument_list|(
name|sc
argument_list|,
operator|&
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|get_aux_id
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|hw
operator|.
name|hwid
expr_stmt|;
name|unblock_mouse_data
argument_list|(
name|sc
argument_list|,
name|command_byte
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* MOUSE_GETHWID */
default|default:
return|return
name|ENOTTY
return|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|psmintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
comment|/*      * the table to turn PS/2 mouse button bits (MOUSE_PS2_BUTTON?DOWN)      * into `mousestatus' button bits (MOUSE_BUTTON?DOWN).      */
specifier|static
name|int
name|butmap
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
name|MOUSE_BUTTON1DOWN
block|,
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
block|,
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|,
name|MOUSE_BUTTON1DOWN
operator||
name|MOUSE_BUTTON2DOWN
operator||
name|MOUSE_BUTTON3DOWN
block|}
decl_stmt|;
specifier|register
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|unit
index|]
decl_stmt|;
name|mousestatus_t
name|ms
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|,
name|z
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|l
decl_stmt|;
comment|/* read until there is nothing to read */
while|while
condition|(
operator|(
name|c
operator|=
name|read_aux_data_no_wait
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* discard the byte if the device is not open */
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/*  	 * Check sync bits. We check for overflow bits and the bit 3 	 * for most mice. True, the code doesn't work if overflow  	 * condition occurs. But we expect it rarely happens... 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|inputbytes
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|c
operator|&
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
operator|)
operator|!=
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psmintr: out of sync (%04x != %04x).\n"
argument_list|,
name|c
operator|&
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|mode
operator|.
name|syncmask
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|ipacket
index|[
name|sc
operator|->
name|inputbytes
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|inputbytes
operator|<
name|sc
operator|->
name|mode
operator|.
name|packetsize
condition|)
continue|continue;
if|#
directive|if
literal|0
block|log(LOG_DEBUG, "psmintr: %02x %02x %02x %02x %02x %02x\n", 	    sc->ipacket[0], sc->ipacket[1], sc->ipacket[2], 	    sc->ipacket[3], sc->ipacket[4], sc->ipacket[5]);
endif|#
directive|endif
name|c
operator|=
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
expr_stmt|;
comment|/*  	 * A kludge for Kensington device!  	 * The MSB of the horizontal count appears to be stored in  	 * a strange place. This kludge doesn't affect other mice  	 * because the bit is the overflow bit which is, in most cases,  	 * expected to be zero when we reach here. XXX  	 */
name|sc
operator|->
name|ipacket
index|[
literal|1
index|]
operator||=
operator|(
name|c
operator|&
name|MOUSE_PS2_XOVERFLOW
operator|)
condition|?
literal|0x80
else|:
literal|0
expr_stmt|;
comment|/* ignore the overflow bits... */
name|x
operator|=
operator|(
name|c
operator|&
name|MOUSE_PS2_XNEG
operator|)
condition|?
name|sc
operator|->
name|ipacket
index|[
literal|1
index|]
operator|-
literal|256
else|:
name|sc
operator|->
name|ipacket
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|=
operator|(
name|c
operator|&
name|MOUSE_PS2_YNEG
operator|)
condition|?
name|sc
operator|->
name|ipacket
index|[
literal|2
index|]
operator|-
literal|256
else|:
name|sc
operator|->
name|ipacket
index|[
literal|2
index|]
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
name|ms
operator|.
name|obutton
operator|=
name|sc
operator|->
name|button
expr_stmt|;
comment|/* previous button state */
name|ms
operator|.
name|button
operator|=
name|butmap
index|[
name|c
operator|&
name|MOUSE_PS2_BUTTONS
index|]
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|hw
operator|.
name|model
condition|)
block|{
case|case
name|MOUSE_MODEL_INTELLI
case|:
case|case
name|MOUSE_MODEL_NET
case|:
comment|/* wheel data is in the fourth byte */
name|z
operator|=
operator|(
name|char
operator|)
name|sc
operator|->
name|ipacket
index|[
literal|3
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_MOUSEMANPLUS
case|:
if|if
condition|(
operator|(
name|c
operator|&
operator|~
name|MOUSE_PS2_BUTTONS
operator|)
operator|==
literal|0xc8
condition|)
block|{
comment|/* the extended data packet encodes button and wheel events */
name|x
operator|=
name|y
operator|=
literal|0
expr_stmt|;
name|z
operator|=
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|1
index|]
operator|&
name|MOUSE_PS2PLUS_ZNEG
operator|)
condition|?
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
operator|-
literal|16
else|:
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|ms
operator|.
name|button
operator||=
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|2
index|]
operator|&
name|MOUSE_PS2PLUS_BUTTON4DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* preserve button states */
name|ms
operator|.
name|button
operator||=
name|ms
operator|.
name|obutton
operator|&
name|MOUSE_EXTBUTTONS
expr_stmt|;
block|}
break|break;
case|case
name|MOUSE_MODEL_GLIDEPOINT
case|:
comment|/* `tapping' action */
name|ms
operator|.
name|button
operator||=
operator|(
operator|(
name|c
operator|&
name|MOUSE_PS2_TAP
operator|)
operator|)
condition|?
literal|0
else|:
name|MOUSE_BUTTON4DOWN
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_NETSCROLL
case|:
comment|/* three addtional bytes encode button and wheel events */
name|ms
operator|.
name|button
operator||=
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_PS2_BUTTON3DOWN
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
name|z
operator|=
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|3
index|]
operator|&
name|MOUSE_PS2_XNEG
operator|)
condition|?
name|sc
operator|->
name|ipacket
index|[
literal|4
index|]
operator|-
literal|256
else|:
name|sc
operator|->
name|ipacket
index|[
literal|4
index|]
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_THINK
case|:
comment|/* the fourth button state in the first byte */
name|ms
operator|.
name|button
operator||=
operator|(
name|c
operator|&
name|MOUSE_PS2_TAP
operator|)
condition|?
name|MOUSE_BUTTON4DOWN
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|MOUSE_MODEL_GENERIC
case|:
default|default:
break|break;
block|}
comment|/* scale values */
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|x
operator|*
name|x
operator|/
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
name|x
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|MOUSE_PS2_XNEG
condition|)
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|y
operator|=
name|y
operator|*
name|y
operator|/
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
name|y
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|MOUSE_PS2_YNEG
condition|)
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
block|}
name|ms
operator|.
name|dx
operator|=
name|x
expr_stmt|;
name|ms
operator|.
name|dy
operator|=
name|y
expr_stmt|;
name|ms
operator|.
name|dz
operator|=
name|z
expr_stmt|;
name|ms
operator|.
name|flags
operator|=
operator|(
operator|(
name|x
operator|||
name|y
operator|||
name|z
operator|)
condition|?
name|MOUSE_POSCHANGED
else|:
literal|0
operator|)
operator||
operator|(
name|ms
operator|.
name|obutton
operator|^
name|ms
operator|.
name|button
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|level
operator|<
name|PSM_LEVEL_NATIVE
condition|)
name|sc
operator|->
name|inputbytes
operator|=
name|tame_mouse
argument_list|(
name|sc
argument_list|,
operator|&
name|ms
argument_list|,
name|sc
operator|->
name|ipacket
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|flags
operator||=
name|ms
operator|.
name|flags
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dx
operator|+=
name|ms
operator|.
name|dx
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dy
operator|+=
name|ms
operator|.
name|dy
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|dz
operator|+=
name|ms
operator|.
name|dz
expr_stmt|;
name|sc
operator|->
name|status
operator|.
name|button
operator|=
name|ms
operator|.
name|button
expr_stmt|;
name|sc
operator|->
name|button
operator|=
name|ms
operator|.
name|button
expr_stmt|;
comment|/* queue data */
if|if
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|+
name|sc
operator|->
name|inputbytes
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
condition|)
block|{
name|l
operator|=
name|min
argument_list|(
name|sc
operator|->
name|inputbytes
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
operator|-
name|sc
operator|->
name|queue
operator|.
name|tail
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|sc
operator|->
name|queue
operator|.
name|tail
index|]
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|inputbytes
operator|>
name|l
condition|)
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|ipacket
index|[
name|l
index|]
argument_list|,
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|inputbytes
operator|-
name|l
argument_list|)
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|tail
operator|=
operator|(
name|sc
operator|->
name|queue
operator|.
name|tail
operator|+
name|sc
operator|->
name|inputbytes
operator|)
operator|%
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|queue
operator|.
name|buf
argument_list|)
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|count
operator|+=
name|sc
operator|->
name|inputbytes
expr_stmt|;
block|}
name|sc
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_ASLP
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_ASLP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|psmselect
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|rw
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Silly to select for output */
if|if
condition|(
name|rw
operator|==
name|FWRITE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Return true if a mouse event available */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* vender/model specific routines */
end_comment

begin_function
specifier|static
name|int
name|mouse_id_proc1
parameter_list|(
name|KBDC
name|kbdc
parameter_list|,
name|int
name|res
parameter_list|,
name|int
name|scale
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|res
argument_list|)
operator|!=
name|res
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
name|scale
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
name|scale
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
name|scale
argument_list|)
operator|&&
operator|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|>=
literal|3
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_if
if|#
directive|if
name|notyet
end_if

begin_comment
comment|/* Logitech MouseMan Cordless II */
end_comment

begin_function
specifier|static
name|int
name|enable_lcordless
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|mouse_id_proc1
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|PSMD_RES_HIGH
argument_list|,
literal|2
argument_list|,
name|status
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|status
index|[
literal|1
index|]
operator|==
name|PSMD_RES_HIGH
condition|)
return|return
name|FALSE
return|;
name|ch
operator|=
operator|(
name|status
index|[
literal|0
index|]
operator|&
literal|0x07
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* channel # */
if|if
condition|(
operator|(
name|ch
operator|<=
literal|0
operator|)
operator|||
operator|(
name|ch
operator|>
literal|4
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/*       * status[1]: always one?      * status[2]: battery status? (0-100)      */
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_comment
comment|/* Genius NetScroll Mouse */
end_comment

begin_function
specifier|static
name|int
name|enable_groller
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/*      * The special sequence to enable the fourth button and the      * roller. Immediately after this sequence check status bytes.      * if the mouse is NetScroll, the second and the third bytes are       * '3' and 'D'.      */
comment|/*      * If the mouse is an ordinary PS/2 mouse, the status bytes should      * look like the following.      *       * byte 1 bit 7 always 0      *        bit 6 stream mode (0)      *        bit 5 disabled (0)      *        bit 4 1:1 scaling (0)      *        bit 3 always 0      *        bit 0-2 button status      * byte 2 resolution (PSMD_RES_HIGH)      * byte 3 report rate (?)      */
if|if
condition|(
operator|!
name|mouse_id_proc1
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|PSMD_RES_HIGH
argument_list|,
literal|1
argument_list|,
name|status
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|1
index|]
operator|!=
literal|'3'
operator|)
operator|||
operator|(
name|status
index|[
literal|2
index|]
operator|!=
literal|'D'
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* FIXME!! */
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|get_mouse_buttons
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|4
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Genius NetMouse/NetMouse Pro */
end_comment

begin_function
specifier|static
name|int
name|enable_gmouse
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/*      * The special sequence to enable the middle, "rubber" button.       * Immediately after this sequence check status bytes.      * if the mouse is NetMouse, NetMouse Pro, or ASCII MIE Mouse,       * the second and the third bytes are '3' and 'U'.      * NOTE: NetMouse reports that it has three buttons although it has      * two buttons and a rubber button. NetMouse Pro and MIE Mouse      * say they have three buttons too and they do have a button on the      * side...      */
if|if
condition|(
operator|!
name|mouse_id_proc1
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|PSMD_RES_HIGH
argument_list|,
literal|1
argument_list|,
name|status
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|1
index|]
operator|!=
literal|'3'
operator|)
operator|||
operator|(
name|status
index|[
literal|2
index|]
operator|!=
literal|'U'
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* ALPS GlidePoint */
end_comment

begin_function
specifier|static
name|int
name|enable_aglide
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/*      * The special sequence to obtain ALPS GlidePoint specific      * information. Immediately after this sequence, status bytes will       * contain something interesting.      * NOTE: ALPS produces several models of GlidePoint. Some of those      * do not respond to this sequence, thus, cannot be detected this way.      */
if|if
condition|(
operator|!
name|mouse_id_proc1
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|PSMD_RES_LOW
argument_list|,
literal|2
argument_list|,
name|status
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|0
index|]
operator|&
literal|0x10
operator|)
operator|||
operator|(
name|status
index|[
literal|1
index|]
operator|==
name|PSMD_RES_LOW
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Kensington ThinkingMouse/Trackball */
end_comment

begin_function
specifier|static
name|int
name|enable_kmouse
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|rate
index|[]
init|=
block|{
literal|20
block|,
literal|60
block|,
literal|40
block|,
literal|20
block|,
literal|20
block|,
literal|60
block|,
literal|40
block|,
literal|20
block|,
literal|20
block|}
decl_stmt|;
name|KBDC
name|kbdc
init|=
name|sc
operator|->
name|kbdc
decl_stmt|;
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
name|int
name|id1
decl_stmt|;
name|int
name|id2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|id1
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
operator|!=
literal|10
condition|)
return|return
name|FALSE
return|;
comment|/*       * The device is now in the native mode? It returns a different      * ID value...      */
name|id2
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|id1
operator|==
name|id2
operator|)
operator|||
operator|(
name|id2
operator|!=
literal|2
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|PSMD_RES_LOW
argument_list|)
operator|!=
name|PSMD_RES_LOW
condition|)
return|return
name|FALSE
return|;
if|#
directive|if
name|PSM_DEBUG
operator|>=
literal|2
comment|/* at this point, resolution is LOW, sampling rate is 10/sec */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
return|return
name|FALSE
return|;
endif|#
directive|endif
comment|/*      * The special sequence to enable the third and fourth buttons.      * Otherwise they behave like the first and second buttons.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rate
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rate
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|rate
index|[
name|i
index|]
argument_list|)
operator|!=
name|rate
index|[
name|i
index|]
condition|)
return|return
name|FALSE
return|;
block|}
comment|/*       * At this point, the device is using default resolution and      * sampling rate for the native mode.       */
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|status
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|status
index|[
literal|1
index|]
operator|==
name|PSMD_RES_LOW
operator|)
operator|||
operator|(
name|status
index|[
literal|2
index|]
operator|==
name|rate
index|[
name|i
operator|-
literal|1
index|]
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* the device appears be enabled by this sequence, diable it for now */
name|disable_aux_dev
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|empty_aux_buffer
argument_list|(
name|kbdc
argument_list|,
literal|5
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Logitech MouseMan+/FirstMouse+ */
end_comment

begin_function
specifier|static
name|int
name|enable_mmanplus
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|char
name|res
index|[]
init|=
block|{
operator|-
literal|1
block|,
name|PSMD_RES_LOW
block|,
name|PSMD_RES_HIGH
block|,
name|PSMD_RES_MEDIUM_HIGH
block|,
name|PSMD_RES_MEDIUM_LOW
block|,
operator|-
literal|1
block|,
name|PSMD_RES_HIGH
block|,
name|PSMD_RES_MEDIUM_LOW
block|,
name|PSMD_RES_MEDIUM_HIGH
block|,
name|PSMD_RES_HIGH
block|,      }
decl_stmt|;
name|KBDC
name|kbdc
init|=
name|sc
operator|->
name|kbdc
decl_stmt|;
name|int
name|data
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* the special sequence to enable the fourth button and the roller. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|res
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|res
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|res
index|[
name|i
index|]
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|set_mouse_scaling
argument_list|(
name|kbdc
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
name|set_mouse_resolution
argument_list|(
name|kbdc
argument_list|,
name|res
index|[
name|i
index|]
argument_list|)
operator|!=
name|res
index|[
name|i
index|]
condition|)
return|return
name|FALSE
return|;
block|}
block|}
if|if
condition|(
name|get_mouse_status
argument_list|(
name|kbdc
argument_list|,
name|data
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
operator|<
literal|3
condition|)
return|return
name|FALSE
return|;
comment|/*       * MouseMan+ and FirstMouse+ return following data.      *      * byte 1 0xc8      * byte 2 ?? (MouseMan+:0xc2, FirstMouse+:0xc6)      * byte 3 model ID? MouseMan+:0x50, FirstMouse+:0x51      */
if|if
condition|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
operator|~
name|MOUSE_PS2_BUTTONS
operator|)
operator|!=
literal|0xc8
condition|)
return|return
name|FALSE
return|;
comment|/*      * MouseMan+ (or FirstMouse+) is now in its native mode, in which      * the wheel and the fourth button events are encoded in the      * special data packet. The mouse may be put in the IntelliMouse mode      * if it is initialized by the IntelliMouse's method.      */
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* MS IntelliMouse */
end_comment

begin_function
specifier|static
name|int
name|enable_msintelli
parameter_list|(
name|struct
name|psm_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/*      * Logitech MouseMan+ and FirstMouse+ will also respond to this      * probe routine and act like IntelliMouse.      */
specifier|static
name|unsigned
name|char
name|rate
index|[]
init|=
block|{
literal|200
block|,
literal|100
block|,
literal|80
block|, }
decl_stmt|;
name|KBDC
name|kbdc
init|=
name|sc
operator|->
name|kbdc
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* the special sequence to enable the third button and the roller. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|rate
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|rate
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|set_mouse_sampling_rate
argument_list|(
name|kbdc
argument_list|,
name|rate
index|[
name|i
index|]
argument_list|)
operator|!=
name|rate
index|[
name|i
index|]
condition|)
return|return
name|FALSE
return|;
block|}
comment|/* the device will give the genuine ID only after the above sequence */
name|id
operator|=
name|get_aux_id
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|PSM_INTELLI_ID
condition|)
return|return
name|FALSE
return|;
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|id
expr_stmt|;
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
literal|3
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|psm_devsw_installed
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|psm_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|psm_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|psm_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|psm_devsw_installed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PSM_HOOKAPM
end_ifdef

begin_function
specifier|static
name|int
name|psmresume
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
name|psm_softc
index|[
operator|(
name|int
operator|)
name|dummy
index|]
decl_stmt|;
name|int
name|unit
init|=
operator|(
name|int
operator|)
name|dummy
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"psm%d: APM resume hook called.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/* don't let anybody mess with the aux device */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* save the current controller command byte */
name|empty_both_buffers
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|c
operator|=
name|get_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: current command byte: %04x (psmresume).\n"
argument_list|,
name|unit
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* enable the aux port but disable the aux interrupt and the keyboard */
if|if
condition|(
operator|(
name|c
operator|==
operator|-
literal|1
operator|)
operator|||
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: unable to set the command byte (psmresume).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* flush any data */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
condition|)
block|{
name|disable_aux_dev
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
expr_stmt|;
comment|/* this may fail; but never mind... */
name|empty_aux_buffer
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PSM_RESETAFTERSUSPEND
comment|/* try to detect the aux device; are you still there? */
if|if
condition|(
name|reinitialize
argument_list|(
name|unit
argument_list|,
operator|&
name|sc
operator|->
name|mode
argument_list|)
condition|)
block|{
comment|/* yes */
name|sc
operator|->
name|state
operator||=
name|PSM_VALID
expr_stmt|;
block|}
else|else
block|{
comment|/* the device has gone! */
name|restore_controller
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_VALID
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: the aux device has gone! (psmresume).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENXIO
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PSM_RESETAFTERSUSPEND */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* restore the driver state */
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
operator|)
operator|&&
operator|(
name|err
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* enable the aux device and the port again */
name|err
operator|=
name|doopen
argument_list|(
name|unit
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to enable the device (psmresume).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* restore the keyboard port and disable the aux port */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|kbdc_get_device_mask
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|)
argument_list|,
operator|(
name|c
operator|&
name|KBD_KBD_CONTROL_BITS
operator|)
operator||
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: failed to disable the aux port (psmresume).\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
block|}
block|}
comment|/* done */
name|kbdc_lock
argument_list|(
name|sc
operator|->
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_ASLP
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
condition|)
block|{
comment|/*  	 * Release the blocked process; it must be notified that the device 	 * cannot be accessed anymore. 	 */
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_ASLP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: APM resume hook exiting.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PSM_HOOKAPM */
end_comment

begin_macro
name|SYSINIT
argument_list|(
argument|psmdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE + CDEV_MAJOR
argument_list|,
argument|psm_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPSM> 0 */
end_comment

end_unit

