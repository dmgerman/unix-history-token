begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993 Erik Forsberg.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN  * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Id$  */
end_comment

begin_comment
comment|/*  *  Ported to 386bsd Oct 17, 1992  *  Sandi Donno, Computer Science, University of Cape Town, South Africa  *  Please send bug reports to sandi@cs.uct.ac.za  *  *  Thanks are also due to Rick Macklem, rick@snowhite.cis.uoguelph.ca -  *  although I was only partially successful in getting the alpha release  *  of his "driver for the Logitech and ATI Inport Bus mice for use with  *  386bsd and the X386 port" to work with my Microsoft mouse, I nevertheless  *  found his code to be an invaluable reference when porting this driver  *  to 386bsd.  *  *  Further modifications for latest 386BSD+patchkit and port to NetBSD,  *  Andrew Herbert<andrew@werple.apana.org.au> - 8 June 1993  *  *  Cloned from the Microsoft Bus Mouse driver, also by Erik Forsberg, by  *  Andrew Herbert - 12 June 1993  *  *  Modified for PS/2 mouse by Charles Hannum<mycroft@ai.mit.edu>  *  - 13 June 1993  *  *  Modified for PS/2 AUX mouse by Shoji Yuen<yuen@nuie.nagoya-u.ac.jp>  *  - 24 October 1993  *  *  Hardware access routines and probe logic rewritten by  *  Kazutaka Yokota<yokota@zodiac.mech.utsunomiya-u.ac.jp>  *  - 3 October 1996.   *  - 14 October 1996.  *  - 22 October 1996.  *  - 28 October 1996. Start adding IOCTLs.  *  - 12 November 1996. IOCTLs and rearranging `psmread', `psmioctl'...  *  - 14 November 1996. Uses `kbdio.c'.  */
end_comment

begin_include
include|#
directive|include
file|"psm.h"
end_include

begin_if
if|#
directive|if
name|NPSM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_comment
comment|/* #include<machine/mouse.h> #include<machine/clock.h> */
end_comment

begin_include
include|#
directive|include
file|<i386/include/mouse.h>
end_include

begin_include
include|#
directive|include
file|<i386/include/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/kbdio.h>
end_include

begin_comment
comment|/* driver specific options: the following options may be set by    `options' statements in the kernel configuration file. */
end_comment

begin_comment
comment|/* debugging */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|PSM_DEBUG
value|2
end_define

begin_comment
comment|/* controls debug logging:  				   0: no logging, 1: brief, 2: verbose */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* version dependency */
end_comment

begin_define
define|#
directive|define
name|PSM_CURRENT
end_define

begin_comment
comment|/* compiles for FreeBSD-current, if defined. 				   otherwise, compiles for FreeBSD 2.1.x. */
end_comment

begin_comment
comment|/* features */
end_comment

begin_comment
comment|/* #define PSM_NOCHECKSYNC	   the driver does not check the header data 				   byte, if defined */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PSM_ACCEL
end_ifndef

begin_define
define|#
directive|define
name|PSM_ACCEL
value|2
end_define

begin_comment
comment|/* the default acceleration factor, must  			           be one or greater; acceleration will be  				   disabled if zero */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #define PSM_NOEMULATION	   disables protocol emulation */
end_comment

begin_comment
comment|/* end of driver specific options */
end_comment

begin_comment
comment|/* default values */
end_comment

begin_define
define|#
directive|define
name|PSMD_DEFAULT_RESOLUTION
value|800
end_define

begin_comment
comment|/* resolution: 800 ppi */
end_comment

begin_define
define|#
directive|define
name|PSMD_DEFAULT_RATE
value|100
end_define

begin_comment
comment|/* report rate: 100 Hz */
end_comment

begin_comment
comment|/* misc */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|(-1)
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_comment
comment|/* some macros */
end_comment

begin_define
define|#
directive|define
name|PSM_UNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>> 1)
end_define

begin_define
define|#
directive|define
name|PSM_NBLOCKIO
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 1)
end_define

begin_define
define|#
directive|define
name|PSM_MKMINOR
parameter_list|(
name|unit
parameter_list|,
name|block
parameter_list|)
value|(((unit)<< 1) | ((block) ? 0:1))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|max
end_ifndef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)> (y) ? (x) : (y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)< (y) ? (x) : (y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* mouse status block */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|mousestatus
block|{
name|int
name|button
decl_stmt|;
comment|/* button status */
name|int
name|obutton
decl_stmt|;
comment|/* previous button status */
name|int
name|dx
decl_stmt|;
comment|/* x movement */
name|int
name|dy
decl_stmt|;
comment|/* y movement */
block|}
name|mousestatus_t
typedef|;
end_typedef

begin_comment
comment|/* ring buffer */
end_comment

begin_define
define|#
directive|define
name|PSM_BUFSIZE
value|256
end_define

begin_typedef
typedef|typedef
struct|struct
name|ringbuf
block|{
name|int
name|count
decl_stmt|;
name|int
name|head
decl_stmt|;
name|int
name|tail
decl_stmt|;
name|mousestatus_t
name|buf
index|[
name|PSM_BUFSIZE
index|]
decl_stmt|;
block|}
name|ringbuf_t
typedef|;
end_typedef

begin_comment
comment|/* driver control block */
end_comment

begin_typedef
typedef|typedef
name|int
argument_list|(
argument|*packetfunc_t
argument_list|)
name|__P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|mousestatus_t
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_struct
specifier|static
struct|struct
name|psm_softc
block|{
comment|/* Driver status information */
name|struct
name|selinfo
name|rsel
decl_stmt|;
comment|/* Process selecting for Input */
name|unsigned
name|char
name|state
decl_stmt|;
comment|/* Mouse driver state */
name|int
name|addr
decl_stmt|;
comment|/* I/O port address */
name|int
name|command_byte
decl_stmt|;
comment|/* controller command byte */
name|mousehw_t
name|hw
decl_stmt|;
comment|/* hardware information */
name|mousemode_t
name|mode
decl_stmt|;
comment|/* operation mode */
name|ringbuf_t
name|queue
decl_stmt|;
comment|/* mouse status queue */
name|packetfunc_t
name|mkpacket
decl_stmt|;
comment|/* func. to turn queued data  				   into output format */
name|char
name|ipacket
index|[
name|MOUSE_PS2_PACKETSIZE
index|]
decl_stmt|;
comment|/* interim input buffer */
name|unsigned
name|char
name|opacket
index|[
name|PSM_BUFSIZE
index|]
decl_stmt|;
comment|/* output buffer */
name|int
name|inputbytes
decl_stmt|;
comment|/* # of bytes in the input buffer */
name|int
name|outputbytes
decl_stmt|;
comment|/* # of bytes in the output buffer */
name|int
name|outputhead
decl_stmt|;
comment|/* points the head of the output buffer */
name|int
name|button
decl_stmt|;
comment|/* the latest button state */
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|devfs_token
decl_stmt|;
name|void
modifier|*
name|n_devfs_token
decl_stmt|;
endif|#
directive|endif
block|}
name|psm_softc
index|[
name|NPSM
index|]
struct|;
end_struct

begin_comment
comment|/* driver state flags (state) */
end_comment

begin_define
define|#
directive|define
name|PSM_VALID
value|0x80
end_define

begin_define
define|#
directive|define
name|PSM_OPEN
value|1
end_define

begin_comment
comment|/* Device is open */
end_comment

begin_define
define|#
directive|define
name|PSM_ASLP
value|2
end_define

begin_comment
comment|/* Waiting for mouse data */
end_comment

begin_comment
comment|/* function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|int
name|psmprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|psmattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mkms
name|__P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|mousestatus_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mkmsc
name|__P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|mousestatus_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mkps2
name|__P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|mousestatus_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PSM_CURRENT
end_ifdef

begin_decl_stmt
specifier|static
name|d_open_t
name|psmopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|psmclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|psmread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|psmioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_select_t
name|psmselect
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PSM_CURRENT */
end_comment

begin_comment
comment|/* device driver declarateion */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|psmdriver
init|=
block|{
name|psmprobe
block|,
name|psmattach
block|,
literal|"psm"
block|,
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PSM_CURRENT
end_ifdef

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|21
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|psm_cdevsw
init|=
block|{
name|psmopen
block|,
name|psmclose
block|,
name|psmread
block|,
name|nowrite
block|,
comment|/* 21 */
name|psmioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|psmselect
block|,
name|nommap
block|,
name|NULL
block|,
literal|"psm"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PSM_CURRENT */
end_comment

begin_comment
comment|/* debug message level */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|bootverbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* `-v' option at `boot:' prompt */
end_comment

begin_decl_stmt
specifier|static
name|int
name|verbose
init|=
name|PSM_DEBUG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* device I/O routines */
end_comment

begin_function
specifier|static
name|int
name|enable_aux_dev
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|port
argument_list|,
name|PSMC_ENABLE_DEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: ENABLE_DEV return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|disable_aux_dev
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|port
argument_list|,
name|PSMC_DISABLE_DEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: DISABLE_DEV return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_mouse_status
parameter_list|(
name|int
name|port
parameter_list|,
name|int
modifier|*
name|status
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|empty_both_buffers
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|port
argument_list|,
name|PSMC_SEND_DEV_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SEND_AUX_STATUS return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|PSM_ACK
condition|)
return|return
name|FALSE
return|;
name|status
index|[
literal|0
index|]
operator|=
name|read_aux_data
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|status
index|[
literal|1
index|]
operator|=
name|read_aux_data
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|status
index|[
literal|2
index|]
operator|=
name|read_aux_data
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_aux_id
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|int
name|retry
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|retry
operator|=
name|KBD_MAXRETRY
init|;
name|retry
operator|>
literal|0
condition|;
operator|--
name|retry
control|)
block|{
name|empty_both_buffers
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|write_aux_command
argument_list|(
name|port
argument_list|,
name|PSMC_SEND_DEV_ID
argument_list|)
expr_stmt|;
comment|/* 10ms delay */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|c
operator|=
name|read_controller_data
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SEND_DEV_ID return code:%04x\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|PSM_ACK
condition|)
break|break;
block|}
if|if
condition|(
name|retry
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|id
operator|=
name|read_aux_data
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: device ID: %04x\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_mouse_sampling_rate
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command_and_data
argument_list|(
name|port
argument_list|,
name|PSMC_SET_SAMPLING_RATE
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_SAMPLING_RATE (%d) %04x\n"
argument_list|,
name|rate
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
condition|?
name|rate
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_mouse_scaling
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|port
argument_list|,
name|PSMC_SET_SCALING11
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_SCALING11 return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_mouse_resolution
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|res
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|resolution
decl_stmt|;
name|int
name|code
decl_stmt|;
block|}
name|rescode
index|[]
init|=
block|{
block|{
literal|25
block|,
name|PSMD_RESOLUTION_25
block|}
block|,
block|{
literal|50
block|,
name|PSMD_RESOLUTION_50
block|}
block|,
block|{
literal|100
block|,
name|PSMD_RESOLUTION_100
block|}
block|,
block|{
literal|200
block|,
name|PSMD_RESOLUTION_200
block|}
block|,
block|{
literal|400
block|,
name|PSMD_RESOLUTION_400
block|}
block|,
comment|/* ?? */
block|{
literal|800
block|,
name|PSMD_RESOLUTION_800
block|}
block|,
comment|/* ?? */
block|{
name|INT_MAX
block|,
name|PSMD_MAX_RESOLUTION
block|}
block|, 	}
struct|;
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|res
operator|<=
literal|0
condition|)
return|return
name|FALSE
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|rescode
index|[
name|i
index|]
operator|.
name|resolution
operator|>
literal|0
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|rescode
index|[
name|i
index|]
operator|.
name|resolution
operator|>=
name|res
condition|)
break|break;
block|}
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|ret
operator|=
name|send_aux_command_and_data
argument_list|(
name|port
argument_list|,
name|PSMC_SET_RESOLUTION
argument_list|,
name|rescode
index|[
name|i
index|]
operator|.
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_RESOLUTION (%d) %04x\n"
argument_list|,
name|rescode
index|[
name|i
index|]
operator|.
name|code
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|PSM_ACK
condition|)
return|return
name|rescode
index|[
name|i
index|]
operator|.
name|resolution
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* NOTE: once `set_mouse_mode()' is called, the mouse device must be    re-enabled by calling `enable_aux_dev()' */
end_comment

begin_function
specifier|static
name|int
name|set_mouse_mode
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|send_aux_command
argument_list|(
name|port
argument_list|,
name|PSMC_SET_STREAM_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: SET_STREAM_MODE return code:%04x\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|==
name|PSM_ACK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_mouse_buttons
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|int
name|c
init|=
literal|2
decl_stmt|;
comment|/* assume two buttons by default */
name|int
name|status
index|[
literal|3
index|]
decl_stmt|;
comment|/* NOTE: a special sequence to obtain Logitech-Mouse-specific 	   information: set resolution to 25 ppi, set scaling to 1:1, 	   set scaling to 1:1, set scaling to 1:1. Then the second 	   byte of the mouse status bytes is the number of available  	   buttons. */
if|if
condition|(
operator|!
name|set_mouse_resolution
argument_list|(
name|port
argument_list|,
literal|25
argument_list|)
condition|)
return|return
name|c
return|;
if|if
condition|(
name|set_mouse_scaling
argument_list|(
name|port
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|port
argument_list|)
operator|&&
name|set_mouse_scaling
argument_list|(
name|port
argument_list|)
operator|&&
name|get_mouse_status
argument_list|(
name|port
argument_list|,
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm: status %02x %02x %02x (get_mouse_buttons)\n"
argument_list|,
name|status
index|[
literal|0
index|]
argument_list|,
name|status
index|[
literal|1
index|]
argument_list|,
name|status
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
index|[
literal|1
index|]
operator|==
literal|3
condition|)
return|return
literal|3
return|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* FIXME: someday, I will get the list of valid pointing devices and    their IDs... */
end_comment

begin_function
specifier|static
name|int
name|is_a_mouse
parameter_list|(
name|int
name|id
parameter_list|)
block|{
specifier|static
name|int
name|valid_ids
index|[]
init|=
block|{
name|PSM_MOUSE_ID
block|,
comment|/* mouse */
name|PSM_BALLPOINT_ID
block|,
comment|/* ballpoint device */
operator|-
literal|1
comment|/* end of table */
block|}
decl_stmt|;
comment|/* 	int i;  	for(i = 0; valid_ids[i]>= 0; ++i) { 	    if (valid_ids[i] == id) 		return TRUE; 	} 	return FALSE; 	*/
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|recover_from_error
parameter_list|(
name|int
name|port
parameter_list|)
block|{
comment|/* discard anything left in the output buffer */
name|empty_both_buffers
argument_list|(
name|port
argument_list|)
expr_stmt|;
comment|/* NOTE: KBDC_RESET_KBD may not restore the communication between 	   the keyboard and the controller. */
comment|/* reset_kbd(port); */
comment|/* NOTE: somehow diagnostic and keyboard port test commands bring 	   the keyboard back. */
name|test_controller
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_controller
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|command_byte
parameter_list|)
block|{
name|set_controller_command_byte
argument_list|(
name|port
argument_list|,
name|command_byte
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* psm driver entry points */
end_comment

begin_function
specifier|static
name|int
name|psmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|int
name|ioport
init|=
name|dvp
operator|->
name|id_iobase
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* validate unit number */
if|if
condition|(
name|unit
operator|>=
name|NPSM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|=
operator|&
name|psm_softc
index|[
name|unit
index|]
expr_stmt|;
name|sc
operator|->
name|addr
operator|=
name|ioport
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|++
name|verbose
expr_stmt|;
comment|/* FIXME: the keyboard interrupt should be disabled while 	   probing a mouse? */
comment|/* NOTE: two bits in the command byte controls the operation of 	   the aux port (mouse port): the aux port disable bit (bit 5) and 	   the aux port interrupt (IRQ 12) enable bit (bit 2). 	   When this probe routine is called, there are following possibilities 	   about the presence of the aux port and the PS/2 mouse.  	   Case 1: aux port disabled (bit 5:1), aux int. disabled (bit 2:0) 	   The aux port most certainly exists. A device may or may not be 	   connected to the port. No driver is probably installed yet.  	   Case 2: aux port enabled (bit 5:0), aux int. disabled (bit 2:0) 	   Three possibile situations here:  	   Case 2a:  	   The aux port does not exist, therefore, is not explicitly disabled. 	   Case 2b: 	   The aux port exists. A device and a driver may exist, 	   using the device in the polling(remote) mode. 	   Case 2c: 	   The aux port exists. A device may exist, but someone who knows 	   nothing about the aux port has set the command byte this way 	   (this is the case with `syscons').  	   Case 3: aux port disabled (bit 5:1), aux int. enabled (bit 2:1) 	   The aux port exists, but someone is controlloing the device and 	   temporalily disabled the port.  	   Case 4: aux port enabled (bit 5:0), aux int. enabled (bit 2:1) 	   The aux port exists, a device is attached to the port, and 	   someone is controlling the device. Some BIOS set the bits this 	   way after boot.  	   All in all, it is no use examing the bits for detecting 	   the presence of the port and the mouse device. 	*/
comment|/* save the current command byte; it will be used later */
name|write_controller_command
argument_list|(
name|ioport
argument_list|,
name|KBDC_GET_COMMAND_BYTE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|command_byte
operator|=
name|read_controller_data
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"psm%d: current command byte:%04x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|command_byte
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|command_byte
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"psm%d: unable to get the current command byte value.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* disable the keyboard port while probing the aux port, which 	   must be enabled during this routine */
name|write_controller_command
argument_list|(
name|ioport
argument_list|,
name|KBDC_DISABLE_KBD_PORT
argument_list|)
expr_stmt|;
name|set_controller_command_byte
argument_list|(
name|ioport
argument_list|,
name|sc
operator|->
name|command_byte
operator|&
operator|~
operator|(
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_AUX_CONTROL_BITS
operator|)
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
expr_stmt|;
comment|/* NOTE: `test_aux_port()' is designed to return with zero 	   if the aux port exists and is functioning. However, some 	   controllers appears to respond with zero even when the aux port 	   doesn't exist. (It may be that this is only the case when the 	   controller DOES have the aux port but the port is not wired 	   on the motherboard.) The keyboard controllers without the port, 	   such as the original AT, are supporsed to return with 	   an error code or simply time out. In any case, we have to 	   continue probing the port even when the controller passes  	   this test. 	*/
switch|switch
condition|(
operator|(
name|i
operator|=
name|test_aux_port
argument_list|(
name|ioport
argument_list|)
operator|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* no error */
break|break;
case|case
operator|-
literal|1
case|:
comment|/* time out */
default|default:
comment|/* error */
name|recover_from_error
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|ioport
argument_list|,
name|sc
operator|->
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: the aux port is not functioning (%d).\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|--
name|verbose
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* NOTE: some controllers appears to hang the `keyboard' when 	   the aux port doesn't exist and `PSMC_RESET_DEV' is issued. */
if|if
condition|(
operator|!
name|reset_aux_dev
argument_list|(
name|ioport
argument_list|)
condition|)
block|{
name|recover_from_error
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
name|restore_controller
argument_list|(
name|ioport
argument_list|,
name|sc
operator|->
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: failed to reset the aux device.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* both the aux port and the aux device is functioning, see 	   if the device can be enabled. 	   NOTE: when enabled, the device will start sending data; 	   we shall immediately disable the device once we know  	   the device can be enabled. */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|ioport
argument_list|)
operator|||
operator|!
name|disable_aux_dev
argument_list|(
name|ioport
argument_list|)
condition|)
block|{
name|restore_controller
argument_list|(
name|ioport
argument_list|,
name|sc
operator|->
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: failed to enable the aux device.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|--
name|verbose
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|empty_both_buffers
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
comment|/* remove stray data if any */
comment|/* hardware information */
name|sc
operator|->
name|hw
operator|.
name|iftype
operator|=
name|MOUSE_IF_PS2
expr_stmt|;
comment|/* verify the device is a mouse */
name|sc
operator|->
name|hw
operator|.
name|hwid
operator|=
name|get_aux_id
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_a_mouse
argument_list|(
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|)
condition|)
block|{
name|restore_controller
argument_list|(
name|ioport
argument_list|,
name|sc
operator|->
name|command_byte
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"psm%d: unknown device type (%d).\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|--
name|verbose
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|sc
operator|->
name|hw
operator|.
name|hwid
condition|)
block|{
case|case
name|PSM_BALLPOINT_ID
case|:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_TRACKBALL
expr_stmt|;
break|break;
case|case
name|PSM_MOUSE_ID
case|:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_MOUSE
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|hw
operator|.
name|type
operator|=
name|MOUSE_UNKNOWN
expr_stmt|;
break|break;
block|}
comment|/* # of buttons */
name|sc
operator|->
name|hw
operator|.
name|buttons
operator|=
name|get_mouse_buttons
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
comment|/* set mouse parameters */
comment|/* FIXME: I don't know if these parameters are reasonable */
comment|/* FIXME: should we set them in `psmattach()' rather than here? */
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|ioport
argument_list|,
name|PSMD_DEFAULT_RATE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|ioport
argument_list|,
name|PSMD_DEFAULT_RESOLUTION
argument_list|)
expr_stmt|;
name|set_mouse_scaling
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
comment|/* 1:1 scaling */
name|set_mouse_mode
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
comment|/* stream mode */
comment|/* just check the status of the mouse */
if|if
condition|(
name|verbose
condition|)
block|{
name|get_mouse_status
argument_list|(
name|ioport
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: status %02x %02x %02x\n"
argument_list|,
name|unit
argument_list|,
name|stat
index|[
literal|0
index|]
argument_list|,
name|stat
index|[
literal|1
index|]
argument_list|,
name|stat
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* disable the aux port for now... */
comment|/* WARNING: we save the controller command byte and use it later 	   during `psmopen()' and `psmclose()'. This will be OK, so long 	   as the keyboard/console device driver won't change the command 	   byte in the course of its operation (this is the case with 	   `syscons'). If not,... */
name|sc
operator|->
name|command_byte
operator|&=
operator|~
name|KBD_AUX_CONTROL_BITS
expr_stmt|;
name|set_controller_command_byte
argument_list|(
name|ioport
argument_list|,
name|sc
operator|->
name|command_byte
argument_list|,
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
expr_stmt|;
comment|/* done */
return|return
operator|(
name|IO_PSMSIZE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
init|=
operator|&
name|psm_softc
index|[
name|unit
index|]
decl_stmt|;
comment|/* initial operation mode */
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|=
name|PSM_ACCEL
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
name|MOUSE_PROTO_PS2
expr_stmt|;
name|sc
operator|->
name|mkpacket
operator|=
name|mkps2
expr_stmt|;
comment|/* Setup initial state */
name|sc
operator|->
name|state
operator|=
name|PSM_VALID
expr_stmt|;
comment|/* Done */
ifdef|#
directive|ifdef
name|DEVFS
name|sc
operator|->
name|devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|psm_cdevsw
argument_list|,
name|PSM_MKMINOR
argument_list|(
name|unit
argument_list|,
name|TRUE
argument_list|)
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0666
argument_list|,
literal|"psm%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|n_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|psm_cdevsw
argument_list|,
name|PSM_MKMINOR
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|)
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0666
argument_list|,
literal|"npsm%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"psm%d: device ID %d, %d buttons?\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|hwid
argument_list|,
name|sc
operator|->
name|hw
operator|.
name|buttons
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
operator|--
name|verbose
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* return (0); XXX eh? usually 1 indicates success */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PSM_CURRENT
end_ifdef

begin_function
specifier|static
endif|#
directive|endif
name|int
name|psmopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|ioport
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|stat
index|[
literal|3
index|]
decl_stmt|;
comment|/* Validate unit number */
if|if
condition|(
name|unit
operator|>=
name|NPSM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Get device data */
name|sc
operator|=
operator|&
name|psm_softc
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_VALID
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ioport
operator|=
name|sc
operator|->
name|addr
expr_stmt|;
comment|/* Disallow multiple opens */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Initialize state */
name|sc
operator|->
name|state
operator||=
name|PSM_OPEN
expr_stmt|;
name|sc
operator|->
name|rsel
operator|.
name|si_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rsel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
comment|/* flush the event queue */
name|sc
operator|->
name|queue
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|button
operator|=
literal|0
expr_stmt|;
comment|/* empty input/output buffers */
name|sc
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|outputbytes
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|outputhead
operator|=
literal|0
expr_stmt|;
comment|/* enable the aux port and temporalily disable the keyboard */
name|write_controller_command
argument_list|(
name|ioport
argument_list|,
name|KBDC_DISABLE_KBD_PORT
argument_list|)
expr_stmt|;
name|set_controller_command_byte
argument_list|(
name|ioport
argument_list|,
name|sc
operator|->
name|command_byte
operator|&
operator|~
name|KBD_KBD_CONTROL_BITS
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
expr_stmt|;
comment|/* enable the mouse device */
if|if
condition|(
operator|!
name|enable_aux_dev
argument_list|(
name|ioport
argument_list|)
condition|)
block|{
name|set_controller_command_byte
argument_list|(
name|ioport
argument_list|,
name|sc
operator|->
name|command_byte
argument_list|,
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"psm%d: unable to enable the pointing device.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|verbose
operator|>=
literal|2
condition|)
block|{
name|get_mouse_status
argument_list|(
name|ioport
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"psm%d: status %02x %02x %02x\n"
argument_list|,
name|unit
argument_list|,
name|stat
index|[
literal|0
index|]
argument_list|,
name|stat
index|[
literal|1
index|]
argument_list|,
name|stat
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* enable the aux port and interrupt */
name|set_controller_command_byte
argument_list|(
name|ioport
argument_list|,
name|sc
operator|->
name|command_byte
argument_list|,
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_ENABLE_AUX_INT
argument_list|)
expr_stmt|;
comment|/* done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PSM_CURRENT
end_ifdef

begin_function
specifier|static
endif|#
directive|endif
name|int
name|psmclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
operator|&
name|psm_softc
index|[
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|ioport
init|=
name|sc
operator|->
name|addr
decl_stmt|;
comment|/* disable the aux interrupt */
name|set_controller_command_byte
argument_list|(
name|ioport
argument_list|,
name|sc
operator|->
name|command_byte
argument_list|,
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
expr_stmt|;
comment|/* remove anything left in the output buffer */
name|empty_aux_buffer
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
comment|/* disable the aux device, port and interrupt */
name|disable_aux_dev
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
name|set_controller_command_byte
argument_list|(
name|ioport
argument_list|,
name|sc
operator|->
name|command_byte
argument_list|,
name|KBD_DISABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
expr_stmt|;
comment|/* remove anything left in the output buffer */
name|empty_aux_buffer
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
comment|/* Complete the close */
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_OPEN
expr_stmt|;
comment|/* close is almost always successful */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mkms
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|len
parameter_list|,
name|int
name|maxlen
parameter_list|,
specifier|register
name|mousestatus_t
modifier|*
name|status
parameter_list|)
block|{
specifier|static
name|int
name|butmap
index|[]
init|=
block|{
literal|0
block|,
name|MOUSE_MSS_BUTTON3DOWN
block|,
name|MOUSE_MSS_BUTTON2DOWN
block|,
name|MOUSE_MSS_BUTTON3DOWN
operator||
name|MOUSE_MSS_BUTTON2DOWN
block|,
name|MOUSE_MSS_BUTTON1DOWN
block|,
name|MOUSE_MSS_BUTTON3DOWN
operator||
name|MOUSE_MSS_BUTTON1DOWN
block|,
name|MOUSE_MSS_BUTTON2DOWN
operator||
name|MOUSE_MSS_BUTTON1DOWN
block|,
name|MOUSE_MSS_BUTTON3DOWN
operator||
name|MOUSE_MSS_BUTTON2DOWN
operator||
name|MOUSE_MSS_BUTTON1DOWN
block|, 	}
decl_stmt|;
name|unsigned
name|char
name|delta
decl_stmt|;
if|if
condition|(
name|maxlen
operator|-
operator|*
name|len
operator|<
name|MOUSE_MSS_PACKETSIZE
condition|)
return|return
name|FALSE
return|;
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSS_SYNC
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
name|butmap
index|[
name|status
operator|->
name|button
operator|&
name|BUTSTATMASK
index|]
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dx
operator|<
operator|-
literal|128
condition|)
name|delta
operator|=
literal|0x80
expr_stmt|;
comment|/* -128 */
elseif|else
if|if
condition|(
name|status
operator|->
name|dx
operator|>
literal|127
condition|)
name|delta
operator|=
literal|0x7f
expr_stmt|;
comment|/* 127 */
else|else
name|delta
operator|=
operator|(
name|unsigned
name|char
operator|)
name|status
operator|->
name|dx
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|delta
operator|&
literal|0xc0
operator|)
operator|>>
literal|6
expr_stmt|;
comment|/* bit 6-7 */
name|buf
index|[
literal|1
index|]
operator|=
name|delta
operator|&
literal|0x3f
expr_stmt|;
comment|/* bit 0-5 */
if|if
condition|(
name|status
operator|->
name|dy
operator|<
operator|-
literal|128
condition|)
name|delta
operator|=
literal|0x80
expr_stmt|;
comment|/* -128 */
elseif|else
if|if
condition|(
name|status
operator|->
name|dy
operator|>
literal|127
condition|)
name|delta
operator|=
literal|0x7f
expr_stmt|;
comment|/* 127 */
else|else
name|delta
operator|=
operator|(
name|unsigned
name|char
operator|)
name|status
operator|->
name|dy
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|(
name|delta
operator|&
literal|0xc0
operator|)
operator|>>
literal|4
expr_stmt|;
comment|/* bit 6-7 */
name|buf
index|[
literal|2
index|]
operator|=
name|delta
operator|&
literal|0x3f
expr_stmt|;
comment|/* bit 0-5 */
operator|*
name|len
operator|+=
name|MOUSE_MSS_PACKETSIZE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mkmsc
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|len
parameter_list|,
name|int
name|maxlen
parameter_list|,
specifier|register
name|mousestatus_t
modifier|*
name|status
parameter_list|)
block|{
specifier|static
name|int
name|butmap
index|[]
init|=
block|{
literal|0
block|,
name|MOUSE_MSC_BUTTON3UP
block|,
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON3UP
operator||
name|MOUSE_MSC_BUTTON2UP
block|,
name|MOUSE_MSC_BUTTON1UP
block|,
name|MOUSE_MSC_BUTTON3UP
operator||
name|MOUSE_MSC_BUTTON1UP
block|,
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON1UP
block|,
name|MOUSE_MSC_BUTTON3UP
operator||
name|MOUSE_MSC_BUTTON2UP
operator||
name|MOUSE_MSC_BUTTON1UP
block|, 	}
decl_stmt|;
name|unsigned
name|char
name|delta
decl_stmt|;
if|if
condition|(
name|maxlen
operator|-
operator|*
name|len
operator|<
name|MOUSE_PS2_PACKETSIZE
condition|)
return|return
name|FALSE
return|;
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_MSC_SYNC
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
operator|~
name|butmap
index|[
name|status
operator|->
name|button
operator|&
name|BUTSTATMASK
index|]
operator|&
name|MOUSE_MSC_BUTTONS
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dx
operator|<
operator|-
literal|128
condition|)
name|delta
operator|=
literal|0x80
expr_stmt|;
comment|/* -128 */
elseif|else
if|if
condition|(
name|status
operator|->
name|dx
operator|>
literal|127
condition|)
name|delta
operator|=
literal|0x7f
expr_stmt|;
comment|/* 127 */
else|else
name|delta
operator|=
operator|(
name|unsigned
name|char
operator|)
name|status
operator|->
name|dx
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|delta
operator|>>
literal|2
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|delta
operator|-
name|buf
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dy
operator|<
operator|-
literal|128
condition|)
name|delta
operator|=
literal|0x80
expr_stmt|;
comment|/* -128 */
elseif|else
if|if
condition|(
name|status
operator|->
name|dy
operator|>
literal|127
condition|)
name|delta
operator|=
literal|0x7f
expr_stmt|;
comment|/* 127 */
else|else
name|delta
operator|=
operator|(
name|unsigned
name|char
operator|)
name|status
operator|->
name|dy
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|delta
operator|>>
literal|2
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|delta
operator|-
name|buf
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|len
operator|+=
name|MOUSE_MSC_PACKETSIZE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mkps2
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|len
parameter_list|,
name|int
name|maxlen
parameter_list|,
specifier|register
name|mousestatus_t
modifier|*
name|status
parameter_list|)
block|{
specifier|static
name|int
name|butmap
index|[]
init|=
block|{
literal|0
block|,
name|MOUSE_PS2_BUTTON3DOWN
block|,
name|MOUSE_PS2_BUTTON2DOWN
block|,
name|MOUSE_PS2_BUTTON3DOWN
operator||
name|MOUSE_PS2_BUTTON2DOWN
block|,
name|MOUSE_PS2_BUTTON1DOWN
block|,
name|MOUSE_PS2_BUTTON3DOWN
operator||
name|MOUSE_PS2_BUTTON1DOWN
block|,
name|MOUSE_PS2_BUTTON2DOWN
operator||
name|MOUSE_PS2_BUTTON1DOWN
block|,
name|MOUSE_PS2_BUTTON3DOWN
operator||
name|MOUSE_PS2_BUTTON2DOWN
operator||
name|MOUSE_PS2_BUTTON1DOWN
block|, 	}
decl_stmt|;
specifier|register
name|int
name|delta
decl_stmt|;
if|if
condition|(
name|maxlen
operator|-
operator|*
name|len
operator|<
name|MOUSE_PS2_PACKETSIZE
condition|)
return|return
name|FALSE
return|;
name|buf
index|[
literal|0
index|]
operator|=
name|MOUSE_PS2_SYNC
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator||=
name|butmap
index|[
name|status
operator|->
name|button
operator|&
name|BUTSTATMASK
index|]
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dx
operator|<
operator|-
literal|128
condition|)
name|delta
operator|=
operator|-
literal|128
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|->
name|dx
operator|>
literal|127
condition|)
name|delta
operator|=
literal|127
expr_stmt|;
else|else
name|delta
operator|=
name|status
operator|->
name|dx
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|buf
index|[
literal|0
index|]
operator||=
name|MOUSE_PS2_XNEG
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|delta
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|dy
operator|<
operator|-
literal|128
condition|)
name|delta
operator|=
operator|-
literal|128
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|->
name|dy
operator|>
literal|127
condition|)
name|delta
operator|=
literal|127
expr_stmt|;
else|else
name|delta
operator|=
name|status
operator|->
name|dy
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|buf
index|[
literal|0
index|]
operator||=
name|MOUSE_PS2_YNEG
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|delta
expr_stmt|;
operator|*
name|len
operator|+=
name|MOUSE_PS2_PACKETSIZE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PSM_CURRENT
end_ifdef

begin_function
specifier|static
endif|#
directive|endif
name|int
name|psmread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|struct
name|psm_softc
modifier|*
name|sc
init|=
operator|&
name|psm_softc
index|[
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* block until mouse activity occured */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|outputbytes
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|<=
literal|0
operator|)
condition|)
block|{
while|while
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|PSM_NBLOCKIO
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|sc
operator|->
name|state
operator||=
name|PSM_ASLP
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"psmread"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|outputbytes
operator|>=
name|uio
operator|->
name|uio_resid
condition|)
block|{
comment|/* nothing to be done */
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|outputbytes
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|opacket
index|[
name|sc
operator|->
name|outputhead
index|]
argument_list|,
name|sc
operator|->
name|opacket
argument_list|,
name|sc
operator|->
name|outputbytes
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|outputhead
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|queue
operator|.
name|head
init|;
name|sc
operator|->
name|queue
operator|.
name|count
operator|>
literal|0
condition|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|PSM_BUFSIZE
operator|,
operator|--
name|sc
operator|->
name|queue
operator|.
name|count
control|)
block|{
if|if
condition|(
operator|!
call|(
modifier|*
name|sc
operator|->
name|mkpacket
call|)
argument_list|(
operator|&
name|sc
operator|->
name|opacket
index|[
name|sc
operator|->
name|outputbytes
index|]
argument_list|,
operator|&
name|sc
operator|->
name|outputbytes
argument_list|,
name|PSM_BUFSIZE
argument_list|,
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
block|}
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
name|i
expr_stmt|;
block|}
comment|/* allow interrupts again */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* copy data to user process */
name|length
operator|=
name|min
argument_list|(
name|sc
operator|->
name|outputbytes
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|sc
operator|->
name|opacket
index|[
name|sc
operator|->
name|outputhead
index|]
argument_list|,
name|length
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|outputhead
operator|+=
name|length
expr_stmt|;
name|sc
operator|->
name|outputbytes
operator|-=
name|length
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PSM_CURRENT
end_ifdef

begin_function
specifier|static
endif|#
directive|endif
name|int
name|psmioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
operator|&
name|psm_softc
index|[
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|mouseinfo_t
name|info
decl_stmt|;
name|mousestatus_t
modifier|*
name|ms
decl_stmt|;
name|packetfunc_t
name|func
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Perform IOCTL command */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOUSE_GETINFO
case|:
operator|*
operator|(
name|mousehw_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|hw
expr_stmt|;
break|break;
case|case
name|MOUSE_GETMODE
case|:
operator|*
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|=
name|sc
operator|->
name|mode
expr_stmt|;
break|break;
case|case
name|MOUSE_SETMODE
case|:
if|if
condition|(
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|rate
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
ifndef|#
directive|ifndef
name|PSM_NOEMULATION
switch|switch
condition|(
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
condition|)
block|{
case|case
name|MOUSE_PROTO_MS
case|:
name|func
operator|=
name|mkms
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_MSC
case|:
name|func
operator|=
name|mkmsc
expr_stmt|;
break|break;
case|case
name|MOUSE_PROTO_PS2
case|:
name|func
operator|=
name|mkps2
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
name|func
operator|=
operator|(
name|packetfunc_t
operator|)
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
break|break;
endif|#
directive|endif
comment|/* PSM_NOEMULATION */
if|if
condition|(
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|accelfactor
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* disable interrupt while updating */
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
operator|(
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|rate
operator|==
literal|0
operator|)
condition|?
name|PSMD_DEFAULT_RATE
else|:
name|min
argument_list|(
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|rate
argument_list|,
name|PSMD_MAX_RATE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
operator|(
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
operator|==
literal|0
operator|)
condition|?
name|PSMD_DEFAULT_RESOLUTION
else|:
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|resolution
expr_stmt|;
comment|/* temporalily disable the keyboard */
name|write_controller_command
argument_list|(
name|sc
operator|->
name|addr
argument_list|,
name|KBDC_DISABLE_KBD_PORT
argument_list|)
expr_stmt|;
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|addr
argument_list|,
name|sc
operator|->
name|command_byte
operator|&
operator|~
name|KBD_KBD_CONTROL_BITS
argument_list|,
name|KBD_DISABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_DISABLE_AUX_INT
argument_list|)
expr_stmt|;
comment|/* program the mouse */
name|sc
operator|->
name|mode
operator|.
name|rate
operator|=
name|set_mouse_sampling_rate
argument_list|(
name|sc
operator|->
name|addr
argument_list|,
name|sc
operator|->
name|mode
operator|.
name|rate
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mode
operator|.
name|resolution
operator|=
name|set_mouse_resolution
argument_list|(
name|sc
operator|->
name|addr
argument_list|,
name|sc
operator|->
name|mode
operator|.
name|resolution
argument_list|)
expr_stmt|;
comment|/* enable the aux port and interrupt */
name|set_controller_command_byte
argument_list|(
name|sc
operator|->
name|addr
argument_list|,
name|sc
operator|->
name|command_byte
argument_list|,
name|KBD_ENABLE_AUX_PORT
operator||
name|KBD_ENABLE_AUX_INT
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PSM_NOEMULATION
name|sc
operator|->
name|mode
operator|.
name|protocol
operator|=
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|protocol
expr_stmt|;
name|sc
operator|->
name|mkpacket
operator|=
name|func
expr_stmt|;
name|sc
operator|->
name|outputbytes
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|outputhead
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* PSM_NOEMULATION */
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|=
operator|(
operator|(
name|mousemode_t
operator|*
operator|)
name|addr
operator|)
operator|->
name|accelfactor
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOUSEIOCREAD
case|:
comment|/* FIXME: this should go... */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|MOUSE_GETSTATE
case|:
name|info
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|xmotion
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|ymotion
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|>
literal|0
condition|)
block|{
name|ms
operator|=
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|sc
operator|->
name|queue
operator|.
name|head
index|]
expr_stmt|;
comment|/* button status */
name|info
operator|.
name|status
operator|=
name|ms
operator|->
name|button
expr_stmt|;
comment|/* BUT?STAT bits */
name|info
operator|.
name|status
operator||=
comment|/* BUT?CHNG bits */
operator|(
operator|(
name|ms
operator|->
name|button
operator|^
name|ms
operator|->
name|obutton
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
comment|/* mouse motion */
name|info
operator|.
name|xmotion
operator|=
name|ms
operator|->
name|dx
expr_stmt|;
name|info
operator|.
name|ymotion
operator|=
name|ms
operator|->
name|dy
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|.
name|xmotion
operator|!=
literal|0
operator|)
operator|||
operator|(
name|info
operator|.
name|ymotion
operator|!=
literal|0
operator|)
condition|)
name|info
operator|.
name|status
operator||=
name|MOVEMENT
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|head
operator|=
operator|(
name|sc
operator|->
name|queue
operator|.
name|head
operator|+
literal|1
operator|)
operator|%
name|PSM_BUFSIZE
expr_stmt|;
operator|--
name|sc
operator|->
name|queue
operator|.
name|count
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
operator|(
name|mouseinfo_t
operator|*
operator|)
name|addr
operator|=
name|info
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Return error code */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|psmintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
comment|/* the table to turn PS/2 mouse button bits (MOUSE_PS2_BUTTON?DOWN)  	   into `mouseinfo' button bits (BUT?STAT). */
specifier|static
name|butmap
index|[
literal|8
index|]
operator|=
block|{
literal|0
block|,
name|BUT1STAT
block|,
name|BUT3STAT
block|,
name|BUT1STAT
operator||
name|BUT3STAT
block|,
name|BUT2STAT
block|,
name|BUT1STAT
operator||
name|BUT2STAT
block|,
name|BUT2STAT
operator||
name|BUT3STAT
block|,
name|BUT1STAT
operator||
name|BUT2STAT
operator||
name|BUT3STAT
block|}
expr_stmt|;
specifier|register
name|struct
name|psm_softc
modifier|*
name|sc
init|=
operator|&
name|psm_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|ioport
init|=
name|sc
operator|->
name|addr
decl_stmt|;
name|mousestatus_t
modifier|*
name|ms
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* is this really for us? */
if|if
condition|(
operator|(
name|inb
argument_list|(
name|ioport
operator|+
name|KBD_STATUS_PORT
argument_list|)
operator|&
name|KBDS_BUFFER_FULL
operator|)
operator|!=
name|KBDS_AUX_BUFFER_FULL
condition|)
return|return;
comment|/* read a byte */
name|c
operator|=
name|inb
argument_list|(
name|ioport
operator|+
name|KBD_DATA_PORT
argument_list|)
expr_stmt|;
comment|/* discard the byte if the device is not open */
if|if
condition|(
operator|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* interpret data bytes  	   FIXME: there seems no way to reliably re-synchronize with  	   the PS/2 mouse once we are out of sync. Sure, there is 	   sync bits in the first data byte, but the second and the  	   third bytes may have these bits on (they are not functioning 	   as sync bits then!). There need to be two consequtive  	   bytes with these bits off to re-sync. (This can be done 	   if the user clicks buttons without moving the mouse?) 	*/
if|if
condition|(
name|sc
operator|->
name|inputbytes
operator|==
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|PSM_NOCHECKSYNC
if|if
condition|(
operator|(
name|c
operator|&
name|MOUSE_PS2_SYNCMASK
operator|)
operator|==
name|MOUSE_PS2_SYNC
condition|)
endif|#
directive|endif
comment|/* PSM_NOCHECKSYNC */
name|sc
operator|->
name|ipacket
index|[
name|sc
operator|->
name|inputbytes
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|ipacket
index|[
name|sc
operator|->
name|inputbytes
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|inputbytes
operator|>=
name|MOUSE_PS2_PACKETSIZE
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|>=
name|PSM_BUFSIZE
condition|)
block|{
comment|/* no room in the queue */
name|sc
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|mode
operator|.
name|accelfactor
operator|>=
literal|1
condition|)
block|{
name|x
operator|=
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_XOVERFLOW
operator|)
condition|?
literal|128
else|:
name|sc
operator|->
name|ipacket
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|x
operator|=
name|x
operator|*
name|x
operator|/
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
name|x
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_XNEG
condition|)
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
name|y
operator|=
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_YOVERFLOW
operator|)
condition|?
literal|128
else|:
name|sc
operator|->
name|ipacket
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|y
operator|!=
literal|0
condition|)
block|{
name|y
operator|=
name|y
operator|*
name|y
operator|/
name|sc
operator|->
name|mode
operator|.
name|accelfactor
expr_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
name|y
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_YNEG
condition|)
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* sc->mode.accelfactor<= 0 */
name|x
operator|=
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_XOVERFLOW
operator|)
condition|?
operator|(
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_XNEG
operator|)
condition|?
operator|-
literal|128
else|:
literal|127
operator|)
else|:
name|sc
operator|->
name|ipacket
index|[
literal|1
index|]
expr_stmt|;
name|y
operator|=
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_YOVERFLOW
operator|)
condition|?
operator|(
operator|(
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_YNEG
operator|)
condition|?
operator|-
literal|128
else|:
literal|127
operator|)
else|:
name|sc
operator|->
name|ipacket
index|[
literal|2
index|]
expr_stmt|;
block|}
comment|/* FIXME: we shouldn't store data if no movement  			   and no button status change is detected? */
name|ms
operator|=
operator|&
name|sc
operator|->
name|queue
operator|.
name|buf
index|[
name|sc
operator|->
name|queue
operator|.
name|tail
index|]
expr_stmt|;
name|ms
operator|->
name|dx
operator|=
name|x
expr_stmt|;
name|ms
operator|->
name|dy
operator|=
name|y
expr_stmt|;
name|ms
operator|->
name|obutton
operator|=
name|sc
operator|->
name|button
expr_stmt|;
comment|/* previous button state */
name|sc
operator|->
name|button
operator|=
name|ms
operator|->
name|button
operator|=
comment|/* latest button state */
name|butmap
index|[
name|sc
operator|->
name|ipacket
index|[
literal|0
index|]
operator|&
name|MOUSE_PS2_BUTTONS
index|]
expr_stmt|;
name|sc
operator|->
name|queue
operator|.
name|tail
operator|=
operator|(
name|sc
operator|->
name|queue
operator|.
name|tail
operator|+
literal|1
operator|)
operator|%
name|PSM_BUFSIZE
expr_stmt|;
operator|++
name|sc
operator|->
name|queue
operator|.
name|count
expr_stmt|;
name|sc
operator|->
name|inputbytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_ASLP
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_ASLP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PSM_CURRENT
end_ifdef

begin_function
specifier|static
endif|#
directive|endif
name|int
name|psmselect
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|rw
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
operator|&
name|psm_softc
index|[
name|PSM_UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|,
name|ret
decl_stmt|;
comment|/* Silly to select for output */
if|if
condition|(
name|rw
operator|==
name|FWRITE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Return true if a mouse event available */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|outputbytes
operator|>
literal|0
operator|)
operator|||
operator|(
name|sc
operator|->
name|queue
operator|.
name|count
operator|>
literal|0
operator|)
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PSM_CURRENT
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|psm_devsw_installed
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|psm_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|psm_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|psm_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|psm_devsw_installed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|psmdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE + CDEV_MAJOR
argument_list|,
argument|psm_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PSM_CURRENT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPSM> 0 */
end_comment

end_unit

