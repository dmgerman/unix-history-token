begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993 Erik Forsberg.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN  * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  *  Ported to 386bsd Oct 17, 1992  *  Sandi Donno, Computer Science, University of Cape Town, South Africa  *  Please send bug reports to sandi@cs.uct.ac.za  *  *  Thanks are also due to Rick Macklem, rick@snowhite.cis.uoguelph.ca -  *  although I was only partially successful in getting the alpha release  *  of his "driver for the Logitech and ATI Inport Bus mice for use with  *  386bsd and the X386 port" to work with my Microsoft mouse, I nevertheless  *  found his code to be an invaluable reference when porting this driver  *  to 386bsd.  *  *  Further modifications for latest 386BSD+patchkit and port to NetBSD,  *  Andrew Herbert<andrew@werple.apana.org.au> - 8 June 1993  *  *  Cloned from the Microsoft Bus Mouse driver, also by Erik Forsberg, by  *  Andrew Herbert - 12 June 1993  *  *  Modified for PS/2 mouse by Charles Hannum<mycroft@ai.mit.edu>  *  - 13 June 1993  *  *  Modified for PS/2 AUX mouse by Shoji Yuen<yuen@nuie.nagoya-u.ac.jp>  *  - 24 October 1993  */
end_comment

begin_include
include|#
directive|include
file|"psm.h"
end_include

begin_if
if|#
directive|if
name|NPSM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<machine/mouse.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_define
define|#
directive|define
name|PSM_DATA
value|0x00
end_define

begin_comment
comment|/* Offset for data port, read-write */
end_comment

begin_define
define|#
directive|define
name|PSM_CNTRL
value|0x04
end_define

begin_comment
comment|/* Offset for control port, write-only */
end_comment

begin_define
define|#
directive|define
name|PSM_STATUS
value|0x04
end_define

begin_comment
comment|/* Offset for status port, read-only */
end_comment

begin_comment
comment|/* status bits */
end_comment

begin_define
define|#
directive|define
name|PSM_OUTPUT_ACK
value|0x02
end_define

begin_comment
comment|/* output acknowledge */
end_comment

begin_comment
comment|/* controller commands */
end_comment

begin_define
define|#
directive|define
name|PSM_INT_ENABLE
value|0x47
end_define

begin_comment
comment|/* enable controller interrupts */
end_comment

begin_define
define|#
directive|define
name|PSM_INT_DISABLE
value|0x65
end_define

begin_comment
comment|/* disable controller interrupts */
end_comment

begin_define
define|#
directive|define
name|PSM_DISABLE
value|0xa7
end_define

begin_comment
comment|/* disable auxiliary port */
end_comment

begin_define
define|#
directive|define
name|PSM_ENABLE
value|0xa8
end_define

begin_comment
comment|/* enable auxiliary port */
end_comment

begin_define
define|#
directive|define
name|PSM_ENABLE
value|0xa9
end_define

begin_comment
comment|/* test auxiliary port */
end_comment

begin_comment
comment|/* mouse commands */
end_comment

begin_define
define|#
directive|define
name|PSM_SET_SCALE11
value|0xe6
end_define

begin_comment
comment|/* set 1:1 scaling */
end_comment

begin_define
define|#
directive|define
name|PSM_SET_SCALE21
value|0xe7
end_define

begin_comment
comment|/* set 2:1 scaling */
end_comment

begin_define
define|#
directive|define
name|PSM_SET_RES
value|0xe8
end_define

begin_comment
comment|/* set resolution */
end_comment

begin_define
define|#
directive|define
name|PSM_GET_SCALE
value|0xe9
end_define

begin_comment
comment|/* set scaling factor */
end_comment

begin_define
define|#
directive|define
name|PSM_SET_STREAM
value|0xea
end_define

begin_comment
comment|/* set streaming mode */
end_comment

begin_define
define|#
directive|define
name|PSM_SET_SAMPLE
value|0xf3
end_define

begin_comment
comment|/* set sampling rate */
end_comment

begin_define
define|#
directive|define
name|PSM_DEV_ENABLE
value|0xf4
end_define

begin_comment
comment|/* mouse on */
end_comment

begin_define
define|#
directive|define
name|PSM_DEV_DISABLE
value|0xf5
end_define

begin_comment
comment|/* mouse off */
end_comment

begin_define
define|#
directive|define
name|PSM_RESET
value|0xff
end_define

begin_comment
comment|/* reset */
end_comment

begin_define
define|#
directive|define
name|PSMUNIT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)>> 1)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(x< y ? x : y)
end_define

begin_endif
endif|#
directive|endif
endif|min
end_endif

begin_function_decl
specifier|static
name|int
name|psmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|psmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|psm_poll_status
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|psmaddr
index|[
name|NPSM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base I/O port addresses per unit */
end_comment

begin_define
define|#
directive|define
name|PSM_CHUNK
value|128
end_define

begin_comment
comment|/* chunk size for read */
end_comment

begin_define
define|#
directive|define
name|PSM_BSIZE
value|1024
end_define

begin_comment
comment|/* buffer size */
end_comment

begin_struct
struct|struct
name|ringbuf
block|{
name|int
name|count
decl_stmt|,
name|first
decl_stmt|,
name|last
decl_stmt|;
name|char
name|queue
index|[
name|PSM_BSIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|psm_softc
block|{
comment|/* Driver status information */
name|struct
name|ringbuf
name|inq
decl_stmt|;
comment|/* Input queue */
name|struct
name|selinfo
name|rsel
decl_stmt|;
comment|/* Process selecting for Input */
name|unsigned
name|char
name|state
decl_stmt|;
comment|/* Mouse driver state */
name|unsigned
name|char
name|status
decl_stmt|;
comment|/* Mouse button status */
name|unsigned
name|char
name|button
decl_stmt|;
comment|/* Previous mouse button status bits */
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* accumulated motion in the X,Y axis */
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|devfs_token
decl_stmt|;
name|void
modifier|*
name|n_devfs_token
decl_stmt|;
endif|#
directive|endif
block|}
name|psm_softc
index|[
name|NPSM
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|PSM_OPEN
value|1
end_define

begin_comment
comment|/* Device is open */
end_comment

begin_define
define|#
directive|define
name|PSM_ASLP
value|2
end_define

begin_comment
comment|/* Waiting for mouse data */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|psmdriver
init|=
block|{
name|psmprobe
block|,
name|psmattach
block|,
literal|"psm"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|psmopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|psmclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|psmread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|psmioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_select_t
name|psmselect
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|21
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|psm_cdevsw
init|=
block|{
name|psmopen
block|,
name|psmclose
block|,
name|psmread
block|,
name|nowrite
block|,
comment|/*21*/
name|psmioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|psmselect
block|,
name|nommap
block|,
name|NULL
block|,
literal|"psm"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|kdc_psm
index|[
name|NPSM
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* filled in by dev_attach */
literal|"psm"
block|,
literal|0
block|,
block|{
name|MDDT_ISA
block|,
literal|0
block|,
literal|"tty"
block|}
block|,
name|isa_generic_externalize
block|,
literal|0
block|,
literal|0
block|,
name|ISA_EXTERNALLEN
block|,
operator|&
name|kdc_isa0
block|,
comment|/* parent */
literal|0
block|,
comment|/* parentdata */
name|DC_UNCONFIGURED
block|,
comment|/* state */
literal|"PS/2 Mouse"
block|,
name|DC_CLS_MISC
comment|/* class */
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|psm_registerdev
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|->
name|id_unit
condition|)
name|kdc_psm
index|[
name|id
operator|->
name|id_unit
index|]
operator|=
name|kdc_psm
index|[
literal|0
index|]
expr_stmt|;
name|kdc_psm
index|[
name|id
operator|->
name|id_unit
index|]
operator|.
name|kdc_unit
operator|=
name|id
operator|->
name|id_unit
expr_stmt|;
name|kdc_psm
index|[
name|id
operator|->
name|id_unit
index|]
operator|.
name|kdc_isa
operator|=
name|id
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|kdc_psm
index|[
name|id
operator|->
name|id_unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|psm_write_dev
parameter_list|(
name|int
name|ioport
parameter_list|,
name|u_char
name|value
parameter_list|)
block|{
name|psm_poll_status
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|PSM_CNTRL
argument_list|,
literal|0xd4
argument_list|)
expr_stmt|;
name|psm_poll_status
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|PSM_DATA
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|psm_command
parameter_list|(
name|int
name|ioport
parameter_list|,
name|u_char
name|value
parameter_list|)
block|{
name|psm_poll_status
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|PSM_CNTRL
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
name|psm_poll_status
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|PSM_DATA
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
comment|/* XXX: Needs a real probe routine. */
name|int
name|ioport
decl_stmt|,
name|c
decl_stmt|,
name|unit
decl_stmt|;
name|psm_registerdev
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|ioport
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|unit
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
ifndef|#
directive|ifndef
name|PSM_NO_RESET
name|psm_write_dev
argument_list|(
name|ioport
argument_list|,
name|PSM_RESET
argument_list|)
expr_stmt|;
comment|/* Reset aux device */
endif|#
directive|endif
name|psm_poll_status
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|PSM_CNTRL
argument_list|,
name|PSM_AUX_TEST
argument_list|)
expr_stmt|;
name|psm_poll_status
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|PSM_CNTRL
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|c
operator|=
name|inb
argument_list|(
name|ioport
operator|+
name|PSM_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0x04
condition|)
block|{
comment|/*		printf("PS/2 AUX mouse is not found\n");*/
name|psm_command
argument_list|(
name|ioport
argument_list|,
name|PSM_INT_DISABLE
argument_list|)
expr_stmt|;
name|psmaddr
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Device not found */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*	printf("PS/2 AUX mouse found.  Installing driver\n");*/
return|return
operator|(
literal|4
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|int
name|ioport
init|=
name|dvp
operator|->
name|id_iobase
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
init|=
operator|&
name|psm_softc
index|[
name|unit
index|]
decl_stmt|;
comment|/* Save I/O base address */
name|psmaddr
index|[
name|unit
index|]
operator|=
name|ioport
expr_stmt|;
comment|/* Disable mouse interrupts */
name|psm_poll_status
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|PSM_CNTRL
argument_list|,
name|PSM_ENABLE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|0
name|psm_write
argument_list|(
name|ioport
argument_list|,
name|PSM_SET_RES
argument_list|)
expr_stmt|;
name|psm_write
argument_list|(
name|ioport
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* 8 counts/mm */
name|psm_write
argument_list|(
name|ioport
argument_list|,
name|PSM_SET_SCALE
argument_list|)
expr_stmt|;
name|psm_write
argument_list|(
name|ioport
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* 2:1 */
name|psm_write
argument_list|(
name|ioport
argument_list|,
name|PSM_SET_SCALE21
argument_list|)
expr_stmt|;
name|psm_write
argument_list|(
name|ioport
argument_list|,
name|PSM_SET_SAMPLE
argument_list|)
expr_stmt|;
name|psm_write
argument_list|(
name|ioport
argument_list|,
literal|0x64
argument_list|)
expr_stmt|;
comment|/* 100 samples/sec */
name|psm_write
argument_list|(
name|ioport
argument_list|,
name|PSM_SET_STREAM
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|psm_poll_status
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|PSM_CNTRL
argument_list|,
name|PSM_DISABLE
argument_list|)
expr_stmt|;
name|psm_command
argument_list|(
name|ioport
argument_list|,
name|PSM_INT_DISABLE
argument_list|)
expr_stmt|;
comment|/* Setup initial state */
name|sc
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|kdc_psm
index|[
name|unit
index|]
operator|.
name|kdc_state
operator|=
name|DC_IDLE
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX eh? usually 1 indicates success */
block|}
end_function

begin_function
specifier|static
name|int
name|psmopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|ioport
decl_stmt|;
name|int
name|unit
init|=
name|PSMUNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* Validate unit number */
if|if
condition|(
name|unit
operator|>=
name|NPSM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Get device data */
name|sc
operator|=
operator|&
name|psm_softc
index|[
name|unit
index|]
expr_stmt|;
name|ioport
operator|=
name|psmaddr
index|[
name|unit
index|]
expr_stmt|;
comment|/* If device does not exist */
if|if
condition|(
name|ioport
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Disallow multiple opens */
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_OPEN
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Initialize state */
name|kdc_psm
index|[
name|unit
index|]
operator|.
name|kdc_state
operator|=
name|DC_BUSY
expr_stmt|;
name|sc
operator|->
name|state
operator||=
name|PSM_OPEN
expr_stmt|;
name|sc
operator|->
name|rsel
operator|.
name|si_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|rsel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|button
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|x
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|y
operator|=
literal|0
expr_stmt|;
comment|/* Allocate and initialize a ring buffer */
name|sc
operator|->
name|inq
operator|.
name|count
operator|=
name|sc
operator|->
name|inq
operator|.
name|first
operator|=
name|sc
operator|->
name|inq
operator|.
name|last
operator|=
literal|0
expr_stmt|;
comment|/* Enable Bus Mouse interrupts */
name|psm_write_dev
argument_list|(
name|ioport
argument_list|,
name|PSM_DEV_ENABLE
argument_list|)
expr_stmt|;
name|psm_poll_status
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|PSM_CNTRL
argument_list|,
name|PSM_ENABLE
argument_list|)
expr_stmt|;
name|psm_command
argument_list|(
name|ioport
argument_list|,
name|PSM_INT_ENABLE
argument_list|)
expr_stmt|;
comment|/* Successful open */
ifdef|#
directive|ifdef
name|DEVFS
name|sc
operator|->
name|devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|psm_cdevsw
argument_list|,
name|unit
operator|<<
literal|1
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0666
argument_list|,
literal|"psm%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|n_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|psm_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|1
operator|)
operator|+
literal|1
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0666
argument_list|,
literal|"npsm%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|psm_poll_status
parameter_list|(
name|int
name|ioport
parameter_list|)
block|{
name|u_char
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
name|inb
argument_list|(
name|ioport
operator|+
name|PSM_STATUS
argument_list|)
operator|&
literal|0x03
condition|)
if|if
condition|(
name|c
operator|&
name|PSM_OUTPUT_ACK
operator|==
name|PSM_OUTPUT_ACK
condition|)
name|inb
argument_list|(
name|ioport
operator|+
name|PSM_DATA
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|psmclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|ioport
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
comment|/* Get unit and associated info */
name|unit
operator|=
name|PSMUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|&
name|psm_softc
index|[
name|unit
index|]
expr_stmt|;
name|ioport
operator|=
name|psmaddr
index|[
name|unit
index|]
expr_stmt|;
comment|/* Disable further mouse interrupts */
name|psm_command
argument_list|(
name|ioport
argument_list|,
name|PSM_INT_DISABLE
argument_list|)
expr_stmt|;
name|psm_poll_status
argument_list|(
name|ioport
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioport
operator|+
name|PSM_CNTRL
argument_list|,
name|PSM_DISABLE
argument_list|)
expr_stmt|;
comment|/* Complete the close */
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_OPEN
expr_stmt|;
name|kdc_psm
index|[
name|unit
index|]
operator|.
name|kdc_state
operator|=
name|DC_IDLE
expr_stmt|;
comment|/* close is almost always successful */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* keep compiler quiet, even though initialisation 			   is unnecessary */
name|unsigned
name|length
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|char
name|buffer
index|[
name|PSM_CHUNK
index|]
decl_stmt|;
comment|/* Get device information */
name|sc
operator|=
operator|&
name|psm_softc
index|[
name|PSMUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
comment|/* Block until mouse activity occured */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|inq
operator|.
name|count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x1
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|sc
operator|->
name|state
operator||=
name|PSM_ASLP
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"psmrea"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Transfer as many chunks as possible */
while|while
condition|(
name|sc
operator|->
name|inq
operator|.
name|count
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|length
operator|=
name|min
argument_list|(
name|sc
operator|->
name|inq
operator|.
name|count
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|)
name|length
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Remove a small chunk from input queue */
if|if
condition|(
name|sc
operator|->
name|inq
operator|.
name|first
operator|+
name|length
operator|>=
name|PSM_BSIZE
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|inq
operator|.
name|queue
index|[
name|sc
operator|->
name|inq
operator|.
name|first
index|]
argument_list|,
name|buffer
argument_list|,
name|PSM_BSIZE
operator|-
name|sc
operator|->
name|inq
operator|.
name|first
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|inq
operator|.
name|queue
argument_list|,
operator|&
name|buffer
index|[
name|PSM_BSIZE
operator|-
name|sc
operator|->
name|inq
operator|.
name|first
index|]
argument_list|,
name|length
operator|-
operator|(
name|PSM_BSIZE
operator|-
name|sc
operator|->
name|inq
operator|.
name|first
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|inq
operator|.
name|queue
index|[
name|sc
operator|->
name|inq
operator|.
name|first
index|]
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sc
operator|->
name|inq
operator|.
name|first
operator|=
operator|(
name|sc
operator|->
name|inq
operator|.
name|first
operator|+
name|length
operator|)
operator|%
name|PSM_BSIZE
expr_stmt|;
name|sc
operator|->
name|inq
operator|.
name|count
operator|-=
name|length
expr_stmt|;
comment|/* Copy data to user process */
name|error
operator|=
name|uiomove
argument_list|(
name|buffer
argument_list|,
name|length
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|sc
operator|->
name|x
operator|=
name|sc
operator|->
name|y
operator|=
literal|0
expr_stmt|;
comment|/* Allow interrupts again */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mouseinfo
name|info
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
comment|/* Get device information */
name|sc
operator|=
operator|&
name|psm_softc
index|[
name|PSMUNIT
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
comment|/* Perform IOCTL command */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOUSEIOCREAD
case|:
comment|/* Don't modify info while calculating */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* Build mouse status octet */
name|info
operator|.
name|status
operator|=
name|sc
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|x
operator|||
name|sc
operator|->
name|y
condition|)
name|info
operator|.
name|status
operator||=
name|MOVEMENT
expr_stmt|;
comment|/* Encode X and Y motion as good as we can */
if|if
condition|(
name|sc
operator|->
name|x
operator|>
literal|127
condition|)
name|info
operator|.
name|xmotion
operator|=
literal|127
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|x
operator|<
operator|-
literal|128
condition|)
name|info
operator|.
name|xmotion
operator|=
operator|-
literal|128
expr_stmt|;
else|else
name|info
operator|.
name|xmotion
operator|=
name|sc
operator|->
name|x
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|y
operator|>
literal|127
condition|)
name|info
operator|.
name|ymotion
operator|=
literal|127
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|y
operator|<
operator|-
literal|128
condition|)
name|info
operator|.
name|ymotion
operator|=
operator|-
literal|128
expr_stmt|;
else|else
name|info
operator|.
name|ymotion
operator|=
name|sc
operator|->
name|y
expr_stmt|;
comment|/* Reset historical information */
name|sc
operator|->
name|x
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|y
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|status
operator|&=
operator|~
name|BUTCHNGMASK
expr_stmt|;
comment|/* Allow interrupts and copy result buffer */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|info
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mouseinfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Return error code */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|psmintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|psm_softc
modifier|*
name|sc
init|=
operator|&
name|psm_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|ioport
init|=
name|psmaddr
index|[
name|unit
index|]
decl_stmt|;
name|sc
operator|->
name|inq
operator|.
name|queue
index|[
name|sc
operator|->
name|inq
operator|.
name|last
operator|++
operator|%
name|PSM_BSIZE
index|]
operator|=
name|inb
argument_list|(
name|ioport
operator|+
name|PSM_DATA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|inq
operator|.
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|state
operator|&
name|PSM_ASLP
condition|)
block|{
name|sc
operator|->
name|state
operator|&=
operator|~
name|PSM_ASLP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|psmselect
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|rw
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|psm_softc
modifier|*
name|sc
init|=
operator|&
name|psm_softc
index|[
name|PSMUNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
comment|/* Silly to select for output */
if|if
condition|(
name|rw
operator|==
name|FWRITE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Return true if a mouse event available */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|inq
operator|.
name|count
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|rsel
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|psm_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|psm_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|psm_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|psm_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|psm_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|psmdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|psm_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPSM> 0 */
end_comment

end_unit

