begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * FreeBSD generic NCR-5380/NCR-53C400 SCSI driver  *  * Copyright (C) 1994 Serge Vakulenko (vak@cronyx.ru)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE DEVELOPERS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE DEVELOPERS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Tested on the following hardware:  *  Adapter: Trantor T130  * Streamer: Archive Viper 150,  *   CD-ROM: NEC CDR-25  */
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_include
include|#
directive|include
file|"nca.h"
end_include

begin_if
if|#
directive|if
name|NNCA
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ic/ncr5380.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ic/ncr53400.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|PRINT
parameter_list|(
name|s
parameter_list|)
value|printf s
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PRINT
parameter_list|(
name|s
parameter_list|)
end_define

begin_comment
comment|/*void*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SCB_TABLE_SIZE
value|8
end_define

begin_comment
comment|/* start with 8 scb entries in table */
end_comment

begin_define
define|#
directive|define
name|BLOCK_SIZE
value|512
end_define

begin_comment
comment|/* size of READ/WRITE areas on SCSI card */
end_comment

begin_define
define|#
directive|define
name|HOST_SCSI_ADDR
value|7
end_define

begin_comment
comment|/* address of the adapter on the SCSI bus */
end_comment

begin_comment
comment|/*  * Defice config flags  */
end_comment

begin_define
define|#
directive|define
name|FLAG_NOPARITY
value|0x01
end_define

begin_comment
comment|/* disable SCSI bus parity check */
end_comment

begin_comment
comment|/*  * ProAudioSpectrum registers  */
end_comment

begin_define
define|#
directive|define
name|PAS16_DATA
value|8
end_define

begin_comment
comment|/* Data Register */
end_comment

begin_define
define|#
directive|define
name|PAS16_STAT
value|9
end_define

begin_comment
comment|/* Status Register */
end_comment

begin_define
define|#
directive|define
name|PAS16_STAT_DREQ
value|0x80
end_define

begin_comment
comment|/* Pseudo-DMA ready bit */
end_comment

begin_define
define|#
directive|define
name|PAS16_REG
parameter_list|(
name|r
parameter_list|)
value|(((r)& 0xc)<< 11 | ((r)& 3))
end_define

begin_decl_stmt
specifier|static
name|u_char
name|pas16_irq_magic
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|0
block|,
literal|10
block|,
literal|11
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * SCSI bus phases  */
end_comment

begin_define
define|#
directive|define
name|PHASE_MASK
value|(CSBR_MSG | CSBR_CD | CSBR_IO)
end_define

begin_define
define|#
directive|define
name|PHASE_DATAOUT
value|0
end_define

begin_define
define|#
directive|define
name|PHASE_DATAIN
value|CSBR_IO
end_define

begin_define
define|#
directive|define
name|PHASE_CMDOUT
value|CSBR_CD
end_define

begin_define
define|#
directive|define
name|PHASE_STATIN
value|(CSBR_CD | CSBR_IO)
end_define

begin_define
define|#
directive|define
name|PHASE_MSGOUT
value|(CSBR_MSG | CSBR_CD)
end_define

begin_define
define|#
directive|define
name|PHASE_MSGIN
value|(CSBR_MSG | CSBR_CD | CSBR_IO)
end_define

begin_define
define|#
directive|define
name|PHASE_NAME
parameter_list|(
name|ph
parameter_list|)
value|phase_name[(ph)>>2]
end_define

begin_define
define|#
directive|define
name|PHASE_TO_TCR
parameter_list|(
name|ph
parameter_list|)
value|((ph)>> 2)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|phase_name
index|[]
init|=
block|{
literal|"DATAOUT"
block|,
literal|"DATAIN"
block|,
literal|"CMDOUT"
block|,
literal|"STATIN"
block|,
literal|"Phase4?"
block|,
literal|"Phase5?"
block|,
literal|"MSGOUT"
block|,
literal|"MSGIN"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * SCSI message codes  */
end_comment

begin_define
define|#
directive|define
name|MSG_COMMAND_COMPLETE
value|0x00
end_define

begin_define
define|#
directive|define
name|MSG_SAVE_POINTERS
value|0x02
end_define

begin_define
define|#
directive|define
name|MSG_RESTORE_POINTERS
value|0x03
end_define

begin_define
define|#
directive|define
name|MSG_DISCONNECT
value|0x04
end_define

begin_define
define|#
directive|define
name|MSG_ABORT
value|0x06
end_define

begin_define
define|#
directive|define
name|MSG_MESSAGE_REJECT
value|0x07
end_define

begin_define
define|#
directive|define
name|MSG_NOP
value|0x08
end_define

begin_define
define|#
directive|define
name|MSG_BUS_DEV_RESET
value|0x0c
end_define

begin_define
define|#
directive|define
name|MSG_IDENTIFY
parameter_list|(
name|lun
parameter_list|)
value|(0xc0 | ((lun)& 0x7))
end_define

begin_define
define|#
directive|define
name|MSG_ISIDENT
parameter_list|(
name|m
parameter_list|)
value|((m)& 0x80)
end_define

begin_comment
comment|/*  * SCSI control block used to keep info about a scsi command  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|scb
block|{
name|int
name|flags
decl_stmt|;
comment|/* status of the instruction */
define|#
directive|define
name|SCB_FREE
value|0x00
define|#
directive|define
name|SCB_ACTIVE
value|0x01
define|#
directive|define
name|SCB_ABORTED
value|0x02
define|#
directive|define
name|SCB_TIMEOUT
value|0x04
define|#
directive|define
name|SCB_ERROR
value|0x08
define|#
directive|define
name|SCB_TIMECHK
value|0x10
comment|/* we have set a timeout on this one */
define|#
directive|define
name|SCB_SENSE
value|0x20
comment|/* sensed data available */
define|#
directive|define
name|SCB_TBUSY
value|0x40
comment|/* target busy */
name|struct
name|scb
modifier|*
name|next
decl_stmt|;
comment|/* in free list */
name|struct
name|scsi_xfer
modifier|*
name|xfer
decl_stmt|;
comment|/* the scsi_xfer for this cmd */
name|u_char
modifier|*
name|data
decl_stmt|;
comment|/* position in data buffer so far */
name|int32
name|datalen
decl_stmt|;
comment|/* bytes remaining to transfer */
empty_stmt|;
block|}
name|scb_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTLR_NONE
block|,
name|CTLR_NCR_5380
block|,
name|CTLR_NCR_53C400
block|,
name|CTLR_PAS_16
block|, }
name|ctlr_t
typedef|;
end_typedef

begin_comment
comment|/*  * Data structure describing the target state.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_char
name|busy
decl_stmt|;
comment|/* mask of busy luns at device target */
name|u_long
name|perrcnt
decl_stmt|;
comment|/* counter of target parity errors */
block|}
name|target_t
typedef|;
end_typedef

begin_comment
comment|/*  * Data structure describing current status of the scsi bus. One for each  * controller card.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|ctlr_t
name|type
decl_stmt|;
comment|/* Seagate or Future Domain */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* adapter name */
comment|/* NCR-5380 controller registers */
name|u_short
name|ODR
decl_stmt|;
comment|/* (wo-0) Output Data Register */
name|u_short
name|CSDR
decl_stmt|;
comment|/* (ro-0) Current SCSI Data Register */
name|u_short
name|ICR
decl_stmt|;
comment|/* (rw-1) Initiator Command Register */
name|u_short
name|MR
decl_stmt|;
comment|/* (rw-2) Mode Register */
name|u_short
name|TCR
decl_stmt|;
comment|/* (rw-3) Target Command Register */
name|u_short
name|SER
decl_stmt|;
comment|/* (wo-4) Select Enable Register */
name|u_short
name|CSBR
decl_stmt|;
comment|/* (ro-4) Current SCSI Bus Status Register */
name|u_short
name|BSR
decl_stmt|;
comment|/* (ro-5) Bus and Status Register */
name|u_short
name|SDSR
decl_stmt|;
comment|/* (wo-5) Start DMA Send Register */
name|u_short
name|SDIR
decl_stmt|;
comment|/* (wo-7) Start DMA Initiator Receive Register */
name|u_short
name|RPIR
decl_stmt|;
comment|/* (ro-7) Reset Parity/Interrupt Register */
comment|/* NCR-53C400 controller registers */
name|u_short
name|CSR
decl_stmt|;
comment|/* (rw-0) Control and Status Register */
name|u_short
name|CCR
decl_stmt|;
comment|/* (rw-1) Clock Counter Register */
name|u_short
name|HBR
decl_stmt|;
comment|/* (rw-4) Host Buffer Register */
comment|/* ProAudioSpectrum controller registers */
name|u_short
name|PDATA
decl_stmt|;
comment|/* (rw) Pseudo-DMA Data Register */
name|u_short
name|PSTAT
decl_stmt|;
comment|/* (rw) Pseudo-DMA Status Register */
name|u_char
name|scsi_addr
decl_stmt|;
comment|/* our scsi address, 0..7 */
name|u_char
name|scsi_id
decl_stmt|;
comment|/* our scsi id mask */
name|u_char
name|parity
decl_stmt|;
comment|/* parity flag: CMD_EN_PARITY or 0 */
name|u_char
name|irq
decl_stmt|;
comment|/* IRQ number used or 0 if no IRQ */
name|u_int
name|timeout_active
range|:
literal|1
decl_stmt|;
comment|/* timeout() active (requested) */
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
comment|/* struct connecting different data */
name|scb_t
modifier|*
name|queue
decl_stmt|;
comment|/* waiting to be issued */
name|scb_t
modifier|*
name|disconnected_queue
decl_stmt|;
comment|/* waiting to reconnect */
name|int
name|numscb
decl_stmt|;
comment|/* number of scsi control blocks */
name|scb_t
modifier|*
name|free_scb
decl_stmt|;
comment|/* free scb list */
name|scb_t
name|scbs
index|[
name|SCB_TABLE_SIZE
index|]
decl_stmt|;
name|target_t
name|target
index|[
literal|8
index|]
decl_stmt|;
comment|/* target state data */
block|}
name|adapter_t
typedef|;
end_typedef

begin_decl_stmt
name|adapter_t
name|ncadata
index|[
name|NNCA
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_BUSY
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)->target[(b)->xfer->sc_link->target].busy&\ 				(1<< (b)->xfer->sc_link->lun))
end_define

begin_define
define|#
directive|define
name|SET_BUSY
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)->target[(b)->xfer->sc_link->target].busy |=\ 				(1<< (b)->xfer->sc_link->lun))
end_define

begin_define
define|#
directive|define
name|CLEAR_BUSY
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)->target[(b)->xfer->sc_link->target].busy&=\ 				~(1<< (b)->xfer->sc_link->lun))
end_define

begin_comment
comment|/*  * Wait for condition, given as an boolean expression.  * Print the message on timeout.  */
end_comment

begin_define
define|#
directive|define
name|WAITFOR
parameter_list|(
name|condition
parameter_list|,
name|count
parameter_list|,
name|message
parameter_list|)
value|{\ 	register u_long cnt = count; char *msg = message;\ 	while (cnt--&& ! (condition)) continue;\ 	if (cnt == -1&& msg)\ 		printf ("nca: %s timeout\n", msg); }
end_define

begin_function_decl
specifier|static
name|int
name|nca_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nca_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32
name|nca_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32
name|nca_adapter_info
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nca_timeout
parameter_list|(
name|void
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncaminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nca_done
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nca_start
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nca_information_transfer
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nca_poll
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nca_init
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nca_reselect
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nca_select
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nca_abort
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nca_send_abort
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
name|nca_msg_input
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nca_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nca_sense
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nca_data_output
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|u_char
modifier|*
modifier|*
name|pdata
parameter_list|,
name|u_long
modifier|*
name|plen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nca_data_input
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|u_char
modifier|*
modifier|*
name|pdata
parameter_list|,
name|u_long
modifier|*
name|plen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nca_cmd_output
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|u_char
modifier|*
name|cmd
parameter_list|,
name|int
name|cmdlen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nca_53400_dma_xfer
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|int
name|r
parameter_list|,
name|u_char
modifier|*
modifier|*
name|dat
parameter_list|,
name|u_long
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nca_pas_dma_xfer
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|int
name|r
parameter_list|,
name|u_char
modifier|*
modifier|*
name|dat
parameter_list|,
name|u_long
modifier|*
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|nca_switch
init|=
block|{
name|nca_scsi_cmd
block|,
name|ncaminphys
block|,
literal|0
block|,
literal|0
block|,
name|nca_adapter_info
block|,
literal|"nca"
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|nca_dev
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"nca"
block|,
literal|0
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|ncadriver
init|=
block|{
name|nca_probe
block|,
name|nca_attach
block|,
literal|"nca"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|nca_description
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|nca_kdc
index|[
name|NNCA
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"nca"
block|,
literal|0
block|,
block|{
name|MDDT_ISA
block|,
literal|0
block|,
literal|"bio"
block|}
block|,
name|isa_generic_externalize
block|,
literal|0
block|,
literal|0
block|,
name|ISA_EXTERNALLEN
block|,
operator|&
name|kdc_isa0
block|,
literal|0
block|,
name|DC_UNCONFIGURED
block|,
name|nca_description
block|,
name|DC_CLS_MISC
comment|/* host adapters aren't special */
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check if the device can be found at the port given and if so,  * detect the type of board. Set it up ready for further work.  * Takes the isa_dev structure from autoconf as an argument.  * Returns 1 if card recognized, 0 if errors.  */
end_comment

begin_function
name|int
name|nca_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|adapter_t
modifier|*
name|z
init|=
operator|&
name|ncadata
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_unit
condition|)
name|nca_kdc
index|[
name|dev
operator|->
name|id_unit
index|]
operator|=
name|nca_kdc
index|[
literal|0
index|]
expr_stmt|;
name|nca_kdc
index|[
name|dev
operator|->
name|id_unit
index|]
operator|.
name|kdc_unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
name|nca_kdc
index|[
name|dev
operator|->
name|id_unit
index|]
operator|.
name|kdc_isa
operator|=
name|dev
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|nca_kdc
index|[
name|dev
operator|->
name|id_unit
index|]
argument_list|)
expr_stmt|;
comment|/* Init fields used by our routines */
name|z
operator|->
name|parity
operator|=
operator|(
name|dev
operator|->
name|id_flags
operator|&
name|FLAG_NOPARITY
operator|)
condition|?
literal|0
else|:
name|MR_ENABLE_PARITY_CHECKING
expr_stmt|;
name|z
operator|->
name|scsi_addr
operator|=
name|HOST_SCSI_ADDR
expr_stmt|;
name|z
operator|->
name|scsi_id
operator|=
literal|1
operator|<<
name|z
operator|->
name|scsi_addr
expr_stmt|;
name|z
operator|->
name|irq
operator|=
name|dev
operator|->
name|id_irq
condition|?
name|ffs
argument_list|(
name|dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|z
operator|->
name|queue
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|disconnected_queue
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|z
operator|->
name|target
index|[
name|i
index|]
operator|.
name|busy
operator|=
literal|0
expr_stmt|;
comment|/* Link up the free list of scbs */
name|z
operator|->
name|numscb
operator|=
name|SCB_TABLE_SIZE
expr_stmt|;
name|z
operator|->
name|free_scb
operator|=
name|z
operator|->
name|scbs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|SCB_TABLE_SIZE
condition|;
name|i
operator|++
control|)
name|z
operator|->
name|scbs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|z
operator|->
name|scbs
operator|+
name|i
expr_stmt|;
name|z
operator|->
name|scbs
index|[
name|SCB_TABLE_SIZE
operator|-
literal|1
index|]
operator|.
name|next
operator|=
literal|0
expr_stmt|;
comment|/* Try NCR 5380. */
name|z
operator|->
name|type
operator|=
name|CTLR_NCR_5380
expr_stmt|;
name|z
operator|->
name|name
operator|=
literal|"NCR-5380"
expr_stmt|;
name|z
operator|->
name|ODR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C80_ODR
expr_stmt|;
name|z
operator|->
name|CSDR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C80_CSDR
expr_stmt|;
name|z
operator|->
name|ICR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C80_ICR
expr_stmt|;
name|z
operator|->
name|MR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C80_MR
expr_stmt|;
name|z
operator|->
name|TCR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C80_TCR
expr_stmt|;
name|z
operator|->
name|SER
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C80_SER
expr_stmt|;
name|z
operator|->
name|CSBR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C80_CSBR
expr_stmt|;
name|z
operator|->
name|BSR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C80_BSR
expr_stmt|;
name|z
operator|->
name|SDSR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C80_SDSR
expr_stmt|;
name|z
operator|->
name|SDIR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C80_SDIR
expr_stmt|;
name|z
operator|->
name|RPIR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C80_RPIR
expr_stmt|;
name|z
operator|->
name|CSR
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|CCR
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|HBR
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|PDATA
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|PSTAT
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nca_init
argument_list|(
name|z
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|8
operator|)
return|;
comment|/* Try NCR 53C400. */
name|z
operator|->
name|type
operator|=
name|CTLR_NCR_53C400
expr_stmt|;
name|z
operator|->
name|name
operator|=
literal|"NCR-53C400"
expr_stmt|;
name|z
operator|->
name|ODR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_5380_REG_OFFSET
operator|+
name|C80_ODR
expr_stmt|;
name|z
operator|->
name|CSDR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_5380_REG_OFFSET
operator|+
name|C80_CSDR
expr_stmt|;
name|z
operator|->
name|ICR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_5380_REG_OFFSET
operator|+
name|C80_ICR
expr_stmt|;
name|z
operator|->
name|MR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_5380_REG_OFFSET
operator|+
name|C80_MR
expr_stmt|;
name|z
operator|->
name|TCR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_5380_REG_OFFSET
operator|+
name|C80_TCR
expr_stmt|;
name|z
operator|->
name|SER
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_5380_REG_OFFSET
operator|+
name|C80_SER
expr_stmt|;
name|z
operator|->
name|CSBR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_5380_REG_OFFSET
operator|+
name|C80_CSBR
expr_stmt|;
name|z
operator|->
name|BSR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_5380_REG_OFFSET
operator|+
name|C80_BSR
expr_stmt|;
name|z
operator|->
name|SDSR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_5380_REG_OFFSET
operator|+
name|C80_SDSR
expr_stmt|;
name|z
operator|->
name|SDIR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_5380_REG_OFFSET
operator|+
name|C80_SDIR
expr_stmt|;
name|z
operator|->
name|RPIR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_5380_REG_OFFSET
operator|+
name|C80_RPIR
expr_stmt|;
name|z
operator|->
name|CSR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_CSR
expr_stmt|;
name|z
operator|->
name|CCR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_CCR
expr_stmt|;
name|z
operator|->
name|HBR
operator|=
name|dev
operator|->
name|id_iobase
operator|+
name|C400_HBR
expr_stmt|;
name|z
operator|->
name|PDATA
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|PSTAT
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nca_init
argument_list|(
name|z
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|16
operator|)
return|;
comment|/* Try ProAudioSpectrum-16. */
name|z
operator|->
name|type
operator|=
name|CTLR_PAS_16
expr_stmt|;
name|z
operator|->
name|name
operator|=
literal|"ProAudioSpectrum"
expr_stmt|;
comment|/* changed later */
name|z
operator|->
name|ODR
operator|=
name|dev
operator|->
name|id_iobase
operator|^
name|PAS16_REG
argument_list|(
name|C80_ODR
argument_list|)
expr_stmt|;
name|z
operator|->
name|CSDR
operator|=
name|dev
operator|->
name|id_iobase
operator|^
name|PAS16_REG
argument_list|(
name|C80_CSDR
argument_list|)
expr_stmt|;
name|z
operator|->
name|ICR
operator|=
name|dev
operator|->
name|id_iobase
operator|^
name|PAS16_REG
argument_list|(
name|C80_ICR
argument_list|)
expr_stmt|;
name|z
operator|->
name|MR
operator|=
name|dev
operator|->
name|id_iobase
operator|^
name|PAS16_REG
argument_list|(
name|C80_MR
argument_list|)
expr_stmt|;
name|z
operator|->
name|TCR
operator|=
name|dev
operator|->
name|id_iobase
operator|^
name|PAS16_REG
argument_list|(
name|C80_TCR
argument_list|)
expr_stmt|;
name|z
operator|->
name|SER
operator|=
name|dev
operator|->
name|id_iobase
operator|^
name|PAS16_REG
argument_list|(
name|C80_SER
argument_list|)
expr_stmt|;
name|z
operator|->
name|CSBR
operator|=
name|dev
operator|->
name|id_iobase
operator|^
name|PAS16_REG
argument_list|(
name|C80_CSBR
argument_list|)
expr_stmt|;
name|z
operator|->
name|BSR
operator|=
name|dev
operator|->
name|id_iobase
operator|^
name|PAS16_REG
argument_list|(
name|C80_BSR
argument_list|)
expr_stmt|;
name|z
operator|->
name|SDSR
operator|=
name|dev
operator|->
name|id_iobase
operator|^
name|PAS16_REG
argument_list|(
name|C80_SDSR
argument_list|)
expr_stmt|;
name|z
operator|->
name|SDIR
operator|=
name|dev
operator|->
name|id_iobase
operator|^
name|PAS16_REG
argument_list|(
name|C80_SDIR
argument_list|)
expr_stmt|;
name|z
operator|->
name|RPIR
operator|=
name|dev
operator|->
name|id_iobase
operator|^
name|PAS16_REG
argument_list|(
name|C80_RPIR
argument_list|)
expr_stmt|;
name|z
operator|->
name|CSR
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|CCR
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|HBR
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|PDATA
operator|=
name|dev
operator|->
name|id_iobase
operator|^
name|PAS16_REG
argument_list|(
name|PAS16_DATA
argument_list|)
expr_stmt|;
name|z
operator|->
name|PSTAT
operator|=
name|dev
operator|->
name|id_iobase
operator|^
name|PAS16_REG
argument_list|(
name|PAS16_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nca_init
argument_list|(
name|z
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|4
operator|)
return|;
name|bzero
argument_list|(
name|z
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe the adapter, and if found, reset the board and the scsi bus.  * Return 0 if the adapter found.  */
end_comment

begin_function
name|int
name|nca_init
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|CTLR_NCR_53C400
condition|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|z
operator|->
name|CSR
argument_list|)
operator|==
literal|0xFF
condition|)
return|return
operator|(
literal|100
operator|)
return|;
comment|/* Reset 53C400. */
name|outb
argument_list|(
name|z
operator|->
name|CSR
argument_list|,
name|CSR_5380_ENABLE
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|outb
argument_list|(
name|z
operator|->
name|CSR
argument_list|,
name|z
operator|->
name|irq
condition|?
name|CSR_5380_INTR
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|CTLR_PAS_16
condition|)
block|{
name|u_short
name|base
init|=
name|z
operator|->
name|PDATA
operator|&
literal|0x3FF
decl_stmt|;
name|outb
argument_list|(
literal|0x9a01
argument_list|,
literal|0xbc
operator|+
operator|(
name|z
operator|-
name|ncadata
operator|)
argument_list|)
expr_stmt|;
comment|/* unit number */
name|outb
argument_list|(
literal|0x9a01
argument_list|,
name|base
operator|>>
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|base
operator|^
literal|0x803
argument_list|)
operator|==
literal|0xFF
condition|)
return|return
operator|(
literal|200
operator|)
return|;
if|if
condition|(
name|inb
argument_list|(
name|z
operator|->
name|CSDR
argument_list|)
operator|==
literal|0xFF
operator|&&
name|inb
argument_list|(
name|z
operator|->
name|CSDR
operator|^
literal|0x2000
argument_list|)
operator|==
literal|0xFF
operator|&&
name|inb
argument_list|(
name|z
operator|->
name|CSDR
argument_list|)
operator|==
literal|0xFF
operator|&&
name|inb
argument_list|(
name|z
operator|->
name|CSDR
operator|^
literal|0x2000
argument_list|)
operator|==
literal|0xFF
operator|&&
name|inb
argument_list|(
name|z
operator|->
name|CSDR
argument_list|)
operator|==
literal|0xFF
operator|&&
name|inb
argument_list|(
name|z
operator|->
name|CSDR
operator|^
literal|0x2000
argument_list|)
operator|==
literal|0xFF
operator|&&
name|inb
argument_list|(
name|z
operator|->
name|CSDR
argument_list|)
operator|==
literal|0xFF
operator|&&
name|inb
argument_list|(
name|z
operator|->
name|CSDR
operator|^
literal|0x2000
argument_list|)
operator|==
literal|0xFF
condition|)
return|return
operator|(
literal|201
operator|)
return|;
name|i
operator|=
name|inb
argument_list|(
name|base
operator|^
literal|0x803
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|^
literal|0x803
argument_list|,
name|i
operator|^
literal|0xE0
argument_list|)
expr_stmt|;
name|c
operator|=
name|inb
argument_list|(
name|base
operator|^
literal|0x803
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|^
literal|0x803
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|c
condition|)
return|return
operator|(
literal|202
operator|)
return|;
comment|/* Various magic. */
name|outb
argument_list|(
name|base
operator|^
literal|0x4000
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/* Timeout counter */
name|outb
argument_list|(
name|base
operator|^
literal|0x4001
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Reset TC */
name|outb
argument_list|(
name|base
operator|^
literal|0xbc00
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* 1 Wait state */
name|outb
argument_list|(
name|base
operator|^
literal|0x8003
argument_list|,
literal|0x4d
argument_list|)
expr_stmt|;
comment|/* sysconfig_4 */
name|i
operator|=
name|pas16_irq_magic
index|[
name|z
operator|->
name|irq
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|z
operator|->
name|irq
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|base
operator|^
literal|0xf002
argument_list|,
name|i
operator|<<
literal|4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|^
literal|0x8003
argument_list|,
literal|0x6d
argument_list|)
expr_stmt|;
comment|/* sysconfig_4 */
block|}
switch|switch
condition|(
name|inb
argument_list|(
name|base
operator|^
literal|0xEC03
argument_list|)
operator|&
literal|0xF
condition|)
block|{
case|case
literal|6
case|:
name|z
operator|->
name|name
operator|=
literal|"ProAudioSpectrum-Plus"
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|z
operator|->
name|name
operator|=
literal|"ProAudioSpectrum-16D"
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|z
operator|->
name|name
operator|=
literal|"ProAudioSpectrum-CDPC"
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|z
operator|->
name|name
operator|=
literal|"ProAudioSpectrum-16"
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|203
operator|)
return|;
block|}
block|}
comment|/* Read RPI port, resetting parity/interrupt state. */
name|inb
argument_list|(
name|z
operator|->
name|RPIR
argument_list|)
expr_stmt|;
comment|/* Test BSR: parity error, interrupt request and busy loss state 	 * should be cleared. */
if|if
condition|(
name|inb
argument_list|(
name|z
operator|->
name|BSR
argument_list|)
operator|&
operator|(
name|BSR_PARITY_ERROR
operator||
name|BSR_INTERRUPT_REQUEST_ACTIVE
operator||
name|BSR_BUSY_ERROR
operator|)
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"nca: invalid bsr[0x%x]=%b\n"
operator|,
name|z
operator|->
name|BSR
operator|,
name|inb
argument_list|(
name|z
operator|->
name|BSR
argument_list|)
operator|,
name|BSR_BITS
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Reset the SCSI bus. */
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_RST
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ODR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Hold reset for at least 25 microseconds. */
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
comment|/* Check that status cleared. */
if|if
condition|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|!=
name|CSBR_RST
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"nca: invalid csbr[0x%x]=%b\n"
operator|,
name|z
operator|->
name|CSBR
operator|,
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|,
name|CSBR_BITS
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
comment|/* Clear reset. */
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait a Bus Clear Delay (800 ns + bus free delay 800 ns). */
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable data drivers. */
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_DATA_BUS
argument_list|)
expr_stmt|;
comment|/* Check that data register is writable. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
name|outb
argument_list|(
name|z
operator|->
name|ODR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|z
operator|->
name|CSDR
argument_list|)
operator|!=
name|i
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"nca: ODR[0x%x] not writable: 0x%x should be 0x%x\n"
operator|,
name|z
operator|->
name|ODR
operator|,
name|inb
argument_list|(
name|z
operator|->
name|CSDR
argument_list|)
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|3
operator|)
return|;
block|}
block|}
comment|/* Disable data drivers. */
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check that data register is NOT writable. */
name|c
operator|=
name|inb
argument_list|(
name|z
operator|->
name|CSDR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
name|outb
argument_list|(
name|z
operator|->
name|ODR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|z
operator|->
name|CSDR
argument_list|)
operator|!=
name|c
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"nca: ODR[0x%x] writable: 0x%x should be 0x%x\n"
operator|,
name|z
operator|->
name|ODR
operator|,
name|inb
argument_list|(
name|z
operator|->
name|CSDR
argument_list|)
operator|,
name|c
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|4
operator|)
return|;
block|}
block|}
comment|/* Initialize the controller. */
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
name|z
operator|->
name|parity
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|TCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|SER
argument_list|,
name|z
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach all sub-devices we can find.  */
end_comment

begin_function
name|int
name|nca_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|adapter_t
modifier|*
name|z
init|=
operator|&
name|ncadata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
name|sprintf
argument_list|(
name|nca_description
argument_list|,
literal|"%s SCSI controller"
argument_list|,
name|z
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"nca%d: type %s%s\n"
argument_list|,
name|unit
argument_list|,
name|z
operator|->
name|name
argument_list|,
operator|(
name|dev
operator|->
name|id_flags
operator|&
name|FLAG_NOPARITY
operator|)
condition|?
literal|", no parity"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* fill in the prototype scsi_link */
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|unit
expr_stmt|;
name|z
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|z
operator|->
name|scsi_addr
expr_stmt|;
name|z
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|nca_switch
expr_stmt|;
name|z
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|nca_dev
expr_stmt|;
comment|/* 	 * Prepare the scsibus_data area for the upperlevel 	 * scsi code. 	 */
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|z
operator|->
name|sc_link
expr_stmt|;
comment|/* ask the adapter what subunits are present */
name|nca_kdc
index|[
name|unit
index|]
operator|.
name|kdc_state
operator|=
name|DC_BUSY
expr_stmt|;
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return some information to the caller about  * the adapter and its capabilities.  */
end_comment

begin_function
name|u_int32
name|nca_adapter_info
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ncaminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Catch an interrupt from the adaptor.  */
end_comment

begin_function
name|void
name|ncaintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|adapter_t
modifier|*
name|z
init|=
operator|&
name|ncadata
index|[
name|unit
index|]
decl_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"nca%d: interrupt bsr=%b csbr=%b\n"
operator|,
name|unit
operator|,
name|inb
argument_list|(
name|z
operator|->
name|BSR
argument_list|)
operator|,
name|BSR_BITS
operator|,
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|,
name|CSBR_BITS
operator|)
argument_list|)
expr_stmt|;
name|nca_start
argument_list|(
name|z
argument_list|)
expr_stmt|;
comment|/* Reset interrupt state. */
name|inb
argument_list|(
name|z
operator|->
name|RPIR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is used in the case when we have no IRQ line (z->irq == 0).  * It is called every timer tick and polls for reconnect from target.  */
end_comment

begin_function
name|void
name|nca_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|adapter_t
modifier|*
name|z
init|=
name|arg
decl_stmt|;
name|int
name|x
init|=
name|splbio
argument_list|()
decl_stmt|;
name|z
operator|->
name|timeout_active
operator|=
literal|0
expr_stmt|;
name|nca_start
argument_list|(
name|z
argument_list|)
expr_stmt|;
comment|/* Reset interrupt state. */
name|inb
argument_list|(
name|z
operator|->
name|RPIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|disconnected_queue
operator|&&
operator|!
name|z
operator|->
name|timeout_active
condition|)
block|{
name|timeout
argument_list|(
name|nca_tick
argument_list|,
name|z
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|z
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a scsi operation given the command and the data address.  * Also needs the unit, target and lu.  Get a free scb and set it up.  * Call send_scb.  Either start timer or wait until done.  */
end_comment

begin_function
name|int32
name|nca_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|int
name|unit
init|=
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
decl_stmt|,
name|flags
init|=
name|xs
operator|->
name|flags
decl_stmt|,
name|x
init|=
literal|0
decl_stmt|;
name|adapter_t
modifier|*
name|z
init|=
operator|&
name|ncadata
index|[
name|unit
index|]
decl_stmt|;
name|scb_t
modifier|*
name|scb
decl_stmt|;
comment|/* PRINT (("nca%d/%d/%d command 0x%x\n", unit, xs->sc_link->target, 		xs->sc_link->lun, xs->cmd->opcode)); */
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
name|flags
operator||=
name|SCSI_NOSLEEP
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"nca%d: already done?"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"nca%d: not in use?"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
name|printf
argument_list|(
literal|"nca%d: SCSI_RESET not implemented\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* Get a free scb. 	 * If we can and have to, sleep waiting for one to come free. */
while|while
condition|(
operator|!
operator|(
name|scb
operator|=
name|z
operator|->
name|free_scb
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|SCSI_NOSLEEP
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|z
operator|->
name|free_scb
argument_list|,
name|PRIBIO
argument_list|,
literal|"ncascb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Get scb from free list. */
name|z
operator|->
name|free_scb
operator|=
name|scb
operator|->
name|next
expr_stmt|;
name|scb
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
comment|/* Put all the arguments for the xfer in the scb */
name|scb
operator|->
name|xfer
operator|=
name|xs
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|scb
operator|->
name|data
operator|=
name|xs
operator|->
name|data
expr_stmt|;
comment|/* Setup the scb to contain necessary values. 	 * The interesting values can be read from the xs that is saved. 	 * I therefore think that the structure can be kept very small. 	 * The driver doesn't use DMA so the scatter/gather is not needed? */
if|if
condition|(
operator|!
name|z
operator|->
name|queue
condition|)
block|{
name|scb
operator|->
name|next
operator|=
name|z
operator|->
name|queue
expr_stmt|;
name|z
operator|->
name|queue
operator|=
name|scb
expr_stmt|;
block|}
else|else
block|{
name|scb_t
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|z
operator|->
name|queue
init|;
name|q
operator|->
name|next
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
continue|continue;
name|q
operator|->
name|next
operator|=
name|scb
expr_stmt|;
name|scb
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* placed at the end of the queue */
block|}
comment|/* Try to send this command to the board. */
name|nca_start
argument_list|(
name|z
argument_list|)
expr_stmt|;
comment|/* Usually return SUCCESSFULLY QUEUED. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
comment|/* Timeout timer not started, already finished. 			 * Tried to return COMPLETE but the machine hanged 			 * with this. */
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
name|timeout
argument_list|(
name|nca_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMECHK
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"nca%d/%d/%d command queued\n"
operator|,
name|unit
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
comment|/* If we can't use interrupts, poll on completion. */
if|if
condition|(
operator|!
name|nca_poll
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
condition|)
block|{
comment|/* We timed out, so call the timeout handler manually, 		 * accounting for the fact that the clock is not running yet 		 * by taking out the clock queue entry it makes. */
name|nca_timeout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|scb
argument_list|)
expr_stmt|;
comment|/* Because we are polling, take out the timeout entry 		 * nca_timeout made. */
name|untimeout
argument_list|(
name|nca_timeout
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nca_poll
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
condition|)
comment|/* We timed out again... This is bad. Notice that 			 * this time there is no clock queue entry to remove. */
name|nca_timeout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|scb
argument_list|)
expr_stmt|;
block|}
comment|/* PRINT (("nca%d/%d/%d command %s\n", unit, 		xs->sc_link->target, xs->sc_link->lun, 		xs->error ? "failed" : "done")); */
return|return
operator|(
name|xs
operator|->
name|error
condition|?
name|HAD_ERROR
else|:
name|COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Coroutine that runs as long as more work can be done.  * Both scsi_cmd() and intr() will try to start it in  * case it is not running.  * Always called with interrupts disabled.  */
end_comment

begin_function
name|void
name|nca_start
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
block|{
name|scb_t
modifier|*
name|q
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|again
label|:
comment|/* First check that if any device has tried 	 * a reconnect while we have done other things 	 * with interrupts disabled. */
if|if
condition|(
name|nca_reselect
argument_list|(
name|z
argument_list|)
condition|)
goto|goto
name|again
goto|;
comment|/* Search through the queue for a command 	 * destined for a target that's not busy. */
for|for
control|(
name|q
operator|=
name|z
operator|->
name|queue
operator|,
name|prev
operator|=
literal|0
init|;
name|q
condition|;
name|prev
operator|=
name|q
operator|,
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
comment|/* Attempt to establish an I_T_L nexus here. */
if|if
condition|(
name|IS_BUSY
argument_list|(
name|z
argument_list|,
name|q
argument_list|)
operator|||
operator|!
name|nca_select
argument_list|(
name|z
argument_list|,
name|q
argument_list|)
condition|)
continue|continue;
comment|/* Remove the command from the issue queue. */
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
else|else
name|z
operator|->
name|queue
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* We are connected. Do the task. */
name|nca_information_transfer
argument_list|(
name|z
argument_list|,
name|q
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
end_function

begin_function
name|void
name|nca_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|scb_t
modifier|*
name|scb
init|=
operator|(
name|scb_t
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|unit
init|=
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|adapter_unit
decl_stmt|;
name|adapter_t
modifier|*
name|z
init|=
operator|&
name|ncadata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|x
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|xfer
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|printf
argument_list|(
literal|"nca%d/%d/%d (%s%d) timed out\n"
argument_list|,
name|unit
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|dev_unit
argument_list|)
expr_stmt|;
comment|/* If it has been through before, then a previous abort has failed, 	 * don't try abort again. */
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORTED
operator|)
condition|)
block|{
name|nca_abort
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 2 seconds for the abort */
name|timeout
argument_list|(
name|nca_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
operator|(
name|SCB_ABORTED
operator||
name|SCB_TIMECHK
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort timed out */
name|scb
operator|->
name|flags
operator||=
name|SCB_ABORTED
expr_stmt|;
name|scb
operator|->
name|xfer
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
name|nca_done
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|nca_sendbyte
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|u_char
name|data
parameter_list|)
block|{
name|outb
argument_list|(
name|z
operator|->
name|ODR
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_DATA_BUS
operator||
name|ICR_ASSERT_ACK
argument_list|)
expr_stmt|;
name|WAITFOR
argument_list|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
operator|)
argument_list|,
literal|10000
argument_list|,
literal|"sendbyte"
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_DATA_BUS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u_char
name|nca_recvbyte
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
block|{
name|u_char
name|data
decl_stmt|;
name|data
operator|=
name|inb
argument_list|(
name|z
operator|->
name|CSDR
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_ACK
argument_list|)
expr_stmt|;
name|WAITFOR
argument_list|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
operator|)
argument_list|,
literal|10000
argument_list|,
literal|"recvbyte"
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Establish I_T_L or I_T_L_Q nexus for new or existing command  * including ARBITRATION, SELECTION, and initial message out  * for IDENTIFY and queue messages.  * Return 1 if selection succeded.  */
end_comment

begin_function
name|int
name|nca_select
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
block|{
comment|/* Set the phase bits to 0, otherwise the NCR5380 won't drive the 	 * data bus during SELECTION. */
name|outb
argument_list|(
name|z
operator|->
name|TCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Start arbitration. */
name|outb
argument_list|(
name|z
operator|->
name|ODR
argument_list|,
name|z
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
name|MR_ARBITRATE
argument_list|)
expr_stmt|;
comment|/* Wait for arbitration logic to complete (20 usec) */
name|WAITFOR
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|ICR
argument_list|)
operator|&
name|ICR_ARBITRATION_IN_PROGRESS
argument_list|,
literal|200
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|ICR
argument_list|)
operator|&
name|ICR_ARBITRATION_IN_PROGRESS
operator|)
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"nca%d/%d/%d no arbitration progress, bsr=%b csbr=%b\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|inb
argument_list|(
name|z
operator|->
name|BSR
argument_list|)
operator|,
name|BSR_BITS
operator|,
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|,
name|CSBR_BITS
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
name|z
operator|->
name|parity
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|/* Check for lost arbitration. */
if|if
condition|(
operator|(
name|inb
argument_list|(
name|z
operator|->
name|ICR
argument_list|)
operator|&
name|ICR_LOST_ARBITRATION
operator|)
operator|||
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSDR
argument_list|)
operator|>>
literal|1
operator|>>
name|z
operator|->
name|scsi_addr
operator|)
operator|||
operator|(
name|inb
argument_list|(
name|z
operator|->
name|ICR
argument_list|)
operator|&
name|ICR_LOST_ARBITRATION
operator|)
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"nca%d/%d/%d arbitration lost\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
name|z
operator|->
name|parity
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_SEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|z
operator|->
name|ICR
argument_list|)
operator|&
name|ICR_LOST_ARBITRATION
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"nca%d/%d/%d arbitration lost after SEL\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
name|z
operator|->
name|parity
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Start selection, asserting the host and target ID's on the bus. */
name|outb
argument_list|(
name|z
operator|->
name|SER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ODR
argument_list|,
name|z
operator|->
name|scsi_id
operator||
operator|(
literal|1
operator|<<
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_DATA_BUS
operator||
name|ICR_ASSERT_BSY
operator||
name|ICR_ASSERT_SEL
argument_list|)
expr_stmt|;
comment|/* Finish arbitration, drop BSY. */
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_DATA_BUS
operator||
name|ICR_ASSERT_SEL
operator||
name|ICR_ASSERT_ATN
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* The SCSI specification calls for a 250 ms timeout for the actual 	 * selection. */
name|WAITFOR
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_BSY
argument_list|,
literal|100000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_BSY
operator|)
condition|)
block|{
comment|/* The target does not respond.  Not an error, though. */
name|PRINT
argument_list|(
operator|(
literal|"nca%d/%d/%d target does not respond\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|SER
argument_list|,
name|z
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
name|z
operator|->
name|parity
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMEOUT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Clear SEL and SCSI id. 	 * Wait for start of REQ/ACK handshake. */
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_DATA_BUS
operator||
name|ICR_ASSERT_ATN
argument_list|)
expr_stmt|;
name|WAITFOR
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
argument_list|,
literal|100000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
operator|)
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"nca%d/%d/%d timeout waiting for REQ\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|SER
argument_list|,
name|z
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
name|z
operator|->
name|parity
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check for phase mismatch. */
if|if
condition|(
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_MSGOUT
condition|)
block|{
comment|/* This should not be taken as an error, but more like 		 * an unsupported feature! 		 * Should set a flag indicating that the target don't support 		 * messages, and continue without failure. 		 * (THIS IS NOT AN ERROR!) */
name|PRINT
argument_list|(
operator|(
literal|"nca%d/%d/%d waiting for MSGOUT: invalid phase %s\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|PHASE_NAME
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|PHASE_MASK
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|SER
argument_list|,
name|z
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
name|z
operator|->
name|parity
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ERROR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Allow disconnects. */
name|outb
argument_list|(
name|z
operator|->
name|TCR
argument_list|,
name|PHASE_TO_TCR
argument_list|(
name|PHASE_MSGOUT
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_DATA_BUS
argument_list|)
expr_stmt|;
name|nca_sendbyte
argument_list|(
name|z
argument_list|,
name|MSG_IDENTIFY
argument_list|(
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|SER
argument_list|,
name|z
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
name|z
operator|->
name|parity
argument_list|)
expr_stmt|;
name|SET_BUSY
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nca_reselect
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
block|{
name|scb_t
modifier|*
name|q
init|=
literal|0
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|u_char
name|msg
decl_stmt|,
name|target_mask
decl_stmt|,
name|lun
decl_stmt|;
name|again
label|:
comment|/* Wait for a device to win the reselection phase. */
comment|/* Signals this by asserting the I/O signal. */
if|if
condition|(
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
operator|(
name|CSBR_SEL
operator||
name|CSBR_IO
operator||
name|CSBR_BSY
operator|)
operator|)
operator|!=
operator|(
name|CSBR_SEL
operator||
name|CSBR_IO
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The data bus contains original initiator id ORed with target id. */
comment|/* See that we really are the initiator. */
name|target_mask
operator|=
name|inb
argument_list|(
name|z
operator|->
name|CSDR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|target_mask
operator|&
name|z
operator|->
name|scsi_id
operator|)
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"nca%d reselect not for me: mask=0x%x, csbr=%b\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|target_mask
operator|,
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|,
name|CSBR_BITS
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* Find target who won. */
comment|/* Host responds by asserting the BSY signal. */
comment|/* Target should respond by deasserting the SEL signal. */
name|target_mask
operator|&=
operator|~
name|z
operator|->
name|scsi_id
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_BSY
argument_list|)
expr_stmt|;
name|WAITFOR
argument_list|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_SEL
operator|)
argument_list|,
literal|10000
argument_list|,
literal|"SEL deassert"
argument_list|)
expr_stmt|;
comment|/* Remove the busy status. */
comment|/* Target should set the MSGIN phase. */
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|WAITFOR
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
argument_list|,
literal|10000
argument_list|,
literal|"MSGIN"
argument_list|)
expr_stmt|;
comment|/* Hope we get an IDENTIFY message. */
name|msg
operator|=
name|nca_msg_input
argument_list|(
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|MSG_ISIDENT
argument_list|(
name|msg
argument_list|)
condition|)
block|{
comment|/* Find the command corresponding to the I_T_L or I_T_L_Q 		 * nexus we just restablished, and remove it from 		 * the disconnected queue. */
name|lun
operator|=
operator|(
name|msg
operator|&
literal|7
operator|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|z
operator|->
name|disconnected_queue
init|;
name|q
condition|;
name|prev
operator|=
name|q
operator|,
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|target_mask
operator|!=
operator|(
literal|1
operator|<<
name|q
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|)
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|!=
name|q
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
condition|)
continue|continue;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
else|else
name|z
operator|->
name|disconnected_queue
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"nca%d/%d/%d reselect done\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|ffs
argument_list|(
name|target_mask
argument_list|)
operator|-
literal|1
operator|,
name|lun
operator|)
argument_list|)
expr_stmt|;
name|nca_information_transfer
argument_list|(
name|z
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|WAITFOR
argument_list|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_BSY
operator|)
argument_list|,
literal|100000
argument_list|,
literal|"reselect !busy"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"nca%d reselect: expecting IDENTIFY, got 0x%x\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* Since we have an established nexus that we can't 	 * do anything with, we must abort it. */
name|nca_send_abort
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"nca%d reselect aborted\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|)
argument_list|)
expr_stmt|;
name|WAITFOR
argument_list|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_BSY
operator|)
argument_list|,
literal|100000
argument_list|,
literal|"reselect abort !busy"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_function

begin_comment
comment|/*  * Send an abort to the target.  * Return 1 success, 0 on failure.  * Called on splbio level.  */
end_comment

begin_function
name|int
name|nca_abort
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
block|{
name|scb_t
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
comment|/* If the command hasn't been issued yet, we simply remove it 	 * from the issue queue. */
name|prev
operator|=
operator|&
name|z
operator|->
name|queue
expr_stmt|;
for|for
control|(
name|q
operator|=
name|z
operator|->
name|queue
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|scb
operator|==
name|q
condition|)
block|{
operator|(
operator|*
name|prev
operator|)
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|next
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|prev
operator|=
operator|&
name|q
operator|->
name|next
expr_stmt|;
block|}
comment|/* If the command is currently disconnected from the bus, 	 * we reconnect the I_T_L or I_T_L_Q nexus associated with it, 	 * go into message out, and send an abort message. */
for|for
control|(
name|q
operator|=
name|z
operator|->
name|disconnected_queue
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|scb
operator|!=
name|q
condition|)
continue|continue;
if|if
condition|(
operator|!
name|nca_select
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|nca_send_abort
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|&
name|z
operator|->
name|disconnected_queue
expr_stmt|;
for|for
control|(
name|q
operator|=
name|z
operator|->
name|disconnected_queue
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|scb
operator|==
name|q
condition|)
block|{
operator|*
name|prev
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* Set some type of error result 				 * for the operation. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|prev
operator|=
operator|&
name|q
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Command not found in any queue. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The task accomplished, mark the i/o control block as done.  * Always called with interrupts disabled.  */
end_comment

begin_function
name|void
name|nca_done
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|scb
operator|->
name|xfer
decl_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TIMECHK
condition|)
name|untimeout
argument_list|(
name|nca_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
comment|/* How much of the buffer was not touched. */
name|xs
operator|->
name|resid
operator|=
name|scb
operator|->
name|datalen
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|!=
name|SCB_ACTIVE
operator|&&
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
condition|)
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
operator|(
name|SCB_TIMEOUT
operator||
name|SCB_ABORTED
operator|)
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ERROR
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TBUSY
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
comment|/* Free the control block. */
name|scb
operator|->
name|next
operator|=
name|z
operator|->
name|free_scb
expr_stmt|;
name|z
operator|->
name|free_scb
operator|=
name|scb
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_FREE
expr_stmt|;
comment|/* If there were none, wake anybody waiting for one to come free, 	 * starting with queued entries. */
if|if
condition|(
operator|!
name|scb
operator|->
name|next
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|z
operator|->
name|free_scb
argument_list|)
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for completion of command in polled mode.  * Always called with interrupts masked out.  */
end_comment

begin_function
name|int
name|nca_poll
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|30
condition|;
operator|++
name|count
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* delay for a while */
name|nca_start
argument_list|(
name|z
argument_list|)
expr_stmt|;
comment|/* retry operation */
if|if
condition|(
name|scb
operator|->
name|xfer
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* all is done */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TIMEOUT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no target present */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform NCR-53C400 pseudo-dma data transfer.  */
end_comment

begin_function
name|void
name|nca_53400_dma_xfer
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|int
name|read
parameter_list|,
name|u_char
modifier|*
modifier|*
name|pdata
parameter_list|,
name|u_long
modifier|*
name|plen
parameter_list|)
block|{
comment|/* Set dma direction. */
name|outb
argument_list|(
name|z
operator|->
name|CSR
argument_list|,
name|read
condition|?
name|CSR_TRANSFER_DIRECTION
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable dma mode. */
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
name|MR_DMA_MODE
operator||
operator|(
name|read
condition|?
name|z
operator|->
name|parity
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Start dma transfer. */
name|outb
argument_list|(
name|read
condition|?
name|z
operator|->
name|SDIR
else|:
name|z
operator|->
name|SDSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up clock counter. */
name|outb
argument_list|(
name|z
operator|->
name|CCR
argument_list|,
operator|*
name|plen
operator|/
literal|128
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|plen
operator|>=
literal|128
condition|;
operator|*
name|plen
operator|-=
literal|128
operator|,
operator|*
name|pdata
operator|+=
literal|128
control|)
block|{
comment|/* Wait for 53C400 host buffer ready. */
name|WAITFOR
argument_list|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSR
argument_list|)
operator|&
name|CSR_HOST_BUF_NOT_READY
operator|)
argument_list|,
literal|100000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|z
operator|->
name|CSR
argument_list|)
operator|&
name|CSR_HOST_BUF_NOT_READY
condition|)
break|break;
comment|/* Transfer 128 bytes of data. */
if|if
condition|(
name|read
condition|)
name|insw
argument_list|(
name|z
operator|->
name|HBR
argument_list|,
operator|*
name|pdata
argument_list|,
literal|64
argument_list|)
expr_stmt|;
else|else
name|outsw
argument_list|(
name|z
operator|->
name|HBR
argument_list|,
operator|*
name|pdata
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
comment|/* Wait for 5380 registers ready. */
name|WAITFOR
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|CSR
argument_list|)
operator|&
name|CSR_5380_ENABLE
argument_list|,
literal|10000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSR
argument_list|)
operator|&
name|CSR_5380_ENABLE
operator|)
condition|)
block|{
comment|/* Reset 53C400. */
name|PRINT
argument_list|(
operator|(
literal|"nca%d: reset: pseudo-dma incomplete, csr=%b\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|inb
argument_list|(
name|z
operator|->
name|CSR
argument_list|)
operator|,
name|CSR_BITS
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|CSR
argument_list|,
name|CSR_5380_ENABLE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|CSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Wait for FIFO flush on write. */
if|if
condition|(
operator|!
name|read
condition|)
name|WAITFOR
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|TCR
argument_list|)
operator|&
name|TCR_LAST_BYTE_SENT
argument_list|,
literal|10000
argument_list|,
literal|"last byte"
argument_list|)
expr_stmt|;
comment|/* Clear dma mode. */
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
name|z
operator|->
name|parity
argument_list|)
expr_stmt|;
comment|/* Re-enable interrupts. */
name|outb
argument_list|(
name|z
operator|->
name|CSR
argument_list|,
name|z
operator|->
name|irq
condition|?
name|CSR_5380_INTR
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform PAS-16 pseudo-dma data transfer.  */
end_comment

begin_function
name|void
name|nca_pas_dma_xfer
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|int
name|read
parameter_list|,
name|u_char
modifier|*
modifier|*
name|pdata
parameter_list|,
name|u_long
modifier|*
name|plen
parameter_list|)
block|{
comment|/* Enable dma mode. */
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
name|MR_DMA_MODE
operator||
operator|(
name|read
condition|?
name|z
operator|->
name|parity
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Start dma transfer. */
name|outb
argument_list|(
name|read
condition|?
name|z
operator|->
name|SDIR
else|:
name|z
operator|->
name|SDSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|plen
operator|>=
literal|512
condition|;
operator|*
name|plen
operator|-=
literal|512
operator|,
operator|*
name|pdata
operator|+=
literal|512
control|)
block|{
comment|/* Wait for pseudo-DMA request. */
name|WAITFOR
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|PSTAT
argument_list|)
operator|&
name|PAS16_STAT_DREQ
argument_list|,
literal|10000
argument_list|,
literal|"pseudo-dma"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|PSTAT
argument_list|)
operator|&
name|PAS16_STAT_DREQ
operator|)
condition|)
break|break;
comment|/* Transfer 512 bytes of data. */
if|if
condition|(
name|read
condition|)
name|insb
argument_list|(
name|z
operator|->
name|PDATA
argument_list|,
operator|*
name|pdata
argument_list|,
literal|512
argument_list|)
expr_stmt|;
else|else
name|outsb
argument_list|(
name|z
operator|->
name|PDATA
argument_list|,
operator|*
name|pdata
argument_list|,
literal|512
argument_list|)
expr_stmt|;
block|}
comment|/* Clear dma mode. */
name|outb
argument_list|(
name|z
operator|->
name|MR
argument_list|,
name|z
operator|->
name|parity
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send data to the target.  */
end_comment

begin_function
name|void
name|nca_data_output
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|u_char
modifier|*
modifier|*
name|pdata
parameter_list|,
name|u_long
modifier|*
name|plen
parameter_list|)
block|{
name|u_char
modifier|*
name|data
init|=
operator|*
name|pdata
decl_stmt|;
name|u_long
name|len
init|=
operator|*
name|plen
decl_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_DATA_BUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|CTLR_NCR_53C400
operator|&&
name|len
operator|%
literal|128
operator|==
literal|0
condition|)
comment|/* Use NCR-53C400 pseudo-dma for data transfer. */
name|nca_53400_dma_xfer
argument_list|(
name|z
argument_list|,
literal|0
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|CTLR_PAS_16
operator|&&
name|len
operator|%
literal|512
operator|==
literal|0
condition|)
comment|/* Use PAS-16 pseudo-dma for data transfer. */
name|nca_pas_dma_xfer
argument_list|(
name|z
argument_list|,
literal|0
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Check SCSI bus phase. */
name|u_char
name|s
init|=
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|^
operator|(
name|CSBR_BSY
operator||
name|PHASE_DATAOUT
operator|)
decl_stmt|;
if|if
condition|(
name|s
operator|&
operator|(
name|CSBR_BSY
operator||
name|PHASE_MASK
operator|)
condition|)
break|break;
comment|/* Wait for REQ. */
if|if
condition|(
operator|!
operator|(
name|s
operator|&
name|CSBR_REQ
operator|)
condition|)
continue|continue;
comment|/* Output data. */
name|outb
argument_list|(
name|z
operator|->
name|ODR
argument_list|,
operator|*
name|data
operator|++
argument_list|)
expr_stmt|;
comment|/* Assert ACK and wait for REQ deassert, 			 * with irqs disabled. */
name|disable_intr
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_ACK
operator||
name|ICR_ASSERT_DATA_BUS
argument_list|)
expr_stmt|;
name|WAITFOR
argument_list|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
operator|)
argument_list|,
literal|1000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
comment|/* Deassert ACK. */
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_DATA_BUS
argument_list|)
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"nca (DATAOUT) send %ld bytes\n"
operator|,
operator|*
name|plen
operator|-
name|len
operator|)
argument_list|)
expr_stmt|;
operator|*
name|plen
operator|=
name|len
expr_stmt|;
operator|*
name|pdata
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Receive data from the target.  */
end_comment

begin_function
name|void
name|nca_data_input
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|u_char
modifier|*
modifier|*
name|pdata
parameter_list|,
name|u_long
modifier|*
name|plen
parameter_list|)
block|{
name|u_char
modifier|*
name|data
init|=
operator|*
name|pdata
decl_stmt|;
name|u_long
name|len
init|=
operator|*
name|plen
decl_stmt|;
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|CTLR_NCR_53C400
operator|&&
name|len
operator|%
literal|128
operator|==
literal|0
condition|)
comment|/* Use NCR-53C400 pseudo-dma for data transfer. */
name|nca_53400_dma_xfer
argument_list|(
name|z
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|CTLR_PAS_16
operator|&&
name|len
operator|%
literal|512
operator|==
literal|0
condition|)
comment|/* Use PAS-16 pseudo-dma for data transfer. */
name|nca_pas_dma_xfer
argument_list|(
name|z
argument_list|,
literal|1
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Check SCSI bus phase. */
name|u_char
name|s
init|=
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|^
operator|(
name|CSBR_BSY
operator||
name|PHASE_DATAIN
operator|)
decl_stmt|;
if|if
condition|(
name|s
operator|&
operator|(
name|CSBR_BSY
operator||
name|PHASE_MASK
operator|)
condition|)
break|break;
comment|/* Wait for REQ. */
if|if
condition|(
operator|!
operator|(
name|s
operator|&
name|CSBR_REQ
operator|)
condition|)
continue|continue;
comment|/* Input data. */
operator|*
name|data
operator|++
operator|=
name|inb
argument_list|(
name|z
operator|->
name|CSDR
argument_list|)
expr_stmt|;
comment|/* Assert ACK and wait for REQ deassert, 			 * with irqs disabled. */
name|disable_intr
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_ACK
argument_list|)
expr_stmt|;
name|WAITFOR
argument_list|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
operator|)
argument_list|,
literal|1000
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
comment|/* Deassert ACK. */
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
name|PRINT
argument_list|(
operator|(
literal|"nca (DATAIN) got %ld bytes\n"
operator|,
operator|*
name|plen
operator|-
name|len
operator|)
argument_list|)
expr_stmt|;
operator|*
name|plen
operator|=
name|len
expr_stmt|;
operator|*
name|pdata
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send the command to the target.  */
end_comment

begin_function
name|void
name|nca_cmd_output
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|u_char
modifier|*
name|cmd
parameter_list|,
name|int
name|cmdlen
parameter_list|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"nca%d send command (%d bytes) "
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|cmdlen
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_DATA_BUS
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmdlen
condition|)
block|{
comment|/* Check for target disconnect. */
name|u_char
name|sts
init|=
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|CSBR_BSY
operator|)
condition|)
break|break;
comment|/* Check for phase mismatch. */
if|if
condition|(
operator|(
name|sts
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_CMDOUT
condition|)
block|{
name|printf
argument_list|(
literal|"nca: sending command: invalid phase %s\n"
argument_list|,
name|PHASE_NAME
argument_list|(
name|sts
operator|&
name|PHASE_MASK
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Wait for REQ. */
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|CSBR_REQ
operator|)
condition|)
continue|continue;
name|PRINT
argument_list|(
operator|(
literal|"-%x"
operator|,
operator|*
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|nca_sendbyte
argument_list|(
name|z
argument_list|,
operator|*
name|cmd
operator|++
argument_list|)
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
block|}
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send the message to the target.  */
end_comment

begin_function
name|void
name|nca_send_abort
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
block|{
name|u_char
name|sts
decl_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_ATN
argument_list|)
expr_stmt|;
comment|/* Wait for REQ, after which the phase bits will be valid. */
name|WAITFOR
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
argument_list|,
literal|1000000
argument_list|,
literal|"abort message"
argument_list|)
expr_stmt|;
name|sts
operator|=
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|CSBR_REQ
operator|)
condition|)
goto|goto
name|ret
goto|;
comment|/* Check for phase mismatch. */
if|if
condition|(
operator|(
name|sts
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_MSGOUT
condition|)
block|{
name|printf
argument_list|(
literal|"nca: sending MSG_ABORT: invalid phase %s\n"
argument_list|,
name|PHASE_NAME
argument_list|(
name|sts
operator|&
name|PHASE_MASK
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_DATA_BUS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|TCR
argument_list|,
name|PHASE_TO_TCR
argument_list|(
name|PHASE_MSGOUT
argument_list|)
argument_list|)
expr_stmt|;
name|nca_sendbyte
argument_list|(
name|z
argument_list|,
name|MSG_ABORT
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"nca%d send MSG_ABORT\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|)
argument_list|)
expr_stmt|;
name|ret
label|:
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the message from the target.  * Return the length of the received message.  */
end_comment

begin_function
name|u_char
name|nca_msg_input
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
block|{
name|u_char
name|sts
decl_stmt|,
name|msg
decl_stmt|;
comment|/* Wait for REQ, after which the phase bits will be valid. */
name|WAITFOR
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
argument_list|,
literal|1000000
argument_list|,
literal|"message input"
argument_list|)
expr_stmt|;
name|sts
operator|=
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|CSBR_REQ
operator|)
condition|)
return|return
operator|(
name|MSG_ABORT
operator|)
return|;
comment|/* Check for phase mismatch. 	 * Reached if the target decides that it has finished the transfer. */
if|if
condition|(
operator|(
name|sts
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_MSGIN
condition|)
block|{
name|printf
argument_list|(
literal|"nca: sending message: invalid phase %s\n"
argument_list|,
name|PHASE_NAME
argument_list|(
name|sts
operator|&
name|PHASE_MASK
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|MSG_ABORT
operator|)
return|;
block|}
comment|/* Do actual transfer from SCSI bus to memory. */
name|outb
argument_list|(
name|z
operator|->
name|TCR
argument_list|,
name|PHASE_TO_TCR
argument_list|(
name|PHASE_MSGIN
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|nca_recvbyte
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"nca%d (MSG_INPUT) got 0x%x\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send request-sense op to the target.  * Return 1 success, 0 on failure.  * Called on splbio level.  */
end_comment

begin_function
name|int
name|nca_sense
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
block|{
name|u_char
name|cmd
index|[
literal|6
index|]
decl_stmt|,
name|status
decl_stmt|,
name|msg
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|u_long
name|len
decl_stmt|;
comment|/* Wait for target to disconnect. */
name|WAITFOR
argument_list|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_BSY
operator|)
argument_list|,
literal|100000
argument_list|,
literal|"sense bus free"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_BSY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Select the target again. */
if|if
condition|(
operator|!
name|nca_select
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Wait for CMDOUT phase. */
name|WAITFOR
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
argument_list|,
literal|100000
argument_list|,
literal|"sense CMDOUT"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
operator|)
operator|||
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_CMDOUT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|outb
argument_list|(
name|z
operator|->
name|TCR
argument_list|,
name|PHASE_TO_TCR
argument_list|(
name|PHASE_CMDOUT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Send command. */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|scb
operator|->
name|xfer
operator|->
name|sense
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|cmd
index|[
literal|1
index|]
operator|=
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|<<
literal|5
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|cmd
index|[
literal|4
index|]
operator|=
name|len
expr_stmt|;
name|cmd
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|nca_cmd_output
argument_list|(
name|z
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wait for DATAIN phase. */
name|WAITFOR
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
argument_list|,
literal|100000
argument_list|,
literal|"sense DATAIN"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
operator|)
operator|||
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_DATAIN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|outb
argument_list|(
name|z
operator|->
name|TCR
argument_list|,
name|PHASE_TO_TCR
argument_list|(
name|PHASE_DATAIN
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|scb
operator|->
name|xfer
operator|->
name|sense
expr_stmt|;
name|nca_data_input
argument_list|(
name|z
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"nca%d sense %x-%x-%x-%x-%x-%x-%x-%x\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|error_code
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|segment
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|flags
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|extra_len
operator|)
argument_list|)
expr_stmt|;
comment|/* Wait for STATIN phase. */
name|WAITFOR
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
argument_list|,
literal|100000
argument_list|,
literal|"sense STATIN"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
operator|)
operator|||
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_STATIN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|outb
argument_list|(
name|z
operator|->
name|TCR
argument_list|,
name|PHASE_TO_TCR
argument_list|(
name|PHASE_STATIN
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|nca_recvbyte
argument_list|(
name|z
argument_list|)
expr_stmt|;
comment|/* Wait for MSGIN phase. */
name|WAITFOR
argument_list|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
argument_list|,
literal|100000
argument_list|,
literal|"sense MSGIN"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_REQ
operator|)
operator|||
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_MSGIN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|outb
argument_list|(
name|z
operator|->
name|TCR
argument_list|,
name|PHASE_TO_TCR
argument_list|(
name|PHASE_MSGIN
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|=
name|nca_recvbyte
argument_list|(
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|||
name|msg
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"nca%d: bad sense status=0x%x, msg=0x%x\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|status
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the transfer. We know we are connected. Update the flags,  * call nca_done when task accomplished. Dialog controlled by the target.  * Always called with interrupts disabled.  */
end_comment

begin_function
name|void
name|nca_information_transfer
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
block|{
name|u_char
modifier|*
name|data
init|=
name|scb
operator|->
name|data
decl_stmt|;
comment|/* current data buffer */
name|u_long
name|datalen
init|=
name|scb
operator|->
name|datalen
decl_stmt|;
comment|/* current data transfer size */
specifier|register
name|u_char
name|sts
decl_stmt|;
name|u_char
name|msg
decl_stmt|;
while|while
condition|(
operator|(
name|sts
operator|=
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|)
operator|&
name|CSBR_BSY
condition|)
block|{
comment|/* We only have a valid SCSI phase when REQ is asserted. */
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|CSBR_REQ
operator|)
condition|)
continue|continue;
if|if
condition|(
name|inb
argument_list|(
name|z
operator|->
name|BSR
argument_list|)
operator|&
name|BSR_PARITY_ERROR
condition|)
block|{
name|int
name|target
init|=
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
decl_stmt|;
if|if
condition|(
operator|++
name|z
operator|->
name|target
index|[
name|target
index|]
operator|.
name|perrcnt
operator|<=
literal|8
condition|)
name|printf
argument_list|(
literal|"nca%d/%d/%d parity error\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|target
index|[
name|target
index|]
operator|.
name|perrcnt
operator|==
literal|8
condition|)
name|printf
argument_list|(
literal|"nca%d/%d/%d too many parity errors, not logging any more\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
comment|/* Clear parity error. */
name|inb
argument_list|(
name|z
operator|->
name|RPIR
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|z
operator|->
name|TCR
argument_list|,
name|PHASE_TO_TCR
argument_list|(
name|sts
operator|&
name|PHASE_MASK
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sts
operator|&
name|PHASE_MASK
condition|)
block|{
case|case
name|PHASE_DATAOUT
case|:
if|if
condition|(
name|datalen
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"nca%d/%d/%d data length underflow\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
comment|/* send zero byte */
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_DATA_BUS
argument_list|)
expr_stmt|;
name|nca_sendbyte
argument_list|(
name|z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|nca_data_output
argument_list|(
name|z
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|datalen
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_DATAIN
case|:
if|if
condition|(
name|datalen
operator|<=
literal|0
condition|)
block|{
comment|/* Get extra data.  Some devices (e.g. CDROMs) 				 * use fixed-length blocks (e.g. 2k), 				 * even if we need less. */
name|PRINT
argument_list|(
operator|(
literal|"@"
operator|)
argument_list|)
expr_stmt|;
name|nca_recvbyte
argument_list|(
name|z
argument_list|)
expr_stmt|;
break|break;
block|}
name|nca_data_input
argument_list|(
name|z
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|datalen
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_CMDOUT
case|:
name|nca_cmd_output
argument_list|(
name|z
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|scb
operator|->
name|xfer
operator|->
name|cmd
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_STATIN
case|:
name|scb
operator|->
name|xfer
operator|->
name|status
operator|=
name|nca_recvbyte
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"nca%d/%d/%d (STATIN) got 0x%x\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|,
operator|(
name|u_char
operator|)
name|scb
operator|->
name|xfer
operator|->
name|status
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_MSGOUT
case|:
comment|/* Send no-op message. */
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
name|ICR_ASSERT_DATA_BUS
argument_list|)
expr_stmt|;
name|nca_sendbyte
argument_list|(
name|z
argument_list|,
name|MSG_NOP
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"nca%d/%d/%d (MSGOUT) send NOP\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_MSGIN
case|:
comment|/* Don't handle multi-byte messages here, because they 			 * should not be present here. */
name|msg
operator|=
name|nca_recvbyte
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"nca%d/%d/%d (MSGIN) got 0x%x\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
condition|)
block|{
case|case
name|MSG_COMMAND_COMPLETE
case|:
name|scb
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
comment|/* In the case of check-condition status, 				 * perform the request-sense op. */
switch|switch
condition|(
name|scb
operator|->
name|xfer
operator|->
name|status
operator|&
literal|0x1e
condition|)
block|{
case|case
name|SCSI_CHECK
case|:
if|if
condition|(
name|nca_sense
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
condition|)
name|scb
operator|->
name|flags
operator|=
name|SCB_SENSE
expr_stmt|;
break|break;
case|case
name|SCSI_BUSY
case|:
name|scb
operator|->
name|flags
operator|=
name|SCB_TBUSY
expr_stmt|;
break|break;
block|}
goto|goto
name|done
goto|;
case|case
name|MSG_ABORT
case|:
name|printf
argument_list|(
literal|"nca: command aborted by target\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ABORTED
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|MSG_MESSAGE_REJECT
case|:
name|printf
argument_list|(
literal|"nca: message rejected\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ABORTED
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|MSG_DISCONNECT
case|:
name|scb
operator|->
name|next
operator|=
name|z
operator|->
name|disconnected_queue
expr_stmt|;
name|z
operator|->
name|disconnected_queue
operator|=
name|scb
expr_stmt|;
if|if
condition|(
operator|!
name|z
operator|->
name|irq
operator|&&
operator|!
name|z
operator|->
name|timeout_active
condition|)
block|{
name|timeout
argument_list|(
name|nca_tick
argument_list|,
name|z
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|z
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
block|}
name|PRINT
argument_list|(
operator|(
literal|"nca%d/%d/%d disconnected\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|MSG_SAVE_POINTERS
case|:
name|scb
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
break|break;
case|case
name|MSG_RESTORE_POINTERS
case|:
name|data
operator|=
name|scb
operator|->
name|data
expr_stmt|;
name|datalen
operator|=
name|scb
operator|->
name|datalen
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"nca%d/%d/%d unknown message: 0x%x\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"nca: unknown phase: %b\n"
argument_list|,
name|sts
argument_list|,
name|CSBR_BITS
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"nca%d/%d/%d unexpected target disconnect\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ERROR
expr_stmt|;
name|done
label|:
name|CLEAR_BUSY
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|nca_done
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ret
label|:
name|outb
argument_list|(
name|z
operator|->
name|ICR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|TCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|z
operator|->
name|SER
argument_list|,
name|z
operator|->
name|scsi_id
argument_list|)
expr_stmt|;
name|WAITFOR
argument_list|(
operator|!
operator|(
name|inb
argument_list|(
name|z
operator|->
name|CSBR
argument_list|)
operator|&
name|CSBR_BSY
operator|)
argument_list|,
literal|100000
argument_list|,
literal|"xfer bus free"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NNCA */
end_comment

end_unit

