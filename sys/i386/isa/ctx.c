begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CORTEX-I Frame Grabber driver V1.0  *  *	Copyright (C) 1994, Paul S. LaFollette, Jr. This software may be used,  *	modified, copied, distributed, and sold, in both source and binary form  *	provided that the above copyright and these terms are retained. Under  *	no circumstances is the author responsible for the proper functioning  *	of this software, nor does the author assume any responsibility  *	for damages incurred with its use.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *  *  *  *	Device Driver for CORTEX-I Frame Grabber  *	Made by ImageNation Corporation  *	1200 N.E. Keyues Road  *	Vancouver, WA 98684  (206) 944-9131  *	(I have no ties to this company, just thought you might want  *	 to know how to get in touch with them.)  *  *	In order to understand this device, you really need to consult the  *	manual which ImageNation provides when you buy the board. (And  *	what a pleasure it is to buy something for a PC and actually get  *	programming information along with it.)  I will limit myself here to  *	a few comments which are specific to this driver.  See also the file  *	ctxreg.h for definitions of registers and control bits.  *  *	1.  Although the hardware supports low resolution (256 x 256)  *	    acqusition and display, I have not implemented access to  *	    these modes in this driver.  There are some fairly quirky  *	    aspects to the way this board works in low resolution mode,  *	    and I don't want to deal with them.  Maybe later.  *  *	2.  Choosing the base address for the video memory:  This is set  *	    using a combination of hardware and software, using the left  *	    most dip switch on the board, and the AB_SELECT bit of control  *	    port 1, according to the chart below:  *  *		Left DIP switch ||	DOWN	|	UP	|  *		=================================================  *		 AB_SELECT =  0	||    0xA0000	|    0xB0000	|  *		-------------------------------------------------  *		 AB_SELECT = 1 	||    0xD0000	|    0xE0000	|  *		------------------------------------------------  *  *	    When the RAM_ENABLE bit of control port 1 is clear (0), the  *	    video ram is disconnected from the computer bus.  This makes  *	    it possible, in principle, to share memory space with other  *	    devices (such as VGA) which can also disconnect themselves  *	    from the bus.  It also means that multiple CORTEX-I boards  *	    can share the same video memory space.  Disconnecting from the  *	    bus does not affect the video display of the video ram contents,  *	    so that one needs only set the RAM_ENABLE bit when actually  *	    reading or writing to memory.  The cost of this is low,  *	    the benefits to me are great (I need more than one board  *	    in my machine, and 0xE0000 is the only address choice that  *	    doesn't conflict with anything) so I adopt this strategy here.  *  *	    XXX-Note... this driver has only been tested for the  *	    XXX base = 0xE0000 case!  *  *	3)  There is a deficiency in the documentation from ImageNation, I  *	    think.  In order to successfully load the lookup table, it is  *	    necessary to clear SEE_STORED_VIDEO in control port 0 as well as  *	    setting LUT_LOAD_ENABLE in control port 1.  *  *	4)  This driver accesses video memory through read or write operations.  *	    Other functionality is provided through ioctl's, manifest  *	    constants for which are defined in ioctl_ctx.h. The ioctl's  *	    include:  *			CTX_LIVE	Display live video  *			CTX_GRAB	Grab a frame of video data  *			CTX_H_ORGANIZE	Set things up so that sequential read  *					operations access horizontal lines of  *					pixels.  *			CTX_V_ORGANIZE	Set things up so that sequential read  *					operations access vertical lines of  *					pixels.  *			CTX_SET_LUT	Set the lookup table from an array  *					of 256 unsigned chars passed as the  *					third parameter to ioctl.  *			CTX_GET_LUT	Return the current lookup table to  *					the application as an array of 256  *					unsigned chars.  Again the third  *					parameter to the ioctl call.  *  *	    Thus,  *		ioctl(fi, CTX_H_ORGANIZE, 0);  *		lseek(fi, y*512, SEEK_SET);  *		read(fi, buffer, 512);  *  *	    will fill buffer with 512 pixels (unsigned chars) which represent  *	    the y-th horizontal line of the image.  *	    Similarly,  *		ioctl(fi, CTX_V_ORGANIZE, 0:  *		lseek(fi, x*512+y, SEEK_SET);  *		read(fi, buffer, 10);  *  *	    will read 10 a vertical line of 10 pixels starting at (x,y).  *  *	    Obviously, this sort of ugliness needs to be hidden away from  *	    the casual user, with an appropriate set of higher level  *	    functions.  *  */
end_comment

begin_include
include|#
directive|include
file|"ctx.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ctxreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/ioctl_ctx.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_OLDISA
end_ifndef

begin_error
error|#
directive|error
literal|"The ctx device requires the old isa compatibility shims"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|waitvb
parameter_list|(
name|int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* state flags */
end_comment

begin_define
define|#
directive|define
name|OPEN
value|(0x01)
end_define

begin_comment
comment|/* device is open */
end_comment

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x07)
end_define

begin_decl_stmt
specifier|static
name|int
name|ctxprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|devp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ctxattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|devp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|ctxdriver
init|=
block|{
name|INTR_TYPE_MISC
block|,
name|ctxprobe
block|,
name|ctxattach
block|,
literal|"ctx"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|COMPAT_ISA_DRIVER
argument_list|(
name|ctx
argument_list|,
name|ctxdriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|ctxopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|ctxclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|ctxread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|ctxwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|ctxioctl
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|40
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ctx_cdevsw
init|=
block|{
comment|/* open */
name|ctxopen
block|,
comment|/* close */
name|ctxclose
block|,
comment|/* read */
name|ctxread
block|,
comment|/* write */
name|ctxwrite
block|,
comment|/* ioctl */
name|ctxioctl
block|,
comment|/* poll */
name|nopoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"ctx"
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LUTSIZE
value|256
end_define

begin_comment
comment|/* buffer size for Look Up Table (LUT) */
end_comment

begin_define
define|#
directive|define
name|PAGESIZE
value|65536
end_define

begin_comment
comment|/* size of one video page, 1/4 of the screen */
end_comment

begin_comment
comment|/*  *  Per unit shadow registers (because the dumb hardware is RO) */
end_comment

begin_struct
specifier|static
struct|struct
name|ctx_soft_registers
block|{
name|u_char
modifier|*
name|lutp
decl_stmt|;
name|u_char
name|cp0
decl_stmt|;
name|u_char
name|cp1
decl_stmt|;
name|u_char
name|flag
decl_stmt|;
name|int
name|iobase
decl_stmt|;
name|caddr_t
name|maddr
decl_stmt|;
name|int
name|msize
decl_stmt|;
block|}
name|ctx_sr
index|[
name|NCTX
index|]
struct|;
end_struct

begin_function
specifier|static
name|int
name|ctxprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|devp
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|devp
operator|->
name|id_iobase
argument_list|)
operator|==
literal|0xff
condition|)
comment|/* 0xff only if board absent */
name|status
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|status
operator|=
literal|1
expr_stmt|;
comment|/*XXX uses only one port? */
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctxattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|devp
parameter_list|)
block|{
name|struct
name|ctx_soft_registers
modifier|*
name|sr
decl_stmt|;
name|sr
operator|=
operator|&
operator|(
name|ctx_sr
index|[
name|devp
operator|->
name|id_unit
index|]
operator|)
expr_stmt|;
name|sr
operator|->
name|cp0
operator|=
literal|0
expr_stmt|;
comment|/* zero out the shadow registers */
name|sr
operator|->
name|cp1
operator|=
literal|0
expr_stmt|;
comment|/* and the open flag.  wait for  */
name|sr
operator|->
name|flag
operator|=
literal|0
expr_stmt|;
comment|/* open to malloc the LUT space  */
name|sr
operator|->
name|iobase
operator|=
name|devp
operator|->
name|id_iobase
expr_stmt|;
name|sr
operator|->
name|maddr
operator|=
name|devp
operator|->
name|id_maddr
expr_stmt|;
name|sr
operator|->
name|msize
operator|=
name|devp
operator|->
name|id_msize
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|ctx_cdevsw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"ctx%d"
argument_list|,
name|devp
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctxopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ctx_soft_registers
modifier|*
name|sr
decl_stmt|;
name|u_char
name|unit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* minor number out of range? */
if|if
condition|(
name|unit
operator|>=
name|NCTX
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sr
operator|=
operator|&
operator|(
name|ctx_sr
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|sr
operator|->
name|flag
operator|!=
literal|0
condition|)
comment|/* someone has already opened us */
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* get space for the LUT buffer */
name|sr
operator|->
name|lutp
operator|=
name|malloc
argument_list|(
name|LUTSIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr
operator|->
name|lutp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sr
operator|->
name|flag
operator|=
name|OPEN
expr_stmt|;
comment|/* 	Set up the shadow registers.  We don't actually write these 	values to the control ports until after we finish loading the 	lookup table. */
name|sr
operator|->
name|cp0
operator||=
name|SEE_STORED_VIDEO
expr_stmt|;
if|if
condition|(
operator|(
name|kvtop
argument_list|(
name|sr
operator|->
name|maddr
argument_list|)
operator|==
literal|0xB0000
operator|)
operator|||
operator|(
name|kvtop
argument_list|(
name|sr
operator|->
name|maddr
argument_list|)
operator|==
literal|0xE0000
operator|)
condition|)
name|sr
operator|->
name|cp1
operator||=
name|AB_SELECT
expr_stmt|;
comment|/* map to B or E if necessary */
comment|/* but don't enable RAM	  */
comment|/* 	Set up the lookup table initially so that it is transparent. */
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp0
argument_list|,
operator|(
name|u_char
operator|)
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp1
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|LUT_LOAD_ENABLE
operator||
name|BLANK_DISPLAY
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LUTSIZE
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_lutaddr
argument_list|,
operator|(
name|u_char
operator|)
name|i
argument_list|)
expr_stmt|;
name|sr
operator|->
name|lutp
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|i
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_lutdata
argument_list|,
operator|(
name|u_char
operator|)
name|sr
operator|->
name|lutp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 	Disable LUT loading, and push the data in the shadow 	registers into the control ports. */
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp0
argument_list|,
name|sr
operator|->
name|cp0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp1
argument_list|,
name|sr
operator|->
name|cp1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* successful open.  All ready to go. */
block|}
end_function

begin_function
specifier|static
name|int
name|ctxclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ctx_sr
index|[
name|unit
index|]
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|ctx_sr
index|[
name|unit
index|]
operator|.
name|lutp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ctx_sr
index|[
name|unit
index|]
operator|.
name|lutp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctxwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|status
init|=
literal|0
decl_stmt|;
name|int
name|page
decl_stmt|,
name|count
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|ctx_soft_registers
modifier|*
name|sr
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sr
operator|=
operator|&
operator|(
name|ctx_sr
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|>=
literal|4
operator|*
name|PAGESIZE
condition|)
name|page
operator|=
literal|4
expr_stmt|;
comment|/* EOF */
else|else
name|page
operator|=
operator|(
name|u_int
operator|)
name|uio
operator|->
name|uio_offset
operator|/
name|PAGESIZE
expr_stmt|;
name|offset
operator|=
operator|(
name|u_int
operator|)
name|uio
operator|->
name|uio_offset
operator|%
name|PAGESIZE
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|PAGESIZE
operator|-
name|offset
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|page
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|page
operator|<=
literal|3
operator|)
operator|&&
operator|(
name|count
operator|>
literal|0
operator|)
condition|)
block|{
name|sr
operator|->
name|cp0
operator|&=
operator|~
literal|3
expr_stmt|;
name|sr
operator|->
name|cp0
operator||=
name|page
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp0
argument_list|,
name|sr
operator|->
name|cp0
argument_list|)
expr_stmt|;
comment|/* 	Before doing the uiomove, we need to "connect" the frame buffer 	ram to the machine bus.  This is done here so that we can have 	several different boards installed, all sharing the same memory 	space... each board is only "connected" to the bus when its memory 	is actually being read or written.  All my instincts tell me that 	I should disable interrupts here, so I have done so. */
name|disable_intr
argument_list|()
expr_stmt|;
name|sr
operator|->
name|cp1
operator||=
name|RAM_ENABLE
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp1
argument_list|,
name|sr
operator|->
name|cp1
argument_list|)
expr_stmt|;
name|status
operator|=
name|uiomove
argument_list|(
name|sr
operator|->
name|maddr
operator|+
name|offset
argument_list|,
name|count
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|sr
operator|->
name|cp1
operator|&=
operator|~
name|RAM_ENABLE
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp1
argument_list|,
name|sr
operator|->
name|cp1
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
name|page
operator|=
operator|(
name|u_int
operator|)
name|uio
operator|->
name|uio_offset
operator|/
name|PAGESIZE
expr_stmt|;
name|offset
operator|=
operator|(
name|u_int
operator|)
name|uio
operator|->
name|uio_offset
operator|%
name|PAGESIZE
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|PAGESIZE
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
else|else
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctxread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|status
init|=
literal|0
decl_stmt|;
name|int
name|page
decl_stmt|,
name|count
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|ctx_soft_registers
modifier|*
name|sr
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sr
operator|=
operator|&
operator|(
name|ctx_sr
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|>=
literal|4
operator|*
name|PAGESIZE
condition|)
name|page
operator|=
literal|4
expr_stmt|;
comment|/* EOF */
else|else
name|page
operator|=
operator|(
name|u_int
operator|)
name|uio
operator|->
name|uio_offset
operator|/
name|PAGESIZE
expr_stmt|;
name|offset
operator|=
operator|(
name|u_int
operator|)
name|uio
operator|->
name|uio_offset
operator|%
name|PAGESIZE
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|PAGESIZE
operator|-
name|offset
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|page
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|page
operator|<=
literal|3
operator|)
operator|&&
operator|(
name|count
operator|>
literal|0
operator|)
condition|)
block|{
name|sr
operator|->
name|cp0
operator|&=
operator|~
literal|3
expr_stmt|;
name|sr
operator|->
name|cp0
operator||=
name|page
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp0
argument_list|,
name|sr
operator|->
name|cp0
argument_list|)
expr_stmt|;
comment|/* 	Before doing the uiomove, we need to "connect" the frame buffer 	ram to the machine bus.  This is done here so that we can have 	several different boards installed, all sharing the same memory 	space... each board is only "connected" to the bus when its memory 	is actually being read or written.  All my instincts tell me that 	I should disable interrupts here, so I have done so. */
name|disable_intr
argument_list|()
expr_stmt|;
name|sr
operator|->
name|cp1
operator||=
name|RAM_ENABLE
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp1
argument_list|,
name|sr
operator|->
name|cp1
argument_list|)
expr_stmt|;
name|status
operator|=
name|uiomove
argument_list|(
name|sr
operator|->
name|maddr
operator|+
name|offset
argument_list|,
name|count
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|sr
operator|->
name|cp1
operator|&=
operator|~
name|RAM_ENABLE
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp1
argument_list|,
name|sr
operator|->
name|cp1
argument_list|)
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
name|page
operator|=
operator|(
name|u_int
operator|)
name|uio
operator|->
name|uio_offset
operator|/
name|PAGESIZE
expr_stmt|;
name|offset
operator|=
operator|(
name|u_int
operator|)
name|uio
operator|->
name|uio_offset
operator|%
name|PAGESIZE
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|PAGESIZE
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
else|else
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctxioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|ctx_soft_registers
modifier|*
name|sr
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sr
operator|=
operator|&
operator|(
name|ctx_sr
index|[
name|unit
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CTX_LIVE
case|:
name|sr
operator|->
name|cp0
operator|&=
operator|~
name|SEE_STORED_VIDEO
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp0
argument_list|,
name|sr
operator|->
name|cp0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTX_GRAB
case|:
name|sr
operator|->
name|cp0
operator|&=
operator|~
name|SEE_STORED_VIDEO
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp0
argument_list|,
name|sr
operator|->
name|cp0
argument_list|)
expr_stmt|;
name|sr
operator|->
name|cp0
operator||=
name|ACQUIRE
expr_stmt|;
if|if
condition|(
name|waitvb
argument_list|(
name|sr
operator|->
name|iobase
argument_list|)
condition|)
comment|/* wait for vert blank to start 					 * acquire */
name|error
operator|=
name|ENODEV
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp0
argument_list|,
name|sr
operator|->
name|cp0
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitvb
argument_list|(
name|sr
operator|->
name|iobase
argument_list|)
condition|)
comment|/* wait for two more to finish acquire */
name|error
operator|=
name|ENODEV
expr_stmt|;
if|if
condition|(
name|waitvb
argument_list|(
name|sr
operator|->
name|iobase
argument_list|)
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
name|sr
operator|->
name|cp0
operator|&=
operator|~
name|ACQUIRE
expr_stmt|;
comment|/* turn off acquire and turn on 					 * display */
name|sr
operator|->
name|cp0
operator||=
name|SEE_STORED_VIDEO
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp0
argument_list|,
name|sr
operator|->
name|cp0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTX_H_ORGANIZE
case|:
name|sr
operator|->
name|cp0
operator|&=
operator|~
name|PAGE_ROTATE
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp0
argument_list|,
name|sr
operator|->
name|cp0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTX_V_ORGANIZE
case|:
name|sr
operator|->
name|cp0
operator||=
name|PAGE_ROTATE
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp0
argument_list|,
name|sr
operator|->
name|cp0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTX_SET_LUT
case|:
name|bcopy
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
name|sr
operator|->
name|lutp
argument_list|,
name|LUTSIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp0
argument_list|,
operator|(
name|u_char
operator|)
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp1
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|LUT_LOAD_ENABLE
operator||
name|BLANK_DISPLAY
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LUTSIZE
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_lutaddr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_lutdata
argument_list|,
name|sr
operator|->
name|lutp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp0
argument_list|,
name|sr
operator|->
name|cp0
argument_list|)
expr_stmt|;
comment|/* restore control 							 * registers */
name|outb
argument_list|(
name|sr
operator|->
name|iobase
operator|+
name|ctx_cp1
argument_list|,
name|sr
operator|->
name|cp1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTX_GET_LUT
case|:
name|bcopy
argument_list|(
name|sr
operator|->
name|lutp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
name|LUTSIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|waitvb
parameter_list|(
name|int
name|port
parameter_list|)
block|{
comment|/* wait for a vertical blank,  */
if|if
condition|(
name|inb
argument_list|(
name|port
argument_list|)
operator|==
literal|0xff
condition|)
comment|/* 0xff means no board present */
return|return
operator|(
literal|1
operator|)
return|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
argument_list|)
operator|&
name|VERTICAL_BLANK
operator|)
operator|!=
literal|0
condition|)
block|{ 	}
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
argument_list|)
operator|&
name|VERTICAL_BLANK
operator|)
operator|==
literal|0
condition|)
block|{ 	}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

