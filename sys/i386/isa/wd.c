begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)wd.c	7.2 (Berkeley) 5/9/91  *	$Id: wd.c,v 1.150 1998/02/01 19:10:04 bde Exp $  */
end_comment

begin_comment
comment|/* TODO:  *	o Bump error count after timeout.  *	o Satisfy ATA timing in all cases.  *	o Finish merging berry/sos timeout code (bump error count...).  *	o Merge/fix TIH/NetBSD bad144 code.  *	o Don't use polling except for initialization.  Need to  *	  reorganize the state machine.  Then "extra" interrupts  *	  shouldn't happen (except maybe one for initialization).  *	o Fix disklabel, boot and driver inconsistencies with  *	  bad144 in standard versions.  *	o Support extended DOS partitions.  *	o Support swapping to DOS partitions.  *	o Handle bad sectors, clustering, disklabelling, DOS  *	  partitions and swapping driver-independently.  Use  *	  i386/dkbad.c for bad sectors.  Swapping will need new  *	  driver entries for polled reinit and polled write).  */
end_comment

begin_include
include|#
directive|include
file|"wd.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NWDC
end_ifdef

begin_undef
undef|#
directive|undef
name|NWDC
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"wdc.h"
end_include

begin_if
if|#
directive|if
name|NWDC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"opt_atapi.h"
end_include

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_include
include|#
directive|include
file|"opt_hw_wdog.h"
end_include

begin_include
include|#
directive|include
file|"opt_wd.h"
end_include

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkbad.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskslice.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<machine/bootinfo.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cons.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/wdreg.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ATAPI
end_ifdef

begin_include
include|#
directive|include
file|<i386/isa/atapi.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CMD640
end_ifdef

begin_include
include|#
directive|include
file|<i386/isa/wdc_p.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*CMD640*/
end_comment

begin_function_decl
specifier|extern
name|void
name|wdstart
parameter_list|(
name|int
name|ctrlr
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|TIMEOUT
value|10000
end_define

begin_define
define|#
directive|define
name|RETRIES
value|5
end_define

begin_comment
comment|/* number of retries before giving up */
end_comment

begin_define
define|#
directive|define
name|RECOVERYTIME
value|500000
end_define

begin_comment
comment|/* usec for controller to recover after err */
end_comment

begin_define
define|#
directive|define
name|MAXTRANSFER
value|255
end_define

begin_comment
comment|/* max size of transfer in sectors */
end_comment

begin_comment
comment|/* correct max is 256 but some controllers */
end_comment

begin_comment
comment|/* can't handle that in all cases */
end_comment

begin_define
define|#
directive|define
name|WDOPT_32BIT
value|0x8000
end_define

begin_define
define|#
directive|define
name|WDOPT_SLEEPHACK
value|0x4000
end_define

begin_define
define|#
directive|define
name|WDOPT_DMA
value|0x2000
end_define

begin_define
define|#
directive|define
name|WDOPT_FORCEHD
parameter_list|(
name|x
parameter_list|)
value|(((x)&0x0f00)>>8)
end_define

begin_define
define|#
directive|define
name|WDOPT_MULTIMASK
value|0x00ff
end_define

begin_comment
comment|/*  * This biotab field doubles as a field for the physical unit number on  * the controller.  */
end_comment

begin_define
define|#
directive|define
name|id_physid
value|id_scsiid
end_define

begin_comment
comment|/*  * Drive states.  Used to initialize drive.  */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|0
end_define

begin_comment
comment|/* disk is closed. */
end_comment

begin_define
define|#
directive|define
name|WANTOPEN
value|1
end_define

begin_comment
comment|/* open requested, not started */
end_comment

begin_define
define|#
directive|define
name|RECAL
value|2
end_define

begin_comment
comment|/* doing restore */
end_comment

begin_define
define|#
directive|define
name|OPEN
value|3
end_define

begin_comment
comment|/* done with open */
end_comment

begin_define
define|#
directive|define
name|PRIMARY
value|0
end_define

begin_comment
comment|/*  * Disk geometry.  A small part of struct disklabel.  * XXX disklabel.5 contains an old clone of disklabel.h.  */
end_comment

begin_struct
struct|struct
name|diskgeom
block|{
name|u_long
name|d_secsize
decl_stmt|;
comment|/* # of bytes per sector */
name|u_long
name|d_nsectors
decl_stmt|;
comment|/* # of data sectors per track */
name|u_long
name|d_ntracks
decl_stmt|;
comment|/* # of tracks per cylinder */
name|u_long
name|d_ncylinders
decl_stmt|;
comment|/* # of data cylinders per unit */
name|u_long
name|d_secpercyl
decl_stmt|;
comment|/* # of data sectors per cylinder */
name|u_long
name|d_secperunit
decl_stmt|;
comment|/* # of data sectors per unit */
name|u_long
name|d_precompcyl
decl_stmt|;
comment|/* XXX always 0 */
block|}
struct|;
end_struct

begin_comment
comment|/*  * The structure of a disk drive.  */
end_comment

begin_struct
struct|struct
name|disk
block|{
name|long
name|dk_bc
decl_stmt|;
comment|/* byte count left */
name|short
name|dk_skip
decl_stmt|;
comment|/* blocks already transferred */
name|int
name|dk_ctrlr
decl_stmt|;
comment|/* physical controller number */
ifdef|#
directive|ifdef
name|CMD640
name|int
name|dk_ctrlr_cmd640
decl_stmt|;
comment|/* controller number for CMD640 quirk */
endif|#
directive|endif
name|int
name|dk_unit
decl_stmt|;
comment|/* physical unit number */
name|int
name|dk_lunit
decl_stmt|;
comment|/* logical unit number */
name|int
name|dk_interface
decl_stmt|;
comment|/* interface (two ctrlrs per interface) */
name|char
name|dk_state
decl_stmt|;
comment|/* control state */
name|u_char
name|dk_status
decl_stmt|;
comment|/* copy of status reg. */
name|u_char
name|dk_error
decl_stmt|;
comment|/* copy of error reg. */
name|u_char
name|dk_timeout
decl_stmt|;
comment|/* countdown to next timeout */
name|int
name|dk_port
decl_stmt|;
comment|/* i/o port base */
name|int
name|dk_altport
decl_stmt|;
comment|/* altstatus port base */
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|dk_bdev
decl_stmt|;
comment|/* devfs token for whole disk */
name|void
modifier|*
name|dk_cdev
decl_stmt|;
comment|/* devfs token for raw whole disk */
endif|#
directive|endif
name|u_long
name|cfg_flags
decl_stmt|;
comment|/* configured characteristics */
name|short
name|dk_flags
decl_stmt|;
comment|/* drive characteristics found */
define|#
directive|define
name|DKFL_SINGLE
value|0x00004
comment|/* sector at a time mode */
define|#
directive|define
name|DKFL_ERROR
value|0x00008
comment|/* processing a disk error */
define|#
directive|define
name|DKFL_LABELLING
value|0x00080
comment|/* readdisklabel() in progress */
define|#
directive|define
name|DKFL_32BIT
value|0x00100
comment|/* use 32-bit i/o mode */
define|#
directive|define
name|DKFL_MULTI
value|0x00200
comment|/* use multi-i/o mode */
define|#
directive|define
name|DKFL_BADSCAN
value|0x00400
comment|/* report all errors */
define|#
directive|define
name|DKFL_USEDMA
value|0x00800
comment|/* use DMA for data transfers */
define|#
directive|define
name|DKFL_DMA
value|0x01000
comment|/* using DMA on this transfer-- DKFL_SINGLE 				 * overrides this 				 */
name|struct
name|wdparams
name|dk_params
decl_stmt|;
comment|/* ESDI/IDE drive/controller parameters */
name|int
name|dk_dkunit
decl_stmt|;
comment|/* disk stats unit number */
name|int
name|dk_multi
decl_stmt|;
comment|/* multi transfers */
name|int
name|dk_currentiosize
decl_stmt|;
comment|/* current io size */
name|struct
name|diskgeom
name|dk_dd
decl_stmt|;
comment|/* device configuration data */
name|struct
name|diskslices
modifier|*
name|dk_slices
decl_stmt|;
comment|/* virtual drives */
name|void
modifier|*
name|dk_dmacookie
decl_stmt|;
comment|/* handle for DMA services */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|WD_COUNT_RETRIES
end_define

begin_decl_stmt
specifier|static
name|int
name|wdtest
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|disk
modifier|*
name|wddrives
index|[
name|NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of units */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buf_queue_head
name|drive_queue
index|[
name|NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of queue per drive */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|b_active
decl_stmt|;
block|}
name|wdutab
index|[
name|NWD
index|]
struct|;
end_struct

begin_comment
comment|/* static struct buf wdtab[NWDC]; */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|buf_queue_head
name|controller_queue
decl_stmt|;
name|int
name|b_errcnt
decl_stmt|;
name|int
name|b_active
decl_stmt|;
block|}
name|wdtab
index|[
name|NWDC
index|]
struct|;
end_struct

begin_decl_stmt
name|struct
name|wddma
name|wddma
index|[
name|NWDC
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|buf
name|rwdbuf
index|[
name|NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers for raw IO */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|wdprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wdustart
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdcontrol
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdcommand
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|u_int
name|cylinder
parameter_list|,
name|u_int
name|head
parameter_list|,
name|u_int
name|sector
parameter_list|,
name|u_int
name|count
parameter_list|,
name|u_int
name|command
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdsetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int wdwsetctlr(struct disk *du);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|wdsetmode
parameter_list|(
name|int
name|mode
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdgetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wderror
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wdflushirq
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|int
name|old_ipl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdreset
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wdsleep
parameter_list|(
name|int
name|ctrlr
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wdstrategy1
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|wdtimeout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|wdunwedge
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdwait
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|u_char
name|bits_wanted
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|wdcdriver
init|=
block|{
name|wdprobe
block|,
name|wdattach
block|,
literal|"wdc"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|wdopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|wdclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|wdstrategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|wdioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_dump_t
name|wddump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_psize_t
name|wdsize
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|3
end_define

begin_define
define|#
directive|define
name|BDEV_MAJOR
value|0
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|wd_cdevsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bdevsw
name|wd_bdevsw
init|=
block|{
name|wdopen
block|,
name|wdclose
block|,
name|wdstrategy
block|,
name|wdioctl
block|,
comment|/*0*/
name|wddump
block|,
name|wdsize
block|,
name|D_DISK
block|,
literal|"wd"
block|,
operator|&
name|wd_cdevsw
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CMD640
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|atapictrlr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|eide_quirks
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  Here we use the pci-subsystem to find out, whether there is  *  a cmd640b-chip attached on this pci-bus. This public routine  *  will be called by wdc_p.c .  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CMD640
end_ifdef

begin_function
name|void
name|wdc_pci
parameter_list|(
name|int
name|quirks
parameter_list|)
block|{
name|eide_quirks
operator|=
name|quirks
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Probe for controller.  */
end_comment

begin_function
specifier|static
name|int
name|wdprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|int
name|interface
decl_stmt|;
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NWDC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|du
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|du
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
name|du
argument_list|,
sizeof|sizeof
expr|*
name|du
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_ctrlr
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
name|interface
operator|=
name|du
operator|->
name|dk_ctrlr
operator|/
literal|2
expr_stmt|;
name|du
operator|->
name|dk_interface
operator|=
name|interface
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_PCI_IDE
argument_list|)
operator|&&
operator|(
name|NPCI
operator|>
literal|0
operator|)
if|if
condition|(
name|wddma
index|[
name|interface
index|]
operator|.
name|wdd_candma
condition|)
block|{
name|du
operator|->
name|dk_dmacookie
operator|=
name|wddma
index|[
name|interface
index|]
operator|.
name|wdd_candma
argument_list|(
name|dvp
operator|->
name|id_iobase
argument_list|,
name|du
operator|->
name|dk_ctrlr
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|du
operator|->
name|dk_altport
operator|=
name|wddma
index|[
name|interface
index|]
operator|.
name|wdd_altiobase
argument_list|(
name|du
operator|->
name|dk_dmacookie
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|du
operator|->
name|dk_port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|du
operator|->
name|dk_altport
operator|=
name|du
operator|->
name|dk_port
operator|+
name|wd_ctlr
expr_stmt|;
block|}
else|#
directive|else
name|du
operator|->
name|dk_port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|du
operator|->
name|dk_altport
operator|=
name|du
operator|->
name|dk_port
operator|+
name|wd_ctlr
expr_stmt|;
endif|#
directive|endif
comment|/* check if we have registers that work */
name|outb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
argument_list|)
expr_stmt|;
comment|/* set unit 0 */
name|outb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_cyl_lo
argument_list|,
literal|0xa5
argument_list|)
expr_stmt|;
comment|/* wd_cyl_lo is read/write */
if|if
condition|(
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_cyl_lo
argument_list|)
operator|==
literal|0xff
condition|)
block|{
comment|/* XXX too weak */
ifdef|#
directive|ifdef
name|ATAPI
comment|/* There is no master, try the ATAPI slave. */
name|outb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
literal|0x10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_cyl_lo
argument_list|,
literal|0xa5
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_cyl_lo
argument_list|)
operator|==
literal|0xff
condition|)
endif|#
directive|endif
goto|goto
name|nodevice
goto|;
block|}
if|if
condition|(
name|wdreset
argument_list|(
name|du
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|reset_ok
goto|;
ifdef|#
directive|ifdef
name|ATAPI
comment|/* test for ATAPI signature */
name|outb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
argument_list|)
expr_stmt|;
comment|/* master */
if|if
condition|(
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_cyl_lo
argument_list|)
operator|==
literal|0x14
operator|&&
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_cyl_hi
argument_list|)
operator|==
literal|0xeb
condition|)
goto|goto
name|reset_ok
goto|;
name|du
operator|->
name|dk_unit
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
literal|0x10
argument_list|)
expr_stmt|;
comment|/* slave */
if|if
condition|(
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_cyl_lo
argument_list|)
operator|==
literal|0x14
operator|&&
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_cyl_hi
argument_list|)
operator|==
literal|0xeb
condition|)
goto|goto
name|reset_ok
goto|;
endif|#
directive|endif
name|DELAY
argument_list|(
name|RECOVERYTIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdreset
argument_list|(
name|du
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|nodevice
goto|;
block|}
name|reset_ok
label|:
comment|/* execute a controller only command */
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_DIAGNOSE
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|nodevice
goto|;
block|}
comment|/* 	 * drive(s) did not time out during diagnostic : 	 * Get error status and check that both drives are OK. 	 * Table 9-2 of ATA specs suggests that we must check for 	 * a value of 0x01 	 * 	 * Strangely, some controllers will return a status of 	 * 0x81 (drive 0 OK, drive 1 failure), and then when 	 * the DRV bit is set, return status of 0x01 (OK) for 	 * drive 2.  (This seems to contradict the ATA spec.) 	 */
name|du
operator|->
name|dk_error
operator|=
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_error
operator|!=
literal|0x01
operator|&&
name|du
operator|->
name|dk_error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|du
operator|->
name|dk_error
operator|&
literal|0x80
condition|)
block|{
comment|/* drive 1 failure */
comment|/* first set the DRV bit */
name|u_int
name|sdh
decl_stmt|;
name|sdh
operator|=
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_sdh
argument_list|)
expr_stmt|;
name|sdh
operator|=
name|sdh
operator||
literal|0x10
expr_stmt|;
name|outb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_sdh
argument_list|,
name|sdh
argument_list|)
expr_stmt|;
comment|/* Wait, to make sure drv 1 has completed diags */
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nodevice
goto|;
comment|/* Get status for drive 1 */
name|du
operator|->
name|dk_error
operator|=
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_error
argument_list|)
expr_stmt|;
comment|/* printf("Error (drv 1) : %x\n", du->dk_error); */
comment|/* 			 * Sometimes (apparently mostly with ATAPI 			 * drives involved) 0x81 really means 0x81 			 * (drive 0 OK, drive 1 failed). 			 */
if|if
condition|(
name|du
operator|->
name|dk_error
operator|!=
literal|0x01
operator|&&
name|du
operator|->
name|dk_error
operator|!=
literal|0x81
condition|)
goto|goto
name|nodevice
goto|;
block|}
else|else
comment|/* drive 0 fail */
goto|goto
name|nodevice
goto|;
block|}
name|free
argument_list|(
name|du
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|IO_WDCSIZE
operator|)
return|;
name|nodevice
label|:
name|free
argument_list|(
name|du
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach each drive if possible.  */
end_comment

begin_function
specifier|static
name|int
name|wdattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEVFS
name|int
name|mynor
decl_stmt|;
endif|#
directive|endif
name|int
name|unit
decl_stmt|,
name|lunit
decl_stmt|;
name|struct
name|isa_device
modifier|*
name|wdup
decl_stmt|;
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|struct
name|wdparams
modifier|*
name|wp
decl_stmt|;
if|if
condition|(
name|dvp
operator|->
name|id_unit
operator|>=
name|NWDC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|CMD640
if|if
condition|(
name|eide_quirks
operator|&
name|Q_CMD640B
condition|)
block|{
if|if
condition|(
name|dvp
operator|->
name|id_unit
operator|==
name|PRIMARY
condition|)
block|{
name|printf
argument_list|(
literal|"wdc0: CMD640B workaround enabled\n"
argument_list|)
expr_stmt|;
name|bufq_init
argument_list|(
operator|&
name|wdtab
index|[
name|PRIMARY
index|]
operator|.
name|controller_queue
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|bufq_init
argument_list|(
operator|&
name|wdtab
index|[
name|dvp
operator|->
name|id_unit
index|]
operator|.
name|controller_queue
argument_list|)
expr_stmt|;
else|#
directive|else
name|bufq_init
argument_list|(
operator|&
name|wdtab
index|[
name|dvp
operator|->
name|id_unit
index|]
operator|.
name|controller_queue
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|wdup
operator|=
name|isa_biotab_wdc
init|;
name|wdup
operator|->
name|id_driver
operator|!=
literal|0
condition|;
name|wdup
operator|++
control|)
block|{
if|if
condition|(
name|wdup
operator|->
name|id_iobase
operator|!=
name|dvp
operator|->
name|id_iobase
condition|)
continue|continue;
name|lunit
operator|=
name|wdup
operator|->
name|id_unit
expr_stmt|;
if|if
condition|(
name|lunit
operator|>=
name|NWD
condition|)
continue|continue;
name|unit
operator|=
name|wdup
operator|->
name|id_physid
expr_stmt|;
name|du
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|du
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|wddrives
index|[
name|lunit
index|]
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"drive attached twice"
argument_list|)
expr_stmt|;
name|wddrives
index|[
name|lunit
index|]
operator|=
name|du
expr_stmt|;
name|bufq_init
argument_list|(
operator|&
name|drive_queue
index|[
name|lunit
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|du
argument_list|,
sizeof|sizeof
expr|*
name|du
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_ctrlr
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
ifdef|#
directive|ifdef
name|CMD640
if|if
condition|(
name|eide_quirks
operator|&
name|Q_CMD640B
condition|)
block|{
name|du
operator|->
name|dk_ctrlr_cmd640
operator|=
name|PRIMARY
expr_stmt|;
block|}
else|else
block|{
name|du
operator|->
name|dk_ctrlr_cmd640
operator|=
name|du
operator|->
name|dk_ctrlr
expr_stmt|;
block|}
endif|#
directive|endif
name|du
operator|->
name|dk_unit
operator|=
name|unit
expr_stmt|;
name|du
operator|->
name|dk_lunit
operator|=
name|lunit
expr_stmt|;
name|du
operator|->
name|dk_port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|du
operator|->
name|dk_altport
operator|=
name|du
operator|->
name|dk_port
operator|+
name|wd_ctlr
expr_stmt|;
comment|/* 		 * Use the individual device flags or the controller 		 * flags. 		 */
name|du
operator|->
name|cfg_flags
operator|=
name|wdup
operator|->
name|id_flags
operator||
operator|(
operator|(
name|dvp
operator|->
name|id_flags
operator|)
operator|>>
operator|(
literal|16
operator|*
name|unit
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|wdgetctlr
argument_list|(
name|du
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Print out description of drive. 			 * wdp_model may not be null terminated. 			 */
name|printf
argument_list|(
literal|"wdc%d: unit %d (wd%d):<%.*s>"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|unit
argument_list|,
name|lunit
argument_list|,
sizeof|sizeof
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|,
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_USEDMA
condition|)
name|printf
argument_list|(
literal|", DMA"
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
condition|)
name|printf
argument_list|(
literal|", 32-bit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_multi
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|", multi-block-%d"
argument_list|,
name|du
operator|->
name|dk_multi
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|cfg_flags
operator|&
name|WDOPT_SLEEPHACK
condition|)
name|printf
argument_list|(
literal|", sleep-hack"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_params
operator|.
name|wdp_heads
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"wd%d: size unknown, using %s values\n"
argument_list|,
name|lunit
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|>
literal|17
condition|?
literal|"BIOS"
else|:
literal|"fake"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wd%d: %luMB (%lu sectors), %lu cyls, %lu heads, %lu S/T, %lu B/S\n"
argument_list|,
name|lunit
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|)
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|wp
operator|=
operator|&
name|du
operator|->
name|dk_params
expr_stmt|;
name|printf
argument_list|(
literal|"wd%d: ATA INQUIRE valid = %04x, dmamword = %04x, apio = %04x, udma = %04x\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|wp
operator|->
name|wdp_atavalid
argument_list|,
name|wp
operator|->
name|wdp_dmamword
argument_list|,
name|wp
operator|->
name|wdp_eidepiomodes
argument_list|,
name|wp
operator|->
name|wdp_udmamode
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Start timeout routine for this drive. 			 * XXX timeout should be per controller. 			 */
name|wdtimeout
argument_list|(
name|du
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|mynor
operator|=
name|dkmakeminor
argument_list|(
name|lunit
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_bdev
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|wd_bdevsw
argument_list|,
name|mynor
argument_list|,
name|DV_BLK
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"wd%d"
argument_list|,
name|lunit
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_cdev
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|wd_cdevsw
argument_list|,
name|mynor
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"rwd%d"
argument_list|,
name|lunit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dk_ndrive
operator|<
name|DK_NDRIVE
condition|)
block|{
name|sprintf
argument_list|(
name|dk_names
index|[
name|dk_ndrive
index|]
argument_list|,
literal|"wd%d"
argument_list|,
name|lunit
argument_list|)
expr_stmt|;
comment|/* 				 * XXX we don't know the transfer rate of the 				 * drive.  Guess the maximum ISA rate of 				 * 4MB/sec.  `wpms' is words per _second_ 				 * according to iostat. 				 */
name|dk_wpms
index|[
name|dk_ndrive
index|]
operator|=
literal|4
operator|*
literal|1024
operator|*
literal|1024
operator|/
literal|2
expr_stmt|;
name|du
operator|->
name|dk_dkunit
operator|=
name|dk_ndrive
operator|++
expr_stmt|;
block|}
else|else
block|{
name|du
operator|->
name|dk_dkunit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|du
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|wddrives
index|[
name|lunit
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|ATAPI
comment|/* 	 * Probe all free IDE units, searching for ATAPI drives. 	 */
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
literal|2
condition|;
operator|++
name|unit
control|)
block|{
for|for
control|(
name|lunit
operator|=
literal|0
init|;
name|lunit
operator|<
name|NWD
condition|;
operator|++
name|lunit
control|)
if|if
condition|(
name|wddrives
index|[
name|lunit
index|]
operator|&&
name|wddrives
index|[
name|lunit
index|]
operator|->
name|dk_ctrlr
operator|==
name|dvp
operator|->
name|id_unit
operator|&&
name|wddrives
index|[
name|lunit
index|]
operator|->
name|dk_unit
operator|==
name|unit
condition|)
goto|goto
name|next
goto|;
ifdef|#
directive|ifdef
name|CMD640
if|if
condition|(
name|atapi_attach
argument_list|(
name|dvp
operator|->
name|id_unit
argument_list|,
name|unit
argument_list|,
name|dvp
operator|->
name|id_iobase
argument_list|)
condition|)
name|atapictrlr
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
else|#
directive|else
name|atapi_attach
argument_list|(
name|dvp
operator|->
name|id_unit
argument_list|,
name|unit
argument_list|,
name|dvp
operator|->
name|id_iobase
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|next
label|:
empty_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Discard any interrupts generated by wdgetctlr().  wdflushirq() 	 * doesn't work now because the ambient ipl is too high. 	 */
ifdef|#
directive|ifdef
name|CMD640
if|if
condition|(
name|eide_quirks
operator|&
name|Q_CMD640B
condition|)
block|{
name|wdtab
index|[
name|PRIMARY
index|]
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|wdtab
index|[
name|dvp
operator|->
name|id_unit
index|]
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
block|}
else|#
directive|else
name|wdtab
index|[
name|dvp
operator|->
name|id_unit
index|]
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read/write routine for a buffer.  Finds the proper unit, range checks  * arguments, and schedules the transfer.  Does not wait for the transfer  * to complete.  Multi-page transfers are supported.  All I/O requests must  * be a multiple of a sector in length.  */
end_comment

begin_function
name|void
name|wdstrategy
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|lunit
init|=
name|dkunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* valid unit, controller, and request?  */
if|if
condition|(
name|lunit
operator|>=
name|NWD
operator|||
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|||
operator|(
name|du
operator|=
name|wddrives
index|[
name|lunit
index|]
operator|)
operator|==
name|NULL
operator|||
name|bp
operator|->
name|b_bcount
operator|%
name|DEV_BSIZE
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Do bounds checking, adjust transfer, and set b_pblkno. 	 */
if|if
condition|(
name|dscheck
argument_list|(
name|bp
argument_list|,
name|du
operator|->
name|dk_slices
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Check for *any* block on this transfer being on the bad block list 	 * if it is, then flag the block as a transfer that requires 	 * bad block handling.  Also, used as a hint for low level disksort 	 * clustering code to keep from coalescing a bad transfer into 	 * a normal transfer.  Single block transfers for a large number of 	 * blocks associated with a cluster I/O are undesirable. 	 * 	 * XXX the old disksort() doesn't look at B_BAD.  Coalescing _is_ 	 * desirable.  We should split the results at bad blocks just 	 * like we should split them at MAXTRANSFER boundaries. 	 */
if|if
condition|(
name|dsgetbad
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|,
name|du
operator|->
name|dk_slices
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|long
modifier|*
name|badsect
init|=
name|dsgetbad
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|,
name|du
operator|->
name|dk_slices
argument_list|)
operator|->
name|bi_bad
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nsecs
init|=
name|howmany
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|DEV_BSIZE
argument_list|)
decl_stmt|;
comment|/* XXX pblkno is too physical. */
name|daddr_t
name|nspblkno
init|=
name|bp
operator|->
name|b_pblkno
operator|-
name|du
operator|->
name|dk_slices
operator|->
name|dss_slices
index|[
name|dkslice
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|ds_offset
decl_stmt|;
name|int
name|blkend
init|=
name|nspblkno
operator|+
name|nsecs
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|badsect
index|[
name|i
index|]
operator|!=
operator|-
literal|1
operator|&&
name|badsect
index|[
name|i
index|]
operator|<
name|blkend
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|badsect
index|[
name|i
index|]
operator|>=
name|nspblkno
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_BAD
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* queue transfer on drive, activate drive and controller if idle */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bufqdisksort
argument_list|(
operator|&
name|drive_queue
index|[
name|lunit
index|]
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdutab
index|[
name|lunit
index|]
operator|.
name|b_active
operator|==
literal|0
condition|)
name|wdustart
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* start drive */
comment|/* Pick up changes made by readdisklabel(). */
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_LABELLING
operator|&&
name|du
operator|->
name|dk_state
operator|>
name|RECAL
condition|)
block|{
name|wdsleep
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|,
literal|"wdlab"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CMD640
if|if
condition|(
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr_cmd640
index|]
operator|.
name|b_active
operator|==
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|.
name|b_active
operator|==
literal|0
condition|)
endif|#
directive|endif
name|wdstart
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|)
expr_stmt|;
comment|/* start controller */
if|if
condition|(
name|du
operator|->
name|dk_dkunit
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * XXX perhaps we should only count successful transfers. 		 */
name|dk_xfer
index|[
name|du
operator|->
name|dk_dkunit
index|]
operator|++
expr_stmt|;
comment|/* 		 * XXX we can't count seeks correctly but we can do better 		 * than this.  E.g., assume that the geometry is correct 		 * and count 1 seek if the starting cylinder of this i/o 		 * differs from the starting cylinder of the previous i/o, 		 * or count 1 seek if the starting bn of this i/o doesn't 		 * immediately follow the ending bn of the previos i/o. 		 */
name|dk_seek
index|[
name|du
operator|->
name|dk_dkunit
index|]
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|done
label|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* toss transfer, we're done early */
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wdstrategy1
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
comment|/* 	 * XXX - do something to make wdstrategy() but not this block while 	 * we're doing dsinit() and dsioctl(). 	 */
name|wdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to queue a command to the controller.  The unit's  * request is linked into the active list for the controller.  * If the controller is idle, the transfer is started.  */
end_comment

begin_function
specifier|static
name|void
name|wdustart
parameter_list|(
specifier|register
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
ifdef|#
directive|ifdef
name|CMD640
name|int
name|ctrlr
init|=
name|du
operator|->
name|dk_ctrlr_cmd640
decl_stmt|;
else|#
directive|else
name|int
name|ctrlr
init|=
name|du
operator|->
name|dk_ctrlr
decl_stmt|;
endif|#
directive|endif
comment|/* unit already active? */
if|if
condition|(
name|wdutab
index|[
name|du
operator|->
name|dk_lunit
index|]
operator|.
name|b_active
condition|)
return|return;
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|drive_queue
index|[
name|du
operator|->
name|dk_lunit
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/* yes, an assign */
return|return;
block|}
name|bufq_remove
argument_list|(
operator|&
name|drive_queue
index|[
name|du
operator|->
name|dk_lunit
index|]
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* link onto controller queue */
name|bufq_insert_tail
argument_list|(
operator|&
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|controller_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* mark the drive unit as busy */
name|wdutab
index|[
name|du
operator|->
name|dk_lunit
index|]
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Controller startup routine.  This does the calculation, and starts  * a single-sector read or write operation.  Called to start a transfer,  * or from the interrupt routine to continue a multi-sector transfer.  * RESTRICTIONS:  * 1. The transfer length must be an exact multiple of the sector size.  */
end_comment

begin_function
name|void
name|wdstart
parameter_list|(
name|int
name|ctrlr
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|diskgeom
modifier|*
name|lp
decl_stmt|;
comment|/* XXX sic */
name|long
name|blknum
decl_stmt|;
name|long
name|secpertrk
decl_stmt|,
name|secpercyl
decl_stmt|;
name|int
name|lunit
decl_stmt|;
name|int
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|CMD640
name|int
name|ctrlr_atapi
decl_stmt|;
if|if
condition|(
name|eide_quirks
operator|&
name|Q_CMD640B
condition|)
block|{
name|ctrlr
operator|=
name|PRIMARY
expr_stmt|;
name|ctrlr_atapi
operator|=
name|atapictrlr
expr_stmt|;
block|}
else|else
block|{
name|ctrlr_atapi
operator|=
name|ctrlr
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ATAPI
if|if
condition|(
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_active
operator|==
literal|2
condition|)
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_active
condition|)
return|return;
endif|#
directive|endif
comment|/* is there a drive for the controller to do a transfer with? */
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|controller_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|ATAPI
ifdef|#
directive|ifdef
name|CMD640
if|if
condition|(
name|atapi_start
operator|&&
name|atapi_start
argument_list|(
name|ctrlr_atapi
argument_list|)
condition|)
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_active
operator|=
literal|3
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|atapi_start
operator|&&
name|atapi_start
argument_list|(
name|ctrlr
argument_list|)
condition|)
comment|/* mark controller active in ATAPI mode */
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_active
operator|=
literal|3
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return;
block|}
comment|/* obtain controller and drive information */
name|lunit
operator|=
name|dkunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|du
operator|=
name|wddrives
index|[
name|lunit
index|]
expr_stmt|;
comment|/* if not really a transfer, do control operations specially */
if|if
condition|(
name|du
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
block|{
if|if
condition|(
name|du
operator|->
name|dk_state
operator|!=
name|WANTOPEN
condition|)
name|printf
argument_list|(
literal|"wd%d: wdstart: weird dk_state %d\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|du
operator|->
name|dk_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdcontrol
argument_list|(
name|bp
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"wd%d: wdstart: wdcontrol returned nonzero, state = %d\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|du
operator|->
name|dk_state
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* calculate transfer details */
name|blknum
operator|=
name|bp
operator|->
name|b_pblkno
operator|+
name|du
operator|->
name|dk_skip
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"wd%d: wdstart: %s %d@%d; map "
argument_list|,
name|lunit
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %d)%x"
argument_list|,
name|du
operator|->
name|dk_skip
argument_list|,
name|inb
argument_list|(
name|du
operator|->
name|dk_altport
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lp
operator|=
operator|&
name|du
operator|->
name|dk_dd
expr_stmt|;
name|secpertrk
operator|=
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|secpercyl
operator|=
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_bc
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BAD
comment|/* 		     * XXX handle large transfers inefficiently instead 		     * of crashing on them. 		     */
operator|||
name|howmany
argument_list|(
name|du
operator|->
name|dk_bc
argument_list|,
name|DEV_BSIZE
argument_list|)
operator|>
name|MAXTRANSFER
condition|)
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_SINGLE
expr_stmt|;
block|}
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
operator|&&
name|dsgetbad
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|,
name|du
operator|->
name|dk_slices
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX */
name|u_long
name|ds_offset
init|=
name|du
operator|->
name|dk_slices
operator|->
name|dss_slices
index|[
name|dkslice
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|ds_offset
decl_stmt|;
name|blknum
operator|=
name|transbad144
argument_list|(
name|dsgetbad
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|,
name|du
operator|->
name|dk_slices
argument_list|)
argument_list|,
name|blknum
operator|-
name|ds_offset
argument_list|)
operator|+
name|ds_offset
expr_stmt|;
block|}
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
comment|/* mark controller active */
comment|/* if starting a multisector transfer, or doing single transfers */
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
operator|||
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
operator|)
condition|)
block|{
name|u_int
name|command
decl_stmt|;
name|u_int
name|count1
decl_stmt|;
name|long
name|cylin
decl_stmt|,
name|head
decl_stmt|,
name|sector
decl_stmt|;
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
comment|/*  		 * XXX this looks like an attempt to skip bad sectors 		 * on write. 		 */
if|if
condition|(
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_errcnt
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
name|du
operator|->
name|dk_bc
operator|+=
name|DEV_BSIZE
expr_stmt|;
name|count1
operator|=
name|howmany
argument_list|(
name|du
operator|->
name|dk_bc
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_MULTI
expr_stmt|;
ifdef|#
directive|ifdef
name|B_FORMAT
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FORMAT
condition|)
block|{
name|command
operator|=
name|WDCC_FORMAT
expr_stmt|;
name|count1
operator|=
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|sector
operator|=
name|lp
operator|->
name|d_gap3
operator|-
literal|1
expr_stmt|;
comment|/* + 1 later */
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
condition|)
block|{
name|command
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|WDCC_READ
else|:
name|WDCC_WRITE
expr_stmt|;
name|count1
operator|=
literal|1
expr_stmt|;
name|du
operator|->
name|dk_currentiosize
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_USEDMA
operator|)
operator|&&
name|wddma
index|[
name|du
operator|->
name|dk_interface
index|]
operator|.
name|wdd_dmaverify
argument_list|(
name|du
operator|->
name|dk_dmacookie
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_data
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
operator|)
argument_list|,
name|du
operator|->
name|dk_bc
argument_list|,
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
argument_list|)
condition|)
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_DMA
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|command
operator|=
name|WDCC_READ_DMA
expr_stmt|;
else|else
name|command
operator|=
name|WDCC_WRITE_DMA
expr_stmt|;
name|du
operator|->
name|dk_currentiosize
operator|=
name|count1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|count1
operator|>
literal|1
operator|)
operator|&&
operator|(
name|du
operator|->
name|dk_multi
operator|>
literal|1
operator|)
condition|)
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_MULTI
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|command
operator|=
name|WDCC_READ_MULTI
expr_stmt|;
block|}
else|else
block|{
name|command
operator|=
name|WDCC_WRITE_MULTI
expr_stmt|;
block|}
name|du
operator|->
name|dk_currentiosize
operator|=
name|du
operator|->
name|dk_multi
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_currentiosize
operator|>
name|count1
condition|)
name|du
operator|->
name|dk_currentiosize
operator|=
name|count1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|command
operator|=
name|WDCC_READ
expr_stmt|;
block|}
else|else
block|{
name|command
operator|=
name|WDCC_WRITE
expr_stmt|;
block|}
name|du
operator|->
name|dk_currentiosize
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * XXX this loop may never terminate.  The code to handle 		 * counting down of retries and eventually failing the i/o 		 * is in wdintr() and we can't get there from here. 		 */
if|if
condition|(
name|wdtest
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|wdtest
operator|==
literal|0
condition|)
block|{
name|wdtest
operator|=
literal|100
expr_stmt|;
name|printf
argument_list|(
literal|"dummy wdunwedge\n"
argument_list|)
expr_stmt|;
name|wdunwedge
argument_list|(
name|du
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|du
operator|->
name|dk_dkunit
operator|>=
literal|0
condition|)
block|{
name|dk_busy
operator||=
literal|1
operator|<<
name|du
operator|->
name|dk_dkunit
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_DMA
operator||
name|DKFL_SINGLE
operator|)
operator|)
operator|==
name|DKFL_DMA
condition|)
block|{
name|wddma
index|[
name|du
operator|->
name|dk_interface
index|]
operator|.
name|wdd_dmaprep
argument_list|(
name|du
operator|->
name|dk_dmacookie
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_data
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
operator|)
argument_list|,
name|du
operator|->
name|dk_bc
argument_list|,
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
name|cylin
argument_list|,
name|head
argument_list|,
name|sector
argument_list|,
name|count1
argument_list|,
name|command
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdstart: timeout waiting to give command"
argument_list|)
expr_stmt|;
name|wdunwedge
argument_list|(
name|du
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"cylin %ld head %ld sector %ld addr %x sts %x\n"
argument_list|,
name|cylin
argument_list|,
name|head
argument_list|,
name|sector
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|b_data
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
argument_list|,
name|inb
argument_list|(
name|du
operator|->
name|dk_altport
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Schedule wdtimeout() to wake up after a few seconds.  Retrying 	 * unmarked bad blocks can take 3 seconds!  Then it is not good that 	 * we retry 5 times. 	 * 	 * On the first try, we give it 10 seconds, for drives that may need 	 * to spin up. 	 * 	 * XXX wdtimeout() doesn't increment the error count so we may loop 	 * forever.  More seriously, the loop isn't forever but causes a 	 * crash. 	 * 	 * TODO fix b_resid bug elsewhere (fd.c....).  Fix short but positive 	 * counts being discarded after there is an error (in physio I 	 * think).  Discarding them would be OK if the (special) file offset 	 * was not advanced. 	 */
if|if
condition|(
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_errcnt
operator|==
literal|0
condition|)
name|du
operator|->
name|dk_timeout
operator|=
literal|1
operator|+
literal|10
expr_stmt|;
else|else
name|du
operator|->
name|dk_timeout
operator|=
literal|1
operator|+
literal|3
expr_stmt|;
comment|/* if this is a DMA op, start DMA and go away until it's done. */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_DMA
operator||
name|DKFL_SINGLE
operator|)
operator|)
operator|==
name|DKFL_DMA
condition|)
block|{
name|wddma
index|[
name|du
operator|->
name|dk_interface
index|]
operator|.
name|wdd_dmastart
argument_list|(
name|du
operator|->
name|dk_dmacookie
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this is a read operation, just go away until it's done. */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
return|return;
comment|/* Ready to send data? */
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdstart: timeout waiting for DRQ"
argument_list|)
expr_stmt|;
comment|/* 		 * XXX what do we do now?  If we've just issued the command, 		 * then we can treat this failure the same as a command 		 * failure.  But if we are continuing a multi-sector write, 		 * the command was issued ages ago, so we can't simply 		 * restart it. 		 * 		 * XXX we waste a lot of time unnecessarily translating block 		 * numbers to cylin/head/sector for continued i/o's. 		 */
block|}
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_MULTI
condition|)
block|{
name|count
operator|=
name|howmany
argument_list|(
name|du
operator|->
name|dk_bc
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|du
operator|->
name|dk_multi
condition|)
name|count
operator|=
name|du
operator|->
name|dk_multi
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_currentiosize
operator|>
name|count
condition|)
name|du
operator|->
name|dk_currentiosize
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
condition|)
name|outsl
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_data
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
operator|)
argument_list|,
operator|(
name|count
operator|*
name|DEV_BSIZE
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|outsw
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_data
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
operator|)
argument_list|,
operator|(
name|count
operator|*
name|DEV_BSIZE
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_bc
operator|-=
name|DEV_BSIZE
operator|*
name|count
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_dkunit
operator|>=
literal|0
condition|)
block|{
comment|/* 		 * `wd's are blocks of 32 16-bit `word's according to 		 * iostat.  dk_wds[] is the one disk i/o statistic that 		 * we can record correctly. 		 * XXX perhaps we shouldn't record words for failed 		 * transfers. 		 */
name|dk_wds
index|[
name|du
operator|->
name|dk_dkunit
index|]
operator|+=
operator|(
name|count
operator|*
name|DEV_BSIZE
operator|)
operator|>>
literal|6
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Interrupt routine for the controller.  Acknowledge the interrupt, check for  * errors on the current operation, mark it done if necessary, and start  * the next request.  Also check for a partially done transfer, and  * continue with the next chunk if so.  */
end_comment

begin_function
name|void
name|wdintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|dmastat
decl_stmt|;
ifdef|#
directive|ifdef
name|CMD640
name|int
name|ctrlr_atapi
decl_stmt|;
if|if
condition|(
name|eide_quirks
operator|&
name|Q_CMD640B
condition|)
block|{
name|unit
operator|=
name|PRIMARY
expr_stmt|;
name|ctrlr_atapi
operator|=
name|atapictrlr
expr_stmt|;
block|}
else|else
block|{
name|ctrlr_atapi
operator|=
name|unit
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|==
literal|2
condition|)
return|return;
comment|/* intr in wdflushirq() */
if|if
condition|(
operator|!
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
condition|)
block|{
ifdef|#
directive|ifdef
name|WDDEBUG
comment|/* 		 * These happen mostly because the power-mgt part of the 		 * bios shuts us down, and we just manage to see the 		 * interrupt from the "SLEEP" command.  		 */
name|printf
argument_list|(
literal|"wdc%d: extra interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
ifdef|#
directive|ifdef
name|ATAPI
if|if
condition|(
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|==
literal|3
condition|)
block|{
comment|/* process an ATAPI interrupt */
ifdef|#
directive|ifdef
name|CMD640
if|if
condition|(
name|atapi_intr
operator|&&
name|atapi_intr
argument_list|(
name|ctrlr_atapi
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
name|atapi_intr
operator|&&
name|atapi_intr
argument_list|(
name|unit
argument_list|)
condition|)
endif|#
directive|endif
comment|/* ATAPI op continues */
return|return;
comment|/* controller is free, start new op */
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|wdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|wdtab
index|[
name|unit
index|]
operator|.
name|controller_queue
argument_list|)
expr_stmt|;
name|du
operator|=
name|wddrives
index|[
name|dkunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
comment|/* finish off DMA */
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_DMA
operator||
name|DKFL_USEDMA
operator|)
condition|)
block|{
comment|/* XXX SMP boxes sometimes generate an early intr.  Why? */
if|if
condition|(
operator|(
name|wddma
index|[
name|du
operator|->
name|dk_interface
index|]
operator|.
name|wdd_dmastatus
argument_list|(
name|du
operator|->
name|dk_dmacookie
argument_list|)
operator|&
name|WDDS_INTERRUPT
operator|)
operator|==
literal|0
condition|)
return|return;
name|dmastat
operator|=
name|wddma
index|[
name|du
operator|->
name|dk_interface
index|]
operator|.
name|wdd_dmadone
argument_list|(
name|du
operator|->
name|dk_dmacookie
argument_list|)
expr_stmt|;
block|}
name|du
operator|->
name|dk_timeout
operator|=
literal|0
expr_stmt|;
comment|/* check drive status/failure */
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdintr: timeout waiting for status"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_status
operator||=
name|WDCS_ERR
expr_stmt|;
comment|/* XXX */
block|}
comment|/* is it not a transfer, but a control operation? */
if|if
condition|(
name|du
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
block|{
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|wdcontrol
argument_list|(
name|bp
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return;
case|case
literal|1
case|:
name|wdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
goto|goto
name|done
goto|;
block|}
block|}
comment|/* have we an error? */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_status
operator|&
operator|(
name|WDCS_ERR
operator||
name|WDCS_ECCCOR
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_DMA
operator||
name|DKFL_SINGLE
operator|)
operator|)
operator|==
name|DKFL_DMA
operator|)
operator|&&
name|dmastat
operator|!=
name|WDDS_INTERRUPT
operator|)
condition|)
block|{
name|unsigned
name|int
name|errstat
decl_stmt|;
name|oops
label|:
comment|/* 		 * XXX bogus inb() here 		 */
name|errstat
operator|=
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_DMA
operator||
name|DKFL_SINGLE
operator|)
operator|)
operator|==
name|DKFL_DMA
operator|)
operator|&&
operator|(
name|errstat
operator|&
name|WDERR_ABORT
operator|)
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"reverting to PIO mode"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_USEDMA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_MULTI
operator|)
operator|&&
operator|(
name|errstat
operator|&
name|WDERR_ABORT
operator|)
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"reverting to non-multi sector mode"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_multi
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|du
operator|->
name|dk_status
operator|&
operator|(
name|WDCS_ERR
operator||
name|WDCS_ECCCOR
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_DMA
operator||
name|DKFL_SINGLE
operator|)
operator|)
operator|==
name|DKFL_DMA
operator|)
operator|&&
operator|(
name|dmastat
operator|!=
name|WDDS_INTERRUPT
operator|)
operator|)
condition|)
name|printf
argument_list|(
literal|"wd%d: DMA failure, DMA status %b\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|dmastat
argument_list|,
name|WDDS_BITS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdintr"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_ERROR
expr_stmt|;
goto|goto
name|outt
goto|;
block|}
ifdef|#
directive|ifdef
name|B_FORMAT
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FORMAT
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_BADSCAN
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
name|WDCS_ERR
condition|)
block|{
if|if
condition|(
operator|++
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
block|{
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"hard error"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* flag the error */
block|}
block|}
elseif|else
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
name|WDCS_ECCCOR
condition|)
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"soft ecc"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this was a successful read operation, fetch the data. 	 */
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_READ
operator||
name|B_ERROR
operator|)
operator|)
operator|==
name|B_READ
operator|)
operator|&&
operator|!
operator|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_DMA
operator||
name|DKFL_SINGLE
operator|)
operator|)
operator|==
name|DKFL_DMA
operator|)
operator|&&
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
condition|)
block|{
name|int
name|chk
decl_stmt|,
name|dummy
decl_stmt|,
name|multisize
decl_stmt|;
name|multisize
operator|=
name|chk
operator|=
name|du
operator|->
name|dk_currentiosize
operator|*
name|DEV_BSIZE
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_bc
operator|<
name|chk
condition|)
block|{
name|chk
operator|=
name|du
operator|->
name|dk_bc
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|chk
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|/
name|DEV_BSIZE
operator|)
operator|<
name|du
operator|->
name|dk_currentiosize
condition|)
block|{
name|du
operator|->
name|dk_currentiosize
operator|=
operator|(
name|chk
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|/
name|DEV_BSIZE
expr_stmt|;
name|multisize
operator|=
name|du
operator|->
name|dk_currentiosize
operator|*
name|DEV_BSIZE
expr_stmt|;
block|}
block|}
comment|/* ready to receive data? */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_status
operator|&
operator|(
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
operator|)
operator|)
operator|!=
operator|(
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
operator|)
condition|)
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdintr: read intr arrived early"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
argument_list|,
name|TIMEOUT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdintr: read error detected late"
argument_list|)
expr_stmt|;
goto|goto
name|oops
goto|;
block|}
comment|/* suck in data */
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
condition|)
name|insl
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_data
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
operator|)
argument_list|,
name|chk
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insw
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_data
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
operator|)
argument_list|,
name|chk
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_bc
operator|-=
name|chk
expr_stmt|;
comment|/* XXX for obsolete fractional sector reads. */
while|while
condition|(
name|chk
operator|<
name|multisize
condition|)
block|{
name|insw
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chk
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|du
operator|->
name|dk_dkunit
operator|>=
literal|0
condition|)
name|dk_wds
index|[
name|du
operator|->
name|dk_dkunit
index|]
operator|+=
name|chk
operator|>>
literal|6
expr_stmt|;
block|}
comment|/* final cleanup on DMA */
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_DMA
operator||
name|DKFL_SINGLE
operator|)
operator|)
operator|==
name|DKFL_DMA
operator|)
operator|&&
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
condition|)
block|{
name|int
name|iosize
decl_stmt|;
name|iosize
operator|=
name|du
operator|->
name|dk_currentiosize
operator|*
name|DEV_BSIZE
expr_stmt|;
name|du
operator|->
name|dk_bc
operator|-=
name|iosize
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_dkunit
operator|>=
literal|0
condition|)
name|dk_wds
index|[
name|du
operator|->
name|dk_dkunit
index|]
operator|+=
name|iosize
operator|>>
literal|6
expr_stmt|;
block|}
name|outt
label|:
if|if
condition|(
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_skip
operator|+=
name|du
operator|->
name|dk_currentiosize
expr_stmt|;
comment|/* add to successful sectors */
if|if
condition|(
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
condition|)
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"soft error"
argument_list|)
expr_stmt|;
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
comment|/* see if more to transfer */
if|if
condition|(
name|du
operator|->
name|dk_bc
operator|>
literal|0
operator|&&
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
operator|)
operator|||
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|wdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|du
operator|->
name|dk_timeout
operator|=
literal|1
operator|+
literal|3
expr_stmt|;
block|}
return|return;
comment|/* next chunk is started */
block|}
elseif|else
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_SINGLE
operator||
name|DKFL_ERROR
operator|)
operator|)
operator|==
name|DKFL_ERROR
condition|)
block|{
name|du
operator|->
name|dk_skip
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_ERROR
expr_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_SINGLE
expr_stmt|;
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|wdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
comment|/* redo xfer sector by sector */
block|}
block|}
name|done
label|:
empty_stmt|;
comment|/* done with this transfer, with or without error */
name|du
operator|->
name|dk_flags
operator|&=
operator|~
operator|(
name|DKFL_SINGLE
operator||
name|DKFL_DMA
operator|)
expr_stmt|;
name|bufq_remove
argument_list|(
operator|&
name|wdtab
index|[
name|unit
index|]
operator|.
name|controller_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
expr_stmt|;
name|wdutab
index|[
name|du
operator|->
name|dk_lunit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_skip
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|du
operator|->
name|dk_dkunit
operator|>=
literal|0
condition|)
block|{
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|du
operator|->
name|dk_dkunit
operator|)
expr_stmt|;
block|}
comment|/* controller idle */
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
comment|/* anything more on drive queue? */
name|wdustart
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* anything more for controller to do? */
ifndef|#
directive|ifndef
name|ATAPI
comment|/* This is not valid in ATAPI mode. */
if|if
condition|(
name|bufq_first
argument_list|(
operator|&
name|wdtab
index|[
name|unit
index|]
operator|.
name|controller_queue
argument_list|)
operator|!=
name|NULL
condition|)
endif|#
directive|endif
name|wdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a drive.  */
end_comment

begin_function
name|int
name|wdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|lunit
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|error
decl_stmt|;
name|lunit
operator|=
name|dkunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lunit
operator|>=
name|NWD
operator|||
name|dktype
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|du
operator|=
name|wddrives
index|[
name|lunit
index|]
expr_stmt|;
if|if
condition|(
name|du
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Finish flushing IRQs left over from wdattach(). */
ifdef|#
directive|ifdef
name|CMD640
if|if
condition|(
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr_cmd640
index|]
operator|.
name|b_active
operator|==
literal|2
condition|)
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr_cmd640
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|.
name|b_active
operator|==
literal|2
condition|)
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_BADSCAN
expr_stmt|;
comment|/* spin waiting for anybody else reading the disk label */
while|while
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_LABELLING
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|du
operator|->
name|dk_flags
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|,
literal|"wdopen"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|wdsleep
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|,
literal|"wdopn1"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_LABELLING
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
block|{
name|struct
name|disklabel
name|label
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|label
argument_list|,
sizeof|sizeof
name|label
argument_list|)
expr_stmt|;
name|label
operator|.
name|d_secsize
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
name|label
operator|.
name|d_nsectors
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|label
operator|.
name|d_ntracks
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
expr_stmt|;
name|label
operator|.
name|d_ncylinders
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
expr_stmt|;
name|label
operator|.
name|d_secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
expr_stmt|;
name|label
operator|.
name|d_secperunit
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
expr_stmt|;
name|error
operator|=
name|dsopen
argument_list|(
literal|"wd"
argument_list|,
name|dev
argument_list|,
name|fmt
argument_list|,
operator|&
name|du
operator|->
name|dk_slices
argument_list|,
operator|&
name|label
argument_list|,
name|wdstrategy1
argument_list|,
operator|(
name|ds_setgeom_t
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|wd_bdevsw
argument_list|,
operator|&
name|wd_cdevsw
argument_list|)
expr_stmt|;
block|}
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_LABELLING
expr_stmt|;
name|wdsleep
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|,
literal|"wdopn2"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
else|#
directive|else
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_BSDLABEL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * wdtab[ctrlr].b_active != 0 implies  XXX applicable now ?? 		 * drive_queue[lunit].b_act == NULL (?)  XXX applicable now ?? 		 * so the following guards most things (until the next i/o). 		 * It doesn't guard against a new i/o starting and being 		 * affected by the label being changed.  Sigh. 		 */
name|wdsleep
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|,
literal|"wdopn1"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_LABELLING
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
name|error
operator|=
name|dsinit
argument_list|(
name|dkmodpart
argument_list|(
name|dev
argument_list|,
name|RAW_PART
argument_list|)
argument_list|,
name|wdstrategy
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
operator|&
name|du
operator|->
name|dk_slices
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_LABELLING
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* XXX check value returned by wdwsetctlr(). */
name|wdwsetctlr
argument_list|(
name|du
argument_list|)
expr_stmt|;
if|if
condition|(
name|dkslice
argument_list|(
name|dev
argument_list|)
operator|==
name|WHOLE_DISK_SLICE
condition|)
block|{
name|dsopen
argument_list|(
name|dev
argument_list|,
name|fmt
argument_list|,
name|du
operator|->
name|dk_slices
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Read label using RAW_PART partition. 		 * 		 * If the drive has an MBR, then the current geometry (from 		 * wdgetctlr()) is used to read it; then the BIOS/DOS 		 * geometry is inferred and used to read the label off the 		 * 'c' partition.  Otherwise the label is read using the 		 * current geometry.  The label gives the final geometry. 		 * If bad sector handling is enabled, then this geometry 		 * is used to read the bad sector table.  The geometry 		 * changes occur inside readdisklabel() and are propagated 		 * to the driver by resetting the state machine. 		 * 		 * XXX can now handle changes directly since dsinit() doesn't 		 * do too much. 		 */
name|msg
operator|=
name|correct_readdisklabel
argument_list|(
name|dkmodpart
argument_list|(
name|dev
argument_list|,
name|RAW_PART
argument_list|)
argument_list|,
name|wdstrategy
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|)
expr_stmt|;
comment|/* XXX check value returned by wdwsetctlr(). */
name|wdwsetctlr
argument_list|(
name|du
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
operator|&&
name|du
operator|->
name|dk_dd
operator|.
name|d_flags
operator|&
name|D_BADSECT
condition|)
name|msg
operator|=
name|readbad144
argument_list|(
name|dkmodpart
argument_list|(
name|dev
argument_list|,
name|RAW_PART
argument_list|)
argument_list|,
name|wdstrategy
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
operator|&
name|du
operator|->
name|dk_bad
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_LABELLING
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wd%d: cannot find label (%s)\n"
argument_list|,
name|lunit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|!=
name|RAW_PART
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX needs translation */
comment|/* 			 * Soon return.  This is how slices without labels 			 * are allowed.  They only work on the raw partition. 			 */
block|}
else|else
block|{
name|unsigned
name|long
name|newsize
decl_stmt|,
name|offset
decl_stmt|,
name|size
decl_stmt|;
if|#
directive|if
literal|0
comment|/* 			 * Force RAW_PART partition to be the whole disk. 			 */
block|offset = du->dk_dd.d_partitions[RAW_PART].p_offset; 			if (offset != 0) { 				printf( 		"wd%d: changing offset of '%c' partition from %lu to 0\n", 				       du->dk_lunit, 'a' + RAW_PART, offset); 				du->dk_dd.d_partitions[RAW_PART].p_offset = 0; 			} 			size = du->dk_dd.d_partitions[RAW_PART].p_size; 			newsize = du->dk_dd.d_secperunit;
comment|/* XXX */
block|if (size != newsize) { 				printf( 		"wd%d: changing size of '%c' partition from %lu to %lu\n", 				       du->dk_lunit, 'a' + RAW_PART, size, 				       newsize); 				du->dk_dd.d_partitions[RAW_PART].p_size 					= newsize; 			}
endif|#
directive|endif
block|}
comment|/* Pick up changes made by readdisklabel(). */
name|wdsleep
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|,
literal|"wdopn2"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
block|}
comment|/* 	 * Warn if a partion is opened that overlaps another partition which 	 * is open unless one is the "raw" partition (whole disk). 	 */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_openpart
operator|&
name|mask
operator|)
operator|==
literal|0
operator|&&
name|part
operator|!=
name|RAW_PART
condition|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|pp
operator|=
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
expr_stmt|;
name|start
operator|=
name|pp
operator|->
name|p_offset
expr_stmt|;
name|end
operator|=
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
init|;
name|pp
operator|<
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|du
operator|->
name|dk_dd
operator|.
name|d_npartitions
index|]
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
operator|<=
name|start
operator|||
name|pp
operator|->
name|p_offset
operator|>=
name|end
condition|)
continue|continue;
if|if
condition|(
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|==
name|RAW_PART
condition|)
continue|continue;
if|if
condition|(
name|du
operator|->
name|dk_openpart
operator|&
operator|(
literal|1
operator|<<
operator|(
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wd%d%c: overlaps open partition (%c)\n"
argument_list|,
name|lunit
argument_list|,
name|part
operator|+
literal|'a'
argument_list|,
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|part
operator|>=
name|du
operator|->
name|dk_dd
operator|.
name|d_npartitions
operator|&&
name|part
operator|!=
name|RAW_PART
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dsopen
argument_list|(
name|dev
argument_list|,
name|fmt
argument_list|,
name|du
operator|->
name|dk_slices
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Implement operations other than read/write.  * Called from wdstart or wdintr during opens and formats.  * Uses finite-state-machine to track progress of operation in progress.  * Returns 0 if operation still in progress, 1 if completed, 2 if error.  */
end_comment

begin_function
specifier|static
name|int
name|wdcontrol
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|ctrlr
decl_stmt|;
name|du
operator|=
name|wddrives
index|[
name|dkunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|CMD640
name|ctrlr
operator|=
name|du
operator|->
name|dk_ctrlr_cmd640
expr_stmt|;
else|#
directive|else
name|ctrlr
operator|=
name|du
operator|->
name|dk_ctrlr
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|du
operator|->
name|dk_state
condition|)
block|{
case|case
name|WANTOPEN
case|:
name|tryagainrecal
label|:
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdcontrol: wdcommand failed"
argument_list|)
expr_stmt|;
goto|goto
name|maybe_retry
goto|;
block|}
name|du
operator|->
name|dk_state
operator|=
name|RECAL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RECAL
case|:
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
name|WDCS_ERR
operator|||
name|wdsetctlr
argument_list|(
name|du
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdcontrol: recal failed"
argument_list|)
expr_stmt|;
name|maybe_retry
label|:
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
name|WDCS_ERR
condition|)
name|wdunwedge
argument_list|(
name|du
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
if|if
condition|(
operator|++
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
goto|goto
name|tryagainrecal
goto|;
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
comment|/* XXX needs translation */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
comment|/* 		 * The rest of the initialization can be done by normal 		 * means. 		 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"wdcontrol"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait uninterruptibly until controller is not busy, then send it a command.  * The wait usually terminates immediately because we waited for the previous  * command to terminate.  */
end_comment

begin_function
specifier|static
name|int
name|wdcommand
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|u_int
name|cylinder
parameter_list|,
name|u_int
name|head
parameter_list|,
name|u_int
name|sector
parameter_list|,
name|u_int
name|count
parameter_list|,
name|u_int
name|command
parameter_list|)
block|{
name|u_int
name|wdc
decl_stmt|;
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|cfg_flags
operator|&
name|WDOPT_SLEEPHACK
condition|)
block|{
comment|/* OK, so the APM bios has put the disk into SLEEP mode, 		 * how can we tell ?  Uhm, we can't.  There is no  		 * standardized way of finding out, and the only way to 		 * wake it up is to reset it.  Bummer. 		 * 		 * All the many and varied versions of the IDE/ATA standard 		 * explicitly tells us not to look at these registers if 		 * the disk is in SLEEP mode.  Well, too bad really, we 		 * have to find out if it's in sleep mode before we can  		 * avoid reading the registers. 		 * 		 * I have reason to belive that most disks will return 		 * either 0xff or 0x00 in all but the status register  		 * when in SLEEP mode, but I have yet to see one return  		 * 0x00, so we don't check for that yet. 		 * 		 * The check for WDCS_BUSY is for the case where the 		 * bios spins up the disk for us, but doesn't initialize 		 * it correctly					/phk 		 */
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_precomp
argument_list|)
operator|+
name|inb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|)
operator|+
name|inb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|)
operator|+
name|inb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|)
operator|+
name|inb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|)
operator|+
name|inb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|)
operator|==
literal|6
operator|*
literal|0xff
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"wd(%d,%d): disk aSLEEP\n"
argument_list|,
name|du
operator|->
name|dk_ctrlr
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|)
expr_stmt|;
name|wdunwedge
argument_list|(
name|du
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|==
name|WDCS_BUSY
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"wd(%d,%d): disk is BUSY\n"
argument_list|,
name|du
operator|->
name|dk_ctrlr
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|)
expr_stmt|;
name|wdunwedge
argument_list|(
name|du
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|command
operator|==
name|WDCC_FEATURES
condition|)
block|{
name|outb
argument_list|(
name|wdc
operator|+
name|wd_features
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|WDFEA_SETXFER
condition|)
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
name|sector
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|wdc
operator|+
name|wd_precomp
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_precompcyl
operator|/
literal|4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
name|cylinder
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|,
name|cylinder
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|du
operator|->
name|dk_unit
operator|<<
literal|4
operator|)
operator||
name|head
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|,
name|sector
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
operator|(
name|command
operator|==
name|WDCC_DIAGNOSE
operator|||
name|command
operator|==
name|WDCC_IDC
operator|)
condition|?
literal|0
else|:
name|WDCS_READY
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wdsetmulti
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
comment|/* 	 * The config option flags low 8 bits define the maximum multi-block 	 * transfer size.  If the user wants the maximum that the drive 	 * is capable of, just set the low bits of the config option to 	 * 0x00ff. 	 */
if|if
condition|(
operator|(
name|du
operator|->
name|cfg_flags
operator|&
name|WDOPT_MULTIMASK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|du
operator|->
name|dk_multi
operator|>
literal|1
operator|)
condition|)
block|{
name|int
name|configval
init|=
name|du
operator|->
name|cfg_flags
operator|&
name|WDOPT_MULTIMASK
decl_stmt|;
name|du
operator|->
name|dk_multi
operator|=
name|min
argument_list|(
name|du
operator|->
name|dk_multi
argument_list|,
name|configval
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|du
operator|->
name|dk_multi
argument_list|,
name|WDCC_SET_MULTI
argument_list|)
condition|)
block|{
name|du
operator|->
name|dk_multi
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|du
operator|->
name|dk_multi
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|du
operator|->
name|dk_multi
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * issue IDC to drive to tell it just what geometry it is to be.  */
end_comment

begin_function
specifier|static
name|int
name|wdsetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"wd(%d,%d): wdsetctlr: C %lu H %lu S %lu\n"
argument_list|,
name|du
operator|->
name|dk_ctrlr
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|==
literal|0
operator|||
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|>
literal|16
condition|)
block|{
name|struct
name|wdparams
modifier|*
name|wp
decl_stmt|;
name|printf
argument_list|(
literal|"wd%d: can't handle %lu heads from partition table "
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
argument_list|)
expr_stmt|;
comment|/* obtain parameters */
name|wp
operator|=
operator|&
name|du
operator|->
name|dk_params
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|wdp_heads
operator|>
literal|0
operator|&&
name|wp
operator|->
name|wdp_heads
operator|<=
literal|16
condition|)
block|{
name|printf
argument_list|(
literal|"(controller value %u restored)\n"
argument_list|,
name|wp
operator|->
name|wdp_heads
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
name|wp
operator|->
name|wdp_heads
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"(truncating to 16)\n"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
literal|16
expr_stmt|;
block|}
block|}
if|if
condition|(
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|==
literal|0
operator|||
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|>
literal|255
condition|)
block|{
name|printf
argument_list|(
literal|"wd%d: cannot handle %lu sectors (max 255)\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|CMD640
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr_cmd640
index|]
operator|.
name|b_errcnt
operator|+=
name|RETRIES
expr_stmt|;
else|#
directive|else
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|.
name|b_errcnt
operator|+=
name|RETRIES
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
argument_list|,
name|WDCC_IDC
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wdsetctlr failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|wdsetmulti
argument_list|(
name|du
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NOTYET
comment|/* set read caching and write caching */
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDFEA_RCACHE
argument_list|,
name|WDCC_FEATURES
argument_list|)
expr_stmt|;
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
argument_list|,
name|TIMEOUT
argument_list|)
expr_stmt|;
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDFEA_WCACHE
argument_list|,
name|WDCC_FEATURES
argument_list|)
expr_stmt|;
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
argument_list|,
name|TIMEOUT
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Wait until driver is inactive, then set up controller.  */
end_comment

begin_endif
unit|static int wdwsetctlr(struct disk *du) { 	int	stat; 	int	x;  	wdsleep(du->dk_ctrlr, "wdwset"); 	x = splbio(); 	stat = wdsetctlr(du); 	wdflushirq(du, x); 	splx(x); 	return (stat); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * gross little callback function for wdddma interface. returns 1 for  * success, 0 for failure.  */
end_comment

begin_function
specifier|static
name|int
name|wdsetmode
parameter_list|(
name|int
name|mode
parameter_list|,
name|void
modifier|*
name|wdinfo
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|du
operator|=
name|wdinfo
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"wd%d: wdsetmode() setting transfer mode to %02x\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|i
operator|=
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|WDFEA_SETXFER
argument_list|,
name|WDCC_FEATURES
argument_list|)
operator|==
literal|0
operator|&&
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
argument_list|,
name|TIMEOUT
argument_list|)
operator|==
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/*  * issue READP to drive to ask it what it is.  */
end_comment

begin_function
specifier|static
name|int
name|wdgetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|tb
index|[
name|DEV_BSIZE
index|]
decl_stmt|,
name|tb2
index|[
name|DEV_BSIZE
index|]
decl_stmt|;
name|struct
name|wdparams
modifier|*
name|wp
init|=
name|NULL
decl_stmt|;
name|u_long
name|flags
init|=
name|du
operator|->
name|cfg_flags
decl_stmt|;
name|again
label|:
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_READP
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
argument_list|,
name|TIMEOUT
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * if we failed on the second try, assume non-32bit 		 */
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
condition|)
goto|goto
name|failed
goto|;
comment|/* XXX need to check error status after final transfer. */
comment|/* 		 * Old drives don't support WDCC_READP.  Try a seek to 0. 		 * Some IDE controllers return trash if there is no drive 		 * attached, so first test that the drive can be selected. 		 * This also avoids long waits for nonexistent drives. 		 */
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|outb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|du
operator|->
name|dk_unit
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* usually unnecessary; drive select is fast */
comment|/* 		 * Do this twice: may get a false WDCS_READY the first time. 		 */
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_status
argument_list|)
operator|&
operator|(
name|WDCS_BUSY
operator||
name|WDCS_READY
operator|)
operator|)
operator|!=
name|WDCS_READY
operator|||
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|,
name|TIMEOUT
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|du
operator|->
name|dk_unit
operator|==
name|bootinfo
operator|.
name|bi_n_bios_used
condition|)
block|{
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|=
name|bootinfo
operator|.
name|bi_bios_geom
index|[
name|du
operator|->
name|dk_unit
index|]
operator|&
literal|0xff
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
operator|(
operator|(
name|bootinfo
operator|.
name|bi_bios_geom
index|[
name|du
operator|->
name|dk_unit
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* XXX Why 2 ? */
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|=
operator|(
name|bootinfo
operator|.
name|bi_bios_geom
index|[
name|du
operator|->
name|dk_unit
index|]
operator|>>
literal|16
operator|)
operator|+
literal|2
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
expr_stmt|;
if|#
directive|if
literal|0
block|du->dk_dd.d_partitions[WDRAW].p_size = 				du->dk_dd.d_secperunit; 			du->dk_dd.d_type = DTYPE_ST506; 			du->dk_dd.d_subtype |= DSTYPE_GEOMETRY; 			strncpy(du->dk_dd.d_typename, "Bios geometry", 				sizeof du->dk_dd.d_typename); 			strncpy(du->dk_params.wdp_model, "ST506", 				sizeof du->dk_params.wdp_model);
endif|#
directive|endif
name|bootinfo
operator|.
name|bi_n_bios_used
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * Fake minimal drive geometry for reading the MBR. 		 * readdisklabel() may enlarge it to read the label and the 		 * bad sector table. 		 */
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|=
literal|17
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
literal|1
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|=
literal|1
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|=
literal|17
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|=
literal|17
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 		 * Fake maximal drive size for writing the label. 		 */
block|du->dk_dd.d_partitions[RAW_PART].p_size = 64 * 16 * 1024;
comment|/* 		 * Fake some more of the label for printing by disklabel(1) 		 * in case there is no real label. 		 */
block|du->dk_dd.d_type = DTYPE_ST506; 		du->dk_dd.d_subtype |= DSTYPE_GEOMETRY; 		strncpy(du->dk_dd.d_typename, "Fake geometry", 			sizeof du->dk_dd.d_typename);
endif|#
directive|endif
comment|/* Fake the model name for printing by wdattach(). */
name|strncpy
argument_list|(
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|,
literal|"unknown"
argument_list|,
sizeof|sizeof
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* obtain parameters */
name|wp
operator|=
operator|&
name|du
operator|->
name|dk_params
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
condition|)
name|insl
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
name|tb
argument_list|,
sizeof|sizeof
argument_list|(
name|tb
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insw
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
name|tb
argument_list|,
sizeof|sizeof
argument_list|(
name|tb
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* try 32-bit data path (VLB IDE controller) */
if|if
condition|(
name|flags
operator|&
name|WDOPT_32BIT
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|tb
argument_list|,
name|tb2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wdparams
argument_list|)
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_32BIT
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* check that we really have 32-bit controller */
if|if
condition|(
name|bcmp
argument_list|(
name|tb
argument_list|,
name|tb2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wdparams
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|failed
label|:
comment|/* test failed, use 16-bit i/o mode */
name|bcopy
argument_list|(
name|tb2
argument_list|,
name|tb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wdparams
argument_list|)
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_32BIT
expr_stmt|;
block|}
block|}
name|bcopy
argument_list|(
name|tb
argument_list|,
name|wp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wdparams
argument_list|)
argument_list|)
expr_stmt|;
comment|/* shuffle string byte order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|wp
operator|->
name|wdp_model
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|u_short
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|wp
operator|->
name|wdp_model
operator|+
name|i
operator|)
expr_stmt|;
operator|*
name|p
operator|=
name|ntohs
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clean up the wdp_model by converting nulls to spaces, and 	 * then removing the trailing spaces. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|wp
operator|->
name|wdp_model
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wp
operator|->
name|wdp_model
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|wp
operator|->
name|wdp_model
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|wp
operator|->
name|wdp_model
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|wp
operator|->
name|wdp_model
index|[
name|i
index|]
operator|==
literal|' '
condition|;
name|i
operator|--
control|)
block|{
name|wp
operator|->
name|wdp_model
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	 * find out the drives maximum multi-block transfer capability 	 */
name|du
operator|->
name|dk_multi
operator|=
name|wp
operator|->
name|wdp_nsecperint
operator|&
literal|0xff
expr_stmt|;
name|wdsetmulti
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* 	 * check drive's DMA capability 	 */
if|if
condition|(
name|wddma
index|[
name|du
operator|->
name|dk_interface
index|]
operator|.
name|wdd_candma
condition|)
block|{
name|du
operator|->
name|dk_dmacookie
operator|=
name|wddma
index|[
name|du
operator|->
name|dk_interface
index|]
operator|.
name|wdd_candma
argument_list|(
name|du
operator|->
name|dk_port
argument_list|,
name|du
operator|->
name|dk_ctrlr
argument_list|)
expr_stmt|;
comment|/* does user want this? */
if|if
condition|(
operator|(
name|du
operator|->
name|cfg_flags
operator|&
name|WDOPT_DMA
operator|)
operator|&&
comment|/* have we got a DMA controller? */
name|du
operator|->
name|dk_dmacookie
operator|&&
comment|/* can said drive do DMA? */
name|wddma
index|[
name|du
operator|->
name|dk_interface
index|]
operator|.
name|wdd_dmainit
argument_list|(
name|du
operator|->
name|dk_dmacookie
argument_list|,
name|wp
argument_list|,
name|wdsetmode
argument_list|,
name|du
argument_list|)
condition|)
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_USEDMA
expr_stmt|;
block|}
block|}
else|else
block|{
name|du
operator|->
name|dk_dmacookie
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"\nwd(%d,%d): wdgetctlr: gc %x cyl %d trk %d sec %d type %d sz %d model %s\n"
argument_list|,
name|du
operator|->
name|dk_ctrlr
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|wp
operator|->
name|wdp_config
argument_list|,
name|wp
operator|->
name|wdp_cylinders
argument_list|,
name|wp
operator|->
name|wdp_heads
argument_list|,
name|wp
operator|->
name|wdp_sectors
argument_list|,
name|wp
operator|->
name|wdp_buffertype
argument_list|,
name|wp
operator|->
name|wdp_buffersize
argument_list|,
name|wp
operator|->
name|wdp_model
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* update disklabel given drive information */
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|=
name|wp
operator|->
name|wdp_cylinders
expr_stmt|;
comment|/* +- 1 */
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
name|wp
operator|->
name|wdp_heads
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|=
name|wp
operator|->
name|wdp_sectors
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
expr_stmt|;
if|if
condition|(
name|WDOPT_FORCEHD
argument_list|(
name|du
operator|->
name|cfg_flags
argument_list|)
condition|)
block|{
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
name|WDOPT_FORCEHD
argument_list|(
name|du
operator|->
name|cfg_flags
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|du->dk_dd.d_partitions[RAW_PART].p_size = du->dk_dd.d_secperunit;
comment|/* dubious ... */
block|bcopy("ESDI/IDE", du->dk_dd.d_typename, 9); 	bcopy(wp->wdp_model + 20, du->dk_dd.d_packname, 14 - 1);
comment|/* better ... */
block|du->dk_dd.d_type = DTYPE_ESDI; 	du->dk_dd.d_subtype |= DSTYPE_GEOMETRY;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|dsclose
argument_list|(
name|dev
argument_list|,
name|fmt
argument_list|,
name|wddrives
index|[
name|dkunit
argument_list|(
name|dev
argument_list|)
index|]
operator|->
name|dk_slices
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|lunit
init|=
name|dkunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|format_op
modifier|*
name|fop
decl_stmt|;
endif|#
directive|endif
name|du
operator|=
name|wddrives
index|[
name|lunit
index|]
expr_stmt|;
name|wdsleep
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|,
literal|"wdioct"
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsioctl
argument_list|(
literal|"wd"
argument_list|,
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flags
argument_list|,
operator|&
name|du
operator|->
name|dk_slices
argument_list|,
name|wdstrategy1
argument_list|,
operator|(
name|ds_setgeom_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCSBADSCAN
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
condition|)
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_BADSCAN
expr_stmt|;
else|else
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_BADSCAN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|notyet
case|case
name|DIOCWFORMAT
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|fop
operator|=
operator|(
expr|struct
name|format_op
operator|*
operator|)
name|addr
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|fop
operator|->
name|df_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|fop
operator|->
name|df_startblk
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
error|#
directive|error
comment|/* XXX the 386BSD interface is different */
name|error
operator|=
name|physio
argument_list|(
name|wdformat
argument_list|,
operator|&
name|rwdbuf
index|[
name|lunit
index|]
argument_list|,
literal|0
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
name|fop
operator|->
name|df_count
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|fop
operator|->
name|df_reg
index|[
literal|0
index|]
operator|=
name|du
operator|->
name|dk_status
expr_stmt|;
name|fop
operator|->
name|df_reg
index|[
literal|1
index|]
operator|=
name|du
operator|->
name|dk_error
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|B_FORMAT
end_ifdef

begin_function
name|int
name|wdformat
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_FORMAT
expr_stmt|;
name|wdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * phk put this here, better that return(wdstrategy(bp)); 	 * XXX 	 */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|wdsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|lunit
decl_stmt|;
name|lunit
operator|=
name|dkunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lunit
operator|>=
name|NWD
operator|||
name|dktype
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|du
operator|=
name|wddrives
index|[
name|lunit
index|]
expr_stmt|;
if|if
condition|(
name|du
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|dssize
argument_list|(
name|dev
argument_list|,
operator|&
name|du
operator|->
name|dk_slices
argument_list|,
name|wdopen
argument_list|,
name|wdclose
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump core after a system crash.  */
end_comment

begin_function
name|int
name|wddump
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|long
name|num
decl_stmt|;
comment|/* number of sectors to write */
name|int
name|lunit
decl_stmt|,
name|part
decl_stmt|;
name|long
name|blkoff
decl_stmt|,
name|blknum
decl_stmt|;
name|long
name|blkchk
decl_stmt|,
name|blkcnt
decl_stmt|,
name|blknext
decl_stmt|;
name|long
name|cylin
decl_stmt|,
name|head
decl_stmt|,
name|sector
decl_stmt|;
name|long
name|secpertrk
decl_stmt|,
name|secpercyl
decl_stmt|,
name|nblocks
decl_stmt|;
name|u_long
name|ds_offset
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
specifier|static
name|int
name|wddoingadump
init|=
literal|0
decl_stmt|;
comment|/* Toss any characters present prior to dump. */
while|while
condition|(
name|cncheckc
argument_list|()
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
comment|/* Check for acceptable device. */
comment|/* XXX should reset to maybe allow du->dk_state< OPEN. */
name|lunit
operator|=
name|dkunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* eventually support floppies? */
name|part
operator|=
name|dkpart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lunit
operator|>=
name|NWD
operator|||
operator|(
name|du
operator|=
name|wddrives
index|[
name|lunit
index|]
operator|)
operator|==
name|NULL
operator|||
name|du
operator|->
name|dk_state
operator|<
name|OPEN
operator|||
operator|(
name|lp
operator|=
name|dsgetlabel
argument_list|(
name|dev
argument_list|,
name|du
operator|->
name|dk_slices
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Size of memory to dump, in disk sectors. */
name|num
operator|=
operator|(
name|u_long
operator|)
name|Maxmem
operator|*
name|PAGE_SIZE
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
name|secpertrk
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
expr_stmt|;
name|nblocks
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
expr_stmt|;
name|blkoff
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
expr_stmt|;
comment|/* XXX */
name|ds_offset
operator|=
name|du
operator|->
name|dk_slices
operator|->
name|dss_slices
index|[
name|dkslice
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|ds_offset
expr_stmt|;
name|blkoff
operator|+=
name|ds_offset
expr_stmt|;
if|#
directive|if
literal|0
block|pg("part %x, nblocks %d, dumplo %d num %d\n", 	   part, nblocks, dumplo, num);
endif|#
directive|endif
comment|/* Check transfer bounds against partition size. */
if|if
condition|(
name|dumplo
operator|<
literal|0
operator|||
name|dumplo
operator|+
name|num
operator|>
name|nblocks
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Check if we are being called recursively. */
if|if
condition|(
name|wddoingadump
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|#
directive|if
literal|0
comment|/* Mark controller active for if we panic during the dump. */
block|wdtab[du->dk_ctrlr].b_active = 1;
endif|#
directive|endif
name|wddoingadump
operator|=
literal|1
expr_stmt|;
comment|/* Recalibrate the drive. */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* ATA spec XXX NOT */
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|,
name|TIMEOUT
argument_list|)
operator|!=
literal|0
operator|||
name|wdsetctlr
argument_list|(
name|du
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wddump: recalibrate failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_SINGLE
expr_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|blknum
operator|=
name|dumplo
operator|+
name|blkoff
expr_stmt|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|blkcnt
operator|=
name|num
expr_stmt|;
if|if
condition|(
name|blkcnt
operator|>
name|MAXTRANSFER
condition|)
name|blkcnt
operator|=
name|MAXTRANSFER
expr_stmt|;
comment|/* Keep transfer within current cylinder. */
if|if
condition|(
operator|(
name|blknum
operator|+
name|blkcnt
operator|-
literal|1
operator|)
operator|/
name|secpercyl
operator|!=
name|blknum
operator|/
name|secpercyl
condition|)
name|blkcnt
operator|=
name|secpercyl
operator|-
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
expr_stmt|;
name|blknext
operator|=
name|blknum
operator|+
name|blkcnt
expr_stmt|;
comment|/* 		 * See if one of the sectors is in the bad sector list 		 * (if we have one).  If the first sector is bad, then 		 * reduce the transfer to this one bad sector; if another 		 * sector is bad, then reduce reduce the transfer to 		 * avoid any bad sectors. 		 */
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
operator|&&
name|dsgetbad
argument_list|(
name|dev
argument_list|,
name|du
operator|->
name|dk_slices
argument_list|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|blkchk
operator|=
name|blknum
init|;
name|blkchk
operator|<
name|blknum
operator|+
name|blkcnt
condition|;
name|blkchk
operator|++
control|)
block|{
name|daddr_t
name|blknew
decl_stmt|;
name|blknew
operator|=
name|transbad144
argument_list|(
name|dsgetbad
argument_list|(
name|dev
argument_list|,
name|du
operator|->
name|dk_slices
argument_list|)
argument_list|,
name|blkchk
operator|-
name|ds_offset
argument_list|)
operator|+
name|ds_offset
expr_stmt|;
if|if
condition|(
name|blknew
operator|!=
name|blkchk
condition|)
block|{
comment|/* Found bad block. */
name|blkcnt
operator|=
name|blkchk
operator|-
name|blknum
expr_stmt|;
if|if
condition|(
name|blkcnt
operator|>
literal|0
condition|)
block|{
name|blknext
operator|=
name|blknum
operator|+
name|blkcnt
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|blkcnt
operator|=
literal|1
expr_stmt|;
name|blknext
operator|=
name|blknum
operator|+
name|blkcnt
expr_stmt|;
if|#
directive|if
literal|1
operator|||
name|defined
argument_list|(
name|WDDEBUG
argument_list|)
name|printf
argument_list|(
literal|"bad block %lu -> %lu\n"
argument_list|,
name|blknum
argument_list|,
name|blknew
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
name|out
label|:
comment|/* Compute disk address. */
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Let's just talk about this first... */
block|pg("cylin l%d head %ld sector %ld addr 0x%x count %ld", 		   cylin, head, sector, addr, blkcnt);
endif|#
directive|endif
comment|/* Do the write. */
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
name|cylin
argument_list|,
name|head
argument_list|,
name|sector
argument_list|,
name|blkcnt
argument_list|,
name|WDCC_WRITE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wddump: timeout waiting to to give command"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
while|while
condition|(
name|blkcnt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|is_physical_memory
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|)
condition|)
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|CADDR1
argument_list|,
name|trunc_page
argument_list|(
name|addr
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|CADDR1
argument_list|,
name|trunc_page
argument_list|(
literal|0
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Ready to send data? */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* ATA spec */
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wddump: timeout waiting for DRQ"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
condition|)
name|outsl
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
name|CADDR1
operator|+
operator|(
operator|(
name|int
operator|)
name|addr
operator|&
name|PAGE_MASK
operator|)
argument_list|,
name|DEV_BSIZE
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|outsw
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
name|CADDR1
operator|+
operator|(
operator|(
name|int
operator|)
name|addr
operator|&
name|PAGE_MASK
operator|)
argument_list|,
name|DEV_BSIZE
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|DEV_BSIZE
expr_stmt|;
comment|/* 			 * If we are dumping core, it may take a while. 			 * So reassure the user and hold off any watchdogs. 			 */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|addr
operator|%
operator|(
literal|1024
operator|*
literal|1024
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HW_WDOG
if|if
condition|(
name|wdog_tickler
condition|)
call|(
modifier|*
name|wdog_tickler
call|)
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HW_WDOG */
name|printf
argument_list|(
literal|"%ld "
argument_list|,
name|num
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|/
name|DEV_BSIZE
operator|)
argument_list|)
expr_stmt|;
block|}
name|num
operator|--
expr_stmt|;
name|blkcnt
operator|--
expr_stmt|;
block|}
comment|/* Wait for completion. */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* ATA spec XXX NOT */
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wddump: timeout waiting for status"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Check final status. */
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
operator|(
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
operator||
name|WDCS_ERR
operator|)
operator|!=
operator|(
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator|)
condition|)
block|{
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wddump: extra DRQ, or error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Update block count. */
name|blknum
operator|=
name|blknext
expr_stmt|;
comment|/* Operator aborting dump? */
if|if
condition|(
name|cncheckc
argument_list|()
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wderror
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"wd%d: %s:\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
else|else
name|diskerr
argument_list|(
name|bp
argument_list|,
literal|"wd"
argument_list|,
name|mesg
argument_list|,
name|LOG_PRINTF
argument_list|,
name|du
operator|->
name|dk_skip
argument_list|,
name|dsgetlabel
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|,
name|du
operator|->
name|dk_slices
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wd%d: status %b error %b\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|du
operator|->
name|dk_status
argument_list|,
name|WDCS_BITS
argument_list|,
name|du
operator|->
name|dk_error
argument_list|,
name|WDERR_BITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Discard any interrupts that were latched by the interrupt system while  * we were doing polled i/o.  */
end_comment

begin_function
specifier|static
name|void
name|wdflushirq
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|int
name|old_ipl
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CMD640
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr_cmd640
index|]
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|splx
argument_list|(
name|old_ipl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splbio
argument_list|()
expr_stmt|;
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr_cmd640
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|splx
argument_list|(
name|old_ipl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splbio
argument_list|()
expr_stmt|;
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Reset the controller.  */
end_comment

begin_function
specifier|static
name|int
name|wdreset
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_DMA
operator||
name|DKFL_USEDMA
operator|)
operator|)
operator|&&
name|du
operator|->
name|dk_dmacookie
condition|)
name|wddma
index|[
name|du
operator|->
name|dk_interface
index|]
operator|.
name|wdd_dmadone
argument_list|(
name|du
operator|->
name|dk_dmacookie
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
name|TIMEOUT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|du
operator|->
name|dk_altport
argument_list|,
name|WDCTL_IDS
operator||
name|WDCTL_RST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|du
operator|->
name|dk_altport
argument_list|,
name|WDCTL_IDS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATAPI
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|,
name|TIMEOUT
argument_list|)
operator|!=
literal|0
condition|)
name|err
operator|=
literal|1
expr_stmt|;
comment|/* no IDE drive found */
name|du
operator|->
name|dk_error
operator|=
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_error
operator|!=
literal|0x01
condition|)
name|err
operator|=
literal|1
expr_stmt|;
comment|/* the drive is incompatible */
else|#
directive|else
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|,
name|TIMEOUT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"wdreset: error1: 0x%x\n"
argument_list|,
name|du
operator|->
name|dk_error
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|outb
argument_list|(
name|du
operator|->
name|dk_altport
argument_list|,
name|WDCTL_4BIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sleep until driver is inactive.  * This is used only for avoiding rare race conditions, so it is unimportant  * that the sleep may be far too short or too long.  */
end_comment

begin_function
specifier|static
name|void
name|wdsleep
parameter_list|(
name|int
name|ctrlr
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|CMD640
if|if
condition|(
name|eide_quirks
operator|&
name|Q_CMD640B
condition|)
name|ctrlr
operator|=
name|PRIMARY
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_active
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_active
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|,
name|wmesg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wdtimeout
parameter_list|(
name|void
modifier|*
name|cdu
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|x
decl_stmt|;
specifier|static
name|int
name|timeouts
decl_stmt|;
name|du
operator|=
operator|(
expr|struct
name|disk
operator|*
operator|)
name|cdu
expr_stmt|;
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_timeout
operator|!=
literal|0
operator|&&
operator|--
name|du
operator|->
name|dk_timeout
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timeouts
operator|++
operator|<=
literal|5
condition|)
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
operator|(
name|timeouts
operator|>
literal|5
operator|)
condition|?
literal|"Last time I say: interrupt timeout.  Probably a portable PC."
else|:
literal|"interrupt timeout"
expr_stmt|;
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_dmacookie
condition|)
name|printf
argument_list|(
literal|"wd%d: wdtimeout() DMA status %b\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|wddma
index|[
name|du
operator|->
name|dk_interface
index|]
operator|.
name|wdd_dmastatus
argument_list|(
name|du
operator|->
name|dk_dmacookie
argument_list|)
argument_list|,
name|WDDS_BITS
argument_list|)
expr_stmt|;
block|}
name|wdunwedge
argument_list|(
name|du
argument_list|)
expr_stmt|;
name|wdflushirq
argument_list|(
name|du
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_skip
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_SINGLE
expr_stmt|;
name|wdstart
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
name|wdtimeout
argument_list|,
name|cdu
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the controller after it has become wedged.  This is different from  * wdreset() so that wdreset() can be used in the probe and so that this  * can restore the geometry .  */
end_comment

begin_function
specifier|static
name|int
name|wdunwedge
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|du1
decl_stmt|;
name|int
name|lunit
decl_stmt|;
comment|/* Schedule other drives for recalibration. */
for|for
control|(
name|lunit
operator|=
literal|0
init|;
name|lunit
operator|<
name|NWD
condition|;
name|lunit
operator|++
control|)
if|if
condition|(
operator|(
name|du1
operator|=
name|wddrives
index|[
name|lunit
index|]
operator|)
operator|!=
name|NULL
operator|&&
name|du1
operator|!=
name|du
operator|&&
name|du1
operator|->
name|dk_ctrlr
operator|==
name|du
operator|->
name|dk_ctrlr
operator|&&
name|du1
operator|->
name|dk_state
operator|>
name|WANTOPEN
condition|)
name|du1
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
name|DELAY
argument_list|(
name|RECOVERYTIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdreset
argument_list|(
name|du
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * XXX - recalibrate current drive now because some callers 		 * aren't prepared to have its state change. 		 */
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
operator|==
literal|0
operator|&&
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|,
name|TIMEOUT
argument_list|)
operator|==
literal|0
operator|&&
name|wdsetctlr
argument_list|(
name|du
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wdunwedge failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait uninterruptibly until controller is not busy and either certain  * status bits are set or an error has occurred.  * The wait is usually short unless it is for the controller to process  * an entire critical command.  * Return 1 for (possibly stale) controller errors, -1 for timeout errors,  * or 0 for no errors.  * Return controller status in du->dk_status and, if there was a controller  * error, return the error code in du->dk_error.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WD_COUNT_RETRIES
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|min_retries
index|[
name|NWDC
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|wdwait
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|u_char
name|bits_wanted
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|wdc
decl_stmt|;
name|u_char
name|status
decl_stmt|;
define|#
directive|define
name|POLLING
value|1000
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
name|timeout
operator|+=
name|POLLING
expr_stmt|;
comment|/*  * This delay is really too long, but does not impact the performance  * as much when using the multi-sector option.  Shorter delays have  * caused I/O errors on some drives and system configs.  This should  * probably be fixed if we develop a better short term delay mechanism.  */
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|WD_COUNT_RETRIES
if|if
condition|(
name|min_retries
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|>
name|timeout
operator|||
name|min_retries
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|==
literal|0
condition|)
name|min_retries
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|=
name|timeout
expr_stmt|;
endif|#
directive|endif
name|du
operator|->
name|dk_status
operator|=
name|status
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATAPI
comment|/* 		 * Atapi drives have a very interesting feature, when attached 		 * as a slave on the IDE bus, and there is no master. 		 * They release the bus after getting the command. 		 * We should reselect the drive here to get the status. 		 */
if|if
condition|(
name|status
operator|==
literal|0xff
condition|)
block|{
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
name|du
operator|->
name|dk_unit
operator|<<
literal|4
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_status
operator|=
name|status
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|WDCS_BUSY
operator|)
condition|)
block|{
if|if
condition|(
name|status
operator|&
name|WDCS_ERR
condition|)
block|{
name|du
operator|->
name|dk_error
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
expr_stmt|;
comment|/* 				 * We once returned here.  This is wrong 				 * because the error bit is apparently only 				 * valid after the controller has interrupted 				 * (e.g., the error bit is stale when we wait 				 * for DRQ for writes).  So we can't depend 				 * on the error bit at all when polling for 				 * command completion. 				 */
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|bits_wanted
operator|)
operator|==
name|bits_wanted
condition|)
block|{
return|return
operator|(
name|status
operator|&
name|WDCS_ERR
operator|)
return|;
block|}
block|}
if|if
condition|(
name|timeout
operator|<
name|TIMEOUT
condition|)
comment|/* 			 * Switch to a polling rate of about 1 KHz so that 			 * the timeout is almost machine-independent.  The 			 * controller is taking a long time to respond, so 			 * an extra msec won't matter. 			 */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
else|else
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|timeout
operator|!=
literal|0
condition|)
do|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|wd_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|wd_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
if|if
condition|(
operator|!
name|wd_devsw_installed
condition|)
block|{
if|if
condition|(
name|wd_bdevsw
operator|.
name|d_maxio
operator|==
literal|0
condition|)
name|wd_bdevsw
operator|.
name|d_maxio
operator|=
literal|248
operator|*
literal|512
expr_stmt|;
name|bdevsw_add_generic
argument_list|(
name|BDEV_MAJOR
argument_list|,
name|CDEV_MAJOR
argument_list|,
operator|&
name|wd_bdevsw
argument_list|)
expr_stmt|;
name|wd_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|wddev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|wd_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NWDC> 0 */
end_comment

end_unit

