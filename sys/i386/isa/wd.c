begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)wd.c	7.2 (Berkeley) 5/9/91  *	$Id: wd.c,v 1.69 1995/03/16 18:12:08 bde Exp $  */
end_comment

begin_comment
comment|/* TODO:  *	o Bump error count after timeout.  *	o Satisfy ATA timing in all cases.  *	o Finish merging berry/sos timeout code (bump error count...).  *	o Merge/fix TIH/NetBSD bad144 code.  *	o Don't use polling except for initialization.  Need to  *	  reorganize the state machine.  Then "extra" interrupts  *	  shouldn't happen (except maybe one for initialization).  *	o Fix disklabel, boot and driver inconsistencies with  *	  bad144 in standard versions.  *	o Support extended DOS partitions.  *	o Support swapping to DOS partitions.  *	o Handle bad sectors, clustering, disklabelling, DOS  *	  partitions and swapping driver-independently.  Use  *	  i386/dkbad.c for bad sectors.  Swapping will need new  *	  driver entries for polled reinit and polled write).  */
end_comment

begin_include
include|#
directive|include
file|"wd.h"
end_include

begin_if
if|#
directive|if
name|NWDC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkbad.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskslice.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bootinfo.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<i386/i386/cons.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/wdreg.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_define
define|#
directive|define
name|TIMEOUT
value|10000
end_define

begin_define
define|#
directive|define
name|RETRIES
value|5
end_define

begin_comment
comment|/* number of retries before giving up */
end_comment

begin_define
define|#
directive|define
name|RECOVERYTIME
value|500000
end_define

begin_comment
comment|/* usec for controller to recover after err */
end_comment

begin_define
define|#
directive|define
name|MAXTRANSFER
value|255
end_define

begin_comment
comment|/* max size of transfer in sectors */
end_comment

begin_comment
comment|/* correct max is 256 but some controllers */
end_comment

begin_comment
comment|/* can't handle that in all cases */
end_comment

begin_define
define|#
directive|define
name|BAD144_NO_CYL
value|0xffff
end_define

begin_comment
comment|/* XXX should be in dkbad.h; bad144.c uses -1 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NSECS_MULTI
end_ifndef

begin_define
define|#
directive|define
name|NSECS_MULTI
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_define
define|#
directive|define
name|wdnoreloc
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x80)
end_define

begin_comment
comment|/* ignore partition table */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|wddospart
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x40)
end_define

begin_comment
comment|/* use dos partitions */
end_comment

begin_define
define|#
directive|define
name|wdunit
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev)& 0x38)>> 3)
end_define

begin_define
define|#
directive|define
name|wdpart
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x7)
end_define

begin_define
define|#
directive|define
name|makewddev
parameter_list|(
name|maj
parameter_list|,
name|unit
parameter_list|,
name|part
parameter_list|)
value|(makedev(maj,((unit<<3)+part)))
end_define

begin_define
define|#
directive|define
name|WDRAW
value|3
end_define

begin_comment
comment|/* XXX must be 2 */
end_comment

begin_comment
comment|/* Cylinder number for doing IO to.  Shares an entry in the buf struct. */
end_comment

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_function_decl
specifier|static
name|int
name|wd_goaway
parameter_list|(
name|struct
name|kern_devconf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdc_goaway
parameter_list|(
name|struct
name|kern_devconf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wd_externalize
parameter_list|(
name|struct
name|proc
modifier|*
parameter_list|,
name|struct
name|kern_devconf
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdc_externalize
parameter_list|(
name|struct
name|proc
modifier|*
parameter_list|,
name|struct
name|kern_devconf
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Templates for the kern_devconf structures used when we attach.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|kdc_wd
index|[
name|NWD
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* filled in by kern_devconf.c */
literal|"wd"
block|,
literal|0
block|,
block|{
name|MDDT_DISK
block|,
literal|0
block|}
block|,
name|wd_externalize
block|,
literal|0
block|,
name|wd_goaway
block|,
name|DISK_EXTERNALLEN
block|,
literal|0
block|,
comment|/* parent */
literal|0
block|,
comment|/* parentdata */
name|DC_UNKNOWN
block|,
comment|/* don't support state yet */
literal|"ST506/ESDI/IDE disk"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|kdc_wdc
index|[
name|NWDC
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* filled in by kern_devconf.c */
literal|"wdc"
block|,
literal|0
block|,
block|{
name|MDDT_ISA
block|,
literal|0
block|}
block|,
name|isa_generic_externalize
block|,
literal|0
block|,
name|wdc_goaway
block|,
name|ISA_EXTERNALLEN
block|,
operator|&
name|kdc_isa0
block|,
comment|/* parent */
literal|0
block|,
comment|/* parentdata */
name|DC_UNKNOWN
block|,
comment|/* state */
literal|"ST506/ESDI/IDE disk controller"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|wd_registerdev
parameter_list|(
name|int
name|ctlr
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
if|if
condition|(
name|unit
operator|!=
literal|0
condition|)
name|kdc_wd
index|[
name|unit
index|]
operator|=
name|kdc_wd
index|[
literal|0
index|]
expr_stmt|;
name|kdc_wd
index|[
name|unit
index|]
operator|.
name|kdc_unit
operator|=
name|unit
expr_stmt|;
name|kdc_wd
index|[
name|unit
index|]
operator|.
name|kdc_parent
operator|=
operator|&
name|kdc_wdc
index|[
name|ctlr
index|]
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|kdc_wd
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|wdc_registerdev
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
if|if
condition|(
name|unit
operator|!=
literal|0
condition|)
name|kdc_wdc
index|[
name|unit
index|]
operator|=
name|kdc_wdc
index|[
literal|0
index|]
expr_stmt|;
name|kdc_wdc
index|[
name|unit
index|]
operator|.
name|kdc_unit
operator|=
name|unit
expr_stmt|;
name|kdc_wdc
index|[
name|unit
index|]
operator|.
name|kdc_parentdata
operator|=
name|dvp
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|kdc_wdc
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wdc_goaway
parameter_list|(
name|struct
name|kern_devconf
modifier|*
name|kdc
parameter_list|,
name|int
name|force
parameter_list|)
block|{
if|if
condition|(
name|force
condition|)
block|{
name|dev_detach
argument_list|(
name|kdc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|EBUSY
return|;
comment|/* XXX fix */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wd_goaway
parameter_list|(
name|struct
name|kern_devconf
modifier|*
name|kdc
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|dev_detach
argument_list|(
name|kdc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This biotab field doubles as a field for the physical unit number on  * the controller.  */
end_comment

begin_define
define|#
directive|define
name|id_physid
value|id_scsiid
end_define

begin_comment
comment|/*  * Drive states.  Used to initialize drive.  */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|0
end_define

begin_comment
comment|/* disk is closed. */
end_comment

begin_define
define|#
directive|define
name|WANTOPEN
value|1
end_define

begin_comment
comment|/* open requested, not started */
end_comment

begin_define
define|#
directive|define
name|RECAL
value|2
end_define

begin_comment
comment|/* doing restore */
end_comment

begin_define
define|#
directive|define
name|OPEN
value|3
end_define

begin_comment
comment|/* done with open */
end_comment

begin_comment
comment|/*  * The structure of a disk drive.  */
end_comment

begin_struct
struct|struct
name|disk
block|{
name|long
name|dk_bc
decl_stmt|;
comment|/* byte count left */
name|short
name|dk_skip
decl_stmt|;
comment|/* blocks already transferred */
name|char
name|dk_ctrlr
decl_stmt|;
comment|/* physical controller number */
name|char
name|dk_unit
decl_stmt|;
comment|/* physical unit number */
name|char
name|dk_lunit
decl_stmt|;
comment|/* logical unit number */
name|char
name|dk_state
decl_stmt|;
comment|/* control state */
name|u_char
name|dk_status
decl_stmt|;
comment|/* copy of status reg. */
name|u_char
name|dk_error
decl_stmt|;
comment|/* copy of error reg. */
name|u_char
name|dk_timeout
decl_stmt|;
comment|/* countdown to next timeout */
name|short
name|dk_port
decl_stmt|;
comment|/* i/o port base */
name|u_long
name|dk_copenpart
decl_stmt|;
comment|/* character units open on this drive */
name|u_long
name|dk_bopenpart
decl_stmt|;
comment|/* block units open on this drive */
name|u_long
name|dk_openpart
decl_stmt|;
comment|/* all units open on this drive */
name|short
name|dk_wlabel
decl_stmt|;
comment|/* label writable? */
name|short
name|dk_flags
decl_stmt|;
comment|/* drive characteistics found */
define|#
directive|define
name|DKFL_DOSPART
value|0x00001
comment|/* has DOS partition table */
define|#
directive|define
name|DKFL_SINGLE
value|0x00004
comment|/* sector at a time mode */
define|#
directive|define
name|DKFL_ERROR
value|0x00008
comment|/* processing a disk error */
define|#
directive|define
name|DKFL_BSDLABEL
value|0x00010
comment|/* has a BSD disk label */
define|#
directive|define
name|DKFL_BADSECT
value|0x00020
comment|/* has a bad144 badsector table */
define|#
directive|define
name|DKFL_WRITEPROT
value|0x00040
comment|/* manual unit write protect */
define|#
directive|define
name|DKFL_LABELLING
value|0x00080
comment|/* readdisklabel() in progress */
define|#
directive|define
name|DKFL_32BIT
value|0x00100
comment|/* use 32-bit i/o mode */
define|#
directive|define
name|DKFL_MULTI
value|0x00200
comment|/* use multi-i/o mode */
name|struct
name|wdparams
name|dk_params
decl_stmt|;
comment|/* ESDI/IDE drive/controller parameters */
name|int
name|dk_dkunit
decl_stmt|;
comment|/* number of statistics purposes */
name|struct
name|disklabel
name|dk_dd
decl_stmt|;
comment|/* device configuration data */
name|struct
name|disklabel
name|dk_dd2
decl_stmt|;
comment|/* DOS view converted to label */
name|struct
name|dos_partition
name|dk_dospartitions
index|[
name|NDOSPART
index|]
decl_stmt|;
comment|/* DOS view of disk */
name|struct
name|dkbad
name|dk_bad
decl_stmt|;
comment|/* bad sector table */
name|int
name|dk_multi
decl_stmt|;
comment|/* multi transfers */
name|int
name|dk_currentiosize
decl_stmt|;
comment|/* current io size */
name|long
name|dk_badsect
index|[
literal|127
index|]
decl_stmt|;
comment|/* 126 plus trailing -1 marker */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|WD_COUNT_RETRIES
end_define

begin_decl_stmt
specifier|static
name|int
name|wdtest
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|disk
modifier|*
name|wddrives
index|[
name|NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of units */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buf
name|wdtab
index|[
name|NWDC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|buf
name|wdutab
index|[
name|NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of queue per drive */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|buf
name|rwdbuf
index|[
name|NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers for raw IO */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|long
name|wdxfer
index|[
name|NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of transfers */
end_comment

begin_function_decl
specifier|static
name|void
name|bad144intern
parameter_list|(
name|struct
name|disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wdustart
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wdstart
parameter_list|(
name|int
name|ctrlr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdcontrol
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdcommand
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|u_int
name|cylinder
parameter_list|,
name|u_int
name|head
parameter_list|,
name|u_int
name|sector
parameter_list|,
name|u_int
name|count
parameter_list|,
name|u_int
name|command
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdsetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdwsetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdgetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wderror
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wdflushirq
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|int
name|old_ipl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdreset
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wdsleep
parameter_list|(
name|int
name|ctrlr
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|wdtimeout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|wdunwedge
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdwait
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|u_char
name|bits_wanted
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Provide hw.devconf information.  */
end_comment

begin_function
specifier|static
name|int
name|wd_externalize
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|kern_devconf
modifier|*
name|kdc
parameter_list|,
name|void
modifier|*
name|userp
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|disk_externalize
argument_list|(
name|wddrives
index|[
name|kdc
operator|->
name|kdc_unit
index|]
operator|->
name|dk_unit
argument_list|,
name|userp
argument_list|,
operator|&
name|len
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|isa_driver
name|wdcdriver
init|=
block|{
name|wdprobe
block|,
name|wdattach
block|,
literal|"wdc"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Probe for controller.  */
end_comment

begin_function
specifier|static
name|int
name|wdprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NWDC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|du
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|du
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
name|du
argument_list|,
sizeof|sizeof
expr|*
name|du
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_ctrlr
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
name|du
operator|->
name|dk_port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
comment|/* check if we have registers that work */
name|outb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_cyl_lo
argument_list|,
literal|0xa5
argument_list|)
expr_stmt|;
comment|/* wd_cyl_lo is read/write */
if|if
condition|(
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_cyl_lo
argument_list|)
operator|==
literal|0xff
condition|)
goto|goto
name|nodevice
goto|;
if|if
condition|(
name|wdreset
argument_list|(
name|du
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|DELAY
argument_list|(
name|RECOVERYTIME
argument_list|)
operator|,
name|wdreset
argument_list|(
name|du
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|nodevice
goto|;
comment|/* execute a controller only command */
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_DIAGNOSE
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nodevice
goto|;
comment|/* 	 * drive(s) did not time out during diagnostic : 	 * Get error status and check that both drives are OK. 	 * Table 9-2 of ATA specs suggests that we must check for  	 * a value of 0x01  	 * 	 * Strangely, some controllers will return a status of 	 * 0x81 (drive 0 OK, drive 1 failure), and then when 	 * the DRV bit is set, return status of 0x01 (OK) for 	 * drive 2.  (This seems to contradict the ATA spec.) 	 */
name|du
operator|->
name|dk_error
operator|=
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_error
argument_list|)
expr_stmt|;
comment|/* printf("Error : %x\n", du->dk_error); */
if|if
condition|(
name|du
operator|->
name|dk_error
operator|!=
literal|0x01
condition|)
block|{
if|if
condition|(
name|du
operator|->
name|dk_error
operator|&
literal|0x80
condition|)
block|{
comment|/* drive 1 failure */
comment|/* first set the DRV bit */
name|u_int
name|sdh
decl_stmt|;
name|sdh
operator|=
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_sdh
argument_list|)
expr_stmt|;
name|sdh
operator|=
name|sdh
operator||
literal|0x10
expr_stmt|;
name|outb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_sdh
argument_list|,
name|sdh
argument_list|)
expr_stmt|;
comment|/* Wait, to make sure drv 1 has completed diags */
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nodevice
goto|;
comment|/* Get status for drive 1 */
name|du
operator|->
name|dk_error
operator|=
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_error
argument_list|)
expr_stmt|;
comment|/* printf("Error (drv 1) : %x\n", du->dk_error); */
if|if
condition|(
name|du
operator|->
name|dk_error
operator|!=
literal|0x01
condition|)
goto|goto
name|nodevice
goto|;
block|}
else|else
comment|/* drive 0 fail */
goto|goto
name|nodevice
goto|;
block|}
name|free
argument_list|(
name|du
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|IO_WDCSIZE
operator|)
return|;
name|nodevice
label|:
name|free
argument_list|(
name|du
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach each drive if possible.  */
end_comment

begin_function
specifier|static
name|int
name|wdattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|lunit
decl_stmt|;
name|struct
name|isa_device
modifier|*
name|wdup
decl_stmt|;
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
if|if
condition|(
name|dvp
operator|->
name|id_unit
operator|>=
name|NWDC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|wdc_registerdev
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
for|for
control|(
name|wdup
operator|=
name|isa_biotab_wdc
init|;
name|wdup
operator|->
name|id_driver
operator|!=
literal|0
condition|;
name|wdup
operator|++
control|)
block|{
if|if
condition|(
name|wdup
operator|->
name|id_iobase
operator|!=
name|dvp
operator|->
name|id_iobase
condition|)
continue|continue;
name|lunit
operator|=
name|wdup
operator|->
name|id_unit
expr_stmt|;
if|if
condition|(
name|lunit
operator|>=
name|NWD
condition|)
continue|continue;
name|unit
operator|=
name|wdup
operator|->
name|id_physid
expr_stmt|;
name|du
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|du
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|wddrives
index|[
name|lunit
index|]
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"drive attached twice"
argument_list|)
expr_stmt|;
name|wddrives
index|[
name|lunit
index|]
operator|=
name|du
expr_stmt|;
name|bzero
argument_list|(
name|du
argument_list|,
sizeof|sizeof
expr|*
name|du
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_ctrlr
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
name|du
operator|->
name|dk_unit
operator|=
name|unit
expr_stmt|;
name|du
operator|->
name|dk_lunit
operator|=
name|lunit
expr_stmt|;
name|du
operator|->
name|dk_port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
block|{
comment|/* Initialize the badsect list to indicate no */
comment|/* bad sectors. */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|127
condition|;
name|i
operator|++
control|)
name|du
operator|->
name|dk_badsect
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 		 * Print out description of drive. 		 * wdp_model can be [0..40] bytes, thus \0 can be missing so 		 * so copy it and add a null before printing. 		 */
if|if
condition|(
name|wdgetctlr
argument_list|(
name|du
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|bcopy
argument_list|(
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"wdc%d: unit %d (wd%d):<%s>"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|unit
argument_list|,
name|lunit
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
condition|)
name|printf
argument_list|(
literal|", 32-bit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_multi
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|", multi-block-%d"
argument_list|,
name|du
operator|->
name|dk_multi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_params
operator|.
name|wdp_heads
operator|==
literal|0
operator|&&
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|>
literal|100
condition|)
name|printf
argument_list|(
literal|"wd%d: size unknown, using BIOS values: "
argument_list|,
name|lunit
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|du
operator|->
name|dk_params
operator|.
name|wdp_heads
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"wd%d: size unknown: "
argument_list|,
name|lunit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"wd%d: %luMB (%lu sectors), "
argument_list|,
name|lunit
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%lu C %lu H %lu S/T %lu B/S\n"
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
argument_list|)
expr_stmt|;
comment|/* 		     * Start timeout routine for this drive. 		     * XXX timeout should be per controller. 		     */
name|wdtimeout
argument_list|(
operator|(
name|caddr_t
operator|)
name|du
argument_list|)
expr_stmt|;
name|wd_registerdev
argument_list|(
name|dvp
operator|->
name|id_unit
argument_list|,
name|lunit
argument_list|)
expr_stmt|;
if|if
condition|(
name|dk_ndrive
operator|<
name|DK_NDRIVE
condition|)
block|{
name|sprintf
argument_list|(
name|dk_names
index|[
name|dk_ndrive
index|]
argument_list|,
literal|"wd%d"
argument_list|,
name|lunit
argument_list|)
expr_stmt|;
name|dk_wpms
index|[
name|dk_ndrive
index|]
operator|=
operator|(
literal|8
operator|*
literal|1024
operator|*
literal|1024
operator|/
literal|2
operator|)
expr_stmt|;
name|du
operator|->
name|dk_dkunit
operator|=
name|dk_ndrive
operator|++
expr_stmt|;
block|}
else|else
block|{
name|du
operator|->
name|dk_dkunit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|free
argument_list|(
name|du
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|wddrives
index|[
name|lunit
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Discard any interrupts generated by wdgetctlr().  wdflushirq() 	 * doesn't work now because the ambient ipl is too high. 	 */
name|wdtab
index|[
name|dvp
operator|->
name|id_unit
index|]
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read/write routine for a buffer.  Finds the proper unit, range checks  * arguments, and schedules the transfer.  Does not wait for the transfer  * to complete.  Multi-page transfers are supported.  All I/O requests must  * be a multiple of a sector in length.  */
end_comment

begin_function
name|void
name|wdstrategy
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|lunit
init|=
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* valid unit, controller, and request?  */
if|if
condition|(
name|lunit
operator|>=
name|NWD
operator|||
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|||
operator|(
name|du
operator|=
name|wddrives
index|[
name|lunit
index|]
operator|)
operator|==
name|NULL
operator|||
name|bp
operator|->
name|b_bcount
operator|%
name|DEV_BSIZE
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISKLABEL_UNPROTECTED
argument_list|)
comment|/* "soft" write protect check */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_WRITEPROT
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
comment|/* !defined(DISKLABEL_UNPROTECTED) */
comment|/* 	 * Do bounds checking, adjust transfer, and set b_cylin. 	 */
if|if
condition|(
name|bounds_check_with_label
argument_list|(
name|bp
argument_list|,
name|wddospart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
condition|?
operator|&
name|du
operator|->
name|dk_dd2
else|:
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
name|du
operator|->
name|dk_wlabel
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Check for *any* block on this transfer being on the bad block list 	 * if it is, then flag the block as a transfer that requires 	 * bad block handling.  Also, used as a hint for low level disksort 	 * clustering code to keep from coalescing a bad transfer into 	 * a normal transfer.  Single block transfers for a large number of 	 * blocks associated with a cluster I/O are undersirable. 	 */
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_BADSECT
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nsecs
init|=
name|howmany
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|DEV_BSIZE
argument_list|)
decl_stmt|;
name|int
name|blkend
init|=
name|bp
operator|->
name|b_pblkno
operator|+
name|nsecs
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|du
operator|->
name|dk_badsect
index|[
name|i
index|]
operator|!=
operator|-
literal|1
operator|&&
name|du
operator|->
name|dk_badsect
index|[
name|i
index|]
operator|<
name|blkend
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|du
operator|->
name|dk_badsect
index|[
name|i
index|]
operator|>=
name|bp
operator|->
name|b_pblkno
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_BAD
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* queue transfer on drive, activate drive and controller if idle */
name|dp
operator|=
operator|&
name|wdutab
index|[
name|lunit
index|]
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
name|wdustart
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* start drive */
comment|/* Pick up changes made by readdisklabel(). */
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_LABELLING
operator|&&
name|du
operator|->
name|dk_state
operator|>
name|RECAL
condition|)
block|{
name|wdsleep
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|,
literal|"wdlab"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
block|}
if|if
condition|(
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|.
name|b_active
operator|==
literal|0
condition|)
name|wdstart
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|)
expr_stmt|;
comment|/* start controller */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|done
label|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* toss transfer, we're done early */
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to queue a command to the controller.  The unit's  * request is linked into the active list for the controller.  * If the controller is idle, the transfer is started.  */
end_comment

begin_function
specifier|static
name|void
name|wdustart
parameter_list|(
specifier|register
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
init|=
operator|&
name|wdutab
index|[
name|du
operator|->
name|dk_lunit
index|]
decl_stmt|;
name|int
name|ctrlr
init|=
name|du
operator|->
name|dk_ctrlr
decl_stmt|;
comment|/* unit already active? */
if|if
condition|(
name|dp
operator|->
name|b_active
condition|)
return|return;
comment|/* anything to start? */
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
name|bp
operator|->
name|b_actf
operator|=
name|NULL
expr_stmt|;
comment|/* link onto controller queue */
if|if
condition|(
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_actf
operator|==
name|NULL
condition|)
block|{
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_actf
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
operator|*
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_actb
operator|=
name|bp
expr_stmt|;
block|}
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_actb
operator|=
operator|&
name|bp
operator|->
name|b_actf
expr_stmt|;
comment|/* mark the drive unit as busy */
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Controller startup routine.  This does the calculation, and starts  * a single-sector read or write operation.  Called to start a transfer,  * or from the interrupt routine to continue a multi-sector transfer.  * RESTRICTIONS:  * 1. The transfer length must be an exact multiple of the sector size.  */
end_comment

begin_function
specifier|static
name|void
name|wdstart
parameter_list|(
name|int
name|ctrlr
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|bt_bad
modifier|*
name|bt_ptr
decl_stmt|;
name|long
name|blknum
decl_stmt|,
name|cylin
decl_stmt|,
name|head
decl_stmt|,
name|sector
decl_stmt|;
name|long
name|secpertrk
decl_stmt|,
name|secpercyl
decl_stmt|;
name|int
name|lunit
decl_stmt|;
name|int
name|count
decl_stmt|;
name|loop
label|:
comment|/* is there a drive for the controller to do a transfer with? */
name|bp
operator|=
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return;
comment|/* obtain controller and drive information */
name|lunit
operator|=
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|du
operator|=
name|wddrives
index|[
name|lunit
index|]
expr_stmt|;
comment|/* if not really a transfer, do control operations specially */
if|if
condition|(
name|du
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
block|{
if|if
condition|(
name|du
operator|->
name|dk_state
operator|!=
name|WANTOPEN
condition|)
name|printf
argument_list|(
literal|"wd%d: wdstart: weird dk_state %d\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|du
operator|->
name|dk_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdcontrol
argument_list|(
name|bp
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"wd%d: wdstart: wdcontrol returned nonzero, state = %d\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|du
operator|->
name|dk_state
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* calculate transfer details */
name|blknum
operator|=
name|bp
operator|->
name|b_pblkno
operator|+
name|du
operator|->
name|dk_skip
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"wd%d: wdstart: %s %d@%d; map "
argument_list|,
name|lunit
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %d)%x"
argument_list|,
name|du
operator|->
name|dk_skip
argument_list|,
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_altsts
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lp
operator|=
operator|&
name|du
operator|->
name|dk_dd
expr_stmt|;
name|secpertrk
operator|=
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|secpercyl
operator|=
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|du
operator|->
name|dk_dkunit
operator|>=
literal|0
condition|)
block|{
name|dk_wds
index|[
name|du
operator|->
name|dk_dkunit
index|]
operator|+=
name|bp
operator|->
name|b_bcount
operator|>>
literal|6
expr_stmt|;
block|}
name|du
operator|->
name|dk_bc
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BAD
comment|/* 		     * XXX handle large transfers inefficiently instead 		     * of crashing on them. 		     */
operator|||
name|howmany
argument_list|(
name|du
operator|->
name|dk_bc
argument_list|,
name|DEV_BSIZE
argument_list|)
operator|>
name|MAXTRANSFER
condition|)
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_SINGLE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_SINGLE
operator||
name|DKFL_BADSECT
operator|)
operator|)
comment|/* 19 Aug 92*/
operator|==
operator|(
name|DKFL_SINGLE
operator||
name|DKFL_BADSECT
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|du
operator|->
name|dk_badsect
index|[
name|i
index|]
operator|!=
operator|-
literal|1
operator|&&
name|du
operator|->
name|dk_badsect
index|[
name|i
index|]
operator|<=
name|blknum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|du
operator|->
name|dk_badsect
index|[
name|i
index|]
operator|==
name|blknum
condition|)
block|{
comment|/* 			 * XXX the offset of the bad sector table ought 			 * to be stored in the in-core copy of the table. 			 */
define|#
directive|define
name|BAD144_PART
value|2
comment|/* XXX scattered magic numbers */
define|#
directive|define
name|BSD_PART
value|0
comment|/* XXX should be 2 but bad144.c uses 0 */
if|if
condition|(
name|lp
operator|->
name|d_partitions
index|[
name|BSD_PART
index|]
operator|.
name|p_offset
operator|!=
literal|0
condition|)
name|blknum
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|BAD144_PART
index|]
operator|.
name|p_offset
operator|+
name|lp
operator|->
name|d_partitions
index|[
name|BAD144_PART
index|]
operator|.
name|p_size
expr_stmt|;
else|else
name|blknum
operator|=
name|lp
operator|->
name|d_secperunit
expr_stmt|;
name|blknum
operator|-=
name|lp
operator|->
name|d_nsectors
operator|+
name|i
operator|+
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
comment|/* mark controller active */
comment|/* if starting a multisector transfer, or doing single transfers */
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
operator|||
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
operator|)
condition|)
block|{
name|u_int
name|command
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
if|if
condition|(
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_errcnt
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
name|du
operator|->
name|dk_bc
operator|+=
name|DEV_BSIZE
expr_stmt|;
name|count
operator|=
name|howmany
argument_list|(
name|du
operator|->
name|dk_bc
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_MULTI
expr_stmt|;
ifdef|#
directive|ifdef
name|B_FORMAT
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FORMAT
condition|)
block|{
name|command
operator|=
name|WDCC_FORMAT
expr_stmt|;
name|count
operator|=
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|sector
operator|=
name|lp
operator|->
name|d_gap3
operator|-
literal|1
expr_stmt|;
comment|/* + 1 later */
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
condition|)
block|{
name|command
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|WDCC_READ
else|:
name|WDCC_WRITE
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|du
operator|->
name|dk_currentiosize
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|count
operator|>
literal|1
operator|)
operator|&&
operator|(
name|du
operator|->
name|dk_multi
operator|>
literal|1
operator|)
condition|)
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_MULTI
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|command
operator|=
name|WDCC_READ_MULTI
expr_stmt|;
block|}
else|else
block|{
name|command
operator|=
name|WDCC_WRITE_MULTI
expr_stmt|;
block|}
name|du
operator|->
name|dk_currentiosize
operator|=
name|du
operator|->
name|dk_multi
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_currentiosize
operator|>
name|count
condition|)
name|du
operator|->
name|dk_currentiosize
operator|=
name|count
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|command
operator|=
name|WDCC_READ
expr_stmt|;
block|}
else|else
block|{
name|command
operator|=
name|WDCC_WRITE
expr_stmt|;
block|}
name|du
operator|->
name|dk_currentiosize
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * XXX this loop may never terminate.  The code to handle 		 * counting down of retries and eventually failing the i/o 		 * is in wdintr() and we can't get there from here. 		 */
if|if
condition|(
name|wdtest
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|wdtest
operator|==
literal|0
condition|)
block|{
name|wdtest
operator|=
literal|100
expr_stmt|;
name|printf
argument_list|(
literal|"dummy wdunwedge\n"
argument_list|)
expr_stmt|;
name|wdunwedge
argument_list|(
name|du
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|du
operator|->
name|dk_dkunit
operator|>=
literal|0
condition|)
block|{
name|dk_busy
operator||=
literal|1
operator|<<
name|du
operator|->
name|dk_dkunit
expr_stmt|;
block|}
while|while
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
name|cylin
argument_list|,
name|head
argument_list|,
name|sector
argument_list|,
name|count
argument_list|,
name|command
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdstart: timeout waiting to give command"
argument_list|)
expr_stmt|;
name|wdunwedge
argument_list|(
name|du
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"cylin %ld head %ld sector %ld addr %x sts %x\n"
argument_list|,
name|cylin
argument_list|,
name|head
argument_list|,
name|sector
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
argument_list|,
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_altsts
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Schedule wdtimeout() to wake up after a few seconds.  Retrying 	 * unmarked bad blocks can take 3 seconds!  Then it is not good that 	 * we retry 5 times. 	 * 	 * XXX wdtimeout() doesn't increment the error count so we may loop 	 * forever.  More seriously, the loop isn't forever but causes a 	 * crash. 	 * 	 * TODO fix b_resid bug elsewhere (fd.c....).  Fix short but positive 	 * counts being discarded after there is an error (in physio I 	 * think).  Discarding them would be OK if the (special) file offset 	 * was not advanced. 	 */
name|du
operator|->
name|dk_timeout
operator|=
literal|1
operator|+
literal|3
expr_stmt|;
comment|/* If this is a read operation, just go away until it's done. */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
return|return;
comment|/* Ready to send data? */
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdstart: timeout waiting for DRQ"
argument_list|)
expr_stmt|;
comment|/* 		 * XXX what do we do now?  If we've just issued the command, 		 * then we can treat this failure the same as a command 		 * failure.  But if we are continuing a multi-sector write, 		 * the command was issued ages ago, so we can't simply 		 * restart it. 		 * 		 * XXX we waste a lot of time unnecessarily translating block 		 * numbers to cylin/head/sector for continued i/o's. 		 */
block|}
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_MULTI
condition|)
block|{
name|count
operator|=
name|howmany
argument_list|(
name|du
operator|->
name|dk_bc
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|du
operator|->
name|dk_multi
condition|)
name|count
operator|=
name|du
operator|->
name|dk_multi
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_currentiosize
operator|>
name|count
condition|)
name|du
operator|->
name|dk_currentiosize
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
condition|)
name|outsl
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
operator|)
argument_list|,
operator|(
name|count
operator|*
name|DEV_BSIZE
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|outsw
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
operator|)
argument_list|,
operator|(
name|count
operator|*
name|DEV_BSIZE
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_bc
operator|-=
name|DEV_BSIZE
operator|*
name|count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Interrupt routine for the controller.  Acknowledge the interrupt, check for  * errors on the current operation, mark it done if necessary, and start  * the next request.  Also check for a partially done transfer, and  * continue with the next chunk if so.  */
end_comment

begin_function
name|void
name|wdintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|==
literal|2
condition|)
return|return;
comment|/* intr in wdflushirq() */
if|if
condition|(
operator|!
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
condition|)
block|{
name|printf
argument_list|(
literal|"wdc%d: extra interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|=
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_actf
expr_stmt|;
name|du
operator|=
name|wddrives
index|[
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|dp
operator|=
operator|&
name|wdutab
index|[
name|du
operator|->
name|dk_lunit
index|]
expr_stmt|;
name|du
operator|->
name|dk_timeout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdintr: timeout waiting for status"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_status
operator||=
name|WDCS_ERR
expr_stmt|;
comment|/* XXX */
block|}
comment|/* is it not a transfer, but a control operation? */
if|if
condition|(
name|du
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
block|{
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|wdcontrol
argument_list|(
name|bp
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return;
case|case
literal|1
case|:
name|wdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
goto|goto
name|done
goto|;
block|}
block|}
comment|/* have we an error? */
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
operator|(
name|WDCS_ERR
operator||
name|WDCS_ECCCOR
operator|)
condition|)
block|{
name|oops
label|:
if|if
condition|(
operator|(
name|du
operator|->
name|dk_status
operator|&
name|DKFL_MULTI
operator|)
operator|&&
operator|(
name|inb
argument_list|(
name|du
operator|->
name|dk_port
argument_list|)
operator|&
name|WDERR_ABORT
operator|)
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"reverting to non-multi sector mode"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_multi
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WDDEBUG
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdintr"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_ERROR
expr_stmt|;
goto|goto
name|outt
goto|;
block|}
ifdef|#
directive|ifdef
name|B_FORMAT
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FORMAT
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
comment|/* error or error correction? */
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
name|WDCS_ERR
condition|)
block|{
if|if
condition|(
operator|++
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
block|{
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"hard error"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* flag the error */
block|}
block|}
else|else
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"soft ecc"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this was a successful read operation, fetch the data. 	 */
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_READ
operator||
name|B_ERROR
operator|)
operator|)
operator|==
name|B_READ
operator|)
operator|&&
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
condition|)
block|{
name|int
name|chk
decl_stmt|,
name|dummy
decl_stmt|,
name|multisize
decl_stmt|;
name|multisize
operator|=
name|chk
operator|=
name|du
operator|->
name|dk_currentiosize
operator|*
name|DEV_BSIZE
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_bc
operator|<
name|chk
condition|)
block|{
name|chk
operator|=
name|du
operator|->
name|dk_bc
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|chk
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|/
name|DEV_BSIZE
operator|)
operator|<
name|du
operator|->
name|dk_currentiosize
condition|)
block|{
name|du
operator|->
name|dk_currentiosize
operator|=
operator|(
name|chk
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|/
name|DEV_BSIZE
expr_stmt|;
name|multisize
operator|=
name|du
operator|->
name|dk_currentiosize
operator|*
name|DEV_BSIZE
expr_stmt|;
block|}
block|}
comment|/* ready to receive data? */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_status
operator|&
operator|(
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
operator|)
operator|)
operator|!=
operator|(
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
operator|)
condition|)
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdintr: read intr arrived early"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
argument_list|,
name|TIMEOUT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdintr: read error detected late"
argument_list|)
expr_stmt|;
goto|goto
name|oops
goto|;
block|}
comment|/* suck in data */
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
condition|)
name|insl
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
operator|)
argument_list|,
name|chk
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insw
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
operator|)
argument_list|,
name|chk
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_bc
operator|-=
name|chk
expr_stmt|;
comment|/* XXX for obsolete fractional sector reads. */
while|while
condition|(
name|chk
operator|<
name|multisize
condition|)
block|{
name|insw
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chk
operator|+=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
block|}
block|}
name|wdxfer
index|[
name|du
operator|->
name|dk_lunit
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_dkunit
operator|>=
literal|0
condition|)
block|{
name|dk_xfer
index|[
name|du
operator|->
name|dk_dkunit
index|]
operator|++
expr_stmt|;
name|dk_seek
index|[
name|du
operator|->
name|dk_dkunit
index|]
operator|++
expr_stmt|;
comment|/* bogus, but we don't know the */
comment|/*   real number */
block|}
name|outt
label|:
if|if
condition|(
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_skip
operator|+=
name|du
operator|->
name|dk_currentiosize
expr_stmt|;
comment|/* add to successful sectors */
if|if
condition|(
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
condition|)
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"soft error"
argument_list|)
expr_stmt|;
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
comment|/* see if more to transfer */
if|if
condition|(
name|du
operator|->
name|dk_bc
operator|>
literal|0
operator|&&
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
operator|)
operator|||
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|wdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|du
operator|->
name|dk_timeout
operator|=
literal|1
operator|+
literal|3
expr_stmt|;
block|}
return|return;
comment|/* next chunk is started */
block|}
elseif|else
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_SINGLE
operator||
name|DKFL_ERROR
operator|)
operator|)
operator|==
name|DKFL_ERROR
condition|)
block|{
name|du
operator|->
name|dk_skip
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_ERROR
expr_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_SINGLE
expr_stmt|;
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|wdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
comment|/* redo xfer sector by sector */
block|}
block|}
name|done
label|:
empty_stmt|;
comment|/* done with this transfer, with or without error */
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_SINGLE
expr_stmt|;
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|-
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_skip
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|du
operator|->
name|dk_dkunit
operator|>=
literal|0
condition|)
block|{
name|dk_busy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|du
operator|->
name|dk_dkunit
operator|)
expr_stmt|;
block|}
comment|/* controller idle */
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
comment|/* anything more on drive queue? */
name|wdustart
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* anything more for controller to do? */
if|if
condition|(
name|wdtab
index|[
name|unit
index|]
operator|.
name|b_actf
condition|)
name|wdstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a drive.  */
end_comment

begin_function
name|int
name|wdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|lunit
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|part
init|=
name|wdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|mask
init|=
literal|1
operator|<<
name|part
decl_stmt|;
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|struct
name|disklabel
name|save_label
decl_stmt|;
name|lunit
operator|=
name|wdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lunit
operator|>=
name|NWD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|du
operator|=
name|wddrives
index|[
name|lunit
index|]
expr_stmt|;
if|if
condition|(
name|du
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Finish flushing IRQs left over from wdattach(). */
if|if
condition|(
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|.
name|b_active
operator|==
literal|2
condition|)
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
comment|/* 	 * That's all for valid DOS partitions.  We don't need a BSD label. 	 * The openmask is only used for checking BSD partitions so we don't 	 * need to maintain it. 	 */
if|if
condition|(
name|wddospart
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* XXX we do need a disklabel for now. */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_BSDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|part
operator|>
name|NDOSPART
condition|?
name|ENXIO
else|:
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_LABELLING
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|du
operator|->
name|dk_flags
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|,
literal|"wdopen"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_BSDLABEL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * wdtab[ctrlr].b_active != 0 implies 		 * wdutab[lunit].b_actf == NULL (?) 		 * so the following guards most things (until the next i/o). 		 * It doesn't guard against a new i/o starting and being 		 * affected by the label being changed.  Sigh. 		 */
name|wdsleep
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|,
literal|"wdopn1"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_LABELLING
operator||
name|DKFL_WRITEPROT
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
name|wdutab
index|[
name|lunit
index|]
operator|.
name|b_actf
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Read label using WDRAW partition. 		 * 		 * If the drive has an MBR, then the current geometry (from 		 * wdgetctlr()) is used to read it; then the BIOS/DOS 		 * geometry is inferred and used to read the label off the 		 * 'c' partition.  Otherwise the label is read using the 		 * current geometry.  The label gives the final geometry. 		 * If bad sector handling is enabled, then this geometry 		 * is used to read the bad sector table.  The geometry 		 * changes occur inside readdisklabel() and are propagated 		 * to the driver by resetting the state machine. 		 */
name|save_label
operator|=
name|du
operator|->
name|dk_dd
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|WDRAW
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|WDRAW
index|]
operator|.
name|p_size
operator|=
literal|0x7fffffff
expr_stmt|;
comment|/* XXX */
name|msg
operator|=
name|readdisklabel
argument_list|(
name|makewddev
argument_list|(
name|major
argument_list|(
name|dev
argument_list|)
argument_list|,
name|lunit
argument_list|,
name|WDRAW
argument_list|)
argument_list|,
name|wdstrategy
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
name|du
operator|->
name|dk_dospartitions
argument_list|,
operator|&
name|du
operator|->
name|dk_bad
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_LABELLING
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|du
operator|->
name|dk_dd
operator|=
name|save_label
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wd%d: cannot find label (%s)\n"
argument_list|,
name|lunit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|!=
name|WDRAW
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX needs translation */
block|}
else|else
block|{
name|int
name|dospart
decl_stmt|;
name|unsigned
name|long
name|newsize
decl_stmt|,
name|offset
decl_stmt|,
name|size
decl_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_BSDLABEL
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_WRITEPROT
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_dd
operator|.
name|d_flags
operator|&
name|D_BADSECT
condition|)
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_BADSECT
expr_stmt|;
name|bad144intern
argument_list|(
name|du
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Force WDRAW partition to be the whole disk. 			 */
name|offset
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|WDRAW
index|]
operator|.
name|p_offset
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"wd%d: changing offset of '%c' partition from %lu to 0\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
literal|'a'
operator|+
name|WDRAW
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|WDRAW
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
block|}
name|size
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|WDRAW
index|]
operator|.
name|p_size
expr_stmt|;
name|newsize
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|size
operator|!=
name|newsize
condition|)
block|{
name|printf
argument_list|(
literal|"wd%d: changing size of '%c' partition from %lu to %lu\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
literal|'a'
operator|+
name|WDRAW
argument_list|,
name|size
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|WDRAW
index|]
operator|.
name|p_size
operator|=
name|newsize
expr_stmt|;
block|}
comment|/* 			 * Convert DOS partition data to a label. 			 */
name|du
operator|->
name|dk_dd2
operator|=
name|du
operator|->
name|dk_dd
expr_stmt|;
name|bzero
argument_list|(
name|du
operator|->
name|dk_dd2
operator|.
name|d_partitions
argument_list|,
sizeof|sizeof
name|du
operator|->
name|dk_dd2
operator|.
name|d_partitions
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_dd2
operator|.
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
expr_stmt|;
comment|/* XXX */
for|for
control|(
name|dospart
operator|=
literal|1
init|;
name|dospart
operator|<=
name|NDOSPART
condition|;
name|dospart
operator|++
control|)
block|{
name|du
operator|->
name|dk_dd2
operator|.
name|d_partitions
index|[
name|dospart
index|]
operator|.
name|p_offset
operator|=
name|du
operator|->
name|dk_dospartitions
index|[
name|dospart
operator|-
literal|1
index|]
operator|.
name|dp_start
expr_stmt|;
name|du
operator|->
name|dk_dd2
operator|.
name|d_partitions
index|[
name|dospart
index|]
operator|.
name|p_size
operator|=
name|du
operator|->
name|dk_dospartitions
index|[
name|dospart
operator|-
literal|1
index|]
operator|.
name|dp_size
expr_stmt|;
block|}
block|}
comment|/* Pick up changes made by readdisklabel(). */
name|wdsleep
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|,
literal|"wdopn2"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
block|}
comment|/* 	 * Warn if a partion is opened that overlaps another partition which 	 * is open unless one is the "raw" partition (whole disk). 	 */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_openpart
operator|&
name|mask
operator|)
operator|==
literal|0
operator|&&
name|part
operator|!=
name|WDRAW
operator|&&
name|part
operator|!=
name|OURPART
condition|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|pp
operator|=
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
expr_stmt|;
name|start
operator|=
name|pp
operator|->
name|p_offset
expr_stmt|;
name|end
operator|=
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
init|;
name|pp
operator|<
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|du
operator|->
name|dk_dd
operator|.
name|d_npartitions
index|]
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
operator|<=
name|start
operator|||
name|pp
operator|->
name|p_offset
operator|>=
name|end
condition|)
continue|continue;
if|if
condition|(
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|==
name|WDRAW
condition|)
continue|continue;
if|if
condition|(
name|du
operator|->
name|dk_openpart
operator|&
operator|(
literal|1
operator|<<
operator|(
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wd%d%c: overlaps open partition (%c)\n"
argument_list|,
name|lunit
argument_list|,
name|part
operator|+
literal|'a'
argument_list|,
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|part
operator|>=
name|du
operator|->
name|dk_dd
operator|.
name|d_npartitions
operator|&&
name|part
operator|!=
name|WDRAW
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|du
operator|->
name|dk_copenpart
operator||=
name|mask
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|du
operator|->
name|dk_bopenpart
operator||=
name|mask
expr_stmt|;
break|break;
block|}
name|du
operator|->
name|dk_openpart
operator|=
name|du
operator|->
name|dk_copenpart
operator||
name|du
operator|->
name|dk_bopenpart
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement operations other than read/write.  * Called from wdstart or wdintr during opens and formats.  * Uses finite-state-machine to track progress of operation in progress.  * Returns 0 if operation still in progress, 1 if completed, 2 if error.  */
end_comment

begin_function
specifier|static
name|int
name|wdcontrol
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|ctrlr
decl_stmt|;
name|du
operator|=
name|wddrives
index|[
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|ctrlr
operator|=
name|du
operator|->
name|dk_ctrlr
expr_stmt|;
switch|switch
condition|(
name|du
operator|->
name|dk_state
condition|)
block|{
case|case
name|WANTOPEN
case|:
name|tryagainrecal
label|:
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdcontrol: wdcommand failed"
argument_list|)
expr_stmt|;
goto|goto
name|maybe_retry
goto|;
block|}
name|du
operator|->
name|dk_state
operator|=
name|RECAL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RECAL
case|:
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
name|WDCS_ERR
operator|||
name|wdsetctlr
argument_list|(
name|du
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdcontrol: recal failed"
argument_list|)
expr_stmt|;
name|maybe_retry
label|:
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
name|WDCS_ERR
condition|)
name|wdunwedge
argument_list|(
name|du
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
if|if
condition|(
operator|++
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
goto|goto
name|tryagainrecal
goto|;
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
comment|/* XXX needs translation */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
comment|/* 		 * The rest of the initialization can be done by normal 		 * means. 		 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"wdcontrol"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait uninterruptibly until controller is not busy, then send it a command.  * The wait usually terminates immediately because we waited for the previous  * command to terminate.  */
end_comment

begin_function
specifier|static
name|int
name|wdcommand
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|u_int
name|cylinder
parameter_list|,
name|u_int
name|head
parameter_list|,
name|u_int
name|sector
parameter_list|,
name|u_int
name|count
parameter_list|,
name|u_int
name|command
parameter_list|)
block|{
name|u_int
name|wdc
decl_stmt|;
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
if|if
condition|(
name|command
operator|==
name|WDCC_FEATURES
condition|)
block|{
name|outb
argument_list|(
name|wdc
operator|+
name|wd_features
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|wdc
operator|+
name|wd_precomp
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_precompcyl
operator|/
literal|4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
name|cylinder
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|,
name|cylinder
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|du
operator|->
name|dk_unit
operator|<<
literal|4
operator|)
operator||
name|head
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|,
name|sector
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|command
operator|==
name|WDCC_DIAGNOSE
operator|||
name|command
operator|==
name|WDCC_IDC
condition|?
literal|0
else|:
name|WDCS_READY
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * issue IDC to drive to tell it just what geometry it is to be.  */
end_comment

begin_function
specifier|static
name|int
name|wdsetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"wd(%d,%d): wdsetctlr: C %lu H %lu S %lu\n"
argument_list|,
name|du
operator|->
name|dk_ctrlr
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|==
literal|0
operator|||
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|>
literal|16
condition|)
block|{
name|struct
name|wdparams
modifier|*
name|wp
decl_stmt|;
name|printf
argument_list|(
literal|"wd%d: can't handle %lu heads from partition table "
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
argument_list|)
expr_stmt|;
comment|/* obtain parameters */
name|wp
operator|=
operator|&
name|du
operator|->
name|dk_params
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|wdp_heads
operator|>
literal|0
operator|&&
name|wp
operator|->
name|wdp_heads
operator|<=
literal|16
condition|)
block|{
name|printf
argument_list|(
literal|"(controller value %lu restored)\n"
argument_list|,
name|wp
operator|->
name|wdp_heads
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
name|wp
operator|->
name|wdp_heads
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"(truncating to 16)\n"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
literal|16
expr_stmt|;
block|}
block|}
if|if
condition|(
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|==
literal|0
operator|||
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|>
literal|255
condition|)
block|{
name|printf
argument_list|(
literal|"wd%d: cannot handle %lu sectors (max 255)\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|.
name|b_errcnt
operator|+=
name|RETRIES
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
argument_list|,
name|WDCC_IDC
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wdsetctlr failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait until driver is inactive, then set up controller.  */
end_comment

begin_function
specifier|static
name|int
name|wdwsetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|int
name|stat
decl_stmt|;
name|int
name|x
decl_stmt|;
name|wdsleep
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|,
literal|"wdwset"
argument_list|)
expr_stmt|;
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|stat
operator|=
name|wdsetctlr
argument_list|(
name|du
argument_list|)
expr_stmt|;
name|wdflushirq
argument_list|(
name|du
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * issue READP to drive to ask it what it is.  */
end_comment

begin_function
specifier|static
name|int
name|wdgetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|tb
index|[
name|DEV_BSIZE
index|]
decl_stmt|,
name|tb2
index|[
name|DEV_BSIZE
index|]
decl_stmt|;
name|struct
name|wdparams
modifier|*
name|wp
init|=
name|NULL
decl_stmt|;
name|again
label|:
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_READP
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
argument_list|,
name|TIMEOUT
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * if we failed on the second try, assume non-32bit 		 */
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
condition|)
goto|goto
name|failed
goto|;
comment|/* XXX need to check error status after final transfer. */
comment|/* 		 * Old drives don't support WDCC_READP.  Try a seek to 0. 		 * Some IDE controllers return trash if there is no drive 		 * attached, so first test that the drive can be selected. 		 * This also avoids long waits for nonexistent drives. 		 */
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|outb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|du
operator|->
name|dk_unit
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* usually unnecessary; drive select is fast */
if|if
condition|(
operator|(
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_status
argument_list|)
operator|&
operator|(
name|WDCS_BUSY
operator||
name|WDCS_READY
operator|)
operator|)
operator|!=
name|WDCS_READY
operator|||
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|,
name|TIMEOUT
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|du
operator|->
name|dk_unit
operator|==
name|bootinfo
operator|.
name|bi_n_bios_used
condition|)
block|{
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|=
name|bootinfo
operator|.
name|bi_bios_geom
index|[
name|du
operator|->
name|dk_unit
index|]
operator|&
literal|0xff
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
operator|(
operator|(
name|bootinfo
operator|.
name|bi_bios_geom
index|[
name|du
operator|->
name|dk_unit
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* XXX Why 2 ? */
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|=
operator|(
name|bootinfo
operator|.
name|bi_bios_geom
index|[
name|du
operator|->
name|dk_unit
index|]
operator|>>
literal|16
operator|)
operator|+
literal|2
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|WDRAW
index|]
operator|.
name|p_size
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_type
operator|=
name|DTYPE_ST506
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_subtype
operator||=
name|DSTYPE_GEOMETRY
expr_stmt|;
name|strncpy
argument_list|(
name|du
operator|->
name|dk_dd
operator|.
name|d_typename
argument_list|,
literal|"Bios geometry"
argument_list|,
sizeof|sizeof
name|du
operator|->
name|dk_dd
operator|.
name|d_typename
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|,
literal|"ST506"
argument_list|,
sizeof|sizeof
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_n_bios_used
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * Fake minimal drive geometry for reading the MBR. 		 * readdisklabel() may enlarge it to read the label and the 		 * bad sector table. 		 */
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|=
literal|17
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
literal|1
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|=
literal|1
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|=
literal|17
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|=
literal|17
expr_stmt|;
comment|/* 		 * Fake maximal drive size for writing the label. 		 */
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|WDRAW
index|]
operator|.
name|p_size
operator|=
literal|64
operator|*
literal|16
operator|*
literal|1024
expr_stmt|;
comment|/* 		 * Fake some more of the label for printing by disklabel(1) 		 * in case there is no real label. 		 */
name|du
operator|->
name|dk_dd
operator|.
name|d_type
operator|=
name|DTYPE_ST506
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_subtype
operator||=
name|DSTYPE_GEOMETRY
expr_stmt|;
name|strncpy
argument_list|(
name|du
operator|->
name|dk_dd
operator|.
name|d_typename
argument_list|,
literal|"Fake geometry"
argument_list|,
sizeof|sizeof
name|du
operator|->
name|dk_dd
operator|.
name|d_typename
argument_list|)
expr_stmt|;
comment|/* Fake the model name for printing by wdattach(). */
name|strncpy
argument_list|(
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|,
literal|"unknown"
argument_list|,
sizeof|sizeof
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* obtain parameters */
name|wp
operator|=
operator|&
name|du
operator|->
name|dk_params
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
condition|)
name|insl
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
name|tb
argument_list|,
sizeof|sizeof
argument_list|(
name|tb
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|insw
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
name|tb
argument_list|,
sizeof|sizeof
argument_list|(
name|tb
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* try 32-bit data path (VLB IDE controller) */
if|if
condition|(
operator|!
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|tb
argument_list|,
name|tb2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wdparams
argument_list|)
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_32BIT
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* check that we really have 32-bit controller */
if|if
condition|(
name|bcmp
argument_list|(
name|tb
argument_list|,
name|tb2
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wdparams
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|failed
label|:
comment|/* test failed, use 16-bit i/o mode */
name|bcopy
argument_list|(
name|tb2
argument_list|,
name|tb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wdparams
argument_list|)
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_32BIT
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|tb
argument_list|,
name|wp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wdparams
argument_list|)
argument_list|)
expr_stmt|;
comment|/* shuffle string byte order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|wp
operator|->
name|wdp_model
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|u_short
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|wp
operator|->
name|wdp_model
operator|+
name|i
operator|)
expr_stmt|;
operator|*
name|p
operator|=
name|ntohs
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clean up the wdp_model by converting nulls to spaces, and 	 * then removing the trailing spaces. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|wp
operator|->
name|wdp_model
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wp
operator|->
name|wdp_model
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|wp
operator|->
name|wdp_model
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|wp
operator|->
name|wdp_model
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|wp
operator|->
name|wdp_model
index|[
name|i
index|]
operator|==
literal|' '
condition|;
name|i
operator|--
control|)
block|{
name|wp
operator|->
name|wdp_model
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"\nwd(%d,%d): wdgetctlr: gc %x cyl %d trk %d sec %d type %d sz %d model %s\n"
argument_list|,
name|du
operator|->
name|dk_ctrlr
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|wp
operator|->
name|wdp_config
argument_list|,
name|wp
operator|->
name|wdp_fixedcyl
operator|+
name|wp
operator|->
name|wdp_removcyl
argument_list|,
name|wp
operator|->
name|wdp_heads
argument_list|,
name|wp
operator|->
name|wdp_sectors
argument_list|,
name|wp
operator|->
name|wdp_cntype
argument_list|,
name|wp
operator|->
name|wdp_cnsbsz
argument_list|,
name|wp
operator|->
name|wdp_model
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* update disklabel given drive information */
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|=
name|wp
operator|->
name|wdp_fixedcyl
operator|+
name|wp
operator|->
name|wdp_removcyl
comment|/*+- 1*/
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
name|wp
operator|->
name|wdp_heads
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|=
name|wp
operator|->
name|wdp_sectors
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|WDRAW
index|]
operator|.
name|p_size
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
expr_stmt|;
comment|/* dubious ... */
name|bcopy
argument_list|(
literal|"ESDI/IDE"
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_typename
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|wp
operator|->
name|wdp_model
operator|+
literal|20
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_packname
argument_list|,
literal|14
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* better ... */
name|du
operator|->
name|dk_dd
operator|.
name|d_type
operator|=
name|DTYPE_ESDI
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_subtype
operator||=
name|DSTYPE_GEOMETRY
expr_stmt|;
name|du
operator|->
name|dk_multi
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|NSECS_MULTI
operator|!=
literal|1
operator|)
operator|&&
operator|(
operator|(
name|wp
operator|->
name|wdp_nsecperint
operator|&
literal|0xff
operator|)
operator|>=
name|NSECS_MULTI
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NSECS_MULTI
argument_list|,
name|WDCC_SET_MULTI
argument_list|)
condition|)
block|{
name|du
operator|->
name|dk_multi
operator|=
name|NSECS_MULTI
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|NOTYET
comment|/* set read caching and write caching */
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDFEA_RCACHE
argument_list|,
name|WDCC_FEATURES
argument_list|)
expr_stmt|;
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDFEA_WCACHE
argument_list|,
name|WDCC_FEATURES
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|wdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|part
init|=
name|wdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|mask
init|=
literal|1
operator|<<
name|part
decl_stmt|;
if|if
condition|(
name|wddospart
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|du
operator|=
name|wddrives
index|[
name|wdunit
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|du
operator|->
name|dk_copenpart
operator|&=
operator|~
name|mask
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|du
operator|->
name|dk_bopenpart
operator|&=
operator|~
name|mask
expr_stmt|;
break|break;
block|}
name|du
operator|->
name|dk_openpart
operator|=
name|du
operator|->
name|dk_copenpart
operator||
name|du
operator|->
name|dk_bopenpart
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|lunit
init|=
name|wdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
endif|#
directive|endif
name|du
operator|=
name|wddrives
index|[
name|lunit
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCSBAD
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
block|{
name|du
operator|->
name|dk_bad
operator|=
operator|*
operator|(
expr|struct
name|dkbad
operator|*
operator|)
name|addr
expr_stmt|;
name|bad144intern
argument_list|(
name|du
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
operator|=
name|du
operator|->
name|dk_dd
expr_stmt|;
break|break;
case|case
name|DIOCGPART
case|:
if|if
condition|(
name|wddospart
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|disklab
operator|=
operator|&
name|du
operator|->
name|dk_dd
expr_stmt|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|part
operator|=
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|wdpart
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|DIOCSDINFO
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|error
operator|=
name|setdisklabel
argument_list|(
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
argument_list|,
if|#
directive|if
literal|0
comment|/* 					     * XXX setdisklabel() uses the 					     * openmask to allow it to reject 					     * changing open partitions.  Why 					     * are we pretending nothing is 					     * open? 					     */
argument_list|du->dk_flags& DKFL_BSDLABEL 					     ? du->dk_openpart :
endif|#
directive|endif
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_BSDLABEL
expr_stmt|;
name|wdwsetctlr
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* XXX - check */
block|}
break|break;
case|case
name|DIOCWLABEL
case|:
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_WRITEPROT
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|du
operator|->
name|dk_wlabel
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|DIOCWDINFO
case|:
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_WRITEPROT
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|setdisklabel
argument_list|(
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
argument_list|,
if|#
directive|if
literal|0
argument_list|du->dk_flags& DKFL_BSDLABEL 					       ? du->dk_openpart :
endif|#
directive|endif
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|wlab
decl_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_BSDLABEL
expr_stmt|;
name|wdwsetctlr
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* XXX - check */
comment|/* simulate opening partition 0 so write succeeds */
name|du
operator|->
name|dk_openpart
operator||=
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
comment|/* XXX */
name|wlab
operator|=
name|du
operator|->
name|dk_wlabel
expr_stmt|;
name|du
operator|->
name|dk_wlabel
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|writedisklabel
argument_list|(
name|dev
argument_list|,
name|wdstrategy
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_openpart
operator|=
name|du
operator|->
name|dk_copenpart
operator||
name|du
operator|->
name|dk_bopenpart
expr_stmt|;
name|du
operator|->
name|dk_wlabel
operator|=
name|wlab
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|notyet
case|case
name|DIOCGDINFOP
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|*
operator|)
name|addr
operator|=
operator|&
operator|(
name|du
operator|->
name|dk_dd
operator|)
expr_stmt|;
break|break;
case|case
name|DIOCWFORMAT
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|format_op
modifier|*
name|fop
decl_stmt|;
name|fop
operator|=
operator|(
expr|struct
name|format_op
operator|*
operator|)
name|addr
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|fop
operator|->
name|df_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|fop
operator|->
name|df_startblk
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
error|#
directive|error
comment|/* XXX the 386BSD interface is different */
name|error
operator|=
name|physio
argument_list|(
name|wdformat
argument_list|,
operator|&
name|rwdbuf
index|[
name|lunit
index|]
argument_list|,
literal|0
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
name|fop
operator|->
name|df_count
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|fop
operator|->
name|df_reg
index|[
literal|0
index|]
operator|=
name|du
operator|->
name|dk_status
expr_stmt|;
name|fop
operator|->
name|df_reg
index|[
literal|1
index|]
operator|=
name|du
operator|->
name|dk_error
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|B_FORMAT
end_ifdef

begin_function
name|int
name|wdformat
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_FORMAT
expr_stmt|;
name|wdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/*  	 * phk put this here, better that return(wdstrategy(bp)); 	 * XXX 	 */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|wdsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|lunit
init|=
name|wdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|part
init|=
name|wdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|val
decl_stmt|;
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|lunit
operator|>=
name|NWD
operator|||
name|wddospart
argument_list|(
name|dev
argument_list|)
operator|||
operator|(
name|du
operator|=
name|wddrives
index|[
name|lunit
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_state
operator|==
name|CLOSED
condition|)
block|{
name|val
operator|=
name|wdopen
argument_list|(
name|makewddev
argument_list|(
name|major
argument_list|(
name|dev
argument_list|)
argument_list|,
name|lunit
argument_list|,
name|WDRAW
argument_list|)
argument_list|,
name|FREAD
argument_list|,
name|S_IFBLK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|!=
literal|0
operator|||
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_WRITEPROT
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|size
operator|=
operator|(
operator|(
name|int
operator|)
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
operator|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|ptvmmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* poor name! */
end_comment

begin_comment
comment|/*  * Dump core after a system crash.  */
end_comment

begin_function
name|int
name|wddump
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|struct
name|bt_bad
modifier|*
name|bt_ptr
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|long
name|num
decl_stmt|;
comment|/* number of sectors to write */
name|int
name|lunit
decl_stmt|,
name|part
decl_stmt|;
name|long
name|blkoff
decl_stmt|,
name|blknum
decl_stmt|;
name|long
name|blkchk
decl_stmt|,
name|blkcnt
decl_stmt|,
name|blknext
decl_stmt|;
name|long
name|cylin
decl_stmt|,
name|head
decl_stmt|,
name|sector
decl_stmt|;
name|long
name|secpertrk
decl_stmt|,
name|secpercyl
decl_stmt|,
name|nblocks
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
specifier|static
name|int
name|wddoingadump
init|=
literal|0
decl_stmt|;
comment|/* Toss any characters present prior to dump. */
while|while
condition|(
name|cncheckc
argument_list|()
condition|)
empty_stmt|;
comment|/* Check for acceptable device. */
comment|/* XXX should reset to maybe allow du->dk_state< OPEN. */
name|lunit
operator|=
name|wdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* eventually support floppies? */
name|part
operator|=
name|wdpart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|lunit
operator|>=
name|NWD
operator|||
name|wddospart
argument_list|(
name|dev
argument_list|)
operator|||
operator|(
name|du
operator|=
name|wddrives
index|[
name|lunit
index|]
operator|)
operator|==
name|NULL
operator|||
name|du
operator|->
name|dk_state
operator|<
name|OPEN
operator|||
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_WRITEPROT
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Size of memory to dump, in disk sectors. */
name|num
operator|=
operator|(
name|u_long
operator|)
name|Maxmem
operator|*
name|NBPG
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
name|secpertrk
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
expr_stmt|;
name|nblocks
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
expr_stmt|;
name|blkoff
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
expr_stmt|;
if|#
directive|if
literal|0
block|pg("part %x, nblocks %d, dumplo %d num %d\n", 	   part, nblocks, dumplo, num);
endif|#
directive|endif
comment|/* Check transfer bounds against partition size. */
if|if
condition|(
name|dumplo
operator|<
literal|0
operator|||
name|dumplo
operator|+
name|num
operator|>
name|nblocks
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Check if we are being called recursively. */
if|if
condition|(
name|wddoingadump
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|#
directive|if
literal|0
comment|/* Mark controller active for if we panic during the dump. */
block|wdtab[du->dk_ctrlr].b_active = 1;
endif|#
directive|endif
name|wddoingadump
operator|=
literal|1
expr_stmt|;
comment|/* Recalibrate the drive. */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* ATA spec XXX NOT */
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|,
name|TIMEOUT
argument_list|)
operator|!=
literal|0
operator|||
name|wdsetctlr
argument_list|(
name|du
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wddump: recalibrate failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_SINGLE
expr_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|blknum
operator|=
name|dumplo
operator|+
name|blkoff
expr_stmt|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|blkcnt
operator|=
name|num
expr_stmt|;
if|if
condition|(
name|blkcnt
operator|>
name|MAXTRANSFER
condition|)
name|blkcnt
operator|=
name|MAXTRANSFER
expr_stmt|;
comment|/* Keep transfer within current cylinder. */
if|if
condition|(
operator|(
name|blknum
operator|+
name|blkcnt
operator|-
literal|1
operator|)
operator|/
name|secpercyl
operator|!=
name|blknum
operator|/
name|secpercyl
condition|)
name|blkcnt
operator|=
name|secpercyl
operator|-
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
expr_stmt|;
name|blknext
operator|=
name|blknum
operator|+
name|blkcnt
expr_stmt|;
comment|/*  		 * See if one of the sectors is in the bad sector list 		 * (if we have one).  If the first sector is bad, then 		 * reduce the transfer to this one bad sector; if another 		 * sector is bad, then reduce reduce the transfer to 		 * avoid any bad sectors. 		 */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_SINGLE
operator||
name|DKFL_BADSECT
operator|)
operator|)
operator|==
operator|(
name|DKFL_SINGLE
operator||
name|DKFL_BADSECT
operator|)
condition|)
for|for
control|(
name|blkchk
operator|=
name|blknum
init|;
name|blkchk
operator|<
name|blknum
operator|+
name|blkcnt
condition|;
name|blkchk
operator|++
control|)
block|{
name|cylin
operator|=
name|blkchk
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blkchk
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blkchk
operator|%
name|secpertrk
expr_stmt|;
for|for
control|(
name|bt_ptr
operator|=
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
init|;
name|bt_ptr
operator|->
name|bt_cyl
operator|!=
name|BAD144_NO_CYL
condition|;
name|bt_ptr
operator|++
control|)
block|{
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|>
name|cylin
condition|)
comment|/* 				 * Sorted list, and we passed our cylinder. 				 * quit. 				 */
break|break;
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|==
name|cylin
operator|&&
name|bt_ptr
operator|->
name|bt_trksec
operator|==
operator|(
name|head
operator|<<
literal|8
operator|)
operator|+
name|sector
condition|)
block|{
comment|/* Found bad block. */
name|blkcnt
operator|=
name|blkchk
operator|-
name|blknum
expr_stmt|;
if|if
condition|(
name|blkcnt
operator|>
literal|0
condition|)
block|{
name|blknext
operator|=
name|blknum
operator|+
name|blkcnt
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|blkcnt
operator|=
literal|1
expr_stmt|;
name|blknext
operator|=
name|blknum
operator|+
name|blkcnt
expr_stmt|;
comment|/* 			 * Found bad block.  Calculate new block number. 			 * This starts at the end of the disk (skip the 			 * last track which is used for the bad block list), 			 * and works backwards to the front of the disk. 			 */
comment|/* XXX as usual. */
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"--- badblock code -> Old = %ld; "
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lp
operator|=
operator|&
name|du
operator|->
name|dk_dd
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|d_partitions
index|[
name|BSD_PART
index|]
operator|.
name|p_offset
operator|!=
literal|0
condition|)
name|blknum
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|BAD144_PART
index|]
operator|.
name|p_offset
operator|+
name|lp
operator|->
name|d_partitions
index|[
name|BAD144_PART
index|]
operator|.
name|p_size
expr_stmt|;
else|else
name|blknum
operator|=
name|lp
operator|->
name|d_secperunit
expr_stmt|;
name|blknum
operator|-=
name|lp
operator|->
name|d_nsectors
operator|+
operator|(
name|bt_ptr
operator|-
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
operator|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"new = %ld\n"
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
name|out
label|:
comment|/* Compute disk address. */
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Let's just talk about this first... */
block|pg("cylin l%d head %ld sector %ld addr 0x%x count %ld", 		   cylin, head, sector, addr, blkcnt);
endif|#
directive|endif
comment|/* Do the write. */
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
name|cylin
argument_list|,
name|head
argument_list|,
name|sector
argument_list|,
name|blkcnt
argument_list|,
name|WDCC_WRITE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wddump: timeout waiting to to give command"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
while|while
condition|(
name|blkcnt
operator|!=
literal|0
condition|)
block|{
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|CADDR1
argument_list|,
name|trunc_page
argument_list|(
name|addr
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Ready to send data? */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* ATA spec */
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wddump: timeout waiting for DRQ"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_32BIT
condition|)
name|outsl
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
name|CADDR1
operator|+
operator|(
operator|(
name|int
operator|)
name|addr
operator|&
operator|(
name|NBPG
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|DEV_BSIZE
operator|/
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|outsw
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
name|CADDR1
operator|+
operator|(
operator|(
name|int
operator|)
name|addr
operator|&
operator|(
name|NBPG
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|DEV_BSIZE
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|DEV_BSIZE
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|addr
operator|%
operator|(
literal|1024
operator|*
literal|1024
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%ld "
argument_list|,
name|num
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|/
name|DEV_BSIZE
operator|)
argument_list|)
expr_stmt|;
name|num
operator|--
expr_stmt|;
name|blkcnt
operator|--
expr_stmt|;
block|}
comment|/* Wait for completion. */
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* ATA spec XXX NOT */
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|,
name|TIMEOUT
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wddump: timeout waiting for status"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Check final status. */
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
operator|(
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
operator||
name|WDCS_ERR
operator|)
operator|!=
operator|(
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator|)
condition|)
block|{
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wddump: extra DRQ, or error"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Update block count. */
name|blknum
operator|=
name|blknext
expr_stmt|;
comment|/* Operator aborting dump? */
if|if
condition|(
name|cncheckc
argument_list|()
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wderror
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"wd%d: %s:\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
else|else
name|diskerr
argument_list|(
name|bp
argument_list|,
literal|"wd"
argument_list|,
name|mesg
argument_list|,
name|LOG_PRINTF
argument_list|,
name|du
operator|->
name|dk_skip
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wd%d: status %b error %b\n"
argument_list|,
name|du
operator|->
name|dk_lunit
argument_list|,
name|du
operator|->
name|dk_status
argument_list|,
name|WDCS_BITS
argument_list|,
name|du
operator|->
name|dk_error
argument_list|,
name|WDERR_BITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Discard any interrupts that were latched by the interrupt system while  * we were doing polled i/o.  */
end_comment

begin_function
specifier|static
name|void
name|wdflushirq
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|int
name|old_ipl
parameter_list|)
block|{
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|.
name|b_active
operator|=
literal|2
expr_stmt|;
name|splx
argument_list|(
name|old_ipl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splbio
argument_list|()
expr_stmt|;
name|wdtab
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the controller.  */
end_comment

begin_function
specifier|static
name|int
name|wdreset
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|int
name|wdc
decl_stmt|;
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
operator|(
name|void
operator|)
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
name|TIMEOUT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_IDS
operator||
name|WDCTL_RST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_IDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|,
name|TIMEOUT
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|du
operator|->
name|dk_error
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
operator|)
operator|!=
literal|0x01
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_4BIT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sleep until driver is inactive.  * This is used only for avoiding rare race conditions, so it is unimportant  * that the sleep may be far too short or too long.  */
end_comment

begin_function
specifier|static
name|void
name|wdsleep
parameter_list|(
name|int
name|ctrlr
parameter_list|,
name|char
modifier|*
name|wmesg
parameter_list|)
block|{
while|while
condition|(
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_active
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|wdtab
index|[
name|ctrlr
index|]
operator|.
name|b_active
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|,
name|wmesg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wdtimeout
parameter_list|(
name|void
modifier|*
name|cdu
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|x
decl_stmt|;
specifier|static
name|int
name|timeouts
decl_stmt|;
name|du
operator|=
operator|(
expr|struct
name|disk
operator|*
operator|)
name|cdu
expr_stmt|;
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_timeout
operator|!=
literal|0
operator|&&
operator|--
name|du
operator|->
name|dk_timeout
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timeouts
operator|++
operator|==
literal|5
condition|)
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"Last time I say: interrupt timeout.  Probably a portable PC."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|timeouts
operator|++
operator|<
literal|5
condition|)
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"interrupt timeout"
argument_list|)
expr_stmt|;
name|wdunwedge
argument_list|(
name|du
argument_list|)
expr_stmt|;
name|wdflushirq
argument_list|(
name|du
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_skip
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_SINGLE
expr_stmt|;
name|wdstart
argument_list|(
name|du
operator|->
name|dk_ctrlr
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
name|wdtimeout
argument_list|,
name|cdu
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the controller after it has become wedged.  This is different from  * wdreset() so that wdreset() can be used in the probe and so that this  * can restore the geometry .  */
end_comment

begin_function
specifier|static
name|int
name|wdunwedge
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|du1
decl_stmt|;
name|int
name|lunit
decl_stmt|;
comment|/* Schedule other drives for recalibration. */
for|for
control|(
name|lunit
operator|=
literal|0
init|;
name|lunit
operator|<
name|NWD
condition|;
name|lunit
operator|++
control|)
if|if
condition|(
operator|(
name|du1
operator|=
name|wddrives
index|[
name|lunit
index|]
operator|)
operator|!=
name|NULL
operator|&&
name|du1
operator|!=
name|du
operator|&&
name|du1
operator|->
name|dk_ctrlr
operator|==
name|du
operator|->
name|dk_ctrlr
operator|&&
name|du1
operator|->
name|dk_state
operator|>
name|WANTOPEN
condition|)
name|du1
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
name|DELAY
argument_list|(
name|RECOVERYTIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdreset
argument_list|(
name|du
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * XXX - recalibrate current drive now because some callers 		 * aren't prepared to have its state change. 		 */
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
operator|==
literal|0
operator|&&
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|,
name|TIMEOUT
argument_list|)
operator|==
literal|0
operator|&&
name|wdsetctlr
argument_list|(
name|du
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wdunwedge failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait uninterruptibly until controller is not busy and either certain  * status bits are set or an error has occurred.  * The wait is usually short unless it is for the controller to process  * an entire critical command.  * Return 1 for (possibly stale) controller errors, -1 for timeout errors,  * or 0 for no errors.  * Return controller status in du->dk_status and, if there was a controller  * error, return the error code in du->dk_error.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WD_COUNT_RETRIES
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|min_retries
index|[
name|NWDC
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|wdwait
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|u_char
name|bits_wanted
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|wdc
decl_stmt|;
name|u_char
name|status
decl_stmt|;
define|#
directive|define
name|POLLING
value|1000
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
name|timeout
operator|+=
name|POLLING
expr_stmt|;
comment|/* dummy read for delay */
comment|/* 	 * the reason that we are reading from an *unused* port, 	 * is that it might be *really* fast to read from the 	 * wd port. 	 */
operator|(
name|void
operator|)
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|WD_COUNT_RETRIES
if|if
condition|(
name|min_retries
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|>
name|timeout
operator|||
name|min_retries
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|==
literal|0
condition|)
name|min_retries
index|[
name|du
operator|->
name|dk_ctrlr
index|]
operator|=
name|timeout
expr_stmt|;
endif|#
directive|endif
name|du
operator|->
name|dk_status
operator|=
name|status
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|WDCS_BUSY
operator|)
condition|)
block|{
if|if
condition|(
name|status
operator|&
name|WDCS_ERR
condition|)
block|{
name|du
operator|->
name|dk_error
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
expr_stmt|;
comment|/* 				 * We once returned here.  This is wrong 				 * because the error bit is apparently only 				 * valid after the controller has interrupted 				 * (e.g., the error bit is stale when we wait 				 * for DRQ for writes).  So we can't depend 				 * on the error bit at all when polling for 				 * command completion. 				 */
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|bits_wanted
operator|)
operator|==
name|bits_wanted
condition|)
return|return
operator|(
name|status
operator|&
name|WDCS_ERR
operator|)
return|;
block|}
if|if
condition|(
name|timeout
operator|<
name|TIMEOUT
condition|)
comment|/* 			 * Switch to a polling rate of about 1 KHz so that 			 * the timeout is almost machine-independent.  The 			 * controller is taking a long time to respond, so 			 * an extra msec won't matter. 			 */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
else|else
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|timeout
operator|!=
literal|0
condition|)
do|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internalize the bad sector table.  */
end_comment

begin_function
name|void
name|bad144intern
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_BADSECT
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|127
condition|;
name|i
operator|++
control|)
block|{
name|du
operator|->
name|dk_badsect
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|126
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_cyl
operator|==
literal|0xffff
condition|)
block|{
break|break;
block|}
else|else
block|{
name|du
operator|->
name|dk_badsect
index|[
name|i
index|]
operator|=
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_cyl
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|+
operator|(
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_trksec
operator|>>
literal|8
operator|)
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|+
operator|(
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_trksec
operator|&
literal|0x00ff
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NWDC> 0 */
end_comment

end_unit

