begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from:@(#)wd.c	7.2 (Berkeley) 5/9/91  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         6       00155  * --------------------         -----   ----------------------  *  * 17 Sep 92	Frank Maclachlan	Fixed I/O error reporting on raw device  * 31 Jul 92	Christoph Robitschko	Fixed second disk recognition,  *					bzero of malloced memory for warm  *					boot problem.  * 19 Aug 92    Frank Maclachlan	Fixed bug when first sector of a  *					multisector read is in bad144 table.  * 17 Jan 93	B. Evans& A.Chernov	Fixed bugs from previous patches,  *					driver initialization, and cylinder  *					boundary conditions.  * 28 Mar 93	Charles Hannum		Add missing splx calls.  * 20 Apr 93	Terry Lee		Always report disk errors  * 20 Apr 93	Brett Lymn		Change infinite while loops to  *					timeouts  * 17 May 93	Rodney W. Grimes	Fixed all 1000000 to use WDCTIMEOUT,  *					and increased to 1000000*10 for new  *					intr-0.1 code.  */
end_comment

begin_comment
comment|/* TODO:peel out buffer at low ipl, speed improvement */
end_comment

begin_include
include|#
directive|include
file|"wd.h"
end_include

begin_if
if|#
directive|if
name|NWD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"dkbad.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"disklabel.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/icu.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/wdreg.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_define
define|#
directive|define
name|_NWD
value|(NWD - 1)
end_define

begin_comment
comment|/* One is for the controller XXX 31 Jul 92*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WDCTIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|WDCTIMEOUT
value|10000000
end_define

begin_comment
comment|/* arbitrary timeout for drive ready waits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RETRIES
value|5
end_define

begin_comment
comment|/* number of retries before giving up */
end_comment

begin_define
define|#
directive|define
name|MAXTRANSFER
value|32
end_define

begin_comment
comment|/* max size of transfer in page clusters */
end_comment

begin_define
define|#
directive|define
name|wdnoreloc
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x80)
end_define

begin_comment
comment|/* ignore partition table */
end_comment

begin_define
define|#
directive|define
name|wddospart
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x40)
end_define

begin_comment
comment|/* use dos partitions */
end_comment

begin_define
define|#
directive|define
name|wdunit
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev)& 0x38)>> 3)
end_define

begin_define
define|#
directive|define
name|wdpart
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x7)
end_define

begin_define
define|#
directive|define
name|makewddev
parameter_list|(
name|maj
parameter_list|,
name|unit
parameter_list|,
name|part
parameter_list|)
value|(makedev(maj,((unit<<3)+part)))
end_define

begin_define
define|#
directive|define
name|WDRAW
value|3
end_define

begin_comment
comment|/* 'd' partition isn't a partition! */
end_comment

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_comment
comment|/* cylinder number for doing IO to */
end_comment

begin_comment
comment|/* shares an entry in the buf struct */
end_comment

begin_comment
comment|/*  * Drive states.  Used to initialize drive.  */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|0
end_define

begin_comment
comment|/* disk is closed. */
end_comment

begin_define
define|#
directive|define
name|WANTOPEN
value|1
end_define

begin_comment
comment|/* open requested, not started */
end_comment

begin_define
define|#
directive|define
name|RECAL
value|2
end_define

begin_comment
comment|/* doing restore */
end_comment

begin_define
define|#
directive|define
name|OPEN
value|3
end_define

begin_comment
comment|/* done with open */
end_comment

begin_comment
comment|/*  * The structure of a disk drive.  */
end_comment

begin_struct
struct|struct
name|disk
block|{
name|long
name|dk_bc
decl_stmt|;
comment|/* byte count left */
name|short
name|dk_skip
decl_stmt|;
comment|/* blocks already transferred */
name|char
name|dk_unit
decl_stmt|;
comment|/* physical unit number */
name|char
name|dk_state
decl_stmt|;
comment|/* control state */
name|u_char
name|dk_status
decl_stmt|;
comment|/* copy of status reg. */
name|u_char
name|dk_error
decl_stmt|;
comment|/* copy of error reg. */
name|short
name|dk_port
decl_stmt|;
comment|/* i/o port base */
name|u_long
name|dk_copenpart
decl_stmt|;
comment|/* character units open on this drive */
name|u_long
name|dk_bopenpart
decl_stmt|;
comment|/* block units open on this drive */
name|u_long
name|dk_openpart
decl_stmt|;
comment|/* all units open on this drive */
name|short
name|dk_wlabel
decl_stmt|;
comment|/* label writable? */
name|short
name|dk_flags
decl_stmt|;
comment|/* drive characteistics found */
define|#
directive|define
name|DKFL_DOSPART
value|0x00001
comment|/* has DOS partition table */
define|#
directive|define
name|DKFL_QUIET
value|0x00002
comment|/* report errors back, but don't complain */
define|#
directive|define
name|DKFL_SINGLE
value|0x00004
comment|/* sector at a time mode */
define|#
directive|define
name|DKFL_ERROR
value|0x00008
comment|/* processing a disk error */
define|#
directive|define
name|DKFL_BSDLABEL
value|0x00010
comment|/* has a BSD disk label */
define|#
directive|define
name|DKFL_BADSECT
value|0x00020
comment|/* has a bad144 badsector table */
define|#
directive|define
name|DKFL_WRITEPROT
value|0x00040
comment|/* manual unit write protect */
name|struct
name|wdparams
name|dk_params
decl_stmt|;
comment|/* ESDI/IDE drive/controller parameters */
name|struct
name|disklabel
name|dk_dd
decl_stmt|;
comment|/* device configuration data */
name|struct
name|dos_partition
name|dk_dospartitions
index|[
name|NDOSPART
index|]
decl_stmt|;
comment|/* DOS view of disk */
name|struct
name|dkbad
name|dk_bad
decl_stmt|;
comment|/* bad sector table */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|disk
modifier|*
name|wddrives
index|[
name|_NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of units */
end_comment

begin_decl_stmt
name|struct
name|buf
name|wdtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|buf
name|wdutab
index|[
name|_NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of queue per drive */
end_comment

begin_decl_stmt
name|struct
name|buf
name|rwdbuf
index|[
name|_NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers for raw IO */
end_comment

begin_decl_stmt
name|long
name|wdxfer
index|[
name|_NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of transfers */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WDDEBUG
end_ifdef

begin_decl_stmt
name|int
name|wddebug
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|isa_driver
name|wddriver
init|=
block|{
name|wdprobe
block|,
name|wdattach
block|,
literal|"wd"
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|wdustart
parameter_list|(
name|struct
name|disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wdstart
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdcommand
parameter_list|(
name|struct
name|disk
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdcontrol
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdsetctlr
parameter_list|(
name|dev_t
parameter_list|,
name|struct
name|disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdgetctlr
parameter_list|(
name|int
parameter_list|,
name|struct
name|disk
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Probe for controller.  */
end_comment

begin_function
name|int
name|wdprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|wdc
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|_NWD
condition|)
comment|/* 31 Jul 92*/
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|disk
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|disk
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|du
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 31 Jul 92*/
name|du
operator|->
name|dk_unit
operator|=
name|unit
expr_stmt|;
block|}
name|wdc
operator|=
name|du
operator|->
name|dk_port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
comment|/* check if we have registers that work */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
literal|0xa5
argument_list|)
expr_stmt|;
comment|/* wd_cyl_lo is read/write */
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|)
operator|!=
literal|0xa5
condition|)
goto|goto
name|nodevice
goto|;
comment|/* reset the device */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
operator|(
name|WDCTL_RST
operator||
name|WDCTL_IDS
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_IDS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* execute a controller only command */
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
name|WDCC_DIAGNOSE
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nodevice
goto|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
expr_stmt|;
comment|/* XXX! */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_4BIT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|nodevice
label|:
name|free
argument_list|(
name|du
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|wddrives
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach each drive if possible.  */
end_comment

begin_function
name|int
name|wdattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
comment|/*	int unit = dvp->id_unit;*/
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|_NWD
condition|;
name|unit
operator|++
control|)
block|{
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
if|if
condition|(
operator|(
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|disk
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|disk
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|du
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_unit
operator|=
name|unit
expr_stmt|;
name|du
operator|->
name|dk_port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
block|}
comment|/* print out description of drive, suppressing multiple blanks*/
if|if
condition|(
name|wdgetctlr
argument_list|(
name|unit
argument_list|,
name|du
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|blank
decl_stmt|;
name|char
name|c
decl_stmt|;
name|printf
argument_list|(
literal|" %d:<"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|blank
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|blank
operator|&&
name|c
operator|==
literal|' '
condition|)
continue|continue;
if|if
condition|(
name|blank
operator|&&
name|c
operator|!=
literal|' '
condition|)
block|{
name|printf
argument_list|(
literal|" %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|blank
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
name|blank
operator|=
literal|1
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_unit
operator|=
name|unit
expr_stmt|;
block|}
else|else
block|{
comment|/* old ST506 controller */
name|printf
argument_list|(
literal|" %d:<wdgetctlr failed, assuming OK>"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read/write routine for a buffer.  Finds the proper unit, range checks  * arguments, and schedules the transfer.  Does not wait for the transfer  * to complete.  Multi-page transfers are supported.  All I/O requests must  * be a multiple of a sector in length.  */
end_comment

begin_function
name|int
name|wdstrategy
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|partition
modifier|*
name|p
decl_stmt|;
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
comment|/* Disk unit to do the IO.	*/
name|long
name|maxsz
decl_stmt|,
name|sz
decl_stmt|;
name|int
name|unit
init|=
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* valid unit, controller, and request?  */
if|if
condition|(
name|unit
operator|>=
name|_NWD
operator|||
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|||
operator|(
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* "soft" write protect check */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_WRITEPROT
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* have partitions and want to use them? */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_BSDLABEL
operator|)
operator|!=
literal|0
operator|&&
name|wdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|!=
name|WDRAW
condition|)
block|{
comment|/* 		 * do bounds checking, adjust transfer. if error, process. 		 * if end of partition, just return 		 */
if|if
condition|(
name|bounds_check_with_label
argument_list|(
name|bp
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
name|du
operator|->
name|dk_wlabel
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* otherwise, process transfer request */
block|}
name|q
label|:
comment|/* queue transfer on drive, activate drive and controller if idle */
name|dp
operator|=
operator|&
name|wdutab
index|[
name|unit
index|]
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
name|wdustart
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* start drive */
if|if
condition|(
name|wdtab
operator|.
name|b_active
operator|==
literal|0
condition|)
name|wdstart
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* start controller */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|done
label|:
comment|/* toss transfer, we're done early */
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to queue a command to the controller.  The unit's  * request is linked into the active list for the controller.  * If the controller is idle, the transfer is started.  */
end_comment

begin_function
specifier|static
name|void
name|wdustart
parameter_list|(
specifier|register
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
init|=
operator|&
name|wdutab
index|[
name|du
operator|->
name|dk_unit
index|]
decl_stmt|;
comment|/* unit already active? */
if|if
condition|(
name|dp
operator|->
name|b_active
condition|)
return|return;
comment|/* anything to start? */
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return;
comment|/* link onto controller queue */
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|wdtab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|wdtab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|wdtab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|wdtab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
comment|/* mark the drive unit as busy */
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Controller startup routine.  This does the calculation, and starts  * a single-sector read or write operation.  Called to start a transfer,  * or from the interrupt routine to continue a multi-sector transfer.  * RESTRICTIONS:  * 1.	The transfer length must be an exact multiple of the sector size.  */
end_comment

begin_function
specifier|static
name|void
name|wdstart
parameter_list|()
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
comment|/* disk unit for IO */
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|bt_bad
modifier|*
name|bt_ptr
decl_stmt|;
name|long
name|blknum
decl_stmt|,
name|pagcnt
decl_stmt|,
name|cylin
decl_stmt|,
name|head
decl_stmt|,
name|sector
decl_stmt|;
name|long
name|secpertrk
decl_stmt|,
name|secpercyl
decl_stmt|,
name|addr
decl_stmt|,
name|i
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|s
decl_stmt|,
name|wdc
decl_stmt|;
name|loop
label|:
comment|/* is there a drive for the controller to do a transfer with? */
name|dp
operator|=
name|wdtab
operator|.
name|b_actf
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return;
comment|/* is there a transfer to this drive ? if so, link it on 	   the controller's queue */
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|wdtab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* obtain controller and drive information */
name|unit
operator|=
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
comment|/* if not really a transfer, do control operations specially */
if|if
condition|(
name|du
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
block|{
operator|(
name|void
operator|)
name|wdcontrol
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* calculate transfer details */
name|blknum
operator|=
name|bp
operator|->
name|b_blkno
operator|+
name|du
operator|->
name|dk_skip
expr_stmt|;
comment|/*if(wddebug)printf("bn%d ", blknum);*/
ifdef|#
directive|ifdef
name|WDDEBUG
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\nwdstart %d: %s %d@%d; map "
argument_list|,
name|unit
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %d)%x"
argument_list|,
name|du
operator|->
name|dk_skip
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_altsts
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
condition|)
name|du
operator|->
name|dk_bc
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|lp
operator|=
operator|&
name|du
operator|->
name|dk_dd
expr_stmt|;
name|secpertrk
operator|=
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|secpercyl
operator|=
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_BSDLABEL
operator|)
operator|!=
literal|0
operator|&&
name|wdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|!=
name|WDRAW
condition|)
name|blknum
operator|+=
name|lp
operator|->
name|d_partitions
index|[
name|wdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|p_offset
expr_stmt|;
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
comment|/*  	 * See if the current block is in the bad block list. 	 * (If we have one, and not formatting.) 	 */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_SINGLE
operator||
name|DKFL_BADSECT
operator|)
operator|)
comment|/* 19 Aug 92*/
operator|==
operator|(
name|DKFL_SINGLE
operator||
name|DKFL_BADSECT
operator|)
condition|)
comment|/* XXX 	     * BAD144END was done to clean up some old bad code that was 	     * attempting to compare a u_short to -1.  This makes the compilers 	     * happy and clearly shows what is going on. 	     * rgrimes 93/06/17 	     */
define|#
directive|define
name|BAD144END
value|(u_short)(-1)
for|for
control|(
name|bt_ptr
operator|=
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
init|;
name|bt_ptr
operator|->
name|bt_cyl
operator|!=
name|BAD144END
condition|;
name|bt_ptr
operator|++
control|)
block|{
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|>
name|cylin
condition|)
comment|/* Sorted list, and we passed our cylinder. quit. */
break|break;
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|==
name|cylin
operator|&&
name|bt_ptr
operator|->
name|bt_trksec
operator|==
operator|(
name|head
operator|<<
literal|8
operator|)
operator|+
name|sector
condition|)
block|{
comment|/* 			 * Found bad block.  Calculate new block addr. 			 * This starts at the end of the disk (skip the 			 * last track which is used for the bad block list), 			 * and works backwards to the front of the disk. 			 */
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"--- badblock code -> Old = %d; "
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|blknum
operator|=
name|lp
operator|->
name|d_secperunit
operator|-
name|lp
operator|->
name|d_nsectors
operator|-
operator|(
name|bt_ptr
operator|-
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
operator|)
operator|-
literal|1
expr_stmt|;
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"new = %d\n"
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
comment|/*if(wddebug)pg("c%d h%d s%d ", cylin, head, sector);*/
name|sector
operator|+=
literal|1
expr_stmt|;
comment|/* sectors begin with 1, not 0 */
name|wdtab
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
comment|/* mark controller active */
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
name|RETRY
label|:
comment|/* if starting a multisector transfer, or doing single transfers */
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
operator|||
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
operator|)
condition|)
block|{
if|if
condition|(
name|wdtab
operator|.
name|b_errcnt
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
name|du
operator|->
name|dk_bc
operator|+=
name|DEV_BSIZE
expr_stmt|;
comment|/* controller idle? */
name|timeout
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_BUSY
condition|)
block|{
if|if
condition|(
operator|++
name|timeout
operator|>
name|WDCTIMEOUT
condition|)
block|{
name|printf
argument_list|(
literal|"wd.c: Controller busy too long!\n"
argument_list|)
expr_stmt|;
comment|/* reset the device */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
operator|(
name|WDCTL_RST
operator||
name|WDCTL_IDS
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_IDS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
expr_stmt|;
comment|/* XXX! */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_4BIT
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* stuff the task file */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_precomp
argument_list|,
name|lp
operator|->
name|d_precompcyl
operator|/
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|B_FORMAT
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FORMAT
condition|)
block|{
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|,
name|lp
operator|->
name|d_gap3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
name|lp
operator|->
name|d_nsectors
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
condition|)
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
name|howmany
argument_list|(
name|du
operator|->
name|dk_bc
argument_list|,
name|DEV_BSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|,
name|sector
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|B_FORMAT
block|}
endif|#
directive|endif
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
name|cylin
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|,
name|cylin
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* set up the SDH register (select drive) */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
operator||
operator|(
name|head
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
comment|/* wait for drive to become ready */
name|timeout
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_READY
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|timeout
operator|>
name|WDCTIMEOUT
condition|)
block|{
name|printf
argument_list|(
literal|"wd.c: Drive busy too long!\n"
argument_list|)
expr_stmt|;
comment|/* reset the device */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
operator|(
name|WDCTL_RST
operator||
name|WDCTL_IDS
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_IDS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
expr_stmt|;
comment|/* XXX! */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_4BIT
argument_list|)
expr_stmt|;
goto|goto
name|RETRY
goto|;
block|}
block|}
comment|/* initiate command! */
ifdef|#
directive|ifdef
name|B_FORMAT
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FORMAT
condition|)
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|WDCC_FORMAT
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|WDCC_READ
else|:
name|WDCC_WRITE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"sector %d cylin %d head %d addr %x sts %x\n"
argument_list|,
name|sector
argument_list|,
name|cylin
argument_list|,
name|head
argument_list|,
name|addr
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_altsts
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* if this is a read operation, just go away until it's done.	*/
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
return|return;
comment|/* ready to send data?	*/
name|timeout
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_DRQ
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|timeout
operator|>
name|WDCTIMEOUT
condition|)
block|{
name|printf
argument_list|(
literal|"wd.c: Drive not ready for too long!\n"
argument_list|)
expr_stmt|;
comment|/* reset the device */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
operator|(
name|WDCTL_RST
operator||
name|WDCTL_IDS
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_IDS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
expr_stmt|;
comment|/* XXX! */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_4BIT
argument_list|)
expr_stmt|;
goto|goto
name|RETRY
goto|;
block|}
block|}
comment|/* then send it! */
name|outsw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
name|addr
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
argument_list|,
name|DEV_BSIZE
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_bc
operator|-=
name|DEV_BSIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Interrupt routine for the controller.  Acknowledge the interrupt, check for  * errors on the current operation, mark it done if necessary, and start  * the next request.  Also check for a partially done transfer, and  * continue with the next chunk if so.  */
end_comment

begin_function
name|void
name|wdintr
parameter_list|(
name|struct
name|intrframe
name|wdif
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|status
decl_stmt|,
name|wdc
decl_stmt|;
name|char
name|partch
decl_stmt|;
if|if
condition|(
operator|!
name|wdtab
operator|.
name|b_active
condition|)
block|{
ifdef|#
directive|ifdef
name|nyet
name|printf
argument_list|(
literal|"wd: extra interrupt\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|dp
operator|=
name|wdtab
operator|.
name|b_actf
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|du
operator|=
name|wddrives
index|[
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"I "
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|status
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|)
operator|&
name|WDCS_BUSY
condition|)
empty_stmt|;
comment|/* is it not a transfer, but a control operation? */
if|if
condition|(
name|du
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
block|{
if|if
condition|(
name|wdcontrol
argument_list|(
name|bp
argument_list|)
condition|)
name|wdstart
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* have we an error? */
if|if
condition|(
name|status
operator|&
operator|(
name|WDCS_ERR
operator||
name|WDCS_ECCCOR
operator|)
condition|)
block|{
name|du
operator|->
name|dk_status
operator|=
name|status
expr_stmt|;
name|du
operator|->
name|dk_error
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"status %x error %x\n"
argument_list|,
name|status
argument_list|,
name|du
operator|->
name|dk_error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_ERROR
expr_stmt|;
goto|goto
name|outt
goto|;
block|}
ifdef|#
directive|ifdef
name|B_FORMAT
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FORMAT
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
comment|/* 17 Sep 92*/
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
comment|/* error or error correction? */
if|if
condition|(
name|status
operator|&
name|WDCS_ERR
condition|)
block|{
if|if
condition|(
operator|++
name|wdtab
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
block|{
name|wdtab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_QUIET
operator|)
operator|==
literal|0
condition|)
block|{
name|diskerr
argument_list|(
name|bp
argument_list|,
literal|"wd"
argument_list|,
literal|"hard error"
argument_list|,
name|LOG_PRINTF
argument_list|,
name|du
operator|->
name|dk_skip
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"status %b error %b\n"
argument_list|,
name|status
argument_list|,
name|WDCS_BITS
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
argument_list|,
name|WDERR_BITS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
comment|/* 17 Sep 92*/
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* flag the error */
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_QUIET
operator|)
operator|==
literal|0
condition|)
block|{
name|diskerr
argument_list|(
name|bp
argument_list|,
literal|"wd"
argument_list|,
literal|"soft ecc"
argument_list|,
literal|0
argument_list|,
name|du
operator|->
name|dk_skip
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|)
expr_stmt|;
block|}
block|}
name|outt
label|:
comment|/* 	 * If this was a successful read operation, fetch the data. 	 */
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_READ
operator||
name|B_ERROR
operator|)
operator|)
operator|==
name|B_READ
operator|)
operator|&&
name|wdtab
operator|.
name|b_active
condition|)
block|{
name|int
name|chk
decl_stmt|,
name|dummy
decl_stmt|;
name|chk
operator|=
name|min
argument_list|(
name|DEV_BSIZE
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
name|du
operator|->
name|dk_bc
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ready to receive data? */
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_DRQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* suck in data */
name|insw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_bc
operator|-=
name|chk
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* for obselete fractional sector reads */
while|while
condition|(
name|chk
operator|++
operator|<
literal|256
condition|)
name|insw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|wdxfer
index|[
name|du
operator|->
name|dk_unit
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|wdtab
operator|.
name|b_active
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_skip
operator|++
expr_stmt|;
comment|/* Add to successful sectors. */
if|if
condition|(
name|wdtab
operator|.
name|b_errcnt
operator|&&
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_QUIET
operator|)
operator|==
literal|0
condition|)
name|diskerr
argument_list|(
name|bp
argument_list|,
literal|"wd"
argument_list|,
literal|"soft error"
argument_list|,
literal|0
argument_list|,
name|du
operator|->
name|dk_skip
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|)
expr_stmt|;
name|wdtab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
comment|/* see if more to transfer */
if|if
condition|(
name|du
operator|->
name|dk_bc
operator|>
literal|0
operator|&&
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|wdstart
argument_list|()
expr_stmt|;
return|return;
comment|/* next chunk is started */
block|}
elseif|else
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_SINGLE
operator||
name|DKFL_ERROR
operator|)
operator|)
operator|==
name|DKFL_ERROR
condition|)
block|{
name|du
operator|->
name|dk_skip
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_ERROR
expr_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_SINGLE
expr_stmt|;
name|wdstart
argument_list|()
expr_stmt|;
return|return;
comment|/* redo xfer sector by sector */
block|}
block|}
name|done
label|:
comment|/* done with this transfer, with or without error */
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_SINGLE
expr_stmt|;
name|wdtab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
name|wdtab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_skip
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|dp
operator|->
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* controller idle */
name|wdtab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
comment|/* anything more on drive queue? */
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
name|wdustart
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* anything more for controller to do? */
if|if
condition|(
name|wdtab
operator|.
name|b_actf
condition|)
name|wdstart
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a drive.  */
end_comment

begin_function
name|int
name|wdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|part
init|=
name|wdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|mask
init|=
literal|1
operator|<<
name|part
decl_stmt|;
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
name|struct
name|dkbad
modifier|*
name|db
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|unit
operator|=
name|wdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|_NWD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|du
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_BSDLABEL
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_WRITEPROT
expr_stmt|;
name|wdutab
index|[
name|unit
index|]
operator|.
name|b_actf
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Use the default sizes until we've read the label, 		 * or longer if there isn't one there. 		 */
name|bzero
argument_list|(
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
sizeof|sizeof
argument_list|(
name|du
operator|->
name|dk_dd
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|d_type
comment|/* fix goddamn segments.h! XXX */
name|du
operator|->
name|dk_dd
operator|.
name|d_type
operator|=
name|DTYPE_ST506
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|=
literal|1024
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
literal|8
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|=
literal|17
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|=
literal|17
operator|*
literal|8
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
name|du
operator|->
name|dk_unit
operator|=
name|unit
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_QUIET
expr_stmt|;
comment|/* read label using "c" partition */
if|if
condition|(
name|msg
operator|=
name|readdisklabel
argument_list|(
name|makewddev
argument_list|(
name|major
argument_list|(
name|dev
argument_list|)
argument_list|,
name|wdunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|WDRAW
argument_list|)
argument_list|,
name|wdstrategy
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
name|du
operator|->
name|dk_dospartitions
argument_list|,
operator|&
name|du
operator|->
name|dk_bad
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_QUIET
operator|)
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wd%d: cannot find label (%s)\n"
argument_list|,
name|unit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* XXX needs translation */
block|}
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|wdsetctlr
argument_list|(
name|dev
argument_list|,
name|du
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_BSDLABEL
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_WRITEPROT
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_dd
operator|.
name|d_flags
operator|&
name|D_BADSECT
condition|)
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_BADSECT
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*          * Warn if a partion is opened          * that overlaps another partition which is open          * unless one is the "raw" partition (whole disk).          */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_openpart
operator|&
name|mask
operator|)
operator|==
literal|0
comment|/*&& part != RAWPART*/
operator|&&
name|part
operator|!=
name|WDRAW
condition|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|pp
operator|=
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
expr_stmt|;
name|start
operator|=
name|pp
operator|->
name|p_offset
expr_stmt|;
name|end
operator|=
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
init|;
name|pp
operator|<
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|du
operator|->
name|dk_dd
operator|.
name|d_npartitions
index|]
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
operator|<=
name|start
operator|||
name|pp
operator|->
name|p_offset
operator|>=
name|end
condition|)
continue|continue;
comment|/*if (pp - du->dk_dd.d_partitions == RAWPART)                                 continue; */
if|if
condition|(
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|==
name|WDRAW
condition|)
continue|continue;
if|if
condition|(
name|du
operator|->
name|dk_openpart
operator|&
operator|(
literal|1
operator|<<
operator|(
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wd%d%c: overlaps open partition (%c)\n"
argument_list|,
name|unit
argument_list|,
name|part
operator|+
literal|'a'
argument_list|,
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|part
operator|>=
name|du
operator|->
name|dk_dd
operator|.
name|d_npartitions
operator|&&
name|part
operator|!=
name|WDRAW
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* insure only one open at a time */
name|du
operator|->
name|dk_openpart
operator||=
name|mask
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|du
operator|->
name|dk_copenpart
operator||=
name|mask
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|du
operator|->
name|dk_bopenpart
operator||=
name|mask
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement operations other than read/write.  * Called from wdstart or wdintr during opens and formats.  * Uses finite-state-machine to track progress of operation in progress.  * Returns 0 if operation still in progress, 1 if completed.  */
end_comment

begin_function
specifier|static
name|int
name|wdcontrol
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|unit
expr_stmt|;
name|unsigned
name|char
name|stat
decl_stmt|;
name|int
name|s
decl_stmt|,
name|cnt
decl_stmt|;
specifier|extern
name|int
name|bootdev
decl_stmt|;
name|int
name|cyl
decl_stmt|,
name|trk
decl_stmt|,
name|sec
decl_stmt|,
name|i
decl_stmt|,
name|wdc
decl_stmt|;
name|struct
name|wdparams
name|foo
decl_stmt|;
name|du
operator|=
name|wddrives
index|[
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|unit
operator|=
name|du
operator|->
name|dk_unit
expr_stmt|;
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
switch|switch
condition|(
name|du
operator|->
name|dk_state
condition|)
block|{
name|tryagainrecal
label|:
case|case
name|WANTOPEN
case|:
comment|/* set SDH, step rate, do restore */
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"wd%d: recal "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* not called from intr level ... */
name|wdgetctlr
argument_list|(
name|unit
argument_list|,
name|du
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|wdtab
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
comment|/* wait for drive and controller to become ready */
for|for
control|(
name|i
operator|=
name|WDCTIMEOUT
init|;
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
operator|(
name|WDCS_READY
operator||
name|WDCS_BUSY
operator|)
operator|)
operator|!=
name|WDCS_READY
operator|&&
name|i
operator|--
operator|!=
literal|0
condition|;
control|)
empty_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RECAL
case|:
if|if
condition|(
operator|(
name|stat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|)
operator|&
name|WDCS_ERR
condition|)
block|{
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_QUIET
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"wd%d: recal"
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|": status %b error %b\n"
argument_list|,
name|stat
argument_list|,
name|WDCS_BITS
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
argument_list|,
name|WDERR_BITS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|wdtab
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
block|{
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
goto|goto
name|tryagainrecal
goto|;
block|}
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
comment|/* XXX needs translation */
goto|goto
name|badopen
goto|;
block|}
comment|/* some controllers require this ... */
name|wdsetctlr
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|,
name|du
argument_list|)
expr_stmt|;
name|wdtab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
comment|/* 		 * The rest of the initialization can be done 		 * by normal means. 		 */
return|return
operator|(
literal|1
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"wdcontrol"
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
name|badopen
label|:
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_QUIET
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|": status %b error %b\n"
argument_list|,
name|stat
argument_list|,
name|WDCS_BITS
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
argument_list|,
name|WDERR_BITS
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * send a command and wait uninterruptibly until controller is finished.  * return -1 if controller busy for too long, otherwise  * return status. intended for brief controller commands at critical points.  * assumes interrupts are blocked.  */
end_comment

begin_function
specifier|static
name|int
name|wdcommand
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|int
name|timeout
init|=
name|WDCTIMEOUT
decl_stmt|,
name|stat
decl_stmt|,
name|wdc
decl_stmt|;
comment|/* controller ready for command? */
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|stat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|)
operator|&
name|WDCS_BUSY
operator|)
operator|&&
name|timeout
operator|>
literal|0
condition|)
name|timeout
operator|--
expr_stmt|;
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* send command, await results */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|stat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|)
operator|&
name|WDCS_BUSY
operator|)
operator|&&
name|timeout
operator|>
literal|0
condition|)
name|timeout
operator|--
expr_stmt|;
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|cmd
operator|!=
name|WDCC_READP
condition|)
return|return
operator|(
name|stat
operator|)
return|;
comment|/* is controller ready to return data? */
while|while
condition|(
operator|(
operator|(
name|stat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|)
operator|&
operator|(
name|WDCS_ERR
operator||
name|WDCS_DRQ
operator|)
operator|)
operator|==
literal|0
operator|&&
name|timeout
operator|>
literal|0
condition|)
name|timeout
operator|--
expr_stmt|;
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * issue IDC to drive to tell it just what geometry it is to be.  */
end_comment

begin_function
specifier|static
name|int
name|wdsetctlr
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|int
name|stat
decl_stmt|,
name|x
decl_stmt|,
name|wdc
decl_stmt|;
comment|/*printf("C%dH%dS%d ", du->dk_dd.d_ncylinders, du->dk_dd.d_ntracks, 	du->dk_dd.d_nsectors);*/
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|,
operator|(
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|+
literal|1
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|wdunit
argument_list|(
name|dev
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
argument_list|)
expr_stmt|;
name|stat
operator|=
name|wdcommand
argument_list|(
name|du
argument_list|,
name|WDCC_IDC
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|<
literal|0
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
if|if
condition|(
name|stat
operator|&
name|WDCS_ERR
condition|)
name|printf
argument_list|(
literal|"wdsetctlr: status %b error %b\n"
argument_list|,
name|stat
argument_list|,
name|WDCS_BITS
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
argument_list|,
name|WDERR_BITS
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * issue READP to drive to ask it what it is.  */
end_comment

begin_function
specifier|static
name|int
name|wdgetctlr
parameter_list|(
name|int
name|u
parameter_list|,
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|int
name|stat
decl_stmt|,
name|x
decl_stmt|,
name|i
decl_stmt|,
name|wdc
decl_stmt|;
name|char
name|tb
index|[
name|DEV_BSIZE
index|]
decl_stmt|;
name|struct
name|wdparams
modifier|*
name|wp
decl_stmt|;
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* not called from intr level ... */
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|u
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|stat
operator|=
name|wdcommand
argument_list|(
name|du
argument_list|,
name|WDCC_READP
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|<
literal|0
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
if|if
condition|(
name|stat
operator|&
name|WDCS_ERR
condition|)
block|{
name|stat
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
comment|/* obtain parameters */
name|wp
operator|=
operator|&
name|du
operator|->
name|dk_params
expr_stmt|;
name|insw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
name|tb
argument_list|,
sizeof|sizeof
argument_list|(
name|tb
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tb
argument_list|,
name|wp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wdparams
argument_list|)
argument_list|)
expr_stmt|;
comment|/* shuffle string byte order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|wp
operator|->
name|wdp_model
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|u_short
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|wp
operator|->
name|wdp_model
operator|+
name|i
operator|)
expr_stmt|;
operator|*
name|p
operator|=
name|ntohs
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
comment|/*printf("gc %x cyl %d trk %d sec %d type %d sz %d model %s\n", wp->wdp_config, wp->wdp_fixedcyl+wp->wdp_removcyl, wp->wdp_heads, wp->wdp_sectors, wp->wdp_cntype, wp->wdp_cnsbsz, wp->wdp_model);*/
comment|/* update disklabel given drive information */
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|=
name|wp
operator|->
name|wdp_fixedcyl
operator|+
name|wp
operator|->
name|wdp_removcyl
comment|/*+- 1*/
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
name|wp
operator|->
name|wdp_heads
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|=
name|wp
operator|->
name|wdp_sectors
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
literal|1
index|]
operator|.
name|p_size
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|*
name|wp
operator|->
name|wdp_sectors
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
literal|1
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
comment|/* dubious ... */
name|bcopy
argument_list|(
literal|"ESDI/IDE"
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_typename
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|wp
operator|->
name|wdp_model
operator|+
literal|20
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_packname
argument_list|,
literal|14
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* better ... */
name|du
operator|->
name|dk_dd
operator|.
name|d_type
operator|=
name|DTYPE_ESDI
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_subtype
operator||=
name|DSTYPE_GEOMETRY
expr_stmt|;
comment|/* XXX sometimes possibly needed */
operator|(
name|void
operator|)
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|wdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|part
init|=
name|wdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|mask
init|=
literal|1
operator|<<
name|part
decl_stmt|;
name|du
operator|=
name|wddrives
index|[
name|wdunit
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
comment|/* insure only one open at a time */
name|du
operator|->
name|dk_openpart
operator|&=
operator|~
name|mask
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|du
operator|->
name|dk_copenpart
operator|&=
operator|~
name|mask
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|du
operator|->
name|dk_bopenpart
operator|&=
operator|~
name|mask
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|unit
init|=
name|wdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCSBAD
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|du
operator|->
name|dk_bad
operator|=
operator|*
operator|(
expr|struct
name|dkbad
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
operator|=
name|du
operator|->
name|dk_dd
expr_stmt|;
break|break;
case|case
name|DIOCGPART
case|:
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|disklab
operator|=
operator|&
name|du
operator|->
name|dk_dd
expr_stmt|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|part
operator|=
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|wdpart
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|DIOCSDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|error
operator|=
name|setdisklabel
argument_list|(
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
argument_list|,
comment|/*(du->dk_flags& DKFL_BSDLABEL) ? du->dk_openpart : */
literal|0
argument_list|,
name|du
operator|->
name|dk_dospartitions
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_BSDLABEL
expr_stmt|;
name|wdsetctlr
argument_list|(
name|dev
argument_list|,
name|du
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DIOCWLABEL
case|:
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_WRITEPROT
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|du
operator|->
name|dk_wlabel
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|DIOCWDINFO
case|:
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_WRITEPROT
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|setdisklabel
argument_list|(
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
argument_list|,
comment|/*(du->dk_flags& DKFL_BSDLABEL) ? du->dk_openpart :*/
literal|0
argument_list|,
name|du
operator|->
name|dk_dospartitions
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|wlab
decl_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_BSDLABEL
expr_stmt|;
name|wdsetctlr
argument_list|(
name|dev
argument_list|,
name|du
argument_list|)
expr_stmt|;
comment|/* simulate opening partition 0 so write succeeds */
name|du
operator|->
name|dk_openpart
operator||=
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
comment|/* XXX */
name|wlab
operator|=
name|du
operator|->
name|dk_wlabel
expr_stmt|;
name|du
operator|->
name|dk_wlabel
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|writedisklabel
argument_list|(
name|dev
argument_list|,
name|wdstrategy
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
name|du
operator|->
name|dk_dospartitions
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_openpart
operator|=
name|du
operator|->
name|dk_copenpart
operator||
name|du
operator|->
name|dk_bopenpart
expr_stmt|;
name|du
operator|->
name|dk_wlabel
operator|=
name|wlab
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|notyet
case|case
name|DIOCGDINFOP
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|*
operator|)
name|addr
operator|=
operator|&
operator|(
name|du
operator|->
name|dk_dd
operator|)
expr_stmt|;
break|break;
case|case
name|DIOCWFORMAT
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|format_op
modifier|*
name|fop
decl_stmt|;
name|fop
operator|=
operator|(
expr|struct
name|format_op
operator|*
operator|)
name|addr
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|fop
operator|->
name|df_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|fop
operator|->
name|df_startblk
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
name|error
operator|=
name|physio
argument_list|(
name|wdformat
argument_list|,
operator|&
name|rwdbuf
index|[
name|unit
index|]
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
name|fop
operator|->
name|df_count
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|fop
operator|->
name|df_reg
index|[
literal|0
index|]
operator|=
name|du
operator|->
name|dk_status
expr_stmt|;
name|fop
operator|->
name|df_reg
index|[
literal|1
index|]
operator|=
name|du
operator|->
name|dk_error
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|B_FORMAT
end_ifdef

begin_function
name|int
name|wdformat
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_FORMAT
expr_stmt|;
return|return
operator|(
name|wdstrategy
argument_list|(
name|bp
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|wdsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|wdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|part
init|=
name|wdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|val
decl_stmt|;
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|_NWD
condition|)
comment|/* 31 Jul 92*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|du
operator|==
literal|0
operator|||
name|du
operator|->
name|dk_state
operator|==
literal|0
condition|)
name|val
operator|=
name|wdopen
argument_list|(
name|makewddev
argument_list|(
name|major
argument_list|(
name|dev
argument_list|)
argument_list|,
name|unit
argument_list|,
name|WDRAW
argument_list|)
argument_list|,
name|FREAD
argument_list|,
name|S_IFBLK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|==
literal|0
operator|||
name|val
operator|!=
literal|0
operator|||
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_WRITEPROT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|(
name|int
operator|)
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|vmmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* poor name! */
end_comment

begin_function
name|int
name|wddump
parameter_list|(
name|dev_t
name|dev
parameter_list|)
comment|/* dump core after a system crash */
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
comment|/* disk unit to do the IO */
specifier|register
name|struct
name|bt_bad
modifier|*
name|bt_ptr
decl_stmt|;
name|long
name|num
decl_stmt|;
comment|/* number of sectors to write */
name|int
name|unit
decl_stmt|,
name|part
decl_stmt|,
name|wdc
decl_stmt|;
name|long
name|blkoff
decl_stmt|,
name|blknum
decl_stmt|,
name|blkcnt
decl_stmt|;
name|long
name|cylin
decl_stmt|,
name|head
decl_stmt|,
name|sector
decl_stmt|,
name|stat
decl_stmt|;
name|long
name|secpertrk
decl_stmt|,
name|secpercyl
decl_stmt|,
name|nblocks
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
specifier|extern
name|int
name|Maxmem
decl_stmt|;
specifier|static
name|wddoingadump
operator|=
literal|0
expr_stmt|;
specifier|extern
name|caddr_t
name|CADDR1
decl_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* starting address */
comment|/* toss any characters present prior to dump */
while|while
condition|(
name|sgetc
argument_list|(
literal|1
argument_list|)
condition|)
empty_stmt|;
comment|/* size of memory to dump */
name|num
operator|=
name|Maxmem
expr_stmt|;
name|unit
operator|=
name|wdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* eventually support floppies? */
name|part
operator|=
name|wdpart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* file system */
comment|/* check for acceptable drive number */
if|if
condition|(
name|unit
operator|>=
name|_NWD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 31 Jul 92*/
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|du
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* was it ever initialized ? */
if|if
condition|(
name|du
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_WRITEPROT
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
comment|/* Convert to disk sectors */
name|num
operator|=
operator|(
name|u_long
operator|)
name|num
operator|*
name|NBPG
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
comment|/* check if controller active */
comment|/*if (wdtab.b_active) return(EFAULT); */
if|if
condition|(
name|wddoingadump
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|secpertrk
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
expr_stmt|;
name|nblocks
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
expr_stmt|;
name|blkoff
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
expr_stmt|;
comment|/*pg("xunit %x, nblocks %d, dumplo %d num %d\n", part,nblocks,dumplo,num);*/
comment|/* check transfer bounds against partition size */
if|if
condition|(
operator|(
name|dumplo
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|dumplo
operator|+
name|num
operator|)
operator|>
name|nblocks
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*wdtab.b_active = 1;		/* mark controller active for if we 					   panic during the dump */
name|wddoingadump
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|100000
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_BUSY
operator|)
operator|&&
operator|(
name|i
operator|--
operator|>
literal|0
operator|)
condition|)
empty_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_BUSY
condition|)
empty_stmt|;
comment|/* some compaq controllers require this ... */
name|wdsetctlr
argument_list|(
name|dev
argument_list|,
name|du
argument_list|)
expr_stmt|;
name|blknum
operator|=
name|dumplo
operator|+
name|blkoff
expr_stmt|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|blkcnt
operator|>
name|MAXTRANSFER
condition|)
name|blkcnt
operator|=
name|MAXTRANSFER
expr_stmt|;
if|if
condition|(
operator|(
name|blknum
operator|+
name|blkcnt
operator|-
literal|1
operator|)
operator|/
name|secpercyl
operator|!=
name|blknum
operator|/
name|secpercyl
condition|)
name|blkcnt
operator|=
name|secpercyl
operator|-
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
expr_stmt|;
comment|/* keep transfer within current cylinder */
endif|#
directive|endif
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
name|CADDR1
argument_list|,
name|trunc_page
argument_list|(
name|addr
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* compute disk address */
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/*  		 * See if the current block is in the bad block list. 		 * (If we have one.) 		 */
for|for
control|(
name|bt_ptr
operator|=
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
init|;
name|bt_ptr
operator|->
name|bt_cyl
operator|!=
operator|-
literal|1
condition|;
name|bt_ptr
operator|++
control|)
block|{
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|>
name|cylin
condition|)
comment|/* Sorted list, and we passed our cylinder. 					quit. */
break|break;
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|==
name|cylin
operator|&&
name|bt_ptr
operator|->
name|bt_trksec
operator|==
operator|(
name|head
operator|<<
literal|8
operator|)
operator|+
name|sector
condition|)
block|{
comment|/* 			 * Found bad block.  Calculate new block addr. 			 * This starts at the end of the disk (skip the 			 * last track which is used for the bad block list), 			 * and works backwards to the front of the disk. 			 */
name|blknum
operator|=
operator|(
name|du
operator|->
name|dk_dd
operator|.
name|d_secperunit
operator|)
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|-
operator|(
name|bt_ptr
operator|-
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
operator|)
operator|-
literal|1
expr_stmt|;
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|sector
operator|++
expr_stmt|;
comment|/* origin 1 */
comment|/* select drive.     */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
operator||
operator|(
name|head
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_READY
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* transfer some blocks */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
name|cylin
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|,
name|cylin
operator|>>
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* lets just talk about this first...*/
name|pg
argument_list|(
literal|"sdh 0%o sector %d cyl %d addr 0x%x"
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|)
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|)
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|)
operator|*
literal|256
operator|+
name|inb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|WDCC_WRITE
argument_list|)
expr_stmt|;
comment|/* Ready to send data?	*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_DRQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_ERR
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|outsw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
name|CADDR1
operator|+
operator|(
operator|(
name|int
operator|)
name|addr
operator|&
operator|(
name|NBPG
operator|-
literal|1
operator|)
operator|)
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_ERR
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Check data request (should be done).         */
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_DRQ
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* wait for completion */
for|for
control|(
name|i
operator|=
name|WDCTIMEOUT
init|;
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_BUSY
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* error check the xfer */
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_ERR
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|addr
operator|%
operator|(
literal|1024
operator|*
literal|1024
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|num
operator|/
literal|2048
argument_list|)
expr_stmt|;
comment|/* update block count */
name|num
operator|--
expr_stmt|;
name|blknum
operator|++
expr_stmt|;
operator|(
name|int
operator|)
name|addr
operator|+=
literal|512
expr_stmt|;
comment|/* operator aborting dump? */
if|if
condition|(
name|sgetc
argument_list|(
literal|1
argument_list|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

