begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * cyclades cyclom-y serial driver  *	Andrew Herbert<andrew@werple.apana.org.au>, 17 August 1993  *  * Copyright (c) 1993 Andrew Herbert.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name Andrew Herbert may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN  * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	$Id: cy.c,v 1.6 1995/03/28 12:29:11 bde Exp $  */
end_comment

begin_comment
comment|/*  * Device minor number encoding:  *  *	c c x x u u u u		- bits in the minor device number  *  *	bits	meaning  *	----	-------  *	uuuu	physical serial line (i.e. unit) to use  *			0-7 on a cyclom-8Y, 0-15 on a cyclom-16Y  *	xx	unused  *	cc	carrier control mode  *			00	complete hardware carrier control of the tty.  *				DCD must be high for the open(2) to complete.  *			01	dialin pseudo-device (not yet implemented)  *			10	carrier ignored until a high->low transition  *			11	carrier completed ignored  */
end_comment

begin_comment
comment|/*  * Known deficiencies:  *  *	* no BREAK handling - breaks are ignored, and can't be sent either  *	* no support for bad-char reporting, except via PARMRK  *	* no support for dialin + dialout devices  */
end_comment

begin_include
include|#
directive|include
file|"cy.h"
end_include

begin_if
if|#
directive|if
name|NCY
operator|>
literal|0
end_if

begin_comment
comment|/* This disgusing hack because we actually have 16 units on one controller */
end_comment

begin_if
if|#
directive|if
name|NCY
operator|<
literal|2
end_if

begin_undef
undef|#
directive|undef
name|NCY
end_undef

begin_define
define|#
directive|define
name|NCY
value|(16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NetBSD
end_ifdef

begin_include
include|#
directive|include
file|<machine/pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ic/cd1400.h>
end_include

begin_define
define|#
directive|define
name|RxFifoThreshold
value|3
end_define

begin_comment
comment|/* 3 characters (out of 12) in the receive 				 * FIFO before an interrupt is generated 				 */
end_comment

begin_define
define|#
directive|define
name|FastRawInput
end_define

begin_comment
comment|/* bypass the regular char-by-char canonical input 			 * processing whenever possible 			 */
end_comment

begin_define
define|#
directive|define
name|PollMode
end_define

begin_comment
comment|/* use polling-based irq service routine, not the 			 * hardware svcack lines.  Must be defined for 			 * cyclom-16y boards. 			 * 			 * XXX cyclom-8y doesn't work without this defined 			 * either (!) 			 */
end_comment

begin_define
define|#
directive|define
name|LogOverruns
end_define

begin_comment
comment|/* log receive fifo overruns */
end_comment

begin_undef
undef|#
directive|undef
name|TxBuffer
end_undef

begin_comment
comment|/* buffer driver output, to be slightly more 			 * efficient 			 * 			 * XXX presently buggy 			 */
end_comment

begin_undef
undef|#
directive|undef
name|Smarts
end_undef

begin_comment
comment|/* enable slightly more CD1400 intelligence.  Mainly 			 * the output CR/LF processing, plus we can avoid a 			 * few checks usually done in ttyinput(). 			 * 			 * XXX not yet implemented, and not particularly 			 * worthwhile either. 			 */
end_comment

begin_define
define|#
directive|define
name|CyDebug
end_define

begin_comment
comment|/* include debugging code (minimal effect on 			 * performance) 			 */
end_comment

begin_define
define|#
directive|define
name|CY_RX_BUFS
value|2
end_define

begin_comment
comment|/* two receive buffers per port */
end_comment

begin_define
define|#
directive|define
name|CY_RX_BUF_SIZE
value|256
end_define

begin_comment
comment|/* bytes per receive buffer */
end_comment

begin_define
define|#
directive|define
name|CY_TX_BUF_SIZE
value|512
end_define

begin_comment
comment|/* bytes per transmit buffer */
end_comment

begin_comment
comment|/* #define CD1400s_PER_CYCLOM	1 */
end_comment

begin_comment
comment|/* cyclom-4y */
end_comment

begin_comment
comment|/* #define CD1400s_PER_CYCLOM	2 */
end_comment

begin_comment
comment|/* cyclom-8y */
end_comment

begin_define
define|#
directive|define
name|CD1400s_PER_CYCLOM
value|4
end_define

begin_comment
comment|/* cyclom-16y */
end_comment

begin_comment
comment|/* FreeBSD's getty doesn't know option for setting RTS/CTS handshake.  Its    getty, like a lot of other old cruft, should be replaced with something    which used POSIX tty interfaces which at least allow enabling it.  In the    meantime, use the force. */
end_comment

begin_define
define|#
directive|define
name|ALWAYS_RTS_CTS
value|1
end_define

begin_if
if|#
directive|if
name|CD1400s_PER_CYCLOM
operator|<
literal|4
end_if

begin_define
define|#
directive|define
name|CD1400_MEMSIZE
value|0x400
end_define

begin_comment
comment|/* 4*256 bytes per chip: cyclom-[48]y */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CD1400_MEMSIZE
value|0x100
end_define

begin_comment
comment|/* 256 bytes per chip: cyclom-16y */
end_comment

begin_comment
comment|/* XXX or is it 0x400 like the rest? */
end_comment

begin_define
define|#
directive|define
name|CYCLOM_16
value|1
end_define

begin_comment
comment|/* This is a cyclom-16Y */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PORTS_PER_CYCLOM
value|(CD1400_NO_OF_CHANNELS * CD1400s_PER_CYCLOM)
end_define

begin_define
define|#
directive|define
name|CYCLOM_RESET_16
value|0x1400
end_define

begin_comment
comment|/* cyclom-16y reset */
end_comment

begin_define
define|#
directive|define
name|CYCLOM_CLEAR_INTR
value|0x1800
end_define

begin_comment
comment|/* intr ack address */
end_comment

begin_define
define|#
directive|define
name|CYCLOM_CLOCK
value|25000000
end_define

begin_comment
comment|/* baud rate clock */
end_comment

begin_define
define|#
directive|define
name|CY_UNITMASK
value|0x0f
end_define

begin_define
define|#
directive|define
name|CY_CARRIERMASK
value|0xC0
end_define

begin_define
define|#
directive|define
name|CY_CARRIERSHIFT
value|6
end_define

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|x
parameter_list|)
value|(minor(x)& CY_UNITMASK)
end_define

begin_define
define|#
directive|define
name|CARRIER_MODE
parameter_list|(
name|x
parameter_list|)
value|((minor(x)& CY_CARRIERMASK)>> CY_CARRIERSHIFT)
end_define

begin_typedef
typedef|typedef
name|u_char
modifier|*
specifier|volatile
name|cy_addr
typedef|;
end_typedef

begin_function_decl
name|int
name|cyprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cyattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|isdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cystart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cyparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cyspeed
parameter_list|(
name|int
name|speed
parameter_list|,
name|int
modifier|*
name|prescaler_io
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cy_channel_init
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|reset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cd1400_channel_cmd
parameter_list|(
name|cy_addr
name|base
parameter_list|,
name|u_char
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* hsu@clinet.fi: sigh */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_define
define|#
directive|define
name|DELAY
parameter_list|(
name|foo
parameter_list|)
value|delay(foo)
end_define

begin_function_decl
name|void
name|delay
parameter_list|(
name|int
name|delay
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Better get rid of this until the core people agree on kernel interfaces.    At least it will then compile on both WhichBSDs.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|extern unsigned int	delaycount;
comment|/* calibrated 1 ms cpu-spin delay */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|isa_driver
name|cydriver
init|=
block|{
name|cyprobe
block|,
name|cyattach
block|,
literal|"cy"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* low-level ping-pong buffer structure */
end_comment

begin_struct
struct|struct
name|cy_buf
block|{
name|u_char
modifier|*
name|next_char
decl_stmt|;
comment|/* location of next char to write */
name|u_int
name|free
decl_stmt|;
comment|/* free chars remaining in buffer */
name|struct
name|cy_buf
modifier|*
name|next_buf
decl_stmt|;
comment|/* circular, you know */
name|u_char
name|buf
index|[
name|CY_RX_BUF_SIZE
index|]
decl_stmt|;
comment|/* start of the buffer */
block|}
struct|;
end_struct

begin_comment
comment|/* low-level ring buffer */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TxBuffer
end_ifdef

begin_struct
struct|struct
name|cy_ring
block|{
name|u_char
name|buf
index|[
name|CY_TX_BUF_SIZE
index|]
decl_stmt|;
name|u_char
modifier|*
name|head
decl_stmt|;
name|u_char
modifier|*
name|tail
decl_stmt|;
comment|/* next pos. to insert char */
name|u_char
modifier|*
name|endish
decl_stmt|;
comment|/* physical end of buf */
name|u_int
name|used
decl_stmt|;
comment|/* no. of chars in queue */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * define a structure to keep track of each serial line  */
end_comment

begin_struct
struct|struct
name|cy
block|{
name|cy_addr
name|base_addr
decl_stmt|;
comment|/* base address of this port's cd1400 */
name|struct
name|tty
modifier|*
name|tty
decl_stmt|;
name|u_int
name|dtrwait
decl_stmt|;
comment|/* time (in ticks) to hold dtr low after close */
name|u_int
name|recv_exception
decl_stmt|;
comment|/* exception chars received */
name|u_int
name|recv_normal
decl_stmt|;
comment|/* normal chars received */
name|u_int
name|xmit
decl_stmt|;
comment|/* chars transmitted */
name|u_int
name|mdm
decl_stmt|;
comment|/* modem signal changes */
ifdef|#
directive|ifdef
name|CyDebug
name|u_int
name|start_count
decl_stmt|;
comment|/* no. of calls to cystart() */
name|u_int
name|start_real
decl_stmt|;
comment|/* no. of calls that did something */
endif|#
directive|endif
name|u_char
name|carrier_mode
decl_stmt|;
comment|/* hardware carrier handling mode */
comment|/* 					 * 0 = always use 					 * 1 = always use (dialin port) 					 * 2 = ignore during open, then use it 					 * 3 = ignore completely 					 */
name|u_char
name|carrier_delta
decl_stmt|;
comment|/* true if carrier has changed state */
name|u_char
name|fifo_overrun
decl_stmt|;
comment|/* true if cd1400 receive fifo has... */
name|u_char
name|rx_buf_overrun
decl_stmt|;
comment|/* true if low-level buf overflow */
name|u_char
name|intr_enable
decl_stmt|;
comment|/* CD1400 SRER shadow */
name|u_char
name|modem_sig
decl_stmt|;
comment|/* CD1400 modem signal shadow */
name|u_char
name|channel_control
decl_stmt|;
comment|/* CD1400 CCR control command shadow */
name|u_char
name|cor
index|[
literal|3
index|]
decl_stmt|;
comment|/* CD1400 COR1-3 shadows */
ifdef|#
directive|ifdef
name|Smarts
name|u_char
name|spec_char
index|[
literal|4
index|]
decl_stmt|;
comment|/* CD1400 SCHR1-4 shadows */
endif|#
directive|endif
name|struct
name|cy_buf
modifier|*
name|rx_buf
decl_stmt|;
comment|/* current receive buffer */
name|struct
name|cy_buf
name|rx_buf_pool
index|[
name|CY_RX_BUFS
index|]
decl_stmt|;
comment|/* receive ping-pong buffers */
ifdef|#
directive|ifdef
name|TxBuffer
name|struct
name|cy_ring
name|tx_buf
decl_stmt|;
comment|/* transmit buffer */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_decl_stmt
name|int
name|cydefaultrate
init|=
name|TTYDEF_SPEED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cy_addr
name|cyclom_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base address of the card */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cy
modifier|*
name|info
index|[
name|NCY
operator|*
name|PORTS_PER_CYCLOM
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_comment
comment|/* XXX actually only temporarily for 2.1-Development */
end_comment

begin_decl_stmt
name|struct
name|tty
name|cy_tty
index|[
name|NCY
operator|*
name|PORTS_PER_CYCLOM
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|tty
modifier|*
name|cy_tty
index|[
name|NCY
operator|*
name|PORTS_PER_CYCLOM
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|volatile
name|u_char
name|timeout_scheduled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if a timeout has been scheduled */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CyDebug
end_ifdef

begin_decl_stmt
name|u_int
name|cy_svrr_probes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debugging */
end_comment

begin_decl_stmt
name|u_int
name|cy_timeouts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|cy_timeout_req
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**********************************************************************/
end_comment

begin_function
name|int
name|cyprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_char
name|version
init|=
literal|0
decl_stmt|;
comment|/* firmware version */
comment|/* Cyclom-16Y hardware reset (Cyclom-8Ys don't care) */
name|i
operator|=
operator|*
call|(
name|cy_addr
call|)
argument_list|(
name|dev
operator|->
name|id_maddr
operator|+
name|CYCLOM_RESET_16
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
comment|/* wait for the board to get its act together (500 us) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CD1400s_PER_CYCLOM
condition|;
name|i
operator|++
control|)
block|{
name|cy_addr
name|base
init|=
name|dev
operator|->
name|id_maddr
operator|+
name|i
operator|*
name|CD1400_MEMSIZE
decl_stmt|;
comment|/* wait for chip to become ready for new command */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|100
condition|;
name|j
operator|+=
literal|50
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* wait 50 us */
if|if
condition|(
operator|!
operator|*
operator|(
name|base
operator|+
name|CD1400_CCR
operator|)
condition|)
break|break;
block|}
comment|/* clear the GFRCR register */
operator|*
operator|(
name|base
operator|+
name|CD1400_GFRCR
operator|)
operator|=
literal|0
expr_stmt|;
comment|/* issue a reset command */
operator|*
operator|(
name|base
operator|+
name|CD1400_CCR
operator|)
operator|=
name|CD1400_CMD_RESET
expr_stmt|;
comment|/* wait for the CD1400 to initialise itself */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|1000
condition|;
name|j
operator|+=
literal|50
control|)
block|{
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
comment|/* wait 50 us */
comment|/* retrieve firmware version */
name|version
operator|=
operator|*
operator|(
name|base
operator|+
name|CD1400_GFRCR
operator|)
expr_stmt|;
if|if
condition|(
name|version
condition|)
break|break;
block|}
comment|/* anything in the 40-4f range is fine */
if|if
condition|(
operator|(
name|version
operator|&
literal|0xf0
operator|)
operator|!=
literal|0x40
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
comment|/* found */
block|}
end_function

begin_function
name|int
name|cyattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|isdp
parameter_list|)
block|{
comment|/*    u_char	unit = UNIT(isdp->id_unit); */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
comment|/* global variable used various routines */
name|cyclom_base
operator|=
operator|(
name|cy_addr
operator|)
name|isdp
operator|->
name|id_maddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|i
operator|<
name|CD1400s_PER_CYCLOM
condition|;
name|i
operator|++
control|)
block|{
name|cy_addr
name|base
init|=
name|cyclom_base
operator|+
name|i
operator|*
name|CD1400_MEMSIZE
decl_stmt|;
comment|/* setup a 1ms clock tick */
operator|*
operator|(
name|base
operator|+
name|CD1400_PPR
operator|)
operator|=
name|CD1400_CLOCK_25_1MS
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CD1400_NO_OF_CHANNELS
condition|;
name|j
operator|++
operator|,
name|k
operator|++
control|)
block|{
name|struct
name|cy
modifier|*
name|ip
decl_stmt|;
comment|/* 	     * grab some space.  it'd be more polite to do this in cyopen(), 	     * but hey. 	     */
name|info
index|[
name|k
index|]
operator|=
name|ip
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cy
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* clear all sorts of junk */
name|bzero
argument_list|(
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cy
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|base_addr
operator|=
name|base
expr_stmt|;
comment|/* initialise the channel, without resetting it first */
name|cy_channel_init
argument_list|(
name|k
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* clear interrupts */
operator|*
operator|(
name|cyclom_base
operator|+
name|CYCLOM_CLEAR_INTR
operator|)
operator|=
operator|(
name|u_char
operator|)
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|cyopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|u_int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|cy
modifier|*
name|infop
decl_stmt|;
name|cy_addr
name|base
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_char
name|carrier
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
comment|/* NCY * ? */
name|PORTS_PER_CYCLOM
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|infop
operator|=
name|info
index|[
name|unit
index|]
expr_stmt|;
name|base
operator|=
name|infop
operator|->
name|base_addr
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|infop
operator|->
name|tty
operator|=
operator|&
name|cy_tty
index|[
name|unit
index|]
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|cy_tty
index|[
name|unit
index|]
condition|)
name|infop
operator|->
name|tty
operator|=
name|cy_tty
index|[
name|unit
index|]
operator|=
name|ttymalloc
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|tp
operator|=
name|infop
operator|->
name|tty
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|cystart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|cyparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|cydefaultrate
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|spltty
argument_list|()
expr_stmt|;
name|cy_channel_init
argument_list|(
name|unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* reset the hardware */
comment|/* 		 * raise dtr and generally set things up correctly.  this 		 * has the side-effect of selecting the appropriate cd1400 		 * channel, to help us with subsequent channel control stuff 		 */
name|cyparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
comment|/* check carrier, and set t_state's TS_CARR_ON flag accordingly */
name|infop
operator|->
name|modem_sig
operator|=
operator|*
operator|(
name|base
operator|+
name|CD1400_MSVR
operator|)
expr_stmt|;
name|carrier
operator|=
name|infop
operator|->
name|modem_sig
operator|&
name|CD1400_MSVR_CD
expr_stmt|;
if|if
condition|(
name|carrier
operator|||
operator|(
name|infop
operator|->
name|carrier_mode
operator|>=
literal|2
operator|)
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CARR_ON
expr_stmt|;
comment|/* 		 * enable modem& rx interrupts - relies on cyparam() 		 * having selected the appropriate cd1400 channel 		 */
name|infop
operator|->
name|intr_enable
operator|=
operator|(
literal|1
operator|<<
literal|7
operator|)
operator||
operator|(
literal|1
operator|<<
literal|4
operator|)
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_SRER
operator|)
operator|=
name|infop
operator|->
name|intr_enable
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
condition|)
while|while
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|&&
operator|!
name|error
condition|)
name|error
operator|=
name|ttysleep
argument_list|(
name|tp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
name|ttopen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
operator|(
name|u_char
operator|)
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end of cyopen() */
end_comment

begin_function
name|void
name|cyclose_wakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|wakeup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of cyclose_wakeup() */
end_comment

begin_function
name|int
name|cyclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|u_int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|cy
modifier|*
name|infop
init|=
name|info
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|infop
operator|->
name|tty
decl_stmt|;
name|cy_addr
name|base
init|=
name|infop
operator|->
name|base_addr
decl_stmt|;
name|int
name|s
decl_stmt|;
operator|(
operator|*
name|linesw
index|[
operator|(
name|u_char
operator|)
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* select the appropriate channel on the CD1400 */
operator|*
operator|(
name|base
operator|+
name|CD1400_CAR
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|unit
operator|&
literal|0x03
argument_list|)
expr_stmt|;
comment|/* disable this channel and lower DTR */
name|infop
operator|->
name|intr_enable
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_SRER
operator|)
operator|=
operator|(
name|u_char
operator|)
literal|0
expr_stmt|;
comment|/* no intrs */
operator|*
operator|(
name|base
operator|+
name|CD1400_DTR
operator|)
operator|=
operator|(
name|u_char
operator|)
name|CD1400_DTR_CLEAR
expr_stmt|;
comment|/* no DTR */
name|infop
operator|->
name|modem_sig
operator|&=
operator|~
name|CD1400_MSVR_DTR
expr_stmt|;
comment|/* disable receiver (leave transmitter enabled) */
name|infop
operator|->
name|channel_control
operator|=
operator|(
literal|1
operator|<<
literal|4
operator|)
operator||
operator|(
literal|1
operator|<<
literal|3
operator|)
operator||
literal|1
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|base
argument_list|,
name|infop
operator|->
name|channel_control
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|broken
comment|/* session holds a ref to the tty; can't deallocate */
name|ttyfree
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|infop
operator|->
name|tty
operator|=
name|cy_tty
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|infop
operator|->
name|dtrwait
condition|)
block|{
name|int
name|error
decl_stmt|;
name|timeout
argument_list|(
name|cyclose_wakeup
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|infop
operator|->
name|dtrwait
argument_list|,
name|infop
operator|->
name|dtrwait
argument_list|)
expr_stmt|;
do|do
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|infop
operator|->
name|dtrwait
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"cyclose"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|ERESTART
condition|)
do|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* end of cyclose() */
end_comment

begin_function
name|int
name|cyread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|u_int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|info
index|[
name|unit
index|]
operator|->
name|tty
decl_stmt|;
return|return
operator|(
operator|*
name|linesw
index|[
operator|(
name|u_char
operator|)
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
return|;
block|}
end_function

begin_comment
comment|/* end of cyread() */
end_comment

begin_function
name|int
name|cywrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|u_int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|info
index|[
name|unit
index|]
operator|->
name|tty
decl_stmt|;
ifdef|#
directive|ifdef
name|Smarts
comment|/* XXX duplicate ttwrite(), but without so much output processing on 	 * CR& LF chars.  Hardly worth the effort, given that high-throughput 	 * sessions are raw anyhow. 	 */
else|#
directive|else
return|return
operator|(
operator|*
name|linesw
index|[
operator|(
name|u_char
operator|)
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* end of cywrite() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|Smarts
end_ifdef

begin_comment
comment|/* standard line discipline input routine */
end_comment

begin_function
name|int
name|cyinput
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
comment|/* XXX duplicate ttyinput(), but without the IXOFF/IXON/ISTRIP/IPARMRK 	 * bits, as they are done by the CD1400.  Hardly worth the effort, 	 * given that high-throughput sessions are raw anyhow. 	 */
block|}
end_function

begin_comment
comment|/* end of cyinput() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Smarts */
end_comment

begin_function
specifier|inline
specifier|static
name|void
name|service_upper_rx
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|cy
modifier|*
name|ip
init|=
name|info
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|ip
operator|->
name|tty
decl_stmt|;
name|struct
name|cy_buf
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_char
modifier|*
name|ch
decl_stmt|;
name|buf
operator|=
name|ip
operator|->
name|rx_buf
expr_stmt|;
comment|/* give service_rx() a new one */
name|disable_intr
argument_list|()
expr_stmt|;
comment|/* faster than spltty() */
name|ip
operator|->
name|rx_buf
operator|=
name|buf
operator|->
name|next_buf
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
name|ch
operator|=
name|buf
operator|->
name|buf
expr_stmt|;
name|i
operator|=
name|buf
operator|->
name|next_char
operator|-
name|buf
operator|->
name|buf
expr_stmt|;
ifdef|#
directive|ifdef
name|FastRawInput
comment|/* try to avoid calling the line discipline stuff if we can */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_line
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_iflag
operator|&
operator|(
name|ICRNL
operator||
name|IMAXBEL
operator||
name|INLCR
operator|)
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_lflag
operator|&
operator|(
name|ECHO
operator||
name|ECHONL
operator||
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
operator||
name|PENDIN
operator|)
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_CNTTB
operator||
name|TS_LNCH
operator|)
operator|)
condition|)
block|{
name|i
operator|=
name|b_to_q
argument_list|(
name|ch
argument_list|,
name|i
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/* 			 * we have no RTS flow control support on cy-8 			 * boards, so this is really just tough luck 			 */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"cy%d: tty input queue overflow\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* notify any readers */
block|}
else|else
endif|#
directive|endif
comment|/* FastRawInput */
block|{
while|while
condition|(
name|i
operator|--
condition|)
operator|(
operator|*
name|linesw
index|[
operator|(
name|u_char
operator|)
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|(
name|int
operator|)
operator|*
name|ch
operator|++
operator|,
name|tp
operator|)
expr_stmt|;
block|}
block|}
comment|/* clear the buffer we've just processed */
name|buf
operator|->
name|next_char
operator|=
name|buf
operator|->
name|buf
expr_stmt|;
name|buf
operator|->
name|free
operator|=
name|CY_RX_BUF_SIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of service_upper_rx() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TxBuffer
end_ifdef

begin_function
specifier|static
name|void
name|service_upper_tx
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|cy
modifier|*
name|ip
init|=
name|info
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|ip
operator|->
name|tty
decl_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_BUSY
operator||
name|TS_FLUSH
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|>
literal|0
condition|)
block|{
name|struct
name|cy_ring
modifier|*
name|txq
init|=
operator|&
name|ip
operator|->
name|tx_buf
decl_stmt|;
name|int
name|free_count
init|=
name|CY_TX_BUF_SIZE
operator|-
name|ip
operator|->
name|tx_buf
operator|.
name|used
decl_stmt|;
name|u_char
modifier|*
name|cp
init|=
name|txq
operator|->
name|tail
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|chars_done
decl_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
comment|/* find the largest contig. copy we can do */
name|count
operator|=
operator|(
operator|(
name|txq
operator|->
name|endish
operator|-
name|cp
operator|)
operator|>
name|free_count
operator|)
condition|?
name|free_count
else|:
name|txq
operator|->
name|endish
operator|-
name|cp
expr_stmt|;
name|count
operator|=
operator|(
operator|(
name|cp
operator|+
name|free_count
operator|)
operator|>
name|txq
operator|->
name|endish
operator|)
condition|?
name|txq
operator|->
name|endish
operator|-
name|cp
else|:
name|free_count
expr_stmt|;
comment|/* copy the first slab */
name|chars_done
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|cp
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* check for wrap-around time */
name|cp
operator|+=
name|chars_done
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|txq
operator|->
name|endish
condition|)
name|cp
operator|=
name|txq
operator|->
name|buf
expr_stmt|;
comment|/* back to the start */
comment|/* copy anything else, after we've wrapped around */
if|if
condition|(
operator|(
name|chars_done
operator|==
name|count
operator|)
operator|&&
operator|(
name|count
operator|!=
name|free_count
operator|)
condition|)
block|{
comment|/* copy the second slab */
name|count
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|cp
argument_list|,
name|free_count
operator|-
name|count
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|count
expr_stmt|;
name|chars_done
operator|+=
name|count
expr_stmt|;
block|}
comment|/* 		 * update queue, protecting ourselves from any rampant 		 * lower-layers 		 */
name|disable_intr
argument_list|()
expr_stmt|;
name|txq
operator|->
name|tail
operator|=
name|cp
expr_stmt|;
name|txq
operator|->
name|used
operator|+=
name|chars_done
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
condition|)
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of service_upper_tx() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TxBuffer */
end_comment

begin_function
specifier|inline
specifier|static
name|void
name|service_upper_mdm
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|cy
modifier|*
name|ip
init|=
name|info
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|carrier_delta
condition|)
block|{
name|int
name|carrier
init|=
name|ip
operator|->
name|modem_sig
operator|&
name|CD1400_MSVR_CD
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|ip
operator|->
name|tty
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|linesw
index|[
operator|(
name|u_char
operator|)
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
name|carrier
operator|)
condition|)
block|{
name|cy_addr
name|base
init|=
name|ip
operator|->
name|base_addr
decl_stmt|;
comment|/* clear DTR */
name|disable_intr
argument_list|()
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_CAR
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|unit
operator|&
literal|0x03
argument_list|)
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_DTR
operator|)
operator|=
operator|(
name|u_char
operator|)
name|CD1400_DTR_CLEAR
expr_stmt|;
name|ip
operator|->
name|modem_sig
operator|&=
operator|~
name|CD1400_MSVR_DTR
expr_stmt|;
name|ip
operator|->
name|carrier_delta
operator|=
literal|0
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|disable_intr
argument_list|()
expr_stmt|;
name|ip
operator|->
name|carrier_delta
operator|=
literal|0
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* end of service_upper_mdm() */
end_comment

begin_comment
comment|/* upper level character processing routine */
end_comment

begin_function
name|void
name|cytimeout
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|timeout_scheduled
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CyDebug
name|cy_timeouts
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* check each port in turn */
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NCY
operator|*
name|PORTS_PER_CYCLOM
condition|;
name|unit
operator|++
control|)
block|{
name|struct
name|cy
modifier|*
name|ip
init|=
name|info
index|[
name|unit
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|TxBuffer
name|struct
name|tty
modifier|*
name|tp
init|=
name|ip
operator|->
name|tty
decl_stmt|;
endif|#
directive|endif
comment|/* ignore anything that is not open */
if|if
condition|(
operator|!
name|ip
operator|->
name|tty
condition|)
continue|continue;
comment|/* 		 * any received chars to handle? (doesn't matter if intr routine 		 * kicks in while we're testing this) 		 */
if|if
condition|(
name|ip
operator|->
name|rx_buf
operator|->
name|free
operator|!=
name|CY_RX_BUF_SIZE
condition|)
name|service_upper_rx
argument_list|(
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TxBuffer
comment|/* anything to add to the transmit buffer (low-water mark)? */
if|if
condition|(
name|ip
operator|->
name|tx_buf
operator|.
name|used
operator|<
name|CY_TX_BUF_SIZE
operator|/
literal|2
condition|)
name|service_upper_tx
argument_list|(
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* anything modem signals altered? */
name|service_upper_mdm
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* any overruns to log? */
ifdef|#
directive|ifdef
name|LogOverruns
if|if
condition|(
name|ip
operator|->
name|fifo_overrun
condition|)
block|{
comment|/* 			 * turn off the alarm - not important enough to bother 			 * with interrupt protection. 			 */
name|ip
operator|->
name|fifo_overrun
operator|=
literal|0
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"cy%d: receive fifo overrun\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ip
operator|->
name|rx_buf_overrun
condition|)
block|{
comment|/* 			 * turn off the alarm - not important enough to bother 			 * with interrupt protection. 			 */
name|ip
operator|->
name|rx_buf_overrun
operator|=
literal|0
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"cy%d: receive buffer full\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* cytimeout() */
end_comment

begin_function
specifier|inline
specifier|static
name|void
name|schedule_upper_service
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CyDebug
name|cy_timeout_req
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|timeout_scheduled
condition|)
block|{
name|timeout
argument_list|(
name|cytimeout
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* call next tick */
name|timeout_scheduled
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end of schedule_upper_service() */
end_comment

begin_comment
comment|/* initialise a channel on the cyclom board */
end_comment

begin_function
specifier|static
name|void
name|cy_channel_init
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
name|u_int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|carrier_mode
init|=
name|CARRIER_MODE
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|cy
modifier|*
name|ip
init|=
name|info
index|[
name|unit
index|]
decl_stmt|;
name|cy_addr
name|base
init|=
name|ip
operator|->
name|base_addr
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|ip
operator|->
name|tty
decl_stmt|;
name|struct
name|cy_buf
modifier|*
name|buf
decl_stmt|,
modifier|*
name|next_buf
decl_stmt|;
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|PollMode
name|u_char
name|cd1400_unit
decl_stmt|;
endif|#
directive|endif
comment|/* clear the structure and refill it */
name|bzero
argument_list|(
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cy
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|base_addr
operator|=
name|base
expr_stmt|;
name|ip
operator|->
name|tty
operator|=
name|tp
expr_stmt|;
name|ip
operator|->
name|carrier_mode
operator|=
name|carrier_mode
expr_stmt|;
comment|/* select channel of the CD1400 */
operator|*
operator|(
name|base
operator|+
name|CD1400_CAR
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|unit
operator|&
literal|0x03
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset
condition|)
name|cd1400_channel_cmd
argument_list|(
name|base
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* reset the channel */
comment|/* set LIVR to 0 - intr routines depend on this */
operator|*
operator|(
name|base
operator|+
name|CD1400_LIVR
operator|)
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|PollMode
comment|/* set top four bits of {R,T,M}ICR to the cd1400 	 * number, cd1400_unit 	 */
name|cd1400_unit
operator|=
name|unit
operator|/
name|CD1400_NO_OF_CHANNELS
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_RICR
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cd1400_unit
operator|<<
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_TICR
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cd1400_unit
operator|<<
literal|4
argument_list|)
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_MICR
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cd1400_unit
operator|<<
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ip
operator|->
name|dtrwait
operator|=
name|hz
operator|/
literal|4
expr_stmt|;
comment|/* quarter of a second */
comment|/* setup low-level buffers */
name|i
operator|=
name|CY_RX_BUFS
expr_stmt|;
name|ip
operator|->
name|rx_buf
operator|=
name|next_buf
operator|=
operator|&
name|ip
operator|->
name|rx_buf_pool
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|buf
operator|=
operator|&
name|ip
operator|->
name|rx_buf_pool
index|[
name|i
index|]
expr_stmt|;
name|buf
operator|->
name|next_char
operator|=
name|buf
operator|->
name|buf
expr_stmt|;
comment|/* first char to use */
name|buf
operator|->
name|free
operator|=
name|CY_RX_BUF_SIZE
expr_stmt|;
comment|/* i.e. empty */
name|buf
operator|->
name|next_buf
operator|=
name|next_buf
expr_stmt|;
comment|/* where to go next */
name|next_buf
operator|=
name|buf
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TxBuffer
name|ip
operator|->
name|tx_buf
operator|.
name|endish
operator|=
name|ip
operator|->
name|tx_buf
operator|.
name|buf
operator|+
name|CY_TX_BUF_SIZE
expr_stmt|;
comment|/* clear the low-level tx buffer */
name|ip
operator|->
name|tx_buf
operator|.
name|head
operator|=
name|ip
operator|->
name|tx_buf
operator|.
name|tail
operator|=
name|ip
operator|->
name|tx_buf
operator|.
name|buf
expr_stmt|;
name|ip
operator|->
name|tx_buf
operator|.
name|used
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* clear the low-level rx buffer */
name|ip
operator|->
name|rx_buf
operator|->
name|next_char
operator|=
name|ip
operator|->
name|rx_buf
operator|->
name|buf
expr_stmt|;
comment|/* first char to use */
name|ip
operator|->
name|rx_buf
operator|->
name|free
operator|=
name|CY_RX_BUF_SIZE
expr_stmt|;
comment|/* completely empty */
block|}
end_function

begin_comment
comment|/* end of cy_channel_init() */
end_comment

begin_comment
comment|/* service a receive interrupt */
end_comment

begin_function
specifier|inline
specifier|static
name|void
name|service_rx
parameter_list|(
name|int
name|cd
parameter_list|,
name|caddr_t
name|base
parameter_list|)
block|{
name|struct
name|cy
modifier|*
name|infop
decl_stmt|;
name|unsigned
name|count
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|u_char
name|serv_type
decl_stmt|,
name|channel
decl_stmt|;
ifdef|#
directive|ifdef
name|PollMode
name|u_char
name|save_rir
decl_stmt|,
name|save_car
decl_stmt|;
endif|#
directive|endif
comment|/* setup */
ifdef|#
directive|ifdef
name|PollMode
name|save_rir
operator|=
operator|*
operator|(
name|base
operator|+
name|CD1400_RIR
operator|)
expr_stmt|;
name|channel
operator|=
name|cd
operator|*
name|CD1400_NO_OF_CHANNELS
operator|+
operator|(
name|save_rir
operator|&
literal|0x3
operator|)
expr_stmt|;
name|save_car
operator|=
operator|*
operator|(
name|base
operator|+
name|CD1400_CAR
operator|)
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_CAR
operator|)
operator|=
name|save_rir
expr_stmt|;
comment|/* enter modem service */
name|serv_type
operator|=
operator|*
operator|(
name|base
operator|+
name|CD1400_RIVR
operator|)
expr_stmt|;
else|#
directive|else
name|serv_type
operator|=
operator|*
operator|(
name|base
operator|+
name|CD1400_SVCACKR
operator|)
expr_stmt|;
comment|/* ack receive service */
name|channel
operator|=
operator|(
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_RICR
operator|)
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* get cyclom channel # */
ifdef|#
directive|ifdef
name|CyDebug
if|if
condition|(
name|channel
operator|>=
name|PORTS_PER_CYCLOM
condition|)
block|{
name|printf
argument_list|(
literal|"cy: service_rx - channel %02x\n"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"cy: service_rx - bad channel"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|infop
operator|=
name|info
index|[
name|channel
index|]
expr_stmt|;
comment|/* read those chars */
if|if
condition|(
name|serv_type
operator|&
name|CD1400_RIVR_EXCEPTION
condition|)
block|{
comment|/* read the exception status */
name|u_char
name|status
init|=
operator|*
operator|(
name|base
operator|+
name|CD1400_RDSR
operator|)
decl_stmt|;
comment|/* XXX is it a break?  Do something if it is! */
comment|/* XXX is IGNPAR not set?  Store a null in the buffer. */
ifdef|#
directive|ifdef
name|LogOverruns
if|if
condition|(
name|status
operator|&
name|CD1400_RDSR_OVERRUN
condition|)
block|{
if|#
directive|if
literal|0
block|ch |= TTY_PE;
comment|/* for SLIP */
endif|#
directive|endif
name|infop
operator|->
name|fifo_overrun
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|infop
operator|->
name|recv_exception
operator|++
expr_stmt|;
block|}
else|else
block|{
name|struct
name|cy_buf
modifier|*
name|buf
init|=
name|infop
operator|->
name|rx_buf
decl_stmt|;
name|count
operator|=
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_RDCR
operator|)
expr_stmt|;
comment|/* how many to read? */
name|infop
operator|->
name|recv_normal
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|free
operator|<
name|count
condition|)
block|{
name|infop
operator|->
name|rx_buf_overrun
operator|+=
name|count
expr_stmt|;
comment|/* read& discard everything */
while|while
condition|(
name|count
operator|--
condition|)
name|ch
operator|=
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_RDSR
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* slurp it into our low-level buffer */
name|buf
operator|->
name|free
operator|-=
name|count
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|ch
operator|=
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_RDSR
operator|)
expr_stmt|;
comment|/* read the char */
operator|*
operator|(
name|buf
operator|->
name|next_char
operator|++
operator|)
operator|=
name|ch
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|PollMode
operator|*
operator|(
name|base
operator|+
name|CD1400_RIR
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|save_rir
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
comment|/* terminate service context */
else|#
directive|else
operator|*
operator|(
name|base
operator|+
name|CD1400_EOSRR
operator|)
operator|=
operator|(
name|u_char
operator|)
literal|0
expr_stmt|;
comment|/* terminate service context */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* end of service_rx */
end_comment

begin_comment
comment|/* service a transmit interrupt */
end_comment

begin_function
specifier|inline
specifier|static
name|void
name|service_tx
parameter_list|(
name|int
name|cd
parameter_list|,
name|caddr_t
name|base
parameter_list|)
block|{
name|struct
name|cy
modifier|*
name|ip
decl_stmt|;
ifdef|#
directive|ifdef
name|TxBuffer
name|struct
name|cy_ring
modifier|*
name|txq
decl_stmt|;
else|#
directive|else
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
endif|#
directive|endif
name|u_char
name|channel
decl_stmt|;
ifdef|#
directive|ifdef
name|PollMode
name|u_char
name|save_tir
decl_stmt|,
name|save_car
decl_stmt|;
else|#
directive|else
name|u_char
name|vector
decl_stmt|;
endif|#
directive|endif
comment|/* setup */
ifdef|#
directive|ifdef
name|PollMode
name|save_tir
operator|=
operator|*
operator|(
name|base
operator|+
name|CD1400_TIR
operator|)
expr_stmt|;
name|channel
operator|=
name|cd
operator|*
name|CD1400_NO_OF_CHANNELS
operator|+
operator|(
name|save_tir
operator|&
literal|0x3
operator|)
expr_stmt|;
name|save_car
operator|=
operator|*
operator|(
name|base
operator|+
name|CD1400_CAR
operator|)
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_CAR
operator|)
operator|=
name|save_tir
expr_stmt|;
comment|/* enter tx service */
else|#
directive|else
name|vector
operator|=
operator|*
operator|(
name|base
operator|+
name|CD1400_SVCACKT
operator|)
expr_stmt|;
comment|/* ack transmit service */
name|channel
operator|=
operator|(
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_TICR
operator|)
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* get cyclom channel # */
ifdef|#
directive|ifdef
name|CyDebug
if|if
condition|(
name|channel
operator|>=
name|PORTS_PER_CYCLOM
condition|)
block|{
name|printf
argument_list|(
literal|"cy: service_tx - channel %02x\n"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"cy: service_tx - bad channel"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|ip
operator|=
name|info
index|[
name|channel
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|TxBuffer
name|txq
operator|=
operator|&
name|ip
operator|->
name|tx_buf
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|used
operator|>
literal|0
condition|)
block|{
name|cy_addr
name|base
init|=
name|ip
operator|->
name|base_addr
decl_stmt|;
name|int
name|count
init|=
name|min
argument_list|(
name|CD1400_FIFOSIZE
argument_list|,
name|txq
operator|->
name|used
argument_list|)
decl_stmt|;
name|int
name|chars_done
init|=
name|count
decl_stmt|;
name|u_char
modifier|*
name|cp
init|=
name|txq
operator|->
name|head
decl_stmt|;
name|u_char
modifier|*
name|buf_end
init|=
name|txq
operator|->
name|endish
decl_stmt|;
comment|/* ip->state |= CY_BUSY; */
while|while
condition|(
name|count
operator|--
condition|)
block|{
operator|*
operator|(
name|base
operator|+
name|CD1400_TDR
operator|)
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|>=
name|buf_end
condition|)
name|cp
operator|=
name|txq
operator|->
name|buf
expr_stmt|;
block|}
empty_stmt|;
name|txq
operator|->
name|head
operator|=
name|cp
expr_stmt|;
name|txq
operator|->
name|used
operator|-=
name|chars_done
expr_stmt|;
comment|/* important that this is atomic */
name|ip
operator|->
name|xmit
operator|+=
name|chars_done
expr_stmt|;
block|}
comment|/* 	 * disable tx intrs if no more chars to send.  we re-enable 	 * them in cystart() 	 */
if|if
condition|(
operator|!
name|txq
operator|->
name|used
condition|)
block|{
name|ip
operator|->
name|intr_enable
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_SRER
operator|)
operator|=
name|ip
operator|->
name|intr_enable
expr_stmt|;
comment|/* ip->state&= ~CY_BUSY; */
block|}
else|#
directive|else
name|tp
operator|=
name|ip
operator|->
name|tty
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|>
literal|0
operator|)
condition|)
block|{
name|cy_addr
name|base
init|=
name|ip
operator|->
name|base_addr
decl_stmt|;
name|int
name|count
init|=
name|min
argument_list|(
name|CD1400_FIFOSIZE
argument_list|,
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
argument_list|)
decl_stmt|;
name|ip
operator|->
name|xmit
operator|+=
name|count
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
operator|*
operator|(
name|base
operator|+
name|CD1400_TDR
operator|)
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * disable tx intrs if no more chars to send.  we re-enable them 	 * in cystart() 	 */
if|if
condition|(
operator|!
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
condition|)
block|{
name|ip
operator|->
name|intr_enable
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_SRER
operator|)
operator|=
name|ip
operator|->
name|intr_enable
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PollMode
operator|*
operator|(
name|base
operator|+
name|CD1400_TIR
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|save_tir
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
comment|/* terminate service context */
else|#
directive|else
operator|*
operator|(
name|base
operator|+
name|CD1400_EOSRR
operator|)
operator|=
operator|(
name|u_char
operator|)
literal|0
expr_stmt|;
comment|/* terminate service context */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* end of service_tx */
end_comment

begin_comment
comment|/* service a modem status interrupt */
end_comment

begin_function
specifier|inline
specifier|static
name|void
name|service_mdm
parameter_list|(
name|int
name|cd
parameter_list|,
name|caddr_t
name|base
parameter_list|)
block|{
name|struct
name|cy
modifier|*
name|infop
decl_stmt|;
name|u_char
name|channel
decl_stmt|,
name|deltas
decl_stmt|;
ifdef|#
directive|ifdef
name|PollMode
name|u_char
name|save_mir
decl_stmt|,
name|save_car
decl_stmt|;
else|#
directive|else
name|u_char
name|vector
decl_stmt|;
endif|#
directive|endif
comment|/* setup */
ifdef|#
directive|ifdef
name|PollMode
name|save_mir
operator|=
operator|*
operator|(
name|base
operator|+
name|CD1400_MIR
operator|)
expr_stmt|;
name|channel
operator|=
name|cd
operator|*
name|CD1400_NO_OF_CHANNELS
operator|+
operator|(
name|save_mir
operator|&
literal|0x3
operator|)
expr_stmt|;
name|save_car
operator|=
operator|*
operator|(
name|base
operator|+
name|CD1400_CAR
operator|)
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_CAR
operator|)
operator|=
name|save_mir
expr_stmt|;
comment|/* enter modem service */
else|#
directive|else
name|vector
operator|=
operator|*
operator|(
name|base
operator|+
name|CD1400_SVCACKM
operator|)
expr_stmt|;
comment|/* ack modem service */
name|channel
operator|=
operator|(
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_MICR
operator|)
operator|)
operator|>>
literal|2
expr_stmt|;
comment|/* get cyclom channel # */
ifdef|#
directive|ifdef
name|CyDebug
if|if
condition|(
name|channel
operator|>=
name|PORTS_PER_CYCLOM
condition|)
block|{
name|printf
argument_list|(
literal|"cy: service_mdm - channel %02x\n"
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"cy: service_mdm - bad channel"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
name|infop
operator|=
name|info
index|[
name|channel
index|]
expr_stmt|;
comment|/* read the siggies and see what's changed */
name|infop
operator|->
name|modem_sig
operator|=
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_MSVR
operator|)
expr_stmt|;
name|deltas
operator|=
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_MISR
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|infop
operator|->
name|carrier_mode
operator|<=
literal|2
operator|)
operator|&&
operator|(
name|deltas
operator|&
name|CD1400_MISR_CDd
operator|)
condition|)
comment|/* something for the upper layer to deal with */
name|infop
operator|->
name|carrier_delta
operator|=
literal|1
expr_stmt|;
name|infop
operator|->
name|mdm
operator|++
expr_stmt|;
comment|/* terminate service context */
ifdef|#
directive|ifdef
name|PollMode
operator|*
operator|(
name|base
operator|+
name|CD1400_MIR
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
name|save_mir
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
operator|(
name|base
operator|+
name|CD1400_EOSRR
operator|)
operator|=
operator|(
name|u_char
operator|)
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* end of service_mdm */
end_comment

begin_function
name|int
name|cyintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|int
name|cd
decl_stmt|;
name|u_char
name|status
decl_stmt|;
comment|/* check each CD1400 in turn */
for|for
control|(
name|cd
operator|=
literal|0
init|;
name|cd
operator|<
name|CD1400s_PER_CYCLOM
condition|;
name|cd
operator|++
control|)
block|{
name|cy_addr
name|base
init|=
name|cyclom_base
operator|+
name|cd
operator|*
name|CD1400_MEMSIZE
decl_stmt|;
comment|/* poll to see if it has any work */
while|while
condition|(
name|status
operator|=
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_SVRR
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|CyDebug
name|cy_svrr_probes
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* service requests as appropriate, giving priority to RX */
if|if
condition|(
name|status
operator|&
name|CD1400_SVRR_RX
condition|)
name|service_rx
argument_list|(
name|cd
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|CD1400_SVRR_TX
condition|)
name|service_tx
argument_list|(
name|cd
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|CD1400_SVRR_MDM
condition|)
name|service_mdm
argument_list|(
name|cd
argument_list|,
name|base
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* request upper level service to deal with whatever happened */
name|schedule_upper_service
argument_list|()
expr_stmt|;
comment|/* re-enable interrupts on the cyclom */
operator|*
operator|(
name|cyclom_base
operator|+
name|CYCLOM_CLEAR_INTR
operator|)
operator|=
operator|(
name|u_char
operator|)
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|cyioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|cy
modifier|*
name|infop
init|=
name|info
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|infop
operator|->
name|tty
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
operator|(
name|u_char
operator|)
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
ifdef|#
directive|ifdef
name|NetBSD
argument_list|,
name|p
endif|#
directive|endif
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
ifdef|#
directive|ifdef
name|notyet
comment|/* sigh - more junk to do XXX */
case|case
name|TIOCSBRK
case|:
break|break;
case|case
name|TIOCCBRK
case|:
break|break;
case|case
name|TIOCSDTR
case|:
break|break;
case|case
name|TIOCCDTR
case|:
break|break;
case|case
name|TIOCMSET
case|:
break|break;
case|case
name|TIOCMBIS
case|:
break|break;
case|case
name|TIOCMBIC
case|:
break|break;
endif|#
directive|endif
comment|/* notyet */
case|case
name|TIOCMGET
case|:
block|{
name|int
name|bits
init|=
literal|0
decl_stmt|;
name|u_char
name|status
init|=
name|infop
operator|->
name|modem_sig
decl_stmt|;
if|if
condition|(
name|status
operator|&
name|CD1400_MSVR_DTR
condition|)
name|bits
operator||=
name|TIOCM_DTR
operator||
name|TIOCM_RTS
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|CD1400_MSVR_CD
condition|)
name|bits
operator||=
name|TIOCM_CD
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|CD1400_MSVR_CTS
condition|)
name|bits
operator||=
name|TIOCM_CTS
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|CD1400_MSVR_DSR
condition|)
name|bits
operator||=
name|TIOCM_DSR
expr_stmt|;
ifdef|#
directive|ifdef
name|CYCLOM_16
if|if
condition|(
name|status
operator|&
name|CD1400_MSVR_RI
condition|)
name|bits
operator||=
name|TIOCM_RI
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|infop
operator|->
name|channel_control
operator|&
literal|0x02
condition|)
name|bits
operator||=
name|TIOCM_LE
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|bits
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|TIOCMSBIDIR
case|case
name|TIOCMSBIDIR
case|:
return|return
operator|(
name|ENOTTY
operator|)
return|;
endif|#
directive|endif
comment|/* TIOCMSBIDIR */
ifdef|#
directive|ifdef
name|TIOCMGBIDIR
case|case
name|TIOCMGBIDIR
case|:
return|return
operator|(
name|ENOTTY
operator|)
return|;
endif|#
directive|endif
comment|/* TIOCMGBIDIR */
ifdef|#
directive|ifdef
name|TIOCMSDTRWAIT
case|case
name|TIOCMSDTRWAIT
case|:
comment|/* must be root to set dtr delay */
if|if
condition|(
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|infop
operator|->
name|dtrwait
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* TIOCMSDTRWAIT */
ifdef|#
directive|ifdef
name|TIOCMGDTRWAIT
case|case
name|TIOCMGDTRWAIT
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|infop
operator|->
name|dtrwait
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* TIOCMGDTRWAIT */
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* end of cyioctl() */
end_comment

begin_function
name|int
name|cyparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|u_char
name|unit
init|=
name|UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
name|struct
name|cy
modifier|*
name|infop
init|=
name|info
index|[
name|unit
index|]
decl_stmt|;
name|cy_addr
name|base
init|=
name|infop
operator|->
name|base_addr
decl_stmt|;
name|int
name|cflag
init|=
name|t
operator|->
name|c_cflag
decl_stmt|;
name|int
name|iflag
init|=
name|t
operator|->
name|c_iflag
decl_stmt|;
name|int
name|ispeed
decl_stmt|,
name|ospeed
decl_stmt|;
name|int
name|itimeout
decl_stmt|;
name|int
name|iprescaler
decl_stmt|,
name|oprescaler
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_char
name|cor_change
init|=
literal|0
decl_stmt|;
name|u_char
name|opt
decl_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|c_ispeed
condition|)
name|t
operator|->
name|c_ispeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* select the appropriate channel on the CD1400 */
operator|*
operator|(
name|base
operator|+
name|CD1400_CAR
operator|)
operator|=
name|unit
operator|&
literal|0x03
expr_stmt|;
comment|/* handle DTR drop on speed == 0 trick */
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|base
operator|+
name|CD1400_DTR
operator|)
operator|=
name|CD1400_DTR_CLEAR
expr_stmt|;
name|infop
operator|->
name|modem_sig
operator|&=
operator|~
name|CD1400_MSVR_DTR
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|base
operator|+
name|CD1400_DTR
operator|)
operator|=
name|CD1400_DTR_SET
expr_stmt|;
name|infop
operator|->
name|modem_sig
operator||=
name|CD1400_MSVR_DTR
expr_stmt|;
block|}
comment|/* set baud rates if they've changed from last time */
if|if
condition|(
operator|(
name|ospeed
operator|=
name|cyspeed
argument_list|(
name|t
operator|->
name|c_ospeed
argument_list|,
operator|&
name|oprescaler
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|base
operator|+
name|CD1400_TBPR
operator|)
operator|=
operator|(
name|u_char
operator|)
name|ospeed
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_TCOR
operator|)
operator|=
operator|(
name|u_char
operator|)
name|oprescaler
expr_stmt|;
if|if
condition|(
operator|(
name|ispeed
operator|=
name|cyspeed
argument_list|(
name|t
operator|->
name|c_ispeed
argument_list|,
operator|&
name|iprescaler
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
operator|*
operator|(
name|base
operator|+
name|CD1400_RBPR
operator|)
operator|=
operator|(
name|u_char
operator|)
name|ispeed
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_RCOR
operator|)
operator|=
operator|(
name|u_char
operator|)
name|iprescaler
expr_stmt|;
comment|/* 	 * set receive time-out period 	 *	generate a rx interrupt if no new chars are received in 	 *	this many ticks 	 * don't bother comparing old& new VMIN, VTIME and ispeed - it 	 * can't be much worse just to calculate and set it each time! 	 * certainly less hassle. :-) 	 */
comment|/* 	 * calculate minimum timeout period: 	 *     5 ms or the time it takes to receive 1 char, rounded up to the 	 *     next ms, whichever is greater 	 */
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|>
literal|0
condition|)
block|{
name|itimeout
operator|=
operator|(
name|t
operator|->
name|c_ispeed
operator|>
literal|2200
operator|)
condition|?
literal|5
else|:
operator|(
literal|10000
operator|/
name|t
operator|->
name|c_ispeed
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* if we're using VTIME as an inter-char timeout, and it is set to 	     * be longer than the minimum calculated above, go for it 	     */
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VMIN
index|]
operator|&&
name|t
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|&&
name|t
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|*
literal|10
operator|>
name|itimeout
condition|)
name|itimeout
operator|=
name|t
operator|->
name|c_cc
index|[
name|VTIME
index|]
operator|*
literal|10
expr_stmt|;
comment|/* store it, taking care not to overflow the byte-sized register */
operator|*
operator|(
name|base
operator|+
name|CD1400_RTPR
operator|)
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|itimeout
operator|<=
literal|255
operator|)
condition|?
name|itimeout
else|:
literal|255
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * channel control 	 *	receiver enable 	 *	transmitter enable (always set) 	 */
name|opt
operator|=
operator|(
literal|1
operator|<<
literal|4
operator|)
operator||
operator|(
literal|1
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|cflag
operator|&
name|CREAD
operator|)
condition|?
operator|(
literal|1
operator|<<
literal|1
operator|)
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|opt
operator|!=
name|infop
operator|->
name|channel_control
condition|)
block|{
name|infop
operator|->
name|channel_control
operator|=
name|opt
expr_stmt|;
name|cd1400_channel_cmd
argument_list|(
name|base
argument_list|,
name|opt
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|Smarts
comment|/* set special chars */
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
operator|!=
name|_POSIX_VDISABLE
operator|&&
operator|(
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
operator|!=
name|infop
operator|->
name|spec_char
index|[
literal|0
index|]
operator|)
condition|)
block|{
operator|*
operator|(
name|base
operator|+
name|CD1400_SCHR1
operator|)
operator|=
name|infop
operator|->
name|spec_char
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
operator|!=
name|_POSIX_VDISABLE
operator|&&
operator|(
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
operator|!=
name|infop
operator|->
name|spec_char
index|[
literal|1
index|]
operator|)
condition|)
block|{
operator|*
operator|(
name|base
operator|+
name|CD1400_SCHR2
operator|)
operator|=
name|infop
operator|->
name|spec_char
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VINTR
index|]
operator|!=
name|_POSIX_VDISABLE
operator|&&
operator|(
name|t
operator|->
name|c_cc
index|[
name|VINTR
index|]
operator|!=
name|infop
operator|->
name|spec_char
index|[
literal|2
index|]
operator|)
condition|)
block|{
operator|*
operator|(
name|base
operator|+
name|CD1400_SCHR3
operator|)
operator|=
name|infop
operator|->
name|spec_char
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|c_cc
index|[
name|VINTR
index|]
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|->
name|c_cc
index|[
name|VSUSP
index|]
operator|!=
name|_POSIX_VDISABLE
operator|&&
operator|(
name|t
operator|->
name|c_cc
index|[
name|VSUSP
index|]
operator|!=
name|infop
operator|->
name|spec_char
index|[
literal|3
index|]
operator|)
condition|)
block|{
operator|*
operator|(
name|base
operator|+
name|CD1400_SCHR4
operator|)
operator|=
name|infop
operator|->
name|spec_char
index|[
literal|0
index|]
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSUSP
index|]
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * set channel option register 1 - 	 *	parity mode 	 *	stop bits 	 *	char length 	 */
name|opt
operator|=
literal|0
expr_stmt|;
comment|/* parity */
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
block|{
if|if
condition|(
name|cflag
operator|&
name|PARODD
condition|)
name|opt
operator||=
literal|1
operator|<<
literal|7
expr_stmt|;
name|opt
operator||=
literal|2
operator|<<
literal|5
expr_stmt|;
comment|/* normal parity mode */
block|}
if|if
condition|(
operator|!
operator|(
name|iflag
operator|&
name|INPCK
operator|)
condition|)
name|opt
operator||=
literal|1
operator|<<
literal|4
expr_stmt|;
comment|/* ignore parity */
comment|/* stop bits */
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
name|opt
operator||=
literal|2
operator|<<
literal|2
expr_stmt|;
comment|/* char length */
name|opt
operator||=
operator|(
name|cflag
operator|&
name|CSIZE
operator|)
operator|>>
literal|8
expr_stmt|;
comment|/* nasty, but fast */
if|if
condition|(
name|opt
operator|!=
name|infop
operator|->
name|cor
index|[
literal|0
index|]
condition|)
block|{
name|cor_change
operator||=
literal|1
operator|<<
literal|1
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_COR1
operator|)
operator|=
name|opt
expr_stmt|;
block|}
comment|/* 	 * set channel option register 2 - 	 *	flow control 	 */
name|opt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
if|if
condition|(
name|iflag
operator|&
name|IXANY
condition|)
name|opt
operator||=
literal|1
operator|<<
literal|7
expr_stmt|;
comment|/* auto output restart on any char after XOFF */
if|if
condition|(
name|iflag
operator|&
name|IXOFF
condition|)
name|opt
operator||=
literal|1
operator|<<
literal|6
expr_stmt|;
comment|/* auto XOFF output flow-control */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ALWAYS_RTS_CTS
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
endif|#
directive|endif
name|opt
operator||=
literal|1
operator|<<
literal|1
expr_stmt|;
comment|/* auto CTS flow-control */
if|if
condition|(
name|opt
operator|!=
name|infop
operator|->
name|cor
index|[
literal|1
index|]
condition|)
block|{
name|cor_change
operator||=
literal|1
operator|<<
literal|2
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_COR2
operator|)
operator|=
name|opt
expr_stmt|;
block|}
comment|/* 	 * set channel option register 3 - 	 *	receiver FIFO interrupt threshold 	 *	flow control 	 */
name|opt
operator|=
name|RxFifoThreshold
expr_stmt|;
comment|/* rx fifo threshold */
ifdef|#
directive|ifdef
name|Smarts
if|if
condition|(
name|t
operator|->
name|c_lflag
operator|&
name|ICANON
condition|)
name|opt
operator||=
literal|1
operator|<<
literal|6
expr_stmt|;
comment|/* detect INTR& SUSP chars */
if|if
condition|(
name|iflag
operator|&
name|IXOFF
condition|)
name|opt
operator||=
operator|(
literal|1
operator|<<
literal|5
operator|)
operator||
operator|(
literal|1
operator|<<
literal|4
operator|)
expr_stmt|;
comment|/* transparent in-band flow control */
endif|#
directive|endif
if|if
condition|(
name|opt
operator|!=
name|infop
operator|->
name|cor
index|[
literal|2
index|]
condition|)
block|{
name|cor_change
operator||=
literal|1
operator|<<
literal|3
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_COR3
operator|)
operator|=
name|opt
expr_stmt|;
block|}
comment|/* notify the CD1400 if COR1-3 have changed */
if|if
condition|(
name|cor_change
condition|)
block|{
name|cor_change
operator||=
literal|1
operator|<<
literal|6
expr_stmt|;
comment|/* COR change flag */
name|cd1400_channel_cmd
argument_list|(
name|base
argument_list|,
name|cor_change
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * set channel option register 4 - 	 *	CR/NL processing 	 *	break processing 	 *	received exception processing 	 */
name|opt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IGNCR
condition|)
name|opt
operator||=
literal|1
operator|<<
literal|7
expr_stmt|;
ifdef|#
directive|ifdef
name|Smarts
comment|/* 	 * we need a new ttyinput() for this, as we don't want to 	 * have ICRNL&& INLCR being done in both layers, or to have 	 * synchronisation problems 	 */
if|if
condition|(
name|iflag
operator|&
name|ICRNL
condition|)
name|opt
operator||=
literal|1
operator|<<
literal|6
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|INLCR
condition|)
name|opt
operator||=
literal|1
operator|<<
literal|5
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iflag
operator|&
name|IGNBRK
condition|)
name|opt
operator||=
literal|1
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iflag
operator|&
name|BRKINT
operator|)
condition|)
name|opt
operator||=
literal|1
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IGNPAR
condition|)
ifdef|#
directive|ifdef
name|LogOverruns
name|opt
operator||=
literal|0
expr_stmt|;
comment|/* broken chars cause receive exceptions */
else|#
directive|else
name|opt
operator||=
literal|2
expr_stmt|;
comment|/* discard broken chars */
endif|#
directive|endif
else|else
block|{
if|if
condition|(
name|iflag
operator|&
name|PARMRK
condition|)
name|opt
operator||=
literal|4
expr_stmt|;
comment|/* precede broken chars with 0xff 0x0 */
else|else
ifdef|#
directive|ifdef
name|LogOverruns
name|opt
operator||=
literal|0
expr_stmt|;
comment|/* broken chars cause receive exceptions */
else|#
directive|else
name|opt
operator||=
literal|3
expr_stmt|;
comment|/* convert framing/parity errs to nulls */
endif|#
directive|endif
block|}
operator|*
operator|(
name|base
operator|+
name|CD1400_COR4
operator|)
operator|=
name|opt
expr_stmt|;
comment|/* 	 * set channel option register 5 - 	 */
name|opt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|ISTRIP
condition|)
name|opt
operator||=
literal|1
operator|<<
literal|7
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_iflag
operator|&
name|IEXTEN
condition|)
block|{
name|opt
operator||=
literal|1
operator|<<
literal|6
expr_stmt|;
comment|/* enable LNEXT (e.g. ctrl-v quoting) handling */
block|}
ifdef|#
directive|ifdef
name|Smarts
if|if
condition|(
name|t
operator|->
name|c_oflag
operator|&
name|ONLCR
condition|)
name|opt
operator||=
literal|1
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_oflag
operator|&
name|OCRNL
condition|)
name|opt
operator||=
literal|1
expr_stmt|;
endif|#
directive|endif
operator|*
operator|(
name|base
operator|+
name|CD1400_COR5
operator|)
operator|=
name|opt
expr_stmt|;
comment|/* 	 * set modem change option register 1 	 *	generate modem interrupts on which 1 -> 0 input transitions 	 *	also controls auto-DTR output flow-control, which we don't use 	 */
name|opt
operator|=
operator|(
name|cflag
operator|&
name|CLOCAL
operator|)
condition|?
literal|0
else|:
literal|1
operator|<<
literal|4
expr_stmt|;
comment|/* CD */
operator|*
operator|(
name|base
operator|+
name|CD1400_MCOR1
operator|)
operator|=
name|opt
expr_stmt|;
comment|/* 	 * set modem change option register 2 	 *	generate modem interrupts on specific 0 -> 1 input transitions 	 */
name|opt
operator|=
operator|(
name|cflag
operator|&
name|CLOCAL
operator|)
condition|?
literal|0
else|:
literal|1
operator|<<
literal|4
expr_stmt|;
comment|/* CD */
operator|*
operator|(
name|base
operator|+
name|CD1400_MCOR2
operator|)
operator|=
name|opt
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* end of cyparam */
end_comment

begin_function
name|void
name|cystart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|u_char
name|unit
init|=
name|UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
name|struct
name|cy
modifier|*
name|infop
init|=
name|info
index|[
name|unit
index|]
decl_stmt|;
name|cy_addr
name|base
init|=
name|infop
operator|->
name|base_addr
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|CyDebug
name|infop
operator|->
name|start_count
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* check the flow-control situation */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
condition|)
return|return;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TxBuffer
name|service_upper_tx
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* feed the monster */
endif|#
directive|endif
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|infop
operator|->
name|intr_enable
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
operator|)
condition|)
block|{
comment|/* select the channel */
operator|*
operator|(
name|base
operator|+
name|CD1400_CAR
operator|)
operator|=
name|unit
operator|&
operator|(
name|u_char
operator|)
literal|3
expr_stmt|;
comment|/* (re)enable interrupts to set things in motion */
name|infop
operator|->
name|intr_enable
operator||=
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_SRER
operator|)
operator|=
name|infop
operator|->
name|intr_enable
expr_stmt|;
name|infop
operator|->
name|start_real
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of cystart() */
end_comment

begin_function
name|int
name|cystop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|u_char
name|unit
init|=
name|UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
name|struct
name|cy
modifier|*
name|ip
init|=
name|info
index|[
name|unit
index|]
decl_stmt|;
name|cy_addr
name|base
init|=
name|ip
operator|->
name|base_addr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* select the channel */
operator|*
operator|(
name|base
operator|+
name|CD1400_CAR
operator|)
operator|=
name|unit
operator|&
literal|3
expr_stmt|;
comment|/* halt output by disabling transmit interrupts */
name|ip
operator|->
name|intr_enable
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|2
operator|)
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_SRER
operator|)
operator|=
name|ip
operator|->
name|intr_enable
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|tty
modifier|*
name|cydevtotty
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|u_char
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
comment|/* NCY * ? */
name|PORTS_PER_CYCLOM
condition|)
return|return
name|NULL
return|;
return|return
name|info
index|[
name|unit
index|]
operator|->
name|tty
return|;
block|}
end_function

begin_function
name|int
name|cyspeed
parameter_list|(
name|int
name|speed
parameter_list|,
name|int
modifier|*
name|prescaler_io
parameter_list|)
block|{
name|int
name|actual
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|divider
decl_stmt|;
name|int
name|prescaler
decl_stmt|;
name|int
name|prescaler_unit
decl_stmt|;
if|if
condition|(
name|speed
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|speed
operator|<
literal|0
operator|||
name|speed
operator|>
literal|150000
condition|)
return|return
operator|-
literal|1
return|;
comment|/* determine which prescaler to use */
for|for
control|(
name|prescaler_unit
operator|=
literal|4
operator|,
name|prescaler
operator|=
literal|2048
init|;
name|prescaler_unit
condition|;
name|prescaler_unit
operator|--
operator|,
name|prescaler
operator|>>=
literal|2
control|)
block|{
if|if
condition|(
name|CYCLOM_CLOCK
operator|/
name|prescaler
operator|/
name|speed
operator|>
literal|63
condition|)
break|break;
block|}
name|divider
operator|=
operator|(
name|CYCLOM_CLOCK
operator|/
name|prescaler
operator|*
literal|2
operator|/
name|speed
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* round off */
if|if
condition|(
name|divider
operator|>
literal|255
condition|)
name|divider
operator|=
literal|255
expr_stmt|;
name|actual
operator|=
name|CYCLOM_CLOCK
operator|/
name|prescaler
operator|/
name|divider
expr_stmt|;
name|error
operator|=
operator|(
operator|(
name|actual
operator|-
name|speed
operator|)
operator|*
literal|2000
operator|/
name|speed
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* percentage */
comment|/* 3.0% max error tolerance */
if|if
condition|(
name|error
operator|<
operator|-
literal|30
operator|||
name|error
operator|>
literal|30
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
literal|0
block|printf("prescaler = %d (%d)\n", prescaler, prescaler_unit);     printf("divider = %d (%x)\n", divider, divider);     printf("actual = %d\n", actual);     printf("error = %d\n", error);
endif|#
directive|endif
operator|*
name|prescaler_io
operator|=
name|prescaler_unit
expr_stmt|;
return|return
name|divider
return|;
block|}
end_function

begin_comment
comment|/* end of cyspeed() */
end_comment

begin_function
specifier|static
name|void
name|cd1400_channel_cmd
parameter_list|(
name|cy_addr
name|base
parameter_list|,
name|u_char
name|cmd
parameter_list|)
block|{
comment|/* XXX hsu@clinet.fi: This is always more dependent on ISA bus speed, 	   as the card is probed every round?  Replaced delaycount with 8k. 	   Either delaycount has to be implemented in FreeBSD or more sensible 	   way of doing these should be implemented.  DELAY isn't enough here. 	   */
name|unsigned
name|maxwait
init|=
literal|5
operator|*
literal|8
operator|*
literal|1024
decl_stmt|;
comment|/* approx. 5 ms */
comment|/* wait for processing of previous command to complete */
while|while
condition|(
operator|*
operator|(
name|base
operator|+
name|CD1400_CCR
operator|)
operator|&&
name|maxwait
operator|--
condition|)
empty_stmt|;
if|if
condition|(
operator|!
name|maxwait
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"cy: channel command timeout (%d loops) - arrgh\n"
argument_list|,
literal|5
operator|*
literal|8
operator|*
literal|1024
argument_list|)
expr_stmt|;
operator|*
operator|(
name|base
operator|+
name|CD1400_CCR
operator|)
operator|=
name|cmd
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of cd1400_channel_cmd() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CyDebug
end_ifdef

begin_comment
comment|/* useful in ddb */
end_comment

begin_function
name|void
name|cyclear
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* clear the timeout request */
name|disable_intr
argument_list|()
expr_stmt|;
name|timeout_scheduled
operator|=
literal|0
expr_stmt|;
name|enable_intr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cyclearintr
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* clear interrupts */
operator|*
operator|(
name|cyclom_base
operator|+
name|CYCLOM_CLEAR_INTR
operator|)
operator|=
operator|(
name|u_char
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cyparam_dummy
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|cyset
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|active
parameter_list|)
block|{
if|if
condition|(
name|unit
operator|<
literal|0
operator|||
name|unit
operator|>=
comment|/* NCY *? */
name|PORTS_PER_CYCLOM
condition|)
block|{
name|printf
argument_list|(
literal|"bad unit number %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|cy_tty
index|[
name|unit
index|]
operator|.
name|t_param
operator|=
name|active
condition|?
name|cyparam
else|:
name|cyparam_dummy
expr_stmt|;
else|#
directive|else
name|cy_tty
index|[
name|unit
index|]
operator|->
name|t_param
operator|=
name|active
condition|?
name|cyparam
else|:
name|cyparam_dummy
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* useful in ddb */
end_comment

begin_function
name|void
name|cystatus
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|cy
modifier|*
name|infop
init|=
name|info
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|infop
operator|->
name|tty
decl_stmt|;
name|cy_addr
name|base
init|=
name|infop
operator|->
name|base_addr
decl_stmt|;
name|printf
argument_list|(
literal|"info for channel %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"------------------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cd1400 base address:\t0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|infop
operator|->
name|base_addr
argument_list|)
expr_stmt|;
comment|/* select the port */
operator|*
operator|(
name|base
operator|+
name|CD1400_CAR
operator|)
operator|=
operator|(
name|u_char
operator|)
name|unit
expr_stmt|;
name|printf
argument_list|(
literal|"saved channel_control:\t%02x\n"
argument_list|,
name|infop
operator|->
name|channel_control
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"saved cor1:\t\t%02x\n"
argument_list|,
name|infop
operator|->
name|cor
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"service request enable reg:\t%02x (%02x cached)\n"
argument_list|,
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_SRER
operator|)
argument_list|,
name|infop
operator|->
name|intr_enable
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"service request register:\t%02x\n"
argument_list|,
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_SVRR
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"modem status:\t\t\t%02x (%02x cached)\n"
argument_list|,
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_MSVR
operator|)
argument_list|,
name|infop
operator|->
name|modem_sig
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rx/tx/mdm interrupt registers:\t%02x %02x %02x\n"
argument_list|,
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_RIR
operator|)
argument_list|,
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_TIR
operator|)
argument_list|,
operator|(
name|u_char
operator|)
operator|*
operator|(
name|base
operator|+
name|CD1400_MIR
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
condition|)
block|{
name|printf
argument_list|(
literal|"tty state:\t\t\t%04x\n"
argument_list|,
name|tp
operator|->
name|t_state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"upper layer queue lengths:\t%d raw, %d canon, %d output\n"
argument_list|,
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
argument_list|,
name|tp
operator|->
name|t_canq
operator|.
name|c_cc
argument_list|,
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"tty state:\t\t\tclosed\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"calls to cystart():\t\t%d (%d useful)\n"
argument_list|,
name|infop
operator|->
name|start_count
argument_list|,
name|infop
operator|->
name|start_real
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total cyclom service probes:\t%d\n"
argument_list|,
name|cy_svrr_probes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"calls to upper layer:\t\t%d\n"
argument_list|,
name|cy_timeouts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rx buffer chars free:\t\t%d\n"
argument_list|,
name|infop
operator|->
name|rx_buf
operator|->
name|free
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TxBuffer
name|printf
argument_list|(
literal|"tx buffer chars used:\t\t%d\n"
argument_list|,
name|infop
operator|->
name|tx_buf
operator|.
name|used
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"received chars:\t\t\t%d good, %d exception\n"
argument_list|,
name|infop
operator|->
name|recv_normal
argument_list|,
name|infop
operator|->
name|recv_exception
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"transmitted chars:\t\t%d\n"
argument_list|,
name|infop
operator|->
name|xmit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"modem signal deltas:\t\t%d\n"
argument_list|,
name|infop
operator|->
name|mdm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end of cystatus() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCY> 0 */
end_comment

end_unit

