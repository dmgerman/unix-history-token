begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Ported for use with the UltraStor 14f by Gary Close (gclose@wvnvms.wvnet.edu)  * Slight fixes to timeouts to run with the 34F  * Thanks to Julian Elischer for advice and help with this port.  *  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * commenced: Sun Sep 27 18:14:01 PDT 1992  * slight mod to make work with 34F as well: Wed Jun  2 18:05:48 WST 1993  *  * today: Fri Jun  2 17:21:03 EST 1994  * added 24F support  ++sg  *  *      $Id: ultra14f.c,v 1.56 1997/09/07 04:21:25 bde Exp $  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_comment
comment|/* don't laugh.. this compiles to a program too.. look */
end_comment

begin_include
include|#
directive|include
file|"uha.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*KERNEL */
end_comment

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_debug.h>
end_include

begin_include
include|#
directive|include
file|"ioconf.h"
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KERNEL
end_ifndef

begin_define
define|#
directive|define
name|NUHA
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*KERNEL */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|addr
index|[
literal|4
index|]
decl_stmt|;
block|}
name|physaddr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|len
index|[
literal|4
index|]
decl_stmt|;
block|}
name|physlen
typedef|;
end_typedef

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_define
define|#
directive|define
name|UHA_MSCP_MAX
value|32
end_define

begin_comment
comment|/* store up to 32MSCPs at any one time 				 * MAX = ? 				 */
end_comment

begin_define
define|#
directive|define
name|MSCP_HASH_SIZE
value|32
end_define

begin_comment
comment|/* when we have a physical addr. for 				 * a mscp and need to find the mscp in 				 * space, look it up in the hash table 				 */
end_comment

begin_define
define|#
directive|define
name|MSCP_HASH_SHIFT
value|9
end_define

begin_comment
comment|/* only hash on multiples of 512 */
end_comment

begin_define
define|#
directive|define
name|MSCP_HASH
parameter_list|(
name|x
parameter_list|)
value|((((long int)(x))>>MSCP_HASH_SHIFT) % MSCP_HASH_SIZE)
end_define

begin_define
define|#
directive|define
name|UHA_NSEG
value|33
end_define

begin_comment
comment|/* number of dma segments supported */
end_comment

begin_comment
comment|/************************** board definitions *******************************/
end_comment

begin_struct
struct|struct
name|uha_reg
block|{
name|int
name|id
decl_stmt|;
comment|/* product id reg		*/
name|int
name|type
decl_stmt|;
comment|/* product type reg		*/
name|int
name|ectl
decl_stmt|;
comment|/* EISA expansion control bits	*/
name|int
name|config
decl_stmt|;
comment|/* configuration bits 		*/
name|int
name|lmask
decl_stmt|;
comment|/* local doorbell mask reg	*/
name|int
name|lint
decl_stmt|;
comment|/* local doorbell int/stat reg	*/
name|int
name|smask
decl_stmt|;
comment|/* system doorbell mask reg	*/
name|int
name|sint
decl_stmt|;
comment|/* system doorbell int/stat reg	*/
name|int
name|ogmcmd
decl_stmt|;
comment|/* outgoing mail command	*/
name|int
name|ogmptr
decl_stmt|;
comment|/* outgoing mail ptr		*/
name|int
name|icmcmd
decl_stmt|;
comment|/* incoming mail command	*/
name|int
name|icmptr
decl_stmt|;
comment|/* incoming mail ptr		*/
block|}
struct|;
end_struct

begin_struct
struct|struct
name|uha_bits
block|{
comment|/* uha_lint (read) */
name|unsigned
name|char
name|ldip
decl_stmt|;
comment|/* uha_lint (write) */
name|unsigned
name|char
name|adrst
decl_stmt|;
name|unsigned
name|char
name|sbrst
decl_stmt|;
name|unsigned
name|char
name|asrst
decl_stmt|;
name|unsigned
name|char
name|abort
decl_stmt|;
name|unsigned
name|char
name|ogmint
decl_stmt|;
comment|/* uha_sint (read) */
name|unsigned
name|char
name|sintp
decl_stmt|;
name|unsigned
name|char
name|abort_succ
decl_stmt|;
name|unsigned
name|char
name|abort_fail
decl_stmt|;
comment|/* uha_sint (write) */
name|unsigned
name|char
name|abort_ack
decl_stmt|;
name|unsigned
name|char
name|icm_ack
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * UHA_LINT bits (read)  */
end_comment

begin_define
define|#
directive|define
name|UHA_LDIP
value|0x80
end_define

begin_comment
comment|/* local doorbell int pending */
end_comment

begin_define
define|#
directive|define
name|U24_LDIP
value|0x02
end_define

begin_comment
comment|/*  * UHA_LINT bits (write)  */
end_comment

begin_define
define|#
directive|define
name|UHA_ADRST
value|0x40
end_define

begin_comment
comment|/* adapter soft reset */
end_comment

begin_define
define|#
directive|define
name|UHA_SBRST
value|0x20
end_define

begin_comment
comment|/* scsi bus reset */
end_comment

begin_define
define|#
directive|define
name|UHA_ASRST
value|0x60
end_define

begin_comment
comment|/* adapter and scsi reset */
end_comment

begin_define
define|#
directive|define
name|UHA_ABORT
value|0x10
end_define

begin_comment
comment|/* abort MSCP */
end_comment

begin_define
define|#
directive|define
name|UHA_OGMINT
value|0x01
end_define

begin_comment
comment|/* tell adapter to get mail */
end_comment

begin_define
define|#
directive|define
name|U24_SBRST
value|0x40
end_define

begin_comment
comment|/* scsi bus reset */
end_comment

begin_define
define|#
directive|define
name|U24_ADRST
value|0x80
end_define

begin_comment
comment|/* adapter soft reset */
end_comment

begin_define
define|#
directive|define
name|U24_ASRST
value|0xc0
end_define

begin_comment
comment|/* adapter and scsi reset */
end_comment

begin_define
define|#
directive|define
name|U24_ABORT
value|0x10
end_define

begin_comment
comment|/* same? */
end_comment

begin_define
define|#
directive|define
name|U24_OGMINT
value|0x02
end_define

begin_comment
comment|/* enable OGM interrupt */
end_comment

begin_comment
comment|/*  * UHA_SMASK bits (read)  */
end_comment

begin_define
define|#
directive|define
name|UHA_SINTEN
value|0x80
end_define

begin_comment
comment|/* system doorbell interupt Enabled */
end_comment

begin_define
define|#
directive|define
name|UHA_ABORT_COMPLETE_EN
value|0x10
end_define

begin_comment
comment|/* abort MSCP command complete int Enabled */
end_comment

begin_define
define|#
directive|define
name|UHA_ICM_ENABLED
value|0x01
end_define

begin_comment
comment|/* ICM interrupt enabled */
end_comment

begin_comment
comment|/*  * UHA_SMASK bits (write)  */
end_comment

begin_define
define|#
directive|define
name|UHA_ENSINT
value|0x80
end_define

begin_comment
comment|/* enable system doorbell interrupt */
end_comment

begin_define
define|#
directive|define
name|UHA_EN_ABORT_COMPLETE
value|0x10
end_define

begin_comment
comment|/* enable abort MSCP complete int */
end_comment

begin_define
define|#
directive|define
name|UHA_ENICM
value|0x01
end_define

begin_comment
comment|/* enable ICM interrupt */
end_comment

begin_comment
comment|/*  * UHA_SINT bits (read)  */
end_comment

begin_define
define|#
directive|define
name|UHA_SINTP
value|0x80
end_define

begin_comment
comment|/* system doorbell int pending */
end_comment

begin_define
define|#
directive|define
name|UHA_ABORT_SUCC
value|0x10
end_define

begin_comment
comment|/* abort MSCP successful */
end_comment

begin_define
define|#
directive|define
name|UHA_ABORT_FAIL
value|0x18
end_define

begin_comment
comment|/* abort MSCP failed */
end_comment

begin_define
define|#
directive|define
name|U24_SINTP
value|0x02
end_define

begin_comment
comment|/* system doorbell int pending */
end_comment

begin_define
define|#
directive|define
name|U24_ABORT_SUCC
value|0x10
end_define

begin_comment
comment|/* same? */
end_comment

begin_define
define|#
directive|define
name|U24_ABORT_FAIL
value|0x18
end_define

begin_comment
comment|/* same? */
end_comment

begin_comment
comment|/*  * UHA_SINT bits (write)  */
end_comment

begin_define
define|#
directive|define
name|UHA_ABORT_ACK
value|0x18
end_define

begin_comment
comment|/* acknowledge status and clear */
end_comment

begin_define
define|#
directive|define
name|UHA_ICM_ACK
value|0x01
end_define

begin_comment
comment|/* acknowledge ICM and clear */
end_comment

begin_define
define|#
directive|define
name|U24_ABORT_ACK
value|0x18
end_define

begin_comment
comment|/* same */
end_comment

begin_define
define|#
directive|define
name|U24_ICM_ACK
value|0x02
end_define

begin_comment
comment|/* 24F acknowledge ICM and clear */
end_comment

begin_comment
comment|/*  * UHA_CONF1 bits (read only)  */
end_comment

begin_define
define|#
directive|define
name|UHA_DMA_CH5
value|0x00
end_define

begin_comment
comment|/* DMA channel 5 */
end_comment

begin_define
define|#
directive|define
name|UHA_DMA_CH6
value|0x40
end_define

begin_comment
comment|/* 6 */
end_comment

begin_define
define|#
directive|define
name|UHA_DMA_CH7
value|0x80
end_define

begin_comment
comment|/* 7 */
end_comment

begin_define
define|#
directive|define
name|UHA_IRQ15
value|0x00
end_define

begin_comment
comment|/* IRQ 15 */
end_comment

begin_define
define|#
directive|define
name|UHA_IRQ14
value|0x10
end_define

begin_comment
comment|/* 14 */
end_comment

begin_define
define|#
directive|define
name|UHA_IRQ11
value|0x20
end_define

begin_comment
comment|/* 11 */
end_comment

begin_define
define|#
directive|define
name|UHA_IRQ10
value|0x30
end_define

begin_comment
comment|/* 10 */
end_comment

begin_define
define|#
directive|define
name|EISA_CONFIG
value|0x0c80
end_define

begin_comment
comment|/* Configuration base port */
end_comment

begin_define
define|#
directive|define
name|EISA_DISABLE
value|0x01
end_define

begin_comment
comment|/* EISA disable bit */
end_comment

begin_comment
comment|/*  * ha_status error codes  */
end_comment

begin_define
define|#
directive|define
name|UHA_NO_ERR
value|0x00
end_define

begin_comment
comment|/* No error supposedly */
end_comment

begin_define
define|#
directive|define
name|UHA_SBUS_ABORT_ERR
value|0x84
end_define

begin_comment
comment|/* scsi bus abort error */
end_comment

begin_define
define|#
directive|define
name|UHA_SBUS_TIMEOUT
value|0x91
end_define

begin_comment
comment|/* scsi bus selection timeout */
end_comment

begin_define
define|#
directive|define
name|UHA_SBUS_OVER_UNDER
value|0x92
end_define

begin_comment
comment|/* scsi bus over/underrun */
end_comment

begin_define
define|#
directive|define
name|UHA_BAD_SCSI_CMD
value|0x96
end_define

begin_comment
comment|/* illegal scsi command */
end_comment

begin_define
define|#
directive|define
name|UHA_AUTO_SENSE_ERR
value|0x9b
end_define

begin_comment
comment|/* auto request sense err */
end_comment

begin_define
define|#
directive|define
name|UHA_SBUS_RES_ERR
value|0xa3
end_define

begin_comment
comment|/* scsi bus reset error */
end_comment

begin_define
define|#
directive|define
name|UHA_BAD_SG_LIST
value|0xff
end_define

begin_comment
comment|/* invalid scatter gath list */
end_comment

begin_struct
struct|struct
name|uha_dma_seg
block|{
name|physaddr
name|addr
decl_stmt|;
name|physlen
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mscp
block|{
name|unsigned
name|char
name|opcode
range|:
literal|3
decl_stmt|;
define|#
directive|define
name|U14_HAC
value|0x01
comment|/* host adapter command */
define|#
directive|define
name|U14_TSP
value|0x02
comment|/* target scsi pass through command */
define|#
directive|define
name|U14_SDR
value|0x04
comment|/* scsi device reset */
name|unsigned
name|char
name|xdir
range|:
literal|2
decl_stmt|;
comment|/* xfer direction */
define|#
directive|define
name|U14_SDET
value|0x00
comment|/* determined by scsi command */
define|#
directive|define
name|U14_SDIN
value|0x01
comment|/* scsi data in */
define|#
directive|define
name|U14_SDOUT
value|0x02
comment|/* scsi data out */
define|#
directive|define
name|U14_NODATA
value|0x03
comment|/* no data xfer */
name|unsigned
name|char
name|dcn
range|:
literal|1
decl_stmt|;
comment|/* disable disconnect for this command */
name|unsigned
name|char
name|ca
range|:
literal|1
decl_stmt|;
comment|/* cache control */
name|unsigned
name|char
name|sgth
range|:
literal|1
decl_stmt|;
comment|/* scatter gather flag */
name|unsigned
name|char
name|target
range|:
literal|3
decl_stmt|;
name|unsigned
name|char
name|chan
range|:
literal|2
decl_stmt|;
comment|/* scsi channel (always 0 for 14f) */
name|unsigned
name|char
name|lun
range|:
literal|3
decl_stmt|;
name|physaddr
name|data
decl_stmt|;
name|physlen
name|datalen
decl_stmt|;
name|physaddr
name|link
decl_stmt|;
name|unsigned
name|char
name|link_id
decl_stmt|;
name|unsigned
name|char
name|sg_num
decl_stmt|;
comment|/*number of scat gath segs */
comment|/*in s-g list if sg flag is */
comment|/*set. starts at 1, 8bytes per */
name|unsigned
name|char
name|senselen
decl_stmt|;
name|unsigned
name|char
name|cdblen
decl_stmt|;
name|unsigned
name|char
name|cdb
index|[
literal|12
index|]
decl_stmt|;
name|unsigned
name|char
name|ha_status
decl_stmt|;
name|unsigned
name|char
name|targ_status
decl_stmt|;
name|physaddr
name|sense
decl_stmt|;
comment|/* if 0 no auto sense */
comment|/*-----------------end of hardware supported fields----------------*/
name|struct
name|mscp
modifier|*
name|next
decl_stmt|;
comment|/* in free list */
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
comment|/* the scsi_xfer for this cmd */
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|MSCP_FREE
value|0
define|#
directive|define
name|MSCP_ACTIVE
value|1
define|#
directive|define
name|MSCP_ABORTED
value|2
name|struct
name|uha_dma_seg
name|uha_dma
index|[
name|UHA_NSEG
index|]
decl_stmt|;
name|struct
name|scsi_sense_data
name|mscp_sense
decl_stmt|;
name|struct
name|mscp
modifier|*
name|nexthash
decl_stmt|;
name|long
name|int
name|hashkey
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|uha_data
block|{
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|UHA_INIT
value|0x01
define|#
directive|define
name|UHA_24F
value|0x02
name|int
name|baseport
decl_stmt|;
name|struct
name|mscp
modifier|*
name|mscphash
index|[
name|MSCP_HASH_SIZE
index|]
decl_stmt|;
name|struct
name|mscp
modifier|*
name|free_mscp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|our_id
decl_stmt|;
comment|/* our scsi id */
name|int
name|vect
decl_stmt|;
name|int
name|dma
decl_stmt|;
name|int
name|nummscps
decl_stmt|;
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
name|struct
name|uha_reg
modifier|*
name|ur
decl_stmt|;
name|struct
name|uha_bits
modifier|*
name|ub
decl_stmt|;
block|}
modifier|*
name|uhadata
index|[
name|NUHA
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|uha_abort
name|__P
argument_list|(
operator|(
expr|struct
name|uha_data
operator|*
name|uha
operator|,
expr|struct
name|mscp
operator|*
name|mscp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|uha_adapter_info
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uha_attach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uha_done
name|__P
argument_list|(
operator|(
expr|struct
name|uha_data
operator|*
name|uha
operator|,
expr|struct
name|mscp
operator|*
name|mscp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uha_free_mscp
name|__P
argument_list|(
operator|(
expr|struct
name|uha_data
operator|*
name|uha
operator|,
expr|struct
name|mscp
operator|*
name|mscp
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mscp
modifier|*
name|uha_get_mscp
name|__P
argument_list|(
operator|(
expr|struct
name|uha_data
operator|*
name|uha
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uha_init
name|__P
argument_list|(
operator|(
expr|struct
name|uha_data
operator|*
name|uha
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uha24_init
name|__P
argument_list|(
operator|(
expr|struct
name|uha_data
operator|*
name|uha
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uhaminphys
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
name|bp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mscp
modifier|*
name|uha_mscp_phys_kv
name|__P
argument_list|(
operator|(
expr|struct
name|uha_data
operator|*
name|uha
operator|,
name|long
name|mscp_phys
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|uha_poll
name|__P
argument_list|(
operator|(
expr|struct
name|uha_data
operator|*
name|uha
operator|,
name|int
name|wait
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UHADEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|uha_print_active_mscp
name|__P
argument_list|(
operator|(
expr|struct
name|uha_data
operator|*
name|uha
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uha_print_mscp
name|__P
argument_list|(
operator|(
expr|struct
name|mscp
operator|*
name|mscp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|uhaprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|uha_scsi_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_xfer
operator|*
name|xs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|uha_send_mbox
name|__P
argument_list|(
operator|(
expr|struct
name|uha_data
operator|*
name|uha
operator|,
expr|struct
name|mscp
operator|*
name|mscp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|uha_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mscp
modifier|*
name|cheat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|int
name|scratch
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EISA_MAX_SLOTS
value|16
end_define

begin_comment
comment|/* XXX This should go into a comon header */
end_comment

begin_expr_stmt
specifier|static
name|uha_slot
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* slot last board was found in */
end_comment

begin_expr_stmt
specifier|static
name|uha_unit
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|UHA_SHOWMSCPS
value|0x01
end_define

begin_define
define|#
directive|define
name|UHA_SHOWINTS
value|0x02
end_define

begin_define
define|#
directive|define
name|UHA_SHOWCMDS
value|0x04
end_define

begin_define
define|#
directive|define
name|UHA_SHOWMISC
value|0x08
end_define

begin_define
define|#
directive|define
name|FAIL
value|1
end_define

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_decl_stmt
name|struct
name|isa_driver
name|uhadriver
init|=
block|{
name|uhaprobe
block|,
name|uha_attach
block|,
literal|"uha"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|uha_switch
init|=
block|{
name|uha_scsi_cmd
block|,
name|uhaminphys
block|,
literal|0
block|,
literal|0
block|,
name|uha_adapter_info
block|,
literal|"uha"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the below structure is so we have a default dev struct for out link struct */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|uha_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"uha"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*KERNEL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KERNEL
end_ifndef

begin_function
name|main
parameter_list|()
block|{
name|printf
argument_list|(
literal|"uha_data is %d bytes\n"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uha_data
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mscp is %d bytes\n"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mscp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*KERNEL*/
end_comment

begin_comment
comment|/*  * Function to send a command out through a mailbox  */
end_comment

begin_function
specifier|static
name|void
name|uha_send_mbox
parameter_list|(
name|struct
name|uha_data
modifier|*
name|uha
parameter_list|,
name|struct
name|mscp
modifier|*
name|mscp
parameter_list|)
block|{
name|int
name|spincount
init|=
literal|100000
decl_stmt|;
comment|/* 1s should be enough */
name|struct
name|uha_reg
modifier|*
name|ur
init|=
name|uha
operator|->
name|ur
decl_stmt|;
name|struct
name|uha_bits
modifier|*
name|ub
init|=
name|uha
operator|->
name|ub
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
while|while
condition|(
operator|--
name|spincount
condition|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|ur
operator|->
name|lint
argument_list|)
operator|&
name|ub
operator|->
name|ldip
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spincount
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: uha_send_mbox, board is not responding\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"ultra14f"
argument_list|)
expr_stmt|;
block|}
name|outl
argument_list|(
name|ur
operator|->
name|ogmptr
argument_list|,
name|KVTOPHYS
argument_list|(
name|mscp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uha
operator|->
name|flags
operator|&
name|UHA_24F
condition|)
name|outb
argument_list|(
name|ur
operator|->
name|ogmcmd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ur
operator|->
name|lint
argument_list|,
name|ub
operator|->
name|ogmint
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function to send abort to 14f  */
end_comment

begin_function
name|int
name|uha_abort
parameter_list|(
name|struct
name|uha_data
modifier|*
name|uha
parameter_list|,
name|struct
name|mscp
modifier|*
name|mscp
parameter_list|)
block|{
name|int
name|spincount
init|=
literal|100
decl_stmt|;
comment|/* 1 mSec */
name|int
name|abortcount
init|=
literal|200000
decl_stmt|;
comment|/*2 secs */
name|struct
name|uha_reg
modifier|*
name|ur
init|=
name|uha
operator|->
name|ur
decl_stmt|;
name|struct
name|uha_bits
modifier|*
name|ub
init|=
name|uha
operator|->
name|ub
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
while|while
condition|(
operator|--
name|spincount
condition|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|ur
operator|->
name|lint
argument_list|)
operator|&
name|ub
operator|->
name|ldip
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spincount
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: uha_abort, board is not responding\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"ultra14f"
argument_list|)
expr_stmt|;
block|}
name|outl
argument_list|(
name|ur
operator|->
name|ogmptr
argument_list|,
name|KVTOPHYS
argument_list|(
name|mscp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uha
operator|->
name|flags
operator|&
name|UHA_24F
condition|)
name|outb
argument_list|(
name|ur
operator|->
name|ogmcmd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ur
operator|->
name|lint
argument_list|,
name|ub
operator|->
name|abort
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|abortcount
condition|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|ur
operator|->
name|sint
argument_list|)
operator|&
name|ub
operator|->
name|abort_fail
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abortcount
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: uha_abort, board is not responding\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"ultra14f"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inb
argument_list|(
name|ur
operator|->
name|sint
argument_list|)
operator|&
literal|0x10
operator|)
operator|!=
literal|0
condition|)
block|{
name|outb
argument_list|(
name|ur
operator|->
name|sint
argument_list|,
name|ub
operator|->
name|abort_ack
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|outb
argument_list|(
name|ur
operator|->
name|sint
argument_list|,
name|ub
operator|->
name|abort_ack
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Function to poll for command completion when in poll mode.  *  *	wait = timeout in msec  */
end_comment

begin_function
specifier|static
name|int
name|uha_poll
parameter_list|(
name|struct
name|uha_data
modifier|*
name|uha
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|struct
name|uha_reg
modifier|*
name|ur
init|=
name|uha
operator|->
name|ur
decl_stmt|;
name|struct
name|uha_bits
modifier|*
name|ub
init|=
name|uha
operator|->
name|ub
decl_stmt|;
name|int
name|stport
init|=
name|ur
operator|->
name|sint
decl_stmt|;
while|while
condition|(
operator|--
name|wait
condition|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|stport
argument_list|)
operator|&
name|ub
operator|->
name|sintp
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 1 mSec per loop */
block|}
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: uha_poll, board is not responding\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|uhaintr
argument_list|(
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the device can be found at the port given and if so, set it up  * ready for further work as an argument, takes the isa_device structure  * from autoconf.c  */
end_comment

begin_function
name|int
name|uhaprobe
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|uha_unit
decl_stmt|;
name|struct
name|uha_data
modifier|*
name|uha
decl_stmt|;
name|dev
operator|->
name|id_unit
operator|=
name|unit
expr_stmt|;
comment|/* XXX */
comment|/* 	 * find unit and check we have that many defined 	 */
if|if
condition|(
name|unit
operator|>=
name|NUHA
condition|)
block|{
name|printf
argument_list|(
literal|"uha: unit number (%d) too high\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dev
operator|->
name|id_unit
operator|=
name|unit
expr_stmt|;
comment|/* 	 * Allocate a storage area for us 	 */
if|if
condition|(
name|uhadata
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: memory already allocated\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|uha
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uha_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uha
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|uha
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uha_data
argument_list|)
argument_list|)
expr_stmt|;
name|uha
operator|->
name|ur
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uha_reg
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uha
operator|->
name|ur
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|uha
operator|->
name|ur
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uha_reg
argument_list|)
argument_list|)
expr_stmt|;
name|uha
operator|->
name|ub
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|uha_bits
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uha
operator|->
name|ub
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|uha
operator|->
name|ub
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uha_bits
argument_list|)
argument_list|)
expr_stmt|;
name|uhadata
index|[
name|unit
index|]
operator|=
name|uha
expr_stmt|;
name|uha
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|uha
operator|->
name|baseport
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
comment|/* 	 * Try initialise a unit at this location 	 * sets up dma and bus speed, loads uha->vect 	 */
if|if
condition|(
name|uha_init
argument_list|(
name|uha
argument_list|)
operator|!=
literal|0
operator|&&
name|uha24_init
argument_list|(
name|uha
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|uhadata
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|uha
operator|->
name|ur
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uha
operator|->
name|ub
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uha
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* if it's there put in its interrupt and DRQ vectors */
name|dev
operator|->
name|id_irq
operator|=
operator|(
literal|1
operator|<<
name|uha
operator|->
name|vect
operator|)
expr_stmt|;
name|dev
operator|->
name|id_drq
operator|=
name|uha
operator|->
name|dma
expr_stmt|;
name|dev
operator|->
name|id_iobase
operator|=
name|uha
operator|->
name|baseport
expr_stmt|;
name|uha_unit
operator|++
expr_stmt|;
return|return
operator|(
literal|16
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|uha_attach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|uha_data
modifier|*
name|uha
init|=
name|uhadata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
comment|/* 	 * fill in the prototype scsi_link. 	 */
name|uha
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|unit
expr_stmt|;
name|uha
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|uha
operator|->
name|our_id
expr_stmt|;
name|uha
operator|->
name|sc_link
operator|.
name|adapter_softc
operator|=
name|uha
expr_stmt|;
name|uha
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|uha_switch
expr_stmt|;
name|uha
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|uha_dev
expr_stmt|;
name|uha
operator|->
name|sc_link
operator|.
name|flags
operator|=
name|SDEV_BOUNCE
expr_stmt|;
comment|/* 	 * Prepare the scsibus_data area for the upperlevel 	 * scsi code. 	 */
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|uha
operator|->
name|sc_link
expr_stmt|;
comment|/* 	 * ask the adapter what subunits are present 	 */
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Return some information to the caller about  * the adapter and it's capabilities  */
end_comment

begin_function
name|u_int32_t
name|uha_adapter_info
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
return|return
operator|(
literal|2
operator|)
return|;
comment|/* 2 outstanding requests at a time per device */
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adaptor  */
end_comment

begin_function
name|void
name|uhaintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|uha_data
modifier|*
name|uha
init|=
name|uhadata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
name|u_char
name|uhastat
decl_stmt|;
name|unsigned
name|long
name|int
name|mboxval
decl_stmt|;
name|struct
name|uha_reg
modifier|*
name|ur
decl_stmt|;
name|struct
name|uha_bits
modifier|*
name|ub
decl_stmt|;
name|int
name|port
decl_stmt|;
name|ur
operator|=
name|uha
operator|->
name|ur
expr_stmt|;
name|ub
operator|=
name|uha
operator|->
name|ub
expr_stmt|;
name|port
operator|=
name|uha
operator|->
name|baseport
expr_stmt|;
ifdef|#
directive|ifdef
name|UHADEBUG
name|printf
argument_list|(
literal|"uhaintr "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*UHADEBUG */
while|while
condition|(
operator|(
name|uhastat
operator|=
name|inb
argument_list|(
name|ur
operator|->
name|sint
argument_list|)
operator|)
operator|&
name|ub
operator|->
name|sintp
condition|)
block|{
comment|/* 		 * First get all the information and then 		 * acknowledge the interrupt 		 */
name|mboxval
operator|=
name|inl
argument_list|(
name|ur
operator|->
name|icmptr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ur
operator|->
name|sint
argument_list|,
name|ub
operator|->
name|icm_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|uha
operator|->
name|flags
operator|&
name|UHA_24F
condition|)
name|outb
argument_list|(
name|ur
operator|->
name|icmcmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UHADEBUG
name|printf
argument_list|(
literal|"status = 0x%x "
argument_list|,
name|uhastat
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*UHADEBUG*/
comment|/* 		 * Process the completed operation 		 */
name|mscp
operator|=
name|uha_mscp_phys_kv
argument_list|(
name|uha
argument_list|,
name|mboxval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mscp
condition|)
block|{
name|printf
argument_list|(
literal|"uha: BAD MSCP RETURNED\n"
argument_list|)
expr_stmt|;
return|return;
comment|/* whatever it was, it'll timeout */
block|}
name|untimeout
argument_list|(
name|uha_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|mscp
argument_list|,
name|mscp
operator|->
name|xs
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|uha_done
argument_list|(
name|uha
argument_list|,
name|mscp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * We have a mscp which has been processed by the adaptor, now we look to see  * how the operation went.  */
end_comment

begin_function
name|void
name|uha_done
parameter_list|(
name|uha
parameter_list|,
name|mscp
parameter_list|)
name|struct
name|uha_data
modifier|*
name|uha
decl_stmt|;
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
block|{
name|struct
name|scsi_sense_data
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|mscp
operator|->
name|xs
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"uha_done\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Otherwise, put the results of the operation 	 * into the xfer and call whoever started it 	 */
if|if
condition|(
operator|(
operator|(
name|mscp
operator|->
name|ha_status
operator|!=
name|UHA_NO_ERR
operator|)
operator|||
operator|(
name|mscp
operator|->
name|targ_status
operator|!=
name|SCSI_OK
operator|)
operator|)
operator|&&
operator|(
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|s1
operator|=
operator|&
operator|(
name|mscp
operator|->
name|mscp_sense
operator|)
expr_stmt|;
name|s2
operator|=
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
if|if
condition|(
name|mscp
operator|->
name|ha_status
operator|!=
name|UHA_NO_ERR
condition|)
block|{
switch|switch
condition|(
name|mscp
operator|->
name|ha_status
condition|)
block|{
case|case
name|UHA_SBUS_ABORT_ERR
case|:
case|case
name|UHA_SBUS_TIMEOUT
case|:
comment|/* No sel response */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"abort or timeout; ha_status 0x%x\n"
operator|,
name|mscp
operator|->
name|ha_status
operator|)
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
break|break;
case|case
name|UHA_SBUS_OVER_UNDER
case|:
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"scsi bus xfer over/underrun\n"
operator|)
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
default|default:
comment|/* Other scsi protocol messes */
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|printf
argument_list|(
literal|"uha%d: unexpected ha_status 0x%x (target status 0x%x)\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|,
name|mscp
operator|->
name|ha_status
argument_list|,
name|mscp
operator|->
name|targ_status
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Target status problem */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"target err 0x%x\n"
operator|,
name|mscp
operator|->
name|targ_status
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mscp
operator|->
name|targ_status
condition|)
block|{
case|case
literal|0x02
case|:
operator|*
name|s2
operator|=
operator|*
name|s1
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"uha%d: unexpected targ_status 0x%x\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|,
name|mscp
operator|->
name|targ_status
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* All went correctly  OR  errors expected */
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|uha_free_mscp
argument_list|(
name|uha
argument_list|,
name|mscp
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A mscp (and hence a mbx-out) is put onto the free list.  */
end_comment

begin_function
name|void
name|uha_free_mscp
parameter_list|(
name|uha
parameter_list|,
name|mscp
parameter_list|,
name|flags
parameter_list|)
name|struct
name|uha_data
modifier|*
name|uha
decl_stmt|;
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|unsigned
name|int
name|opri
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|mscp
operator|->
name|next
operator|=
name|uha
operator|->
name|free_mscp
expr_stmt|;
name|uha
operator|->
name|free_mscp
operator|=
name|mscp
expr_stmt|;
name|mscp
operator|->
name|flags
operator|=
name|MSCP_FREE
expr_stmt|;
comment|/* 	 * If there were none, wake abybody waiting for 	 * one to come free, starting with queued entries 	 */
if|if
condition|(
operator|!
name|mscp
operator|->
name|next
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|uha
operator|->
name|free_mscp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free mscp  *  * If there are none, see if we can allocate a new one.  If so, put it in the  * hash table too otherwise either return an error or sleep.  */
end_comment

begin_function
specifier|static
name|struct
name|mscp
modifier|*
name|uha_get_mscp
parameter_list|(
name|uha
parameter_list|,
name|flags
parameter_list|)
name|struct
name|uha_data
modifier|*
name|uha
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|unsigned
name|opri
init|=
literal|0
decl_stmt|;
name|struct
name|mscp
modifier|*
name|mscpp
decl_stmt|;
name|int
name|hashnum
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * If we can and have to, sleep waiting for one to come free 	 * but only if we can't allocate a new one 	 */
while|while
condition|(
operator|!
operator|(
name|mscpp
operator|=
name|uha
operator|->
name|free_mscp
operator|)
condition|)
block|{
if|if
condition|(
name|uha
operator|->
name|nummscps
operator|<
name|UHA_MSCP_MAX
condition|)
block|{
if|if
condition|(
name|mscpp
operator|=
operator|(
expr|struct
name|mscp
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mscp
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
name|mscpp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mscp
argument_list|)
argument_list|)
expr_stmt|;
name|uha
operator|->
name|nummscps
operator|++
expr_stmt|;
name|mscpp
operator|->
name|flags
operator|=
name|MSCP_ACTIVE
expr_stmt|;
comment|/* 				 * put in the phystokv hash table 				 * Never gets taken out. 				 */
name|mscpp
operator|->
name|hashkey
operator|=
name|KVTOPHYS
argument_list|(
name|mscpp
argument_list|)
expr_stmt|;
name|hashnum
operator|=
name|MSCP_HASH
argument_list|(
name|mscpp
operator|->
name|hashkey
argument_list|)
expr_stmt|;
name|mscpp
operator|->
name|nexthash
operator|=
name|uha
operator|->
name|mscphash
index|[
name|hashnum
index|]
expr_stmt|;
name|uha
operator|->
name|mscphash
index|[
name|hashnum
index|]
operator|=
name|mscpp
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"uha%d: Can't malloc MSCP\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
goto|goto
name|gottit
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|uha
operator|->
name|free_mscp
argument_list|,
name|PRIBIO
argument_list|,
literal|"uhamscp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mscpp
condition|)
block|{
comment|/* Get MSCP from from free list */
name|uha
operator|->
name|free_mscp
operator|=
name|mscpp
operator|->
name|next
expr_stmt|;
name|mscpp
operator|->
name|flags
operator|=
name|MSCP_ACTIVE
expr_stmt|;
block|}
name|gottit
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|mscpp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * given a physical address, find the mscp that it corresponds to.  */
end_comment

begin_function
specifier|static
name|struct
name|mscp
modifier|*
name|uha_mscp_phys_kv
parameter_list|(
name|uha
parameter_list|,
name|mscp_phys
parameter_list|)
name|struct
name|uha_data
modifier|*
name|uha
decl_stmt|;
name|long
name|int
name|mscp_phys
decl_stmt|;
block|{
name|int
name|hashnum
init|=
name|MSCP_HASH
argument_list|(
name|mscp_phys
argument_list|)
decl_stmt|;
name|struct
name|mscp
modifier|*
name|mscpp
init|=
name|uha
operator|->
name|mscphash
index|[
name|hashnum
index|]
decl_stmt|;
while|while
condition|(
name|mscpp
condition|)
block|{
if|if
condition|(
name|mscpp
operator|->
name|hashkey
operator|==
name|mscp_phys
condition|)
break|break;
name|mscpp
operator|=
name|mscpp
operator|->
name|nexthash
expr_stmt|;
block|}
return|return
name|mscpp
return|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|uha_init
parameter_list|(
name|uha
parameter_list|)
name|struct
name|uha_data
modifier|*
name|uha
decl_stmt|;
block|{
specifier|volatile
name|unsigned
name|char
name|model
decl_stmt|;
specifier|volatile
name|unsigned
name|char
name|submodel
decl_stmt|;
name|unsigned
name|char
name|config_reg1
decl_stmt|;
name|unsigned
name|char
name|config_reg2
decl_stmt|;
name|unsigned
name|char
name|dma_ch
decl_stmt|;
name|unsigned
name|char
name|irq_ch
decl_stmt|;
name|unsigned
name|char
name|uha_id
decl_stmt|;
name|int
name|port
init|=
name|uha
operator|->
name|baseport
decl_stmt|;
name|int
name|resetcount
init|=
literal|4000
decl_stmt|;
comment|/* 4 secs? */
name|struct
name|uha_reg
modifier|*
name|ur
init|=
name|uha
operator|->
name|ur
decl_stmt|;
name|struct
name|uha_bits
modifier|*
name|ub
init|=
name|uha
operator|->
name|ub
decl_stmt|;
comment|/* 	 *  Prepare to use a 14/34F. 	 */
name|ur
operator|->
name|id
operator|=
name|port
operator|+
literal|0x04
expr_stmt|;
name|ur
operator|->
name|type
operator|=
name|port
operator|+
literal|0x00
expr_stmt|;
comment|/* 24F only */
name|ur
operator|->
name|ectl
operator|=
name|port
operator|+
literal|0x00
expr_stmt|;
comment|/* 24F only */
name|ur
operator|->
name|config
operator|=
name|port
operator|+
literal|0x06
expr_stmt|;
comment|/* 0-1 for 14F */
name|ur
operator|->
name|lmask
operator|=
name|port
operator|+
literal|0x00
expr_stmt|;
name|ur
operator|->
name|lint
operator|=
name|port
operator|+
literal|0x01
expr_stmt|;
name|ur
operator|->
name|smask
operator|=
name|port
operator|+
literal|0x02
expr_stmt|;
name|ur
operator|->
name|sint
operator|=
name|port
operator|+
literal|0x03
expr_stmt|;
name|ur
operator|->
name|ogmcmd
operator|=
name|port
operator|+
literal|0x00
expr_stmt|;
comment|/* 24F only */
name|ur
operator|->
name|ogmptr
operator|=
name|port
operator|+
literal|0x08
expr_stmt|;
name|ur
operator|->
name|icmcmd
operator|=
name|port
operator|+
literal|0x00
expr_stmt|;
comment|/* 24F only */
name|ur
operator|->
name|icmptr
operator|=
name|port
operator|+
literal|0x0c
expr_stmt|;
name|ub
operator|->
name|ldip
operator|=
name|UHA_LDIP
expr_stmt|;
name|ub
operator|->
name|adrst
operator|=
name|UHA_ADRST
expr_stmt|;
name|ub
operator|->
name|sbrst
operator|=
name|UHA_SBRST
expr_stmt|;
name|ub
operator|->
name|asrst
operator|=
name|UHA_ASRST
expr_stmt|;
name|ub
operator|->
name|abort
operator|=
name|UHA_ABORT
expr_stmt|;
name|ub
operator|->
name|ogmint
operator|=
name|UHA_OGMINT
expr_stmt|;
name|ub
operator|->
name|sintp
operator|=
name|UHA_SINTP
expr_stmt|;
name|ub
operator|->
name|abort_succ
operator|=
name|UHA_ABORT_SUCC
expr_stmt|;
name|ub
operator|->
name|abort_fail
operator|=
name|UHA_ABORT_FAIL
expr_stmt|;
name|ub
operator|->
name|abort_ack
operator|=
name|UHA_ABORT_ACK
expr_stmt|;
name|ub
operator|->
name|icm_ack
operator|=
name|UHA_ICM_ACK
expr_stmt|;
name|model
operator|=
name|inb
argument_list|(
name|ur
operator|->
name|id
argument_list|)
expr_stmt|;
name|submodel
operator|=
name|inb
argument_list|(
name|ur
operator|->
name|id
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|model
operator|!=
literal|0x56
operator|)
operator|&
operator|(
name|submodel
operator|!=
literal|0x40
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|printf
argument_list|(
literal|"uha%d: reading board settings, "
argument_list|,
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
name|config_reg1
operator|=
name|inb
argument_list|(
name|ur
operator|->
name|config
argument_list|)
expr_stmt|;
name|config_reg2
operator|=
name|inb
argument_list|(
name|ur
operator|->
name|config
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dma_ch
operator|=
operator|(
name|config_reg1
operator|&
literal|0xc0
operator|)
expr_stmt|;
name|irq_ch
operator|=
operator|(
name|config_reg1
operator|&
literal|0x30
operator|)
expr_stmt|;
name|uha_id
operator|=
operator|(
name|config_reg2
operator|&
literal|0x07
operator|)
expr_stmt|;
switch|switch
condition|(
name|dma_ch
condition|)
block|{
case|case
name|UHA_DMA_CH5
case|:
name|uha
operator|->
name|dma
operator|=
literal|5
expr_stmt|;
name|printf
argument_list|(
literal|"dma=5 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHA_DMA_CH6
case|:
name|uha
operator|->
name|dma
operator|=
literal|6
expr_stmt|;
name|printf
argument_list|(
literal|"dma=6 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHA_DMA_CH7
case|:
name|uha
operator|->
name|dma
operator|=
literal|7
expr_stmt|;
name|printf
argument_list|(
literal|"dma=7 "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"illegal dma jumper setting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
switch|switch
condition|(
name|irq_ch
condition|)
block|{
case|case
name|UHA_IRQ10
case|:
name|uha
operator|->
name|vect
operator|=
literal|10
expr_stmt|;
name|printf
argument_list|(
literal|"int=10 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHA_IRQ11
case|:
name|uha
operator|->
name|vect
operator|=
literal|11
expr_stmt|;
name|printf
argument_list|(
literal|"int=11 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHA_IRQ14
case|:
name|uha
operator|->
name|vect
operator|=
literal|14
expr_stmt|;
name|printf
argument_list|(
literal|"int=14 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHA_IRQ15
case|:
name|uha
operator|->
name|vect
operator|=
literal|15
expr_stmt|;
name|printf
argument_list|(
literal|"int=15 "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"illegal int jumper setting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* who are we on the scsi bus */
name|printf
argument_list|(
literal|"id=%x\n"
argument_list|,
name|uha_id
argument_list|)
expr_stmt|;
name|uha
operator|->
name|our_id
operator|=
name|uha_id
expr_stmt|;
comment|/* 	 * Note that we are going and return (to probe) 	 */
name|outb
argument_list|(
name|ur
operator|->
name|lint
argument_list|,
name|ub
operator|->
name|asrst
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|resetcount
condition|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|ur
operator|->
name|lint
argument_list|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 1 mSec per loop */
block|}
if|if
condition|(
name|resetcount
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: board timed out during reset\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|outb
argument_list|(
name|ur
operator|->
name|smask
argument_list|,
literal|0x81
argument_list|)
expr_stmt|;
comment|/* make sure interrupts are enabled */
name|uha
operator|->
name|flags
operator||=
name|UHA_INIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Initialize an Ultrastor 24F  */
end_comment

begin_function
name|int
name|uha24_init
parameter_list|(
name|uha
parameter_list|)
name|struct
name|uha_data
modifier|*
name|uha
decl_stmt|;
block|{
name|unsigned
name|char
name|p0
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|,
name|p3
decl_stmt|,
name|p5
decl_stmt|,
name|p7
decl_stmt|;
name|unsigned
name|char
name|id
index|[
literal|7
index|]
decl_stmt|,
name|rev
decl_stmt|,
name|haid
decl_stmt|;
name|int
name|port
init|=
literal|0
decl_stmt|,
name|irq
decl_stmt|;
name|int
name|resetcount
init|=
literal|4000
decl_stmt|;
name|struct
name|uha_reg
modifier|*
name|ur
init|=
name|uha
operator|->
name|ur
decl_stmt|;
name|struct
name|uha_bits
modifier|*
name|ub
init|=
name|uha
operator|->
name|ub
decl_stmt|;
comment|/* Search for the 24F's product ID */
name|uha_slot
operator|++
expr_stmt|;
while|while
condition|(
name|uha_slot
operator|<
name|EISA_MAX_SLOTS
condition|)
block|{
comment|/* 	 *  Prepare to use a 24F. 	 */
name|port
operator|=
name|EISA_CONFIG
operator||
operator|(
name|uha_slot
operator|<<
literal|12
operator|)
expr_stmt|;
name|ur
operator|->
name|id
operator|=
name|port
operator|+
literal|0x00
expr_stmt|;
name|ur
operator|->
name|type
operator|=
name|port
operator|+
literal|0x02
expr_stmt|;
name|ur
operator|->
name|ectl
operator|=
name|port
operator|+
literal|0x04
expr_stmt|;
name|ur
operator|->
name|config
operator|=
name|port
operator|+
literal|0x05
expr_stmt|;
comment|/* 0-2 for 24F */
name|ur
operator|->
name|lmask
operator|=
name|port
operator|+
literal|0x0c
expr_stmt|;
name|ur
operator|->
name|lint
operator|=
name|port
operator|+
literal|0x0d
expr_stmt|;
name|ur
operator|->
name|smask
operator|=
name|port
operator|+
literal|0x0e
expr_stmt|;
name|ur
operator|->
name|sint
operator|=
name|port
operator|+
literal|0x0f
expr_stmt|;
name|ur
operator|->
name|ogmcmd
operator|=
name|port
operator|+
literal|0x16
expr_stmt|;
name|ur
operator|->
name|ogmptr
operator|=
name|port
operator|+
literal|0x17
expr_stmt|;
name|ur
operator|->
name|icmcmd
operator|=
name|port
operator|+
literal|0x1b
expr_stmt|;
name|ur
operator|->
name|icmptr
operator|=
name|port
operator|+
literal|0x1c
expr_stmt|;
name|ub
operator|->
name|ldip
operator|=
name|U24_LDIP
expr_stmt|;
name|ub
operator|->
name|adrst
operator|=
name|U24_ADRST
expr_stmt|;
name|ub
operator|->
name|sbrst
operator|=
name|U24_SBRST
expr_stmt|;
name|ub
operator|->
name|asrst
operator|=
name|U24_ASRST
expr_stmt|;
name|ub
operator|->
name|abort
operator|=
name|U24_ABORT
expr_stmt|;
name|ub
operator|->
name|ogmint
operator|=
name|U24_OGMINT
expr_stmt|;
name|ub
operator|->
name|sintp
operator|=
name|U24_SINTP
expr_stmt|;
name|ub
operator|->
name|abort_succ
operator|=
name|U24_ABORT_SUCC
expr_stmt|;
name|ub
operator|->
name|abort_fail
operator|=
name|U24_ABORT_FAIL
expr_stmt|;
name|ub
operator|->
name|abort_ack
operator|=
name|U24_ABORT_ACK
expr_stmt|;
name|ub
operator|->
name|icm_ack
operator|=
name|U24_ICM_ACK
expr_stmt|;
comment|/* 	 * Make sure an EISA card is installed in this slot, 	 * and if it is make sure that the card is enabled. 	 */
name|outb
argument_list|(
name|ur
operator|->
name|id
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|p0
operator|=
name|inb
argument_list|(
name|ur
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p0
operator|==
literal|0xff
operator|)
operator|||
operator|(
operator|(
name|p0
operator|&
literal|0x80
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|inb
argument_list|(
name|ur
operator|->
name|ectl
argument_list|)
operator|&
name|EISA_DISABLE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|uha_slot
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Found an enabled card.  Grab the product ID. */
name|p1
operator|=
name|inb
argument_list|(
name|ur
operator|->
name|id
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p2
operator|=
name|inb
argument_list|(
name|ur
operator|->
name|type
argument_list|)
expr_stmt|;
name|p3
operator|=
name|inb
argument_list|(
name|ur
operator|->
name|type
operator|+
literal|1
argument_list|)
expr_stmt|;
name|id
index|[
literal|0
index|]
operator|=
literal|0x40
operator|+
operator|(
operator|(
name|p0
operator|>>
literal|2
operator|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|id
index|[
literal|1
index|]
operator|=
literal|0x40
operator|+
operator|(
operator|(
operator|(
name|p0
operator|&
literal|0x03
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|p1
operator|>>
literal|5
operator|)
operator|&
literal|0x07
operator|)
operator|)
expr_stmt|;
name|id
index|[
literal|2
index|]
operator|=
literal|0x40
operator|+
operator|(
name|p1
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|id
index|[
literal|3
index|]
operator|=
name|hex2ascii
argument_list|(
operator|(
name|p2
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|id
index|[
literal|4
index|]
operator|=
name|hex2ascii
argument_list|(
name|p2
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|id
index|[
literal|5
index|]
operator|=
name|hex2ascii
argument_list|(
operator|(
name|p3
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|id
index|[
literal|6
index|]
operator|=
literal|'\0'
expr_stmt|;
name|rev
operator|=
name|p3
operator|&
literal|0xf
expr_stmt|;
comment|/* We only want the 24F product ID. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|id
argument_list|,
literal|"USC024"
argument_list|)
condition|)
break|break;
name|uha_slot
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|uha_slot
operator|==
name|EISA_MAX_SLOTS
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* We have the card!  Grab remaining config. */
name|p5
operator|=
name|inb
argument_list|(
name|ur
operator|->
name|config
argument_list|)
expr_stmt|;
name|p7
operator|=
name|inb
argument_list|(
name|ur
operator|->
name|config
operator|+
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p5
operator|&
literal|0xf0
condition|)
block|{
case|case
literal|0x10
case|:
name|irq
operator|=
literal|15
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
name|irq
operator|=
literal|14
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
name|irq
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|irq
operator|=
literal|10
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"uha%d: bad 24F irq\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|haid
operator|=
operator|(
name|p7
operator|&
literal|0x07
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"uha%d: UltraStor 24F int=%d id=%d\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|,
name|irq
argument_list|,
name|haid
argument_list|)
expr_stmt|;
comment|/* Issue SCSI and adapter reset */
name|outb
argument_list|(
name|ur
operator|->
name|lint
argument_list|,
name|ub
operator|->
name|asrst
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|resetcount
condition|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|ur
operator|->
name|lint
argument_list|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* 1 mSec per loop */
block|}
if|if
condition|(
name|resetcount
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: board timed out during reset\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|outb
argument_list|(
name|ur
operator|->
name|smask
argument_list|,
literal|0xc2
argument_list|)
expr_stmt|;
comment|/* make sure interrupts are enabled */
name|uha
operator|->
name|flags
operator||=
operator|(
name|UHA_INIT
operator||
name|UHA_24F
operator|)
expr_stmt|;
name|uha
operator|->
name|baseport
operator|=
name|port
expr_stmt|;
name|uha
operator|->
name|our_id
operator|=
name|haid
expr_stmt|;
name|uha
operator|->
name|vect
operator|=
name|irq
expr_stmt|;
name|uha
operator|->
name|dma
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(x< y ? x : y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* min */
end_comment

begin_function
name|void
name|uhaminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|UHA_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|UHA_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * start a scsi operation given the command and the data address.  Also  * needs the unit, target and lu.  */
end_comment

begin_function
specifier|static
name|int32_t
name|uha_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
name|struct
name|uha_dma_seg
modifier|*
name|sg
decl_stmt|;
name|int
name|seg
decl_stmt|;
comment|/* scatter gather seg being worked on */
name|int
name|thiskv
decl_stmt|;
name|unsigned
name|long
name|int
name|thisphys
decl_stmt|,
name|nextphys
decl_stmt|;
name|int
name|bytes_this_seg
decl_stmt|,
name|bytes_this_page
decl_stmt|,
name|datalen
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|uha_data
modifier|*
name|uha
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unsigned
name|long
name|int
name|templen
decl_stmt|;
name|uha
operator|=
operator|(
expr|struct
name|uha_data
operator|*
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|adapter_softc
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"uha_scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * get a mscp (mbox-out) to use. If the transfer 	 * is from a buf (possibly from interrupt time) 	 * then we can't allow it to sleep 	 */
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
name|flags
operator||=
operator|(
name|SCSI_NOSLEEP
operator|)
expr_stmt|;
comment|/* just to be sure */
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: Already done?"
argument_list|,
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: Not in use?"
argument_list|,
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|mscp
operator|=
name|uha_get_mscp
argument_list|(
name|uha
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
name|cheat
operator|=
name|mscp
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"start mscp(%p)\n"
operator|,
name|mscp
operator|)
argument_list|)
expr_stmt|;
name|mscp
operator|->
name|xs
operator|=
name|xs
expr_stmt|;
comment|/* 	 * Put all the arguments for the xfer in the mscp 	 */
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|mscp
operator|->
name|opcode
operator|=
literal|0x04
expr_stmt|;
name|mscp
operator|->
name|ca
operator|=
literal|0x01
expr_stmt|;
block|}
else|else
block|{
name|mscp
operator|->
name|opcode
operator|=
literal|0x02
expr_stmt|;
name|mscp
operator|->
name|ca
operator|=
literal|0x01
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_IN
condition|)
block|{
name|mscp
operator|->
name|xdir
operator|=
literal|0x01
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_OUT
condition|)
block|{
name|mscp
operator|->
name|xdir
operator|=
literal|0x02
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GOTTABEJOKING
if|if
condition|(
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|!=
literal|0
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|uha_free_mscp
argument_list|(
name|uha
argument_list|,
name|mscp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
endif|#
directive|endif
name|mscp
operator|->
name|dcn
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|chan
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|target
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|target
expr_stmt|;
name|mscp
operator|->
name|lun
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|lun
expr_stmt|;
name|mscp
operator|->
name|link
operator|.
name|addr
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|link
operator|.
name|addr
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|link
operator|.
name|addr
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|link
operator|.
name|addr
index|[
literal|3
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|link_id
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|cdblen
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
name|scratch
operator|=
name|KVTOPHYS
argument_list|(
operator|&
operator|(
name|mscp
operator|->
name|mscp_sense
operator|)
argument_list|)
expr_stmt|;
name|mscp
operator|->
name|sense
operator|.
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|scratch
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|sense
operator|.
name|addr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|sense
operator|.
name|addr
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|sense
operator|.
name|addr
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|senselen
operator|=
sizeof|sizeof
argument_list|(
name|mscp
operator|->
name|mscp_sense
argument_list|)
expr_stmt|;
name|mscp
operator|->
name|ha_status
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|targ_status
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|datalen
condition|)
block|{
comment|/* should use S/G only if not zero length */
name|scratch
operator|=
name|KVTOPHYS
argument_list|(
name|mscp
operator|->
name|uha_dma
argument_list|)
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|scratch
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|=
name|mscp
operator|->
name|uha_dma
expr_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
name|mscp
operator|->
name|sgth
operator|=
literal|0x01
expr_stmt|;
ifdef|#
directive|ifdef
name|TFS
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_UIO
condition|)
block|{
name|iovp
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iov
expr_stmt|;
name|datalen
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iovcnt
expr_stmt|;
name|xs
operator|->
name|datalen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|UHA_NSEG
operator|)
condition|)
block|{
name|scratch
operator|=
operator|(
name|unsigned
name|long
operator|)
name|iovp
operator|->
name|iov_base
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|scratch
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|xs
operator|->
name|datalen
operator|+=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|sg
operator|->
name|len
operator|.
name|len
operator|=
name|iovp
operator|->
name|iov_len
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"(0x%x@0x%x)"
operator|,
name|iovp
operator|->
name|iov_len
operator|,
name|iovp
operator|->
name|iov_base
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|iovp
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|datalen
operator|--
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/*TFS */
block|{
comment|/* 			 * Set up the scatter gather block 			 */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"%ld @%p:- "
operator|,
name|xs
operator|->
name|datalen
operator|,
name|xs
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|thiskv
operator|=
operator|(
name|int
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
name|templen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|UHA_NSEG
operator|)
condition|)
block|{
name|bytes_this_seg
operator|=
literal|0
expr_stmt|;
comment|/* put in the base address */
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|thisphys
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|thisphys
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|thisphys
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|thisphys
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"0x%lx"
operator|,
name|thisphys
operator|)
argument_list|)
expr_stmt|;
comment|/* do it at least once */
name|nextphys
operator|=
name|thisphys
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|thisphys
operator|==
name|nextphys
operator|)
condition|)
comment|/* 					 * This page is contiguous (physically) with 					 * the the last, just extend the length 					 */
block|{
comment|/* how far to the end of the page */
name|nextphys
operator|=
operator|(
name|thisphys
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
name|bytes_this_page
operator|=
name|nextphys
operator|-
name|thisphys
expr_stmt|;
comment|/**** or the data ****/
name|bytes_this_page
operator|=
name|min
argument_list|(
name|bytes_this_page
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|bytes_this_seg
operator|+=
name|bytes_this_page
expr_stmt|;
name|datalen
operator|-=
name|bytes_this_page
expr_stmt|;
comment|/* get more ready for the next page */
name|thiskv
operator|=
operator|(
name|thiskv
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * next page isn't contiguous, finish the seg 				 */
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"(0x%x)"
operator|,
name|bytes_this_seg
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|.
name|len
index|[
literal|0
index|]
operator|=
operator|(
name|bytes_this_seg
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|len
operator|.
name|len
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|bytes_this_seg
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|len
operator|.
name|len
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|bytes_this_seg
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|len
operator|.
name|len
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|bytes_this_seg
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|templen
operator|+=
name|bytes_this_seg
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
block|}
comment|/* end of iov/kv decision */
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|0
index|]
operator|=
operator|(
name|templen
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|templen
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|templen
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|templen
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|sg_num
operator|=
name|seg
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* there's still data, must have run out of segs! */
name|printf
argument_list|(
literal|"uha%d: uha_scsi_cmd, more than %d DMA segs\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|,
name|UHA_NSEG
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|uha_free_mscp
argument_list|(
name|uha
argument_list|,
name|mscp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* No data xfer, use non S/G values */
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|3
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|3
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|xdir
operator|=
literal|0x03
expr_stmt|;
name|mscp
operator|->
name|sgth
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|sg_num
operator|=
literal|0x00
expr_stmt|;
block|}
comment|/* 	 * Put the scsi command in the mscp and start it 	 */
name|bcopy
argument_list|(
name|xs
operator|->
name|cmd
argument_list|,
name|mscp
operator|->
name|cdb
argument_list|,
name|xs
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
comment|/* 	 * Usually return SUCCESSFULLY QUEUED 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|uha_send_mbox
argument_list|(
name|uha
argument_list|,
name|mscp
argument_list|)
expr_stmt|;
name|xs
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|uha_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|mscp
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_sent\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
comment|/* 	 * If we can't use interrupts, poll on completion 	 */
name|uha_send_mbox
argument_list|(
name|uha
argument_list|,
name|mscp
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_wait\n"
operator|)
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|uha_poll
argument_list|(
name|uha
argument_list|,
name|xs
operator|->
name|timeout
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"uha%d: cmd fail\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|uha_abort
argument_list|(
name|uha
argument_list|,
name|mscp
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: abort failed in wait\n"
argument_list|,
name|uha
operator|->
name|unit
argument_list|)
expr_stmt|;
name|uha_free_mscp
argument_list|(
name|uha
argument_list|,
name|mscp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|)
do|;
comment|/* something (?) else finished */
if|if
condition|(
name|xs
operator|->
name|error
condition|)
block|{
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uha_timeout
parameter_list|(
name|arg1
parameter_list|)
name|void
modifier|*
name|arg1
decl_stmt|;
block|{
name|struct
name|mscp
modifier|*
name|mscp
init|=
operator|(
expr|struct
name|mscp
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|uha_data
modifier|*
name|uha
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|uha
operator|=
operator|(
expr|struct
name|uha_data
operator|*
operator|)
name|mscp
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|adapter_softc
expr_stmt|;
name|printf
argument_list|(
literal|"uha%d:%d:%d (%s%d) timed out "
argument_list|,
name|uha
operator|->
name|unit
argument_list|,
name|mscp
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|mscp
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|mscp
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|mscp
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|dev_unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UHADEBUG
name|uha_print_active_mscp
argument_list|(
name|uha
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*UHADEBUG */
if|if
condition|(
operator|(
name|uha_abort
argument_list|(
name|uha
argument_list|,
name|mscp
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|mscp
operator|->
name|flags
operator|=
name|MSCP_ABORTED
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"AGAIN"
argument_list|)
expr_stmt|;
name|mscp
operator|->
name|xs
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* I MEAN IT ! */
name|uha_done
argument_list|(
name|uha
argument_list|,
name|mscp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort the operation that has timed out */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|mscp
operator|->
name|xs
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|uha_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|mscp
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|mscp
operator|->
name|flags
operator|=
name|MSCP_ABORTED
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UHADEBUG
end_ifdef

begin_function
name|void
name|uha_print_mscp
parameter_list|(
name|mscp
parameter_list|)
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"mscp:%x op:%x cmdlen:%d senlen:%d\n"
argument_list|,
name|mscp
argument_list|,
name|mscp
operator|->
name|opcode
argument_list|,
name|mscp
operator|->
name|cdblen
argument_list|,
name|mscp
operator|->
name|senselen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	sg:%d sgnum:%x datlen:%d hstat:%x tstat:%x flags:%x\n"
argument_list|,
name|mscp
operator|->
name|sgth
argument_list|,
name|mscp
operator|->
name|sg_num
argument_list|,
name|mscp
operator|->
name|datalen
argument_list|,
name|mscp
operator|->
name|ha_status
argument_list|,
name|mscp
operator|->
name|targ_status
argument_list|,
name|mscp
operator|->
name|flags
argument_list|)
expr_stmt|;
name|show_scsi_cmd
argument_list|(
name|mscp
operator|->
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|uha_print_active_mscp
parameter_list|(
name|struct
name|uha_data
modifier|*
name|uha
parameter_list|)
block|{
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|MSCP_HASH_SIZE
condition|)
block|{
name|mscp
operator|=
name|uha
operator|->
name|mscphash
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|mscp
condition|)
block|{
if|if
condition|(
name|mscp
operator|->
name|flags
operator|!=
name|MSCP_FREE
condition|)
block|{
name|uha_print_mscp
argument_list|(
name|mscp
argument_list|)
expr_stmt|;
block|}
name|mscp
operator|=
name|mscp
operator|->
name|nexthash
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*UHADEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*KERNEL */
end_comment

end_unit

