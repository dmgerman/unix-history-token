begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Ported for use with the UltraStor 14f by Gary Close (gclose@wvnvms.wvnet.edu)  * Thanks to Julian Elischer for advice and help with this port.  *  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         1       00098  * --------------------         -----   ----------------------  *  * 16 Feb 93	Julian Elischer		ADDED for SCSI system  * commenced: Sun Sep 27 18:14:01 PDT 1992  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<uha.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MACH
end_ifdef

begin_comment
comment|/* EITHER CMU OR OSF */
end_comment

begin_include
include|#
directive|include
file|<i386/ipl.h>
end_include

begin_include
include|#
directive|include
file|<i386at/scsi.h>
end_include

begin_include
include|#
directive|include
file|<i386at/scsiconf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|OSF
end_ifdef

begin_comment
comment|/* OSF ONLY */
end_comment

begin_include
include|#
directive|include
file|<sys/table.h>
end_include

begin_include
include|#
directive|include
file|<i386/handler.h>
end_include

begin_include
include|#
directive|include
file|<i386/dispatcher.h>
end_include

begin_include
include|#
directive|include
file|<i386/AT386/atbus.h>
end_include

begin_else
else|#
directive|else
else|OSF
end_else

begin_comment
comment|/* CMU ONLY */
end_comment

begin_include
include|#
directive|include
file|<i386at/atbus.h>
end_include

begin_include
include|#
directive|include
file|<i386/pio.h>
end_include

begin_endif
endif|#
directive|endif
endif|OSF
end_endif

begin_endif
endif|#
directive|endif
endif|MACH
end_endif

begin_comment
comment|/* end of MACH specific */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__386BSD__
end_ifdef

begin_comment
comment|/* 386BSD specific */
end_comment

begin_define
define|#
directive|define
name|isa_dev
value|isa_device
end_define

begin_define
define|#
directive|define
name|dev_unit
value|id_unit
end_define

begin_define
define|#
directive|define
name|dev_addr
value|id_iobase
end_define

begin_include
include|#
directive|include
file|<i386/include/pio.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_endif
endif|#
directive|endif
endif|__386BSD__
end_endif

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__386BSD__
end_ifdef

begin_include
include|#
directive|include
file|"ddb.h"
end_include

begin_if
if|#
directive|if
name|NDDB
operator|>
literal|0
end_if

begin_function_decl
name|int
name|Debugger
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
else|NDDB
end_else

begin_define
define|#
directive|define
name|Debugger
parameter_list|()
value|panic("should call debugger here")
end_define

begin_endif
endif|#
directive|endif
endif|NDDB
end_endif

begin_endif
endif|#
directive|endif
endif|__386BSD__
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MACH
end_ifdef

begin_function_decl
name|int
name|Debugger
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|MACH
end_endif

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|addr
index|[
literal|4
index|]
decl_stmt|;
block|}
name|physaddr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|len
index|[
literal|4
index|]
decl_stmt|;
block|}
name|physlen
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|MACH
end_ifdef

begin_function_decl
specifier|extern
name|physaddr
name|kvtophys
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PHYSTOKV
parameter_list|(
name|x
parameter_list|)
value|phystokv(x)
end_define

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|kvtophys(x)
end_define

begin_endif
endif|#
directive|endif
endif|MACH
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__386BSD__
end_ifdef

begin_define
define|#
directive|define
name|PHYSTOKV
parameter_list|(
name|x
parameter_list|)
value|(x | 0xFE000000)
end_define

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_endif
endif|#
directive|endif
endif|__386BSD__
end_endif

begin_decl_stmt
specifier|extern
name|int
name|delaycount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from clock setup code */
end_comment

begin_define
define|#
directive|define
name|NUM_CONCURRENT
value|16
end_define

begin_comment
comment|/* number of concurrent ops per board */
end_comment

begin_define
define|#
directive|define
name|UHA_NSEG
value|33
end_define

begin_comment
comment|/* number of dma segments supported     */
end_comment

begin_define
define|#
directive|define
name|FUDGE
parameter_list|(
name|X
parameter_list|)
value|(X>>1)
end_define

begin_comment
comment|/* our loops are slower than spinwait() */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/************************** board definitions *******************************/
end_comment

begin_comment
comment|/*  * I/O Port Interface */
end_comment

begin_define
define|#
directive|define
name|UHA_LMASK
value|(0x000)
end_define

begin_comment
comment|/* local doorbell mask reg */
end_comment

begin_define
define|#
directive|define
name|UHA_LINT
value|(0x001)
end_define

begin_comment
comment|/* local doorbell int/stat reg */
end_comment

begin_define
define|#
directive|define
name|UHA_SMASK
value|(0x002)
end_define

begin_comment
comment|/* system doorbell mask reg */
end_comment

begin_define
define|#
directive|define
name|UHA_SINT
value|(0x003)
end_define

begin_comment
comment|/* system doorbell int/stat reg */
end_comment

begin_define
define|#
directive|define
name|UHA_ID0
value|(0x004)
end_define

begin_comment
comment|/* product id reg 0 */
end_comment

begin_define
define|#
directive|define
name|UHA_ID1
value|(0x005)
end_define

begin_comment
comment|/* product id reg 1 */
end_comment

begin_define
define|#
directive|define
name|UHA_CONF1
value|(0x006)
end_define

begin_comment
comment|/* config reg 1 */
end_comment

begin_define
define|#
directive|define
name|UHA_CONF2
value|(0x007)
end_define

begin_comment
comment|/* config reg 2 */
end_comment

begin_define
define|#
directive|define
name|UHA_OGM0
value|(0x008)
end_define

begin_comment
comment|/* outgoing mail ptr 0 least sig */
end_comment

begin_define
define|#
directive|define
name|UHA_OGM1
value|(0x009)
end_define

begin_comment
comment|/* outgoing mail ptr 1 least mid */
end_comment

begin_define
define|#
directive|define
name|UHA_OGM2
value|(0x00a)
end_define

begin_comment
comment|/* outgoing mail ptr 2 most mid  */
end_comment

begin_define
define|#
directive|define
name|UHA_OGM3
value|(0x00b)
end_define

begin_comment
comment|/* outgoing mail ptr 3 most sig  */
end_comment

begin_define
define|#
directive|define
name|UHA_ICM0
value|(0x00c)
end_define

begin_comment
comment|/* incoming mail ptr 0 */
end_comment

begin_define
define|#
directive|define
name|UHA_ICM1
value|(0x00d)
end_define

begin_comment
comment|/* incoming mail ptr 1 */
end_comment

begin_define
define|#
directive|define
name|UHA_ICM2
value|(0x00e)
end_define

begin_comment
comment|/* incoming mail ptr 2 */
end_comment

begin_define
define|#
directive|define
name|UHA_ICM3
value|(0x00f)
end_define

begin_comment
comment|/* incoming mail ptr 3 */
end_comment

begin_comment
comment|/* * UHA_LMASK bits (read only)  */
end_comment

begin_define
define|#
directive|define
name|UHA_LDIE
value|0x80
end_define

begin_comment
comment|/* local doorbell int enabled */
end_comment

begin_define
define|#
directive|define
name|UHA_SRSTE
value|0x40
end_define

begin_comment
comment|/* soft reset enabled */
end_comment

begin_define
define|#
directive|define
name|UHA_ABORTEN
value|0x10
end_define

begin_comment
comment|/* abort MSCP enabled */
end_comment

begin_define
define|#
directive|define
name|UHA_OGMINTEN
value|0x01
end_define

begin_comment
comment|/* outgoing mail interrupt enabled */
end_comment

begin_comment
comment|/* * UHA_LINT bits (read) */
end_comment

begin_define
define|#
directive|define
name|UHA_LDIP
value|0x80
end_define

begin_comment
comment|/* local doorbell int pending */
end_comment

begin_comment
comment|/* * UHA_LINT bits (write) */
end_comment

begin_define
define|#
directive|define
name|UHA_ADRST
value|0x40
end_define

begin_comment
comment|/* adapter soft reset */
end_comment

begin_define
define|#
directive|define
name|UHA_SBRST
value|0x20
end_define

begin_comment
comment|/* scsi bus reset */
end_comment

begin_define
define|#
directive|define
name|UHA_ASRST
value|0x60
end_define

begin_comment
comment|/* adapter and scsi reset */
end_comment

begin_define
define|#
directive|define
name|UHA_ABORT
value|0x10
end_define

begin_comment
comment|/* abort MSCP */
end_comment

begin_define
define|#
directive|define
name|UHA_OGMINT
value|0x01
end_define

begin_comment
comment|/* tell adapter to get mail */
end_comment

begin_comment
comment|/* * UHA_SMASK bits (read) */
end_comment

begin_define
define|#
directive|define
name|UHA_SINTEN
value|0x80
end_define

begin_comment
comment|/* system doorbell interupt Enabled */
end_comment

begin_define
define|#
directive|define
name|UHA_ABORT_COMPLETE_EN
value|0x10
end_define

begin_comment
comment|/* abort MSCP command complete int Enabled */
end_comment

begin_define
define|#
directive|define
name|UHA_ICM_ENABLED
value|0x01
end_define

begin_comment
comment|/* ICM interrupt enabled  /* * UHA_SMASK bits (write) */
end_comment

begin_define
define|#
directive|define
name|UHA_ENSINT
value|0x80
end_define

begin_comment
comment|/* enable system doorbell interrupt */
end_comment

begin_define
define|#
directive|define
name|UHA_EN_ABORT_COMPLETE
value|0x10
end_define

begin_comment
comment|/* enable abort MSCP complete int */
end_comment

begin_define
define|#
directive|define
name|UHA_ENICM
value|0x01
end_define

begin_comment
comment|/* enable ICM interrupt */
end_comment

begin_comment
comment|/* * UHA_SINT bits (read) */
end_comment

begin_define
define|#
directive|define
name|UHA_SINTP
value|0x80
end_define

begin_comment
comment|/* system doorbell int pending */
end_comment

begin_define
define|#
directive|define
name|UHA_ABORT_SUCC
value|0x10
end_define

begin_comment
comment|/* abort MSCP successful */
end_comment

begin_define
define|#
directive|define
name|UHA_ABORT_FAIL
value|0x18
end_define

begin_comment
comment|/* abort MSCP failed */
end_comment

begin_comment
comment|/* * UHA_SINT bits (write) */
end_comment

begin_define
define|#
directive|define
name|UHA_ABORT_ACK
value|0x18
end_define

begin_comment
comment|/* acknowledge status and clear */
end_comment

begin_define
define|#
directive|define
name|UHA_ICM_ACK
value|0x01
end_define

begin_comment
comment|/* acknowledge ICM and clear */
end_comment

begin_comment
comment|/*  * UHA_CONF1 bits (read only) */
end_comment

begin_define
define|#
directive|define
name|UHA_DMA_CH5
value|0x00
end_define

begin_comment
comment|/* DMA channel 5 */
end_comment

begin_define
define|#
directive|define
name|UHA_DMA_CH6
value|0x40
end_define

begin_comment
comment|/* 6 */
end_comment

begin_define
define|#
directive|define
name|UHA_DMA_CH7
value|0x80
end_define

begin_comment
comment|/* 7 */
end_comment

begin_define
define|#
directive|define
name|UHA_IRQ15
value|0x00
end_define

begin_comment
comment|/* IRQ 15 */
end_comment

begin_define
define|#
directive|define
name|UHA_IRQ14
value|0x10
end_define

begin_comment
comment|/* 14 */
end_comment

begin_define
define|#
directive|define
name|UHA_IRQ11
value|0x20
end_define

begin_comment
comment|/* 11 */
end_comment

begin_define
define|#
directive|define
name|UHA_IRQ10
value|0x30
end_define

begin_comment
comment|/* 10 */
end_comment

begin_comment
comment|/*********************************** * ha_status error codes \***********************************/
end_comment

begin_define
define|#
directive|define
name|UHA_NO_ERR
value|0x00
end_define

begin_comment
comment|/* No error supposedly */
end_comment

begin_define
define|#
directive|define
name|UHA_SBUS_ABORT_ERR
value|0x84
end_define

begin_comment
comment|/* scsi bus abort error */
end_comment

begin_define
define|#
directive|define
name|UHA_SBUS_TIMEOUT
value|0x91
end_define

begin_comment
comment|/* scsi bus selection timeout */
end_comment

begin_define
define|#
directive|define
name|UHA_SBUS_OVER_UNDER
value|0x92
end_define

begin_comment
comment|/* scsi bus over/underrun */
end_comment

begin_define
define|#
directive|define
name|UHA_BAD_SCSI_CMD
value|0x96
end_define

begin_comment
comment|/* illegal scsi command */
end_comment

begin_define
define|#
directive|define
name|UHA_AUTO_SENSE_ERR
value|0x9b
end_define

begin_comment
comment|/* auto request sense err */
end_comment

begin_define
define|#
directive|define
name|UHA_SBUS_RES_ERR
value|0xa3
end_define

begin_comment
comment|/* scsi bus reset error */
end_comment

begin_define
define|#
directive|define
name|UHA_BAD_SG_LIST
value|0xff
end_define

begin_comment
comment|/* invalid scatter gath list */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_struct
struct|struct
name|uha_dma_seg
block|{
name|physaddr
name|addr
decl_stmt|;
name|physlen
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*
comment|*/
end_comment

begin_struct
struct|struct
name|mscp
block|{
name|unsigned
name|char
name|opcode
range|:
literal|3
decl_stmt|;
define|#
directive|define
name|U14_HAC
value|0x01
comment|/*host adapter command*/
define|#
directive|define
name|U14_TSP
value|0x02
comment|/*target scsi pass through command*/
define|#
directive|define
name|U14_SDR
value|0x04
comment|/*scsi device reset*/
name|unsigned
name|char
name|xdir
range|:
literal|2
decl_stmt|;
comment|/*xfer direction*/
define|#
directive|define
name|U14_SDET
value|0x00
comment|/*determined by scsi command*/
define|#
directive|define
name|U14_SDIN
value|0x01
comment|/*scsi data in*/
define|#
directive|define
name|U14_SDOUT
value|0x02
comment|/*scsi data out*/
define|#
directive|define
name|U14_NODATA
value|0x03
comment|/*no data xfer*/
name|unsigned
name|char
name|dcn
range|:
literal|1
decl_stmt|;
comment|/*disable disconnect for this command*/
name|unsigned
name|char
name|ca
range|:
literal|1
decl_stmt|;
comment|/*Cache control*/
name|unsigned
name|char
name|sgth
range|:
literal|1
decl_stmt|;
comment|/*scatter gather flag*/
name|unsigned
name|char
name|target
range|:
literal|3
decl_stmt|;
name|unsigned
name|char
name|chan
range|:
literal|2
decl_stmt|;
comment|/*scsi channel (always 0 for 14f)*/
name|unsigned
name|char
name|lun
range|:
literal|3
decl_stmt|;
name|physaddr
name|data
decl_stmt|;
name|physlen
name|datalen
decl_stmt|;
name|physaddr
name|link
decl_stmt|;
name|unsigned
name|char
name|link_id
decl_stmt|;
name|unsigned
name|char
name|sg_num
decl_stmt|;
comment|/*number of scat gath segs */
comment|/*in s-g list if sg flag is*/
comment|/*set. starts at 1, 8bytes per*/
name|unsigned
name|char
name|senselen
decl_stmt|;
name|unsigned
name|char
name|cdblen
decl_stmt|;
name|unsigned
name|char
name|cdb
index|[
literal|12
index|]
decl_stmt|;
name|unsigned
name|char
name|ha_status
decl_stmt|;
name|unsigned
name|char
name|targ_status
decl_stmt|;
name|physaddr
name|sense
decl_stmt|;
comment|/* if 0 no auto sense */
comment|/*-----------------end of hardware supported fields----------------*/
name|struct
name|mscp
modifier|*
name|next
decl_stmt|;
comment|/* in free list */
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
comment|/* the scsi_xfer for this cmd */
name|long
name|int
name|delta
decl_stmt|;
comment|/* difference from previous*/
name|struct
name|mscp
modifier|*
name|later
decl_stmt|,
modifier|*
name|sooner
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|MSCP_FREE
value|0
define|#
directive|define
name|MSCP_ACTIVE
value|1
define|#
directive|define
name|MSCP_ABORTED
value|2
name|struct
name|uha_dma_seg
name|uha_dma
index|[
name|UHA_NSEG
index|]
decl_stmt|;
name|struct
name|scsi_sense_data
name|mscp_sense
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|uha_soonest
init|=
operator|(
expr|struct
name|mscp
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|uha_latest
init|=
operator|(
expr|struct
name|mscp
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|int
name|uha_furtherest
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* longest time in the timeout queue */
end_comment

begin_comment
comment|/*
comment|*/
end_comment

begin_struct
struct|struct
name|uha_data
block|{
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|UHA_INIT
value|0x01;
name|int
name|baseport
decl_stmt|;
name|struct
name|mscp
name|mscps
index|[
name|NUM_CONCURRENT
index|]
decl_stmt|;
name|struct
name|mscp
modifier|*
name|free_mscp
decl_stmt|;
name|int
name|our_id
decl_stmt|;
comment|/* our scsi id */
name|int
name|vect
decl_stmt|;
name|int
name|dma
decl_stmt|;
block|}
name|uha_data
index|[
name|NUHA
index|]
struct|;
end_struct

begin_function_decl
name|int
name|uhaprobe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|uha_attach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|uhaintr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|uha_scsi_cmd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|uha_timeout
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|uha_abort
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|cheat
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|uhaminphys
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|long
name|int
name|uha_adapter_info
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|unsigned
name|long
name|int
name|scratch
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MACH
end_ifdef

begin_decl_stmt
name|struct
name|isa_driver
name|uhadriver
init|=
block|{
name|uhaprobe
block|,
literal|0
block|,
name|uha_attach
block|,
literal|"uha"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|uhaintrs
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|uhaintr
operator|,
function_decl|0
end_function_decl

begin_endif
unit|};
endif|#
directive|endif
endif|MACH
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__386BSD__
end_ifdef

begin_decl_stmt
name|struct
name|isa_driver
name|uhadriver
init|=
block|{
name|uhaprobe
block|,
name|uha_attach
block|,
literal|"uha"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|__386BSD__
end_endif

begin_expr_stmt
specifier|static
name|uha_unit
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|uha_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UHA_SHOWMSCPS
value|0x01
end_define

begin_define
define|#
directive|define
name|UHA_SHOWINTS
value|0x02
end_define

begin_define
define|#
directive|define
name|UHA_SHOWCMDS
value|0x04
end_define

begin_define
define|#
directive|define
name|UHA_SHOWMISC
value|0x08
end_define

begin_define
define|#
directive|define
name|FAIL
value|1
end_define

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_decl_stmt
name|struct
name|scsi_switch
name|uha_switch
init|=
block|{
name|uha_scsi_cmd
block|,
name|uhaminphys
block|,
literal|0
block|,
literal|0
block|,
name|uha_adapter_info
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*
comment|*/
end_comment

begin_comment
comment|/***********************************************************************\ * Function to send a command out through a mailbox                      * \***********************************************************************/
end_comment

begin_macro
name|uha_send_mbox
argument_list|(
argument|int             unit
argument_list|,
argument|struct mscp     *mscp
argument_list|)
end_macro

begin_block
block|{
name|int
name|port
init|=
name|uha_data
index|[
name|unit
index|]
operator|.
name|baseport
decl_stmt|;
name|int
name|spincount
init|=
name|FUDGE
argument_list|(
name|delaycount
argument_list|)
operator|*
literal|1
decl_stmt|;
comment|/* 1ms should be enough */
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|UHA_LINT
argument_list|)
operator|&
operator|(
name|UHA_LDIP
operator|)
operator|)
operator|!=
operator|(
literal|0
operator|)
operator|)
operator|&&
operator|(
name|spincount
operator|--
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|spincount
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: board not responding\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|Debugger
argument_list|()
expr_stmt|;
block|}
name|outl
argument_list|(
name|port
operator|+
name|UHA_OGM0
argument_list|,
name|KVTOPHYS
argument_list|(
name|mscp
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|UHA_LINT
argument_list|,
operator|(
name|UHA_OGMINT
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***********************************************************************\ * Function to send abort to 14f                                         * \***********************************************************************/
end_comment

begin_macro
name|uha_abort
argument_list|(
argument|int		unit
argument_list|,
argument|struct mscp	*mscp
argument_list|)
end_macro

begin_block
block|{
name|int
name|port
init|=
name|uha_data
index|[
name|unit
index|]
operator|.
name|baseport
decl_stmt|;
name|int
name|spincount
init|=
name|FUDGE
argument_list|(
name|delaycount
argument_list|)
operator|*
literal|1
decl_stmt|;
name|int
name|abortcount
init|=
name|FUDGE
argument_list|(
name|delaycount
argument_list|)
operator|*
literal|2000
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
while|while
condition|(
operator|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|UHA_LINT
argument_list|)
operator|&
operator|(
name|UHA_LDIP
operator|)
operator|)
operator|!=
operator|(
literal|0
operator|)
operator|)
operator|&&
operator|(
name|spincount
operator|--
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|spincount
operator|==
operator|-
literal|1
condition|)
empty_stmt|;
block|{
name|printf
argument_list|(
literal|"uha%d: board not responding\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|Debugger
argument_list|()
expr_stmt|;
block|}
name|outl
argument_list|(
name|port
operator|+
name|UHA_OGM0
argument_list|,
name|KVTOPHYS
argument_list|(
name|mscp
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|UHA_LINT
argument_list|,
name|UHA_ABORT
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|abortcount
operator|--
operator|)
operator|&&
operator|(
operator|!
operator|(
name|inb
argument_list|(
name|port
operator|+
name|UHA_SINT
argument_list|)
operator|&
name|UHA_ABORT_FAIL
operator|)
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|abortcount
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: board not responding\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|Debugger
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|UHA_SINT
argument_list|)
operator|&
literal|0x10
operator|)
operator|!=
literal|0
condition|)
block|{
name|outb
argument_list|(
name|port
operator|+
name|UHA_SINT
argument_list|,
name|UHA_ABORT_ACK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|outb
argument_list|(
name|port
operator|+
name|UHA_SINT
argument_list|,
name|UHA_ABORT_ACK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_block

begin_comment
comment|/***********************************************************************\ * Function to poll for command completion when in poll mode             * \***********************************************************************/
end_comment

begin_macro
name|uha_poll
argument_list|(
argument|int unit
argument_list|,
argument|int wait
argument_list|)
end_macro

begin_comment
comment|/* in msec  */
end_comment

begin_block
block|{
name|int
name|port
init|=
name|uha_data
index|[
name|unit
index|]
operator|.
name|baseport
decl_stmt|;
name|int
name|spincount
init|=
name|FUDGE
argument_list|(
name|delaycount
argument_list|)
operator|*
name|wait
decl_stmt|;
comment|/* in msec */
name|int
name|stport
init|=
name|port
operator|+
name|UHA_SINT
decl_stmt|;
name|int
name|start
init|=
name|spincount
decl_stmt|;
name|retry
label|:
while|while
condition|(
operator|(
name|spincount
operator|--
operator|)
operator|&&
operator|(
operator|!
operator|(
name|inb
argument_list|(
name|stport
argument_list|)
operator|&
name|UHA_SINTP
operator|)
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|spincount
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: board not responding\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|cheat
operator|!=
name|PHYSTOKV
argument_list|(
name|inl
argument_list|(
name|port
operator|+
name|UHA_ICM0
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"discarding %x "
argument_list|,
name|inl
argument_list|(
name|port
operator|+
name|UHA_ICM0
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|UHA_SINT
argument_list|,
name|UHA_ICM_ACK
argument_list|)
expr_stmt|;
name|spinwait
argument_list|(
literal|50
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/* don't know this will work */
name|uhaintr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Check if the device can be found at the port given    * * and if so, set it up ready for further work           * * as an argument, takes the isa_dev structure from      * * autoconf.c                                            * \*******************************************************/
end_comment

begin_macro
name|uhaprobe
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_dev
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|uha_unit
decl_stmt|;
name|dev
operator|->
name|dev_unit
operator|=
name|unit
expr_stmt|;
name|uha_data
index|[
name|unit
index|]
operator|.
name|baseport
operator|=
name|dev
operator|->
name|dev_addr
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NUHA
condition|)
block|{
name|printf
argument_list|(
literal|"uha: unit number (%d) too high\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*try and initialize unit at this location*/
if|if
condition|(
name|uha_init
argument_list|(
name|unit
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* if its there put in it's interrupt and DRQ vectors */
name|dev
operator|->
name|id_irq
operator|=
operator|(
literal|1
operator|<<
name|uha_data
index|[
name|unit
index|]
operator|.
name|vect
operator|)
expr_stmt|;
name|dev
operator|->
name|id_drq
operator|=
name|uha_data
index|[
name|unit
index|]
operator|.
name|dma
expr_stmt|;
name|uha_unit
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/***********************************************\ * Attach all the sub-devices we can find        * \***********************************************/
end_comment

begin_macro
name|uha_attach
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_dev
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|dev_unit
decl_stmt|;
ifdef|#
directive|ifdef
name|__386BSD__
name|printf
argument_list|(
literal|" probing for scsi devices**\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|__386BSD__
comment|/***********************************************\ 	* ask the adapter what subunits are present     * 	\***********************************************/
name|scsi_attachdevs
argument_list|(
name|unit
argument_list|,
name|uha_data
index|[
name|unit
index|]
operator|.
name|our_id
argument_list|,
operator|&
name|uha_switch
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
name|uha_attached
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* defined(OSF) */
if|if
condition|(
operator|!
name|unit
condition|)
comment|/* only one for all boards */
block|{
name|uha_timeout
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__386BSD__
name|printf
argument_list|(
literal|"uha%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|__386BSD__
return|return;
block|}
end_block

begin_comment
comment|/***********************************************\ * Return some information to the caller about   * * the adapter and it's capabilities             * \***********************************************/
end_comment

begin_function
name|long
name|int
name|uha_adapter_info
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
return|return
operator|(
literal|2
operator|)
return|;
comment|/* 2 outstanding requests at a time per device */
block|}
end_function

begin_comment
comment|/***********************************************\ * Catch an interrupt from the adaptor           * \***********************************************/
end_comment

begin_macro
name|uhaintr
argument_list|(
argument|unit
argument_list|)
end_macro

begin_block
block|{
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
name|u_char
name|uhastat
decl_stmt|;
name|unsigned
name|long
name|int
name|mboxval
decl_stmt|;
name|int
name|port
init|=
name|uha_data
index|[
name|unit
index|]
operator|.
name|baseport
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"uhaintr "
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
if|if
condition|(
operator|!
name|uha_attached
index|[
name|unit
index|]
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* defined(OSF) */
while|while
condition|(
name|inb
argument_list|(
name|port
operator|+
name|UHA_SINT
argument_list|)
operator|&
name|UHA_SINTP
condition|)
block|{
comment|/***********************************************\ 		* First get all the information and then        * 		* acknowlege the interrupt                      * 		\***********************************************/
name|uhastat
operator|=
name|inb
argument_list|(
name|port
operator|+
name|UHA_SINT
argument_list|)
expr_stmt|;
name|mboxval
operator|=
name|inl
argument_list|(
name|port
operator|+
name|UHA_ICM0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|UHA_SINT
argument_list|,
name|UHA_ICM_ACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEINTERRUPTS
condition|)
name|printf
argument_list|(
literal|"status = 0x%x "
argument_list|,
name|uhastat
argument_list|)
expr_stmt|;
comment|/***********************************************\ 		* Process the completed operation               * 		\***********************************************/
name|mscp
operator|=
operator|(
expr|struct
name|mscp
operator|*
operator|)
operator|(
name|PHYSTOKV
argument_list|(
name|mboxval
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|uha_debug
operator|&
name|UHA_SHOWCMDS
condition|)
block|{
name|uha_show_scsi_cmd
argument_list|(
name|mscp
operator|->
name|xs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uha_debug
operator|&
name|UHA_SHOWMSCPS
operator|)
operator|&&
name|mscp
condition|)
name|printf
argument_list|(
literal|"<int mscp(%x)>"
argument_list|,
name|mscp
argument_list|)
expr_stmt|;
name|uha_remove_timeout
argument_list|(
name|mscp
argument_list|)
expr_stmt|;
name|uha_done
argument_list|(
name|unit
argument_list|,
name|mscp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/***********************************************\ * We have a mscp which has been processed by the * * adaptor, now we look to see how the operation * * went.                                         * \***********************************************/
end_comment

begin_macro
name|uha_done
argument_list|(
argument|unit
argument_list|,
argument|mscp
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_sense_data
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|mscp
operator|->
name|xs
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
operator|(
name|PRINTROUTINES
operator||
name|TRACEINTERRUPTS
operator|)
condition|)
name|printf
argument_list|(
literal|"uha_done "
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* Otherwise, put the results of the operation   * 	* into the xfer and call whoever started it     * 	\***********************************************/
if|if
condition|(
operator|(
name|mscp
operator|->
name|ha_status
operator|==
name|UHA_NO_ERR
operator|)
operator|||
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
condition|)
block|{
comment|/* All went correctly  OR errors expected */
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|s1
operator|=
operator|&
operator|(
name|mscp
operator|->
name|mscp_sense
operator|)
expr_stmt|;
name|s2
operator|=
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
if|if
condition|(
name|mscp
operator|->
name|ha_status
operator|!=
name|UHA_NO_ERR
condition|)
block|{
switch|switch
condition|(
name|mscp
operator|->
name|ha_status
condition|)
block|{
case|case
name|UHA_SBUS_TIMEOUT
case|:
comment|/* No response */
if|if
condition|(
name|uha_debug
operator|&
name|UHA_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"timeout reported back\n"
argument_list|)
expr_stmt|;
block|}
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
break|break;
case|case
name|UHA_SBUS_OVER_UNDER
case|:
if|if
condition|(
name|uha_debug
operator|&
name|UHA_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"scsi bus xfer over/underrun\n"
argument_list|)
expr_stmt|;
block|}
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
case|case
name|UHA_BAD_SG_LIST
case|:
if|if
condition|(
name|uha_debug
operator|&
name|UHA_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"bad sg list reported back\n"
argument_list|)
expr_stmt|;
block|}
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
default|default:
comment|/* Other scsi protocol messes */
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
if|if
condition|(
name|uha_debug
operator|&
name|UHA_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"unexpected ha_status: %x\n"
argument_list|,
name|mscp
operator|->
name|ha_status
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|mscp
operator|->
name|targ_status
operator|!=
literal|0
condition|)
comment|/**************************************************************************\ * I have no information for any possible value of target status field     * * other than 0 means no error!! So I guess any error is unexpected in that * * event!! 								   * \**************************************************************************/
block|{
if|if
condition|(
name|uha_debug
operator|&
name|UHA_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"unexpected targ_status: %x\n"
argument_list|,
name|mscp
operator|->
name|targ_status
argument_list|)
expr_stmt|;
block|}
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
block|}
block|}
block|}
name|done
label|:
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|uha_free_mscp
argument_list|(
name|unit
argument_list|,
name|mscp
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|when_done
condition|)
operator|(
operator|*
operator|(
name|xs
operator|->
name|when_done
operator|)
operator|)
operator|(
name|xs
operator|->
name|done_arg
operator|,
name|xs
operator|->
name|done_arg2
operator|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***********************************************\ * A mscp (and hence a mbx-out is put onto the    * * free list.                                    * \***********************************************/
end_comment

begin_macro
name|uha_free_mscp
argument_list|(
argument|unit
argument_list|,
argument|mscp
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|int
name|opri
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"mscp%d(0x%x)> "
argument_list|,
name|unit
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|mscp
operator|->
name|next
operator|=
name|uha_data
index|[
name|unit
index|]
operator|.
name|free_mscp
expr_stmt|;
name|uha_data
index|[
name|unit
index|]
operator|.
name|free_mscp
operator|=
name|mscp
expr_stmt|;
name|mscp
operator|->
name|flags
operator|=
name|MSCP_FREE
expr_stmt|;
comment|/***********************************************\ 	* If there were none, wake abybody waiting for  * 	* one to come free, starting with queued entries* 	\***********************************************/
if|if
condition|(
operator|!
name|mscp
operator|->
name|next
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|uha_data
index|[
name|unit
index|]
operator|.
name|free_mscp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/***********************************************\ * Get a free mscp (and hence mbox-out entry)     * \***********************************************/
end_comment

begin_function
name|struct
name|mscp
modifier|*
name|uha_get_mscp
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|)
block|{
name|unsigned
name|opri
decl_stmt|;
name|struct
name|mscp
modifier|*
name|rc
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"<mscp%d(0x%x) "
argument_list|,
name|unit
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/***********************************************\ 	* If we can and have to, sleep waiting for one  * 	* to come free                                  * 	\***********************************************/
while|while
condition|(
operator|(
operator|!
operator|(
name|rc
operator|=
name|uha_data
index|[
name|unit
index|]
operator|.
name|free_mscp
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
operator|)
condition|)
block|{
name|sleep
argument_list|(
operator|&
name|uha_data
index|[
name|unit
index|]
operator|.
name|free_mscp
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
condition|)
block|{
name|uha_data
index|[
name|unit
index|]
operator|.
name|free_mscp
operator|=
name|rc
operator|->
name|next
expr_stmt|;
name|rc
operator|->
name|flags
operator|=
name|MSCP_ACTIVE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************\ * Start the board, ready for normal operation   * \***********************************************/
end_comment

begin_macro
name|uha_init
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|char
name|ad
index|[
literal|4
index|]
decl_stmt|;
specifier|volatile
name|unsigned
name|char
name|model
decl_stmt|;
specifier|volatile
name|unsigned
name|char
name|submodel
decl_stmt|;
name|unsigned
name|char
name|config_reg1
decl_stmt|;
name|unsigned
name|char
name|config_reg2
decl_stmt|;
name|unsigned
name|char
name|dma_ch
decl_stmt|;
name|unsigned
name|char
name|irq_ch
decl_stmt|;
name|unsigned
name|char
name|uha_id
decl_stmt|;
name|int
name|port
init|=
name|uha_data
index|[
name|unit
index|]
operator|.
name|baseport
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|resetcount
init|=
name|FUDGE
argument_list|(
name|delaycount
argument_list|)
operator|*
literal|4000
decl_stmt|;
name|model
operator|=
name|inb
argument_list|(
name|port
operator|+
name|UHA_ID0
argument_list|)
expr_stmt|;
name|submodel
operator|=
name|inb
argument_list|(
name|port
operator|+
name|UHA_ID1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|model
operator|!=
literal|0x56
operator|)
operator|&
operator|(
name|submodel
operator|!=
literal|0x40
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ultrastor 14f not responding\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"uha%d reading board settings, "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|config_reg1
operator|=
name|inb
argument_list|(
name|port
operator|+
name|UHA_CONF1
argument_list|)
expr_stmt|;
name|config_reg2
operator|=
name|inb
argument_list|(
name|port
operator|+
name|UHA_CONF2
argument_list|)
expr_stmt|;
name|dma_ch
operator|=
operator|(
name|config_reg1
operator|&
literal|0xc0
operator|)
expr_stmt|;
name|irq_ch
operator|=
operator|(
name|config_reg1
operator|&
literal|0x30
operator|)
expr_stmt|;
name|uha_id
operator|=
operator|(
name|config_reg2
operator|&
literal|0x07
operator|)
expr_stmt|;
switch|switch
condition|(
name|dma_ch
condition|)
block|{
case|case
name|UHA_DMA_CH5
case|:
name|uha_data
index|[
name|unit
index|]
operator|.
name|dma
operator|=
literal|5
expr_stmt|;
name|printf
argument_list|(
literal|"dma=5 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHA_DMA_CH6
case|:
name|uha_data
index|[
name|unit
index|]
operator|.
name|dma
operator|=
literal|6
expr_stmt|;
name|printf
argument_list|(
literal|"dma=6 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHA_DMA_CH7
case|:
name|uha_data
index|[
name|unit
index|]
operator|.
name|dma
operator|=
literal|7
expr_stmt|;
name|printf
argument_list|(
literal|"dma=7 "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"illegal dma jumper setting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
switch|switch
condition|(
name|irq_ch
condition|)
block|{
case|case
name|UHA_IRQ10
case|:
name|uha_data
index|[
name|unit
index|]
operator|.
name|vect
operator|=
literal|10
expr_stmt|;
name|printf
argument_list|(
literal|"int=10 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHA_IRQ11
case|:
name|uha_data
index|[
name|unit
index|]
operator|.
name|vect
operator|=
literal|11
expr_stmt|;
name|printf
argument_list|(
literal|"int=11 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHA_IRQ14
case|:
name|uha_data
index|[
name|unit
index|]
operator|.
name|vect
operator|=
literal|14
expr_stmt|;
name|printf
argument_list|(
literal|"int=14 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|UHA_IRQ15
case|:
name|uha_data
index|[
name|unit
index|]
operator|.
name|vect
operator|=
literal|15
expr_stmt|;
name|printf
argument_list|(
literal|"int=15 "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"illegal int jumper setting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* who are we on the scsi bus */
name|printf
argument_list|(
literal|"id=%x\n"
argument_list|,
name|uha_id
argument_list|)
expr_stmt|;
name|uha_data
index|[
name|unit
index|]
operator|.
name|our_id
operator|=
name|uha_id
expr_stmt|;
comment|/***********************************************\ 	* link up all our MSCPs into a free list         * 	\***********************************************/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_CONCURRENT
condition|;
name|i
operator|++
control|)
block|{
name|uha_data
index|[
name|unit
index|]
operator|.
name|mscps
index|[
name|i
index|]
operator|.
name|next
operator|=
name|uha_data
index|[
name|unit
index|]
operator|.
name|free_mscp
expr_stmt|;
name|uha_data
index|[
name|unit
index|]
operator|.
name|free_mscp
operator|=
operator|&
name|uha_data
index|[
name|unit
index|]
operator|.
name|mscps
index|[
name|i
index|]
expr_stmt|;
name|uha_data
index|[
name|unit
index|]
operator|.
name|free_mscp
operator|->
name|flags
operator|=
name|MSCP_FREE
expr_stmt|;
block|}
comment|/***********************************************\ 	* Note that we are going and return (to probe)  * 	\***********************************************/
name|outb
argument_list|(
name|port
operator|+
name|UHA_LINT
argument_list|,
name|UHA_ASRST
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|resetcount
operator|--
operator|)
operator|&&
operator|(
operator|!
operator|(
name|inb
argument_list|(
name|port
operator|+
name|UHA_LINT
argument_list|)
operator|)
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|resetcount
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d: board timed out during reset\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|outb
argument_list|(
name|port
operator|+
name|UHA_SMASK
argument_list|,
literal|0x81
argument_list|)
expr_stmt|;
comment|/* make sure interrupts are enabled */
name|uha_data
index|[
name|unit
index|]
operator|.
name|flags
operator||=
name|UHA_INIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(x< y ? x : y)
end_define

begin_endif
endif|#
directive|endif
endif|min
end_endif

begin_function
name|void
name|uhaminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|MACH
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OSF
argument_list|)
name|bp
operator|->
name|b_flags
operator||=
name|B_NPAGES
expr_stmt|;
comment|/* can support scat/gather */
endif|#
directive|endif
comment|/* defined(OSF) */
endif|#
directive|endif
endif|MACH
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|UHA_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|UHA_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***********************************************\ * start a scsi operation given the command and  * * the data address. Also needs the unit, target * * and lu                                        * \***********************************************/
end_comment

begin_function
name|int
name|uha_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_sense_data
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
name|struct
name|uha_dma_seg
modifier|*
name|sg
decl_stmt|;
name|int
name|seg
decl_stmt|;
comment|/* scatter gather seg being worked on */
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|int
name|thiskv
decl_stmt|;
name|unsigned
name|long
name|int
name|thisphys
decl_stmt|,
name|nextphys
decl_stmt|;
name|int
name|unit
init|=
name|xs
operator|->
name|adapter
decl_stmt|;
name|int
name|bytes_this_seg
decl_stmt|,
name|bytes_this_page
decl_stmt|,
name|datalen
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|iovec
modifier|*
name|iovp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|unsigned
name|int
name|stat
decl_stmt|;
name|int
name|port
init|=
name|uha_data
index|[
name|unit
index|]
operator|.
name|baseport
decl_stmt|;
name|unsigned
name|long
name|int
name|templen
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"uha_scsi_cmd "
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* get a mscp (mbox-out) to use. If the transfer  * 	* is from a buf (possibly from interrupt time)  * 	* then we can't allow it to sleep               * 	\***********************************************/
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
name|flags
operator||=
operator|(
name|SCSI_NOSLEEP
operator|)
expr_stmt|;
comment|/* just to be sure */
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"Already done?"
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Not in use?"
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|mscp
operator|=
name|uha_get_mscp
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
name|cheat
operator|=
name|mscp
expr_stmt|;
if|if
condition|(
name|uha_debug
operator|&
name|UHA_SHOWMSCPS
condition|)
name|printf
argument_list|(
literal|"<start mscp(%x)>"
argument_list|,
name|mscp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWCOMMANDS
condition|)
block|{
name|uha_show_scsi_cmd
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
name|mscp
operator|->
name|xs
operator|=
name|xs
expr_stmt|;
comment|/***********************************************\ 	* Put all the arguments for the xfer in the mscp * 	\***********************************************/
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|mscp
operator|->
name|opcode
operator|=
literal|0x04
expr_stmt|;
name|mscp
operator|->
name|ca
operator|=
literal|0x01
expr_stmt|;
block|}
else|else
block|{
name|mscp
operator|->
name|opcode
operator|=
literal|0x02
expr_stmt|;
name|mscp
operator|->
name|ca
operator|=
literal|0x01
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_IN
condition|)
block|{
name|mscp
operator|->
name|xdir
operator|=
literal|0x01
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_OUT
condition|)
block|{
name|mscp
operator|->
name|xdir
operator|=
literal|0x02
expr_stmt|;
block|}
if|if
condition|(
name|xs
operator|->
name|lu
operator|!=
literal|0
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|uha_free_mscp
argument_list|(
name|unit
argument_list|,
name|mscp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
name|mscp
operator|->
name|dcn
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|chan
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|target
operator|=
name|xs
operator|->
name|targ
expr_stmt|;
name|mscp
operator|->
name|lun
operator|=
name|xs
operator|->
name|lu
expr_stmt|;
name|mscp
operator|->
name|link
operator|.
name|addr
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|link
operator|.
name|addr
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|link
operator|.
name|addr
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|link
operator|.
name|addr
index|[
literal|3
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|link_id
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|cdblen
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
name|scratch
operator|=
name|KVTOPHYS
argument_list|(
operator|&
operator|(
name|mscp
operator|->
name|mscp_sense
operator|)
argument_list|)
expr_stmt|;
name|mscp
operator|->
name|sense
operator|.
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|scratch
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|sense
operator|.
name|addr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|sense
operator|.
name|addr
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|sense
operator|.
name|addr
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|senselen
operator|=
sizeof|sizeof
argument_list|(
name|mscp
operator|->
name|mscp_sense
argument_list|)
expr_stmt|;
name|mscp
operator|->
name|ha_status
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|targ_status
operator|=
literal|0x00
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|datalen
condition|)
block|{
comment|/* should use S/G only if not zero length */
name|scratch
operator|=
name|KVTOPHYS
argument_list|(
name|mscp
operator|->
name|uha_dma
argument_list|)
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|scratch
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|=
name|mscp
operator|->
name|uha_dma
expr_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
name|mscp
operator|->
name|sgth
operator|=
literal|0x01
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_UIO
condition|)
block|{
name|iovp
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iov
expr_stmt|;
name|datalen
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iovcnt
expr_stmt|;
name|xs
operator|->
name|datalen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|UHA_NSEG
operator|)
condition|)
block|{
name|scratch
operator|=
operator|(
name|unsigned
name|long
operator|)
name|iovp
operator|->
name|iov_base
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|scratch
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|scratch
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|xs
operator|->
name|datalen
operator|+=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
name|sg
operator|->
name|len
operator|.
name|len
operator|=
name|iovp
operator|->
name|iov_len
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWSCATGATH
condition|)
name|printf
argument_list|(
literal|"(0x%x@0x%x)"
argument_list|,
name|iovp
operator|->
name|iov_len
argument_list|,
name|iovp
operator|->
name|iov_base
argument_list|)
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|iovp
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|datalen
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/***********************************************\ 			* Set up the scatter gather block               * 			\***********************************************/
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWSCATGATH
condition|)
name|printf
argument_list|(
literal|"%d @0x%x:- "
argument_list|,
name|xs
operator|->
name|datalen
argument_list|,
name|xs
operator|->
name|data
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|thiskv
operator|=
operator|(
name|int
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
name|templen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|UHA_NSEG
operator|)
condition|)
block|{
name|bytes_this_seg
operator|=
literal|0
expr_stmt|;
comment|/* put in the base address */
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|0
index|]
operator|=
operator|(
name|thisphys
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|thisphys
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|thisphys
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|addr
operator|.
name|addr
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|thisphys
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWSCATGATH
condition|)
name|printf
argument_list|(
literal|"0x%x"
argument_list|,
name|thisphys
argument_list|)
expr_stmt|;
comment|/* do it at least once */
name|nextphys
operator|=
name|thisphys
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|thisphys
operator|==
name|nextphys
operator|)
condition|)
comment|/*********************************************\ 				* This page is contiguous (physically) with   * 				* the the last, just extend the length        * 				\*********************************************/
block|{
comment|/* how far to the end of the page */
name|nextphys
operator|=
operator|(
name|thisphys
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
name|bytes_this_page
operator|=
name|nextphys
operator|-
name|thisphys
expr_stmt|;
comment|/**** or the data ****/
name|bytes_this_page
operator|=
name|min
argument_list|(
name|bytes_this_page
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|bytes_this_seg
operator|+=
name|bytes_this_page
expr_stmt|;
name|datalen
operator|-=
name|bytes_this_page
expr_stmt|;
comment|/* get more ready for the next page */
name|thiskv
operator|=
operator|(
name|thiskv
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
block|}
comment|/********************************************\ 				* next page isn't contiguous, finish the seg * 				\********************************************/
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWSCATGATH
condition|)
name|printf
argument_list|(
literal|"(0x%x)"
argument_list|,
name|bytes_this_seg
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|.
name|len
index|[
literal|0
index|]
operator|=
operator|(
name|bytes_this_seg
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|len
operator|.
name|len
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|bytes_this_seg
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|len
operator|.
name|len
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|bytes_this_seg
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|sg
operator|->
name|len
operator|.
name|len
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|bytes_this_seg
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|templen
operator|+=
name|bytes_this_seg
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
block|}
comment|/*end of iov/kv decision */
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|0
index|]
operator|=
operator|(
name|templen
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|templen
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|2
index|]
operator|=
operator|(
operator|(
name|templen
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|templen
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|mscp
operator|->
name|sg_num
operator|=
name|seg
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWSCATGATH
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* there's still data, must have run out of segs! */
name|printf
argument_list|(
literal|"uha_scsi_cmd%d: more than %d DMA segs\n"
argument_list|,
name|unit
argument_list|,
name|UHA_NSEG
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|uha_free_mscp
argument_list|(
name|unit
argument_list|,
name|mscp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* No data xfer, use non S/G values */
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|data
operator|.
name|addr
index|[
literal|3
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|0
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|1
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|2
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|datalen
operator|.
name|len
index|[
literal|3
index|]
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|xdir
operator|=
literal|0x03
expr_stmt|;
name|mscp
operator|->
name|sgth
operator|=
literal|0x00
expr_stmt|;
name|mscp
operator|->
name|sg_num
operator|=
literal|0x00
expr_stmt|;
block|}
comment|/***********************************************\ 	* Put the scsi command in the mscp and start it  * 	\***********************************************/
name|bcopy
argument_list|(
name|xs
operator|->
name|cmd
argument_list|,
name|mscp
operator|->
name|cdb
argument_list|,
name|xs
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
comment|/***********************************************\ 	* Usually return SUCCESSFULLY QUEUED            * 	\***********************************************/
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|uha_send_mbox
argument_list|(
name|unit
argument_list|,
name|mscp
argument_list|)
expr_stmt|;
name|uha_add_timeout
argument_list|(
name|mscp
argument_list|,
name|xs
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEINTERRUPTS
condition|)
name|printf
argument_list|(
literal|"cmd_sent "
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
comment|/***********************************************\ 	* If we can't use interrupts, poll on completion* 	\***********************************************/
name|uha_send_mbox
argument_list|(
name|unit
argument_list|,
name|mscp
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEINTERRUPTS
condition|)
name|printf
argument_list|(
literal|"cmd_wait "
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|uha_poll
argument_list|(
name|unit
argument_list|,
name|xs
operator|->
name|timeout
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"cmd fail\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|uha_abort
argument_list|(
name|unit
argument_list|,
name|mscp
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"abort failed in wait\n"
argument_list|)
expr_stmt|;
name|uha_free_mscp
argument_list|(
name|unit
argument_list|,
name|mscp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|)
do|;
comment|/* something (?) else finished */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|scsi_debug
operator|=
literal|0
expr_stmt|;
name|uha_debug
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|error
condition|)
block|{
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *                +----------+    +----------+    +----------+  * uha_soonest--->|    later |--->|     later|--->|     later|--->0  *                | [Delta]  |    | [Delta]  |    | [Delta]  |  *           0<---|sooner    |<---|sooner    |<---|sooner    |<---uha_latest  *                +----------+    +----------+    +----------+  *  *     uha_furtherest = sum(Delta[1..n])  */
end_comment

begin_macro
name|uha_add_timeout
argument_list|(
argument|mscp
argument_list|,
argument|time
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|time
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|timeprev
decl_stmt|;
name|struct
name|mscp
modifier|*
name|prev
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
name|prev
operator|=
name|uha_latest
condition|)
comment|/* yes, an assign */
block|{
name|timeprev
operator|=
name|uha_furtherest
expr_stmt|;
block|}
else|else
block|{
name|timeprev
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
name|prev
operator|&&
operator|(
name|timeprev
operator|>
name|time
operator|)
condition|)
block|{
name|timeprev
operator|-=
name|prev
operator|->
name|delta
expr_stmt|;
name|prev
operator|=
name|prev
operator|->
name|sooner
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|mscp
operator|->
name|delta
operator|=
name|time
operator|-
name|timeprev
expr_stmt|;
if|if
condition|(
name|mscp
operator|->
name|later
operator|=
name|prev
operator|->
name|later
condition|)
comment|/* yes an assign */
block|{
name|mscp
operator|->
name|later
operator|->
name|sooner
operator|=
name|mscp
expr_stmt|;
name|mscp
operator|->
name|later
operator|->
name|delta
operator|-=
name|mscp
operator|->
name|delta
expr_stmt|;
block|}
else|else
block|{
name|uha_furtherest
operator|=
name|time
expr_stmt|;
name|uha_latest
operator|=
name|mscp
expr_stmt|;
block|}
name|mscp
operator|->
name|sooner
operator|=
name|prev
expr_stmt|;
name|prev
operator|->
name|later
operator|=
name|mscp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mscp
operator|->
name|later
operator|=
name|uha_soonest
condition|)
comment|/* yes, an assign*/
block|{
name|mscp
operator|->
name|later
operator|->
name|sooner
operator|=
name|mscp
expr_stmt|;
name|mscp
operator|->
name|later
operator|->
name|delta
operator|-=
name|time
expr_stmt|;
block|}
else|else
block|{
name|uha_furtherest
operator|=
name|time
expr_stmt|;
name|uha_latest
operator|=
name|mscp
expr_stmt|;
block|}
name|mscp
operator|->
name|delta
operator|=
name|time
expr_stmt|;
name|mscp
operator|->
name|sooner
operator|=
operator|(
expr|struct
name|mscp
operator|*
operator|)
literal|0
expr_stmt|;
name|uha_soonest
operator|=
name|mscp
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|uha_remove_timeout
argument_list|(
argument|mscp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
name|mscp
operator|->
name|sooner
condition|)
block|{
name|mscp
operator|->
name|sooner
operator|->
name|later
operator|=
name|mscp
operator|->
name|later
expr_stmt|;
block|}
else|else
block|{
name|uha_soonest
operator|=
name|mscp
operator|->
name|later
expr_stmt|;
block|}
if|if
condition|(
name|mscp
operator|->
name|later
condition|)
block|{
name|mscp
operator|->
name|later
operator|->
name|sooner
operator|=
name|mscp
operator|->
name|sooner
expr_stmt|;
name|mscp
operator|->
name|later
operator|->
name|delta
operator|+=
name|mscp
operator|->
name|delta
expr_stmt|;
block|}
else|else
block|{
name|uha_latest
operator|=
name|mscp
operator|->
name|sooner
expr_stmt|;
name|uha_furtherest
operator|-=
name|mscp
operator|->
name|delta
expr_stmt|;
block|}
name|mscp
operator|->
name|sooner
operator|=
name|mscp
operator|->
name|later
operator|=
operator|(
expr|struct
name|mscp
operator|*
operator|)
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ONETICK
value|500
end_define

begin_comment
comment|/* milliseconds */
end_comment

begin_define
define|#
directive|define
name|SLEEPTIME
value|((hz * 1000) / ONETICK)
end_define

begin_macro
name|uha_timeout
argument_list|(
argument|arg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|unsigned
name|int
name|stat
decl_stmt|;
name|int
name|port
init|=
name|uha_data
index|[
name|unit
index|]
operator|.
name|baseport
decl_stmt|;
while|while
condition|(
name|mscp
operator|=
name|uha_soonest
condition|)
block|{
if|if
condition|(
name|mscp
operator|->
name|delta
operator|<=
name|ONETICK
condition|)
comment|/***********************************************\ 		* It has timed out, we need to do some work     * 		\***********************************************/
block|{
name|unit
operator|=
name|mscp
operator|->
name|xs
operator|->
name|adapter
expr_stmt|;
name|printf
argument_list|(
literal|"uha%d:%d device timed out\n"
argument_list|,
name|unit
argument_list|,
name|mscp
operator|->
name|xs
operator|->
name|targ
argument_list|)
expr_stmt|;
if|if
condition|(
name|uha_debug
operator|&
name|UHA_SHOWMSCPS
condition|)
name|uha_print_active_mscp
argument_list|()
expr_stmt|;
comment|/***************************************\ 			* Unlink it from the queue              * 			\***************************************/
name|uha_remove_timeout
argument_list|(
name|mscp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uha_abort
argument_list|(
name|unit
argument_list|,
name|mscp
argument_list|)
operator|!=
literal|1
operator|)
operator|||
operator|(
name|mscp
operator|->
name|flags
operator|=
name|MSCP_ABORTED
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"AGAIN"
argument_list|)
expr_stmt|;
name|mscp
operator|->
name|xs
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* I MEAN IT ! */
name|uha_done
argument_list|(
name|unit
argument_list|,
name|mscp
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* abort the operation that has timed out */
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|uha_add_timeout
argument_list|(
name|mscp
argument_list|,
literal|2000
operator|+
name|ONETICK
argument_list|)
expr_stmt|;
name|mscp
operator|->
name|flags
operator|=
name|MSCP_ABORTED
expr_stmt|;
block|}
block|}
else|else
comment|/***********************************************\ 		* It has not timed out, adjust and leave        * 		\***********************************************/
block|{
name|mscp
operator|->
name|delta
operator|-=
name|ONETICK
expr_stmt|;
name|uha_furtherest
operator|-=
name|ONETICK
expr_stmt|;
break|break;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|uha_timeout
argument_list|,
name|arg
argument_list|,
name|SLEEPTIME
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|uha_show_scsi_cmd
argument_list|(
argument|struct scsi_xfer *xs
argument_list|)
end_macro

begin_block
block|{
name|u_char
modifier|*
name|b
init|=
operator|(
name|u_char
operator|*
operator|)
name|xs
operator|->
name|cmd
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_RESET
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"uha%d:%d:%d-"
argument_list|,
name|xs
operator|->
name|adapter
argument_list|,
name|xs
operator|->
name|targ
argument_list|,
name|xs
operator|->
name|lu
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|xs
operator|->
name|cmdlen
condition|)
block|{
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
name|b
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"-\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"uha%d:%d:%d-RESET-\n"
argument_list|,
name|xs
operator|->
name|adapter
argument_list|,
name|xs
operator|->
name|targ
argument_list|,
name|xs
operator|->
name|lu
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|uha_print_mscp
argument_list|(
argument|mscp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"mscp:%x op:%x cmdlen:%d senlen:%d\n"
argument_list|,
name|mscp
argument_list|,
name|mscp
operator|->
name|opcode
argument_list|,
name|mscp
operator|->
name|cdblen
argument_list|,
name|mscp
operator|->
name|senselen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	sg:%d sgnum:%x datlen:%d hstat:%x tstat:%x delta:%d flags:%x\n"
argument_list|,
name|mscp
operator|->
name|sgth
argument_list|,
name|mscp
operator|->
name|sg_num
argument_list|,
name|mscp
operator|->
name|datalen
argument_list|,
name|mscp
operator|->
name|ha_status
argument_list|,
name|mscp
operator|->
name|targ_status
argument_list|,
name|mscp
operator|->
name|delta
argument_list|,
name|mscp
operator|->
name|flags
argument_list|)
expr_stmt|;
name|uha_show_scsi_cmd
argument_list|(
name|mscp
operator|->
name|xs
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|uha_print_active_mscp
argument_list|()
end_macro

begin_block
block|{
name|struct
name|mscp
modifier|*
name|mscp
decl_stmt|;
name|mscp
operator|=
name|uha_soonest
expr_stmt|;
while|while
condition|(
name|mscp
condition|)
block|{
name|uha_print_mscp
argument_list|(
name|mscp
argument_list|)
expr_stmt|;
name|mscp
operator|=
name|mscp
operator|->
name|later
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Furtherest = %d\n"
argument_list|,
name|uha_furtherest
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

