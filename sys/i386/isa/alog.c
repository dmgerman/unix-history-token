begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998 Scottibox   * All rights reserved.  *  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Industrial Computer Source model AIO8-P  * 8 channel, moderate speed analog to digital converter board with  * 128 channel MUX capability via daisy chained AT-16P units  * alog.c, character device driver, last revised January 6 1998  * See http://www.scottibox.com  *     http://www.indcompsrc.com/products/data/html/aio8g-p.html  *     http://www.indcompsrc.com/products/data/html/at16-p.html  *  * Written by: Jamil J. Weatherbee<jamil@scottibox.com>  *  */
end_comment

begin_comment
comment|/* Include Files */
end_comment

begin_include
include|#
directive|include
file|"alog.h"
end_include

begin_if
if|#
directive|if
name|NALOG
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<sys/alogio.h>
end_include

begin_include
include|#
directive|include
file|<sys/dataacq.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Local Defines */
end_comment

begin_comment
comment|/* Tests have shown that increasing the fifo size   * beyond 64 entries for this particular piece of hardware is  * unproductive */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ALOG_FIFOSIZE
end_ifdef

begin_define
define|#
directive|define
name|FIFOSIZE
value|ALOG_FIFOSIZE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FIFOSIZE
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ALOG_FIFO_TRIGGER
end_ifdef

begin_define
define|#
directive|define
name|DEFAULT_FIFO_TRIGGER
value|ALOG_FIFO_TRIGGER
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEFAULT_FIFO_TRIGGER
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ALOG_CHANNELS
end_ifdef

begin_define
define|#
directive|define
name|NUMCHANNELS
value|ALOG_CHANNELS
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NUMCHANNELS
value|128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ALOG_TIMO
end_ifdef

begin_define
define|#
directive|define
name|READTIMO
value|ALOG_TIMO
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|READTIMO
value|(MAX_MICRO_PERIOD*NUMCHANNELS/500000*hz)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|86
end_define

begin_define
define|#
directive|define
name|NUMPORTS
value|8
end_define

begin_define
define|#
directive|define
name|MAXUNITS
value|2
end_define

begin_define
define|#
directive|define
name|NUMIMUXES
value|8
end_define

begin_define
define|#
directive|define
name|ADLOW
value|0x0
end_define

begin_define
define|#
directive|define
name|ADHIGH
value|0x1
end_define

begin_define
define|#
directive|define
name|STATUS
value|0x2
end_define

begin_define
define|#
directive|define
name|CNTR0
value|0x4
end_define

begin_define
define|#
directive|define
name|CNTR1
value|0x5
end_define

begin_define
define|#
directive|define
name|CNTR2
value|0x6
end_define

begin_define
define|#
directive|define
name|CNTRCNTRL
value|0x7
end_define

begin_define
define|#
directive|define
name|DEVFORMAT
value|"alog%d%c%d"
end_define

begin_define
define|#
directive|define
name|CLOCK2FREQ
value|4.165
end_define

begin_define
define|#
directive|define
name|MIN_MICRO_PERIOD
value|25
end_define

begin_define
define|#
directive|define
name|MAX_MICRO_PERIOD
value|(65535/CLOCK2FREQ*PRIMARY_STATES)
end_define

begin_define
define|#
directive|define
name|DEFAULT_MICRO_PERIOD
value|MAX_MICRO_PERIOD
end_define

begin_define
define|#
directive|define
name|READMAXTRIG
value|0.75*FIFOSIZE
end_define

begin_define
define|#
directive|define
name|ALOGPRI
value|PRIBIO
end_define

begin_define
define|#
directive|define
name|ALOGMSG
value|"alogio"
end_define

begin_define
define|#
directive|define
name|PRIMARY_STATES
value|2
end_define

begin_comment
comment|/* Setup and conversion are clock tick consuming */
end_comment

begin_define
define|#
directive|define
name|STATE_SETUP
value|0
end_define

begin_define
define|#
directive|define
name|STATE_CONVERT
value|1
end_define

begin_define
define|#
directive|define
name|STATE_READ
value|2
end_define

begin_comment
comment|/* Notes on interrupt driven A/D conversion:  * On the AIO8-P, interrupt driven conversion (the only type supported by this  * driver) is facilitated through 8253 timer #2.  In order for interrrupts to  * be generated you must connect line 6 to line 24 (counter 2 output to   * interrupt input) and line 23 to line 29 (counter 2 gate to +5VDC).   * Due to the design of the AIO8-P this precludes the use of programmable   * gain control.  */
end_comment

begin_comment
comment|/* mode bits for the status register */
end_comment

begin_define
define|#
directive|define
name|EOC
value|0x80
end_define

begin_define
define|#
directive|define
name|IEN
value|0x08
end_define

begin_define
define|#
directive|define
name|IMUXMASK
value|0x07
end_define

begin_define
define|#
directive|define
name|EMUXMASK
value|0xf0
end_define

begin_comment
comment|/* mode bits for counter controller */
end_comment

begin_define
define|#
directive|define
name|LD2MODE4
value|0xb8
end_define

begin_comment
comment|/* Minor allocations:  * UCCCCMMM  * U: board unit (0-1)  * CCCC: external multiplexer channel (0-15) (on AT-16P units)  * MMM: internal multiplexer channel (0-7) (on AIO8-P card)  */
end_comment

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev)& 0x80)>> 7)
end_define

begin_define
define|#
directive|define
name|CHANNEL
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x7f)
end_define

begin_define
define|#
directive|define
name|EMUX
parameter_list|(
name|chan
parameter_list|)
value|((chan& 0x78)>> 3)
end_define

begin_define
define|#
directive|define
name|EMUXMAKE
parameter_list|(
name|chan
parameter_list|)
value|((chan& 0x78)<< 1)
end_define

begin_define
define|#
directive|define
name|IMUX
parameter_list|(
name|chan
parameter_list|)
value|(chan& 0x07)
end_define

begin_define
define|#
directive|define
name|LMINOR
parameter_list|(
name|unit
parameter_list|,
name|chan
parameter_list|)
value|((unit<< 7)+chan)
end_define

begin_comment
comment|/* port statuses */
end_comment

begin_define
define|#
directive|define
name|STATUS_UNUSED
value|0
end_define

begin_define
define|#
directive|define
name|STATUS_INUSE
value|1
end_define

begin_define
define|#
directive|define
name|STATUS_STOPPED
value|2
end_define

begin_define
define|#
directive|define
name|STATUS_INIT
value|3
end_define

begin_comment
comment|/* Type definitions */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|short
name|status
decl_stmt|;
comment|/* the status of this chan */
name|struct
name|selinfo
name|readpoll
decl_stmt|;
comment|/* the poll() info */
name|u_short
name|fifo
index|[
name|FIFOSIZE
index|]
decl_stmt|;
comment|/* fifo for this chan */
name|int
name|fifostart
decl_stmt|,
name|fifoend
decl_stmt|;
comment|/* the ptrs showing where info is stored in fifo */
name|int
name|fifosize
decl_stmt|,
name|fifotrig
decl_stmt|;
comment|/* the current and trigger size of the fifo */
name|void
modifier|*
name|devfs_token
decl_stmt|;
comment|/* the devfs token for this chan */
name|int
name|nextchan
decl_stmt|;
block|}
name|talog_chan
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|isa_device
modifier|*
name|isaunit
decl_stmt|;
comment|/* ptr to isa device information */
name|talog_chan
name|chan
index|[
name|NUMCHANNELS
index|]
decl_stmt|;
comment|/* the device nodes */
name|int
name|curchan
decl_stmt|;
comment|/* the current chan being intr handled */
name|int
name|firstchan
decl_stmt|;
comment|/* the first chan to go to in list */
name|int
name|state
decl_stmt|;
comment|/* is the node in setup or convert mode */
name|long
name|microperiod
decl_stmt|;
comment|/* current microsecond period setting */
name|u_char
name|perlo
decl_stmt|,
name|perhi
decl_stmt|;
comment|/* current values to send to clock 2 after every intr */
block|}
name|talog_unit
typedef|;
end_typedef

begin_comment
comment|/* Function Prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|alog_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Check for alog board */
end_comment

begin_function_decl
specifier|static
name|int
name|alog_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Take alog board */
end_comment

begin_function_decl
specifier|static
name|int
name|sync_clock2
parameter_list|(
name|int
name|unit
parameter_list|,
name|long
name|period
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* setup clock 2 period */
end_comment

begin_function_decl
specifier|static
name|int
name|putfifo
parameter_list|(
name|talog_chan
modifier|*
name|pchan
parameter_list|,
name|u_short
name|fifoent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alog_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alog_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alog_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alog_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alog_poll
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Global Data */
end_comment

begin_decl_stmt
specifier|static
name|int
name|alog_devsw_installed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protect against reinit multiunit */
end_comment

begin_decl_stmt
specifier|static
name|talog_unit
modifier|*
name|alog_unit
index|[
name|NALOG
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data structs for each unit */
end_comment

begin_comment
comment|/* Character device switching structure */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|alog_cdevsw
init|=
block|{
name|alog_open
block|,
name|alog_close
block|,
name|alog_read
block|,
name|nowrite
block|,
name|alog_ioctl
block|,
name|nostop
block|,
name|noreset
block|,
name|nodevtotty
block|,
name|alog_poll
block|,
name|nommap
block|,
name|nostrategy
block|,
literal|"alog"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure expected to tell how to probe and attach the driver  * Must be published externally (cannot be static) */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|alogdriver
init|=
block|{
name|alog_probe
block|,
name|alog_attach
block|,
literal|"alog"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* handle the ioctls */
end_comment

begin_function
specifier|static
name|int
name|alog_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|chan
init|=
name|CHANNEL
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|talog_unit
modifier|*
name|info
init|=
name|alog_unit
index|[
name|unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIONBIO
case|:
return|return
literal|0
return|;
comment|/* this allows for non-blocking ioctls */
case|case
name|AD_NCHANS_GET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|NUMCHANNELS
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AD_FIFOSIZE_GET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|FIFOSIZE
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AD_FIFO_TRIGGER_GET
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifotrig
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AD_FIFO_TRIGGER_SET
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<
literal|1
operator|)
operator|||
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>
name|FIFOSIZE
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EPERM
return|;
block|}
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifotrig
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AD_STOP
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|status
operator|=
name|STATUS_STOPPED
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AD_START
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|status
operator|=
name|STATUS_INUSE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AD_MICRO_PERIOD_SET
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sync_clock2
argument_list|(
name|unit
argument_list|,
operator|*
operator|(
name|long
operator|*
operator|)
name|data
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EPERM
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AD_MICRO_PERIOD_GET
case|:
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|*
operator|(
name|long
operator|*
operator|)
name|data
operator|=
name|info
operator|->
name|microperiod
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENOTTY
return|;
block|}
end_function

begin_comment
comment|/* handle poll() based read polling */
end_comment

begin_function
specifier|static
name|int
name|alog_poll
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|chan
init|=
name|CHANNEL
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|talog_unit
modifier|*
name|info
init|=
name|alog_unit
index|[
name|unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
comment|/* if polling for any/normal data */
if|if
condition|(
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifosize
operator|>=
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifotrig
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
return|;
comment|/* ready for any/read */
block|}
else|else
block|{
comment|/* record this request */
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
operator|(
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|readpoll
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* not ready, yet */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* not ready (any I never will be) */
block|}
end_function

begin_comment
comment|/* how to read from the board */
end_comment

begin_function
specifier|static
name|int
name|alog_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|chan
init|=
name|CHANNEL
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|talog_unit
modifier|*
name|info
init|=
name|alog_unit
index|[
name|unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|,
name|oldtrig
decl_stmt|,
name|toread
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|oldtrig
operator|=
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifotrig
expr_stmt|;
comment|/* save official trigger value */
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
comment|/* while uio has space */
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifosize
condition|)
comment|/* if we have an empty fifo */
block|{
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
comment|/* exit if we are non-blocking */
block|{
name|err
operator|=
name|EWOULDBLOCK
expr_stmt|;
break|break;
block|}
comment|/* Start filling fifo on first blocking read */
if|if
condition|(
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|status
operator|==
name|STATUS_INIT
condition|)
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|status
operator|=
name|STATUS_INUSE
expr_stmt|;
comment|/* temporarily adjust the fifo trigger to be optimal size */
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifotrig
operator|=
name|min
argument_list|(
name|READMAXTRIG
argument_list|,
name|uio
operator|->
name|uio_resid
operator|/
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lets sleep until we have some io available or timeout */
name|err
operator|=
name|tsleep
argument_list|(
operator|&
operator|(
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifo
operator|)
argument_list|,
name|ALOGPRI
operator||
name|PCATCH
argument_list|,
name|ALOGMSG
argument_list|,
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifotrig
operator|*
name|READTIMO
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|printf
argument_list|(
name|DEVFORMAT
literal|": read timeout\n"
argument_list|,
name|unit
argument_list|,
literal|'a'
operator|+
name|EMUX
argument_list|(
name|chan
argument_list|)
argument_list|,
name|IMUX
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|ERESTART
condition|)
name|err
operator|=
name|EINTR
expr_stmt|;
comment|/* don't know how to restart */
if|if
condition|(
name|err
condition|)
break|break;
comment|/* exit if any kind of error or signal */
block|}
comment|/* ok, now if we got here there is something to read from the fifo */
comment|/* calculate how many entries we can read out from the fifostart       * pointer */
name|toread
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
operator|/
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|min
argument_list|(
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifosize
argument_list|,
name|FIFOSIZE
operator|-
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifostart
argument_list|)
argument_list|)
expr_stmt|;
comment|/* perform the move, if there is an error then exit */
if|if
condition|(
name|err
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifo
index|[
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifostart
index|]
operator|)
argument_list|,
name|toread
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|uio
argument_list|)
condition|)
break|break;
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifosize
operator|-=
name|toread
expr_stmt|;
comment|/* fifo this much smaller */
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifostart
operator|+=
name|toread
expr_stmt|;
comment|/* we got this many more */
if|if
condition|(
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifostart
operator|==
name|FIFOSIZE
condition|)
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifostart
operator|=
literal|0
expr_stmt|;
comment|/* wrap around fifostart */
block|}
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifotrig
operator|=
name|oldtrig
expr_stmt|;
comment|/* restore trigger changes */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* open a channel */
end_comment

begin_function
specifier|static
name|int
name|alog_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* get unit no */
name|int
name|chan
init|=
name|CHANNEL
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* get channel no */
name|talog_unit
modifier|*
name|info
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* priority */
name|int
name|cur
decl_stmt|;
if|if
condition|(
operator|(
name|unit
operator|>=
name|NALOG
operator|)
operator|||
operator|(
name|unit
operator|>=
name|MAXUNITS
operator|)
operator|||
operator|(
name|chan
operator|>=
name|NUMCHANNELS
operator|)
condition|)
return|return
name|ENXIO
return|;
comment|/* unit and channel no ok ? */
if|if
condition|(
operator|!
name|alog_unit
index|[
name|unit
index|]
condition|)
return|return
name|ENXIO
return|;
comment|/* unit attached */
name|info
operator|=
name|alog_unit
index|[
name|unit
index|]
expr_stmt|;
comment|/* ok, this is valid now */
if|if
condition|(
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|status
condition|)
return|return
name|EBUSY
return|;
comment|/* channel busy */
if|if
condition|(
name|oflags
operator|&
name|FREAD
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|status
operator|=
name|STATUS_INIT
expr_stmt|;
comment|/* channel open, read waiting */
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifostart
operator|=
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifoend
operator|=
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifosize
operator|=
literal|0
expr_stmt|;
comment|/* fifo empty */
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|fifotrig
operator|=
name|DEFAULT_FIFO_TRIGGER
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|firstchan
operator|<
literal|0
condition|)
comment|/* if empty chain */
block|{
name|info
operator|->
name|firstchan
operator|=
name|info
operator|->
name|curchan
operator|=
name|chan
expr_stmt|;
comment|/* rev up the list */
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|nextchan
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* end of the list */
block|}
else|else
comment|/* non empty list must insert */
block|{
if|if
condition|(
name|chan
operator|<
name|info
operator|->
name|firstchan
condition|)
comment|/* this one must become first in list */
block|{
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|nextchan
operator|=
name|info
operator|->
name|firstchan
expr_stmt|;
name|info
operator|->
name|firstchan
operator|=
name|chan
expr_stmt|;
block|}
else|else
comment|/* insert this one as second - last in chan list */
block|{
name|cur
operator|=
name|info
operator|->
name|firstchan
expr_stmt|;
comment|/* traverse list as long as cur is less than chan and cur is 	    * not last in list */
while|while
condition|(
operator|(
name|info
operator|->
name|chan
index|[
name|cur
index|]
operator|.
name|nextchan
operator|<
name|chan
operator|)
operator|&&
operator|(
name|info
operator|->
name|chan
index|[
name|cur
index|]
operator|.
name|nextchan
operator|>=
literal|0
operator|)
condition|)
name|cur
operator|=
name|info
operator|->
name|chan
index|[
name|cur
index|]
operator|.
name|nextchan
expr_stmt|;
comment|/* now cur should point to the entry right before yours */
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|nextchan
operator|=
name|info
operator|->
name|chan
index|[
name|cur
index|]
operator|.
name|nextchan
expr_stmt|;
name|info
operator|->
name|chan
index|[
name|cur
index|]
operator|.
name|nextchan
operator|=
name|chan
expr_stmt|;
comment|/* insert yours in */
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* open successful */
block|}
return|return
name|EPERM
return|;
comment|/* this is a read only device */
block|}
end_function

begin_comment
comment|/* close a channel */
end_comment

begin_function
specifier|static
name|int
name|alog_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|chan
init|=
name|CHANNEL
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|talog_unit
modifier|*
name|info
init|=
name|alog_unit
index|[
name|unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|cur
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|status
operator|=
name|STATUS_UNUSED
expr_stmt|;
comment|/* what if we are in the middle of a conversion ?    * then smoothly get us out of it: */
if|if
condition|(
name|info
operator|->
name|curchan
operator|==
name|chan
condition|)
block|{
comment|/* if we are last in list set curchan to first in list */
if|if
condition|(
operator|(
name|info
operator|->
name|curchan
operator|=
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|nextchan
operator|)
operator|<
literal|0
condition|)
name|info
operator|->
name|curchan
operator|=
name|info
operator|->
name|firstchan
expr_stmt|;
name|info
operator|->
name|state
operator|=
name|STATE_SETUP
expr_stmt|;
block|}
comment|/* if this is the first channel, then make the second channel the first    * channel (note that if this is also the only channel firstchan becomes    * -1 and so the list is marked as empty */
if|if
condition|(
name|chan
operator|==
name|info
operator|->
name|firstchan
condition|)
name|info
operator|->
name|firstchan
operator|=
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|nextchan
expr_stmt|;
else|else
comment|/* ok, so there must be at least 2 channels (and it is not the first) */
block|{
name|cur
operator|=
name|info
operator|->
name|firstchan
expr_stmt|;
comment|/* find the entry before it (which must exist if you are closing) */
while|while
condition|(
name|info
operator|->
name|chan
index|[
name|cur
index|]
operator|.
name|nextchan
operator|<
name|chan
condition|)
name|cur
operator|=
name|info
operator|->
name|chan
index|[
name|cur
index|]
operator|.
name|nextchan
expr_stmt|;
comment|/* at this point we must have the entry before ours */
name|info
operator|->
name|chan
index|[
name|cur
index|]
operator|.
name|nextchan
operator|=
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|nextchan
expr_stmt|;
comment|/* give our link */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* close always successful */
block|}
end_function

begin_comment
comment|/* The probing routine - returns number of bytes needed */
end_comment

begin_function
specifier|static
name|int
name|alog_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
block|{
name|int
name|unit
init|=
name|idp
operator|->
name|id_unit
decl_stmt|;
comment|/* this device unit number */
name|int
name|iobase
init|=
name|idp
operator|->
name|id_iobase
decl_stmt|;
comment|/* the base address of the unit */
name|int
name|addr
decl_stmt|;
if|if
condition|(
operator|(
name|unit
operator|<
literal|0
operator|)
operator|||
operator|(
name|unit
operator|>=
name|NALOG
operator|)
operator|||
operator|(
name|unit
operator|>=
name|MAXUNITS
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"alog: invalid unit number (%d)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* the unit number is ok, lets check if used */
if|if
condition|(
name|alog_unit
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"alog: unit (%d) already attached\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|inb
argument_list|(
name|iobase
operator|+
name|STATUS
argument_list|)
operator|&
name|EOC
condition|)
return|return
literal|0
return|;
comment|/* End of conv bit should be 0 */
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|NUMIMUXES
condition|;
name|addr
operator|++
control|)
block|{
name|outb
argument_list|(
name|iobase
operator|+
name|STATUS
argument_list|,
name|EMUXMASK
operator||
name|addr
argument_list|)
expr_stmt|;
comment|/* output ones to upper nibbl+addr */
comment|/* get back a zero in MSB and the addr where you put it */
if|if
condition|(
operator|(
name|inb
argument_list|(
name|iobase
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|EOC
operator||
name|IMUXMASK
operator|)
operator|)
operator|!=
name|addr
condition|)
return|return
literal|0
return|;
block|}
return|return
name|NUMPORTS
return|;
comment|/* this device needs this many ports */
block|}
end_function

begin_comment
comment|/* setup the info structure correctly for reloading clock 2 after interrupt */
end_comment

begin_function
specifier|static
name|int
name|sync_clock2
parameter_list|(
name|int
name|unit
parameter_list|,
name|long
name|period
parameter_list|)
block|{
name|int
name|clockper
decl_stmt|;
name|talog_unit
modifier|*
name|info
init|=
name|alog_unit
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|period
operator|>
name|MAX_MICRO_PERIOD
operator|)
operator|||
operator|(
name|period
operator|<
name|MIN_MICRO_PERIOD
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* error period too long */
name|info
operator|->
name|microperiod
operator|=
name|period
expr_stmt|;
comment|/* record the period */
name|clockper
operator|=
operator|(
name|CLOCK2FREQ
operator|*
name|period
operator|)
operator|/
name|PRIMARY_STATES
expr_stmt|;
name|info
operator|->
name|perlo
operator|=
name|clockper
operator|&
literal|0xff
expr_stmt|;
comment|/* least sig byte of clock period */
name|info
operator|->
name|perhi
operator|=
operator|(
operator|(
name|clockper
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
comment|/* most sig byte of clock period */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* The attachment routine - returns true on success */
end_comment

begin_function
specifier|static
name|int
name|alog_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
block|{
name|int
name|unit
init|=
name|idp
operator|->
name|id_unit
decl_stmt|;
comment|/* this device unit number */
name|int
name|iobase
init|=
name|idp
operator|->
name|id_iobase
decl_stmt|;
comment|/* the base address of the unit */
name|talog_unit
modifier|*
name|info
decl_stmt|;
comment|/* pointer to driver specific info for unit */
name|int
name|chan
decl_stmt|;
comment|/* the channel used for creating devfs nodes */
if|if
condition|(
operator|!
operator|(
name|info
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"alog%d: cannot allocate driver storage\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|alog_unit
index|[
name|unit
index|]
operator|=
name|info
expr_stmt|;
comment|/* make sure to save the pointer */
name|bzero
argument_list|(
name|info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear info structure to all false */
name|info
operator|->
name|isaunit
operator|=
name|idp
expr_stmt|;
comment|/* store ptr to isa device information */
name|sync_clock2
argument_list|(
name|unit
argument_list|,
name|DEFAULT_MICRO_PERIOD
argument_list|)
expr_stmt|;
comment|/* setup perlo and perhi */
name|info
operator|->
name|firstchan
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* channel lists are empty */
comment|/* insert devfs nodes */
ifdef|#
directive|ifdef
name|DEVFS
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|NUMCHANNELS
condition|;
name|chan
operator|++
control|)
name|info
operator|->
name|chan
index|[
name|chan
index|]
operator|.
name|devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|alog_cdevsw
argument_list|,
name|LMINOR
argument_list|(
name|unit
argument_list|,
name|chan
argument_list|)
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0400
argument_list|,
name|DEVFORMAT
argument_list|,
name|unit
argument_list|,
literal|'a'
operator|+
name|EMUX
argument_list|(
name|chan
argument_list|)
argument_list|,
name|IMUX
argument_list|(
name|chan
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"alog%d: %d channels, %d bytes/FIFO, %d entry trigger\n"
argument_list|,
name|unit
argument_list|,
name|NUMCHANNELS
argument_list|,
name|FIFOSIZE
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|DEFAULT_FIFO_TRIGGER
argument_list|)
expr_stmt|;
name|alogintr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* start the periodic interrupting process */
return|return
literal|1
return|;
comment|/* obviously successful */
block|}
end_function

begin_comment
comment|/* Unit interrupt handling routine (interrupts generated by clock 2) */
end_comment

begin_function
name|void
name|alogintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|talog_unit
modifier|*
name|info
init|=
name|alog_unit
index|[
name|unit
index|]
decl_stmt|;
name|int
name|iobase
init|=
name|info
operator|->
name|isaunit
operator|->
name|id_iobase
decl_stmt|;
name|u_short
name|fifoent
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|firstchan
operator|>=
literal|0
condition|)
comment|/* ? is there even a chan list to traverse */
switch|switch
condition|(
name|info
operator|->
name|state
condition|)
block|{
case|case
name|STATE_READ
case|:
if|if
condition|(
name|info
operator|->
name|chan
index|[
name|info
operator|->
name|curchan
index|]
operator|.
name|status
operator|==
name|STATUS_INUSE
condition|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|iobase
operator|+
name|STATUS
argument_list|)
operator|&
name|EOC
condition|)
comment|/* check that conversion finished */
name|printf
argument_list|(
name|DEVFORMAT
literal|": incomplete conversion\n"
argument_list|,
name|unit
argument_list|,
literal|'a'
operator|+
name|EMUX
argument_list|(
name|info
operator|->
name|curchan
argument_list|)
argument_list|,
name|IMUX
argument_list|(
name|info
operator|->
name|curchan
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* conversion is finished (should always be) */
block|{
name|fifoent
operator|=
operator|(
name|inb
argument_list|(
name|iobase
operator|+
name|ADHIGH
argument_list|)
operator|<<
literal|8
operator|)
operator|+
name|inb
argument_list|(
name|iobase
operator|+
name|ADLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|putfifo
argument_list|(
operator|&
operator|(
name|info
operator|->
name|chan
index|[
name|info
operator|->
name|curchan
index|]
operator|)
argument_list|,
name|fifoent
argument_list|)
condition|)
block|{
name|printf
argument_list|(
name|DEVFORMAT
literal|": fifo overflow\n"
argument_list|,
name|unit
argument_list|,
literal|'a'
operator|+
name|EMUX
argument_list|(
name|info
operator|->
name|curchan
argument_list|)
argument_list|,
name|IMUX
argument_list|(
name|info
operator|->
name|curchan
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|chan
index|[
name|info
operator|->
name|curchan
index|]
operator|.
name|fifosize
operator|>=
name|info
operator|->
name|chan
index|[
name|info
operator|->
name|curchan
index|]
operator|.
name|fifotrig
condition|)
block|{
comment|/* if we've reached trigger levels */
name|selwakeup
argument_list|(
operator|&
operator|(
name|info
operator|->
name|chan
index|[
name|info
operator|->
name|curchan
index|]
operator|.
name|readpoll
operator|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
operator|(
name|info
operator|->
name|chan
index|[
name|info
operator|->
name|curchan
index|]
operator|.
name|fifo
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* goto setup state for next channel on list */
if|if
condition|(
operator|(
name|info
operator|->
name|curchan
operator|=
name|info
operator|->
name|chan
index|[
name|info
operator|->
name|curchan
index|]
operator|.
name|nextchan
operator|)
operator|<
literal|0
condition|)
name|info
operator|->
name|curchan
operator|=
name|info
operator|->
name|firstchan
expr_stmt|;
comment|/* notice lack of break here this implys a STATE_SETUP */
case|case
name|STATE_SETUP
case|:
comment|/* set the muxes and let them settle */
if|#
directive|if
name|NUMCHANNELS
operator|>
name|NUMIMUXES
comment|/* only do this if using external muxes */
name|outb
argument_list|(
name|iobase
operator|+
name|STATUS
argument_list|,
name|EMUXMAKE
argument_list|(
name|info
operator|->
name|curchan
argument_list|)
operator||
name|IMUX
argument_list|(
name|info
operator|->
name|curchan
argument_list|)
operator||
name|IEN
argument_list|)
expr_stmt|;
name|info
operator|->
name|state
operator|=
name|STATE_CONVERT
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|STATE_CONVERT
case|:
name|outb
argument_list|(
name|iobase
operator|+
name|STATUS
argument_list|,
name|EMUXMAKE
argument_list|(
name|info
operator|->
name|curchan
argument_list|)
operator||
name|IMUX
argument_list|(
name|info
operator|->
name|curchan
argument_list|)
operator||
name|IEN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
operator|+
name|ADHIGH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* start the conversion */
name|info
operator|->
name|state
operator|=
name|STATE_READ
expr_stmt|;
break|break;
block|}
else|else
comment|/* this is kind of like an idle mode */
block|{
name|outb
argument_list|(
name|iobase
operator|+
name|STATUS
argument_list|,
name|IEN
argument_list|)
expr_stmt|;
comment|/* no list keep getting interrupts though */
comment|/* since we have no open channels spin clock rate down to         * minimum to save interrupt overhead */
name|outb
argument_list|(
name|iobase
operator|+
name|CNTRCNTRL
argument_list|,
name|LD2MODE4
argument_list|)
expr_stmt|;
comment|/* counter 2 to mode 4 strobe */
name|outb
argument_list|(
name|iobase
operator|+
name|CNTR2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* longest period we can generate */
name|outb
argument_list|(
name|iobase
operator|+
name|CNTR2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
return|return;
block|}
name|outb
argument_list|(
name|iobase
operator|+
name|CNTRCNTRL
argument_list|,
name|LD2MODE4
argument_list|)
expr_stmt|;
comment|/* counter 2 to mode 4 strobe */
name|outb
argument_list|(
name|iobase
operator|+
name|CNTR2
argument_list|,
name|info
operator|->
name|perlo
argument_list|)
expr_stmt|;
comment|/* low part of the period count */
name|outb
argument_list|(
name|iobase
operator|+
name|CNTR2
argument_list|,
name|info
operator|->
name|perhi
argument_list|)
expr_stmt|;
comment|/* high part of the period count */
block|}
end_function

begin_comment
comment|/* this will put an entry in fifo, returns 1 if the first item in   * fifo was wiped (overflow) or 0 if everything went fine */
end_comment

begin_function
specifier|static
name|int
name|putfifo
parameter_list|(
name|talog_chan
modifier|*
name|pchan
parameter_list|,
name|u_short
name|fifoent
parameter_list|)
block|{
name|pchan
operator|->
name|fifo
index|[
name|pchan
operator|->
name|fifoend
index|]
operator|=
name|fifoent
expr_stmt|;
comment|/* insert the entry in */
name|pchan
operator|->
name|fifoend
operator|++
expr_stmt|;
comment|/* one more in fifo */
if|if
condition|(
name|pchan
operator|->
name|fifoend
operator|==
name|FIFOSIZE
condition|)
name|pchan
operator|->
name|fifoend
operator|=
literal|0
expr_stmt|;
comment|/* wrap around */
comment|/* note: I did intend to write over the oldest entry on overflow */
if|if
condition|(
name|pchan
operator|->
name|fifosize
operator|==
name|FIFOSIZE
condition|)
comment|/* overflowing state already */
block|{
name|pchan
operator|->
name|fifostart
operator|++
expr_stmt|;
if|if
condition|(
name|pchan
operator|->
name|fifostart
operator|==
name|FIFOSIZE
condition|)
name|pchan
operator|->
name|fifostart
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
comment|/* we overflowed */
block|}
name|pchan
operator|->
name|fifosize
operator|++
expr_stmt|;
comment|/* actually one bigger, else same size */
return|return
literal|0
return|;
comment|/* went in just fine */
block|}
end_function

begin_comment
comment|/* Driver initialization */
end_comment

begin_function
specifier|static
name|void
name|alog_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
comment|/* Type for holding device major/minor numbers (int) */
if|if
condition|(
operator|!
name|alog_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* description of device major */
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|alog_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* put driver in cdev table */
name|alog_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* System initialization call instance */
end_comment

begin_expr_stmt
name|SYSINIT
argument_list|(
name|alogdev
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
operator|+
name|CDEV_MAJOR
argument_list|,
name|alog_drvinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

