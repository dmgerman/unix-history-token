begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Driver for the 27/284X series adaptec SCSI controllers written by   * Justin T. Gibbs.  Much of this driver was taken from Julian Elischer's  * 1742 driver, so it bears his copyright.  *  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * commenced: Sun Sep 27 18:14:01 PDT 1992  *  *      $Id: aha2742.c,v 1.1 1994/11/18 05:01:06 jkh Exp $  */
end_comment

begin_comment
comment|/*  * TODO:  * 	Add support for dual and wide busses  *	Implement Target Mode  *	Implement Tagged Queuing  * 	Add target reset capabilities  *	Test the check SCSI sense code  *	Write a message abort procedure for use in ahc_timeout  *	Add support for the 294X series cards  *  *	This driver is very stable, and seems to offer performance  *	comprable to the 1742 FreeBSD driver.  The only timeouts  *	I have ever experienced were due to critical driver bugs  *	where an abort wouldn't have helped me anyway. So I haven't  *	written code to actually search the QINFIFO and/or kill an  *	active command.  Same goes for target reset.  */
end_comment

begin_define
define|#
directive|define
name|AHC_SCB_MAX
value|16
end_define

begin_comment
comment|/*  				 * Up to 16 SCBs on some types of aic7xxx based  				 * boards.  The aic7770 family only have 4 				 */
end_comment

begin_include
include|#
directive|include
file|"ahc.h"
end_include

begin_comment
comment|/* for NAHC from config */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_define
define|#
directive|define
name|AHC_NSEG
value|256
end_define

begin_comment
comment|/* number of dma segments supported */
end_comment

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|AHCDEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|unsigned
name|long
name|int
name|physaddr
typedef|;
end_typedef

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_typedef
typedef|typedef
enum|enum
block|{
name|AHC_274
block|,
comment|/* Single Channel */
name|AHC_274T
block|,
comment|/* Twin Channel */
name|AHC_274W
block|,
comment|/* Wide Channel */
name|AHC_284
block|,
comment|/* VL Single Channel */
name|AHC_284T
block|,
comment|/* VL Twin Channel */
name|AHC_284W
block|,
comment|/* VL Wide Channel - Do these exist?? */
block|}
name|ahc_type
typedef|;
end_typedef

begin_function_decl
name|int
name|ahcprobe
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|ahcprobe1
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|,
name|ahc_type
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|ahc_attach
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|ahc_init
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ahc_loadseq
name|__P
argument_list|(
operator|(
name|int
name|port
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|ahcintr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int32
name|ahc_scsi_cmd
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|timeout_t
name|ahc_timeout
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ahc_done
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|scb
modifier|*
name|ahc_get_scb
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ahc_free_scb
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ahcminphys
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|scb
modifier|*
name|ahc_scb_phys_kv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|u_int32
name|ahc_adapter_info
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAX_SLOTS
value|8
end_define

begin_comment
comment|/* XXX should this be 16?? Need EISA spec */
end_comment

begin_expr_stmt
specifier|static
name|ahc_slot
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* slot last board was found in */
end_comment

begin_expr_stmt
specifier|static
name|ahc_unit
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Different debugging levels - only one so-far */
end_comment

begin_define
define|#
directive|define
name|AHC_SHOWMISC
value|0x0001
end_define

begin_decl_stmt
name|int
name|ahc_debug
init|=
name|AHC_SHOWMISC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Standard EISA Host ID regs  (Offset from slot base)  */
end_comment

begin_define
define|#
directive|define
name|HID0
value|0xC80
end_define

begin_comment
comment|/* 0,1: msb of ID2, 2-7: ID1      */
end_comment

begin_define
define|#
directive|define
name|HID1
value|0xC81
end_define

begin_comment
comment|/* 0-4: ID3, 5-7: LSB ID2         */
end_comment

begin_define
define|#
directive|define
name|HID2
value|0xC82
end_define

begin_comment
comment|/* product, 0=174[20] 1 = 1744    */
end_comment

begin_define
define|#
directive|define
name|HID3
value|0xC83
end_define

begin_comment
comment|/* firmware revision              */
end_comment

begin_comment
comment|/**** bit definitions for SCSIDEF ****/
end_comment

begin_define
define|#
directive|define
name|HSCSIID
value|0x07
end_define

begin_comment
comment|/* our SCSI ID */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|ahc_type
name|type
decl_stmt|;
name|unsigned
name|char
name|id
decl_stmt|;
comment|/* The Last EISA Host ID reg */
block|}
name|ahc_sig
typedef|;
end_typedef

begin_define
define|#
directive|define
name|CHAR1
parameter_list|(
name|B1
parameter_list|,
name|B2
parameter_list|)
value|(((B1>>2)& 0x1F) | '@')
end_define

begin_define
define|#
directive|define
name|CHAR2
parameter_list|(
name|B1
parameter_list|,
name|B2
parameter_list|)
value|(((B1<<3)& 0x18) | ((B2>>5)& 0x7)|'@')
end_define

begin_define
define|#
directive|define
name|CHAR3
parameter_list|(
name|B1
parameter_list|,
name|B2
parameter_list|)
value|((B2& 0x1F) | '@')
end_define

begin_decl_stmt
name|struct
name|isa_driver
name|ahcdriver
init|=
block|{
name|ahcprobe
block|,
name|ahc_attach
block|,
literal|"ahc"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scsi_adapter
name|ahc_switch
init|=
block|{
name|ahc_scsi_cmd
block|,
name|ahcminphys
block|,
literal|0
block|,
literal|0
block|,
name|ahc_adapter_info
block|,
literal|"ahc"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the below structure is so we have a default dev struct for our link struct */
end_comment

begin_decl_stmt
name|struct
name|scsi_device
name|ahc_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"ahc"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * All of these should be in a separate header file shared by the sequencer  * code and the kernel level driver.  The only catch is that we would need to   * add an additional 0xc00 offset when using them in the kernel driver.  The   * aic7770 assembler must be modified to allow include files as well.  All   * page numbers refer to the Adaptec AIC-7770 Data Book availible from   * Adaptec's Technical Documents Department 1-800-634-2766  */
end_comment

begin_comment
comment|/* -------------------- AIC-7770 offset definitions ----------------------- */
end_comment

begin_comment
comment|/*   * SCSI Sequence Control (p. 3-11).    * Each bit, when set starts a specific SCSI sequence on the bus  */
end_comment

begin_define
define|#
directive|define
name|SCSISEQ
value|0xc00
end_define

begin_define
define|#
directive|define
name|TEMODEO
value|0x80
end_define

begin_define
define|#
directive|define
name|ENSELO
value|0x40
end_define

begin_define
define|#
directive|define
name|ENSELI
value|0x20
end_define

begin_define
define|#
directive|define
name|ENRSELI
value|0x10
end_define

begin_define
define|#
directive|define
name|ENAUTOATNO
value|0x08
end_define

begin_define
define|#
directive|define
name|ENAUTOATNI
value|0x04
end_define

begin_define
define|#
directive|define
name|ENAUTOATNP
value|0x02
end_define

begin_define
define|#
directive|define
name|SCSIRSTO
value|0x01
end_define

begin_comment
comment|/*  * SCSI Control Signal Read Register (p. 3-15).   * Reads the actual state of the SCSI bus pins  */
end_comment

begin_define
define|#
directive|define
name|SCSISIGI
value|0xc03
end_define

begin_define
define|#
directive|define
name|CDI
value|0x80
end_define

begin_define
define|#
directive|define
name|IOI
value|0x40
end_define

begin_define
define|#
directive|define
name|MSGI
value|0x20
end_define

begin_define
define|#
directive|define
name|ATNI
value|0x10
end_define

begin_define
define|#
directive|define
name|SELI
value|0x08
end_define

begin_define
define|#
directive|define
name|BSYI
value|0x04
end_define

begin_define
define|#
directive|define
name|REQI
value|0x02
end_define

begin_define
define|#
directive|define
name|ACKI
value|0x01
end_define

begin_comment
comment|/*  * SCSI Contol Signal Write Register (p. 3-16).   * Writing to this register modifies the control signals on the bus.  Only   * those signals that are allowed in the current mode (Initiator/Target) are  * asserted.  */
end_comment

begin_define
define|#
directive|define
name|SCSISIGO
value|0xc03
end_define

begin_define
define|#
directive|define
name|CDO
value|0x80
end_define

begin_define
define|#
directive|define
name|IOO
value|0x40
end_define

begin_define
define|#
directive|define
name|MSGO
value|0x20
end_define

begin_define
define|#
directive|define
name|ATNO
value|0x10
end_define

begin_define
define|#
directive|define
name|SELO
value|0x08
end_define

begin_define
define|#
directive|define
name|BSYO
value|0x04
end_define

begin_define
define|#
directive|define
name|REQO
value|0x02
end_define

begin_define
define|#
directive|define
name|ACKO
value|0x01
end_define

begin_comment
comment|/*  * SCSI ID (p. 3-18).  * Contains the ID of the board and the current target on the  * selected channel  */
end_comment

begin_define
define|#
directive|define
name|SCSIID
value|0xc05
end_define

begin_define
define|#
directive|define
name|TID
value|0xf0
end_define

begin_comment
comment|/* Target ID mask */
end_comment

begin_define
define|#
directive|define
name|OID
value|0x0f
end_define

begin_comment
comment|/* Our ID mask */
end_comment

begin_comment
comment|/*  * SCSI Status 0 (p. 3-21)  * Contains one set of SCSI Interrupt codes  * These are most likely of interest to the sequencer  */
end_comment

begin_define
define|#
directive|define
name|SSTAT0
value|0xc0b
end_define

begin_define
define|#
directive|define
name|TARGET
value|0x80
end_define

begin_comment
comment|/* Board is a target */
end_comment

begin_define
define|#
directive|define
name|SELDO
value|0x40
end_define

begin_comment
comment|/* Selection Done */
end_comment

begin_define
define|#
directive|define
name|SELDI
value|0x20
end_define

begin_comment
comment|/* Board has been selected */
end_comment

begin_define
define|#
directive|define
name|SELINGO
value|0x10
end_define

begin_comment
comment|/* Selection In Progress */
end_comment

begin_define
define|#
directive|define
name|SWRAP
value|0x08
end_define

begin_comment
comment|/* 24bit counter wrap */
end_comment

begin_define
define|#
directive|define
name|SDONE
value|0x04
end_define

begin_comment
comment|/* STCNT = 0x000000 */
end_comment

begin_define
define|#
directive|define
name|SPIORDY
value|0x02
end_define

begin_comment
comment|/* SCSI PIO Ready */
end_comment

begin_define
define|#
directive|define
name|DMADONE
value|0x01
end_define

begin_comment
comment|/* DMA transfer completed */
end_comment

begin_comment
comment|/*  * Clear SCSI Interrupt 1 (p. 3-23)  * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT1.  */
end_comment

begin_define
define|#
directive|define
name|CLRSINT1
value|0xc0c
end_define

begin_define
define|#
directive|define
name|CLRSELTIMEO
value|0x80
end_define

begin_define
define|#
directive|define
name|CLRATNO
value|0x40
end_define

begin_define
define|#
directive|define
name|CLRSCSIRSTI
value|0x20
end_define

begin_comment
comment|/*  UNUSED			0x10 */
end_comment

begin_define
define|#
directive|define
name|CLRBUSFREE
value|0x08
end_define

begin_define
define|#
directive|define
name|CLRSCSIPERR
value|0x04
end_define

begin_define
define|#
directive|define
name|CLRPHASECHG
value|0x02
end_define

begin_define
define|#
directive|define
name|CLRREQINIT
value|0x01
end_define

begin_comment
comment|/*  * SCSI Status 1 (p. 3-24)  * These interrupt bits are of interest to the kernel driver  */
end_comment

begin_define
define|#
directive|define
name|SSTAT1
value|0xc0c
end_define

begin_define
define|#
directive|define
name|SELTO
value|0x80
end_define

begin_define
define|#
directive|define
name|ATNTARG
value|0x40
end_define

begin_define
define|#
directive|define
name|SCSIRSTI
value|0x20
end_define

begin_define
define|#
directive|define
name|PHASEMIS
value|0x10
end_define

begin_define
define|#
directive|define
name|BUSFREE
value|0x08
end_define

begin_define
define|#
directive|define
name|SCSIPERR
value|0x04
end_define

begin_define
define|#
directive|define
name|PHASECHG
value|0x02
end_define

begin_define
define|#
directive|define
name|REQINIT
value|0x01
end_define

begin_comment
comment|/*  * Selection/Reselection ID (p. 3-31)  * Upper four bits are the device id.  The ONEBIT is set when the re/selecting  * device did not set its own ID.  */
end_comment

begin_define
define|#
directive|define
name|SELID
value|0xc19
end_define

begin_define
define|#
directive|define
name|SELID_MASK
value|0xf0
end_define

begin_define
define|#
directive|define
name|ONEBIT
value|0x08
end_define

begin_comment
comment|/*  UNUSED			0x07 */
end_comment

begin_comment
comment|/*  * SCSI Block Control (p. 3-32)  * Controls Bus type and channel selection.  In a twin channel configuration  * addresses 0x00-0x1e are gated to the appropriate channel based on this  * register.  SELWIDE allows for the coexistence of 8bit and 16bit devices  * on a wide bus.  */
end_comment

begin_define
define|#
directive|define
name|SBLKCTL
value|0xc1f
end_define

begin_comment
comment|/*  UNUSED			0xc0 */
end_comment

begin_define
define|#
directive|define
name|AUTOFLUSHDIS
value|0x20
end_define

begin_comment
comment|/*  UNUSED			0x10 */
end_comment

begin_define
define|#
directive|define
name|SELBUSB
value|0x08
end_define

begin_comment
comment|/*  UNUSED			0x04 */
end_comment

begin_define
define|#
directive|define
name|SELWIDE
value|0x02
end_define

begin_comment
comment|/*  UNUSED			0x01 */
end_comment

begin_comment
comment|/*  * Sequencer Control (p. 3-33)  * Error detection mode and speed configuration  */
end_comment

begin_define
define|#
directive|define
name|SEQCTL
value|0xc60
end_define

begin_define
define|#
directive|define
name|PERRORDIS
value|0x80
end_define

begin_define
define|#
directive|define
name|PAUSEDIS
value|0x40
end_define

begin_define
define|#
directive|define
name|FAILDIS
value|0x20
end_define

begin_define
define|#
directive|define
name|FASTMODE
value|0x10
end_define

begin_define
define|#
directive|define
name|BRKADRINTEN
value|0x08
end_define

begin_define
define|#
directive|define
name|STEP
value|0x04
end_define

begin_define
define|#
directive|define
name|SEQRESET
value|0x02
end_define

begin_define
define|#
directive|define
name|LOADRAM
value|0x01
end_define

begin_comment
comment|/*  * Sequencer RAM Data (p. 3-34)  * Single byte window into the Scratch Ram area starting at the address  * specified by SEQADDR0 and SEQADDR1.  To write a full word, simply write  * four bytes in sucessesion.  The SEQADDRs will increment after the most  * significant byte is written  */
end_comment

begin_define
define|#
directive|define
name|SEQRAM
value|0xc61
end_define

begin_comment
comment|/*  * Sequencer Address Registers (p. 3-35)   * Only the first bit of SEQADDR1 holds addressing information  */
end_comment

begin_define
define|#
directive|define
name|SEQADDR0
value|0xc62
end_define

begin_define
define|#
directive|define
name|SEQADDR1
value|0xc63
end_define

begin_define
define|#
directive|define
name|SEQADDR1_MASK
value|0x01
end_define

begin_comment
comment|/*  * Accumulator  * We cheat by passing arguments in the Accumulator up to the kernel driver  */
end_comment

begin_define
define|#
directive|define
name|ACCUM
value|0xc64
end_define

begin_comment
comment|/*  * Board Control (p. 3-43)  */
end_comment

begin_define
define|#
directive|define
name|BCTL
value|0xc84
end_define

begin_comment
comment|/*   RSVD			0xf0 */
end_comment

begin_define
define|#
directive|define
name|ACE
value|0x08
end_define

begin_comment
comment|/* Support for external processors */
end_comment

begin_comment
comment|/*   RSVD			0x06 */
end_comment

begin_define
define|#
directive|define
name|ENABLE
value|0x01
end_define

begin_comment
comment|/*  * Host Control (p. 3-47) R/W  * Overal host control of the device.    */
end_comment

begin_define
define|#
directive|define
name|HCNTRL
value|0xc87
end_define

begin_comment
comment|/*    UNUSED			0x80 */
end_comment

begin_define
define|#
directive|define
name|POWRDN
value|0x40
end_define

begin_comment
comment|/*    UNUSED			0x20 */
end_comment

begin_define
define|#
directive|define
name|SWINT
value|0x10
end_define

begin_define
define|#
directive|define
name|IRQMS
value|0x08
end_define

begin_define
define|#
directive|define
name|PAUSE
value|0x04
end_define

begin_define
define|#
directive|define
name|INTEN
value|0x02
end_define

begin_define
define|#
directive|define
name|CHIPRST
value|0x01
end_define

begin_define
define|#
directive|define
name|REQ_PAUSE
value|IRQMS | PAUSE | INTEN
end_define

begin_define
define|#
directive|define
name|UNPAUSE_274X
value|IRQMS | INTEN
end_define

begin_define
define|#
directive|define
name|UNPAUSE_284X
value|INTEN
end_define

begin_comment
comment|/*  * SCB Pointer (p. 3-49)  * Gate one of the four SCBs into the SCBARRAY window.  */
end_comment

begin_define
define|#
directive|define
name|SCBPTR
value|0xc90
end_define

begin_comment
comment|/*  * Interrupt Status (p. 3-50)  * Status for system interrupts  */
end_comment

begin_define
define|#
directive|define
name|INTSTAT
value|0xc91
end_define

begin_define
define|#
directive|define
name|SEQINT_MASK
value|0xf0
end_define

begin_comment
comment|/* SEQINT Status Codes */
end_comment

begin_define
define|#
directive|define
name|BAD_PHASE
value|0x00
end_define

begin_define
define|#
directive|define
name|MSG_REJECT
value|0x10
end_define

begin_define
define|#
directive|define
name|NO_IDENT
value|0x20
end_define

begin_define
define|#
directive|define
name|NO_MATCH
value|0x30
end_define

begin_define
define|#
directive|define
name|TRANS_RATE
value|0x40
end_define

begin_define
define|#
directive|define
name|BAD_STATUS
value|0x50
end_define

begin_define
define|#
directive|define
name|BRKADRINT
value|0x08
end_define

begin_define
define|#
directive|define
name|SCSIINT
value|0x04
end_define

begin_define
define|#
directive|define
name|CMDCMPLT
value|0x02
end_define

begin_define
define|#
directive|define
name|SEQINT
value|0x01
end_define

begin_define
define|#
directive|define
name|INT_PEND
value|SEQINT | SCSIINT | CMDCMPLT
end_define

begin_comment
comment|/* For polling */
end_comment

begin_comment
comment|/*  * Hard Error (p. 3-53)  * Reporting of catastrophic errors.  You usually cannot recover from   * these without a full board reset.  */
end_comment

begin_define
define|#
directive|define
name|ERROR
value|0xc92
end_define

begin_comment
comment|/*    UNUSED			0xf0 */
end_comment

begin_define
define|#
directive|define
name|PARERR
value|0x08
end_define

begin_define
define|#
directive|define
name|ILLOPCODE
value|0x04
end_define

begin_define
define|#
directive|define
name|ILLSADDR
value|0x02
end_define

begin_define
define|#
directive|define
name|ILLHADDR
value|0x01
end_define

begin_comment
comment|/*  * Clear Interrupt Status (p. 3-52)  */
end_comment

begin_define
define|#
directive|define
name|CLRINT
value|0xc92
end_define

begin_define
define|#
directive|define
name|CLRBRKADRINT
value|0x08
end_define

begin_define
define|#
directive|define
name|CLRINTSTAT
value|0x04
end_define

begin_comment
comment|/* UNDOCUMENTED - must be unpaused */
end_comment

begin_define
define|#
directive|define
name|CLRCMDINT
value|0x02
end_define

begin_define
define|#
directive|define
name|CLRSEQINT
value|0x01
end_define

begin_comment
comment|/*  * SCB Auto Increment (p. 3-59)  * Byte offset into the SCB Array and an optional bit to allow auto   * incrementing of the address during download and upload operations  */
end_comment

begin_define
define|#
directive|define
name|SCBCNT
value|0xc9a
end_define

begin_define
define|#
directive|define
name|SCBAUTO
value|0x80
end_define

begin_define
define|#
directive|define
name|SCBCNT_MASK
value|0x1f
end_define

begin_comment
comment|/*  * Queue In FIFO (p. 3-60)  * Input queue for queued SCBs (commands that the seqencer has yet to start)  */
end_comment

begin_define
define|#
directive|define
name|QINFIFO
value|0xc9b
end_define

begin_comment
comment|/*  * Queue In Count (p. 3-60)  * Number of queued SCBs  */
end_comment

begin_define
define|#
directive|define
name|QINCNT
value|0xc9c
end_define

begin_comment
comment|/*  * Queue Out FIFO (p. 3-61)  * Queue of SCBs that have completed and await the host  */
end_comment

begin_define
define|#
directive|define
name|QOUTFIFO
value|0xc9d
end_define

begin_comment
comment|/*  * Queue Out Count (p. 3-61)  * Number of queued SCBs in the Out FIFO  */
end_comment

begin_define
define|#
directive|define
name|QOUTCNT
value|0xc9e
end_define

begin_define
define|#
directive|define
name|SCBARRAY
value|0xca0
end_define

begin_comment
comment|/* ---------------- END AIC-7770 Register Definitions ----------------- */
end_comment

begin_comment
comment|/* ---------------------- Scratch RAM Offsets ------------------------- */
end_comment

begin_comment
comment|/* These offsets are either to values that are initialized by the board's  * BIOS or are specified by the Linux sequencer code.  If I can figure out  * how to read the EISA configuration info at probe time, the cards could  * be run without BIOS support installed  */
end_comment

begin_comment
comment|/*  * The sequencer will stick the frist byte of any rejected message here so  * we can see what is getting thrown away.  */
end_comment

begin_define
define|#
directive|define
name|HA_REJBYTE
value|0xc31
end_define

begin_comment
comment|/*  * Pending message flag  */
end_comment

begin_define
define|#
directive|define
name|HA_MSG_FLAGS
value|0xc35
end_define

begin_comment
comment|/*  * Length of pending message  */
end_comment

begin_define
define|#
directive|define
name|HA_MSG_LEN
value|0xc36
end_define

begin_comment
comment|/*  * message body  */
end_comment

begin_define
define|#
directive|define
name|HA_MSG_START
value|0xc37
end_define

begin_comment
comment|/* outgoing message body */
end_comment

begin_comment
comment|/*  * These are offsets into the card's scratch ram.  Some of the values are  * specified in the AHA2742 technical reference manual and are initialized   * by the BIOS at boot time.  */
end_comment

begin_define
define|#
directive|define
name|HA_ARG_1
value|0xc4c
end_define

begin_define
define|#
directive|define
name|HA_ARG_2
value|0xc4d
end_define

begin_define
define|#
directive|define
name|HA_RETURN_1
value|0xc4c
end_define

begin_define
define|#
directive|define
name|HA_SIGSTATE
value|0xc4e
end_define

begin_define
define|#
directive|define
name|HA_NEEDSDTR
value|0xc4f
end_define

begin_define
define|#
directive|define
name|HA_SCSICONF
value|0xc5a
end_define

begin_define
define|#
directive|define
name|INTDEF
value|0xc5c
end_define

begin_define
define|#
directive|define
name|HA_HOSTCONF
value|0xc5d
end_define

begin_define
define|#
directive|define
name|HA_SCBCOUNT
value|0xc56
end_define

begin_define
define|#
directive|define
name|ACTIVE_A
value|0xc57
end_define

begin_define
define|#
directive|define
name|MSG_ABORT
value|0x06
end_define

begin_comment
comment|/*  * Since the sequencer can disable pausing in a critical section, we  * must loop until it actually stops.   * XXX Should add a timeout in here!!  */
end_comment

begin_define
define|#
directive|define
name|PAUSE_SEQUENCER
parameter_list|(
name|ahc
parameter_list|)
define|\
value|outb(HCNTRL + ahc->baseport, REQ_PAUSE);   \ 				\         while ((inb(HCNTRL + ahc->baseport)& PAUSE) == 0)             \                         ;
end_define

begin_define
define|#
directive|define
name|UNPAUSE_SEQUENCER
parameter_list|(
name|ahc
parameter_list|)
define|\
value|outb( HCNTRL + ahc->baseport, ahc->unpause )
end_define

begin_comment
comment|/*  * Restart the sequencer program from address zero  */
end_comment

begin_define
define|#
directive|define
name|RESTART_SEQUENCER
parameter_list|(
name|ahc
parameter_list|)
define|\
value|do {                                    \                         outb( SEQCTL + ahc->baseport, SEQRESET );     \                 } while (inw(SEQADDR0 + ahc->baseport) != 0);     \                                                         \                 UNPAUSE_SEQUENCER(ahc);
end_define

begin_struct
struct|struct
name|ahc_dma_seg
block|{
name|physaddr
name|addr
decl_stmt|;
name|long
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The driver keeps up to four scb structures per card in memory.  Only the  * first 26 bytes of the structure are valid for the hardware, the rest used  * for driver level bookeeping.  The "__attribute ((packed))" tags ensure that  * gcc does not attempt to pad the long ints in the structure to word   * boundaries since the first 26 bytes of this structure must have the correct  * offsets for the hardware to find them.  The driver should be further   * optimized so that we only have to download the first 14 bytes since as long   * as we always use S/G, the last fields should be zero anyway.  Its mostly a   * matter of looking through the sequencer code and ensuring that those fields   * are cleared or loaded with a valid value before being read.  */
end_comment

begin_struct
struct|struct
name|scb
block|{
comment|/* ------------    Begin hardware supported fields    ---------------- */
comment|/*1*/
name|u_char
name|control
decl_stmt|;
define|#
directive|define
name|SCB_REJ_MDP
value|0x80
comment|/* Reject MDP message */
define|#
directive|define
name|SCB_DCE
value|0x40
comment|/* Disconnect enable */
define|#
directive|define
name|SCB_TE
value|0x20
comment|/* Tag enable */
define|#
directive|define
name|SCB_WAITING
value|0x06
define|#
directive|define
name|SCB_DIS
value|0x04
define|#
directive|define
name|SCB_TAG_TYPE
value|0x3
define|#
directive|define
name|SIMPLE_QUEUE
value|0x0
define|#
directive|define
name|HEAD_QUEUE
value|0x1
define|#
directive|define
name|OR_QUEUE
value|0x2
comment|/*2*/
name|u_char
name|target_channel_lun
decl_stmt|;
comment|/* 4/1/3 bits */
comment|/*3*/
name|u_char
name|SG_segment_count
decl_stmt|;
comment|/*7*/
name|physaddr
name|SG_list_pointer
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
comment|/*11*/
name|physaddr
name|cmdpointer
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
comment|/*12*/
name|u_char
name|cmdlen
decl_stmt|;
comment|/*14*/
name|u_char
name|RESERVED
index|[
literal|2
index|]
decl_stmt|;
comment|/* must be zero */
comment|/*15*/
name|u_char
name|target_status
decl_stmt|;
comment|/*18*/
name|u_char
name|residual_data_count
index|[
literal|3
index|]
decl_stmt|;
comment|/*19*/
name|u_char
name|residual_SG_segment_count
decl_stmt|;
comment|/*23*/
name|physaddr
name|data
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
comment|/*26*/
name|u_char
name|datalen
index|[
literal|3
index|]
decl_stmt|;
define|#
directive|define
name|SCB_SIZE
value|26
comment|/* amount to actually download */
if|#
directive|if
literal|0
comment|/* 	 *  No real point in transferring this to the 	 *  SCB registers. 	 */
block|unsigned char RESERVED[6];
endif|#
directive|endif
comment|/*-----------------end of hardware supported fields----------------*/
name|struct
name|scb
modifier|*
name|next
decl_stmt|;
comment|/* in free list */
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
comment|/* the scsi_xfer for this cmd */
name|int
name|flags
decl_stmt|;
name|int
name|position
decl_stmt|;
comment|/* Position in scbarray */
define|#
directive|define
name|SCB_FREE
value|0
define|#
directive|define
name|SCB_ACTIVE
value|1
define|#
directive|define
name|SCB_ABORTED
value|2
define|#
directive|define
name|SCB_IMMED
value|4
define|#
directive|define
name|SCB_IMMED_FAIL
value|8
define|#
directive|define
name|SCB_SENSE
value|16
name|struct
name|ahc_dma_seg
name|ahc_dma
index|[
name|AHC_NSEG
index|]
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|struct
name|scsi_sense
name|sense_cmd
decl_stmt|;
comment|/* SCSI command block */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ahc_data
block|{
name|ahc_type
name|type
decl_stmt|;
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|AHC_INIT
value|0x01;
name|int
name|baseport
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbarray
index|[
name|AHC_SCB_MAX
index|]
decl_stmt|;
comment|/* Mirror boards scbarray */
name|struct
name|scb
modifier|*
name|free_scb
decl_stmt|;
name|int
name|our_id
decl_stmt|;
comment|/* our scsi id */
name|int
name|vect
decl_stmt|;
name|struct
name|scb
modifier|*
name|immed_ecb
decl_stmt|;
comment|/* an outstanding immediete command */
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
name|int
name|numscbs
decl_stmt|;
name|u_char
name|maxscbs
decl_stmt|;
name|int
name|unpause
decl_stmt|;
block|}
modifier|*
name|ahcdata
index|[
name|NAHC
index|]
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|AHCDEBUG
end_ifdef

begin_function
name|void
name|ahc_print_scb
parameter_list|(
name|scb
parameter_list|)
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"scb:%x control:%x tcl:%x cmdlen:%d cmdpointer:%x\n"
argument_list|,
name|scb
argument_list|,
name|scb
operator|->
name|control
argument_list|,
name|scb
operator|->
name|target_channel_lun
argument_list|,
name|scb
operator|->
name|cmdlen
argument_list|,
name|scb
operator|->
name|cmdpointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        datlen:%d data:%x res:%x segs:%x segp:%x\n"
argument_list|,
name|scb
operator|->
name|datalen
index|[
literal|2
index|]
operator|<<
literal|16
operator||
name|scb
operator|->
name|datalen
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|scb
operator|->
name|datalen
index|[
literal|0
index|]
argument_list|,
name|scb
operator|->
name|data
argument_list|,
name|scb
operator|->
name|RESERVED
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|scb
operator|->
name|RESERVED
index|[
literal|0
index|]
argument_list|,
name|scb
operator|->
name|SG_segment_count
argument_list|,
name|scb
operator|->
name|SG_list_pointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	sg_addr:%x sg_len:%d\n"
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
literal|0
index|]
operator|.
name|addr
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	size:%d\n"
argument_list|,
operator|(
name|int
operator|)
operator|&
operator|(
name|scb
operator|->
name|next
operator|)
operator|-
operator|(
name|int
operator|)
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_print_active_scb
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
name|int
name|cur_scb_offset
decl_stmt|;
name|int
name|port
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|PAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|cur_scb_offset
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|port
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_print_scb
argument_list|(
name|ahc
operator|->
name|scbarray
index|[
name|cur_scb_offset
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PARERR
value|0x08
end_define

begin_define
define|#
directive|define
name|ILLOPCODE
value|0x04
end_define

begin_define
define|#
directive|define
name|ILLSADDR
value|0x02
end_define

begin_define
define|#
directive|define
name|ILLHADDR
value|0x01
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
block|{
name|u_char
name|errno
decl_stmt|;
name|char
modifier|*
name|errmesg
decl_stmt|;
block|}
name|hard_error
index|[]
init|=
block|{
name|ILLHADDR
block|,
literal|"Illegal Host Access"
block|,
name|ILLSADDR
block|,
literal|"Illegal Sequencer Address referrenced"
block|,
name|ILLOPCODE
block|,
literal|"Illegal Opcode in sequencer program"
block|,
name|PARERR
block|,
literal|"Sequencer Ram Parity Error"
block|, }
struct|;
end_struct

begin_comment
comment|/*  * Valid SCSIRATE values.  (p. 3-17)  * Provides a mapping of tranfer periods in ns to the proper value to  * stick in the scsiscfr reg to use that transfer rate.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|short
name|sxfr
decl_stmt|;
name|short
name|period
decl_stmt|;
comment|/* in ns */
name|char
modifier|*
name|rate
decl_stmt|;
block|}
name|ahc_syncrates
index|[]
init|=
block|{
literal|0x00
block|,
literal|100
block|,
literal|"10.0"
block|,
literal|0x10
block|,
literal|125
block|,
literal|"8.0"
block|,
literal|0x20
block|,
literal|150
block|,
literal|"6.67"
block|,
literal|0x30
block|,
literal|175
block|,
literal|"5.7"
block|,
literal|0x40
block|,
literal|200
block|,
literal|"5.0"
block|,
literal|0x50
block|,
literal|225
block|,
literal|"4.4"
block|,
literal|0x60
block|,
literal|250
block|,
literal|"4.0"
block|,
literal|0x70
block|,
literal|275
block|,
literal|"3.6"
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|ahc_num_syncrates
init|=
sizeof|sizeof
argument_list|(
name|ahc_syncrates
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ahc_syncrates
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ahcprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_char
name|sig_id
index|[
literal|4
index|]
decl_stmt|;
name|ahc_sig
name|valid_ids
index|[]
init|=
block|{
comment|/* Entries of other tested adaptors should be added here */
name|AHC_274
block|,
literal|0x71
block|,
comment|/*274x, Card*/
name|AHC_274
block|,
literal|0x70
block|,
comment|/*274x, Motherboard*/
name|AHC_284
block|,
literal|0x56
block|,
comment|/*284x, BIOS enabled*/
name|AHC_284
block|,
literal|0x57
block|,
comment|/*284x, BIOS disabled*/
block|}
decl_stmt|;
name|ahc_slot
operator|++
expr_stmt|;
while|while
condition|(
name|ahc_slot
operator|<=
name|MAX_SLOTS
condition|)
block|{
name|port
operator|=
literal|0x1000
operator|*
name|ahc_slot
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sig_id
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/*  			* An outb is required to prime these registers on 			* VL cards 			*/
name|outb
argument_list|(
name|port
operator|+
name|HID0
argument_list|,
name|HID0
operator|+
name|i
argument_list|)
expr_stmt|;
name|sig_id
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|port
operator|+
name|HID0
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sig_id
index|[
literal|0
index|]
operator|==
literal|0xff
condition|)
block|{
name|ahc_slot
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Check manufacturer's ID. */
if|if
condition|(
operator|(
name|CHAR1
argument_list|(
name|sig_id
index|[
literal|0
index|]
argument_list|,
name|sig_id
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'A'
operator|)
operator|&&
operator|(
name|CHAR2
argument_list|(
name|sig_id
index|[
literal|0
index|]
argument_list|,
name|sig_id
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'D'
operator|)
operator|&&
operator|(
name|CHAR3
argument_list|(
name|sig_id
index|[
literal|0
index|]
argument_list|,
name|sig_id
index|[
literal|1
index|]
argument_list|)
operator|==
literal|'P'
operator|)
operator|&&
operator|(
name|sig_id
index|[
literal|2
index|]
operator|==
literal|0x77
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|valid_ids
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ahc_sig
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sig_id
index|[
literal|3
index|]
operator|==
name|valid_ids
index|[
name|i
index|]
operator|.
name|id
condition|)
block|{
name|dev
operator|->
name|id_iobase
operator|=
name|port
expr_stmt|;
return|return
name|ahcprobe1
argument_list|(
name|dev
argument_list|,
name|valid_ids
index|[
name|i
index|]
operator|.
name|type
argument_list|)
return|;
block|}
block|}
name|ahc_slot
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the device can be found at the port given  * and if so, determine configuration and set it up for further work.  * As an argument, takes the isa_device structure from  * autoconf.c.  */
end_comment

begin_function
name|int
name|ahcprobe1
parameter_list|(
name|dev
parameter_list|,
name|type
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
name|ahc_type
name|type
decl_stmt|;
block|{
comment|/*          * find unit and check we have that many defined          */
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NAHC
condition|)
block|{
name|printf
argument_list|(
literal|"ahc: unit number (%d) too high\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*          * Allocate a storage area for us          */
if|if
condition|(
name|ahcdata
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: memory already allocated\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ahc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahc
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|ahc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_data
argument_list|)
argument_list|)
expr_stmt|;
name|ahcdata
index|[
name|unit
index|]
operator|=
name|ahc
expr_stmt|;
name|ahc
operator|->
name|baseport
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
name|ahc
operator|->
name|type
operator|=
name|type
expr_stmt|;
comment|/*          * Try to initialize a unit at this location          * reset the AIC-7770, read its registers,          * and fill in the dev structure accordingly          */
if|if
condition|(
name|ahc_init
argument_list|(
name|unit
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ahcdata
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|ahc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*          * If it's there, put in it's interrupt vectors          */
name|dev
operator|->
name|id_irq
operator|=
operator|(
literal|1
operator|<<
name|ahc
operator|->
name|vect
operator|)
expr_stmt|;
name|dev
operator|->
name|id_drq
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* use EISA dma */
name|ahc_unit
operator|++
expr_stmt|;
return|return
name|IO_EISASIZE
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the valid period to SCSIRATE conversion in our table.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_scsirate
parameter_list|(
name|scsirate
parameter_list|,
name|period
parameter_list|,
name|offset
parameter_list|,
name|unit
parameter_list|,
name|target
parameter_list|)
name|u_char
modifier|*
name|scsirate
decl_stmt|;
name|u_char
name|period
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|target
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc_num_syncrates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|period
operator|-
name|period
operator|)
operator|>=
literal|0
condition|)
block|{
operator|*
name|scsirate
operator|=
operator|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|sxfr
operator|)
operator||
operator|(
name|offset
operator|&
literal|0x0f
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHCDEBUG
name|printf
argument_list|(
literal|"ahc%d: target %d synchronous at %sMb/s\n"
argument_list|,
name|unit
argument_list|,
name|target
argument_list|,
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|rate
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AHCDEBUG */
return|return;
block|}
block|}
comment|/* Default to asyncronous transfer */
operator|*
name|scsirate
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AHCDEBUG
name|printf
argument_list|(
literal|"ahc%d: target %d using asyncronous transfers\n"
argument_list|,
name|unit
argument_list|,
name|target
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AHCDEBUG */
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|ahc_attach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
comment|/*          * fill in the prototype scsi_link.          */
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|unit
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|ahc_switch
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|ahc_dev
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|flags
operator|=
name|DEBUGLEVEL
expr_stmt|;
comment|/*  	 * Here, we should really fill in up to two different sc_links, 	 * making use of the extra fields in the sc_link structure so  	 * we can know which channel any requests are for.  Then its just 	 * a matter of doing a scsi_attachdevs to both instead of the one. 	 * This should be done when we get or write sequencer code that  	 * supports more than one channel. XXX 	 */
comment|/*          * ask the adapter what subunits are present          */
name|scsi_attachdevs
argument_list|(
operator|&
operator|(
name|ahc
operator|->
name|sc_link
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|ahc_send_scb
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|int
name|old_scbptr
decl_stmt|;
name|int
name|base
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|PAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|old_scbptr
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|base
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|base
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|base
argument_list|,
name|SCBAUTO
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|SCBARRAY
operator|+
name|base
argument_list|,
name|scb
argument_list|,
name|SCB_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|QINFIFO
operator|+
name|base
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|base
argument_list|,
name|old_scbptr
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_getscb
parameter_list|(
name|base
parameter_list|,
name|scb
parameter_list|)
name|int
name|base
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|outb
argument_list|(
name|SCBCNT
operator|+
name|base
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* SCBAUTO */
name|insb
argument_list|(
name|SCBARRAY
operator|+
name|base
argument_list|,
name|scb
argument_list|,
name|SCB_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*                * Catch an interrupt from the adaptor  */
end_comment

begin_function
name|int
name|ahcintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|intstat
decl_stmt|;
name|u_char
name|status
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|port
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
init|=
name|NULL
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|NULL
decl_stmt|;
name|intstat
operator|=
name|inb
argument_list|(
name|INTSTAT
operator|+
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|intstat
operator|&
name|BRKADRINT
condition|)
block|{
comment|/* We upset the sequencer :-( */
comment|/* Lookup the error message */
name|int
name|i
decl_stmt|,
name|error
init|=
name|inb
argument_list|(
name|ERROR
operator|+
name|port
argument_list|)
decl_stmt|;
name|int
name|num_errors
init|=
sizeof|sizeof
argument_list|(
name|hard_error
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|hard_error
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|error
operator|!=
literal|1
operator|&&
name|i
operator|<
name|num_errors
condition|;
name|i
operator|++
control|)
name|error
operator|>>=
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"ahc%d: brkadrint, %s at seqaddr = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|hard_error
index|[
name|i
index|]
operator|.
name|errmesg
argument_list|,
name|inw
argument_list|(
name|SEQADDR0
operator|+
name|port
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intstat
operator|&
name|SEQINT
condition|)
block|{
name|unsigned
name|char
name|transfer
decl_stmt|,
name|offset
decl_stmt|,
name|rate
decl_stmt|;
switch|switch
condition|(
name|intstat
operator|&
name|SEQINT_MASK
condition|)
block|{
case|case
name|BAD_PHASE
case|:
name|panic
argument_list|(
literal|"ahc%d: unknown scsi bus phase.  "
literal|"Attempting to continue\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REJECT
case|:
name|printf
argument_list|(
literal|"ahc%d: Warning - "
literal|"message reject, message type: 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|inb
argument_list|(
name|HA_REJBYTE
operator|+
name|port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_IDENT
case|:
name|panic
argument_list|(
literal|"ahc%d: No IDENTIFY message from reconnecting "
literal|"target %d\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|inb
argument_list|(
name|SELID
operator|+
name|port
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_MATCH
case|:
block|{
name|u_char
name|active
decl_stmt|;
name|int
name|target
init|=
operator|(
name|inb
argument_list|(
name|SELID
operator|+
name|port
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0x4
decl_stmt|;
name|printf
argument_list|(
literal|"ahc%d: no active SCB for reconnecting "
literal|"target %d - issuing ABORT\n"
argument_list|,
name|unit
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|active
operator|=
name|inb
argument_list|(
name|HA_SCBCOUNT
operator|+
name|port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCBCOUNT is %d\n"
argument_list|,
name|active
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|active
operator|=
name|inb
argument_list|(
name|ACTIVE_A
operator|+
name|port
argument_list|)
expr_stmt|;
name|active
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
name|target
operator|)
expr_stmt|;
name|outb
argument_list|(
name|ACTIVE_A
operator|+
name|port
argument_list|,
name|active
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|port
argument_list|,
name|CLRSELTIMEO
argument_list|)
expr_stmt|;
name|RESTART_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TRANS_RATE
case|:
comment|/*  			 * Help the sequencer to translate the negotiated                          * transfer rate.  Transfer is 1/4 the period 			 * in ns as is returned by the sync negotiation 			 * message.  So, we must multiply by four                          */
name|transfer
operator|=
name|inb
argument_list|(
name|HA_ARG_1
operator|+
name|port
argument_list|)
operator|<<
literal|2
expr_stmt|;
comment|/* The bottom half of SCSIXFER*/
name|offset
operator|=
name|inb
argument_list|(
name|HA_ARG_2
operator|+
name|port
argument_list|)
expr_stmt|;
name|ahc_scsirate
argument_list|(
operator|&
name|rate
argument_list|,
name|transfer
argument_list|,
name|offset
argument_list|,
name|unit
argument_list|,
name|inb
argument_list|(
name|SCSIID
operator|+
name|port
argument_list|)
operator|>>
literal|0x4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_RETURN_1
operator|+
name|port
argument_list|,
name|rate
argument_list|)
expr_stmt|;
break|break;
case|case
name|BAD_STATUS
case|:
block|{
name|int
name|scb_index
decl_stmt|,
name|saved_scb_index
decl_stmt|;
comment|/* The sequencer will notify us when a command                            * has an error that would be of interest to                            * the kernel.  This allows us to leave the sequencer                            * running in the common case of command completes                            * without error.                            */
name|scb_index
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|port
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|||
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: ahcintr - referenced scb not "
literal|"valid during seqint 0x%x scb(%d)\n"
argument_list|,
name|unit
argument_list|,
name|intstat
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
goto|goto
name|clear
goto|;
block|}
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
name|ahc_getscb
argument_list|(
name|port
argument_list|,
name|scb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHCDEBUG
if|if
condition|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|==
name|DEBUGTARG
condition|)
name|ahc_print_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xs
operator|->
name|status
operator|=
name|scb
operator|->
name|target_status
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
operator|(
operator|(
name|scb
operator|->
name|residual_data_count
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|scb
operator|->
name|residual_data_count
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|scb
operator|->
name|residual_data_count
index|[
literal|0
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|scb
operator|->
name|target_status
condition|)
block|{
case|case
name|SCSI_OK
case|:
name|printf
argument_list|(
literal|"ahc%d: Interrupted for staus of "
literal|"0???\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_CHECK
case|:
ifdef|#
directive|ifdef
name|AHCDEBUG
name|printf
argument_list|(
literal|"ahc%d: SCSI Check requested\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*Priliminary code for requesting Sense */
comment|/* Enable at your own risk */
if|#
directive|if
name|STILL_NEEDS_TESTING
if|if
condition|(
operator|(
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
operator|)
operator|&&
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
condition|)
block|{
name|struct
name|ahc_dma_seg
modifier|*
name|sg
init|=
name|scb
operator|->
name|ahc_dma
decl_stmt|;
name|struct
name|scsi_sense
modifier|*
name|sc
init|=
operator|&
operator|(
name|scb
operator|->
name|sense_cmd
operator|)
decl_stmt|;
name|int
name|scbsave
index|[
name|AHC_SCB_MAX
index|]
decl_stmt|,
name|i
decl_stmt|;
name|int
name|queued
init|=
name|inb
argument_list|(
name|QINCNT
operator|+
name|port
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|AHCDEBUG
name|printf
argument_list|(
literal|"SENDING SENSE.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|scb
argument_list|,
name|SCB_SIZE
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_SENSE
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
name|sc
operator|->
name|op_code
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|sc
operator|->
name|byte2
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|<<
literal|5
expr_stmt|;
name|sc
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|scb
operator|->
name|cmdlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
expr_stmt|;
name|scb
operator|->
name|cmdpointer
operator|=
name|KVTOPHYS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|scb
operator|->
name|SG_segment_count
operator|=
literal|1
expr_stmt|;
name|scb
operator|->
name|SG_list_pointer
operator|=
name|KVTOPHYS
argument_list|(
name|sg
argument_list|)
expr_stmt|;
name|sg
operator|->
name|addr
operator|=
name|KVTOPHYS
argument_list|(
operator|&
name|xs
operator|->
name|sense
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
comment|/* 					 * Reinsert us at head of 					 * queue 					 */
name|outb
argument_list|(
name|SCBCNT
operator|+
name|port
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|SCBARRAY
operator|+
name|port
argument_list|,
name|scb
argument_list|,
name|SCB_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|queued
condition|;
name|i
operator|++
control|)
name|scbsave
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|QINFIFO
operator|+
name|port
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|QINFIFO
operator|+
name|port
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|queued
condition|;
name|i
operator|++
control|)
name|outb
argument_list|(
name|QINFIFO
operator|+
name|port
argument_list|,
name|scbsave
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* New lease on life */
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
goto|goto
name|clear
goto|;
block|}
endif|#
directive|endif
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
case|case
name|SCSI_BUSY
case|:
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
name|printf
argument_list|(
literal|"ahc%d: Target Busy\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|AHCDEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"unexpected targ_status: %x\n"
argument_list|,
name|scb
operator|->
name|target_status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*AHCDEBUG */
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
block|}
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"ahc: seqint, "
literal|"intstat = 0x%x, scsisigi = 0x%x\n"
argument_list|,
name|intstat
argument_list|,
name|inb
argument_list|(
name|SCSISIGI
operator|+
name|port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/*                              * Clear the upper byte that holds SEQINT status                  * codes and clear the SEQINT bit.                  */
name|clear
label|:
name|outb
argument_list|(
name|CLRINT
operator|+
name|port
argument_list|,
name|CLRSEQINT
argument_list|)
expr_stmt|;
comment|/*                              *  The sequencer is paused immediately on                  *  a SEQINT, so we should restart it when                  *  we leave this section.                   */
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intstat
operator|&
name|SCSIINT
condition|)
block|{
name|int
name|scb_index
init|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|port
argument_list|)
decl_stmt|;
name|status
operator|=
name|inb
argument_list|(
name|SSTAT1
operator|+
name|port
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|||
name|scb
operator|->
name|flags
operator|!=
name|SCB_ACTIVE
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: ahcintr - referenced scb not "
literal|"valid during scsiint 0x%x scb(%d)\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|port
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|port
argument_list|,
name|CLRINTSTAT
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
goto|goto
name|cmdcomplete
goto|;
block|}
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|SELTO
condition|)
block|{
name|u_char
name|active
decl_stmt|;
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
comment|/*  			 * Clear any pending messages for the timed out 			 * target, and mark the target as free 			 */
name|outb
argument_list|(
name|HA_MSG_FLAGS
operator|+
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|active
operator|=
name|inb
argument_list|(
name|ACTIVE_A
operator|+
name|port
argument_list|)
expr_stmt|;
name|active
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|)
expr_stmt|;
name|outb
argument_list|(
name|ACTIVE_A
operator|+
name|port
argument_list|,
name|active
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|port
argument_list|,
name|CLRSELTIMEO
argument_list|)
expr_stmt|;
name|RESTART_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|port
argument_list|,
name|CLRINTSTAT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|SCSIPERR
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: parity error on channel A "
literal|"target %d, lun %d\n"
argument_list|,
name|unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|port
argument_list|,
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|port
argument_list|,
name|CLRINTSTAT
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|BUSFREE
condition|)
block|{
if|#
directive|if
literal|0
comment|/*  		      * Has seen busfree since selection, i.e.                       * a "spurious" selection. Shouldn't happen.                       */
block|printf("ahc: unexpected busfree\n");                        xs->error = XS_DRIVER_STUFFUP;                        outb(CLRSINT1 + port, BUSFREE);
comment|/* CLRBUSFREE */
endif|#
directive|endif
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ahc%d: Unknown SCSIINT. Status = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|port
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|port
argument_list|,
name|CLRINTSTAT
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
block|{
comment|/* We want to process the command */
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
block|}
name|cmdcomplete
label|:
if|if
condition|(
name|intstat
operator|&
name|CMDCMPLT
condition|)
block|{
name|int
name|scb_index
decl_stmt|,
name|saved_scb_index
decl_stmt|;
do|do
block|{
name|scb_index
operator|=
name|inb
argument_list|(
name|QOUTFIFO
operator|+
name|port
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|||
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: WARNING "
literal|"no command for scb %d (cmdcmplt)\n"
argument_list|,
name|unit
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|port
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|outb
argument_list|(
name|CLRINT
operator|+
name|port
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inb
argument_list|(
name|QOUTCNT
operator|+
name|port
argument_list|)
condition|)
do|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * We have a scb which has been processed by the  * adaptor, now we look to see how the operation  * went.  */
end_comment

begin_function
name|void
name|ahc_done
parameter_list|(
name|unit
parameter_list|,
name|scb
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|scb
operator|->
name|xs
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"ahc_done\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*          * Put the results of the operation          * into the xfer and call whoever started it          */
if|if
condition|(
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
operator|&&
operator|!
operator|(
name|xs
operator|->
name|error
operator|==
name|XS_SENSE
operator|)
condition|)
block|{
comment|/* All went correctly  OR errors expected */
name|xs
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|ahc_init
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|port
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|int
name|intdef
decl_stmt|;
comment|/* 	 * Assume we have a board at this stage 	 * Find out the configured interupt and the card type. 	 */
name|printf
argument_list|(
literal|"ahc%d: scb %d; SCB_SIZE %d, ahc_dma %d\n"
argument_list|,
name|unit
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|,
name|SCB_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ahc%d: reading board settings\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HCNTRL
operator|+
name|port
argument_list|,
name|CHIPRST
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ahc
operator|->
name|type
condition|)
block|{
case|case
name|AHC_274
case|:
name|printf
argument_list|(
literal|"ahc%d: 274x"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|unpause
operator|=
name|UNPAUSE_274X
expr_stmt|;
name|ahc
operator|->
name|maxscbs
operator|=
literal|0x4
expr_stmt|;
break|break;
case|case
name|AHC_284
case|:
name|printf
argument_list|(
literal|"ahc%d: 284x"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|unpause
operator|=
name|UNPAUSE_284X
expr_stmt|;
name|ahc
operator|->
name|maxscbs
operator|=
literal|0x4
expr_stmt|;
break|break;
default|default:
block|}
empty_stmt|;
comment|/* Determine channel configuration. */
switch|switch
condition|(
name|inb
argument_list|(
name|SBLKCTL
operator|+
name|port
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|" Single Channel, "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|" Wide SCSI configuration - Unsupported\n"
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|type
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
case|case
literal|8
case|:
name|printf
argument_list|(
literal|" Twin Channel - ignoring channel B, "
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|type
operator|+=
literal|1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" Unsupported adapter type.  Ignoring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|intdef
operator|=
name|inb
argument_list|(
name|INTDEF
operator|+
name|port
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intdef
operator|&
literal|0xf
condition|)
block|{
case|case
literal|9
case|:
name|ahc
operator|->
name|vect
operator|=
literal|9
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|ahc
operator|->
name|vect
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|ahc
operator|->
name|vect
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|ahc
operator|->
name|vect
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|ahc
operator|->
name|vect
operator|=
literal|14
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|ahc
operator|->
name|vect
operator|=
literal|15
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"illegal irq setting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"int=%d, "
argument_list|,
name|ahc
operator|->
name|vect
argument_list|)
expr_stmt|;
comment|/* who are we on the scsi bus? */
name|ahc
operator|->
name|our_id
operator|=
operator|(
name|inb
argument_list|(
name|HA_SCSICONF
operator|+
name|port
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCSI Id=%d\n"
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
comment|/* 	 * Load the Sequencer program and Enable the adapter          */
name|printf
argument_list|(
literal|"ahc%d: Downloading Sequencer Program\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ahc_loadseq
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|BCTL
operator|+
name|port
argument_list|,
name|ENABLE
argument_list|)
expr_stmt|;
comment|/* Reset the SCSI bus.  Is this necessary? */
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|port
argument_list|,
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt syncronous negotiation for all targets. 	 * Clear the pending messages flag 	 */
name|outb
argument_list|(
name|HA_NEEDSDTR
operator|+
name|port
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_MSG_FLAGS
operator|+
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCBCOUNT == %d\n"
argument_list|,
name|ahc
operator|->
name|maxscbs
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_SCBCOUNT
operator|+
name|port
argument_list|,
name|ahc
operator|->
name|maxscbs
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ACTIVE_A
operator|+
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we are going and return (to probe) 	 */
name|ahc
operator|->
name|flags
operator||=
name|AHC_INIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahcminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
comment|/* Even though the card can transfer up to 16megs per command  * we are limited by the number of segments in the dma segment  * list that we can hold.  The worst case is that all pages are  * discontinuous physically, hense the "page per segment" limit  * enforced here.  */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|AHC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|AHC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * start a scsi operation given the command and  * the data address, target, and lun all of which   * are stored in the scsi_xfer struct  */
end_comment

begin_function
name|int32
name|ahc_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|scb
init|=
name|NULL
decl_stmt|;
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
name|int
name|seg
decl_stmt|;
comment|/* scatter gather seg being worked on */
name|int
name|thiskv
decl_stmt|;
name|physaddr
name|thisphys
decl_stmt|,
name|nextphys
decl_stmt|;
name|int
name|unit
init|=
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
decl_stmt|;
name|int
name|bytes_this_seg
decl_stmt|,
name|bytes_this_page
decl_stmt|,
name|datalen
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"ahc_scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*           * get an scb to use. If the transfer          * is from a buf (possibly from interrupt time)          * then we can't allow it to sleep          */
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
name|flags
operator||=
operator|(
name|SCSI_NOSLEEP
operator|)
expr_stmt|;
comment|/* just to be sure */
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: Already done?"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: Not in use?"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|scb
operator|=
name|ahc_get_scb
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"start scb(%x)\n"
operator|,
name|scb
operator|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|xs
operator|=
name|xs
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
comment|/* AR: Needs Implementation */
name|printf
argument_list|(
literal|"ahc0: SCSI_RESET called.\n"
argument_list|)
expr_stmt|;
block|}
comment|/*          * Put all the arguments for the xfer in the scb          */
comment|/* Note, Linux sequencer code does not support extra channels */
name|scb
operator|->
name|target_channel_lun
operator|=
operator|(
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|<<
literal|4
operator|)
operator|&
literal|0xF0
operator|)
operator||
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|&
literal|0x7
expr_stmt|;
name|scb
operator|->
name|cmdlen
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
name|scb
operator|->
name|cmdpointer
operator|=
name|KVTOPHYS
argument_list|(
name|xs
operator|->
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|datalen
condition|)
block|{
comment|/* should use S/G only if not zero length */
name|scb
operator|->
name|SG_list_pointer
operator|=
name|KVTOPHYS
argument_list|(
name|scb
operator|->
name|ahc_dma
argument_list|)
expr_stmt|;
name|sg
operator|=
name|scb
operator|->
name|ahc_dma
expr_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
block|{
comment|/*                          * Set up the scatter gather block                          */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"%d @0x%x:- "
operator|,
name|xs
operator|->
name|datalen
operator|,
name|xs
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|thiskv
operator|=
operator|(
name|int
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|AHC_NSEG
operator|)
condition|)
block|{
name|bytes_this_seg
operator|=
literal|0
expr_stmt|;
comment|/* put in the base address */
name|sg
operator|->
name|addr
operator|=
name|thisphys
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"0x%x"
operator|,
name|thisphys
operator|)
argument_list|)
expr_stmt|;
comment|/* do it at least once */
name|nextphys
operator|=
name|thisphys
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|thisphys
operator|==
name|nextphys
operator|)
condition|)
block|{
comment|/* 					 * This page is contiguous (physically)  					 * with the the last, just extend the  					 * length 					 */
comment|/* how far to the end of the page */
name|nextphys
operator|=
operator|(
name|thisphys
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
name|bytes_this_page
operator|=
name|nextphys
operator|-
name|thisphys
expr_stmt|;
comment|/**** or the data ****/
name|bytes_this_page
operator|=
name|min
argument_list|(
name|bytes_this_page
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|bytes_this_seg
operator|+=
name|bytes_this_page
expr_stmt|;
name|datalen
operator|-=
name|bytes_this_page
expr_stmt|;
comment|/* get more ready for the next page */
name|thiskv
operator|=
operator|(
name|thiskv
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
block|}
comment|/*                                  * next page isn't contiguous, finish the seg                                  */
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"(0x%x)"
operator|,
name|bytes_this_seg
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|bytes_this_seg
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
block|}
comment|/*end of iov/kv decision */
name|scb
operator|->
name|SG_segment_count
operator|=
name|seg
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* there's still data, must have run out of segs! */
name|printf
argument_list|(
literal|"ahc_scsi_cmd%d: more than %d DMA segs\n"
argument_list|,
name|unit
argument_list|,
name|AHC_NSEG
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
comment|/*  else No data xfer, use non S/G values  	 *  the SG_segment_count and SG_list_pointer are pre-zeroed, so  	 *  we don't have to do anything 	 */
comment|/*                                         * Usually return SUCCESSFULLY QUEUED          */
ifdef|#
directive|ifdef
name|AHCDEBUG
if|if
condition|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|==
name|DEBUGTARG
condition|)
name|ahc_print_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_sent\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
comment|/*                                        * If we can't use interrupts, poll on completion          */
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_wait\n"
operator|)
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ahc_poll
argument_list|(
name|unit
argument_list|,
name|xs
operator|->
name|timeout
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"cmd fail\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cmd fail\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Abort called.  Someone implement me please!\n"
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|)
do|;
comment|/* something (?) else finished */
if|if
condition|(
name|xs
operator|->
name|error
condition|)
block|{
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*        * Return some information to the caller about  * the adapter and it's capabilities.    */
end_comment

begin_function
name|u_int32
name|ahc_adapter_info
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
return|return
operator|(
literal|2
operator|)
return|;
comment|/* 2 outstanding requests at a time per device */
block|}
end_function

begin_comment
comment|/*  * A scb (and hence an scb entry on the board is put onto the  * free list.  */
end_comment

begin_function
name|void
name|ahc_free_scb
parameter_list|(
name|unit
parameter_list|,
name|scb
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|unsigned
name|int
name|opri
init|=
literal|0
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|scb
operator|->
name|next
operator|=
name|ahc
operator|->
name|free_scb
expr_stmt|;
name|ahc
operator|->
name|free_scb
operator|=
name|scb
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_FREE
expr_stmt|;
comment|/*          * If there were none, wake abybody waiting for          * one to come free, starting with queued entries          */
if|if
condition|(
operator|!
name|scb
operator|->
name|next
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahc
operator|->
name|free_scb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free scb  * If there are none, see if we can allocate a  * new one.  Otherwise either return an error or sleep  */
end_comment

begin_function
name|struct
name|scb
modifier|*
name|ahc_get_scb
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
block|{
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
name|unsigned
name|opri
init|=
literal|0
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|int
name|position
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/*          * If we can and have to, sleep waiting for one to come free          * but only if we can't allocate a new one.          */
while|while
condition|(
operator|!
operator|(
name|scbp
operator|=
name|ahc
operator|->
name|free_scb
operator|)
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|numscbs
operator|<
name|ahc
operator|->
name|maxscbs
condition|)
block|{
name|scbp
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbp
condition|)
block|{
name|bzero
argument_list|(
name|scbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|scbp
operator|->
name|position
operator|=
name|ahc
operator|->
name|numscbs
expr_stmt|;
name|ahc
operator|->
name|numscbs
operator|++
expr_stmt|;
name|scbp
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
comment|/* 				 * Place in the scbarray 				 * Never is removed.  Position 				 * in ahc->scbarray is the scbarray 				 * position on the board we will 				 * load it into. 				 */
name|ahc
operator|->
name|scbarray
index|[
name|scbp
operator|->
name|position
index|]
operator|=
name|scbp
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ahc%d: Can't malloc SCB\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
goto|goto
name|gottit
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahc
operator|->
name|free_scb
argument_list|,
name|PRIBIO
argument_list|,
literal|"ahcscb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|scbp
condition|)
block|{
comment|/* Get SCB from from free list */
name|ahc
operator|->
name|free_scb
operator|=
name|scbp
operator|->
name|next
expr_stmt|;
comment|/* preserve the position */
name|position
operator|=
name|scbp
operator|->
name|position
expr_stmt|;
name|bzero
argument_list|(
name|scbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|scbp
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
name|scbp
operator|->
name|position
operator|=
name|position
expr_stmt|;
block|}
name|gottit
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|scbp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_loadseq
parameter_list|(
name|port
parameter_list|)
name|int
name|port
decl_stmt|;
block|{
specifier|static
name|unsigned
name|char
name|seqprog
index|[]
init|=
block|{
include|#
directive|include
file|<aha274x_seq.h>
block|}
decl_stmt|;
name|outb
argument_list|(
name|SEQCTL
operator|+
name|port
argument_list|,
name|PERRORDIS
operator||
name|SEQRESET
operator||
name|LOADRAM
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|SEQRAM
operator|+
name|port
argument_list|,
name|seqprog
argument_list|,
sizeof|sizeof
argument_list|(
name|seqprog
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SEQCTL
operator|+
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* XXX Need a timer here? */
name|outb
argument_list|(
name|SEQCTL
operator|+
name|port
argument_list|,
name|SEQRESET
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inw
argument_list|(
name|SEQADDR0
operator|+
name|port
argument_list|)
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/*                * Function to poll for command completion when in poll mode  */
end_comment

begin_function
name|int
name|ahc_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
comment|/* in msec  */
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|port
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|int
name|stport
init|=
name|INTSTAT
operator|+
name|port
decl_stmt|;
name|retry
label|:
while|while
condition|(
operator|--
name|wait
condition|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|stport
argument_list|)
operator|&
name|INT_PEND
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: board not responding\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ahcintr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_timeout
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
init|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|cur_scb_offset
decl_stmt|,
name|port
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|unit
operator|=
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
expr_stmt|;
name|ahc
operator|=
name|ahcdata
index|[
name|unit
index|]
expr_stmt|;
name|port
operator|=
name|ahc
operator|->
name|baseport
expr_stmt|;
name|printf
argument_list|(
literal|"ahc%d: target %d, lun %d (%s%d) timed out "
argument_list|,
name|unit
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|dev_unit
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|AHCDEBUG
block|if (ahc_debug& AHC_SHOWMISC)                 ahc_print_active_scb(unit);
endif|#
directive|endif
comment|/*AHCDEBUG */
endif|#
directive|endif
comment|/*          * If it's immediate, don't try abort it          */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_IMMED
condition|)
block|{
name|scb
operator|->
name|xs
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* I MEAN IT ! */
name|scb
operator|->
name|flags
operator||=
name|SCB_IMMED_FAIL
expr_stmt|;
name|ahc_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*          * If it has been through before, then          * a previous abort has failed, don't          * try abort again          */
if|if
condition|(
name|scb
operator|->
name|flags
operator|==
name|SCB_ABORTED
condition|)
block|{
comment|/*                  * abort timed out                  */
name|printf
argument_list|(
literal|"AGAIN"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|xs
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* I MEAN IT ! */
name|ahc_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort the operation that has timed out */
name|printf
argument_list|(
literal|"Abort unsupported!!!\n"
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

