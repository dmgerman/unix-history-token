begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * GPIB driver for FreeBSD.  * Version 0.1 (No interrupts, no DMA)  * Supports National Instruments AT-GPIB and AT-GPIB/TNT boards.  * (AT-GPIB not tested, but it should work)  *  * Written by Fred Cawthorne (fcawth@delphi.umd.edu)  * Some sections were based partly on the lpt driver.  *  (some remnants may remain)  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * The author grants any other persons or organizations permission to use  * or modify this software as long as this message is kept with the software,  * all derivative works or modified versions.  *  *  */
end_comment

begin_comment
comment|/*Please read the README file for usage information*/
end_comment

begin_include
include|#
directive|include
file|"gp.h"
end_include

begin_if
if|#
directive|if
name|NGP
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<i386/isa/gpibreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/gpib.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a< b) ? a : b)
end_define

begin_define
define|#
directive|define
name|GPIBPRI
value|(PZERO+8)|PCATCH
end_define

begin_define
define|#
directive|define
name|SLEEP_MAX
value|1000
end_define

begin_define
define|#
directive|define
name|SLEEP_MIN
value|4
end_define

begin_function_decl
specifier|static
name|int
name|initgpib
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|closegpib
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sendgpibfifo
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sendrawgpibfifo
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|readgpibfifo
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void showregs(void);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|enableremote
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gotolocal
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|menableremote
parameter_list|(
name|unsigned
name|char
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mgotolocal
parameter_list|(
name|unsigned
name|char
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mtrigger
parameter_list|(
name|unsigned
name|char
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trigger
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
name|spoll
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gpprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gpattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|gpdriver
init|=
block|{
name|gpprobe
block|,
name|gpattach
block|,
literal|"gp"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|gpopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|gpclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|gpwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|gpioctl
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|44
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|gp_cdevsw
init|=
block|{
name|gpopen
block|,
name|gpclose
block|,
name|noread
block|,
name|gpwrite
block|,
comment|/*44*/
name|gpioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
comment|/* GPIB */
name|seltrue
block|,
name|nommap
block|,
name|NULL
block|,
literal|"gp"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUFSIZE
value|1024
end_define

begin_define
define|#
directive|define
name|ATTACHED
value|0x08
end_define

begin_define
define|#
directive|define
name|OPEN
value|0x04
end_define

begin_define
define|#
directive|define
name|INIT
value|0x02
end_define

begin_struct
specifier|static
struct|struct
name|gpib_softc
block|{
name|char
modifier|*
name|sc_cp
decl_stmt|;
comment|/* current data to send		*/
name|int
name|sc_count
decl_stmt|;
comment|/* bytes queued in sc_inbuf	*/
name|int
name|sc_type
decl_stmt|;
comment|/* Type of gpib controller	*/
name|u_char
name|sc_flags
decl_stmt|;
comment|/* flags (open and internal)	*/
name|char
name|sc_unit
decl_stmt|;
comment|/* gpib device number		*/
name|char
modifier|*
name|sc_inbuf
decl_stmt|;
comment|/* buffer for data		*/
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|devfs_token
decl_stmt|;
comment|/* handle for devfs entry	*/
endif|#
directive|endif
block|}
name|gpib_sc
struct|;
end_struct

begin_comment
comment|/* only support one of these? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|oldcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|oldbytes
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Probe routine*/
end_comment

begin_comment
comment|/*This needs to be changed to be a bit more robust*/
end_comment

begin_function
specifier|static
name|int
name|gpprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|struct
name|gpib_softc
modifier|*
name|sc
init|=
operator|&
name|gpib_sc
decl_stmt|;
name|gpib_port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_type
operator|=
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|KSR
argument_list|)
operator|&
literal|0xF7
operator|)
operator|==
literal|0x34
condition|)
name|sc
operator|->
name|sc_type
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|inb
argument_list|(
name|KSR
argument_list|)
operator|&
literal|0xF7
operator|)
operator|==
literal|0x24
condition|)
name|sc
operator|->
name|sc_type
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|inb
argument_list|(
name|KSR
argument_list|)
operator|&
literal|0xF7
operator|)
operator|==
literal|0x14
condition|)
name|sc
operator|->
name|sc_type
operator|=
literal|1
expr_stmt|;
else|else
name|status
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gpattach()  *  Attach device and print the type of card to the screen.  */
end_comment

begin_function
specifier|static
name|int
name|gpattach
parameter_list|(
name|isdp
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isdp
decl_stmt|;
block|{
name|struct
name|gpib_softc
modifier|*
name|sc
init|=
operator|&
name|gpib_sc
decl_stmt|;
name|sc
operator|->
name|sc_unit
operator|=
name|isdp
operator|->
name|id_unit
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_type
operator|==
literal|3
condition|)
name|printf
argument_list|(
literal|"gp%d: type AT-GPIB/TNT\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_type
operator|==
literal|2
condition|)
name|printf
argument_list|(
literal|"gp%d: type AT-GPIB chip NAT4882B\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_type
operator|==
literal|1
condition|)
name|printf
argument_list|(
literal|"gp%d: type AT-GPIB chip NAT4882A\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|ATTACHED
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|sc
operator|->
name|devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|gp_cdevsw
argument_list|,
literal|0
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"gp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gpopen()  *	New open on device.  *  * More than 1 open is not allowed on the entire device.  * i.e. even if gpib5 is open, we can't open another minor device  */
end_comment

begin_function
specifier|static
name|int
name|gpopen
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|gpib_softc
modifier|*
name|sc
init|=
operator|&
name|gpib_sc
decl_stmt|;
name|u_char
name|unit
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* minor number out of limits ? */
if|if
condition|(
name|unit
operator|>=
literal|32
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Attached ? */
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|ATTACHED
operator|)
condition|)
block|{
comment|/* not attached */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Already open  */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|OPEN
condition|)
block|{
comment|/* too late .. */
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Have memory for buffer? */
name|sc
operator|->
name|sc_inbuf
operator|=
name|malloc
argument_list|(
name|BUFSIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_inbuf
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|initgpib
argument_list|()
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|sc
operator|->
name|sc_flags
operator||=
name|OPEN
expr_stmt|;
name|sc
operator|->
name|sc_count
operator|=
literal|0
expr_stmt|;
name|oldcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unit
operator|!=
literal|0
condition|)
block|{
comment|/*Someone is trying to access an actual device*/
comment|/*So.. we'll address it to listen*/
name|enableremote
argument_list|(
name|unit
argument_list|)
expr_stmt|;
do|do
block|{
name|status
operator|=
name|inb
argument_list|(
name|ISR2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|status
operator|&
literal|8
operator|)
operator|&&
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|CDOR
argument_list|,
operator|(
name|unit
operator|&
literal|31
operator|)
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/*address device to listen*/
do|do
name|status
operator|=
name|inb
argument_list|(
name|ISR2
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|status
operator|&
literal|8
operator|)
operator|&&
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/*Address controller (me) to talk*/
do|do
name|status
operator|=
name|inb
argument_list|(
name|ISR2
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|status
operator|&
literal|8
operator|)
operator|&&
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|gts
argument_list|)
expr_stmt|;
comment|/*Set to Standby (Controller)*/
do|do
name|status
operator|=
name|inb
argument_list|(
name|ISR1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|status
operator|&
literal|2
operator|)
operator|&&
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Set up the TURBO488 registers*/
name|outb
argument_list|(
name|IMR2
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/*we have to enable DMA (0x30) for turbo488 to work*/
name|outb
argument_list|(
name|CNT0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTE this does not enable DMA to the host computer!!*/
name|outb
argument_list|(
name|CNT1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CNT2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CNT3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CFG
argument_list|,
literal|0x47
argument_list|)
expr_stmt|;
comment|/* 16 bit, write, fifo B first, TMOE TIM */
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/*RESET fifos*/
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/*Tell TURBO488 to GO*/
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gpclose()  *	Close gpib device.  */
end_comment

begin_function
specifier|static
name|int
name|gpclose
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|gpib_softc
modifier|*
name|sc
init|=
operator|&
name|gpib_sc
decl_stmt|;
name|unsigned
name|char
name|unit
decl_stmt|;
name|unsigned
name|char
name|status
decl_stmt|;
name|unit
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|!=
literal|0
condition|)
block|{
comment|/*Here we need to send the last character with EOS*/
comment|/*and unaddress the listening device*/
name|status
operator|=
name|EWOULDBLOCK
expr_stmt|;
comment|/*Wait for fifo to become empty*/
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|inb
argument_list|(
name|ISR3
argument_list|)
operator|&
literal|0x04
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Fifo is not empty*/
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/*Issue STOP to TURBO488*/
comment|/*Wait for DONE and STOP*/
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR3
argument_list|)
operator|&
literal|0x11
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*not done and stop*/
comment|/*Shut down TURBO488 */
name|outb
argument_list|(
name|IMR2
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*DISABLE DMA to turbo488*/
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/*soft reset turbo488*/
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/*reset fifos*/
comment|/*Send last byte with EOI set*/
comment|/*Send second to last byte if there are 2 bytes left*/
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
block|{
do|do
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|2
operator|)
condition|)
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|2
operator|)
operator|&&
operator|(
name|status
operator|==
name|EWOULDBLOCK
operator|)
condition|)
do|;
if|if
condition|(
name|oldcount
operator|==
literal|2
condition|)
block|{
name|outb
argument_list|(
name|CDOR
argument_list|,
name|oldbytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/*Send second to last byte*/
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|2
operator|)
operator|&&
operator|(
name|status
operator|==
name|EWOULDBLOCK
operator|)
condition|)
empty_stmt|;
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|seoi
argument_list|)
expr_stmt|;
comment|/*Set EOI for the last byte*/
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
comment|/*Clear SYNC*/
if|if
condition|(
name|oldcount
operator|==
literal|1
condition|)
name|outb
argument_list|(
name|CDOR
argument_list|,
name|oldbytes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oldcount
operator|==
literal|2
condition|)
name|outb
argument_list|(
name|CDOR
argument_list|,
name|oldbytes
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|13
argument_list|)
expr_stmt|;
comment|/*Send a CR.. we've got trouble*/
name|printf
argument_list|(
literal|"gpib: Warning: gpclose called with nothing left in buffer\n"
argument_list|)
expr_stmt|;
block|}
block|}
do|do
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|2
operator|)
condition|)
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|2
operator|)
operator|&&
operator|(
name|status
operator|==
name|EWOULDBLOCK
operator|)
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|2
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|2
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|tca
argument_list|)
expr_stmt|;
comment|/* Regain full control of the bus*/
do|do
name|status
operator|=
name|inb
argument_list|(
name|ISR2
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|status
operator|&
literal|8
operator|)
operator|&&
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/*unlisten*/
do|do
name|status
operator|=
name|inb
argument_list|(
name|ISR2
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|status
operator|&
literal|8
operator|)
operator|&&
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
comment|/*Clear SYNC*/
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|95
argument_list|)
expr_stmt|;
comment|/*untalk*/
do|do
name|status
operator|=
name|inb
argument_list|(
name|ISR2
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|status
operator|&
literal|8
operator|)
operator|&&
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*gotolocal(minor(dev));*/
block|}
name|closegpib
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|ATTACHED
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_inbuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_inbuf
operator|=
literal|0
expr_stmt|;
comment|/* Sanity */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gpwrite()  *	Copy from user's buffer, then write to GPIB device referenced  *    by minor(dev).  */
end_comment

begin_function
specifier|static
name|int
name|gpwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|ioflag
decl_stmt|;
block|{
name|int
name|err
decl_stmt|,
name|count
decl_stmt|;
comment|/* main loop */
while|while
condition|(
operator|(
name|gpib_sc
operator|.
name|sc_count
operator|=
name|MIN
argument_list|(
name|BUFSIZE
operator|-
literal|1
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/*  If there were>1 bytes left over, send them  */
if|if
condition|(
name|oldcount
operator|==
literal|2
condition|)
name|sendrawgpibfifo
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|oldbytes
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/*If there was 1 character left, put it at the beginning                    of the new buffer*/
if|if
condition|(
name|oldcount
operator|==
literal|1
condition|)
block|{
operator|(
name|gpib_sc
operator|.
name|sc_inbuf
operator|)
index|[
literal|0
index|]
operator|=
name|oldbytes
index|[
literal|0
index|]
expr_stmt|;
name|gpib_sc
operator|.
name|sc_cp
operator|=
name|gpib_sc
operator|.
name|sc_inbuf
expr_stmt|;
comment|/*  get from user-space  */
name|uiomove
argument_list|(
name|gpib_sc
operator|.
name|sc_inbuf
operator|+
literal|1
argument_list|,
name|gpib_sc
operator|.
name|sc_count
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|gpib_sc
operator|.
name|sc_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|gpib_sc
operator|.
name|sc_cp
operator|=
name|gpib_sc
operator|.
name|sc_inbuf
expr_stmt|;
comment|/*  get from user-space  */
name|uiomove
argument_list|(
name|gpib_sc
operator|.
name|sc_inbuf
argument_list|,
name|gpib_sc
operator|.
name|sc_count
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
comment|/*NOTE we always leave one byte in case this is the last write   so close can send EOI with the last byte There may be 2 bytes   since we are doing 16 bit transfers.(note the -1 in the count below)*/
comment|/*If count<=2 we'll either pick it up on the next write or on close*/
if|if
condition|(
name|gpib_sc
operator|.
name|sc_count
operator|>
literal|2
condition|)
block|{
name|count
operator|=
name|sendrawgpibfifo
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|gpib_sc
operator|.
name|sc_cp
argument_list|,
name|gpib_sc
operator|.
name|sc_count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
operator|!
name|count
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|oldcount
operator|=
name|gpib_sc
operator|.
name|sc_count
operator|-
name|count
expr_stmt|;
comment|/*Set # of remaining bytes*/
name|gpib_sc
operator|.
name|sc_count
operator|-=
name|count
expr_stmt|;
name|gpib_sc
operator|.
name|sc_cp
operator|+=
name|count
expr_stmt|;
comment|/*point char pointer to remaining bytes*/
block|}
else|else
name|oldcount
operator|=
name|gpib_sc
operator|.
name|sc_count
expr_stmt|;
name|oldbytes
index|[
literal|0
index|]
operator|=
name|gpib_sc
operator|.
name|sc_cp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|oldcount
operator|==
literal|2
condition|)
name|oldbytes
index|[
literal|1
index|]
operator|=
name|gpib_sc
operator|.
name|sc_cp
index|[
literal|1
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Here is how you would usually access a GPIB device    An exception would be a plotter or printer that you can just    write to using a minor device = its GPIB address */
end_comment

begin_function
specifier|static
name|int
name|gpioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|gpibdata
modifier|*
name|gd
init|=
operator|(
expr|struct
name|gpibdata
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
decl_stmt|,
name|result
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|GPIBWRITE
case|:
name|sendgpibfifo
argument_list|(
name|gd
operator|->
name|address
argument_list|,
name|gd
operator|->
name|data
argument_list|,
operator|*
operator|(
name|gd
operator|->
name|count
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GPIBREAD
case|:
name|result
operator|=
name|readgpibfifo
argument_list|(
name|gd
operator|->
name|address
argument_list|,
name|gd
operator|->
name|data
argument_list|,
operator|*
operator|(
name|gd
operator|->
name|count
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|gd
operator|->
name|count
operator|)
operator|=
name|result
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GPIBINIT
case|:
name|initgpib
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GPIBTRIGGER
case|:
name|trigger
argument_list|(
name|gd
operator|->
name|address
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GPIBREMOTE
case|:
name|enableremote
argument_list|(
name|gd
operator|->
name|address
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GPIBLOCAL
case|:
name|gotolocal
argument_list|(
name|gd
operator|->
name|address
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GPIBMTRIGGER
case|:
name|mtrigger
argument_list|(
name|gd
operator|->
name|data
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GPIBMREMOTE
case|:
name|menableremote
argument_list|(
name|gd
operator|->
name|data
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GPIBMLOCAL
case|:
name|mgotolocal
argument_list|(
name|gd
operator|->
name|data
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GPIBSPOLL
case|:
operator|*
operator|(
name|gd
operator|->
name|data
operator|)
operator|=
name|spoll
argument_list|(
name|gd
operator|->
name|address
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENODEV
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*Just in case you want a dump of the registers...*/
end_comment

begin_endif
unit|static void showregs() {  printf ("NAT4882:\n");  printf ("ISR1=%X\t",inb(ISR1));  printf ("ISR2=%X\t",inb(ISR2));  printf ("SPSR=%X\t",inb(SPSR));  printf ("KSR =%X\t",inb(KSR));  printf ("ADSR=%X\t",inb(ADSR));  printf ("CPTR=%X\t",inb(CPTR));  printf ("SASR=%X\t",inb(SASR));  printf ("ADR0=%X\t",inb(ADR0));  printf ("ISR0=%X\t",inb(ISR0));  printf ("ADR1=%X\t",inb(ADR1));  printf ("BSR =%X\n",inb(BSR));   printf ("Turbo488\n");  printf ("STS1=%X ",inb(STS1));  printf ("STS2=%X ",inb(STS2));  printf ("ISR3=%X ",inb(ISR3));  printf ("CNT0=%X ",inb(CNT0));  printf ("CNT1=%X ",inb(CNT1));  printf ("CNT2=%X ",inb(CNT2));  printf ("CNT3=%X ",inb(CNT3));  printf ("IMR3=%X ",inb(IMR3));  printf ("TIMER=%X\n",inb(TIMER));    }
endif|#
directive|endif
end_endif

begin_comment
comment|/*Set up the NAT4882 and TURBO488 registers */
end_comment

begin_comment
comment|/*This will be nonsense to you unless you have a data sheet from   National Instruments.  They should give you one if you call them*/
end_comment

begin_function
specifier|static
name|int
name|initgpib
parameter_list|()
block|{
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CFG
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IMR3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CNT0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CNT1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CNT2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CNT3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|INTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put interrupt line in tri-state mode??*/
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|chip_reset
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IMR1
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* send interrupt to TURBO488 when END received*/
name|outb
argument_list|(
name|IMR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IMR0
argument_list|,
literal|0x90
argument_list|)
expr_stmt|;
comment|/* Do we want nba here too??? */
name|outb
argument_list|(
name|ADMR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ADR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ADR
argument_list|,
literal|128
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0xE9
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x49
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0xD0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0xA0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|EOSR
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/*set EOS message to newline*/
comment|/*should I make the default to interpret END as EOS?*/
comment|/*It isn't now.  The following changes this*/
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/*No special EOS handling*/
comment|/*outb(AUXMR,0x88) */
comment|/* Transmit END with EOS*/
comment|/*outb(AUXMR,0x84) */
comment|/* Set END on EOS received*/
comment|/*outb(AUXMR,0x8C) */
comment|/* Do both of the above*/
comment|/* outb(AUXMR,hldi); */
comment|/*Perform RFD Holdoff for all data in*/
comment|/*Not currently supported*/
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|pon
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|sic_rsc
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|sic_rsc_off
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*This is kind of Brute force..  But it works*/
end_comment

begin_function
specifier|static
name|void
name|closegpib
parameter_list|()
block|{
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|chip_reset
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*GPIB ROUTINES:   These will also make little sense unless you have a data sheet.   Note that the routines with an "m" in the beginning are for   accessing multiple devices in one call*/
end_comment

begin_comment
comment|/*This is one thing I could not figure out how to do correctly.   I tried to use the auxilary  command to enable remote, but it   never worked.  Here, I bypass everything and write to the BSR   to enable the remote line.  NOTE that these lines are effectively   "OR'ed" with the actual lines, so writing a 1 to the bit in the BSR   forces the GPIB line true, no matter what the fancy circuitry of the   NAT4882 wants to do with it*/
end_comment

begin_function
specifier|static
name|void
name|enableremote
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|EWOULDBLOCK
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|BSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*Set REN bit on GPIB*/
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|CDOR
argument_list|,
operator|(
name|device
operator|&
literal|31
operator|)
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/*address device to listen*/
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/*Unaddress device*/
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
block|}
end_function

begin_comment
comment|/*This does not release the REM line on the gpib port, because if it did,   all the remote devices would go to local mode.  This only sends the   gotolocal message to one device.  Currently, REM is always held true   after enableremote is called, and is reset only on a close of the   gpib device */
end_comment

begin_function
specifier|static
name|void
name|gotolocal
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|EWOULDBLOCK
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|CDOR
argument_list|,
operator|(
name|device
operator|&
literal|31
operator|)
operator|+
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
comment|/*Clear SYNC*/
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/*unaddress device*/
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
block|}
end_function

begin_function
specifier|static
name|void
name|menableremote
parameter_list|(
name|unsigned
name|char
modifier|*
name|device
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|counter
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|EWOULDBLOCK
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|BSR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*Set REN bit on GPIB*/
do|do
block|{
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|CDOR
argument_list|,
operator|(
name|device
index|[
name|counter
index|]
operator|&
literal|31
operator|)
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/*address device to listen*/
name|counter
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|device
index|[
name|counter
index|]
operator|<
literal|32
condition|)
do|;
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/*Unaddress device*/
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
block|}
end_function

begin_function
specifier|static
name|void
name|mgotolocal
parameter_list|(
name|unsigned
name|char
modifier|*
name|device
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|EWOULDBLOCK
expr_stmt|;
if|if
condition|(
name|device
index|[
name|counter
index|]
operator|<
literal|32
condition|)
do|do
block|{
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|CDOR
argument_list|,
operator|(
name|device
index|[
name|counter
index|]
operator|&
literal|31
operator|)
operator|+
literal|32
argument_list|)
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|device
index|[
name|counter
index|]
operator|<
literal|32
condition|)
do|;
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
comment|/*Clear SYNC*/
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/*unaddress device*/
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
block|}
end_function

begin_comment
comment|/*Trigger a device.  What happens depends on how the device is  configured.  */
end_comment

begin_function
specifier|static
name|void
name|trigger
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|EWOULDBLOCK
expr_stmt|;
if|if
condition|(
name|device
operator|<
literal|32
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|CDOR
argument_list|,
operator|(
name|device
operator|&
literal|31
operator|)
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/*address device to listen*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/*send GET*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/*unaddress device*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
block|}
block|}
end_function

begin_comment
comment|/*Trigger multiple devices by addressing them all to listen, and then   sending GET*/
end_comment

begin_function
specifier|static
name|void
name|mtrigger
parameter_list|(
name|unsigned
name|char
modifier|*
name|device
parameter_list|)
block|{
name|int
name|status
init|=
name|EWOULDBLOCK
decl_stmt|;
name|int
name|counter
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|device
index|[
literal|0
index|]
operator|<
literal|32
condition|)
block|{
do|do
block|{
if|if
condition|(
name|device
index|[
name|counter
index|]
operator|<
literal|32
condition|)
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|CDOR
argument_list|,
operator|(
name|device
index|[
name|counter
index|]
operator|&
literal|31
operator|)
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/*address device to listen*/
name|counter
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|device
index|[
name|counter
index|]
operator|<
literal|32
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/*send GET*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/*unaddress device*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Wait to send next cmd*/
block|}
block|}
end_function

begin_comment
comment|/*This is not used now, but it should work with NI's 8 bit gpib board   since it does not use the TURBO488 registers at all */
end_comment

begin_comment
comment|/*Send data through the TURBO488 FIFOS to a device that is already  addressed to listen.  This is used by the write call when someone is  writing to a printer or plotter, etc... */
end_comment

begin_comment
comment|/*The last byte of each write is held off until either the next  write or close, so it can be sent with EOI set*/
end_comment

begin_function
specifier|static
name|int
name|sendrawgpibfifo
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|counter
decl_stmt|;
name|int
name|fifopos
decl_stmt|;
name|int
name|sleeptime
decl_stmt|;
name|sleeptime
operator|=
name|SLEEP_MIN
expr_stmt|;
name|counter
operator|=
literal|0
expr_stmt|;
name|fifopos
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|EWOULDBLOCK
expr_stmt|;
do|do
block|{
comment|/*Wait for fifo to become not full if it is full */
name|sleeptime
operator|=
name|SLEEP_MIN
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR3
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
name|sleeptime
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleeptime
operator|<
name|SLEEP_MAX
condition|)
name|sleeptime
operator|=
name|sleeptime
operator|*
literal|2
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR3
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
operator|(
name|status
operator|==
name|EWOULDBLOCK
operator|)
condition|)
do|;
comment|/*Fifo is full*/
if|if
condition|(
operator|(
name|count
operator|>
literal|1
operator|)
operator|&&
operator|(
name|inb
argument_list|(
name|ISR3
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
block|{
name|outw
argument_list|(
name|FIFOB
argument_list|,
operator|*
operator|(
name|unsigned
operator|*
operator|)
operator|(
name|data
operator|+
name|counter
operator|)
argument_list|)
expr_stmt|;
comment|/*  printf ("gpib: sent:%c,%c\n",data[counter],data[counter+1]);*/
name|counter
operator|+=
literal|2
expr_stmt|;
name|count
operator|-=
literal|2
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|count
operator|>
literal|1
operator|)
operator|&&
operator|(
name|status
operator|==
name|EWOULDBLOCK
operator|)
condition|)
do|;
comment|/*The write routine and close routine must check if there is 1   byte left and handle it accordingly*/
comment|/*Return the number of bytes written to the device*/
return|return
operator|(
name|counter
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sendgpibfifo
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|counter
decl_stmt|;
name|int
name|fifopos
decl_stmt|;
name|int
name|sleeptime
decl_stmt|;
name|outb
argument_list|(
name|IMR2
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/*we have to enable DMA (0x30) for turbo488 to work*/
name|outb
argument_list|(
name|CNT0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CNT1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CNT2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CNT3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|EWOULDBLOCK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|CDOR
argument_list|,
operator|(
name|device
operator|&
literal|31
operator|)
operator|+
literal|32
argument_list|)
expr_stmt|;
comment|/*address device to listen*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/*Address controller (me) to talk*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|gts
argument_list|)
expr_stmt|;
comment|/*Set to Standby (Controller)*/
name|fifopos
operator|=
literal|0
expr_stmt|;
name|sleeptime
operator|=
name|SLEEP_MIN
expr_stmt|;
name|counter
operator|=
literal|0
expr_stmt|;
name|fifopos
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CFG
argument_list|,
literal|0x47
argument_list|)
expr_stmt|;
comment|/* 16 bit, write, fifo B first, TMOE TIM */
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/*RESET fifos*/
name|outb
argument_list|(
name|CCRG
argument_list|,
name|seoi
argument_list|)
expr_stmt|;
comment|/*program to send EOI at end*/
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/*Tell TURBO488 to GO*/
name|status
operator|=
name|EWOULDBLOCK
expr_stmt|;
do|do
block|{
comment|/*Wait for fifo to become not full if it is full */
name|sleeptime
operator|=
name|SLEEP_MIN
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR3
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
name|sleeptime
argument_list|)
expr_stmt|;
if|if
condition|(
name|sleeptime
operator|<
name|SLEEP_MAX
condition|)
name|sleeptime
operator|=
name|sleeptime
operator|*
literal|2
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR3
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
operator|(
name|status
operator|==
name|EWOULDBLOCK
operator|)
condition|)
do|;
comment|/*Fifo is full*/
if|if
condition|(
operator|(
name|count
operator|>
literal|1
operator|)
operator|&&
operator|(
name|inb
argument_list|(
name|ISR3
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
block|{
comment|/*if(count==2) outb(CFG,15+0x40); */
comment|/*send eoi when done*/
name|outw
argument_list|(
name|FIFOB
argument_list|,
operator|*
operator|(
name|unsigned
operator|*
operator|)
operator|(
name|data
operator|+
name|counter
operator|)
argument_list|)
expr_stmt|;
name|counter
operator|+=
literal|2
expr_stmt|;
name|count
operator|-=
literal|2
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|count
operator|>
literal|2
operator|)
operator|&&
operator|(
name|status
operator|==
name|EWOULDBLOCK
operator|)
condition|)
do|;
if|if
condition|(
name|count
operator|==
literal|2
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
block|{
comment|/*Wait for fifo to become not full*/
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
operator|&&
operator|!
operator|(
name|inb
argument_list|(
name|ISR3
argument_list|)
operator|&
literal|0x08
operator|)
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
name|SLEEP_MIN
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR3
argument_list|)
operator|&
literal|0x08
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Fifo is full*/
comment|/*outb(CFG,0x40+15);*/
comment|/*send eoi when done*/
name|outb
argument_list|(
name|FIFOB
argument_list|,
name|data
index|[
name|counter
index|]
argument_list|)
expr_stmt|;
name|counter
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
comment|/*outb(CMDR,0x04);*/
comment|/*Wait for fifo to become empty*/
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|inb
argument_list|(
name|ISR3
argument_list|)
operator|&
literal|0x04
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*Fifo is not empty*/
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/*Issue STOP to TURBO488*/
comment|/*Wait for DONE and STOP*/
if|if
condition|(
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR3
argument_list|)
operator|&
literal|0x11
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*not done and stop*/
name|outb
argument_list|(
name|IMR2
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*we have to enable DMA (0x30) for turbo488 to work*/
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/*soft reset turbo488*/
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/*reset fifos*/
comment|/*Send last byte with EOI set*/
comment|/*Here EOI is handled correctly since the string to be sent */
comment|/*is actually all sent during the ioctl.  (See above)*/
if|if
condition|(
name|count
operator|==
literal|1
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
block|{
comment|/*Count should always=1 here*/
do|do
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|2
operator|)
condition|)
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|2
operator|)
operator|&&
operator|(
name|status
operator|==
name|EWOULDBLOCK
operator|)
condition|)
do|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|seoi
argument_list|)
expr_stmt|;
comment|/*Set EOI for the last byte*/
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
comment|/*Clear SYNC*/
name|outb
argument_list|(
name|CDOR
argument_list|,
name|data
index|[
name|counter
index|]
argument_list|)
expr_stmt|;
name|counter
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
do|do
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|2
operator|)
condition|)
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|2
operator|)
operator|&&
operator|(
name|status
operator|==
name|EWOULDBLOCK
operator|)
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|2
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|2
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|tca
argument_list|)
expr_stmt|;
comment|/* Regain full control of the bus*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/*unlisten*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
comment|/*Clear SYNC*/
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|95
argument_list|)
expr_stmt|;
comment|/*untalk*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
return|return
operator|(
name|counter
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|readgpibfifo
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|status2
init|=
literal|0
decl_stmt|;
name|int
name|status1
decl_stmt|;
name|int
name|counter
decl_stmt|;
name|int
name|fifopos
decl_stmt|;
name|unsigned
name|inword
decl_stmt|;
name|outb
argument_list|(
name|IMR2
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/*we have to enable DMA (0x30) for turbo488 to work*/
comment|/*outb(IMR3,0x1F);  outb(INTR,1); */
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CFG
argument_list|,
literal|14
operator|+
literal|0x60
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Halt on int,read, fifo B first, CCEN TMOE TIM */
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/*RESET fifos*/
name|outb
argument_list|(
name|CCRG
argument_list|,
name|tcs
argument_list|)
expr_stmt|;
comment|/*program to tcs at end*/
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/*STOP??*/
name|status
operator|=
name|EWOULDBLOCK
expr_stmt|;
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/*Address controller (me) to listen*/
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|CDOR
argument_list|,
operator|(
name|device
operator|&
literal|31
operator|)
operator|+
literal|64
argument_list|)
expr_stmt|;
comment|/*address device to talk*/
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|gts
argument_list|)
expr_stmt|;
comment|/*Set to Standby (Controller)*/
name|counter
operator|=
literal|0
expr_stmt|;
name|fifopos
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/*Tell TURBO488 to GO*/
do|do
block|{
name|status1
operator|=
name|inb
argument_list|(
name|ISR3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status1
operator|&
literal|0x01
operator|)
operator|&&
operator|(
name|status1
operator|&
literal|0x04
operator|)
condition|)
block|{
name|status2
operator|=
name|inb
argument_list|(
name|STS2
argument_list|)
expr_stmt|;
name|inword
operator|=
name|inw
argument_list|(
name|FIFOB
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
operator|*
operator|)
operator|(
name|data
operator|+
name|counter
operator|)
operator|=
name|inword
expr_stmt|;
comment|/* printf ("Read:%c,%c\n",data[counter],data[counter+1]);*/
name|counter
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|status1
operator|&
literal|0x01
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|status2
operator|&
literal|0x04
operator|)
condition|)
block|{
comment|/*Only 1 byte came in on last 16 bit transfer*/
name|data
index|[
name|counter
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|counter
operator|--
expr_stmt|;
block|}
else|else
name|data
index|[
name|counter
index|]
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/*send STOP*/
do|do
block|{
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR3
argument_list|)
operator|&
literal|0x11
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*wait for DONE and STOP*/
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IMR2
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*we have to enable DMA (0x30) for turbo488 to work*/
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/*soft reset turbo488*/
name|outb
argument_list|(
name|CMDR
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/*reset fifos*/
comment|/* do    status=tsleep((caddr_t)&gpib_sc,GPIBPRI,"gpibpoll",1);  while (!(inb(ISR1)&2));*/
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|tca
argument_list|)
expr_stmt|;
comment|/* Regain full control of the bus*/
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/*unlisten*/
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
comment|/*Clear SYNC*/
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|95
argument_list|)
expr_stmt|;
comment|/*untalk*/
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
return|return
operator|(
name|counter
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the status byte from device */
end_comment

begin_function
specifier|static
name|char
name|spoll
parameter_list|(
name|unsigned
name|char
name|device
parameter_list|)
block|{
name|int
name|status
init|=
name|EWOULDBLOCK
decl_stmt|;
name|unsigned
name|int
name|statusbyte
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|CDOR
argument_list|,
operator|(
name|device
operator|&
literal|31
operator|)
operator|+
literal|64
argument_list|)
expr_stmt|;
comment|/*address device to talk*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/*Address controller (me) to listen*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|0x18
argument_list|)
expr_stmt|;
comment|/*Send SPE (serial poll enable)*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*wait for bus to be synced*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR0
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR0
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|gts
argument_list|)
expr_stmt|;
comment|/*Set to Standby (Controller)*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR1
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
name|tcs
argument_list|)
expr_stmt|;
comment|/* Take control after next read*/
name|statusbyte
operator|=
name|inb
argument_list|(
name|DIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
comment|/*SPD (serial poll disable)*/
comment|/*wait for bus to be synced*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR0
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR0
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|95
argument_list|)
expr_stmt|;
comment|/*untalk*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|outb
argument_list|(
name|AUXMR
argument_list|,
literal|0x5E
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CDOR
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/*unlisten*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR2
argument_list|)
operator|&
literal|8
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
comment|/*wait for bus to be synced*/
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR0
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|do
name|status
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|gpib_sc
argument_list|,
name|GPIBPRI
argument_list|,
literal|"gpibpoll"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ISR0
argument_list|)
operator|&
literal|1
operator|)
operator|&&
name|status
operator|==
name|EWOULDBLOCK
condition|)
do|;
return|return
operator|(
name|statusbyte
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|gp_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|gp_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|gp_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|gp_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gp_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|gpdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|gp_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NGPIB> 0 */
end_comment

end_unit

