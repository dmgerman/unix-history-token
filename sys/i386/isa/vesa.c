begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Kazutaka YOKOTA and Michael Smith  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer as  *    the first lines of this file unmodified.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Id: vesa.c,v 1.26 1999/07/01 15:05:11 peter Exp $  */
end_comment

begin_include
include|#
directive|include
file|"vga.h"
end_include

begin_include
include|#
directive|include
file|"opt_vga.h"
end_include

begin_include
include|#
directive|include
file|"opt_vesa.h"
end_include

begin_include
include|#
directive|include
file|"opt_fb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|VGA_NO_MODE_CHANGE
end_ifdef

begin_undef
undef|#
directive|undef
name|VESA
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|NVGA
operator|>
literal|0
operator|&&
name|defined
argument_list|(
name|VESA
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|KLD_MODULE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fbio.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/vm86.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/bios.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/vesa.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/fbreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/vgareg.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__i386__
end_ifndef

begin_include
include|#
directive|include
file|<isa/isareg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|VESA_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|VESA_DEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VESA video adapter state buffer stub */
end_comment

begin_struct
struct|struct
name|adp_state
block|{
name|int
name|sig
decl_stmt|;
define|#
directive|define
name|V_STATE_SIG
value|0x61736576
name|u_char
name|regs
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|adp_state
name|adp_state_t
typedef|;
end_typedef

begin_comment
comment|/* VESA video adapter */
end_comment

begin_decl_stmt
specifier|static
name|video_adapter_t
modifier|*
name|vesa_adp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vesa_state_buf_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VESA functions */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int			vesa_nop(void);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|vesa_error
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|vi_probe_t
name|vesa_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_init_t
name|vesa_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_get_info_t
name|vesa_get_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_query_mode_t
name|vesa_query_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_mode_t
name|vesa_set_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_save_font_t
name|vesa_save_font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_load_font_t
name|vesa_load_font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_show_font_t
name|vesa_show_font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_save_palette_t
name|vesa_save_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_load_palette_t
name|vesa_load_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_border_t
name|vesa_set_border
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_save_state_t
name|vesa_save_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_load_state_t
name|vesa_load_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_win_org_t
name|vesa_set_origin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_read_hw_cursor_t
name|vesa_read_hw_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_hw_cursor_t
name|vesa_set_hw_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_hw_cursor_shape_t
name|vesa_set_hw_cursor_shape
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_blank_display_t
name|vesa_blank_display
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_mmap_t
name|vesa_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_ioctl_t
name|vesa_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_clear_t
name|vesa_clear
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_fill_rect_t
name|vesa_fill_rect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_bitblt_t
name|vesa_bitblt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_diag_t
name|vesa_diag
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|vesa_bios_info
parameter_list|(
name|int
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|vm86context
name|vesa_vmcontext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|video_switch_t
name|vesavidsw
init|=
block|{
name|vesa_probe
block|,
name|vesa_init
block|,
name|vesa_get_info
block|,
name|vesa_query_mode
block|,
name|vesa_set_mode
block|,
name|vesa_save_font
block|,
name|vesa_load_font
block|,
name|vesa_show_font
block|,
name|vesa_save_palette
block|,
name|vesa_load_palette
block|,
name|vesa_set_border
block|,
name|vesa_save_state
block|,
name|vesa_load_state
block|,
name|vesa_set_origin
block|,
name|vesa_read_hw_cursor
block|,
name|vesa_set_hw_cursor
block|,
name|vesa_set_hw_cursor_shape
block|,
name|vesa_blank_display
block|,
name|vesa_mmap
block|,
name|vesa_ioctl
block|,
name|vesa_clear
block|,
name|vesa_fill_rect
block|,
name|vesa_bitblt
block|,
name|vesa_error
block|,
name|vesa_error
block|,
name|vesa_diag
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|video_switch_t
modifier|*
name|prevvidsw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VESA BIOS video modes */
end_comment

begin_define
define|#
directive|define
name|VESA_MAXMODES
value|64
end_define

begin_define
define|#
directive|define
name|EOT
value|(-1)
end_define

begin_define
define|#
directive|define
name|NA
value|(-2)
end_define

begin_define
define|#
directive|define
name|MODE_TABLE_DELTA
value|8
end_define

begin_decl_stmt
specifier|static
name|int
name|vesa_vmode_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|video_info_t
name|vesa_vmode_empty
init|=
block|{
name|EOT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|video_info_t
modifier|*
name|vesa_vmode
init|=
operator|&
name|vesa_vmode_empty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|vesa_init_done
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|has_vesa_bios
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vesa_info
modifier|*
name|vesa_adp_info
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int16_t
modifier|*
name|vesa_vmodetab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vesa_oemstr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vesa_venderstr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vesa_prodstr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|vesa_revstr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local macros and functions */
end_comment

begin_define
define|#
directive|define
name|BIOS_SADDRTOLADDR
parameter_list|(
name|p
parameter_list|)
value|((((p)& 0xffff0000)>> 12) + ((p)& 0x0000ffff))
end_define

begin_function_decl
specifier|static
name|int
name|int10_set_mode
parameter_list|(
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_get_mode
parameter_list|(
name|int
name|mode
parameter_list|,
name|struct
name|vesa_mode
modifier|*
name|vmode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_set_mode
parameter_list|(
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_get_dac
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_set_dac
parameter_list|(
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_save_palette
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|,
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_save_palette2
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|r
parameter_list|,
name|u_char
modifier|*
name|g
parameter_list|,
name|u_char
modifier|*
name|b
parameter_list|,
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_load_palette
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|,
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|int
name|vesa_bios_load_palette2
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|r
parameter_list|,
name|u_char
modifier|*
name|g
parameter_list|,
name|u_char
modifier|*
name|b
parameter_list|,
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STATE_SIZE
value|0
end_define

begin_define
define|#
directive|define
name|STATE_SAVE
value|1
end_define

begin_define
define|#
directive|define
name|STATE_LOAD
value|2
end_define

begin_define
define|#
directive|define
name|STATE_HW
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|STATE_DATA
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|STATE_DAC
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|STATE_REG
value|(1<<3)
end_define

begin_define
define|#
directive|define
name|STATE_MOST
value|(STATE_HW | STATE_DATA | STATE_REG)
end_define

begin_define
define|#
directive|define
name|STATE_ALL
value|(STATE_HW | STATE_DATA | STATE_DAC | STATE_REG)
end_define

begin_function_decl
specifier|static
name|int
name|vesa_bios_state_buf_size
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_save_restore
parameter_list|(
name|int
name|code
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_get_line_length
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_set_line_length
parameter_list|(
name|int
name|pixel
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int vesa_bios_get_start(int *x, int *y);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|vesa_bios_set_start
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_map_gen_mode_num
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|color
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_translate_flags
parameter_list|(
name|u_int16_t
name|vflags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_translate_mmodel
parameter_list|(
name|u_int8_t
name|vmodel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|vesa_fix_ptr
parameter_list|(
name|u_int32_t
name|p
parameter_list|,
name|u_int16_t
name|seg
parameter_list|,
name|u_int16_t
name|off
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vesa_bios_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vesa_clear_modes
parameter_list|(
name|video_info_t
modifier|*
name|info
parameter_list|,
name|int
name|color
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_offset_t
name|vesa_map_buffer
parameter_list|(
name|u_int
name|paddr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vesa_unmap_buffer
parameter_list|(
name|vm_offset_t
name|vaddr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int vesa_get_origin(video_adapter_t *adp, off_t *offset);
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|dump_buffer
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"%02x "
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|++
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* INT 10 BIOS calls */
end_comment

begin_function
specifier|static
name|int
name|int10_set_mode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x0000
operator||
name|mode
expr_stmt|;
name|vm86_intcall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* VESA BIOS calls */
end_comment

begin_function
specifier|static
name|int
name|vesa_bios_get_mode
parameter_list|(
name|int
name|mode
parameter_list|,
name|struct
name|vesa_mode
modifier|*
name|vmode
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f01
expr_stmt|;
name|vmf
operator|.
name|vmf_ecx
operator|=
name|mode
expr_stmt|;
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|vm86_getpage
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm86_getptr
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|buf
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_es
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_di
argument_list|)
expr_stmt|;
name|err
operator|=
name|vm86_datacall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|,
operator|&
name|vesa_vmcontext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
condition|)
return|return
literal|1
return|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|vmode
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vmode
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_set_mode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f02
expr_stmt|;
name|vmf
operator|.
name|vmf_ebx
operator|=
name|mode
expr_stmt|;
name|err
operator|=
name|vm86_intcall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_get_dac
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f08
expr_stmt|;
name|vmf
operator|.
name|vmf_ebx
operator|=
literal|1
expr_stmt|;
comment|/* get DAC width */
name|err
operator|=
name|vm86_intcall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
condition|)
return|return
literal|6
return|;
comment|/* XXX */
return|return
operator|(
operator|(
name|vmf
operator|.
name|vmf_ebx
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_set_dac
parameter_list|(
name|int
name|bits
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f08
expr_stmt|;
name|vmf
operator|.
name|vmf_ebx
operator|=
operator|(
name|bits
operator|<<
literal|8
operator|)
expr_stmt|;
name|err
operator|=
name|vm86_intcall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
condition|)
return|return
literal|6
return|;
comment|/* XXX */
return|return
operator|(
operator|(
name|vmf
operator|.
name|vmf_ebx
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_save_palette
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f09
expr_stmt|;
name|vmf
operator|.
name|vmf_ebx
operator|=
literal|1
expr_stmt|;
comment|/* get primary palette data */
name|vmf
operator|.
name|vmf_ecx
operator|=
name|colors
expr_stmt|;
name|vmf
operator|.
name|vmf_edx
operator|=
name|start
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
name|vm86_getpage
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm86_getptr
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|p
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_es
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_di
argument_list|)
expr_stmt|;
name|err
operator|=
name|vm86_datacall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|,
operator|&
name|vesa_vmcontext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
condition|)
return|return
literal|1
return|;
name|bits
operator|=
literal|8
operator|-
name|bits
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
operator|++
name|i
control|)
block|{
name|palette
index|[
name|i
operator|*
literal|3
index|]
operator|=
name|p
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|<<
name|bits
expr_stmt|;
name|palette
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|=
name|p
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|<<
name|bits
expr_stmt|;
name|palette
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|=
name|p
index|[
name|i
operator|*
literal|4
index|]
operator|<<
name|bits
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_save_palette2
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|r
parameter_list|,
name|u_char
modifier|*
name|g
parameter_list|,
name|u_char
modifier|*
name|b
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f09
expr_stmt|;
name|vmf
operator|.
name|vmf_ebx
operator|=
literal|1
expr_stmt|;
comment|/* get primary palette data */
name|vmf
operator|.
name|vmf_ecx
operator|=
name|colors
expr_stmt|;
name|vmf
operator|.
name|vmf_edx
operator|=
name|start
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
name|vm86_getpage
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm86_getptr
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|p
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_es
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_di
argument_list|)
expr_stmt|;
name|err
operator|=
name|vm86_datacall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|,
operator|&
name|vesa_vmcontext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
condition|)
return|return
literal|1
return|;
name|bits
operator|=
literal|8
operator|-
name|bits
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
operator|++
name|i
control|)
block|{
name|r
index|[
name|i
index|]
operator|=
name|p
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|<<
name|bits
expr_stmt|;
name|g
index|[
name|i
index|]
operator|=
name|p
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|<<
name|bits
expr_stmt|;
name|b
index|[
name|i
index|]
operator|=
name|p
index|[
name|i
operator|*
literal|4
index|]
operator|<<
name|bits
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_load_palette
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
name|vm86_getpage
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bits
operator|=
literal|8
operator|-
name|bits
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
operator|++
name|i
control|)
block|{
name|p
index|[
name|i
operator|*
literal|4
index|]
operator|=
name|palette
index|[
name|i
operator|*
literal|3
operator|+
literal|2
index|]
operator|>>
name|bits
expr_stmt|;
name|p
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|=
name|palette
index|[
name|i
operator|*
literal|3
operator|+
literal|1
index|]
operator|>>
name|bits
expr_stmt|;
name|p
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|=
name|palette
index|[
name|i
operator|*
literal|3
index|]
operator|>>
name|bits
expr_stmt|;
name|p
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f09
expr_stmt|;
name|vmf
operator|.
name|vmf_ebx
operator|=
literal|0
expr_stmt|;
comment|/* set primary palette data */
name|vmf
operator|.
name|vmf_ecx
operator|=
name|colors
expr_stmt|;
name|vmf
operator|.
name|vmf_edx
operator|=
name|start
expr_stmt|;
name|vm86_getptr
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|p
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_es
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_di
argument_list|)
expr_stmt|;
name|err
operator|=
name|vm86_datacall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|,
operator|&
name|vesa_vmcontext
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|vesa_bios_load_palette2
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|colors
parameter_list|,
name|u_char
modifier|*
name|r
parameter_list|,
name|u_char
modifier|*
name|g
parameter_list|,
name|u_char
modifier|*
name|b
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
name|vm86_getpage
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bits
operator|=
literal|8
operator|-
name|bits
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|colors
condition|;
operator|++
name|i
control|)
block|{
name|p
index|[
name|i
operator|*
literal|4
index|]
operator|=
name|b
index|[
name|i
index|]
operator|>>
name|bits
expr_stmt|;
name|p
index|[
name|i
operator|*
literal|4
operator|+
literal|1
index|]
operator|=
name|g
index|[
name|i
index|]
operator|>>
name|bits
expr_stmt|;
name|p
index|[
name|i
operator|*
literal|4
operator|+
literal|2
index|]
operator|=
name|r
index|[
name|i
index|]
operator|>>
name|bits
expr_stmt|;
name|p
index|[
name|i
operator|*
literal|4
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f09
expr_stmt|;
name|vmf
operator|.
name|vmf_ebx
operator|=
literal|0
expr_stmt|;
comment|/* set primary palette data */
name|vmf
operator|.
name|vmf_ecx
operator|=
name|colors
expr_stmt|;
name|vmf
operator|.
name|vmf_edx
operator|=
name|start
expr_stmt|;
name|vm86_getptr
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|p
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_es
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_di
argument_list|)
expr_stmt|;
name|err
operator|=
name|vm86_datacall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|,
operator|&
name|vesa_vmcontext
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vesa_bios_state_buf_size
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f04
expr_stmt|;
name|vmf
operator|.
name|vmf_ecx
operator|=
name|STATE_MOST
expr_stmt|;
name|vmf
operator|.
name|vmf_edx
operator|=
name|STATE_SIZE
expr_stmt|;
name|err
operator|=
name|vm86_intcall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
condition|)
return|return
literal|0
return|;
return|return
name|vmf
operator|.
name|vmf_bx
operator|*
literal|64
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_save_restore
parameter_list|(
name|int
name|code
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f04
expr_stmt|;
name|vmf
operator|.
name|vmf_ecx
operator|=
name|STATE_MOST
expr_stmt|;
name|vmf
operator|.
name|vmf_edx
operator|=
name|code
expr_stmt|;
comment|/* STATE_SAVE/STATE_LOAD */
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|vm86_getpage
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm86_getptr
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|buf
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_es
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_di
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|err
operator|=
name|vm86_datacall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|,
operator|&
name|vesa_vmcontext
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_get_line_length
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f06
expr_stmt|;
name|vmf
operator|.
name|vmf_ebx
operator|=
literal|1
expr_stmt|;
comment|/* get scan line length */
name|err
operator|=
name|vm86_intcall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|vmf
operator|.
name|vmf_bx
return|;
comment|/* line length in bytes */
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_set_line_length
parameter_list|(
name|int
name|pixel
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f06
expr_stmt|;
name|vmf
operator|.
name|vmf_ebx
operator|=
literal|0
expr_stmt|;
comment|/* set scan line length in pixel */
name|vmf
operator|.
name|vmf_ecx
operator|=
name|pixel
expr_stmt|;
name|err
operator|=
name|vm86_intcall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"bx:%d, cx:%d, dx:%d\n"
argument_list|,
name|vmf
operator|.
name|vmf_bx
argument_list|,
name|vmf
operator|.
name|vmf_cx
argument_list|,
name|vmf
operator|.
name|vmf_dx
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int vesa_bios_get_start(int *x, int *y) { 	struct vm86frame vmf; 	int err;  	bzero(&vmf, sizeof(vmf)); 	vmf.vmf_eax = 0x4f07;  	vmf.vmf_ebx = 1;
comment|/* get display start */
end_comment

begin_endif
unit|err = vm86_intcall(0x10,&vmf); 	if ((err != 0) || (vmf.vmf_ax != 0x4f)) 		return 1; 	*x = vmf.vmf_cx; 	*y = vmf.vmf_dx; 	return 0; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vesa_bios_set_start
parameter_list|(
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f07
expr_stmt|;
name|vmf
operator|.
name|vmf_ebx
operator|=
literal|0x80
expr_stmt|;
comment|/* set display start */
name|vmf
operator|.
name|vmf_edx
operator|=
name|y
expr_stmt|;
name|vmf
operator|.
name|vmf_ecx
operator|=
name|x
expr_stmt|;
name|err
operator|=
name|vm86_intcall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* map a generic video mode to a known mode */
end_comment

begin_function
specifier|static
name|int
name|vesa_map_gen_mode_num
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|color
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
block|}
name|mode_map
index|[]
init|=
block|{
block|{
name|M_TEXT_132x25
block|,
name|M_VESA_C132x25
block|}
block|,
block|{
name|M_TEXT_132x43
block|,
name|M_VESA_C132x43
block|}
block|,
block|{
name|M_TEXT_132x50
block|,
name|M_VESA_C132x50
block|}
block|,
block|{
name|M_TEXT_132x60
block|,
name|M_VESA_C132x60
block|}
block|,     }
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mode_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mode_map
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mode_map
index|[
name|i
index|]
operator|.
name|from
operator|==
name|mode
condition|)
return|return
name|mode_map
index|[
name|i
index|]
operator|.
name|to
return|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_translate_flags
parameter_list|(
name|u_int16_t
name|vflags
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|u_int16_t
name|mask
decl_stmt|;
name|int
name|set
decl_stmt|;
name|int
name|reset
decl_stmt|;
block|}
name|ftable
index|[]
init|=
block|{
block|{
name|V_MODECOLOR
block|,
name|V_INFO_COLOR
block|,
literal|0
block|}
block|,
block|{
name|V_MODEGRAPHICS
block|,
name|V_INFO_GRAPHICS
block|,
literal|0
block|}
block|,
block|{
name|V_MODELFB
block|,
name|V_INFO_LINEAR
block|,
literal|0
block|}
block|, 	}
struct|;
name|int
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|flags
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ftable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ftable
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|flags
operator||=
operator|(
name|vflags
operator|&
name|ftable
index|[
name|i
index|]
operator|.
name|mask
operator|)
condition|?
name|ftable
index|[
name|i
index|]
operator|.
name|set
else|:
name|ftable
index|[
name|i
index|]
operator|.
name|reset
expr_stmt|;
block|}
return|return
name|flags
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_translate_mmodel
parameter_list|(
name|u_int8_t
name|vmodel
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|u_int8_t
name|vmodel
decl_stmt|;
name|int
name|mmodel
decl_stmt|;
block|}
name|mtable
index|[]
init|=
block|{
block|{
name|V_MMTEXT
block|,
name|V_INFO_MM_TEXT
block|}
block|,
block|{
name|V_MMCGA
block|,
name|V_INFO_MM_CGA
block|}
block|,
block|{
name|V_MMHGC
block|,
name|V_INFO_MM_HGC
block|}
block|,
block|{
name|V_MMEGA
block|,
name|V_INFO_MM_PLANAR
block|}
block|,
block|{
name|V_MMPACKED
block|,
name|V_INFO_MM_PACKED
block|}
block|,
block|{
name|V_MMDIRCOLOR
block|,
name|V_INFO_MM_DIRECT
block|}
block|, 	}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|mtable
index|[
name|i
index|]
operator|.
name|mmodel
operator|>=
literal|0
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mtable
index|[
name|i
index|]
operator|.
name|vmodel
operator|==
name|vmodel
condition|)
return|return
name|mtable
index|[
name|i
index|]
operator|.
name|mmodel
return|;
block|}
return|return
name|V_INFO_MM_OTHER
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|vesa_fix_ptr
parameter_list|(
name|u_int32_t
name|p
parameter_list|,
name|u_int16_t
name|seg
parameter_list|,
name|u_int16_t
name|off
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
operator|(
name|p
operator|>>
literal|16
operator|)
operator|==
name|seg
operator|)
operator|&&
operator|(
operator|(
name|p
operator|&
literal|0xffff
operator|)
operator|>=
name|off
operator|)
condition|)
return|return
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
operator|(
operator|(
name|p
operator|&
literal|0xffff
operator|)
operator|-
name|off
operator|)
operator|)
return|;
else|else
block|{
name|p
operator|=
name|BIOS_SADDRTOLADDR
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|void
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|p
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|u_char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|struct
name|vesa_mode
name|vmode
decl_stmt|;
name|video_info_t
modifier|*
name|p
decl_stmt|;
name|u_char
modifier|*
name|vmbuf
decl_stmt|;
name|int
name|modes
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vesa_init_done
condition|)
return|return
literal|0
return|;
name|has_vesa_bios
operator|=
name|FALSE
expr_stmt|;
name|vesa_adp_info
operator|=
name|NULL
expr_stmt|;
name|vesa_vmode_max
operator|=
literal|0
expr_stmt|;
name|vesa_vmode
index|[
literal|0
index|]
operator|.
name|vi_mode
operator|=
name|EOT
expr_stmt|;
name|vmbuf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|vm86_addpage
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* paranoia */
name|bcopy
argument_list|(
literal|"VBE2"
argument_list|,
name|vmbuf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* try for VBE2 data */
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f00
expr_stmt|;
name|vm86_getptr
argument_list|(
operator|&
name|vesa_vmcontext
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|vmbuf
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_es
argument_list|,
operator|&
name|vmf
operator|.
name|vmf_di
argument_list|)
expr_stmt|;
name|err
operator|=
name|vm86_datacall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|,
operator|&
name|vesa_vmcontext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
operator|||
name|bcmp
argument_list|(
literal|"VESA"
argument_list|,
name|vmbuf
argument_list|,
literal|4
argument_list|)
condition|)
return|return
literal|1
return|;
name|bcopy
argument_list|(
name|vmbuf
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|vesa_adp_info
operator|=
operator|(
expr|struct
name|vesa_info
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"VESA: information block\n"
argument_list|)
expr_stmt|;
name|dump_buffer
argument_list|(
name|buf
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vesa_adp_info
operator|->
name|v_flags
operator|&
name|V_NONVGA
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|vesa_adp_info
operator|->
name|v_version
operator|<
literal|0x0102
condition|)
block|{
name|printf
argument_list|(
literal|"VESA: VBE version %d.%d is not supported; "
literal|"version 1.2 or later is required.\n"
argument_list|,
operator|(
operator|(
name|vesa_adp_info
operator|->
name|v_version
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|vesa_adp_info
operator|->
name|v_version
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
operator|)
argument_list|,
operator|(
operator|(
name|vesa_adp_info
operator|->
name|v_version
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
operator|)
operator|*
literal|10
operator|+
operator|(
name|vesa_adp_info
operator|->
name|v_version
operator|&
literal|0x000f
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* fix string ptrs */
name|vesa_oemstr
operator|=
operator|(
name|char
operator|*
operator|)
name|vesa_fix_ptr
argument_list|(
name|vesa_adp_info
operator|->
name|v_oemstr
argument_list|,
name|vmf
operator|.
name|vmf_es
argument_list|,
name|vmf
operator|.
name|vmf_di
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|vesa_adp_info
operator|->
name|v_version
operator|>=
literal|0x0200
condition|)
block|{
name|vesa_venderstr
operator|=
operator|(
name|char
operator|*
operator|)
name|vesa_fix_ptr
argument_list|(
name|vesa_adp_info
operator|->
name|v_venderstr
argument_list|,
name|vmf
operator|.
name|vmf_es
argument_list|,
name|vmf
operator|.
name|vmf_di
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|vesa_prodstr
operator|=
operator|(
name|char
operator|*
operator|)
name|vesa_fix_ptr
argument_list|(
name|vesa_adp_info
operator|->
name|v_prodstr
argument_list|,
name|vmf
operator|.
name|vmf_es
argument_list|,
name|vmf
operator|.
name|vmf_di
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|vesa_revstr
operator|=
operator|(
name|char
operator|*
operator|)
name|vesa_fix_ptr
argument_list|(
name|vesa_adp_info
operator|->
name|v_revstr
argument_list|,
name|vmf
operator|.
name|vmf_es
argument_list|,
name|vmf
operator|.
name|vmf_di
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* obtain video mode information */
name|vesa_vmodetab
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|vesa_fix_ptr
argument_list|(
name|vesa_adp_info
operator|->
name|v_modetable
argument_list|,
name|vmf
operator|.
name|vmf_es
argument_list|,
name|vmf
operator|.
name|vmf_di
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|vesa_vmodetab
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|modes
operator|=
literal|0
init|;
operator|(
name|i
operator|<
operator|(
name|M_VESA_MODE_MAX
operator|-
name|M_VESA_BASE
operator|+
literal|1
operator|)
operator|)
operator|&&
operator|(
name|vesa_vmodetab
index|[
name|i
index|]
operator|!=
literal|0xffff
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|vesa_bios_get_mode
argument_list|(
name|vesa_vmodetab
index|[
name|i
index|]
argument_list|,
operator|&
name|vmode
argument_list|)
condition|)
continue|continue;
comment|/* reject unsupported modes */
if|#
directive|if
literal|0
block|if ((vmode.v_modeattr& (V_MODESUPP | V_MODEOPTINFO  					| V_MODENONVGA)) 		    != (V_MODESUPP | V_MODEOPTINFO)) 			continue;
else|#
directive|else
if|if
condition|(
operator|(
name|vmode
operator|.
name|v_modeattr
operator|&
operator|(
name|V_MODEOPTINFO
operator||
name|V_MODENONVGA
operator|)
operator|)
operator|!=
operator|(
name|V_MODEOPTINFO
operator|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* expand the array if necessary */
if|if
condition|(
name|modes
operator|>=
name|vesa_vmode_max
condition|)
block|{
name|vesa_vmode_max
operator|+=
name|MODE_TABLE_DELTA
expr_stmt|;
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vesa_vmode
argument_list|)
operator|*
operator|(
name|vesa_vmode_max
operator|+
literal|1
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"vesa_bios_init(): modes:%d, vesa_mode_max:%d\n"
argument_list|,
name|modes
argument_list|,
name|vesa_vmode_max
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|modes
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|vesa_vmode
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vesa_vmode
argument_list|)
operator|*
name|modes
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vesa_vmode
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|vesa_vmode
operator|=
name|p
expr_stmt|;
block|}
comment|/* copy some fields */
name|bzero
argument_list|(
operator|&
name|vesa_vmode
index|[
name|modes
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|vesa_vmode
index|[
name|modes
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_mode
operator|=
name|vesa_vmodetab
index|[
name|i
index|]
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_width
operator|=
name|vmode
operator|.
name|v_width
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_height
operator|=
name|vmode
operator|.
name|v_height
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_depth
operator|=
name|vmode
operator|.
name|v_bpp
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_planes
operator|=
name|vmode
operator|.
name|v_planes
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_cwidth
operator|=
name|vmode
operator|.
name|v_cwidth
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_cheight
operator|=
name|vmode
operator|.
name|v_cheight
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_window
operator|=
operator|(
name|u_int
operator|)
name|vmode
operator|.
name|v_waseg
operator|<<
literal|4
expr_stmt|;
comment|/* XXX window B */
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_window_size
operator|=
name|vmode
operator|.
name|v_wsize
operator|*
literal|1024
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_window_gran
operator|=
name|vmode
operator|.
name|v_wgran
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODELFB
condition|)
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_buffer
operator|=
name|vmode
operator|.
name|v_lfb
expr_stmt|;
else|else
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_buffer
operator|=
literal|0
expr_stmt|;
comment|/* XXX */
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_buffer_size
operator|=
name|vesa_adp_info
operator|->
name|v_memsize
operator|*
literal|64
operator|*
literal|1024
expr_stmt|;
if|#
directive|if
literal|0
block|if (vmode.v_offscreen> vmode.v_lfb) 			vesa_vmode[modes].vi_buffer_size 				= vmode.v_offscreen + vmode.v_offscreensize*1024 				      - vmode.v_lfb; 		else 			vesa_vmode[modes].vi_buffer_size 				= vmode.v_offscreen + vmode.v_offscreensize*1024
endif|#
directive|endif
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_mem_model
operator|=
name|vesa_translate_mmodel
argument_list|(
name|vmode
operator|.
name|v_memmodel
argument_list|)
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_mem_model
operator|==
name|V_INFO_MM_PACKED
condition|)
block|{
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_size
operator|=
operator|(
name|vmode
operator|.
name|v_bpp
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_mem_model
operator|==
name|V_INFO_MM_DIRECT
condition|)
block|{
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_size
operator|=
operator|(
name|vmode
operator|.
name|v_bpp
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|0
index|]
operator|=
name|vmode
operator|.
name|v_redfieldpos
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|1
index|]
operator|=
name|vmode
operator|.
name|v_greenfieldpos
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|2
index|]
operator|=
name|vmode
operator|.
name|v_bluefieldpos
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fields
index|[
literal|3
index|]
operator|=
name|vmode
operator|.
name|v_resfieldpos
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|0
index|]
operator|=
name|vmode
operator|.
name|v_redmasksize
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|1
index|]
operator|=
name|vmode
operator|.
name|v_greenmasksize
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|2
index|]
operator|=
name|vmode
operator|.
name|v_bluemasksize
expr_stmt|;
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_fsizes
index|[
literal|3
index|]
operator|=
name|vmode
operator|.
name|v_resmasksize
expr_stmt|;
block|}
else|else
block|{
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_pixel_size
operator|=
literal|0
expr_stmt|;
block|}
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_flags
operator|=
name|vesa_translate_flags
argument_list|(
name|vmode
operator|.
name|v_modeattr
argument_list|)
operator||
name|V_INFO_VESA
expr_stmt|;
operator|++
name|modes
expr_stmt|;
block|}
name|vesa_vmode
index|[
name|modes
index|]
operator|.
name|vi_mode
operator|=
name|EOT
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"VESA: %d mode(s) found\n"
argument_list|,
name|modes
argument_list|)
expr_stmt|;
name|has_vesa_bios
operator|=
operator|(
name|modes
operator|>
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|has_vesa_bios
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vesa_clear_modes
parameter_list|(
name|video_info_t
modifier|*
name|info
parameter_list|,
name|int
name|color
parameter_list|)
block|{
while|while
condition|(
name|info
operator|->
name|vi_mode
operator|!=
name|EOT
condition|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|vi_flags
operator|&
name|V_INFO_COLOR
operator|)
operator|!=
name|color
condition|)
name|info
operator|->
name|vi_mode
operator|=
name|NA
expr_stmt|;
operator|++
name|info
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|vesa_map_buffer
parameter_list|(
name|u_int
name|paddr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|vaddr
decl_stmt|;
name|u_int
name|off
decl_stmt|;
name|off
operator|=
name|paddr
operator|-
name|trunc_page
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|pmap_mapdev
argument_list|(
name|paddr
operator|-
name|off
argument_list|,
name|size
operator|+
name|off
argument_list|)
expr_stmt|;
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"vesa_map_buffer: paddr:%x vaddr:%x size:%x off:%x\n"
argument_list|,
name|paddr
argument_list|,
name|vaddr
argument_list|,
name|size
argument_list|,
name|off
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|vaddr
operator|+
name|off
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vesa_unmap_buffer
parameter_list|(
name|vm_offset_t
name|vaddr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"vesa_unmap_buffer: vaddr:%x size:%x\n"
argument_list|,
name|vaddr
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|vaddr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* entry points */
end_comment

begin_function
specifier|static
name|int
name|vesa_configure
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|video_adapter_t
modifier|*
name|adp
decl_stmt|;
name|int
name|adapters
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vesa_init_done
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flags
operator|&
name|VIO_PROBE_ONLY
condition|)
return|return
literal|0
return|;
comment|/* XXX */
comment|/* 	 * If the VESA module has already been loaded, abort loading  	 * the module this time. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|adp
operator|=
name|vid_get_adapter
argument_list|(
name|i
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_VESA
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_VGA
condition|)
break|break;
block|}
comment|/* 	 * The VGA adapter is not found.  This is because either  	 * 1) the VGA driver has not been initialized, or 2) the VGA card 	 * is not present.  If 1) is the case, we shall defer 	 * initialization for now and try again later. 	 */
if|if
condition|(
name|adp
operator|==
name|NULL
condition|)
block|{
name|vga_sub_configure
operator|=
name|vesa_configure
expr_stmt|;
return|return
name|ENODEV
return|;
block|}
comment|/* count number of registered adapters */
for|for
control|(
operator|++
name|i
init|;
name|vid_get_adapter
argument_list|(
name|i
argument_list|)
operator|!=
name|NULL
condition|;
operator|++
name|i
control|)
empty_stmt|;
name|adapters
operator|=
name|i
expr_stmt|;
comment|/* call VESA BIOS */
name|vesa_adp
operator|=
name|adp
expr_stmt|;
if|if
condition|(
name|vesa_bios_init
argument_list|()
condition|)
block|{
name|vesa_adp
operator|=
name|NULL
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|vesa_adp
operator|->
name|va_flags
operator||=
name|V_ADP_VESA
expr_stmt|;
comment|/* remove conflicting modes if we have more than one adapter */
if|if
condition|(
name|adapters
operator|>
literal|1
condition|)
block|{
name|vesa_clear_modes
argument_list|(
name|vesa_vmode
argument_list|,
operator|(
name|vesa_adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
name|V_INFO_COLOR
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|vesa_load_ioctl
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|prevvidsw
operator|=
name|vidsw
index|[
name|vesa_adp
operator|->
name|va_index
index|]
expr_stmt|;
name|vidsw
index|[
name|vesa_adp
operator|->
name|va_index
index|]
operator|=
operator|&
name|vesavidsw
expr_stmt|;
name|vesa_init_done
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|vesa_adp
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int vesa_nop(void) { 	return 0; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vesa_error
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_probe
parameter_list|(
name|int
name|unit
parameter_list|,
name|video_adapter_t
modifier|*
modifier|*
name|adpp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|probe
call|)
argument_list|(
name|unit
argument_list|,
name|adpp
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_init
parameter_list|(
name|int
name|unit
parameter_list|,
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|init
call|)
argument_list|(
name|unit
argument_list|,
name|adp
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_get_info
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|mode
parameter_list|,
name|video_info_t
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|prevvidsw
operator|->
name|get_info
call|)
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|,
name|info
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
literal|1
return|;
name|mode
operator|=
name|vesa_map_gen_mode_num
argument_list|(
name|vesa_adp
operator|->
name|va_type
argument_list|,
name|vesa_adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|!=
name|EOT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|==
name|NA
condition|)
continue|continue;
if|if
condition|(
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|==
name|mode
condition|)
block|{
operator|*
name|info
operator|=
name|vesa_vmode
index|[
name|i
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_query_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_info_t
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
call|(
modifier|*
name|prevvidsw
operator|->
name|query_mode
call|)
argument_list|(
name|adp
argument_list|,
name|info
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
return|return
name|i
return|;
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|!=
name|EOT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|info
operator|->
name|vi_width
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_width
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_width
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_height
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_height
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_height
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_cwidth
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_cwidth
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_cwidth
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_cheight
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_cheight
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_cheight
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_depth
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_depth
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_depth
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_planes
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_planes
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_planes
operator|)
condition|)
continue|continue;
comment|/* pixel format, memory model */
if|if
condition|(
operator|(
name|info
operator|->
name|vi_flags
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_flags
operator|!=
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_flags
operator|)
condition|)
continue|continue;
return|return
name|vesa_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_set_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|set_mode
call|)
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|)
return|;
name|mode
operator|=
name|vesa_map_gen_mode_num
argument_list|(
name|adp
operator|->
name|va_type
argument_list|,
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"VESA: set_mode(): %d(%x) -> %d(%x)\n"
argument_list|,
name|adp
operator|->
name|va_mode
argument_list|,
name|adp
operator|->
name|va_mode
argument_list|,
name|mode
argument_list|,
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  	 * If the current mode is a VESA mode and the new mode is not, 	 * restore the state of the adapter first by setting one of the 	 * standard VGA mode, so that non-standard, extended SVGA registers  	 * are set to the state compatible with the standard VGA modes.  	 * Otherwise (*prevvidsw->set_mode)() may not be able to set up  	 * the new mode correctly. 	 */
if|if
condition|(
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|prevvidsw
operator|->
name|get_info
call|)
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|,
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int10_set_mode
argument_list|(
name|adp
operator|->
name|va_initial_bios_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|va_info
operator|.
name|vi_flags
operator|&
name|V_INFO_LINEAR
condition|)
name|vesa_unmap_buffer
argument_list|(
name|adp
operator|->
name|va_buffer
argument_list|,
name|vesa_adp_info
operator|->
name|v_memsize
operator|*
literal|64
operator|*
literal|1024
argument_list|)
expr_stmt|;
comment|/*  			 * Once (*prevvidsw->get_info)() succeeded,  			 * (*prevvidsw->set_mode)() below won't fail... 			 */
block|}
block|}
comment|/* we may not need to handle this mode after all... */
if|if
condition|(
call|(
modifier|*
name|prevvidsw
operator|->
name|set_mode
call|)
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* is the new mode supported? */
if|if
condition|(
name|vesa_get_info
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|,
operator|&
name|info
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* assert(VESA_MODE(mode)); */
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"VESA: about to set a VESA mode...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* don't use the linear frame buffer for text modes. XXX */
if|if
condition|(
operator|!
operator|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
operator|)
condition|)
name|info
operator|.
name|vi_flags
operator|&=
operator|~
name|V_INFO_LINEAR
expr_stmt|;
if|if
condition|(
name|vesa_bios_set_mode
argument_list|(
name|mode
operator||
operator|(
operator|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_LINEAR
operator|)
condition|?
literal|0x4000
else|:
literal|0
operator|)
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|adp
operator|->
name|va_info
operator|.
name|vi_flags
operator|&
name|V_INFO_LINEAR
condition|)
name|vesa_unmap_buffer
argument_list|(
name|adp
operator|->
name|va_buffer
argument_list|,
name|vesa_adp_info
operator|->
name|v_memsize
operator|*
literal|64
operator|*
literal|1024
argument_list|)
expr_stmt|;
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"VESA: mode set!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vesa_adp
operator|->
name|va_mode
operator|=
name|mode
expr_stmt|;
name|vesa_adp
operator|->
name|va_flags
operator|&=
operator|~
name|V_ADP_COLOR
expr_stmt|;
name|vesa_adp
operator|->
name|va_flags
operator||=
operator|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_COLOR
operator|)
condition|?
name|V_ADP_COLOR
else|:
literal|0
expr_stmt|;
name|vesa_adp
operator|->
name|va_crtc_addr
operator|=
operator|(
name|vesa_adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
name|COLOR_CRTC
else|:
name|MONO_CRTC
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_LINEAR
condition|)
block|{
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|printf
argument_list|(
literal|"VESA: setting up LFB\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vesa_adp
operator|->
name|va_buffer
operator|=
name|vesa_map_buffer
argument_list|(
name|info
operator|.
name|vi_buffer
argument_list|,
name|vesa_adp_info
operator|->
name|v_memsize
operator|*
literal|64
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|vesa_adp
operator|->
name|va_buffer_size
operator|=
name|info
operator|.
name|vi_buffer_size
expr_stmt|;
name|vesa_adp
operator|->
name|va_window
operator|=
name|vesa_adp
operator|->
name|va_buffer
expr_stmt|;
name|vesa_adp
operator|->
name|va_window_size
operator|=
name|info
operator|.
name|vi_buffer_size
operator|/
name|info
operator|.
name|vi_planes
expr_stmt|;
name|vesa_adp
operator|->
name|va_window_gran
operator|=
name|info
operator|.
name|vi_buffer_size
operator|/
name|info
operator|.
name|vi_planes
expr_stmt|;
block|}
else|else
block|{
name|vesa_adp
operator|->
name|va_buffer
operator|=
literal|0
expr_stmt|;
name|vesa_adp
operator|->
name|va_buffer_size
operator|=
name|info
operator|.
name|vi_buffer_size
expr_stmt|;
name|vesa_adp
operator|->
name|va_window
operator|=
name|BIOS_PADDRTOVADDR
argument_list|(
name|info
operator|.
name|vi_window
argument_list|)
expr_stmt|;
name|vesa_adp
operator|->
name|va_window_size
operator|=
name|info
operator|.
name|vi_window_size
expr_stmt|;
name|vesa_adp
operator|->
name|va_window_gran
operator|=
name|info
operator|.
name|vi_window_gran
expr_stmt|;
block|}
name|vesa_adp
operator|->
name|va_window_orig
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|vesa_bios_get_line_length
argument_list|()
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|vesa_adp
operator|->
name|va_line_width
operator|=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
block|{
switch|switch
condition|(
name|info
operator|.
name|vi_depth
operator|/
name|info
operator|.
name|vi_planes
condition|)
block|{
case|case
literal|1
case|:
name|vesa_adp
operator|->
name|va_line_width
operator|=
name|info
operator|.
name|vi_width
operator|/
literal|8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|vesa_adp
operator|->
name|va_line_width
operator|=
name|info
operator|.
name|vi_width
operator|/
literal|4
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|vesa_adp
operator|->
name|va_line_width
operator|=
name|info
operator|.
name|vi_width
operator|/
literal|2
expr_stmt|;
break|break;
case|case
literal|8
case|:
default|default:
comment|/* shouldn't happen */
name|vesa_adp
operator|->
name|va_line_width
operator|=
name|info
operator|.
name|vi_width
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|vesa_adp
operator|->
name|va_line_width
operator|=
name|info
operator|.
name|vi_width
expr_stmt|;
block|}
name|vesa_adp
operator|->
name|va_disp_start
operator|.
name|x
operator|=
literal|0
expr_stmt|;
name|vesa_adp
operator|->
name|va_disp_start
operator|.
name|y
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"vesa_set_mode(): vi_width:%d, len:%d, line_width:%d\n"
argument_list|,
name|info
operator|.
name|vi_width
argument_list|,
name|len
argument_list|,
name|vesa_adp
operator|->
name|va_line_width
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
operator|&
name|info
argument_list|,
operator|&
name|vesa_adp
operator|->
name|va_info
argument_list|,
sizeof|sizeof
argument_list|(
name|vesa_adp
operator|->
name|va_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* move hardware cursor out of the way */
operator|(
operator|*
name|vidsw
index|[
name|vesa_adp
operator|->
name|va_index
index|]
operator|->
name|set_hw_cursor
operator|)
operator|(
name|vesa_adp
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_save_font
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|fontsize
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|count
parameter_list|)
block|{
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|save_font
call|)
argument_list|(
name|adp
argument_list|,
name|page
argument_list|,
name|fontsize
argument_list|,
name|data
argument_list|,
name|ch
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_load_font
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|fontsize
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|count
parameter_list|)
block|{
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|load_font
call|)
argument_list|(
name|adp
argument_list|,
name|page
argument_list|,
name|fontsize
argument_list|,
name|data
argument_list|,
name|ch
argument_list|,
name|count
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_show_font
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|page
parameter_list|)
block|{
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|show_font
call|)
argument_list|(
name|adp
argument_list|,
name|page
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_save_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|bits
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|adp
operator|==
name|vesa_adp
operator|)
operator|&&
operator|(
name|vesa_adp_info
operator|->
name|v_flags
operator|&
name|V_DAC8
operator|)
operator|&&
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
condition|)
block|{
name|bits
operator|=
name|vesa_bios_get_dac
argument_list|()
expr_stmt|;
name|error
operator|=
name|vesa_bios_save_palette
argument_list|(
literal|0
argument_list|,
literal|256
argument_list|,
name|palette
argument_list|,
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|bits
operator|!=
literal|6
condition|)
return|return
name|error
return|;
block|}
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|save_palette
call|)
argument_list|(
name|adp
argument_list|,
name|palette
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_load_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|)
block|{
if|#
directive|if
name|notyet
name|int
name|bits
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|adp
operator|==
name|vesa_adp
operator|)
operator|&&
operator|(
name|vesa_adp_info
operator|->
name|v_flags
operator|&
name|V_DAC8
operator|)
operator|&&
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
operator|&&
operator|(
operator|(
name|bits
operator|=
name|vesa_bios_set_dac
argument_list|(
literal|8
argument_list|)
operator|)
operator|>
literal|6
operator|)
condition|)
block|{
name|error
operator|=
name|vesa_bios_load_palette
argument_list|(
literal|0
argument_list|,
literal|256
argument_list|,
name|palette
argument_list|,
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|vesa_bios_set_dac
argument_list|(
literal|6
argument_list|)
operator|!=
literal|6
condition|)
return|return
literal|1
return|;
block|}
endif|#
directive|endif
comment|/* notyet */
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|load_palette
call|)
argument_list|(
name|adp
argument_list|,
name|palette
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_set_border
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|color
parameter_list|)
block|{
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|set_border
call|)
argument_list|(
name|adp
argument_list|,
name|color
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_save_state
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|save_state
call|)
argument_list|(
name|adp
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
return|;
if|if
condition|(
name|vesa_state_buf_size
operator|==
literal|0
condition|)
name|vesa_state_buf_size
operator|=
name|vesa_bios_state_buf_size
argument_list|()
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|vesa_state_buf_size
operator|)
return|;
elseif|else
if|if
condition|(
name|size
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
name|vesa_state_buf_size
operator|)
condition|)
return|return
literal|1
return|;
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|sig
operator|=
name|V_STATE_SIG
expr_stmt|;
name|bzero
argument_list|(
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|regs
argument_list|,
name|vesa_state_buf_size
argument_list|)
expr_stmt|;
return|return
name|vesa_bios_save_restore
argument_list|(
name|STATE_SAVE
argument_list|,
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|regs
argument_list|,
name|vesa_state_buf_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_load_state
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|(
name|adp
operator|!=
name|vesa_adp
operator|)
operator|||
operator|(
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|sig
operator|!=
name|V_STATE_SIG
operator|)
condition|)
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|load_state
call|)
argument_list|(
name|adp
argument_list|,
name|p
argument_list|)
return|;
return|return
name|vesa_bios_save_restore
argument_list|(
name|STATE_LOAD
argument_list|,
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|regs
argument_list|,
name|vesa_state_buf_size
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int vesa_get_origin(video_adapter_t *adp, off_t *offset) { 	struct vm86frame vmf; 	int err;  	bzero(&vmf, sizeof(vmf)); 	vmf.vmf_eax = 0x4f05;  	vmf.vmf_ebx = 0x10;
comment|/* WINDOW_A, XXX */
end_comment

begin_endif
unit|err = vm86_intcall(0x10,&vmf);  	if ((err != 0) || (vmf.vmf_ax != 0x4f)) 		return 1; 	*offset = vmf.vmf_dx*adp->va_window_gran; 	return 0; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vesa_set_origin
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * This function should return as quickly as possible to  	 * maintain good performance of the system. For this reason, 	 * error checking is kept minimal and let the VESA BIOS to  	 * detect error. 	 */
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|set_win_org
call|)
argument_list|(
name|adp
argument_list|,
name|offset
argument_list|)
return|;
comment|/* if this is a linear frame buffer, do nothing */
if|if
condition|(
name|adp
operator|->
name|va_info
operator|.
name|vi_flags
operator|&
name|V_INFO_LINEAR
condition|)
return|return
literal|0
return|;
comment|/* XXX */
if|if
condition|(
name|adp
operator|->
name|va_window_gran
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f05
expr_stmt|;
name|vmf
operator|.
name|vmf_ebx
operator|=
literal|0
expr_stmt|;
comment|/* WINDOW_A, XXX */
name|vmf
operator|.
name|vmf_edx
operator|=
name|offset
operator|/
name|adp
operator|->
name|va_window_gran
expr_stmt|;
name|err
operator|=
name|vm86_intcall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vmf
operator|.
name|vmf_ax
operator|!=
literal|0x4f
operator|)
condition|)
return|return
literal|1
return|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
name|vmf
argument_list|)
argument_list|)
expr_stmt|;
name|vmf
operator|.
name|vmf_eax
operator|=
literal|0x4f05
expr_stmt|;
name|vmf
operator|.
name|vmf_ebx
operator|=
literal|1
expr_stmt|;
comment|/* WINDOW_B, XXX */
name|vmf
operator|.
name|vmf_edx
operator|=
name|offset
operator|/
name|adp
operator|->
name|va_window_gran
expr_stmt|;
name|err
operator|=
name|vm86_intcall
argument_list|(
literal|0x10
argument_list|,
operator|&
name|vmf
argument_list|)
expr_stmt|;
name|adp
operator|->
name|va_window_orig
operator|=
operator|(
name|offset
operator|/
name|adp
operator|->
name|va_window_gran
operator|)
operator|*
name|adp
operator|->
name|va_window_gran
expr_stmt|;
return|return
literal|0
return|;
comment|/* XXX */
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_read_hw_cursor
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
modifier|*
name|col
parameter_list|,
name|int
modifier|*
name|row
parameter_list|)
block|{
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|read_hw_cursor
call|)
argument_list|(
name|adp
argument_list|,
name|col
argument_list|,
name|row
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_set_hw_cursor
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|col
parameter_list|,
name|int
name|row
parameter_list|)
block|{
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|set_hw_cursor
call|)
argument_list|(
name|adp
argument_list|,
name|col
argument_list|,
name|row
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_set_hw_cursor_shape
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|celsize
parameter_list|,
name|int
name|blink
parameter_list|)
block|{
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|set_hw_cursor_shape
call|)
argument_list|(
name|adp
argument_list|,
name|base
argument_list|,
name|height
argument_list|,
name|celsize
argument_list|,
name|blink
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_blank_display
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* XXX: use VESA DPMS */
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|blank_display
call|)
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_mmap
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|0
name|printf
argument_list|(
literal|"vesa_mmap(): window:0x%x, buffer:0x%x, offset:0x%x\n"
argument_list|,
name|adp
operator|->
name|va_info
operator|.
name|vi_window
argument_list|,
name|adp
operator|->
name|va_info
operator|.
name|vi_buffer
argument_list|,
name|offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|adp
operator|==
name|vesa_adp
operator|)
operator|&&
operator|(
name|adp
operator|->
name|va_info
operator|.
name|vi_flags
operator|&
name|V_INFO_LINEAR
operator|)
condition|)
block|{
comment|/* va_window_size == va_buffer_size/vi_planes */
comment|/* XXX: is this correct? */
if|if
condition|(
name|offset
operator|>
name|adp
operator|->
name|va_window_size
operator|-
name|PAGE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|__i386__
return|return
name|i386_btop
argument_list|(
name|adp
operator|->
name|va_info
operator|.
name|vi_buffer
operator|+
name|offset
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__alpha__
comment|/* XXX */
return|return
name|alpha_btop
argument_list|(
name|adp
operator|->
name|va_info
operator|.
name|vi_buffer
operator|+
name|offset
argument_list|)
return|;
endif|#
directive|endif
block|}
else|else
block|{
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|mmap
call|)
argument_list|(
name|adp
argument_list|,
name|offset
argument_list|,
name|prot
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_clear
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|)
block|{
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|clear
call|)
argument_list|(
name|adp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_fill_rect
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|val
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|cx
parameter_list|,
name|int
name|cy
parameter_list|)
block|{
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|fill_rect
call|)
argument_list|(
name|adp
argument_list|,
name|val
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|cx
argument_list|,
name|cy
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bitblt
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
modifier|...
parameter_list|)
block|{
comment|/* FIXME */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|red
parameter_list|,
name|u_char
modifier|*
name|green
parameter_list|,
name|u_char
modifier|*
name|blue
parameter_list|,
name|u_char
modifier|*
name|trans
parameter_list|)
block|{
name|u_char
modifier|*
name|r
decl_stmt|;
name|u_char
modifier|*
name|g
decl_stmt|;
name|u_char
modifier|*
name|b
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|base
operator|<
literal|0
operator|)
operator|||
operator|(
name|base
operator|>=
literal|256
operator|)
operator|||
operator|(
name|base
operator|+
name|count
operator|>
literal|256
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|vesa_adp_info
operator|->
name|v_flags
operator|&
name|V_DAC8
operator|)
operator|||
operator|!
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
condition|)
return|return
literal|1
return|;
name|bits
operator|=
name|vesa_bios_get_dac
argument_list|()
expr_stmt|;
if|if
condition|(
name|bits
operator|<=
literal|6
condition|)
return|return
literal|1
return|;
name|r
operator|=
name|malloc
argument_list|(
name|count
operator|*
literal|3
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|g
operator|=
name|r
operator|+
name|count
expr_stmt|;
name|b
operator|=
name|g
operator|+
name|count
expr_stmt|;
name|error
operator|=
name|vesa_bios_save_palette2
argument_list|(
name|base
argument_list|,
name|count
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|bits
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|copyout
argument_list|(
name|r
argument_list|,
name|red
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|g
argument_list|,
name|green
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|b
argument_list|,
name|blue
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|trans
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|r
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
name|r
argument_list|,
name|trans
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|r
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* if error&& bits != 6 at this point, we are in in trouble... XXX */
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|red
parameter_list|,
name|u_char
modifier|*
name|green
parameter_list|,
name|u_char
modifier|*
name|blue
parameter_list|,
name|u_char
modifier|*
name|trans
parameter_list|)
block|{
return|return
literal|1
return|;
if|#
directive|if
name|notyet
name|u_char
modifier|*
name|r
decl_stmt|;
name|u_char
modifier|*
name|g
decl_stmt|;
name|u_char
modifier|*
name|b
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|base
operator|<
literal|0
operator|)
operator|||
operator|(
name|base
operator|>=
literal|256
operator|)
operator|||
operator|(
name|base
operator|+
name|count
operator|>
literal|256
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|(
name|vesa_adp_info
operator|->
name|v_flags
operator|&
name|V_DAC8
operator|)
operator|||
operator|!
name|VESA_MODE
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
operator|||
operator|(
operator|(
name|bits
operator|=
name|vesa_bios_set_dac
argument_list|(
literal|8
argument_list|)
operator|)
operator|<=
literal|6
operator|)
condition|)
return|return
literal|1
return|;
name|r
operator|=
name|malloc
argument_list|(
name|count
operator|*
literal|3
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|g
operator|=
name|r
operator|+
name|count
expr_stmt|;
name|b
operator|=
name|g
operator|+
name|count
expr_stmt|;
name|copyin
argument_list|(
name|red
argument_list|,
name|r
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|copyin
argument_list|(
name|green
argument_list|,
name|g
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|copyin
argument_list|(
name|blue
argument_list|,
name|b
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|error
operator|=
name|vesa_bios_load_palette2
argument_list|(
name|base
argument_list|,
name|count
argument_list|,
name|r
argument_list|,
name|g
argument_list|,
name|b
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* if the following call fails, we are in trouble... XXX */
name|vesa_bios_set_dac
argument_list|(
literal|6
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* notyet */
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_ioctl
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FBIO_SETWINORG
case|:
comment|/* set frame buffer window origin */
return|return
operator|(
name|vesa_set_origin
argument_list|(
name|adp
argument_list|,
operator|*
operator|(
name|off_t
operator|*
operator|)
name|arg
argument_list|)
condition|?
name|ENODEV
else|:
literal|0
operator|)
return|;
case|case
name|FBIO_SETDISPSTART
case|:
comment|/* set display start address */
if|if
condition|(
name|vesa_bios_set_start
argument_list|(
operator|(
operator|(
name|video_display_start_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|x
argument_list|,
operator|(
operator|(
name|video_display_start_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|y
argument_list|)
condition|)
return|return
name|ENODEV
return|;
name|adp
operator|->
name|va_disp_start
operator|.
name|x
operator|=
operator|(
operator|(
name|video_display_start_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|x
expr_stmt|;
name|adp
operator|->
name|va_disp_start
operator|.
name|y
operator|=
operator|(
operator|(
name|video_display_start_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|y
expr_stmt|;
return|return
literal|0
return|;
case|case
name|FBIO_SETLINEWIDTH
case|:
comment|/* set line length in pixel */
if|if
condition|(
name|vesa_bios_set_line_length
argument_list|(
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg
argument_list|)
condition|)
return|return
name|ENODEV
return|;
name|adp
operator|->
name|va_line_width
operator|=
operator|(
operator|*
operator|(
name|u_int
operator|*
operator|)
name|arg
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
return|return
literal|0
return|;
case|case
name|FBIO_GETPALETTE
case|:
comment|/* get color palette */
if|if
condition|(
name|get_palette
argument_list|(
name|adp
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|index
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|red
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|green
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|blue
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|transparent
argument_list|)
condition|)
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|FBIO_SETPALETTE
case|:
comment|/* set color palette */
if|if
condition|(
name|set_palette
argument_list|(
name|adp
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|index
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|red
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|green
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|blue
argument_list|,
operator|(
operator|(
name|video_color_palette_t
operator|*
operator|)
name|arg
operator|)
operator|->
name|transparent
argument_list|)
condition|)
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|FBIOGETCMAP
case|:
comment|/* get color palette */
if|if
condition|(
name|get_palette
argument_list|(
name|adp
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|index
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|red
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|green
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|blue
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
return|return
literal|0
return|;
case|case
name|FBIOPUTCMAP
case|:
comment|/* set color palette */
if|if
condition|(
name|set_palette
argument_list|(
name|adp
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|index
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|count
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|red
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|green
argument_list|,
operator|(
operator|(
expr|struct
name|fbcmap
operator|*
operator|)
name|arg
operator|)
operator|->
name|blue
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
return|return
literal|0
return|;
default|default:
return|return
call|(
modifier|*
name|prevvidsw
operator|->
name|ioctl
call|)
argument_list|(
name|adp
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_diag
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* call the previous handler first */
name|error
operator|=
call|(
modifier|*
name|prevvidsw
operator|->
name|diag
call|)
argument_list|(
name|adp
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|adp
operator|!=
name|vesa_adp
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|level
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_bios_info
parameter_list|(
name|int
name|level
parameter_list|)
block|{
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
name|struct
name|vesa_mode
name|vmode
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* general adapter information */
name|printf
argument_list|(
literal|"VESA: v%d.%d, %dk memory, flags:0x%x, mode table:%p (%x)\n"
argument_list|,
operator|(
operator|(
name|vesa_adp_info
operator|->
name|v_version
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|vesa_adp_info
operator|->
name|v_version
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
operator|)
argument_list|,
operator|(
operator|(
name|vesa_adp_info
operator|->
name|v_version
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
operator|)
operator|*
literal|10
operator|+
operator|(
name|vesa_adp_info
operator|->
name|v_version
operator|&
literal|0x000f
operator|)
argument_list|,
name|vesa_adp_info
operator|->
name|v_memsize
operator|*
literal|64
argument_list|,
name|vesa_adp_info
operator|->
name|v_flags
argument_list|,
name|vesa_vmodetab
argument_list|,
name|vesa_adp_info
operator|->
name|v_modetable
argument_list|)
expr_stmt|;
comment|/* OEM string */
if|if
condition|(
name|vesa_oemstr
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"VESA: %s\n"
argument_list|,
name|vesa_oemstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|vesa_adp_info
operator|->
name|v_version
operator|>=
literal|0x0200
condition|)
block|{
comment|/* vender name, product name, product revision */
name|printf
argument_list|(
literal|"VESA: %s %s %s\n"
argument_list|,
operator|(
name|vesa_venderstr
operator|!=
name|NULL
operator|)
condition|?
name|vesa_venderstr
else|:
literal|"unknown"
argument_list|,
operator|(
name|vesa_prodstr
operator|!=
name|NULL
operator|)
condition|?
name|vesa_prodstr
else|:
literal|"unknown"
argument_list|,
operator|(
name|vesa_revstr
operator|!=
name|NULL
operator|)
condition|?
name|vesa_revstr
else|:
literal|"?"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|VESA_DEBUG
operator|>
literal|1
comment|/* mode information */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
operator|(
name|M_VESA_MODE_MAX
operator|-
name|M_VESA_BASE
operator|+
literal|1
operator|)
operator|)
operator|&&
operator|(
name|vesa_vmodetab
index|[
name|i
index|]
operator|!=
literal|0xffff
operator|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|vesa_bios_get_mode
argument_list|(
name|vesa_vmodetab
index|[
name|i
index|]
argument_list|,
operator|&
name|vmode
argument_list|)
condition|)
continue|continue;
comment|/* print something for diagnostic purpose */
name|printf
argument_list|(
literal|"VESA: mode:0x%03x, flags:0x%04x"
argument_list|,
name|vesa_vmodetab
index|[
name|i
index|]
argument_list|,
name|vmode
operator|.
name|v_modeattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODEOPTINFO
condition|)
block|{
if|if
condition|(
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODEGRAPHICS
condition|)
block|{
name|printf
argument_list|(
literal|", G %dx%dx%d %d, "
argument_list|,
name|vmode
operator|.
name|v_width
argument_list|,
name|vmode
operator|.
name|v_height
argument_list|,
name|vmode
operator|.
name|v_bpp
argument_list|,
name|vmode
operator|.
name|v_planes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|", T %dx%d, "
argument_list|,
name|vmode
operator|.
name|v_width
argument_list|,
name|vmode
operator|.
name|v_height
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"font:%dx%d, "
argument_list|,
name|vmode
operator|.
name|v_cwidth
argument_list|,
name|vmode
operator|.
name|v_cheight
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pages:%d, mem:%d"
argument_list|,
name|vmode
operator|.
name|v_ipages
operator|+
literal|1
argument_list|,
name|vmode
operator|.
name|v_memmodel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vmode
operator|.
name|v_modeattr
operator|&
name|V_MODELFB
condition|)
block|{
name|printf
argument_list|(
literal|"\nVESA: LFB:0x%x, off:0x%x, off_size:0x%x"
argument_list|,
name|vmode
operator|.
name|v_lfb
argument_list|,
name|vmode
operator|.
name|v_offscreen
argument_list|,
name|vmode
operator|.
name|v_offscreensize
operator|*
literal|1024
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"VESA: window A:0x%x (%x), window B:0x%x (%x), "
argument_list|,
name|vmode
operator|.
name|v_waseg
argument_list|,
name|vmode
operator|.
name|v_waattr
argument_list|,
name|vmode
operator|.
name|v_wbseg
argument_list|,
name|vmode
operator|.
name|v_wbattr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"size:%dk, gran:%dk\n"
argument_list|,
name|vmode
operator|.
name|v_wsize
argument_list|,
name|vmode
operator|.
name|v_wgran
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VESA_DEBUG> 1 */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* module loading */
end_comment

begin_function
specifier|static
name|int
name|vesa_load
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|vesa_init_done
condition|)
return|return
literal|0
return|;
comment|/* locate a VGA adapter */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|vesa_adp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|vesa_configure
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|vesa_bios_info
argument_list|(
name|bootverbose
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|palette
index|[
literal|256
operator|*
literal|3
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* if the adapter is currently in a VESA mode, don't unload */
if|if
condition|(
operator|(
name|vesa_adp
operator|!=
name|NULL
operator|)
operator|&&
name|VESA_MODE
argument_list|(
name|vesa_adp
operator|->
name|va_mode
argument_list|)
condition|)
return|return
name|EBUSY
return|;
comment|/*  	 * FIXME: if there is at least one vty which is in a VESA mode, 	 * we shouldn't be unloading! XXX 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vesa_unload_ioctl
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vesa_adp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vesa_adp_info
operator|->
name|v_flags
operator|&
name|V_DAC8
condition|)
block|{
name|bits
operator|=
name|vesa_bios_get_dac
argument_list|()
expr_stmt|;
if|if
condition|(
name|bits
operator|>
literal|6
condition|)
block|{
name|vesa_bios_save_palette
argument_list|(
literal|0
argument_list|,
literal|256
argument_list|,
name|palette
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|vesa_bios_set_dac
argument_list|(
literal|6
argument_list|)
expr_stmt|;
name|vesa_bios_load_palette
argument_list|(
literal|0
argument_list|,
literal|256
argument_list|,
name|palette
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
name|vesa_adp
operator|->
name|va_flags
operator|&=
operator|~
name|V_ADP_VESA
expr_stmt|;
name|vidsw
index|[
name|vesa_adp
operator|->
name|va_index
index|]
operator|=
name|prevvidsw
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vesa_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
return|return
name|vesa_load
argument_list|()
return|;
case|case
name|MOD_UNLOAD
case|:
return|return
name|vesa_unload
argument_list|()
return|;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|vesa_mod
init|=
block|{
literal|"vesa"
block|,
name|vesa_mod_event
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|vesa
argument_list|,
name|vesa_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* (NVGA> 0&& VESA) || KLD_MODULE */
end_comment

end_unit

