begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Cronyx-Sigma adapter driver for FreeBSD.  * Supports PPP/HDLC protocol in synchronous mode,  * and asyncronous channels with full modem control.  *  * Copyright (C) 1994 Cronyx Ltd.  * Author: Serge Vakulenko,<vak@zebub.msk.su>  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations permission to use  * or modify this software as long as this message is kept with the software,  * all derivative works or modified versions.  *  * Version 1.9, Wed Oct  4 18:58:15 MSK 1995  */
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_include
include|#
directive|include
file|"cx.h"
end_include

begin_if
if|#
directive|if
name|NCX
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_if
if|#
directive|if
name|__FreeBSD__
operator|<
literal|2
end_if

begin_include
include|#
directive|include
file|<machine/pio.h>
end_include

begin_define
define|#
directive|define
name|RB_GETC
parameter_list|(
name|q
parameter_list|)
value|getc(q)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__bsdi__
end_ifdef

begin_include
include|#
directive|include
file|<sys/ttystats.h>
end_include

begin_include
include|#
directive|include
file|<machine/inline.h>
end_include

begin_define
define|#
directive|define
name|tsleep
parameter_list|(
name|tp
parameter_list|,
name|pri
parameter_list|,
name|msg
parameter_list|,
name|x
parameter_list|)
value|((tp)->t_state |= TS_WOPEN,\ 		ttysleep (tp, (caddr_t)&tp->t_rawq, pri, msg, x))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|__FreeBSD__
operator|>=
literal|2
end_if

begin_define
define|#
directive|define
name|t_out
value|t_outq
end_define

begin_define
define|#
directive|define
name|RB_LEN
parameter_list|(
name|q
parameter_list|)
value|((q).c_cc)
end_define

begin_define
define|#
directive|define
name|RB_GETC
parameter_list|(
name|q
parameter_list|)
value|getc(&q)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|TSA_CARR_ON
end_ifndef

begin_comment
comment|/* FreeBSD 2.x before not long after 2.0.5 */
end_comment

begin_define
define|#
directive|define
name|TSA_CARR_ON
parameter_list|(
name|tp
parameter_list|)
value|tp
end_define

begin_define
define|#
directive|define
name|TSA_OLOWAT
parameter_list|(
name|q
parameter_list|)
value|((caddr_t)&(q)->t_out)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/cronyx.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/cxreg.h>
end_include

begin_comment
comment|/* XXX imported from if_cx.c. */
end_comment

begin_function_decl
name|void
name|cxswitch
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|cx_soft_opt_t
name|new
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXX exported. */
end_comment

begin_function_decl
name|void
name|cxmint
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|cxrinta
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|cxtinta
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|timeout_t
name|cxtimeout
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|print
parameter_list|(
name|s
parameter_list|)
value|printf s
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|print
parameter_list|(
name|s
parameter_list|)
value|{
comment|/*void*/
value|}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DMABUFSZ
value|(6*256)
end_define

begin_comment
comment|/* buffer size */
end_comment

begin_define
define|#
directive|define
name|BYTE
value|*(unsigned char*)&
end_define

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|u
parameter_list|)
value|((u)& 077)
end_define

begin_define
define|#
directive|define
name|UNIT_CTL
value|077
end_define

begin_decl_stmt
specifier|extern
name|cx_board_t
name|cxboard
index|[
name|NCX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* adapter state structures */
end_comment

begin_decl_stmt
specifier|extern
name|cx_chan_t
modifier|*
name|cxchan
index|[
name|NCX
operator|*
name|NCHAN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* unit to channel struct pointer */
end_comment

begin_if
if|#
directive|if
name|__FreeBSD__
operator|>=
literal|2
end_if

begin_decl_stmt
specifier|static
name|struct
name|tty
name|cx_tty
index|[
name|NCX
operator|*
name|NCHAN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tty data */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|cxopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|cxclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|cxread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|cxwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|cxioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_stop_t
name|cxstop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_devtotty_t
name|cxdevtotty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|cxpoll
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|42
end_define

begin_comment
comment|/* Don't make this static.  if_cx.c  uses it. */
end_comment

begin_decl_stmt
name|struct
name|cdevsw
name|cx_cdevsw
init|=
block|{
name|cxopen
block|,
name|cxclose
block|,
name|cxread
block|,
name|cxwrite
block|,
comment|/*42*/
name|cxioctl
block|,
name|cxstop
block|,
name|nullreset
block|,
name|cxdevtotty
block|,
comment|/* cronyx */
name|cxpoll
block|,
name|nommap
block|,
name|NULL
block|,
literal|"cx"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|tty
modifier|*
name|cx_tty
index|[
name|NCX
operator|*
name|NCHAN
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tty data */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|cxoproc
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cxparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|cxopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|cx_chan_t
modifier|*
name|c
init|=
name|cxchan
index|[
name|unit
index|]
decl_stmt|;
name|unsigned
name|short
name|port
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|unit
operator|==
name|UNIT_CTL
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"cx: cxopen /dev/cronyx\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|unit
operator|>=
name|NCX
operator|*
name|NCHAN
operator|||
operator|!
name|c
operator|||
name|c
operator|->
name|type
operator|==
name|T_NONE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|port
operator|=
name|c
operator|->
name|chip
operator|->
name|port
expr_stmt|;
name|print
argument_list|(
operator|(
literal|"cx%d.%d: cxopen unit=%d\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|!=
name|M_ASYNC
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|!
name|c
operator|->
name|ttyp
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
if|#
directive|if
name|__FreeBSD__
operator|>=
literal|2
name|c
operator|->
name|ttyp
operator|=
operator|&
name|cx_tty
index|[
name|unit
index|]
expr_stmt|;
else|#
directive|else
name|c
operator|->
name|ttyp
operator|=
name|cx_tty
index|[
name|unit
index|]
operator|=
name|ttymalloc
argument_list|(
name|cx_tty
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|MALLOC
argument_list|(
name|cx_tty
index|[
name|unit
index|]
argument_list|,
expr|struct
name|tty
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tty
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cx_tty
index|[
name|unit
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cx_tty
index|[
name|unit
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|ttyp
operator|=
name|cx_tty
index|[
name|unit
index|]
expr_stmt|;
endif|#
directive|endif
name|c
operator|->
name|ttyp
operator|->
name|t_oproc
operator|=
name|cxoproc
expr_stmt|;
name|c
operator|->
name|ttyp
operator|->
name|t_param
operator|=
name|cxparam
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__bsdi__
if|if
condition|(
operator|!
name|c
operator|->
name|ttydev
condition|)
block|{
name|MALLOC
argument_list|(
name|c
operator|->
name|ttydev
argument_list|,
expr|struct
name|ttydevice_tmp
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ttydevice_tmp
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|c
operator|->
name|ttydev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|c
operator|->
name|ttydev
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|c
operator|->
name|ttydev
operator|->
name|tty_name
argument_list|,
literal|"cx"
argument_list|)
expr_stmt|;
name|c
operator|->
name|ttydev
operator|->
name|tty_unit
operator|=
name|unit
expr_stmt|;
name|c
operator|->
name|ttydev
operator|->
name|tty_base
operator|=
name|unit
expr_stmt|;
name|c
operator|->
name|ttydev
operator|->
name|tty_count
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|ttydev
operator|->
name|tty_ttys
operator|=
name|c
operator|->
name|ttyp
expr_stmt|;
name|tty_attach
argument_list|(
name|c
operator|->
name|ttydev
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tp
operator|=
name|c
operator|->
name|ttyp
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|)
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|__bsdi__
name|tp
operator|->
name|t_termios
operator|=
name|deftermios
expr_stmt|;
else|#
directive|else
name|tp
operator|->
name|t_iflag
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|CREAD
operator||
name|CS8
operator||
name|HUPCL
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|c
operator|->
name|rxbaud
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|c
operator|->
name|txbaud
expr_stmt|;
endif|#
directive|endif
block|}
name|cxparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
comment|/* 		 * Compute optimal receiver buffer length. 		 * The best choice is rxbaud/400. 		 * Make it even, to avoid byte-wide DMA transfers. 		 * -------------------------- 		 * Baud rate    Buffer length 		 * -------------------------- 		 *      300     4 		 *     1200     4 		 *     9600     24 		 *    19200     48 		 *    38400     96 		 *    57600     192 		 *   115200     288 		 * -------------------------- 		 */
name|int
name|rbsz
init|=
operator|(
name|c
operator|->
name|rxbaud
operator|+
literal|800
operator|-
literal|1
operator|)
operator|/
literal|800
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|rbsz
operator|<
literal|4
condition|)
name|rbsz
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|rbsz
operator|>
name|DMABUFSZ
condition|)
name|rbsz
operator|=
name|DMABUFSZ
expr_stmt|;
comment|/* Initialize channel, enable receiver. */
name|cx_cmd
argument_list|(
name|port
argument_list|,
name|CCR_INITCH
operator||
name|CCR_ENRX
argument_list|)
expr_stmt|;
name|cx_cmd
argument_list|(
name|port
argument_list|,
name|CCR_INITCH
operator||
name|CCR_ENRX
argument_list|)
expr_stmt|;
comment|/* Start receiver. */
name|outw
argument_list|(
name|ARBCNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|rbsz
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BRBCNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|rbsz
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|BSTS_OWN24
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|BSTS_OWN24
argument_list|)
expr_stmt|;
comment|/* Enable interrupts. */
name|outb
argument_list|(
name|IER
argument_list|(
name|port
argument_list|)
argument_list|,
name|IER_RXD
operator||
name|IER_RET
operator||
name|IER_TXD
operator||
name|IER_MDM
argument_list|)
expr_stmt|;
name|cx_chan_dtr
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cx_chan_rts
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cx_chan_cd
argument_list|(
name|c
argument_list|)
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
condition|)
block|{
comment|/* Lock the channel against cxconfig while we are 		 * waiting for carrier. */
name|c
operator|->
name|sopt
operator|.
name|lock
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|tsleep
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"cxdcd"
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
break|break;
name|c
operator|->
name|sopt
operator|.
name|lock
operator|=
literal|0
expr_stmt|;
comment|/* Unlock the channel. */
block|}
name|print
argument_list|(
operator|(
literal|"cx%d.%d: cxopen done csr=%b\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|inb
argument_list|(
name|CSR
argument_list|(
name|c
operator|->
name|chip
operator|->
name|port
argument_list|)
argument_list|)
operator|,
name|CSRA_BITS
operator|)
argument_list|)
expr_stmt|;
name|spl0
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|#
directive|if
name|__FreeBSD__
operator|>=
literal|2
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|,
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cxclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|cx_chan_t
modifier|*
name|c
init|=
name|cxchan
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|unit
operator|==
name|UNIT_CTL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tp
operator|=
name|c
operator|->
name|ttyp
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
comment|/* Disable receiver. 	 * Transmitter continues sending the queued data. */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|CAR
argument_list|(
name|c
operator|->
name|chip
operator|->
name|port
argument_list|)
argument_list|,
name|c
operator|->
name|num
operator|&
literal|3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IER
argument_list|(
name|c
operator|->
name|chip
operator|->
name|port
argument_list|)
argument_list|,
name|IER_TXD
operator||
name|IER_MDM
argument_list|)
expr_stmt|;
name|cx_cmd
argument_list|(
name|c
operator|->
name|chip
operator|->
name|port
argument_list|,
name|CCR_DISRX
argument_list|)
expr_stmt|;
comment|/* Clear DTR and RTS. */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|)
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|cx_chan_dtr
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cx_chan_rts
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Stop sending break. */
if|if
condition|(
name|c
operator|->
name|brk
operator|==
name|BRK_SEND
condition|)
block|{
name|c
operator|->
name|brk
operator|=
name|BRK_STOP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
operator|)
condition|)
name|cxoproc
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cxread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|unit
operator|==
name|UNIT_CTL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|tp
operator|=
name|cxchan
index|[
name|unit
index|]
operator|->
name|ttyp
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cxwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|unit
operator|==
name|UNIT_CTL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|tp
operator|=
name|cxchan
index|[
name|unit
index|]
operator|->
name|ttyp
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cxioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|cx_chan_t
modifier|*
name|c
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|cx_stat_t
modifier|*
name|st
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|unsigned
name|char
name|msv
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|master
decl_stmt|;
if|if
condition|(
name|unit
operator|==
name|UNIT_CTL
condition|)
block|{
comment|/* Process an ioctl request on /dev/cronyx */
name|cx_options_t
modifier|*
name|o
init|=
operator|(
name|cx_options_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|board
operator|>=
name|NCX
operator|||
name|o
operator|->
name|channel
operator|>=
name|NCHAN
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|c
operator|=
operator|&
name|cxboard
index|[
name|o
operator|->
name|board
index|]
operator|.
name|chan
index|[
name|o
operator|->
name|channel
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_NONE
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|CXIOCSETMODE
case|:
name|print
argument_list|(
operator|(
literal|"cx%d.%d: CXIOCSETMODE\n"
operator|,
name|o
operator|->
name|board
operator|,
name|o
operator|->
name|channel
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_NONE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_ASYNC
operator|&&
name|o
operator|->
name|mode
operator|!=
name|M_ASYNC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|o
operator|->
name|mode
operator|==
name|M_ASYNC
condition|)
switch|switch
condition|(
name|c
operator|->
name|type
condition|)
block|{
case|case
name|T_SYNC_RS232
case|:
case|case
name|T_SYNC_V35
case|:
case|case
name|T_SYNC_RS449
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Somebody is waiting for carrier? */
if|if
condition|(
name|c
operator|->
name|sopt
operator|.
name|lock
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* /dev/ttyXX is already opened by someone? */
if|if
condition|(
name|c
operator|->
name|mode
operator|==
name|M_ASYNC
operator|&&
name|c
operator|->
name|ttyp
operator|&&
operator|(
name|c
operator|->
name|ttyp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Network interface is up? */
if|if
condition|(
name|c
operator|->
name|mode
operator|!=
name|M_ASYNC
operator|&&
operator|(
name|c
operator|->
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Find the master interface. */
name|master
operator|=
operator|*
name|o
operator|->
name|master
condition|?
name|ifunit
argument_list|(
name|o
operator|->
name|master
argument_list|)
else|:
name|c
operator|->
name|ifp
expr_stmt|;
if|if
condition|(
operator|!
name|master
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|m
operator|=
name|cxchan
index|[
name|master
operator|->
name|if_unit
index|]
expr_stmt|;
comment|/* Leave the previous master queue. */
if|if
condition|(
name|c
operator|->
name|master
operator|!=
name|c
operator|->
name|ifp
condition|)
block|{
name|cx_chan_t
modifier|*
name|p
init|=
name|cxchan
index|[
name|c
operator|->
name|master
operator|->
name|if_unit
index|]
decl_stmt|;
for|for
control|(
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|slaveq
control|)
if|if
condition|(
name|p
operator|->
name|slaveq
operator|==
name|c
condition|)
name|p
operator|->
name|slaveq
operator|=
name|c
operator|->
name|slaveq
expr_stmt|;
block|}
comment|/* Set up new master. */
name|c
operator|->
name|master
operator|=
name|master
expr_stmt|;
name|c
operator|->
name|slaveq
operator|=
literal|0
expr_stmt|;
comment|/* Join the new master queue. */
if|if
condition|(
name|c
operator|->
name|master
operator|!=
name|c
operator|->
name|ifp
condition|)
block|{
name|c
operator|->
name|slaveq
operator|=
name|m
operator|->
name|slaveq
expr_stmt|;
name|m
operator|->
name|slaveq
operator|=
name|c
expr_stmt|;
block|}
name|c
operator|->
name|mode
operator|=
name|o
operator|->
name|mode
expr_stmt|;
name|c
operator|->
name|rxbaud
operator|=
name|o
operator|->
name|rxbaud
expr_stmt|;
name|c
operator|->
name|txbaud
operator|=
name|o
operator|->
name|txbaud
expr_stmt|;
name|c
operator|->
name|opt
operator|=
name|o
operator|->
name|opt
expr_stmt|;
name|c
operator|->
name|aopt
operator|=
name|o
operator|->
name|aopt
expr_stmt|;
name|c
operator|->
name|hopt
operator|=
name|o
operator|->
name|hopt
expr_stmt|;
name|c
operator|->
name|bopt
operator|=
name|o
operator|->
name|bopt
expr_stmt|;
name|c
operator|->
name|xopt
operator|=
name|o
operator|->
name|xopt
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|num
condition|)
block|{
case|case
literal|0
case|:
name|c
operator|->
name|board
operator|->
name|if0type
operator|=
name|o
operator|->
name|iftype
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|c
operator|->
name|board
operator|->
name|if8type
operator|=
name|o
operator|->
name|iftype
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|cxswitch
argument_list|(
name|c
argument_list|,
name|o
operator|->
name|sopt
argument_list|)
expr_stmt|;
name|cx_setup_chan
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IER
argument_list|(
name|c
operator|->
name|chip
operator|->
name|port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|CXIOCGETSTAT
case|:
name|st
operator|=
operator|(
name|cx_stat_t
operator|*
operator|)
name|data
expr_stmt|;
name|st
operator|->
name|rintr
operator|=
name|c
operator|->
name|stat
operator|->
name|rintr
expr_stmt|;
name|st
operator|->
name|tintr
operator|=
name|c
operator|->
name|stat
operator|->
name|tintr
expr_stmt|;
name|st
operator|->
name|mintr
operator|=
name|c
operator|->
name|stat
operator|->
name|mintr
expr_stmt|;
name|st
operator|->
name|ibytes
operator|=
name|c
operator|->
name|stat
operator|->
name|ibytes
expr_stmt|;
name|st
operator|->
name|ipkts
operator|=
name|c
operator|->
name|stat
operator|->
name|ipkts
expr_stmt|;
name|st
operator|->
name|ierrs
operator|=
name|c
operator|->
name|stat
operator|->
name|ierrs
expr_stmt|;
name|st
operator|->
name|obytes
operator|=
name|c
operator|->
name|stat
operator|->
name|obytes
expr_stmt|;
name|st
operator|->
name|opkts
operator|=
name|c
operator|->
name|stat
operator|->
name|opkts
expr_stmt|;
name|st
operator|->
name|oerrs
operator|=
name|c
operator|->
name|stat
operator|->
name|oerrs
expr_stmt|;
break|break;
case|case
name|CXIOCGETMODE
case|:
name|print
argument_list|(
operator|(
literal|"cx%d.%d: CXIOCGETMODE\n"
operator|,
name|o
operator|->
name|board
operator|,
name|o
operator|->
name|channel
operator|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|type
operator|=
name|c
operator|->
name|type
expr_stmt|;
name|o
operator|->
name|mode
operator|=
name|c
operator|->
name|mode
expr_stmt|;
name|o
operator|->
name|rxbaud
operator|=
name|c
operator|->
name|rxbaud
expr_stmt|;
name|o
operator|->
name|txbaud
operator|=
name|c
operator|->
name|txbaud
expr_stmt|;
name|o
operator|->
name|opt
operator|=
name|c
operator|->
name|opt
expr_stmt|;
name|o
operator|->
name|aopt
operator|=
name|c
operator|->
name|aopt
expr_stmt|;
name|o
operator|->
name|hopt
operator|=
name|c
operator|->
name|hopt
expr_stmt|;
name|o
operator|->
name|bopt
operator|=
name|c
operator|->
name|bopt
expr_stmt|;
name|o
operator|->
name|xopt
operator|=
name|c
operator|->
name|xopt
expr_stmt|;
name|o
operator|->
name|sopt
operator|=
name|c
operator|->
name|sopt
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|num
condition|)
block|{
case|case
literal|0
case|:
name|o
operator|->
name|iftype
operator|=
name|c
operator|->
name|board
operator|->
name|if0type
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|o
operator|->
name|iftype
operator|=
name|c
operator|->
name|board
operator|->
name|if8type
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|->
name|master
operator|!=
name|c
operator|->
name|ifp
condition|)
name|sprintf
argument_list|(
name|o
operator|->
name|master
argument_list|,
literal|"%s%d"
argument_list|,
name|c
operator|->
name|master
operator|->
name|if_name
argument_list|,
name|c
operator|->
name|master
operator|->
name|if_unit
argument_list|)
expr_stmt|;
else|else
operator|*
name|o
operator|->
name|master
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|c
operator|=
name|cxchan
index|[
name|unit
index|]
expr_stmt|;
name|tp
operator|=
name|c
operator|->
name|ttyp
expr_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|#
directive|if
name|__FreeBSD__
operator|>=
literal|2
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTTY
operator|)
return|;
case|case
name|TIOCSBRK
case|:
comment|/* Start sending line break */
name|c
operator|->
name|brk
operator|=
name|BRK_SEND
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
operator|)
condition|)
name|cxoproc
argument_list|(
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
comment|/* Stop sending line break */
name|c
operator|->
name|brk
operator|=
name|BRK_STOP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
operator|)
condition|)
name|cxoproc
argument_list|(
name|tp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCSDTR
case|:
comment|/* Set DTR */
name|cx_chan_dtr
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
comment|/* Clear DTR */
name|cx_chan_dtr
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
comment|/* Set DTR/RTS */
name|cx_chan_dtr
argument_list|(
name|c
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|cx_chan_rts
argument_list|(
name|c
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
comment|/* Add DTR/RTS */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|cx_chan_dtr
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|cx_chan_rts
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
comment|/* Clear DTR/RTS */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_DTR
condition|)
name|cx_chan_dtr
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|TIOCM_RTS
condition|)
name|cx_chan_rts
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
comment|/* Get modem status */
name|msv
operator|=
name|inb
argument_list|(
name|MSVR
argument_list|(
name|c
operator|->
name|chip
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TIOCM_LE
expr_stmt|;
comment|/* always enabled while open */
if|if
condition|(
name|msv
operator|&
name|MSV_DSR
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator||=
name|TIOCM_DSR
expr_stmt|;
if|if
condition|(
name|msv
operator|&
name|MSV_CTS
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator||=
name|TIOCM_CTS
expr_stmt|;
if|if
condition|(
name|msv
operator|&
name|MSV_CD
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator||=
name|TIOCM_CD
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|dtr
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator||=
name|TIOCM_DTR
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|rts
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator||=
name|TIOCM_RTS
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill transmitter buffer with data.  */
end_comment

begin_function
specifier|static
name|void
name|cxout
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|,
name|char
name|b
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|sym
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|,
name|cnt_port
decl_stmt|,
name|sts_port
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|c
operator|->
name|ttyp
decl_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
return|return;
comment|/* Choose the buffer. */
if|if
condition|(
name|b
operator|==
literal|'A'
condition|)
block|{
name|buf
operator|=
name|c
operator|->
name|atbuf
expr_stmt|;
name|cnt_port
operator|=
name|ATBCNT
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|sts_port
operator|=
name|ATBSTS
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|c
operator|->
name|btbuf
expr_stmt|;
name|cnt_port
operator|=
name|BTBCNT
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|sts_port
operator|=
name|BTBSTS
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
comment|/* Is it busy? */
if|if
condition|(
name|inb
argument_list|(
name|sts_port
argument_list|)
operator|&
name|BSTS_OWN24
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|c
operator|->
name|brk
condition|)
block|{
case|case
name|BRK_SEND
case|:
operator|*
name|buf
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* extended transmit command */
operator|*
name|buf
operator|++
operator|=
literal|0x81
expr_stmt|;
comment|/* send break */
operator|*
name|buf
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* extended transmit command */
operator|*
name|buf
operator|++
operator|=
literal|0x82
expr_stmt|;
comment|/* insert delay */
operator|*
name|buf
operator|++
operator|=
literal|250
expr_stmt|;
comment|/* 1/4 of second */
operator|*
name|buf
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* extended transmit command */
operator|*
name|buf
operator|++
operator|=
literal|0x82
expr_stmt|;
comment|/* insert delay */
operator|*
name|buf
operator|++
operator|=
literal|250
expr_stmt|;
comment|/* + 1/4 of second */
name|len
operator|=
literal|8
expr_stmt|;
name|c
operator|->
name|brk
operator|=
name|BRK_IDLE
expr_stmt|;
break|break;
case|case
name|BRK_STOP
case|:
operator|*
name|buf
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* extended transmit command */
operator|*
name|buf
operator|++
operator|=
literal|0x83
expr_stmt|;
comment|/* stop break */
name|len
operator|=
literal|2
expr_stmt|;
name|c
operator|->
name|brk
operator|=
name|BRK_IDLE
expr_stmt|;
break|break;
case|case
name|BRK_IDLE
case|:
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXOFF
condition|)
while|while
condition|(
name|RB_LEN
argument_list|(
name|tp
operator|->
name|t_out
argument_list|)
operator|&&
name|p
operator|<
name|buf
operator|+
name|DMABUFSZ
operator|-
literal|1
condition|)
block|{
name|sym
operator|=
name|RB_GETC
argument_list|(
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
comment|/* Send XON/XOFF out of band. */
if|if
condition|(
name|sym
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VSTOP
index|]
condition|)
block|{
name|outb
argument_list|(
name|STCR
argument_list|(
name|port
argument_list|)
argument_list|,
name|STC_SNDSPC
operator||
name|STC_SSPC_2
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sym
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VSTART
index|]
condition|)
block|{
name|outb
argument_list|(
name|STCR
argument_list|(
name|port
argument_list|)
argument_list|,
name|STC_SNDSPC
operator||
name|STC_SSPC_1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Duplicate NULLs in ETC mode. */
if|if
condition|(
operator|!
name|sym
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|sym
expr_stmt|;
block|}
else|else
while|while
condition|(
name|RB_LEN
argument_list|(
name|tp
operator|->
name|t_out
argument_list|)
operator|&&
name|p
operator|<
name|buf
operator|+
name|DMABUFSZ
operator|-
literal|1
condition|)
block|{
name|sym
operator|=
name|RB_GETC
argument_list|(
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
comment|/* Duplicate NULLs in ETC mode. */
if|if
condition|(
operator|!
name|sym
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|sym
expr_stmt|;
block|}
name|len
operator|=
name|p
operator|-
name|buf
expr_stmt|;
break|break;
block|}
comment|/* Start transmitter. */
if|if
condition|(
name|len
condition|)
block|{
name|outw
argument_list|(
name|cnt_port
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sts_port
argument_list|,
name|BSTS_INTR
operator||
name|BSTS_OWN24
argument_list|)
expr_stmt|;
name|c
operator|->
name|stat
operator|->
name|obytes
operator|+=
name|len
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|print
argument_list|(
operator|(
literal|"cx%d.%d: out %d bytes to %c\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|len
operator|,
name|b
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|cxoproc
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
name|cx_chan_t
modifier|*
name|c
init|=
name|cxchan
index|[
name|unit
index|]
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|int
name|s
init|=
name|spltty
argument_list|()
decl_stmt|;
comment|/* Set current channel number */
name|outb
argument_list|(
name|CAR
argument_list|(
name|port
argument_list|)
argument_list|,
name|c
operator|->
name|num
operator|&
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
operator|)
condition|)
block|{
comment|/* Start transmitter. */
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|CSR
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|CSRA_TXEN
operator|)
condition|)
name|cx_cmd
argument_list|(
name|port
argument_list|,
name|CCR_ENTX
argument_list|)
expr_stmt|;
comment|/* Determine the buffer order. */
if|if
condition|(
name|inb
argument_list|(
name|DMABSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|DMABSTS_NTBUF
condition|)
block|{
name|cxout
argument_list|(
name|c
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
name|cxout
argument_list|(
name|c
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cxout
argument_list|(
name|c
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|cxout
argument_list|(
name|c
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* FreeBSD some time after 2.0.5 */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|RB_LEN
argument_list|(
name|tp
operator|->
name|t_out
argument_list|)
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_OLOWAT
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|cxparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
decl_stmt|;
name|cx_chan_t
modifier|*
name|c
init|=
name|cxchan
index|[
name|unit
index|]
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|int
name|clock
decl_stmt|,
name|period
decl_stmt|,
name|s
decl_stmt|;
name|cx_cor1_async_t
name|cor1
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|==
literal|0
condition|)
block|{
comment|/* Clear DTR and RTS. */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|cx_chan_dtr
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cx_chan_rts
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|(
literal|"cx%d.%d: cxparam (hangup)\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|print
argument_list|(
operator|(
literal|"cx%d.%d: cxparam\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|)
argument_list|)
expr_stmt|;
comment|/* Check requested parameters. */
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|<
literal|300
operator|||
name|t
operator|->
name|c_ospeed
operator|>
literal|256
operator|*
literal|1024
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|&&
operator|(
name|t
operator|->
name|c_ispeed
operator|<
literal|300
operator|||
name|t
operator|->
name|c_ispeed
operator|>
literal|256
operator|*
literal|1024
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifdef|#
directive|ifdef
name|__bsdi__
comment|/* CLOCAL flag set -- wakeup everybody who waits for CD. */
comment|/* FreeBSD does this themselves. */
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|(
name|t
operator|->
name|c_cflag
operator|&
name|CLOCAL
operator|)
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* And copy them to tty and channel structures. */
name|c
operator|->
name|rxbaud
operator|=
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|c
operator|->
name|txbaud
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
comment|/* Set character length and parity mode. */
name|BYTE
name|cor1
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|CSIZE
condition|)
block|{
default|default:
case|case
name|CS8
case|:
name|cor1
operator|.
name|charlen
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|cor1
operator|.
name|charlen
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|cor1
operator|.
name|charlen
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|CS5
case|:
name|cor1
operator|.
name|charlen
operator|=
literal|4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|PARENB
condition|)
block|{
name|cor1
operator|.
name|parmode
operator|=
name|PARM_NORMAL
expr_stmt|;
name|cor1
operator|.
name|ignpar
operator|=
literal|0
expr_stmt|;
name|cor1
operator|.
name|parity
operator|=
operator|(
name|t
operator|->
name|c_cflag
operator|&
name|PARODD
operator|)
condition|?
name|PAR_ODD
else|:
name|PAR_EVEN
expr_stmt|;
block|}
else|else
block|{
name|cor1
operator|.
name|parmode
operator|=
name|PARM_NOPAR
expr_stmt|;
name|cor1
operator|.
name|ignpar
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Enable/disable hardware CTS. */
name|c
operator|->
name|aopt
operator|.
name|cor2
operator|.
name|ctsae
operator|=
operator|(
name|t
operator|->
name|c_cflag
operator|&
name|CRTSCTS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Handle DSR as CTS. */
name|c
operator|->
name|aopt
operator|.
name|cor2
operator|.
name|dsrae
operator|=
operator|(
name|t
operator|->
name|c_cflag
operator|&
name|CRTSCTS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Enable extended transmit command mode. 	 * Unfortunately, there is no other method for sending break. */
name|c
operator|->
name|aopt
operator|.
name|cor2
operator|.
name|etc
operator|=
literal|1
expr_stmt|;
comment|/* Enable/disable hardware XON/XOFF. */
name|c
operator|->
name|aopt
operator|.
name|cor2
operator|.
name|ixon
operator|=
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|IXON
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|c
operator|->
name|aopt
operator|.
name|cor2
operator|.
name|ixany
operator|=
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|IXANY
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* Set the number of stop bits. */
if|if
condition|(
name|t
operator|->
name|c_cflag
operator|&
name|CSTOPB
condition|)
name|c
operator|->
name|aopt
operator|.
name|cor3
operator|.
name|stopb
operator|=
name|STOPB_2
expr_stmt|;
else|else
name|c
operator|->
name|aopt
operator|.
name|cor3
operator|.
name|stopb
operator|=
name|STOPB_1
expr_stmt|;
comment|/* Disable/enable passing XON/XOFF chars to the host. */
name|c
operator|->
name|aopt
operator|.
name|cor3
operator|.
name|scde
operator|=
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|IXON
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|c
operator|->
name|aopt
operator|.
name|cor3
operator|.
name|flowct
operator|=
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|IXON
operator|)
condition|?
name|FLOWCC_NOTPASS
else|:
name|FLOWCC_PASS
expr_stmt|;
name|c
operator|->
name|aopt
operator|.
name|schr1
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTART
index|]
expr_stmt|;
comment|/* XON */
name|c
operator|->
name|aopt
operator|.
name|schr2
operator|=
name|t
operator|->
name|c_cc
index|[
name|VSTOP
index|]
expr_stmt|;
comment|/* XOFF */
comment|/* Set current channel number. */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|CAR
argument_list|(
name|port
argument_list|)
argument_list|,
name|c
operator|->
name|num
operator|&
literal|3
argument_list|)
expr_stmt|;
comment|/* Set up receiver clock values. */
name|cx_clock
argument_list|(
name|c
operator|->
name|chip
operator|->
name|oscfreq
argument_list|,
name|c
operator|->
name|rxbaud
argument_list|,
operator|&
name|clock
argument_list|,
operator|&
name|period
argument_list|)
expr_stmt|;
name|c
operator|->
name|opt
operator|.
name|rcor
operator|.
name|clk
operator|=
name|clock
expr_stmt|;
name|outb
argument_list|(
argument|RCOR(port)
argument_list|,
argument|BYTE c->opt.rcor
argument_list|)
empty_stmt|;
name|outb
argument_list|(
name|RBPR
argument_list|(
name|port
argument_list|)
argument_list|,
name|period
argument_list|)
expr_stmt|;
comment|/* Set up transmitter clock values. */
name|cx_clock
argument_list|(
name|c
operator|->
name|chip
operator|->
name|oscfreq
argument_list|,
name|c
operator|->
name|txbaud
argument_list|,
operator|&
name|clock
argument_list|,
operator|&
name|period
argument_list|)
expr_stmt|;
name|c
operator|->
name|opt
operator|.
name|tcor
operator|.
name|clk
operator|=
name|clock
expr_stmt|;
name|c
operator|->
name|opt
operator|.
name|tcor
operator|.
name|ext1x
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
argument|TCOR(port)
argument_list|,
argument|BYTE c->opt.tcor
argument_list|)
empty_stmt|;
name|outb
argument_list|(
name|TBPR
argument_list|(
name|port
argument_list|)
argument_list|,
name|period
argument_list|)
expr_stmt|;
name|outb
argument_list|(
argument|COR2(port)
argument_list|,
argument|BYTE c->aopt.cor2
argument_list|)
empty_stmt|;
name|outb
argument_list|(
argument|COR3(port)
argument_list|,
argument|BYTE c->aopt.cor3
argument_list|)
empty_stmt|;
name|outb
argument_list|(
name|SCHR1
argument_list|(
name|port
argument_list|)
argument_list|,
name|c
operator|->
name|aopt
operator|.
name|schr1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCHR2
argument_list|(
name|port
argument_list|)
argument_list|,
name|c
operator|->
name|aopt
operator|.
name|schr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|BYTE
name|c
operator|->
name|aopt
operator|.
name|cor1
operator|!=
name|BYTE
name|cor1
condition|)
block|{
name|BYTE
name|c
operator|->
name|aopt
operator|.
name|cor1
init|=
name|BYTE
name|cor1
decl_stmt|;
name|outb
argument_list|(
argument|COR1(port)
argument_list|,
argument|BYTE c->aopt.cor1
argument_list|)
empty_stmt|;
comment|/* Any change to COR1 require reinitialization. */
comment|/* Unfortunately, it may cause transmitter glitches... */
name|cx_cmd
argument_list|(
name|port
argument_list|,
name|CCR_INITCH
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|tty
modifier|*
name|cxdevtotty
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|==
name|UNIT_CTL
operator|||
name|unit
operator|>=
name|NCX
operator|*
name|NCHAN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|cxchan
index|[
name|unit
index|]
operator|->
name|ttyp
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cxpoll
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|==
name|UNIT_CTL
operator|||
name|unit
operator|>=
name|NCX
operator|*
name|NCHAN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ttypoll
argument_list|(
name|cxchan
index|[
name|unit
index|]
operator|->
name|ttyp
argument_list|,
name|events
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop output on a line  */
end_comment

begin_function
name|void
name|cxstop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|cx_chan_t
modifier|*
name|c
init|=
name|cxchan
index|[
name|UNIT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|int
name|s
init|=
name|spltty
argument_list|()
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"cx%d.%d: cxstop\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|)
argument_list|)
expr_stmt|;
comment|/* Set current channel number */
name|outb
argument_list|(
name|CAR
argument_list|(
name|port
argument_list|)
argument_list|,
name|c
operator|->
name|num
operator|&
literal|3
argument_list|)
expr_stmt|;
comment|/* Stop transmitter */
name|cx_cmd
argument_list|(
name|port
argument_list|,
name|CCR_DISTX
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle receive interrupts, including receive errors and  * receive timeout interrupt.  */
end_comment

begin_function
name|int
name|cxrinta
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|unsigned
name|short
name|len
init|=
literal|0
decl_stmt|,
name|risr
init|=
name|inw
argument_list|(
name|RISR
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|,
name|reoir
init|=
literal|0
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|c
operator|->
name|ttyp
decl_stmt|;
comment|/* Compute optimal receiver buffer length. */
name|int
name|rbsz
init|=
operator|(
name|c
operator|->
name|rxbaud
operator|+
literal|800
operator|-
literal|1
operator|)
operator|/
literal|800
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|rbsz
operator|<
literal|4
condition|)
name|rbsz
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|rbsz
operator|>
name|DMABUFSZ
condition|)
name|rbsz
operator|=
name|DMABUFSZ
expr_stmt|;
if|if
condition|(
name|risr
operator|&
name|RISA_TIMEOUT
condition|)
block|{
name|unsigned
name|long
name|rcbadr
init|=
operator|(
name|unsigned
name|short
operator|)
name|inw
argument_list|(
name|RCBADRL
argument_list|(
name|port
argument_list|)
argument_list|)
operator||
operator|(
name|long
operator|)
name|inw
argument_list|(
name|RCBADRU
argument_list|(
name|port
argument_list|)
argument_list|)
operator|<<
literal|16
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|cnt_port
init|=
literal|0
decl_stmt|,
name|sts_port
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rcbadr
operator|>=
name|c
operator|->
name|brphys
operator|&&
name|rcbadr
operator|<
name|c
operator|->
name|brphys
operator|+
name|DMABUFSZ
condition|)
block|{
name|buf
operator|=
name|c
operator|->
name|brbuf
expr_stmt|;
name|len
operator|=
name|rcbadr
operator|-
name|c
operator|->
name|brphys
expr_stmt|;
name|cnt_port
operator|=
name|BRBCNT
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|sts_port
operator|=
name|BRBSTS
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rcbadr
operator|>=
name|c
operator|->
name|arphys
operator|&&
name|rcbadr
operator|<
name|c
operator|->
name|arphys
operator|+
name|DMABUFSZ
condition|)
block|{
name|buf
operator|=
name|c
operator|->
name|arbuf
expr_stmt|;
name|len
operator|=
name|rcbadr
operator|-
name|c
operator|->
name|arphys
expr_stmt|;
name|cnt_port
operator|=
name|ARBCNT
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|sts_port
operator|=
name|ARBSTS
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"cx%d.%d: timeout: invalid buffer address\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"cx%d.%d: async receive timeout (%d bytes), risr=%b, arbsts=%b, brbsts=%b\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|len
operator|,
name|risr
operator|,
name|RISA_BITS
operator|,
name|inb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|,
name|inb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|stat
operator|->
name|ibytes
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|tp
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
function_decl|(
modifier|*
name|rint
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|tty
modifier|*
parameter_list|)
init|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
function_decl|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
call|(
modifier|*
name|rint
call|)
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* Restart receiver. */
name|outw
argument_list|(
name|cnt_port
argument_list|,
name|rbsz
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sts_port
argument_list|,
name|BSTS_OWN24
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|REOI_TERMBUFF
operator|)
return|;
block|}
name|print
argument_list|(
operator|(
literal|"cx%d.%d: async receive interrupt, risr=%b, arbsts=%b, brbsts=%b\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|risr
operator|,
name|RISA_BITS
operator|,
name|inb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|,
name|inb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|risr
operator|&
name|RIS_BUSERR
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d.%d: receive bus error\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|stat
operator|->
name|ierrs
expr_stmt|;
block|}
if|if
condition|(
name|risr
operator|&
operator|(
name|RIS_OVERRUN
operator||
name|RISA_PARERR
operator||
name|RISA_FRERR
operator||
name|RISA_BREAK
operator|)
condition|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|risr
operator|&
name|RISA_PARERR
condition|)
name|err
operator||=
name|TTY_PE
expr_stmt|;
if|if
condition|(
name|risr
operator|&
name|RISA_FRERR
condition|)
name|err
operator||=
name|TTY_FE
expr_stmt|;
ifdef|#
directive|ifdef
name|TTY_OE
if|if
condition|(
name|risr
operator|&
name|RIS_OVERRUN
condition|)
name|err
operator||=
name|TTY_OE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TTY_BI
if|if
condition|(
name|risr
operator|&
name|RISA_BREAK
condition|)
name|err
operator||=
name|TTY_BI
expr_stmt|;
endif|#
directive|endif
name|print
argument_list|(
operator|(
literal|"cx%d.%d: receive error %x\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|err
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|err
operator|,
name|tp
operator|)
expr_stmt|;
operator|++
name|c
operator|->
name|stat
operator|->
name|ierrs
expr_stmt|;
block|}
comment|/* Discard exception characters. */
if|if
condition|(
operator|(
name|risr
operator|&
name|RISA_SCMASK
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXON
operator|)
condition|)
name|reoir
operator||=
name|REOI_DISCEXC
expr_stmt|;
comment|/* Handle received data. */
if|if
condition|(
operator|(
name|risr
operator|&
name|RIS_EOBUF
operator|)
operator|&&
name|tp
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|int
function_decl|(
modifier|*
name|rint
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|tty
modifier|*
parameter_list|)
init|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
function_decl|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|len
operator|=
operator|(
name|risr
operator|&
name|RIS_BB
operator|)
condition|?
name|inw
argument_list|(
name|BRBCNT
argument_list|(
name|port
argument_list|)
argument_list|)
else|:
name|inw
argument_list|(
name|ARBCNT
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|print
argument_list|(
operator|(
literal|"cx%d.%d: async: %d bytes received\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|stat
operator|->
name|ibytes
operator|+=
name|len
expr_stmt|;
name|buf
operator|=
operator|(
name|risr
operator|&
name|RIS_BB
operator|)
condition|?
name|c
operator|->
name|brbuf
else|:
name|c
operator|->
name|arbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
call|(
modifier|*
name|rint
call|)
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
comment|/* Restart receiver. */
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
condition|)
block|{
name|outw
argument_list|(
name|ARBCNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|rbsz
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ARBSTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|BSTS_OWN24
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|&
name|BSTS_OWN24
operator|)
condition|)
block|{
name|outw
argument_list|(
name|BRBCNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|rbsz
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|BRBSTS
argument_list|(
name|port
argument_list|)
argument_list|,
name|BSTS_OWN24
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|reoir
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle transmit interrupt.  */
end_comment

begin_function
name|void
name|cxtinta
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|c
operator|->
name|ttyp
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|unsigned
name|char
name|tisr
init|=
name|inb
argument_list|(
name|TISR
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
name|print
argument_list|(
operator|(
literal|"cx%d.%d: async transmit interrupt, tisr=%b, atbsts=%b, btbsts=%b\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|tisr
operator|,
name|TIS_BITS
operator|,
name|inb
argument_list|(
name|ATBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|,
name|inb
argument_list|(
name|BTBSTS
argument_list|(
name|port
argument_list|)
argument_list|)
operator|,
name|BSTS_BITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tisr
operator|&
name|TIS_BUSERR
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d.%d: transmit bus error\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|stat
operator|->
name|oerrs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tisr
operator|&
name|TIS_UNDERRUN
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d.%d: transmit underrun error\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|)
expr_stmt|;
operator|++
name|c
operator|->
name|stat
operator|->
name|oerrs
expr_stmt|;
block|}
if|if
condition|(
name|tp
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_BUSY
operator||
name|TS_FLUSH
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_line
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
else|else
name|cxoproc
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle modem interrupt.  */
end_comment

begin_function
name|void
name|cxmint
parameter_list|(
name|cx_chan_t
modifier|*
name|c
parameter_list|)
block|{
name|unsigned
name|short
name|port
init|=
name|c
operator|->
name|chip
operator|->
name|port
decl_stmt|;
name|unsigned
name|char
name|misr
init|=
name|inb
argument_list|(
name|MISR
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|msvr
init|=
name|inb
argument_list|(
name|MSVR
argument_list|(
name|port
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
name|c
operator|->
name|ttyp
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|mode
operator|!=
name|M_ASYNC
condition|)
block|{
name|printf
argument_list|(
literal|"cx%d.%d: unexpected modem interrupt, misr=%b, msvr=%b\n"
argument_list|,
name|c
operator|->
name|board
operator|->
name|num
argument_list|,
name|c
operator|->
name|num
argument_list|,
name|misr
argument_list|,
name|MIS_BITS
argument_list|,
name|msvr
argument_list|,
name|MSV_BITS
argument_list|)
expr_stmt|;
return|return;
block|}
name|print
argument_list|(
operator|(
literal|"cx%d.%d: modem interrupt, misr=%b, msvr=%b\n"
operator|,
name|c
operator|->
name|board
operator|->
name|num
operator|,
name|c
operator|->
name|num
operator|,
name|misr
operator|,
name|MIS_BITS
operator|,
name|msvr
operator|,
name|MSV_BITS
operator|)
argument_list|)
expr_stmt|;
comment|/* Ignore DSR events. */
comment|/* Ignore RTC/CTS events, handled by hardware. */
comment|/* Handle carrier detect/loss. */
if|if
condition|(
name|tp
operator|&&
operator|(
name|misr
operator|&
name|MIS_CCD
operator|)
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
operator|(
name|msvr
operator|&
name|MSV_CD
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Recover after lost transmit interrupts.  */
end_comment

begin_function
name|void
name|cxtimeout
parameter_list|(
name|void
modifier|*
name|a
parameter_list|)
block|{
name|cx_board_t
modifier|*
name|b
decl_stmt|;
name|cx_chan_t
modifier|*
name|c
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|s
decl_stmt|;
for|for
control|(
name|b
operator|=
name|cxboard
init|;
name|b
operator|<
name|cxboard
operator|+
name|NCX
condition|;
operator|++
name|b
control|)
for|for
control|(
name|c
operator|=
name|b
operator|->
name|chan
init|;
name|c
operator|<
name|b
operator|->
name|chan
operator|+
name|NCHAN
condition|;
operator|++
name|c
control|)
block|{
name|tp
operator|=
name|c
operator|->
name|ttyp
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|T_NONE
operator|||
name|c
operator|->
name|mode
operator|!=
name|M_ASYNC
operator|||
operator|!
name|tp
condition|)
continue|continue;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_line
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
else|else
name|cxoproc
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
name|cxtimeout
argument_list|,
literal|0
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|__FreeBSD__
operator|>
literal|1
operator|)
end_if

begin_expr_stmt
specifier|static
name|cx_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|cx_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|cx_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|cx_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cx_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|cxdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|cx_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCX */
end_comment

end_unit

