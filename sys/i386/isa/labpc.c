begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995 HD Associates, Inc.  * All rights reserved.  *  * HD Associates, Inc.  * PO Box 276  * Pepperell, MA 01463-0276  * dufault@hda.com  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by HD Associates, Inc.  * 4. The name of HD Associates, Inc.  *    may not be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY HD ASSOCIATES ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Written by:  * Peter Dufault  * dufault@hda.com  */
end_comment

begin_include
include|#
directive|include
file|"labpc.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_define
define|#
directive|define
name|b_actf
value|b_act.tqe_next
end_define

begin_include
include|#
directive|include
file|<sys/dataacq.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_comment
comment|/* Miniumum timeout:  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LABPC_MIN_TMO
end_ifndef

begin_define
define|#
directive|define
name|LABPC_MIN_TMO
value|(hz)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LABPC_DEFAULT_HERZ
end_ifndef

begin_define
define|#
directive|define
name|LABPC_DEFAULT_HERZ
value|500
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Minor number:  * UUSIDCCC  * UU: Board unit.  * S: SCAN bit for scan enable.  * I: INTERVAL for interval support  * D: 1: Digital I/O, 0: Analog I/O  * CCC: Channel.  *  Analog (D==0):  *  input: channel must be 0 to 7.  *  output: channel must be 0 to 2  *          0: D-A 0  *          1: D-A 1  *          2: Alternate channel 0 then 1  *  *  Digital (D==1):  *  input: Channel must be 0 to 2.  *  output: Channel must be 0 to 2.  */
end_comment

begin_comment
comment|/* Up to four boards:  */
end_comment

begin_define
define|#
directive|define
name|MAX_UNITS
value|4
end_define

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|dev
parameter_list|)
value|(((minor(dev)& 0xB0)>> 6)& 0x3)
end_define

begin_define
define|#
directive|define
name|SCAN
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev)& 0x20)>> 5)
end_define

begin_define
define|#
directive|define
name|INTERVAL
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev)& 0x10)>> 4)
end_define

begin_define
define|#
directive|define
name|DIGITAL
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev)& 0x08)>> 3)
end_define

begin_comment
comment|/* Eight channels:  */
end_comment

begin_define
define|#
directive|define
name|CHAN
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x7)
end_define

begin_comment
comment|/* History: Derived from "dt2811.c" March 1995  */
end_comment

begin_struct
struct|struct
name|ctlr
block|{
name|int
name|err
decl_stmt|;
define|#
directive|define
name|DROPPED_INPUT
value|0x100
name|int
name|base
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
define|#
directive|define
name|BUSY
value|0x00000001
name|u_char
name|cr_image
index|[
literal|4
index|]
decl_stmt|;
name|u_short
name|sample_us
decl_stmt|;
name|struct
name|buf
name|start_queue
decl_stmt|;
comment|/* Start queue */
name|struct
name|buf
modifier|*
name|last
decl_stmt|;
comment|/* End of start queue */
name|u_char
modifier|*
name|data
decl_stmt|;
name|u_char
modifier|*
name|data_end
decl_stmt|;
name|long
name|tmo
decl_stmt|;
comment|/* Timeout in Herz */
name|long
name|min_tmo
decl_stmt|;
comment|/* Timeout in Herz */
name|int
name|cleared_intr
decl_stmt|;
name|int
name|gains
index|[
literal|8
index|]
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
comment|/* Copy of device */
name|void
function_decl|(
modifier|*
name|starter
function_decl|)
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|,
name|long
name|count
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|stop
function_decl|)
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|intr
function_decl|)
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
function_decl|;
comment|/* Digital I/O support.  Copy of Data Control Register for 8255: 	 */
name|u_char
name|dcr_val
decl_stmt|,
name|dcr_is
decl_stmt|;
comment|/* 	 * Handle for canceling our timeout. 	 */
name|struct
name|callout_handle
name|ch
decl_stmt|;
comment|/* Device configuration structure: 	 */
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|devfs_token
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|LOUTB
end_ifdef

begin_comment
comment|/* loutb is a slow outb for debugging.  The overrun test may fail  * with this for some slower processors.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|loutb
parameter_list|(
name|int
name|port
parameter_list|,
name|u_char
name|val
parameter_list|)
block|{
name|outb
argument_list|(
name|port
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|loutb
parameter_list|(
name|port
parameter_list|,
name|val
parameter_list|)
value|outb(port, val)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|ctlr
modifier|*
modifier|*
name|labpcs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX: Should be dynamic */
end_comment

begin_comment
comment|/* CR_EXPR: A macro that sets the shadow register in addition to  * sending out the data.  */
end_comment

begin_define
define|#
directive|define
name|CR_EXPR
parameter_list|(
name|LABPC
parameter_list|,
name|CR
parameter_list|,
name|EXPR
parameter_list|)
value|do { \ 	(LABPC)->cr_image[CR - 1] EXPR ; \ 	loutb(((LABPC)->base + ( (CR == 4) ? (0x0F) : (CR - 1))), ((LABPC)->cr_image[(CR - 1)])); \ } while (0)
end_define

begin_define
define|#
directive|define
name|CR_CLR
parameter_list|(
name|LABPC
parameter_list|,
name|CR
parameter_list|)
value|CR_EXPR(LABPC, CR,&=0)
end_define

begin_define
define|#
directive|define
name|CR_REFRESH
parameter_list|(
name|LABPC
parameter_list|,
name|CR
parameter_list|)
value|CR_EXPR(LABPC, CR,&=0xff)
end_define

begin_define
define|#
directive|define
name|CR_SET
parameter_list|(
name|LABPC
parameter_list|,
name|CR
parameter_list|,
name|EXPR
parameter_list|)
value|CR_EXPR(LABPC, CR, = EXPR)
end_define

begin_comment
comment|/* Configuration and Status Register Group.  */
end_comment

begin_define
define|#
directive|define
name|CR1
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x00)
end_define

begin_comment
comment|/* Page 4-5 */
end_comment

begin_define
define|#
directive|define
name|SCANEN
value|0x80
end_define

begin_define
define|#
directive|define
name|GAINMASK
value|0x70
end_define

begin_define
define|#
directive|define
name|GAIN
parameter_list|(
name|LABPC
parameter_list|,
name|SEL
parameter_list|)
value|do { \ 		(LABPC)->cr_image[1 - 1]&= ~GAINMASK; \ 		(LABPC)->cr_image[1 - 1] |= (SEL<< 4); \ 		loutb((LABPC)->base + (1 - 1), (LABPC)->cr_image[(1 - 1)]); \ 		} while (0)
end_define

begin_define
define|#
directive|define
name|TWOSCMP
value|0x08
end_define

begin_define
define|#
directive|define
name|MAMASK
value|0x07
end_define

begin_define
define|#
directive|define
name|MA
parameter_list|(
name|LABPC
parameter_list|,
name|SEL
parameter_list|)
value|do { \ 		(LABPC)->cr_image[1 - 1]&= ~MAMASK; \ 		(LABPC)->cr_image[1 - 1] |= SEL; \ 		loutb((LABPC)->base + (1 - 1), (LABPC)->cr_image[(1 - 1)]); \ 		} while (0)
end_define

begin_define
define|#
directive|define
name|STATUS
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x00)
end_define

begin_comment
comment|/* Page 4-7 */
end_comment

begin_define
define|#
directive|define
name|LABPCPLUS
value|0x80
end_define

begin_define
define|#
directive|define
name|EXTGATA0
value|0x40
end_define

begin_define
define|#
directive|define
name|GATA0
value|0x20
end_define

begin_define
define|#
directive|define
name|DMATC
value|0x10
end_define

begin_define
define|#
directive|define
name|CNTINT
value|0x08
end_define

begin_define
define|#
directive|define
name|OVERFLOW
value|0x04
end_define

begin_define
define|#
directive|define
name|OVERRUN
value|0x02
end_define

begin_define
define|#
directive|define
name|DAVAIL
value|0x01
end_define

begin_define
define|#
directive|define
name|CR2
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x01)
end_define

begin_comment
comment|/* Page 4-9 */
end_comment

begin_define
define|#
directive|define
name|LDAC1
value|0x80
end_define

begin_define
define|#
directive|define
name|LDAC0
value|0x40
end_define

begin_define
define|#
directive|define
name|_2SDAC1
value|0x20
end_define

begin_define
define|#
directive|define
name|_2SDAC0
value|0x10
end_define

begin_define
define|#
directive|define
name|TBSEL
value|0x08
end_define

begin_define
define|#
directive|define
name|SWTRIG
value|0x04
end_define

begin_define
define|#
directive|define
name|HWTRIG
value|0x02
end_define

begin_define
define|#
directive|define
name|PRETRIG
value|0x01
end_define

begin_define
define|#
directive|define
name|SWTRIGGERRED
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC->cr_image[1])& SWTRIG)
end_define

begin_define
define|#
directive|define
name|CR3
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x02)
end_define

begin_comment
comment|/* Page 4-11 */
end_comment

begin_define
define|#
directive|define
name|FIFOINTEN
value|0x20
end_define

begin_define
define|#
directive|define
name|ERRINTEN
value|0x10
end_define

begin_define
define|#
directive|define
name|CNTINTEN
value|0x08
end_define

begin_define
define|#
directive|define
name|TCINTEN
value|0x04
end_define

begin_define
define|#
directive|define
name|DIOINTEN
value|0x02
end_define

begin_define
define|#
directive|define
name|DMAEN
value|0x01
end_define

begin_define
define|#
directive|define
name|ALLINTEN
value|0x3E
end_define

begin_define
define|#
directive|define
name|FIFOINTENABLED
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC->cr_image[2])& FIFOINTEN)
end_define

begin_define
define|#
directive|define
name|CR4
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x0F)
end_define

begin_comment
comment|/* Page 4-13 */
end_comment

begin_define
define|#
directive|define
name|ECLKRCV
value|0x10
end_define

begin_define
define|#
directive|define
name|SE_D
value|0x08
end_define

begin_define
define|#
directive|define
name|ECKDRV
value|0x04
end_define

begin_define
define|#
directive|define
name|EOIRCV
value|0x02
end_define

begin_define
define|#
directive|define
name|INTSCAN
value|0x01
end_define

begin_comment
comment|/* Analog Input Register Group  */
end_comment

begin_define
define|#
directive|define
name|ADFIFO
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x0A)
end_define

begin_comment
comment|/* Page 4-16 */
end_comment

begin_define
define|#
directive|define
name|ADCLEAR
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x08)
end_define

begin_comment
comment|/* Page 4-18 */
end_comment

begin_define
define|#
directive|define
name|ADSTART
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x03)
end_define

begin_comment
comment|/* Page 4-19 */
end_comment

begin_define
define|#
directive|define
name|DMATCICLR
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x0A)
end_define

begin_comment
comment|/* Page 4-20 */
end_comment

begin_comment
comment|/* Analog Output Register Group  */
end_comment

begin_define
define|#
directive|define
name|DAC0L
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x04)
end_define

begin_comment
comment|/* Page 4-22 */
end_comment

begin_define
define|#
directive|define
name|DAC0H
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x05)
end_define

begin_comment
comment|/* Page 4-22 */
end_comment

begin_define
define|#
directive|define
name|DAC1L
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x06)
end_define

begin_comment
comment|/* Page 4-22 */
end_comment

begin_define
define|#
directive|define
name|DAC1H
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x07)
end_define

begin_comment
comment|/* Page 4-22 */
end_comment

begin_comment
comment|/* 8253 registers:  */
end_comment

begin_define
define|#
directive|define
name|A0DATA
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x14)
end_define

begin_define
define|#
directive|define
name|A1DATA
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x15)
end_define

begin_define
define|#
directive|define
name|A2DATA
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x16)
end_define

begin_define
define|#
directive|define
name|AMODE
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x17)
end_define

begin_define
define|#
directive|define
name|TICR
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x0c)
end_define

begin_define
define|#
directive|define
name|B0DATA
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x18)
end_define

begin_define
define|#
directive|define
name|B1DATA
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x19)
end_define

begin_define
define|#
directive|define
name|B2DATA
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x1A)
end_define

begin_define
define|#
directive|define
name|BMODE
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x1B)
end_define

begin_comment
comment|/* 8255 registers:  */
end_comment

begin_define
define|#
directive|define
name|PORTX
parameter_list|(
name|LABPC
parameter_list|,
name|X
parameter_list|)
value|((LABPC)->base + 0x10 + X)
end_define

begin_define
define|#
directive|define
name|PORTA
parameter_list|(
name|LABPC
parameter_list|)
value|PORTX(LABPC, 0)
end_define

begin_define
define|#
directive|define
name|PORTB
parameter_list|(
name|LABPC
parameter_list|)
value|PORTX(LABPC, 1)
end_define

begin_define
define|#
directive|define
name|PORTC
parameter_list|(
name|LABPC
parameter_list|)
value|PORTX(LABPC, 2)
end_define

begin_define
define|#
directive|define
name|DCR
parameter_list|(
name|LABPC
parameter_list|)
value|((LABPC)->base + 0x13)
end_define

begin_function_decl
specifier|static
name|int
name|labpcattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|labpcprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|labpcdriver
init|=
block|{
name|labpcprobe
block|,
name|labpcattach
block|,
literal|"labpc"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|labpcopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|labpcclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|labpcioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|labpcstrategy
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|66
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|labpc_cdevsw
init|=
block|{
name|labpcopen
block|,
name|labpcclose
block|,
name|rawread
block|,
name|rawwrite
block|,
comment|/*66*/
name|labpcioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
comment|/* labpc */
name|seltrue
block|,
name|nommap
block|,
name|labpcstrategy
block|,
literal|"labpc"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|start
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|bp_done
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|err
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|bp
operator|->
name|b_resid
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|tmo_stop
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|done_and_start_next
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|ctlr
operator|->
name|data_end
operator|-
name|ctlr
operator|->
name|data
expr_stmt|;
name|ctlr
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|ctlr
operator|->
name|start_queue
operator|.
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
name|bp_done
argument_list|(
name|bp
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|tmo_stop
argument_list|,
name|ctlr
argument_list|,
name|ctlr
operator|->
name|ch
argument_list|)
expr_stmt|;
name|start
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ad_clear
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|loutb
argument_list|(
name|ADCLEAR
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10000
operator|&&
operator|(
name|inb
argument_list|(
name|STATUS
argument_list|(
name|ctlr
argument_list|)
argument_list|)
operator|&
name|GATA0
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|ADFIFO
argument_list|(
name|ctlr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|ADFIFO
argument_list|(
name|ctlr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* reset: Reset the board following the sequence on page 5-1  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|reset
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|CR_CLR
argument_list|(
name|ctlr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Turn off interrupts first */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|CR_CLR
argument_list|(
name|ctlr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CR_CLR
argument_list|(
name|ctlr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CR_CLR
argument_list|(
name|ctlr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|AMODE
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0x34
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|A0DATA
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0x0A
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|A0DATA
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|DMATCICLR
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|TICR
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|ad_clear
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|DAC0L
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|DAC0H
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|DAC1L
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|DAC1H
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ad_clear
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* overrun: slam the start convert register and OVERRUN should get set:  */
end_comment

begin_function
specifier|static
name|u_char
name|overrun
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|status
init|=
name|inb
argument_list|(
name|STATUS
argument_list|(
name|ctlr
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|status
operator|&
name|OVERRUN
operator|)
operator|==
literal|0
operator|)
operator|&&
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
name|loutb
argument_list|(
name|ADSTART
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|inb
argument_list|(
name|STATUS
argument_list|(
name|ctlr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|labpcinit
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|NLABPC
operator|>
name|MAX_UNITS
condition|)
return|return
literal|0
return|;
name|labpcs
operator|=
name|malloc
argument_list|(
name|NLABPC
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ctlr
operator|*
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|labpcs
condition|)
block|{
name|bzero
argument_list|(
name|labpcs
argument_list|,
name|NLABPC
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|cltr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|labpcprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
specifier|static
name|unit
expr_stmt|;
name|struct
name|ctlr
name|scratch
decl_stmt|,
modifier|*
name|ctlr
decl_stmt|;
name|u_char
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|labpcs
condition|)
block|{
if|if
condition|(
name|labpcinit
argument_list|()
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"labpcprobe: init failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|unit
operator|>
name|NLABPC
condition|)
block|{
name|printf
argument_list|(
literal|"Too many LAB-PCs.  Reconfigure O/S.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ctlr
operator|=
operator|&
name|scratch
expr_stmt|;
comment|/* Need somebody with the right base for the macros */
name|ctlr
operator|->
name|base
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
comment|/* XXX: There really isn't a perfect way to probe this board. 	 *      Here is my best attempt: 	 */
name|reset
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
comment|/* After reset none of these bits should be set: 	 */
name|status
operator|=
name|inb
argument_list|(
name|STATUS
argument_list|(
name|ctlr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
operator|(
name|GATA0
operator||
name|OVERFLOW
operator||
name|DAVAIL
operator||
name|OVERRUN
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Now try to overrun the board FIFO and get the overrun bit set: 	 */
name|status
operator|=
name|overrun
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|OVERRUN
operator|)
operator|==
literal|0
condition|)
comment|/* No overrun bit set? */
return|return
literal|0
return|;
comment|/* Assume we have a board. 	 */
name|reset
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|labpcs
index|[
name|unit
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ctlr
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
condition|)
block|{
name|struct
name|ctlr
modifier|*
name|l
init|=
name|labpcs
index|[
name|unit
index|]
decl_stmt|;
name|bzero
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ctlr
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|->
name|base
operator|=
name|ctlr
operator|->
name|base
expr_stmt|;
name|dev
operator|->
name|id_unit
operator|=
name|l
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|unit
operator|++
expr_stmt|;
return|return
literal|0x20
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"labpc%d: Can't malloc.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* attach: Set things in a normal state.  */
end_comment

begin_function
specifier|static
name|int
name|labpcattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|ctlr
modifier|*
name|ctlr
init|=
name|labpcs
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|ctlr
operator|->
name|ch
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|sample_us
operator|=
operator|(
literal|1000000.0
operator|/
operator|(
name|double
operator|)
name|LABPC_DEFAULT_HERZ
operator|)
operator|+
literal|.50
expr_stmt|;
name|reset
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|min_tmo
operator|=
name|LABPC_MIN_TMO
expr_stmt|;
name|ctlr
operator|->
name|dcr_val
operator|=
literal|0x80
expr_stmt|;
name|ctlr
operator|->
name|dcr_is
operator|=
literal|0x80
expr_stmt|;
name|loutb
argument_list|(
name|DCR
argument_list|(
name|ctlr
argument_list|)
argument_list|,
name|ctlr
operator|->
name|dcr_val
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|ctlr
operator|->
name|devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|labpc_cdevsw
argument_list|,
literal|0
argument_list|,
name|DV_CHR
argument_list|,
comment|/* what  UID GID PERM */
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"labpc%d"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Null handlers:  */
end_comment

begin_function
specifier|static
name|void
name|null_intr
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|null_start
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|,
name|long
name|count
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|null_stop
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
specifier|inline
name|void
name|trigger
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{
name|CR_EXPR
argument_list|(
name|ctlr
argument_list|,
literal|2
argument_list|,
operator||=
name|SWTRIG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad_start
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|,
name|long
name|count
parameter_list|)
block|{
if|if
condition|(
operator|!
name|SWTRIGGERRED
argument_list|(
name|ctlr
argument_list|)
condition|)
block|{
name|int
name|chan
init|=
name|CHAN
argument_list|(
name|ctlr
operator|->
name|dev
argument_list|)
decl_stmt|;
name|CR_EXPR
argument_list|(
name|ctlr
argument_list|,
literal|1
argument_list|,
operator|&=
operator|~
name|SCANEN
argument_list|)
expr_stmt|;
name|CR_EXPR
argument_list|(
name|ctlr
argument_list|,
literal|2
argument_list|,
operator|&=
operator|~
name|TBSEL
argument_list|)
expr_stmt|;
name|MA
argument_list|(
name|ctlr
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|GAIN
argument_list|(
name|ctlr
argument_list|,
name|ctlr
operator|->
name|gains
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCAN
argument_list|(
name|ctlr
operator|->
name|dev
argument_list|)
condition|)
name|CR_EXPR
argument_list|(
name|ctlr
argument_list|,
literal|1
argument_list|,
operator||=
name|SCANEN
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|AMODE
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0x34
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|A0DATA
argument_list|(
name|ctlr
argument_list|)
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|ctlr
operator|->
name|sample_us
operator|&
literal|0xff
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|A0DATA
argument_list|(
name|ctlr
argument_list|)
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|ctlr
operator|->
name|sample_us
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|AMODE
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
name|ad_clear
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
name|trigger
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
name|ctlr
operator|->
name|tmo
operator|=
operator|(
operator|(
name|count
operator|+
literal|16
operator|)
operator|*
operator|(
name|long
operator|)
name|ctlr
operator|->
name|sample_us
operator|*
name|hz
operator|)
operator|/
literal|1000000
operator|+
name|ctlr
operator|->
name|min_tmo
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad_interval_start
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|,
name|long
name|count
parameter_list|)
block|{
name|int
name|chan
init|=
name|CHAN
argument_list|(
name|ctlr
operator|->
name|dev
argument_list|)
decl_stmt|;
name|int
name|n_frames
init|=
name|count
operator|/
operator|(
name|chan
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|SWTRIGGERRED
argument_list|(
name|ctlr
argument_list|)
condition|)
block|{
name|CR_EXPR
argument_list|(
name|ctlr
argument_list|,
literal|1
argument_list|,
operator|&=
operator|~
name|SCANEN
argument_list|)
expr_stmt|;
name|CR_EXPR
argument_list|(
name|ctlr
argument_list|,
literal|2
argument_list|,
operator|&=
operator|~
name|TBSEL
argument_list|)
expr_stmt|;
name|MA
argument_list|(
name|ctlr
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|GAIN
argument_list|(
name|ctlr
argument_list|,
name|ctlr
operator|->
name|gains
index|[
name|chan
index|]
argument_list|)
expr_stmt|;
comment|/* XXX: Is it really possible that you clear INTSCAN as 		 * the documentation says?  That seems pretty unlikely. 		 */
name|CR_EXPR
argument_list|(
name|ctlr
argument_list|,
literal|4
argument_list|,
operator|&=
operator|~
name|INTSCAN
argument_list|)
expr_stmt|;
comment|/* XXX: Is this possible? */
comment|/* Program the sample interval counter to run as fast as 		 * possible. 		 */
name|loutb
argument_list|(
name|AMODE
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0x34
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|A0DATA
argument_list|(
name|ctlr
argument_list|)
argument_list|,
call|(
name|u_char
call|)
argument_list|(
literal|0x02
argument_list|)
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|A0DATA
argument_list|(
name|ctlr
argument_list|)
argument_list|,
call|(
name|u_char
call|)
argument_list|(
literal|0x00
argument_list|)
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|AMODE
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* Program the interval scanning counter to run at the sample 		 * frequency. 		 */
name|loutb
argument_list|(
name|BMODE
argument_list|(
name|ctlr
argument_list|)
argument_list|,
literal|0x74
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|B1DATA
argument_list|(
name|ctlr
argument_list|)
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|ctlr
operator|->
name|sample_us
operator|&
literal|0xff
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|B1DATA
argument_list|(
name|ctlr
argument_list|)
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|ctlr
operator|->
name|sample_us
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|CR_EXPR
argument_list|(
name|ctlr
argument_list|,
literal|1
argument_list|,
operator||=
name|SCANEN
argument_list|)
expr_stmt|;
name|ad_clear
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
name|trigger
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
comment|/* Each frame time takes two microseconds per channel times 	 * the number of channels being sampled plus the sample period. 	 */
name|ctlr
operator|->
name|tmo
operator|=
operator|(
operator|(
name|n_frames
operator|+
literal|16
operator|)
operator|*
operator|(
operator|(
name|long
operator|)
name|ctlr
operator|->
name|sample_us
operator|+
operator|(
name|chan
operator|+
literal|1
operator|)
operator|*
literal|2
operator|)
operator|*
name|hz
operator|)
operator|/
literal|1000000
operator|+
name|ctlr
operator|->
name|min_tmo
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|all_stop
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{
name|reset
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tmo_stop
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ctlr
modifier|*
name|ctlr
init|=
operator|(
expr|struct
name|ctlr
operator|*
operator|)
name|p
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
init|=
name|spltty
argument_list|()
decl_stmt|;
if|if
condition|(
name|ctlr
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"labpc?: Null ctlr struct?\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"labpc%d: timeout"
argument_list|,
name|ctlr
operator|->
name|unit
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ctlr
operator|->
name|stop
call|)
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
name|bp
operator|=
name|ctlr
operator|->
name|start_queue
operator|.
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|", Null bp.\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|done_and_start_next
argument_list|(
name|ctlr
argument_list|,
name|bp
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad_intr
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{
name|u_char
name|status
decl_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|cr_image
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ctlr
operator|->
name|cleared_intr
condition|)
block|{
name|ctlr
operator|->
name|cleared_intr
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"ad_intr (should not happen) interrupt with interrupts off\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"status %x, cr3 %x\n"
argument_list|,
name|inb
argument_list|(
name|STATUS
argument_list|(
name|ctlr
argument_list|)
argument_list|)
argument_list|,
name|ctlr
operator|->
name|cr_image
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|status
operator|=
operator|(
name|inb
argument_list|(
name|STATUS
argument_list|(
name|ctlr
argument_list|)
argument_list|)
operator|&
operator|(
name|DAVAIL
operator||
name|OVERRUN
operator||
name|OVERFLOW
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|OVERRUN
operator||
name|OVERFLOW
operator|)
operator|)
condition|)
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|ctlr
operator|->
name|start_queue
operator|.
name|b_actf
decl_stmt|;
name|printf
argument_list|(
literal|"ad_intr: error: bp %0p, data %0p, status %x"
argument_list|,
name|bp
argument_list|,
name|ctlr
operator|->
name|data
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|OVERRUN
condition|)
name|printf
argument_list|(
literal|" Conversion overrun (multiple A-D trigger)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|OVERFLOW
condition|)
name|printf
argument_list|(
literal|" FIFO overflow"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
block|{
name|done_and_start_next
argument_list|(
name|ctlr
argument_list|,
name|bp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ad_intr: (should not happen) error between records\n"
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|err
operator|=
name|status
expr_stmt|;
comment|/* Set overrun condition */
return|return;
block|}
block|}
else|else
comment|/* FIFO interrupt */
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|ctlr
operator|->
name|start_queue
operator|.
name|b_actf
decl_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|data
condition|)
block|{
operator|*
name|ctlr
operator|->
name|data
operator|++
operator|=
name|inb
argument_list|(
name|ADFIFO
argument_list|(
name|ctlr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|data
operator|==
name|ctlr
operator|->
name|data_end
condition|)
comment|/* Normal completion */
block|{
name|done_and_start_next
argument_list|(
name|ctlr
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
comment|/* Interrupt with no where to put the data.  */
block|{
name|printf
argument_list|(
literal|"ad_intr: (should not happen) dropped input.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|ADFIFO
argument_list|(
name|ctlr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bp %0p, status %x, cr3 %x\n"
argument_list|,
name|bp
argument_list|,
name|status
argument_list|,
name|ctlr
operator|->
name|cr_image
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|err
operator|=
name|DROPPED_INPUT
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|labpcintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ctlr
modifier|*
name|ctlr
init|=
name|labpcs
index|[
name|unit
index|]
decl_stmt|;
call|(
modifier|*
name|ctlr
operator|->
name|intr
call|)
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* lockout_multiple_opens: Return whether or not we can open again, or  * if the new mode is inconsistent with an already opened mode.  * We only permit multiple opens for digital I/O now.  */
end_comment

begin_function
specifier|static
name|int
name|lockout_multiple_open
parameter_list|(
name|dev_t
name|current
parameter_list|,
name|dev_t
name|next
parameter_list|)
block|{
return|return
operator|!
operator|(
name|DIGITAL
argument_list|(
name|current
argument_list|)
operator|&&
name|DIGITAL
argument_list|(
name|next
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|labpcopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|u_short
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ctlr
modifier|*
name|ctlr
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|MAX_UNITS
condition|)
return|return
name|ENXIO
return|;
name|ctlr
operator|=
name|labpcs
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|ctlr
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
comment|/* Don't allow another open if we have to change modes. 	 */
if|if
condition|(
operator|(
name|ctlr
operator|->
name|flags
operator|&
name|BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|ctlr
operator|->
name|flags
operator||=
name|BUSY
expr_stmt|;
name|reset
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|err
operator|=
literal|0
expr_stmt|;
name|ctlr
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|ctlr
operator|->
name|intr
operator|=
name|null_intr
expr_stmt|;
name|ctlr
operator|->
name|starter
operator|=
name|null_start
expr_stmt|;
name|ctlr
operator|->
name|stop
operator|=
name|null_stop
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lockout_multiple_open
argument_list|(
name|ctlr
operator|->
name|dev
argument_list|,
name|dev
argument_list|)
condition|)
return|return
name|EBUSY
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|labpcclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ctlr
modifier|*
name|ctlr
init|=
name|labpcs
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
call|(
modifier|*
name|ctlr
operator|->
name|stop
call|)
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|flags
operator|&=
operator|~
name|BUSY
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Start: Start a frame going in or out.  */
end_comment

begin_function
specifier|static
name|void
name|start
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|ctlr
operator|->
name|start_queue
operator|.
name|b_actf
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We must turn off FIFO interrupts when there is no 		 * place to put the data.  We have to get back to 		 * reading before the FIFO overflows. 		 */
name|CR_EXPR
argument_list|(
name|ctlr
argument_list|,
literal|3
argument_list|,
operator|&=
operator|~
operator|(
name|FIFOINTEN
operator||
name|ERRINTEN
operator|)
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|cleared_intr
operator|=
literal|1
expr_stmt|;
name|ctlr
operator|->
name|start_queue
operator|.
name|b_bcount
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|ctlr
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|ctlr
operator|->
name|data_end
operator|=
name|ctlr
operator|->
name|data
operator|+
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"labpc start: (should not happen) error between records.\n"
argument_list|)
expr_stmt|;
name|done_and_start_next
argument_list|(
name|ctlr
argument_list|,
name|bp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ctlr
operator|->
name|data
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"labpc start: (should not happen) NULL data pointer.\n"
argument_list|)
expr_stmt|;
name|done_and_start_next
argument_list|(
name|ctlr
argument_list|,
name|bp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
return|return;
block|}
call|(
modifier|*
name|ctlr
operator|->
name|starter
call|)
argument_list|(
name|ctlr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|FIFOINTENABLED
argument_list|(
name|ctlr
argument_list|)
condition|)
comment|/* We can store the data again */
block|{
name|CR_EXPR
argument_list|(
name|ctlr
argument_list|,
literal|3
argument_list|,
operator||=
operator|(
name|FIFOINTEN
operator||
name|ERRINTEN
operator|)
argument_list|)
expr_stmt|;
comment|/* Don't wait for the interrupts to fill things up. 		 */
call|(
modifier|*
name|ctlr
operator|->
name|intr
call|)
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
name|ctlr
operator|->
name|ch
operator|=
name|timeout
argument_list|(
name|tmo_stop
argument_list|,
name|ctlr
argument_list|,
name|ctlr
operator|->
name|tmo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|bp
operator|->
name|b_actf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ctlr
operator|->
name|start_queue
operator|.
name|b_bcount
condition|)
block|{
name|ctlr
operator|->
name|last
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
name|ctlr
operator|->
name|last
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
name|ctlr
operator|->
name|start_queue
operator|.
name|b_bcount
operator|=
literal|1
expr_stmt|;
name|ctlr
operator|->
name|start_queue
operator|.
name|b_actf
operator|=
name|bp
expr_stmt|;
name|ctlr
operator|->
name|last
operator|=
name|bp
expr_stmt|;
name|start
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* da_strategy: Send data to the D-A.  The CHAN field should be  * 0: D-A port 0  * 1: D-A port 1  * 2: Alternate port 0 then port 1  *  * XXX:  *  * 1. There is no state for CHAN field 2:  * the first sample in each buffer goes to channel 0.  *  * 2. No interrupt support yet.  */
end_comment

begin_function
specifier|static
name|void
name|da_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|CHAN
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|port
operator|=
name|DAC0L
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|port
operator|=
name|DAC1L
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Device 2 handles both ports interleaved. */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|<=
literal|2
condition|)
block|{
name|port
operator|=
name|DAC0L
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|bp
operator|->
name|b_bcount
operator|/
literal|2
expr_stmt|;
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|loutb
argument_list|(
name|DAC0H
argument_list|(
name|ctlr
argument_list|)
argument_list|,
operator|*
name|data
operator|++
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|DAC0L
argument_list|(
name|ctlr
argument_list|)
argument_list|,
operator|*
name|data
operator|++
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|DAC1H
argument_list|(
name|ctlr
argument_list|)
argument_list|,
operator|*
name|data
operator|++
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|DAC1L
argument_list|(
name|ctlr
argument_list|)
argument_list|,
operator|*
name|data
operator|++
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
operator|&
literal|3
expr_stmt|;
name|bp_done
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
default|default:
name|bp_done
argument_list|(
name|bp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Port 0 or 1 falls through to here. 	 */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|&
literal|1
condition|)
comment|/* Odd transfers are illegal */
name|bp_done
argument_list|(
name|bp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
name|len
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|loutb
argument_list|(
name|port
operator|+
literal|1
argument_list|,
operator|*
name|data
operator|++
argument_list|)
expr_stmt|;
name|loutb
argument_list|(
name|port
argument_list|,
operator|*
name|data
operator|++
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|bp_done
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Input masks for MODE 0 of the ports treating PC as a single  * 8 bit port.  Set these bits to set the port to input.  */
end_comment

begin_comment
comment|/* A     B    lowc  highc combined */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|set_input
index|[]
init|=
block|{
literal|0x10
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0x08
block|,
literal|0x09
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|flush_dcr
parameter_list|(
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{
if|if
condition|(
name|ctlr
operator|->
name|dcr_is
operator|!=
name|ctlr
operator|->
name|dcr_val
condition|)
block|{
name|loutb
argument_list|(
name|DCR
argument_list|(
name|ctlr
argument_list|)
argument_list|,
name|ctlr
operator|->
name|dcr_val
argument_list|)
expr_stmt|;
name|ctlr
operator|->
name|dcr_is
operator|=
name|ctlr
operator|->
name|dcr_val
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* do: Digital output  */
end_comment

begin_function
specifier|static
name|void
name|digital_out_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|chan
init|=
name|CHAN
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|ctlr
operator|->
name|dcr_val
operator|&=
operator|~
name|set_input
index|[
name|chan
index|]
expr_stmt|;
comment|/* Digital out: Clear bit */
name|flush_dcr
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
name|port
operator|=
name|PORTX
argument_list|(
name|ctlr
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|len
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|loutb
argument_list|(
name|port
argument_list|,
operator|*
name|data
operator|++
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|bp_done
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* digital_in_strategy: Digital input  */
end_comment

begin_function
specifier|static
name|void
name|digital_in_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|ctlr
modifier|*
name|ctlr
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|chan
init|=
name|CHAN
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|ctlr
operator|->
name|dcr_val
operator||=
name|set_input
index|[
name|chan
index|]
expr_stmt|;
comment|/* Digital in: Set bit */
name|flush_dcr
argument_list|(
name|ctlr
argument_list|)
expr_stmt|;
name|port
operator|=
name|PORTX
argument_list|(
name|ctlr
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|len
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|data
operator|++
operator|=
name|inb
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|bp_done
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|labpcstrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|ctlr
modifier|*
name|ctlr
init|=
name|labpcs
index|[
name|UNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|DIGITAL
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|ctlr
operator|->
name|starter
operator|=
name|null_start
expr_stmt|;
name|ctlr
operator|->
name|stop
operator|=
name|all_stop
expr_stmt|;
name|ctlr
operator|->
name|intr
operator|=
name|null_intr
expr_stmt|;
name|digital_in_strategy
argument_list|(
name|bp
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctlr
operator|->
name|starter
operator|=
name|null_start
expr_stmt|;
name|ctlr
operator|->
name|stop
operator|=
name|all_stop
expr_stmt|;
name|ctlr
operator|->
name|intr
operator|=
name|null_intr
expr_stmt|;
name|digital_out_strategy
argument_list|(
name|bp
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|ctlr
operator|->
name|starter
operator|=
name|INTERVAL
argument_list|(
name|ctlr
operator|->
name|dev
argument_list|)
condition|?
name|ad_interval_start
else|:
name|ad_start
expr_stmt|;
name|ctlr
operator|->
name|stop
operator|=
name|all_stop
expr_stmt|;
name|ctlr
operator|->
name|intr
operator|=
name|ad_intr
expr_stmt|;
name|ad_strategy
argument_list|(
name|bp
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctlr
operator|->
name|starter
operator|=
name|null_start
expr_stmt|;
name|ctlr
operator|->
name|stop
operator|=
name|all_stop
expr_stmt|;
name|ctlr
operator|->
name|intr
operator|=
name|null_intr
expr_stmt|;
name|da_strategy
argument_list|(
name|bp
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|labpcioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ctlr
modifier|*
name|ctlr
init|=
name|labpcs
index|[
name|UNIT
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|AD_MICRO_PERIOD_SET
case|:
block|{
comment|/* XXX I'm only supporting what I have to, which is 			 * no slow periods.  You can't get any slower than 15 Hz 			 * with the current setup.  To go slower you'll need to 			 * support TCINTEN in CR3. 			 */
name|long
name|sample_us
init|=
operator|*
operator|(
name|long
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|sample_us
operator|>
literal|65535
condition|)
return|return
name|EIO
return|;
name|ctlr
operator|->
name|sample_us
operator|=
name|sample_us
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|AD_MICRO_PERIOD_GET
case|:
operator|*
operator|(
name|long
operator|*
operator|)
name|arg
operator|=
name|ctlr
operator|->
name|sample_us
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AD_NGAINS_GET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|8
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AD_NCHANS_GET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|8
expr_stmt|;
return|return
literal|0
return|;
case|case
name|AD_SUPPORTED_GAINS
case|:
block|{
specifier|static
name|double
name|gains
index|[]
init|=
block|{
literal|1.
block|,
literal|1.25
block|,
literal|2.
block|,
literal|5.
block|,
literal|10.
block|,
literal|20.
block|,
literal|50.
block|,
literal|100.
block|}
decl_stmt|;
name|copyout
argument_list|(
name|gains
argument_list|,
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|gains
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|AD_GAINS_SET
case|:
block|{
name|copyin
argument_list|(
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
argument_list|,
name|ctlr
operator|->
name|gains
argument_list|,
sizeof|sizeof
argument_list|(
name|ctlr
operator|->
name|gains
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|AD_GAINS_GET
case|:
block|{
name|copyout
argument_list|(
name|ctlr
operator|->
name|gains
argument_list|,
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|ctlr
operator|->
name|gains
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
default|default:
return|return
name|ENOTTY
return|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|labpc_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|labpc_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|labpc_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|labpc_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|labpc_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|labpcdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|labpc_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

end_unit

