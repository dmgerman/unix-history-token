begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * All Rights Reserved, Copyright (C) Fujitsu Limited 1995  *  * This software may be used, modified, copied, distributed, and sold, in  * both source and binary form provided that the above copyright, these  * terms and the following disclaimer are retained.  The name of the author  * and/or the contributor may not be used to endorse or promote products  * derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND THE CONTRIBUTOR ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR THE CONTRIBUTOR BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION.  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $Id: if_fe.c,v 1.50 1999/05/04 12:59:59 kato Exp $  *  * Device driver for Fujitsu MB86960A/MB86965A based Ethernet cards.  * To be used with FreeBSD 3.x  * Contributed by M. Sekiguchi.<seki@sysrap.cs.fujitsu.co.jp>  *  * This version is intended to be a generic template for various  * MB86960A/MB86965A based Ethernet cards.  It currently supports  * Fujitsu FMV-180 series for ISA and Allied-Telesis AT1700/RE2000  * series for ISA, as well as Fujitsu MBH10302 PC card.  * There are some currently-  * unused hooks embedded, which are primarily intended to support  * other types of Ethernet cards, but the author is not sure whether  * they are useful.  *  * This version also includes some alignments to support RE1000,  * C-NET(98)P2 and so on. These cards are not for AT-compatibles,  * but for NEC PC-98 bus -- a proprietary bus architecture available  * only in Japan. Confusingly, it is different from the Microsoft's  * PC98 architecture. :-{  * Further work for PC-98 version will be available as a part of  * FreeBSD(98) project.  *  * This software is a derivative work of if_ed.c version 1.56 by David  * Greenman available as a part of FreeBSD 2.0 RELEASE source distribution.  *  * The following lines are retained from the original if_ed.c:  *  * Copyright (C) 1993, David Greenman. This software may be used, modified,  *   copied, distributed, and sold, in both source and binary form provided  *   that the above copyright and these terms are retained. Under no  *   circumstances is the author responsible for the proper functioning  *   of this software, nor does the author assume any responsibility  *   for damages incurred with its use.  */
end_comment

begin_comment
comment|/*  * TODO:  *  o   To support ISA PnP auto configuration for FMV-183/184.  *  o   To reconsider mbuf usage.  *  o   To reconsider transmission buffer usage, including  *      transmission buffer size (currently 4KB x 2) and pros-and-  *      cons of multiple frame transmission.  *  o   To test IPX codes.  *  o   To test FreeBSD3.0-current.  *  o   To test BRIDGE codes.  */
end_comment

begin_include
include|#
directive|include
file|"fe.h"
end_include

begin_include
include|#
directive|include
file|"bpf.h"
end_include

begin_include
include|#
directive|include
file|"opt_fe.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipx.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_mib.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPX code is not tested.  FIXME.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IPX
end_ifdef

begin_include
include|#
directive|include
file|<netipx/ipx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* To be used with IPv6 package of INRIA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/* IPv6 added by shin 96.2.6 */
end_comment

begin_include
include|#
directive|include
file|<netinet/if_ether6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XNS code is not tested.  FIXME.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPF
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGE
end_ifdef

begin_include
include|#
directive|include
file|<net/bridge.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_comment
comment|/* PCCARD suport */
end_comment

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<pccard/cardinfo.h>
end_include

begin_include
include|#
directive|include
file|<pccard/slot.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/ic/mb86960.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_fereg.h>
end_include

begin_comment
comment|/*  * Default settings for fe driver specific options.  * They can be set in config file by "options" statements.  */
end_comment

begin_comment
comment|/*  * Transmit just one packet per a "send" command to 86960.  * This option is intended for performance test.  An EXPERIMENTAL option.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FE_SINGLE_TRANSMISSION
end_ifndef

begin_define
define|#
directive|define
name|FE_SINGLE_TRANSMISSION
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Maximum loops when interrupt.  * This option prevents an infinite loop due to hardware failure.  * (Some laptops make an infinite loop after PC-Card is ejected.)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FE_MAX_LOOP
end_ifndef

begin_define
define|#
directive|define
name|FE_MAX_LOOP
value|0x800
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * If you define this option, 8-bit cards are also supported.  */
end_comment

begin_comment
comment|/*#define FE_8BIT_SUPPORT*/
end_comment

begin_comment
comment|/*  * Device configuration flags.  */
end_comment

begin_comment
comment|/* DLCR6 settings.  */
end_comment

begin_define
define|#
directive|define
name|FE_FLAGS_DLCR6_VALUE
value|0x007F
end_define

begin_comment
comment|/* Force DLCR6 override.  */
end_comment

begin_define
define|#
directive|define
name|FE_FLAGS_OVERRIDE_DLCR6
value|0x0080
end_define

begin_comment
comment|/* Shouldn't these be defined somewhere else such as isa_device.h?  */
end_comment

begin_define
define|#
directive|define
name|NO_IOADDR
value|(-1)
end_define

begin_define
define|#
directive|define
name|NO_IRQ
value|0
end_define

begin_comment
comment|/*  * Data type for a multicast address filter on 8696x.  */
end_comment

begin_struct
struct|struct
name|fe_filter
block|{
name|u_char
name|data
index|[
name|FE_FILTER_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Special filter values.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fe_filter
specifier|const
name|fe_filter_nothing
init|=
block|{
name|FE_FILTER_NOTHING
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fe_filter
specifier|const
name|fe_filter_all
init|=
block|{
name|FE_FILTER_ALL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many registers does an fe-supported adapter have at maximum?  */
end_comment

begin_define
define|#
directive|define
name|MAXREGISTERS
value|32
end_define

begin_comment
comment|/*  * fe_softc: per line info and status  */
end_comment

begin_struct
specifier|static
struct|struct
name|fe_softc
block|{
comment|/* Used by "common" codes.  */
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common */
comment|/* Used by config codes.  */
comment|/* Set by probe() and not modified in later phases.  */
name|char
specifier|const
modifier|*
name|typestr
decl_stmt|;
comment|/* printable name of the interface.  */
name|u_short
name|iobase
decl_stmt|;
comment|/* base I/O address of the adapter.  */
name|u_short
name|ioaddr
index|[
name|MAXREGISTERS
index|]
decl_stmt|;
comment|/* I/O addresses of registers.  */
name|u_short
name|txb_size
decl_stmt|;
comment|/* size of TX buffer, in bytes  */
name|u_char
name|proto_dlcr4
decl_stmt|;
comment|/* DLCR4 prototype.  */
name|u_char
name|proto_dlcr5
decl_stmt|;
comment|/* DLCR5 prototype.  */
name|u_char
name|proto_dlcr6
decl_stmt|;
comment|/* DLCR6 prototype.  */
name|u_char
name|proto_dlcr7
decl_stmt|;
comment|/* DLCR7 prototype.  */
name|u_char
name|proto_bmpr13
decl_stmt|;
comment|/* BMPR13 prototype.  */
name|u_char
name|stability
decl_stmt|;
comment|/* How stable is this?  */
name|u_short
name|priv_info
decl_stmt|;
comment|/* info specific to a vendor/model.  */
comment|/* Vendor/model specific hooks.  */
name|void
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
comment|/* Just before fe_init().  */
name|void
function_decl|(
modifier|*
name|stop
function_decl|)
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
comment|/* Just after fe_stop().  */
comment|/* Transmission buffer management.  */
name|u_short
name|txb_free
decl_stmt|;
comment|/* free bytes in TX buffer  */
name|u_char
name|txb_count
decl_stmt|;
comment|/* number of packets in TX buffer  */
name|u_char
name|txb_sched
decl_stmt|;
comment|/* number of scheduled packets  */
comment|/* Excessive collision counter (see fe_tint() for details.)  */
name|u_char
name|tx_excolls
decl_stmt|;
comment|/* # of excessive collisions.  */
comment|/* Multicast address filter management.  */
name|u_char
name|filter_change
decl_stmt|;
comment|/* MARs must be changed ASAP. */
name|struct
name|fe_filter
name|filter
decl_stmt|;
comment|/* new filter value.  */
comment|/* Network management.  */
name|struct
name|ifmib_iso_8802_3
name|mibdata
decl_stmt|;
comment|/* Media information.  */
name|struct
name|ifmedia
name|media
decl_stmt|;
comment|/* used by if_media.  */
name|u_short
name|mbitmap
decl_stmt|;
comment|/* bitmap for supported media; see bit2media */
name|int
name|defmedia
decl_stmt|;
comment|/* default media  */
name|void
function_decl|(
modifier|*
name|msel
function_decl|)
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
comment|/* media selector.  */
block|}
name|fe_softc
index|[
name|NFE
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|sc_if
value|arpcom.ac_if
end_define

begin_define
define|#
directive|define
name|sc_unit
value|arpcom.ac_if.if_unit
end_define

begin_define
define|#
directive|define
name|sc_enaddr
value|arpcom.ac_enaddr
end_define

begin_comment
comment|/* Standard driver entry points.  These can be static.  */
end_comment

begin_function_decl
specifier|static
name|int
name|fe_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ointhand2_t
name|feintr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|fe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_medchange
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_medstat
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Local functions.  Order of declaration is confused.  FIXME.  */
end_comment

begin_function_decl
specifier|static
name|int
name|fe_probe_ssi
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_jli
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_fmv
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_lnx
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_gwy
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_ubn
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_function_decl
specifier|static
name|int
name|fe_probe_re1000
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_cnet9ne
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_function_decl
specifier|static
name|int
name|fe_probe_mbh
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_probe_tdk
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|fe_get_packet
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|,
name|u_short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_stop
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_tint
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|,
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_rint
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|,
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_xmit
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_write_mbufs
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_setmode
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fe_loadmar
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_function_decl
specifier|static
name|void
name|fe_emptybuffer
parameter_list|(
name|struct
name|fe_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Driver struct used in the config code.  This must be public (external.)  */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|fedriver
init|=
block|{
name|fe_probe
block|,
name|fe_attach
block|,
literal|"fe"
block|,
literal|1
comment|/* It's safe to mark as "sensitive"  */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Fe driver specific constants which relate to 86960/86965.  */
end_comment

begin_comment
comment|/* Interrupt masks  */
end_comment

begin_define
define|#
directive|define
name|FE_TMASK
value|( FE_D2_COLL16 | FE_D2_TXDONE )
end_define

begin_define
define|#
directive|define
name|FE_RMASK
value|( FE_D3_OVRFLO | FE_D3_CRCERR \ 		 | FE_D3_ALGERR | FE_D3_SRTPKT | FE_D3_PKTRDY )
end_define

begin_comment
comment|/* Maximum number of iterations for a receive interrupt.  */
end_comment

begin_define
define|#
directive|define
name|FE_MAX_RECV_COUNT
value|( ( 65536 - 2048 * 2 ) / 64 )
end_define

begin_comment
comment|/* 	 * Maximum size of SRAM is 65536, 	 * minimum size of transmission buffer in fe is 2x2KB, 	 * and minimum amount of received packet including headers 	 * added by the chip is 64 bytes. 	 * Hence FE_MAX_RECV_COUNT is the upper limit for number 	 * of packets in the receive buffer. 	 */
end_comment

begin_comment
comment|/*  * Miscellaneous definitions not directly related to hardware.  */
end_comment

begin_comment
comment|/* Flags for stability.  */
end_comment

begin_define
define|#
directive|define
name|UNSTABLE_IRQ
value|0x01
end_define

begin_comment
comment|/* IRQ setting may be incorrect.  */
end_comment

begin_define
define|#
directive|define
name|UNSTABLE_MAC
value|0x02
end_define

begin_comment
comment|/* Probed MAC address may be incorrect.  */
end_comment

begin_define
define|#
directive|define
name|UNSTABLE_TYPE
value|0x04
end_define

begin_comment
comment|/* Probed vendor/model may be incorrect.  */
end_comment

begin_comment
comment|/* The following line must be delete when "net/if_media.h" support it.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IFM_10_FL
end_ifndef

begin_define
define|#
directive|define
name|IFM_10_FL
comment|/* 13 */
value|IFM_10_5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Mapping between media bitmap (in fe_softc.mbitmap) and ifm_media.  */
end_comment

begin_define
unit|static int const bit2media [] = {
define|#
directive|define
name|MB_HA
value|0x0001
end_define

begin_define
unit|IFM_HDX | IFM_ETHER | IFM_AUTO,
define|#
directive|define
name|MB_HM
value|0x0002
end_define

begin_define
unit|IFM_HDX | IFM_ETHER | IFM_MANUAL,
define|#
directive|define
name|MB_HT
value|0x0004
end_define

begin_define
unit|IFM_HDX | IFM_ETHER | IFM_10_T,
define|#
directive|define
name|MB_H2
value|0x0008
end_define

begin_define
unit|IFM_HDX | IFM_ETHER | IFM_10_2,
define|#
directive|define
name|MB_H5
value|0x0010
end_define

begin_define
unit|IFM_HDX | IFM_ETHER | IFM_10_5,
define|#
directive|define
name|MB_HF
value|0x0020
end_define

begin_define
unit|IFM_HDX | IFM_ETHER | IFM_10_FL,
define|#
directive|define
name|MB_FT
value|0x0040
end_define

begin_comment
unit|IFM_FDX | IFM_ETHER | IFM_10_T,
comment|/* More can be come here... */
end_comment

begin_else
unit|0 };
else|#
directive|else
end_else

begin_comment
comment|/* Mapping between media bitmap (in fe_softc.mbitmap) and ifm_media.  */
end_comment

begin_decl_stmt
specifier|static
name|int
specifier|const
name|bit2media
index|[]
init|=
block|{
define|#
directive|define
name|MB_HA
value|0x0001
name|IFM_ETHER
operator||
name|IFM_AUTO
block|,
define|#
directive|define
name|MB_HM
value|0x0002
name|IFM_ETHER
operator||
name|IFM_MANUAL
block|,
define|#
directive|define
name|MB_HT
value|0x0004
name|IFM_ETHER
operator||
name|IFM_10_T
block|,
define|#
directive|define
name|MB_H2
value|0x0008
name|IFM_ETHER
operator||
name|IFM_10_2
block|,
define|#
directive|define
name|MB_H5
value|0x0010
name|IFM_ETHER
operator||
name|IFM_10_5
block|,
define|#
directive|define
name|MB_HF
value|0x0020
name|IFM_ETHER
operator||
name|IFM_10_FL
block|,
define|#
directive|define
name|MB_FT
value|0x0040
name|IFM_ETHER
operator||
name|IFM_10_T
block|,
comment|/* More can be come here... */
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Routines to access contiguous I/O ports.  */
end_comment

begin_function
specifier|static
name|void
name|inblk
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offs
parameter_list|,
name|u_char
modifier|*
name|mem
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
operator|*
name|mem
operator|++
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|offs
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|outblk
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|offs
parameter_list|,
name|u_char
specifier|const
modifier|*
name|mem
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|offs
operator|++
index|]
argument_list|,
operator|*
name|mem
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* PCCARD Support */
end_comment

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_comment
comment|/*  *      PC-Card (PCMCIA) specific code.  */
end_comment

begin_function_decl
specifier|static
name|int
name|feinit
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|feunload
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fe_card_intr
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|PCCARD_MODULE
argument_list|(
name|fe
argument_list|,
name|feinit
argument_list|,
name|feunload
argument_list|,
name|fe_card_intr
argument_list|,
literal|0
argument_list|,
name|net_imask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *      Initialize the device - called from Slot manager.  */
end_comment

begin_function
specifier|static
name|int
name|feinit
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
decl_stmt|;
comment|/* validate unit number.  */
if|if
condition|(
name|devi
operator|->
name|isahd
operator|.
name|id_unit
operator|>=
name|NFE
condition|)
return|return
name|ENODEV
return|;
comment|/* Prepare for the device probe process.  */
name|sc
operator|=
operator|&
name|fe_softc
index|[
name|devi
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|sc
operator|->
name|sc_unit
operator|=
name|devi
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|sc
operator|->
name|iobase
operator|=
name|devi
operator|->
name|isahd
operator|.
name|id_iobase
expr_stmt|;
comment|/* 	 * When the feinit() is called, the devi->misc holds a 	 * six-byte value set by the pccard daemon.  If the 	 * corresponding entry in /etc/pccard.conf has an "ether" 	 * keyword, the value is the Ethernet MAC address extracted 	 * from CIS area of the card.  If the entry has no "ether" 	 * keyword, the daemon fills the field with binary zero, 	 * instead.  We passes the value (either MAC address or zero) 	 * to model-specific sub-probe routines through sc->sc_enaddr 	 * (it actually is sc->sc_arpcom.ar_enaddr, BTW) so that the 	 * sub-probe routies can use that info. 	 */
name|bcopy
argument_list|(
name|devi
operator|->
name|misc
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Probe for supported cards.  */
if|if
condition|(
name|fe_probe_mbh
argument_list|(
operator|&
name|devi
operator|->
name|isahd
argument_list|,
name|sc
argument_list|)
operator|==
literal|0
operator|&&
name|fe_probe_tdk
argument_list|(
operator|&
name|devi
operator|->
name|isahd
argument_list|,
name|sc
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
comment|/* We've got a supported card.  Attach it, then.  */
if|if
condition|(
name|fe_attach
argument_list|(
operator|&
name|devi
operator|->
name|isahd
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *	feunload - unload the driver and clear the table.  *	XXX TODO:  *	This is usually called when the card is ejected, but  *	can be caused by a modunload of a controller driver.  *	The idea is to reset the driver's view of the device  *	and ensure that any driver entry points such as  *	read and write do not hang.  */
end_comment

begin_function
specifier|static
name|void
name|feunload
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
operator|&
name|fe_softc
index|[
name|devi
operator|->
name|isahd
operator|.
name|id_unit
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"fe%d: unload\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|fe_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_down
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	fe_card_intr - Shared interrupt called from  *	 front end of PC-Card handler.  */
end_comment

begin_function
specifier|static
name|int
name|fe_card_intr
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|feintr
argument_list|(
name|devi
operator|->
name|isahd
operator|.
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCARD> 0 */
end_comment

begin_comment
comment|/*  * Hardware probe routines.  *  * In older versions of this driver, we provided an automatic I/O  * address detection.  The features is, however, removed from this  * version, for simplicity.  Any comments?  */
end_comment

begin_comment
comment|/*  * Determine if the device is present at a specified I/O address.  The  * main entry to the driver.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|nports
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|dev
operator|->
name|id_unit
operator|>=
name|NFE
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: too large unit number for the current config\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* Prepare for the softc struct.  */
name|sc
operator|=
operator|&
name|fe_softc
index|[
name|dev
operator|->
name|id_unit
index|]
expr_stmt|;
name|sc
operator|->
name|sc_unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
name|sc
operator|->
name|iobase
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
comment|/* Probe for supported boards.  */
name|nports
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
operator|!
name|nports
condition|)
name|nports
operator|=
name|fe_probe_re1000
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nports
condition|)
name|nports
operator|=
name|fe_probe_cnet9ne
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|nports
condition|)
name|nports
operator|=
name|fe_probe_ssi
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nports
condition|)
name|nports
operator|=
name|fe_probe_jli
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nports
condition|)
name|nports
operator|=
name|fe_probe_fmv
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nports
condition|)
name|nports
operator|=
name|fe_probe_lnx
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nports
condition|)
name|nports
operator|=
name|fe_probe_ubn
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nports
condition|)
name|nports
operator|=
name|fe_probe_gwy
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* We found supported board.  */
return|return
name|nports
return|;
block|}
end_function

begin_comment
comment|/*  * Check for specific bits in specific registers have specific values.  * A common utility function called from various sub-probe routines.  */
end_comment

begin_struct
struct|struct
name|fe_simple_probe_struct
block|{
name|u_char
name|port
decl_stmt|;
comment|/* Offset from the base I/O address.  */
name|u_char
name|mask
decl_stmt|;
comment|/* Bits to be checked.  */
name|u_char
name|bits
decl_stmt|;
comment|/* Values to be compared against.  */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|fe_simple_probe
parameter_list|(
name|struct
name|fe_softc
specifier|const
modifier|*
name|sc
parameter_list|,
name|struct
name|fe_simple_probe_struct
specifier|const
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|fe_simple_probe_struct
specifier|const
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|sp
init|;
name|p
operator|->
name|mask
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|FE_DEBUG
name|unsigned
name|a
init|=
name|sc
operator|->
name|ioaddr
index|[
name|p
operator|->
name|port
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"fe%d: Probing %02x (%04x): %02x (%02x, %02x): %s\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|p
operator|->
name|port
argument_list|,
name|a
argument_list|,
name|inb
argument_list|(
name|a
argument_list|)
argument_list|,
name|p
operator|->
name|mask
argument_list|,
name|p
operator|->
name|bits
argument_list|,
operator|(
name|inb
argument_list|(
name|a
argument_list|)
operator|&
name|p
operator|->
name|mask
operator|)
operator|==
name|p
operator|->
name|bits
condition|?
literal|"OK"
else|:
literal|"NG"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|p
operator|->
name|port
index|]
argument_list|)
operator|&
name|p
operator|->
name|mask
operator|)
operator|!=
name|p
operator|->
name|bits
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Test if a given 6 byte value is a valid Ethernet station (MAC)    address.  "Vendor" is an expected vendor code (first three bytes,)    or a zero when nothing expected.  */
end_comment

begin_function
specifier|static
name|int
name|valid_Ether_p
parameter_list|(
name|u_char
specifier|const
modifier|*
name|addr
parameter_list|,
name|unsigned
name|vendor
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FE_DEBUG
name|printf
argument_list|(
literal|"fe?: validating %6D against %06x\n"
argument_list|,
name|addr
argument_list|,
literal|":"
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* All zero is not allowed as a vendor code.  */
if|if
condition|(
name|addr
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|addr
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|addr
index|[
literal|2
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|vendor
condition|)
block|{
case|case
literal|0x000000
case|:
comment|/* Legal Ethernet address (stored in ROM) must have 		   its Group and Local bits cleared.  */
if|if
condition|(
operator|(
name|addr
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
case|case
literal|0x020000
case|:
comment|/* Same as above, but a local address is allowed in                    this context.  */
if|if
condition|(
operator|(
name|addr
index|[
literal|0
index|]
operator|&
literal|0x01
operator|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
break|break;
default|default:
comment|/* Make sure the vendor part matches if one is given.  */
if|if
condition|(
name|addr
index|[
literal|0
index|]
operator|!=
operator|(
operator|(
name|vendor
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
operator|)
operator|||
name|addr
index|[
literal|1
index|]
operator|!=
operator|(
operator|(
name|vendor
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
operator|)
operator|||
name|addr
index|[
literal|2
index|]
operator|!=
operator|(
operator|(
name|vendor
operator|)
operator|&
literal|0xFF
operator|)
condition|)
return|return
literal|0
return|;
break|break;
block|}
comment|/* Host part must not be all-zeros nor all-ones.  */
if|if
condition|(
name|addr
index|[
literal|3
index|]
operator|==
literal|0xFF
operator|&&
name|addr
index|[
literal|4
index|]
operator|==
literal|0xFF
operator|&&
name|addr
index|[
literal|5
index|]
operator|==
literal|0xFF
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|addr
index|[
literal|3
index|]
operator|==
literal|0x00
operator|&&
name|addr
index|[
literal|4
index|]
operator|==
literal|0x00
operator|&&
name|addr
index|[
literal|5
index|]
operator|==
literal|0x00
condition|)
return|return
literal|0
return|;
comment|/* Given addr looks like an Ethernet address.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fill our softc struct with default value.  */
end_comment

begin_function
specifier|static
name|void
name|fe_softc_defaults
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Initialize I/O address re-mapping table for the standard 	   (contiguous) register layout.  This routine doesn't use 	   ioaddr[], so the caller can safely override it after 	   calling fe_softc_defaults, if needed.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
name|i
expr_stmt|;
comment|/* Prepare for typical register prototypes.  We assume a            "typical" board has<32KB> of<fast> SRAM connected with a<byte-wide> data lines.  */
name|sc
operator|->
name|proto_dlcr4
operator|=
name|FE_D4_LBC_DISABLE
operator||
name|FE_D4_CNTRL
expr_stmt|;
name|sc
operator|->
name|proto_dlcr5
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_32KB
operator||
name|FE_D6_TXBSIZ_2x4KB
operator||
name|FE_D6_BBW_BYTE
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM_100ns
expr_stmt|;
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
expr_stmt|;
name|sc
operator|->
name|proto_bmpr13
operator|=
literal|0
expr_stmt|;
comment|/* Assume the probe process (to be done later) is stable.  */
name|sc
operator|->
name|stability
operator|=
literal|0
expr_stmt|;
comment|/* A typical board needs no hooks.  */
name|sc
operator|->
name|init
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|stop
operator|=
name|NULL
expr_stmt|;
comment|/* Assume the board has no software-controllable media selection.  */
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HM
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HM
expr_stmt|;
name|sc
operator|->
name|msel
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Common error reporting routine used in probe routines for    "soft configured IRQ"-type boards.  */
end_comment

begin_function
specifier|static
name|void
name|fe_irq_failure
parameter_list|(
name|char
specifier|const
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|irq
parameter_list|,
name|char
specifier|const
modifier|*
name|list
parameter_list|)
block|{
name|printf
argument_list|(
literal|"fe%d: %s board is detected, but %s IRQ was given\n"
argument_list|,
name|unit
argument_list|,
name|name
argument_list|,
operator|(
name|irq
operator|==
name|NO_IRQ
condition|?
literal|"no"
else|:
literal|"invalid"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: specify an IRQ from %s in kernel config\n"
argument_list|,
name|unit
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Hardware (vendor) specific probe routines and hooks.  */
end_comment

begin_comment
comment|/*  * Machine independent routines.  */
end_comment

begin_comment
comment|/*  * Generic media selection scheme for MB86965 based boards.  */
end_comment

begin_function
specifier|static
name|void
name|fe_msel_965
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|b13
decl_stmt|;
comment|/* Find the appropriate bits for BMPR13 tranceiver control.  */
switch|switch
condition|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|media
operator|.
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_AUTO
case|:
name|b13
operator|=
name|FE_B13_PORT_AUTO
operator||
name|FE_B13_TPTYPE_UTP
expr_stmt|;
break|break;
case|case
name|IFM_10_T
case|:
name|b13
operator|=
name|FE_B13_PORT_TP
operator||
name|FE_B13_TPTYPE_UTP
expr_stmt|;
break|break;
default|default:
name|b13
operator|=
name|FE_B13_PORT_AUI
expr_stmt|;
break|break;
block|}
comment|/* Write it into the register.  It takes effect immediately.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR13
index|]
argument_list|,
name|sc
operator|->
name|proto_bmpr13
operator||
name|b13
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fujitsu MB86965 JLI mode support routines.  */
end_comment

begin_comment
comment|/* Datasheet for 86965 explicitly states that it only supports serial  * EEPROM with 16 words (32 bytes) capacity.  (I.e., 93C06.)  However,  * ones with 64 words (128 bytes) are available in the marked, namely  * 93C46, and are also fully compatible with 86965.  It is known that  * some boards (e.g., ICL) actually have 93C46 on them and use extra  * storage to keep various config info.  */
end_comment

begin_define
define|#
directive|define
name|JLI_EEPROM_SIZE
value|128
end_define

begin_comment
comment|/*  * Routines to read all bytes from the config EEPROM through MB86965A.  * It is a MicroWire (3-wire) serial EEPROM with 6-bit address.  * (93C06 or 93C46.)  */
end_comment

begin_function
specifier|static
name|void
name|fe_strobe_eeprom_jli
parameter_list|(
name|u_short
name|bmpr16
parameter_list|)
block|{
comment|/* 	 * We must guarantee 1us (or more) interval to access slow 	 * EEPROMs.  The following redundant code provides enough 	 * delay with ISA timing.  (Even if the bus clock is "tuned.") 	 * Some modification will be needed on faster busses. 	 */
name|outb
argument_list|(
name|bmpr16
argument_list|,
name|FE_B16_SELECT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr16
argument_list|,
name|FE_B16_SELECT
operator||
name|FE_B16_CLOCK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr16
argument_list|,
name|FE_B16_SELECT
operator||
name|FE_B16_CLOCK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr16
argument_list|,
name|FE_B16_SELECT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fe_read_eeprom_jli
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|u_short
name|bmpr16
init|=
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR16
index|]
decl_stmt|;
name|u_short
name|bmpr17
init|=
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR17
index|]
decl_stmt|;
name|u_char
name|n
decl_stmt|,
name|val
decl_stmt|,
name|bit
decl_stmt|;
name|u_char
name|save16
decl_stmt|,
name|save17
decl_stmt|;
comment|/* Save the current value of the EEPROM interface registers.  */
name|save16
operator|=
name|inb
argument_list|(
name|bmpr16
argument_list|)
expr_stmt|;
name|save17
operator|=
name|inb
argument_list|(
name|bmpr17
argument_list|)
expr_stmt|;
comment|/* Read bytes from EEPROM; two bytes per an iteration.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|JLI_EEPROM_SIZE
operator|/
literal|2
condition|;
name|n
operator|++
control|)
block|{
comment|/* Reset the EEPROM interface.  */
name|outb
argument_list|(
name|bmpr16
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr17
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Start EEPROM access.  */
name|outb
argument_list|(
name|bmpr16
argument_list|,
name|FE_B16_SELECT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr17
argument_list|,
name|FE_B17_DATA
argument_list|)
expr_stmt|;
name|fe_strobe_eeprom_jli
argument_list|(
name|bmpr16
argument_list|)
expr_stmt|;
comment|/* Pass the iteration count as well as a READ command.  */
name|val
operator|=
literal|0x80
operator||
name|n
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|outb
argument_list|(
name|bmpr17
argument_list|,
operator|(
name|val
operator|&
name|bit
operator|)
condition|?
name|FE_B17_DATA
else|:
literal|0
argument_list|)
expr_stmt|;
name|fe_strobe_eeprom_jli
argument_list|(
name|bmpr16
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|bmpr17
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Read a byte.  */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|fe_strobe_eeprom_jli
argument_list|(
name|bmpr16
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|bmpr17
argument_list|)
operator|&
name|FE_B17_DATA
condition|)
block|{
name|val
operator||=
name|bit
expr_stmt|;
block|}
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
comment|/* Read one more byte.  */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|fe_strobe_eeprom_jli
argument_list|(
name|bmpr16
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|bmpr17
argument_list|)
operator|&
name|FE_B17_DATA
condition|)
block|{
name|val
operator||=
name|bit
expr_stmt|;
block|}
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Reset the EEPROM interface, again.  */
block|outb( bmpr16, 0x00 ); 	outb( bmpr17, 0x00 );
else|#
directive|else
comment|/* Make sure to restore the original value of EEPROM interface            registers, since we are not yet sure we have MB86965A on            the address.  */
name|outb
argument_list|(
name|bmpr17
argument_list|,
name|save17
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr16
argument_list|,
name|save16
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|1
comment|/* Report what we got.  */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|int
name|i
decl_stmt|;
name|data
operator|-=
name|JLI_EEPROM_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JLI_EEPROM_SIZE
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|printf
argument_list|(
literal|"fe%d: EEPROM(JLI):%3x: %16D\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|i
argument_list|,
name|data
operator|+
name|i
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|fe_init_jli
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* "Reset" by writing into a magic location.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1E
index|]
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1E
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|300
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SSi 78Q8377A support routines.  */
end_comment

begin_define
define|#
directive|define
name|SSI_EEPROM_SIZE
value|512
end_define

begin_define
define|#
directive|define
name|SSI_DIN
value|0x01
end_define

begin_define
define|#
directive|define
name|SSI_DAT
value|0x01
end_define

begin_define
define|#
directive|define
name|SSI_CSL
value|0x02
end_define

begin_define
define|#
directive|define
name|SSI_CLK
value|0x04
end_define

begin_define
define|#
directive|define
name|SSI_EEP
value|0x10
end_define

begin_comment
comment|/*  * Routines to read all bytes from the config EEPROM through 78Q8377A.  * It is a MicroWire (3-wire) serial EEPROM with 8-bit address.  (I.e.,  * 93C56 or 93C66.)  *  * As I don't have SSi manuals, (hmm, an old song again!) I'm not exactly  * sure the following code is correct...  It is just stolen from the  * C-NET(98)P2 support routine in FreeBSD(98).  */
end_comment

begin_function
specifier|static
name|void
name|fe_read_eeprom_ssi
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|u_short
name|bmpr12
init|=
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR12
index|]
decl_stmt|;
name|u_char
name|val
decl_stmt|,
name|bit
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_char
name|save6
decl_stmt|,
name|save7
decl_stmt|,
name|save12
decl_stmt|;
comment|/* Save the current value for the DLCR registers we are about            to destroy.  */
name|save6
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|)
expr_stmt|;
name|save7
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|)
expr_stmt|;
comment|/* Put the 78Q8377A into a state that we can access the EEPROM.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|FE_D6_BBW_WORD
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|FE_D7_BYTSWP_LH
operator||
name|FE_D7_RBS_BMPR
operator||
name|FE_D7_RDYPNS
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
comment|/* Save the current value for the BMPR12 register, too.  */
name|save12
operator|=
name|inb
argument_list|(
name|bmpr12
argument_list|)
expr_stmt|;
comment|/* Read bytes from EEPROM; two bytes per an iteration.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|SSI_EEPROM_SIZE
operator|/
literal|2
condition|;
name|n
operator|++
control|)
block|{
comment|/* Start EEPROM access  */
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
argument_list|)
expr_stmt|;
comment|/* Send the following four bits to the EEPROM in the                    specified order: a dummy bit, a start bit, and                    command bits (10) for READ.  */
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
argument_list|)
expr_stmt|;
comment|/* 0 */
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_DAT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
operator||
name|SSI_DAT
argument_list|)
expr_stmt|;
comment|/* 1 */
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_DAT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
operator||
name|SSI_DAT
argument_list|)
expr_stmt|;
comment|/* 1 */
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
argument_list|)
expr_stmt|;
comment|/* 0 */
comment|/* Pass the iteration count to the chip.  */
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|val
operator|=
operator|(
name|n
operator|&
name|bit
operator|)
condition|?
name|SSI_DAT
else|:
literal|0
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|val
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
operator||
name|val
argument_list|)
expr_stmt|;
block|}
comment|/* Read a byte.  */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|bmpr12
argument_list|)
operator|&
name|SSI_DIN
condition|)
name|val
operator||=
name|bit
expr_stmt|;
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
comment|/* Read one more byte.  */
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
operator||
name|SSI_CSL
operator||
name|SSI_CLK
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|bmpr12
argument_list|)
operator|&
name|SSI_DIN
condition|)
name|val
operator||=
name|bit
expr_stmt|;
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
name|outb
argument_list|(
name|bmpr12
argument_list|,
name|SSI_EEP
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the EEPROM interface.  (For now.)  */
name|outb
argument_list|(
name|bmpr12
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Restore the saved register values, for the case that we            didn't have 78Q8377A at the given address.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR12
index|]
argument_list|,
name|save12
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|save7
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|save6
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Report what we got.  */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|int
name|i
decl_stmt|;
name|data
operator|-=
name|SSI_EEPROM_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SSI_EEPROM_SIZE
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|printf
argument_list|(
literal|"fe%d: EEPROM(SSI):%3x: %16D\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|i
argument_list|,
name|data
operator|+
name|i
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_define
define|#
directive|define
name|FE_SSI_EEP_IRQ
value|9
end_define

begin_comment
comment|/* Irq ???		*/
end_comment

begin_define
define|#
directive|define
name|FE_SSI_EEP_ADDR
value|16
end_define

begin_comment
comment|/* Station(MAC) address	*/
end_comment

begin_define
define|#
directive|define
name|FE_SSI_EEP_DUPLEX
value|25
end_define

begin_comment
comment|/* Duplex mode ???	*/
end_comment

begin_comment
comment|/*  * TDK/LANX boards support routines.  */
end_comment

begin_comment
comment|/* AX012/AX013 equips an X24C01 chip, which has 128 bytes of memory cells.  */
end_comment

begin_define
define|#
directive|define
name|LNX_EEPROM_SIZE
value|128
end_define

begin_comment
comment|/* Bit assignments and command definitions for the serial EEPROM    interface register in LANX ASIC.  */
end_comment

begin_define
define|#
directive|define
name|LNX_SDA_HI
value|0x08
end_define

begin_comment
comment|/* Drive SDA line high (logical 1.)	*/
end_comment

begin_define
define|#
directive|define
name|LNX_SDA_LO
value|0x00
end_define

begin_comment
comment|/* Drive SDA line low (logical 0.)	*/
end_comment

begin_define
define|#
directive|define
name|LNX_SDA_FL
value|0x08
end_define

begin_comment
comment|/* Float (don't drive) SDA line.	*/
end_comment

begin_define
define|#
directive|define
name|LNX_SDA_IN
value|0x01
end_define

begin_comment
comment|/* Mask for reading SDA line.		*/
end_comment

begin_define
define|#
directive|define
name|LNX_CLK_HI
value|0x04
end_define

begin_comment
comment|/* Drive clock line high (active.)	*/
end_comment

begin_define
define|#
directive|define
name|LNX_CLK_LO
value|0x00
end_define

begin_comment
comment|/* Drive clock line low (inactive.)	*/
end_comment

begin_comment
comment|/* It is assumed that the CLK line is low and SDA is high (float) upon entry.  */
end_comment

begin_define
define|#
directive|define
name|LNX_PH
parameter_list|(
name|D
parameter_list|,
name|K
parameter_list|,
name|N
parameter_list|)
define|\
value|((LNX_SDA_##D | LNX_CLK_##K)<< N)
end_define

begin_define
define|#
directive|define
name|LNX_CYCLE
parameter_list|(
name|D1
parameter_list|,
name|D2
parameter_list|,
name|D3
parameter_list|,
name|D4
parameter_list|,
name|K1
parameter_list|,
name|K2
parameter_list|,
name|K3
parameter_list|,
name|K4
parameter_list|)
define|\
value|(LNX_PH(D1,K1,0)|LNX_PH(D2,K2,8)|LNX_PH(D3,K3,16)|LNX_PH(D4,K4,24))
end_define

begin_define
define|#
directive|define
name|LNX_CYCLE_START
value|LNX_CYCLE(HI,LO,LO,HI, HI,HI,LO,LO)
end_define

begin_define
define|#
directive|define
name|LNX_CYCLE_STOP
value|LNX_CYCLE(LO,LO,HI,HI, LO,HI,HI,LO)
end_define

begin_define
define|#
directive|define
name|LNX_CYCLE_HI
value|LNX_CYCLE(HI,HI,HI,HI, LO,HI,LO,LO)
end_define

begin_define
define|#
directive|define
name|LNX_CYCLE_LO
value|LNX_CYCLE(LO,LO,LO,HI, LO,HI,LO,LO)
end_define

begin_define
define|#
directive|define
name|LNX_CYCLE_INIT
value|LNX_CYCLE(LO,HI,HI,HI, LO,LO,LO,LO)
end_define

begin_function
specifier|static
name|void
name|fe_eeprom_cycle_lnx
parameter_list|(
name|u_short
name|reg20
parameter_list|,
name|u_long
name|cycle
parameter_list|)
block|{
name|outb
argument_list|(
name|reg20
argument_list|,
operator|(
name|cycle
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|reg20
argument_list|,
operator|(
name|cycle
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|reg20
argument_list|,
operator|(
name|cycle
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|reg20
argument_list|,
operator|(
name|cycle
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_char
name|fe_eeprom_receive_lnx
parameter_list|(
name|u_short
name|reg20
parameter_list|)
block|{
name|u_char
name|dat
decl_stmt|;
name|outb
argument_list|(
name|reg20
argument_list|,
name|LNX_CLK_HI
operator||
name|LNX_SDA_FL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|dat
operator|=
name|inb
argument_list|(
name|reg20
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|reg20
argument_list|,
name|LNX_CLK_LO
operator||
name|LNX_SDA_FL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
return|return
operator|(
name|dat
operator|&
name|LNX_SDA_IN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fe_read_eeprom_lnx
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|n
decl_stmt|,
name|bit
decl_stmt|,
name|val
decl_stmt|;
name|u_char
name|save20
decl_stmt|;
name|u_short
name|reg20
init|=
name|sc
operator|->
name|ioaddr
index|[
literal|0x14
index|]
decl_stmt|;
name|save20
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x14
index|]
argument_list|)
expr_stmt|;
comment|/* NOTE: DELAY() timing constants are approximately three            times longer (slower) than the required minimum.  This is            to guarantee a reliable operation under some tough            conditions...  Fortunately, this routine is only called            during the boot phase, so the speed is less important than            stability.  */
if|#
directive|if
literal|1
comment|/* Reset the X24C01's internal state machine and put it into 	   the IDLE state.  We usually don't need this, but *if* 	   someone (e.g., probe routine of other driver) write some 	   garbage into the register at 0x14, synchronization will be 	   lost, and the normal EEPROM access protocol won't work. 	   Moreover, as there are no easy way to reset, we need a 	   _manoeuvre_ here.  (It even lacks a reset pin, so pushing 	   the RESET button on the PC doesn't help!)  */
name|fe_eeprom_cycle_lnx
argument_list|(
name|reg20
argument_list|,
name|LNX_CYCLE_INIT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|fe_eeprom_cycle_lnx
argument_list|(
name|reg20
argument_list|,
name|LNX_CYCLE_START
argument_list|)
expr_stmt|;
block|}
name|fe_eeprom_cycle_lnx
argument_list|(
name|reg20
argument_list|,
name|LNX_CYCLE_STOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Issue a start condition.  */
name|fe_eeprom_cycle_lnx
argument_list|(
name|reg20
argument_list|,
name|LNX_CYCLE_START
argument_list|)
expr_stmt|;
comment|/* Send seven bits of the starting address (zero, in this 	   case) and a command bit for READ.  */
name|val
operator|=
literal|0x01
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|val
operator|&
name|bit
condition|)
block|{
name|fe_eeprom_cycle_lnx
argument_list|(
name|reg20
argument_list|,
name|LNX_CYCLE_HI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fe_eeprom_cycle_lnx
argument_list|(
name|reg20
argument_list|,
name|LNX_CYCLE_LO
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Receive an ACK bit.  */
if|if
condition|(
name|fe_eeprom_receive_lnx
argument_list|(
name|reg20
argument_list|)
condition|)
block|{
comment|/* ACK was not received.  EEPROM is not present (i.e., 		   this board was not a TDK/LANX) or not working 		   properly.  */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: no ACK received from EEPROM(LNX)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
comment|/* Clear the given buffer to indicate we could not get                    any info. and return.  */
name|bzero
argument_list|(
name|data
argument_list|,
name|LNX_EEPROM_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|RET
goto|;
block|}
comment|/* Read bytes from EEPROM.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|LNX_EEPROM_SIZE
condition|;
name|n
operator|++
control|)
block|{
comment|/* Read a byte and store it into the buffer.  */
name|val
operator|=
literal|0x00
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0x80
init|;
name|bit
operator|!=
literal|0x00
condition|;
name|bit
operator|>>=
literal|1
control|)
block|{
if|if
condition|(
name|fe_eeprom_receive_lnx
argument_list|(
name|reg20
argument_list|)
condition|)
name|val
operator||=
name|bit
expr_stmt|;
block|}
operator|*
name|data
operator|++
operator|=
name|val
expr_stmt|;
comment|/* Acknowledge if we have to read more.  */
if|if
condition|(
name|n
operator|<
name|LNX_EEPROM_SIZE
operator|-
literal|1
condition|)
block|{
name|fe_eeprom_cycle_lnx
argument_list|(
name|reg20
argument_list|,
name|LNX_CYCLE_LO
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Issue a STOP condition, de-activating the clock line. 	   It will be safer to keep the clock line low than to leave 	   it high.  */
name|fe_eeprom_cycle_lnx
argument_list|(
name|reg20
argument_list|,
name|LNX_CYCLE_STOP
argument_list|)
expr_stmt|;
name|RET
label|:
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x14
index|]
argument_list|,
name|save20
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Report what we got.  */
name|data
operator|-=
name|LNX_EEPROM_SIZE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JLI_EEPROM_SIZE
condition|;
name|i
operator|+=
literal|16
control|)
block|{
name|printf
argument_list|(
literal|"fe%d: EEPROM(LNX):%3x: %16D\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|i
argument_list|,
name|data
operator|+
name|i
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|fe_init_lnx
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Reset the 86960.  Do we need this?  FIXME.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x12
index|]
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x12
index|]
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Setup IRQ control register on the ASIC.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x14
index|]
argument_list|,
name|sc
operator|->
name|priv_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ungermann-Bass boards support routine.  */
end_comment

begin_function
specifier|static
name|void
name|fe_init_ubn
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Do we need this?  FIXME.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_BMPR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x18
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Setup IRQ control register on the ASIC.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x14
index|]
argument_list|,
name|sc
operator|->
name|priv_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Machine dependent probe routines.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_function
specifier|static
name|int
name|fe_probe_fmv
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* PC-98 has no board of this architechture.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ioaddr for RE1000/1000Plus - Very dirty!  */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|ioaddr_re1000
index|[
name|MAXREGISTERS
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x0001
block|,
literal|0x0200
block|,
literal|0x0201
block|,
literal|0x0400
block|,
literal|0x0401
block|,
literal|0x0600
block|,
literal|0x0601
block|,
literal|0x0800
block|,
literal|0x0801
block|,
literal|0x0a00
block|,
literal|0x0a01
block|,
literal|0x0c00
block|,
literal|0x0c01
block|,
literal|0x0e00
block|,
literal|0x0e01
block|,
literal|0x1000
block|,
literal|0x1200
block|,
literal|0x1400
block|,
literal|0x1600
block|,
literal|0x1800
block|,
literal|0x1a00
block|,
literal|0x1c00
block|,
literal|0x1e00
block|,
literal|0x1001
block|,
literal|0x1201
block|,
literal|0x1401
block|,
literal|0x1601
block|,
literal|0x1801
block|,
literal|0x1a01
block|,
literal|0x1c01
block|,
literal|0x1e01
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Probe and initialization for Allied-Telesis RE1000 series.  */
end_comment

begin_function
specifier|static
name|void
name|fe_init_re1000
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Setup IRQ control register on the ASIC.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_RE1000_IRQCONF
index|]
argument_list|,
name|sc
operator|->
name|priv_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fe_probe_re1000
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_char
name|sum
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for RE1000.  */
comment|/* [01]D[02468ACE] are allowed.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|iobase
operator|&
operator|~
literal|0x10E
operator|)
operator|!=
literal|0xD0
condition|)
return|return
literal|0
return|;
comment|/* Setup an I/O address mapping table and some others.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Re-map ioaddr for RE1000.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
name|ioaddr_re1000
index|[
name|i
index|]
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Get our station address from EEPROM.  */
name|inblk
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Make sure it is Allied-Telesis's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x0000F4
argument_list|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
literal|1
comment|/* Calculate checksum.  */
name|sum
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1e
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|^=
name|sc
operator|->
name|sc_enaddr
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* Setup the board type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"RE1000"
expr_stmt|;
comment|/* This looks like an RE1000 board.  It requires an 	   explicit IRQ setting in config.  Make sure we have one, 	   determining an appropriate value for the IRQ control 	   register.  */
switch|switch
condition|(
name|dev
operator|->
name|id_irq
condition|)
block|{
case|case
name|IRQ3
case|:
name|n
operator|=
literal|0x10
expr_stmt|;
break|break;
case|case
name|IRQ5
case|:
name|n
operator|=
literal|0x20
expr_stmt|;
break|break;
case|case
name|IRQ6
case|:
name|n
operator|=
literal|0x40
expr_stmt|;
break|break;
case|case
name|IRQ12
case|:
name|n
operator|=
literal|0x80
expr_stmt|;
break|break;
default|default:
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|dev
operator|->
name|id_irq
argument_list|,
literal|"3/5/6/12"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|priv_info
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_RE1000_IRQCONF
index|]
argument_list|)
operator|&
literal|0x0f
operator||
name|n
expr_stmt|;
comment|/* Setup hooks.  We need a special initialization procedure.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_re1000
expr_stmt|;
comment|/* The I/O address range is fragmented in the RE1000. 	   It occupies 2*16 I/O addresses, by the way.  */
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/* JLI sub-probe for Allied-Telesis RE1000Plus/ME1500 series.  */
end_comment

begin_function
specifier|static
name|u_short
specifier|const
modifier|*
name|fe_probe_jli_re1000p
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
specifier|const
modifier|*
name|eeprom
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmaps_re1000p
index|[
literal|4
index|]
init|=
block|{
name|IRQ3
block|,
name|IRQ5
block|,
name|IRQ6
block|,
name|IRQ12
block|}
decl_stmt|;
comment|/* Make sure the EEPROM contains Allied-Telesis bit pattern.  */
if|if
condition|(
name|eeprom
index|[
literal|1
index|]
operator|!=
literal|0xFF
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0xFF
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|14
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0xFF
condition|)
return|return
name|NULL
return|;
comment|/* Get our station address from EEPROM, and make sure the            EEPROM contains Allied-Telesis's address.  */
name|bcopy
argument_list|(
name|eeprom
operator|+
literal|8
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x0000F4
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* I don't know any sub-model identification.  */
name|sc
operator|->
name|typestr
operator|=
literal|"RE1000Plus/ME1500"
expr_stmt|;
comment|/* Returns the IRQ table for the RE1000Plus.  */
return|return
name|irqmaps_re1000p
return|;
block|}
end_function

begin_comment
comment|/*  * Probe for Allied-Telesis RE1000Plus/ME1500 series.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_jli
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|u_char
name|eeprom
index|[
name|JLI_EEPROM_SIZE
index|]
decl_stmt|;
name|u_short
specifier|const
modifier|*
name|irqmap
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|baseaddr
index|[
literal|8
index|]
init|=
block|{
literal|0x1D6
block|,
literal|0x1D8
block|,
literal|0x1DA
block|,
literal|0x1D4
block|,
literal|0x0D4
block|,
literal|0x0D2
block|,
literal|0x0D8
block|,
literal|0x0D0
block|}
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_table
index|[]
init|=
block|{
comment|/*	{ FE_DLCR1,  0x20, 0x00 },	Doesn't work. */
block|{
name|FE_DLCR2
block|,
literal|0x50
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
comment|/*	{ FE_DLCR5,  0x80, 0x00 },	Doesn't work. */
if|#
directive|if
literal|0
block|{ FE_BMPR16, 0x1B, 0x00 }, 		{ FE_BMPR17, 0x7F, 0x00 },
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* 	 * See if the specified address is possible for MB86965A JLI mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|baseaddr
index|[
name|i
index|]
operator|==
name|sc
operator|->
name|iobase
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|8
condition|)
return|return
literal|0
return|;
comment|/* Fill the softc struct with reasonable default.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Re-map ioaddr for RE1000Plus.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
name|ioaddr_re1000
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * We should test if MB86965A is on the base address now. 	 * Unfortunately, it is very hard to probe it reliably, since 	 * we have no way to reset the chip under software control. 	 * On cold boot, we could check the "signature" bit patterns 	 * described in the Fujitsu document.  On warm boot, however, 	 * we can predict almost nothing about register values. 	 */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check if our I/O address matches config info on 86965.  */
name|n
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR19
index|]
argument_list|)
operator|&
name|FE_B19_ADDR
operator|)
operator|>>
name|FE_B19_ADDR_SHIFT
expr_stmt|;
if|if
condition|(
name|baseaddr
index|[
name|n
index|]
operator|!=
name|sc
operator|->
name|iobase
condition|)
return|return
literal|0
return|;
comment|/* 	 * We are now almost sure we have an MB86965 at the given 	 * address.  So, read EEPROM through it.  We have to write 	 * into LSI registers to read from EEPROM.  I want to avoid it 	 * at this stage, but I cannot test the presence of the chip 	 * any further without reading EEPROM.  FIXME. 	 */
name|fe_read_eeprom_jli
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure that config info in EEPROM and 86965 agree.  */
if|if
condition|(
name|eeprom
index|[
name|FE_EEPROM_CONF
index|]
operator|!=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR19
index|]
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* Use 86965 media selection scheme, unless othewise            specified.  It is "AUTO always" and "select with BMPR13".            This behaviour covers most of the 86965 based board (as            minimum requirements.)  It is backward compatible with            previous versions, also.  */
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HA
expr_stmt|;
name|sc
operator|->
name|msel
operator|=
name|fe_msel_965
expr_stmt|;
comment|/* Perform board-specific probe.  */
if|if
condition|(
operator|(
name|irqmap
operator|=
name|fe_probe_jli_re1000p
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Find the IRQ read from EEPROM.  */
name|n
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR19
index|]
argument_list|)
operator|&
name|FE_B19_IRQ
operator|)
operator|>>
name|FE_B19_IRQ_SHIFT
expr_stmt|;
name|irq
operator|=
name|irqmap
index|[
name|n
index|]
expr_stmt|;
comment|/* Try to determine IRQ setting.  */
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
operator|&&
name|irq
operator|==
name|NO_IRQ
condition|)
block|{
comment|/* The device must be configured with an explicit IRQ.  */
name|printf
argument_list|(
literal|"fe%d: IRQ auto-detection does not work\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
operator|&&
name|irq
operator|!=
name|NO_IRQ
condition|)
block|{
comment|/* Just use the probed IRQ value.  */
name|dev
operator|->
name|id_irq
operator|=
name|irq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|!=
name|NO_IRQ
operator|&&
name|irq
operator|==
name|NO_IRQ
condition|)
block|{
comment|/* No problem.  Go ahead.  */
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|irq
condition|)
block|{
comment|/* Good.  Go ahead.  */
block|}
else|else
block|{
comment|/* User must be warned in this case.  */
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_IRQ
expr_stmt|;
block|}
comment|/* Setup a hook, which resets te 86965 when the driver is being            initialized.  This may solve a nasty bug.  FIXME.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_jli
expr_stmt|;
comment|/* The I/O address range is fragmented in the RE1000Plus. 	   It occupies 2*16 I/O addresses, by the way.  */
return|return
literal|2
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and initialization for Contec C-NET(9N)E series.  */
end_comment

begin_comment
comment|/* TODO: Should be in "if_fereg.h" */
end_comment

begin_define
define|#
directive|define
name|FE_CNET9NE_INTR
value|0x10
end_define

begin_comment
comment|/* Interrupt Mask? */
end_comment

begin_function
specifier|static
name|void
name|fe_init_cnet9ne
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Enable interrupt?  FIXME.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_CNET9NE_INTR
index|]
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fe_probe_cnet9ne
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|u_short
name|ioaddr
index|[
name|MAXREGISTERS
operator|-
literal|16
index|]
init|=
block|{
comment|/*	0x000, 0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x007,	*/
comment|/*	0x008, 0x009, 0x00a, 0x00b, 0x00c, 0x00d, 0x00e, 0x00f,	*/
literal|0x400
block|,
literal|0x402
block|,
literal|0x404
block|,
literal|0x406
block|,
literal|0x408
block|,
literal|0x40a
block|,
literal|0x40c
block|,
literal|0x40e
block|,
literal|0x401
block|,
literal|0x403
block|,
literal|0x405
block|,
literal|0x407
block|,
literal|0x409
block|,
literal|0x40b
block|,
literal|0x40d
block|,
literal|0x40f
block|, 	}
decl_stmt|;
comment|/* See if the specified I/O address is possible for C-NET(9N)E.  */
if|if
condition|(
name|sc
operator|->
name|iobase
operator|!=
literal|0x73D0
condition|)
return|return
literal|0
return|;
comment|/* Setup an I/O address mapping table and some others.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Re-map ioaddr for C-NET(9N)E.  */
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
name|ioaddr
index|[
name|i
operator|-
literal|16
index|]
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Get our station address from EEPROM.  */
name|inblk
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Make sure it is Contec's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x00804C
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Setup the board type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"C-NET(9N)E"
expr_stmt|;
comment|/* C-NET(9N)E seems to work only IRQ5.  FIXME.  */
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|!=
name|IRQ5
condition|)
block|{
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|dev
operator|->
name|id_irq
argument_list|,
literal|"5"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We need an init hook to initialize ASIC before we start.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_cnet9ne
expr_stmt|;
comment|/* C-NET(9N)E has 64KB SRAM.  */
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_64KB
operator||
name|FE_D6_TXBSIZ_2x4KB
operator||
name|FE_D6_BBW_WORD
operator||
name|FE_D6_SBW_WORD
operator||
name|FE_D6_SRAM
expr_stmt|;
comment|/* The I/O address range is fragmented in the C-NET(9N)E. 	   This is the number of regs at iobase.  */
return|return
literal|16
return|;
block|}
end_function

begin_comment
comment|/*  * Probe for Contec C-NET(98)P2 series.  * (Logitec LAN-98TP/LAN-98T25P - parhaps)  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_ssi
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|eeprom
index|[
name|SSI_EEPROM_SIZE
index|]
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap
index|[]
init|=
block|{
comment|/*                      INT0            INT1    INT2        */
name|NO_IRQ
block|,
name|NO_IRQ
block|,
name|NO_IRQ
block|,
name|IRQ3
block|,
name|NO_IRQ
block|,
name|IRQ5
block|,
name|IRQ6
block|,
name|NO_IRQ
block|,
name|NO_IRQ
block|,
name|IRQ9
block|,
name|IRQ10
block|,
name|NO_IRQ
block|,
name|IRQ12
block|,
name|IRQ13
block|,
name|NO_IRQ
block|,
name|NO_IRQ
block|,
comment|/*      INT3    INT41           INT5    INT6                */
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for 78Q8377A.  */
comment|/* [0-D]3D0 are allowed.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|iobase
operator|&
literal|0xFFF
operator|)
operator|!=
literal|0x3D0
condition|)
return|return
literal|0
return|;
comment|/* XXX */
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We now have to read the config EEPROM.  We should be very            careful, since doing so destroys a register.  (Remember, we            are not yet sure we have a C-NET(98)P2 board here.)  Don't            remember to select BMPRs bofore reading EEPROM, since other            register bank may be selected before the probe() is called.  */
name|fe_read_eeprom_ssi
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure the Ethernet (MAC) station address is of Contec's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|eeprom
operator|+
name|FE_SSI_EEP_ADDR
argument_list|,
literal|0x00804C
argument_list|)
condition|)
return|return
literal|0
return|;
name|bcopy
argument_list|(
name|eeprom
operator|+
name|FE_SSI_EEP_ADDR
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Setup the board type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"C-NET(98)P2"
expr_stmt|;
comment|/* Get IRQ configuration from EEPROM.  */
name|dev
operator|->
name|id_irq
operator|=
name|irqmap
index|[
name|eeprom
index|[
name|FE_SSI_EEP_IRQ
index|]
index|]
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
condition|)
block|{
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|dev
operator|->
name|id_irq
argument_list|,
literal|"3/5/6/9/10/12/13"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Get Duplex-mode configuration from EEPROM.  */
name|sc
operator|->
name|proto_dlcr4
operator||=
operator|(
name|eeprom
index|[
name|FE_SSI_EEP_DUPLEX
index|]
operator|&
name|FE_D4_DSC
operator|)
expr_stmt|;
comment|/* Fill softc struct accordingly.  */
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HT
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HT
expr_stmt|;
comment|/* We have 16 registers.  */
return|return
literal|16
return|;
block|}
end_function

begin_comment
comment|/*  * Probe for TDK LAC-98012/013/025/9N011 - parhaps.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_lnx
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|FE_8BIT_SUPPORT
name|printf
argument_list|(
literal|"fe%d: skip LAC-98012/013(only 16-bit cards are supported)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
name|int
name|i
decl_stmt|;
name|u_char
name|eeprom
index|[
name|LNX_EEPROM_SIZE
index|]
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for TDK/LANX boards.  */
comment|/* 0D0, 4D0, 8D0, and CD0 are allowed.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|iobase
operator|&
operator|~
literal|0xC00
operator|)
operator|!=
literal|0xD0
condition|)
return|return
literal|0
return|;
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Re-map ioaddr for LAC-98. 	 *	0x000, 0x002, 0x004, 0x006, 0x008, 0x00a, 0x00c, 0x00e, 	 *	0x100, 0x102, 0x104, 0x106, 0x108, 0x10a, 0x10c, 0x10e, 	 *	0x200, 0x202, 0x204, 0x206, 0x208, 0x20a, 0x20c, 0x20e, 	 *	0x300, 0x302, 0x304, 0x306, 0x308, 0x30a, 0x30c, 0x30e, 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
operator|(
operator|(
name|i
operator|&
literal|7
operator|)
operator|<<
literal|1
operator|)
operator|+
operator|(
operator|(
name|i
operator|&
literal|0x18
operator|)
operator|<<
literal|5
operator|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We now have to read the config EEPROM.  We should be very            careful, since doing so destroys a register.  (Remember, we            are not yet sure we have a LAC-98012/98013 board here.)  */
name|fe_read_eeprom_lnx
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure the Ethernet (MAC) station address is of TDK/LANX's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|eeprom
argument_list|,
literal|0x008098
argument_list|)
condition|)
return|return
literal|0
return|;
name|bcopy
argument_list|(
name|eeprom
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Setup the board type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"LAC-98012/98013"
expr_stmt|;
comment|/* This looks like a TDK/LANX board.  It requires an 	   explicit IRQ setting in config.  Make sure we have one, 	   determining an appropriate value for the IRQ control 	   register.  */
switch|switch
condition|(
name|dev
operator|->
name|id_irq
condition|)
block|{
case|case
name|IRQ3
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x10
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
case|case
name|IRQ5
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x20
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
case|case
name|IRQ6
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x40
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
case|case
name|IRQ12
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x80
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
default|default:
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|dev
operator|->
name|id_irq
argument_list|,
literal|"3/5/6/12"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* LAC-98's system bus width is 8-bit.  */
name|sc
operator|->
name|proto_dlcr6
operator|=
name|FE_D6_BUFSIZ_32KB
operator||
name|FE_D6_TXBSIZ_2x2KB
operator||
name|FE_D6_BBW_BYTE
operator||
name|FE_D6_SBW_BYTE
operator||
name|FE_D6_SRAM_150ns
expr_stmt|;
comment|/* Setup hooks.  We need a special initialization procedure.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_lnx
expr_stmt|;
comment|/* The I/O address range is fragmented in the LAC-98. 	   It occupies 16*4 I/O addresses, by the way.  */
return|return
literal|16
return|;
endif|#
directive|endif
comment|/* FE_8BIT_SUPPORT */
block|}
end_function

begin_comment
comment|/*  * Probe for Gateway Communications' old cards.  * (both as Generic MB86960 probe routine)  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_gwy
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
comment|/*	{ FE_DLCR2, 0x70, 0x00 }, */
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* I'm not sure which address is possible, so accepts any.  FIXME.  */
comment|/* Setup an I/O address mapping table and some others.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Does we need to re-map ioaddr?  FIXME.  */
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Get our station address from EEPROM. */
name|inblk
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x000000
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Determine the card type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"Generic MB86960 Ethernet"
expr_stmt|;
if|if
condition|(
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x000061
argument_list|)
condition|)
name|sc
operator|->
name|typestr
operator|=
literal|"Gateway Ethernet (Fujitsu chipset)"
expr_stmt|;
comment|/* Gateway's board requires an explicit IRQ to work, since it 	   is not possible to probe the setting of jumpers.  */
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
condition|)
block|{
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|NO_IRQ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* We should change return value when re-mapping ioaddr.  FIXME. */
return|return
literal|32
return|;
block|}
end_function

begin_comment
comment|/*  * Probe for Ungermann-Bass Access/PC N98C+(Model 85152).  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_ubn
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|sum
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for Access/PC.  */
comment|/* [01][048C]D0 are allowed.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|iobase
operator|&
operator|~
literal|0x1C00
operator|)
operator|!=
literal|0xD0
condition|)
return|return
literal|0
return|;
comment|/* Setup an I/O address mapping table and some others.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Re-map ioaddr for Access/PC N98C+. 	 *	0x000, 0x001, 0x002, 0x003, 0x004, 0x005, 0x006, 0x007, 	 *	0x008, 0x009, 0x00a, 0x00b, 0x00c, 0x00d, 0x00e, 0x00f, 	 *	0x200, 0x201, 0x202, 0x203, 0x204, 0x205, 0x206, 0x207, 	 *	0x208, 0x209, 0x20a, 0x20b, 0x20c, 0x20d, 0x20e, 0x20f, 	 */
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
name|MAXREGISTERS
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|ioaddr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|iobase
operator|+
literal|0x200
operator|-
literal|16
operator|+
name|i
expr_stmt|;
comment|/* Simple probe.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Get our station address form ID ROM and make sure it is UBN's.  */
name|inblk
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x00DD01
argument_list|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
literal|1
comment|/* Calculate checksum.  */
name|sum
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1e
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|sum
operator|^=
name|sc
operator|->
name|sc_enaddr
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|sum
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* Setup the board type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"Access/PC"
expr_stmt|;
comment|/* This looks like an AccessPC/N98C+ board.  It requires an 	   explicit IRQ setting in config.  Make sure we have one, 	   determining an appropriate value for the IRQ control 	   register.  */
switch|switch
condition|(
name|dev
operator|->
name|id_irq
condition|)
block|{
case|case
name|IRQ3
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x01
expr_stmt|;
break|break;
case|case
name|IRQ5
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x02
expr_stmt|;
break|break;
case|case
name|IRQ6
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x04
expr_stmt|;
break|break;
case|case
name|IRQ12
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x08
expr_stmt|;
break|break;
default|default:
name|fe_irq_failure
argument_list|(
name|sc
operator|->
name|typestr
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|dev
operator|->
name|id_irq
argument_list|,
literal|"3/5/6/12"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Setup hooks.  We need a special initialization procedure.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_ubn
expr_stmt|;
comment|/* The I/O address range is fragmented in the Access/PC N98C+. 	   This is the number of regs at iobase.  */
return|return
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !PC98 */
end_comment

begin_comment
comment|/*  * Probe and initialization for Fujitsu FMV-180 series boards  */
end_comment

begin_function
specifier|static
name|void
name|fe_init_fmv
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Initialize ASIC.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV10
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* "Refresh" hardware configuration.  FIXME.  */
block|outb( sc->ioaddr[ FE_FMV2 ], inb( sc->ioaddr[ FE_FMV2 ] ) );
endif|#
directive|endif
comment|/* Turn the "master interrupt control" flag of ASIC on.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV3
index|]
argument_list|,
name|FE_FMV3_IRQENB
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fe_msel_fmv184
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|port
decl_stmt|;
comment|/* FMV-184 has a special "register" to switch between AUI/BNC. 	   Determine the value to write into the register, based on the 	   user-specified media selection.  */
name|port
operator|=
operator|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|media
operator|.
name|ifm_media
argument_list|)
operator|==
name|IFM_10_2
operator|)
condition|?
literal|0x00
else|:
literal|0x01
expr_stmt|;
comment|/* The register is #5 on exntesion register bank... 	   (Details of the register layout is not yet discovered.)  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1B
index|]
argument_list|,
literal|0x46
argument_list|)
expr_stmt|;
comment|/* ??? */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1E
index|]
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* select ex-reg #4.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1F
index|]
argument_list|,
literal|0xC8
argument_list|)
expr_stmt|;
comment|/* ??? */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1E
index|]
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* select ex-reg #5.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1F
index|]
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/* Switch the media.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1E
index|]
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* select ex-reg #4.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1F
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* ??? */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
literal|0x1B
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* ??? */
comment|/* Make sure to select "external tranceiver" on MB86964.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR13
index|]
argument_list|,
name|sc
operator|->
name|proto_bmpr13
operator||
name|FE_B13_PORT_AUI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fe_probe_fmv
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap
index|[
literal|4
index|]
init|=
block|{
name|IRQ3
block|,
name|IRQ7
block|,
name|IRQ10
block|,
name|IRQ15
block|}
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x71
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
name|FE_FMV0
block|,
literal|0x78
block|,
literal|0x50
block|}
block|,
comment|/* ERRDY+PRRDY */
block|{
name|FE_FMV1
block|,
literal|0xB0
block|,
literal|0x00
block|}
block|,
comment|/* FMV-183/4 has 0x48 bits. */
block|{
name|FE_FMV3
block|,
literal|0x7F
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* Board subtypes; it lists known FMV-180 variants.  */
struct|struct
name|subtype
block|{
name|u_short
name|mcode
decl_stmt|;
name|u_short
name|mbitmap
decl_stmt|;
name|u_short
name|defmedia
decl_stmt|;
name|char
specifier|const
modifier|*
name|str
decl_stmt|;
block|}
struct|;
specifier|static
name|struct
name|subtype
specifier|const
name|typelist
index|[]
init|=
block|{
block|{
literal|0x0005
block|,
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H5
block|,
name|MB_HA
block|,
literal|"FMV-181"
block|}
block|,
block|{
literal|0x0105
block|,
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H5
block|,
name|MB_HA
block|,
literal|"FMV-181A"
block|}
block|,
block|{
literal|0x0003
block|,
name|MB_HM
block|,
name|MB_HM
block|,
literal|"FMV-182"
block|}
block|,
block|{
literal|0x0103
block|,
name|MB_HM
block|,
name|MB_HM
block|,
literal|"FMV-182A"
block|}
block|,
block|{
literal|0x0804
block|,
name|MB_HT
block|,
name|MB_HT
block|,
literal|"FMV-183"
block|}
block|,
block|{
literal|0x0C04
block|,
name|MB_HT
block|,
name|MB_HT
block|,
literal|"FMV-183 (on-board)"
block|}
block|,
block|{
literal|0x0803
block|,
name|MB_H2
operator||
name|MB_H5
block|,
name|MB_H2
block|,
literal|"FMV-184"
block|}
block|,
block|{
literal|0
block|,
name|MB_HA
block|,
name|MB_HA
block|,
literal|"unknown FMV-180 (?)"
block|}
block|, 	}
decl_stmt|;
name|struct
name|subtype
specifier|const
modifier|*
name|type
decl_stmt|;
comment|/* Media indicator and "Hardware revision ID"  */
name|u_short
name|mcode
decl_stmt|;
comment|/* See if the specified address is possible for FMV-180            series.  220, 240, 260, 280, 2A0, 2C0, 300, and 340 are            allowed for all boards, and 200, 2E0, 320, 360, 380, 3A0,            3C0, and 3E0 for PnP boards.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|iobase
operator|&
operator|~
literal|0x1E0
operator|)
operator|!=
literal|0x200
condition|)
return|return
literal|0
return|;
comment|/* Setup an I/O address mapping table and some others.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Simple probe.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Get our station address from EEPROM, and make sure it is            Fujitsu's.  */
name|inblk
argument_list|(
name|sc
argument_list|,
name|FE_FMV4
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x00000E
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Find the supported media and "hardware revision" to know            the model identification.  */
name|mcode
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV0
index|]
argument_list|)
operator|&
name|FE_FMV0_MEDIA
operator|)
operator||
operator|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV1
index|]
argument_list|)
operator|&
name|FE_FMV1_REV
operator|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Determine the card type.  */
for|for
control|(
name|type
operator|=
name|typelist
init|;
name|type
operator|->
name|mcode
operator|!=
literal|0
condition|;
name|type
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|->
name|mcode
operator|==
name|mcode
condition|)
break|break;
block|}
if|if
condition|(
name|type
operator|->
name|mcode
operator|==
literal|0
condition|)
block|{
comment|/* Unknown card type...  Hope the driver works.  */
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_TYPE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: unknown config: %x-%x-%x-%x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV0
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV1
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV2
index|]
argument_list|)
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV3
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Setup the board type and media information.  */
name|sc
operator|->
name|typestr
operator|=
name|type
operator|->
name|str
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|type
operator|->
name|mbitmap
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|type
operator|->
name|defmedia
expr_stmt|;
name|sc
operator|->
name|msel
operator|=
name|fe_msel_965
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|mbitmap
operator|==
operator|(
name|MB_H2
operator||
name|MB_H5
operator|)
condition|)
block|{
comment|/* FMV184 requires a special media selection procedure.  */
name|sc
operator|->
name|msel
operator|=
name|fe_msel_fmv184
expr_stmt|;
block|}
comment|/* 	 * An FMV-180 has been probed. 	 * Determine which IRQ to be used. 	 * 	 * In this version, we give a priority to the kernel config file. 	 * If the EEPROM and config don't match, say it to the user for 	 * an attention. 	 */
name|n
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_FMV2
index|]
argument_list|)
operator|&
name|FE_FMV2_IRS
operator|)
operator|>>
name|FE_FMV2_IRS_SHIFT
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
condition|)
block|{
comment|/* Just use the probed value.  */
name|dev
operator|->
name|id_irq
operator|=
name|irqmap
index|[
name|n
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|!=
name|irqmap
index|[
name|n
index|]
condition|)
block|{
comment|/* Don't match.  */
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_IRQ
expr_stmt|;
block|}
comment|/* We need an init hook to initialize ASIC before we start.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_fmv
expr_stmt|;
comment|/* 	 * That's all.  FMV-180 occupies 32 I/O addresses, by the way. 	 */
return|return
literal|32
return|;
block|}
end_function

begin_comment
comment|/*  * Fujitsu MB86965 JLI mode probe routines.  *  * 86965 has a special operating mode called JLI (mode 0), under which  * the chip interfaces with ISA bus with a software-programmable  * configuration.  (The Fujitsu document calls the feature "Plug and  * play," but it is not compatible with the ISA-PnP spec. designed by  * Intel and Microsoft.)  Ethernet cards designed to use JLI are  * almost same, but there are two things which require board-specific  * probe routines: EEPROM layout and IRQ pin connection.  *  * JLI provides a handy way to access EEPROM which should contains the  * chip configuration information (such as I/O port address) as well  * as Ethernet station (MAC) address.  The chip configuration info. is  * stored on a fixed location.  However, the station address can be  * located anywhere in the EEPROM; it is up to the board designer to  * determine the location.  (The manual just says "somewhere in the  * EEPROM.")  The fe driver must somehow find out the correct  * location.  *  * Another problem resides in the IRQ pin connection.  JLI provides a  * user to choose an IRQ from up to four predefined IRQs.  The 86965  * chip has a register to select one out of the four possibilities.  * However, the selection is against the four IRQ pins on the chip.  * (So-called IRQ-A, -B, -C and -D.)  It is (again) up to the board  * designer to determine which pin to connect which IRQ line on the  * ISA bus.  We need a vendor (or model, for some vendor) specific IRQ  * mapping table.  *   * The routine fe_probe_jli() provides all probe and initialization  * processes which are common to all JLI implementation, and sub-probe  * routines supply board-specific actions.  *  * JLI sub-probe routine has the following template:  *  *	u_short const * func (struct fe_softc * sc, u_char const * eeprom);  *  * where eeprom is a pointer to an array of 32 byte data read from the  * config EEPROM on the board.  It retuns an IRQ mapping table for the  * board, when the corresponding implementation is detected.  It  * returns a NULL otherwise.  *   * Primary purpose of the functin is to analize the config EEPROM,  * determine if it matches with the pattern of that of supported card,  * and extract necessary information from it.  One of the information  * expected to be extracted from EEPROM is the Ethernet station (MAC)  * address, which must be set to the softc table of the interface by  * the board-specific routine.  */
end_comment

begin_comment
comment|/* JLI sub-probe for Allied-Telesyn/Allied-Telesis AT1700/RE2000 series.  */
end_comment

begin_function
specifier|static
name|u_short
specifier|const
modifier|*
name|fe_probe_jli_ati
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
specifier|const
modifier|*
name|eeprom
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmaps_ati
index|[
literal|4
index|]
index|[
literal|4
index|]
init|=
block|{
block|{
name|IRQ3
block|,
name|IRQ4
block|,
name|IRQ5
block|,
name|IRQ9
block|}
block|,
block|{
name|IRQ10
block|,
name|IRQ11
block|,
name|IRQ12
block|,
name|IRQ15
block|}
block|,
block|{
name|IRQ3
block|,
name|IRQ11
block|,
name|IRQ5
block|,
name|IRQ15
block|}
block|,
block|{
name|IRQ10
block|,
name|IRQ11
block|,
name|IRQ14
block|,
name|IRQ15
block|}
block|, 	}
decl_stmt|;
comment|/* Make sure the EEPROM contains Allied-Telesis/Allied-Telesyn 	   bit pattern.  */
if|if
condition|(
name|eeprom
index|[
literal|1
index|]
operator|!=
literal|0x00
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0xFF
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|14
init|;
name|i
operator|<
literal|24
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0xFF
condition|)
return|return
name|NULL
return|;
comment|/* Get our station address from EEPROM, and make sure the            EEPROM contains ATI's address.  */
name|bcopy
argument_list|(
name|eeprom
operator|+
literal|8
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x0000F4
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * The following model identification codes are stolen 	 * from the NetBSD port of the fe driver.  My reviewers 	 * suggested minor revision. 	 */
comment|/* Determine the card type.  */
switch|switch
condition|(
name|eeprom
index|[
name|FE_ATI_EEP_MODEL
index|]
condition|)
block|{
case|case
name|FE_ATI_MODEL_AT1700T
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"AT-1700T/RE2001"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HT
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HT
expr_stmt|;
break|break;
case|case
name|FE_ATI_MODEL_AT1700BT
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"AT-1700BT/RE2003"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H2
expr_stmt|;
break|break;
case|case
name|FE_ATI_MODEL_AT1700FT
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"AT-1700FT/RE2009"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_HF
expr_stmt|;
break|break;
case|case
name|FE_ATI_MODEL_AT1700AT
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"AT-1700AT/RE2005"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H5
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|typestr
operator|=
literal|"unknown AT-1700/RE2000"
expr_stmt|;
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_TYPE
operator||
name|UNSTABLE_IRQ
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
comment|/* Should we extract default media from eeprom?  Linux driver 	   for AT1700 does it, although previous releases of FreeBSD 	   don't.  FIXME.  */
comment|/* Determine the default media selection from the config            EEPROM.  The byte at offset EEP_MEDIA is believed to            contain BMPR13 value to be set.  We just ignore STP bit or            squelch bit, since we don't support those.  (It is            intentional.)  */
block|switch (eeprom[FE_ATI_EEP_MEDIA]& FE_B13_PORT) { 	    case FE_B13_AUTO: 		sc->defmedia = MB_HA; 		break; 	    case FE_B13_TP: 		sc->defmedia = MB_HT; 		break; 	    case FE_B13_AUI: 		sc->defmedia = sc->mbitmap& (MB_H2|MB_H5|MB_H5);
comment|/*XXX*/
block|break; 	    default:	     		sc->defmedia = MB_HA; 		break; 	}
comment|/* Make sure the default media is compatible with the supported 	   ones.  */
block|if ((sc->defmedia& sc->mbitmap) == 0) { 		if (sc->defmedia == MB_HA) { 			sc->defmedia = MB_HT; 		} else { 			sc->defmedia = MB_HA; 		} 	}
endif|#
directive|endif
comment|/* 	 * Try to determine IRQ settings. 	 * Different models use different ranges of IRQs. 	 */
switch|switch
condition|(
operator|(
name|eeprom
index|[
name|FE_ATI_EEP_REVISION
index|]
operator|&
literal|0xf0
operator|)
operator||
operator|(
name|eeprom
index|[
name|FE_ATI_EEP_MAGIC
index|]
operator|&
literal|0x04
operator|)
condition|)
block|{
case|case
literal|0x30
case|:
case|case
literal|0x34
case|:
return|return
name|irqmaps_ati
index|[
literal|3
index|]
return|;
case|case
literal|0x10
case|:
case|case
literal|0x14
case|:
case|case
literal|0x50
case|:
case|case
literal|0x54
case|:
return|return
name|irqmaps_ati
index|[
literal|2
index|]
return|;
case|case
literal|0x44
case|:
case|case
literal|0x64
case|:
return|return
name|irqmaps_ati
index|[
literal|1
index|]
return|;
default|default:
return|return
name|irqmaps_ati
index|[
literal|0
index|]
return|;
block|}
block|}
end_function

begin_comment
comment|/* JLI sub-probe and msel hook for ICL Ethernet.  */
end_comment

begin_function
specifier|static
name|void
name|fe_msel_icl
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|d4
decl_stmt|;
comment|/* Switch between UTP and "external tranceiver" as always.  */
name|fe_msel_965
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* The board needs one more bit (on DLCR4) be set appropriately.  */
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|sc
operator|->
name|media
operator|.
name|ifm_media
argument_list|)
operator|==
name|IFM_10_5
condition|)
block|{
name|d4
operator|=
name|sc
operator|->
name|proto_dlcr4
operator||
name|FE_D4_CNTRL
expr_stmt|;
block|}
else|else
block|{
name|d4
operator|=
name|sc
operator|->
name|proto_dlcr4
operator|&
operator|~
name|FE_D4_CNTRL
expr_stmt|;
block|}
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR4
index|]
argument_list|,
name|d4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_short
specifier|const
modifier|*
name|fe_probe_jli_icl
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
specifier|const
modifier|*
name|eeprom
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_short
name|defmedia
decl_stmt|;
name|u_char
name|d6
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap_icl
index|[
literal|4
index|]
init|=
block|{
name|IRQ9
block|,
name|IRQ10
block|,
name|IRQ5
block|,
name|IRQ15
block|}
decl_stmt|;
comment|/* Make sure the EEPROM contains ICL bit pattern.  */
for|for
control|(
name|i
operator|=
literal|24
init|;
name|i
operator|<
literal|39
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0x20
operator|&&
operator|(
name|eeprom
index|[
name|i
index|]
operator|&
literal|0xF0
operator|)
operator|!=
literal|0x30
condition|)
return|return
name|NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|112
init|;
name|i
operator|<
literal|122
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0x20
operator|&&
operator|(
name|eeprom
index|[
name|i
index|]
operator|&
literal|0xF0
operator|)
operator|!=
literal|0x30
condition|)
return|return
name|NULL
return|;
block|}
comment|/* Make sure the EEPROM contains ICL's permanent station            address.  If it isn't, probably this board is not an            ICL's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|eeprom
operator|+
literal|122
argument_list|,
literal|0x00004B
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Check if the "configured" Ethernet address in the EEPROM is 	   valid.  Use it if it is, or use the "permanent" address instead.  */
if|if
condition|(
name|valid_Ether_p
argument_list|(
name|eeprom
operator|+
literal|4
argument_list|,
literal|0x020000
argument_list|)
condition|)
block|{
comment|/* The configured address is valid.  Use it.  */
name|bcopy
argument_list|(
name|eeprom
operator|+
literal|4
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The configured address is invalid.  Use permanent.  */
name|bcopy
argument_list|(
name|eeprom
operator|+
literal|122
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
comment|/* Determine model and supported media.  */
switch|switch
condition|(
name|eeprom
index|[
literal|0x5E
index|]
condition|)
block|{
case|case
literal|0
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"EtherTeam16i/COMBO"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H5
operator||
name|MB_H2
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"EtherTeam16i/TP"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HT
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"EtherTeam16i/ErgoPro"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H5
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|sc
operator|->
name|typestr
operator|=
literal|"EtherTeam16i/DUO"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
operator||
name|MB_HT
operator||
name|MB_H2
expr_stmt|;
break|break;
default|default:
name|sc
operator|->
name|typestr
operator|=
literal|"EtherTeam16i"
expr_stmt|;
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_TYPE
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: unknown model code %02x for EtherTeam16i\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|eeprom
index|[
literal|0x5E
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* I'm not sure the following msel hook is required by all            models or COMBO only...  FIXME.  */
name|sc
operator|->
name|msel
operator|=
name|fe_msel_icl
expr_stmt|;
comment|/* Make the configured media selection the default media.  */
switch|switch
condition|(
name|eeprom
index|[
literal|0x28
index|]
condition|)
block|{
case|case
literal|0
case|:
name|defmedia
operator|=
name|MB_HA
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|defmedia
operator|=
name|MB_H5
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|defmedia
operator|=
name|MB_HT
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|defmedia
operator|=
name|MB_H2
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: unknown default media: %02x\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|eeprom
index|[
literal|0x28
index|]
argument_list|)
expr_stmt|;
block|}
name|defmedia
operator|=
name|MB_HA
expr_stmt|;
break|break;
block|}
comment|/* Make sure the default media is compatible with the 	   supported media.  */
if|if
condition|(
operator|(
name|defmedia
operator|&
name|sc
operator|->
name|mbitmap
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: default media adjusted\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
name|defmedia
operator|=
name|sc
operator|->
name|mbitmap
expr_stmt|;
block|}
comment|/* Keep the determined default media.  */
name|sc
operator|->
name|defmedia
operator|=
name|defmedia
expr_stmt|;
comment|/* ICL has "fat" models.  We have to program 86965 to properly 	   reflect the hardware.  */
name|d6
operator|=
name|sc
operator|->
name|proto_dlcr6
operator|&
operator|~
operator|(
name|FE_D6_BUFSIZ
operator||
name|FE_D6_BBW
operator|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|eeprom
index|[
literal|0x61
index|]
operator|<<
literal|8
operator|)
operator||
name|eeprom
index|[
literal|0x60
index|]
condition|)
block|{
case|case
literal|0x2008
case|:
name|d6
operator||=
name|FE_D6_BUFSIZ_32KB
operator||
name|FE_D6_BBW_BYTE
expr_stmt|;
break|break;
case|case
literal|0x4010
case|:
name|d6
operator||=
name|FE_D6_BUFSIZ_64KB
operator||
name|FE_D6_BBW_WORD
expr_stmt|;
break|break;
default|default:
comment|/* We can't support it, since we don't know which bits 		   to set in DLCR6.  */
name|printf
argument_list|(
literal|"fe%d: unknown SRAM config for ICL\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sc
operator|->
name|proto_dlcr6
operator|=
name|d6
expr_stmt|;
comment|/* Returns the IRQ table for the ICL board.  */
return|return
name|irqmap_icl
return|;
block|}
end_function

begin_comment
comment|/* JLI sub-probe for RATOC REX-5586/5587.  */
end_comment

begin_function
specifier|static
name|u_short
specifier|const
modifier|*
name|fe_probe_jli_rex
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
specifier|const
modifier|*
name|eeprom
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap_rex
index|[
literal|4
index|]
init|=
block|{
name|IRQ3
block|,
name|IRQ4
block|,
name|IRQ5
block|,
name|NO_IRQ
block|}
decl_stmt|;
comment|/* Make sure the EEPROM contains RATOC's config pattern.  */
if|if
condition|(
name|eeprom
index|[
literal|1
index|]
operator|!=
name|eeprom
index|[
literal|0
index|]
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
literal|0xFF
condition|)
return|return
name|NULL
return|;
comment|/* Get our station address from EEPROM.  Note that RATOC 	   stores it "byte-swapped" in each word.  (I don't know why.) 	   So, we just can't use bcopy().*/
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|=
name|eeprom
index|[
literal|3
index|]
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|=
name|eeprom
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|=
name|eeprom
index|[
literal|5
index|]
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|3
index|]
operator|=
name|eeprom
index|[
literal|4
index|]
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|4
index|]
operator|=
name|eeprom
index|[
literal|7
index|]
expr_stmt|;
name|sc
operator|->
name|sc_enaddr
index|[
literal|5
index|]
operator|=
name|eeprom
index|[
literal|6
index|]
expr_stmt|;
comment|/* Make sure the EEPROM contains RATOC's station address.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x00C0D0
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* I don't know any sub-model identification.  */
name|sc
operator|->
name|typestr
operator|=
literal|"REX-5586/5587"
expr_stmt|;
comment|/* Returns the IRQ for the RATOC board.  */
return|return
name|irqmap_rex
return|;
block|}
end_function

begin_comment
comment|/* JLI sub-probe for Unknown board.  */
end_comment

begin_function
specifier|static
name|u_short
specifier|const
modifier|*
name|fe_probe_jli_unk
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
specifier|const
modifier|*
name|eeprom
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|romsize
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|irqmap
index|[
literal|4
index|]
init|=
block|{
name|NO_IRQ
block|,
name|NO_IRQ
block|,
name|NO_IRQ
block|,
name|NO_IRQ
block|}
decl_stmt|;
comment|/* The generic JLI probe considered this board has an 86965 	   in JLI mode, but any other board-specific routines could 	   not find the matching implementation.  So, we "guess" the 	   location by looking for a bit pattern which looks like a 	   MAC address.  */
comment|/* Determine how large the EEPROM is.  */
for|for
control|(
name|romsize
operator|=
name|JLI_EEPROM_SIZE
operator|/
literal|2
init|;
name|romsize
operator|>
literal|16
condition|;
name|romsize
operator|>>=
literal|1
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|romsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|eeprom
index|[
name|i
index|]
operator|!=
name|eeprom
index|[
name|i
operator|+
name|romsize
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|romsize
condition|)
break|break;
block|}
name|romsize
operator|<<=
literal|1
expr_stmt|;
comment|/* Look for a bit pattern which looks like a MAC address.  */
for|for
control|(
name|n
operator|=
literal|2
init|;
name|n
operator|<=
name|romsize
operator|-
name|ETHER_ADDR_LEN
condition|;
name|n
operator|+=
literal|2
control|)
block|{
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|eeprom
operator|+
name|n
argument_list|,
literal|0x000000
argument_list|)
condition|)
continue|continue;
block|}
comment|/* If no reasonable address was found, we can't go further.  */
if|if
condition|(
name|n
operator|>
name|romsize
operator|-
name|ETHER_ADDR_LEN
condition|)
return|return
name|NULL
return|;
comment|/* Extract our (guessed) station address.  */
name|bcopy
argument_list|(
name|eeprom
operator|+
name|n
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* We are not sure what type of board it is... */
name|sc
operator|->
name|typestr
operator|=
literal|"(unknown JLI)"
expr_stmt|;
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_TYPE
operator||
name|UNSTABLE_MAC
expr_stmt|;
comment|/* Returns the totally unknown IRQ mapping table.  */
return|return
name|irqmap
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and initialization for all JLI implementations.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_jli
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|u_char
name|eeprom
index|[
name|JLI_EEPROM_SIZE
index|]
decl_stmt|;
name|u_short
specifier|const
modifier|*
name|irqmap
decl_stmt|;
specifier|static
name|u_short
specifier|const
name|baseaddr
index|[
literal|8
index|]
init|=
block|{
literal|0x260
block|,
literal|0x280
block|,
literal|0x2A0
block|,
literal|0x240
block|,
literal|0x340
block|,
literal|0x320
block|,
literal|0x380
block|,
literal|0x300
block|}
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR1
block|,
literal|0x20
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR2
block|,
literal|0x50
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR5
block|,
literal|0x80
block|,
literal|0x00
block|}
block|,
if|#
directive|if
literal|0
block|{ FE_BMPR16, 0x1B, 0x00 }, 		{ FE_BMPR17, 0x7F, 0x00 },
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* 	 * See if the specified address is possible for MB86965A JLI mode. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|baseaddr
index|[
name|i
index|]
operator|==
name|sc
operator|->
name|iobase
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|8
condition|)
return|return
literal|0
return|;
comment|/* Fill the softc struct with reasonable default.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * We should test if MB86965A is on the base address now. 	 * Unfortunately, it is very hard to probe it reliably, since 	 * we have no way to reset the chip under software control. 	 * On cold boot, we could check the "signature" bit patterns 	 * described in the Fujitsu document.  On warm boot, however, 	 * we can predict almost nothing about register values. 	 */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check if our I/O address matches config info on 86965.  */
name|n
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR19
index|]
argument_list|)
operator|&
name|FE_B19_ADDR
operator|)
operator|>>
name|FE_B19_ADDR_SHIFT
expr_stmt|;
if|if
condition|(
name|baseaddr
index|[
name|n
index|]
operator|!=
name|sc
operator|->
name|iobase
condition|)
return|return
literal|0
return|;
comment|/* 	 * We are now almost sure we have an MB86965 at the given 	 * address.  So, read EEPROM through it.  We have to write 	 * into LSI registers to read from EEPROM.  I want to avoid it 	 * at this stage, but I cannot test the presence of the chip 	 * any further without reading EEPROM.  FIXME. 	 */
name|fe_read_eeprom_jli
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure that config info in EEPROM and 86965 agree.  */
if|if
condition|(
name|eeprom
index|[
name|FE_EEPROM_CONF
index|]
operator|!=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR19
index|]
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* Use 86965 media selection scheme, unless othewise            specified.  It is "AUTO always" and "select with BMPR13."            This behaviour covers most of the 86965 based board (as            minimum requirements.)  It is backward compatible with            previous versions, also.  */
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HA
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HA
expr_stmt|;
name|sc
operator|->
name|msel
operator|=
name|fe_msel_965
expr_stmt|;
comment|/* Perform board-specific probe, one by one.  Note that the            order of probe is important and should not be changed            arbitrarily.  */
if|if
condition|(
operator|(
name|irqmap
operator|=
name|fe_probe_jli_ati
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|irqmap
operator|=
name|fe_probe_jli_rex
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|irqmap
operator|=
name|fe_probe_jli_icl
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|(
name|irqmap
operator|=
name|fe_probe_jli_unk
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Find the IRQ read from EEPROM.  */
name|n
operator|=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR19
index|]
argument_list|)
operator|&
name|FE_B19_IRQ
operator|)
operator|>>
name|FE_B19_IRQ_SHIFT
expr_stmt|;
name|irq
operator|=
name|irqmap
index|[
name|n
index|]
expr_stmt|;
comment|/* Try to determine IRQ setting.  */
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
operator|&&
name|irq
operator|==
name|NO_IRQ
condition|)
block|{
comment|/* The device must be configured with an explicit IRQ.  */
name|printf
argument_list|(
literal|"fe%d: IRQ auto-detection does not work\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
operator|&&
name|irq
operator|!=
name|NO_IRQ
condition|)
block|{
comment|/* Just use the probed IRQ value.  */
name|dev
operator|->
name|id_irq
operator|=
name|irq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|!=
name|NO_IRQ
operator|&&
name|irq
operator|==
name|NO_IRQ
condition|)
block|{
comment|/* No problem.  Go ahead.  */
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|irq
condition|)
block|{
comment|/* Good.  Go ahead.  */
block|}
else|else
block|{
comment|/* User must be warned in this case.  */
name|sc
operator|->
name|stability
operator||=
name|UNSTABLE_IRQ
expr_stmt|;
block|}
comment|/* Setup a hook, which resets te 86965 when the driver is being            initialized.  This may solve a nasty bug.  FIXME.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_jli
expr_stmt|;
comment|/* 	 * That's all.  86965 JLI occupies 32 I/O addresses, by the way. 	 */
return|return
literal|32
return|;
block|}
end_function

begin_comment
comment|/* Probe for TDK LAK-AX031, which is an SSi 78Q8377A based board.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_ssi
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|eeprom
index|[
name|SSI_EEPROM_SIZE
index|]
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for 78Q8377A.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|iobase
operator|&
operator|~
literal|0x3F0
operator|)
operator|!=
literal|0x000
condition|)
return|return
literal|0
return|;
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We now have to read the config EEPROM.  We should be very            careful, since doing so destroys a register.  (Remember, we            are not yet sure we have a LAK-AX031 board here.)  Don't            remember to select BMPRs bofore reading EEPROM, since other            register bank may be selected before the probe() is called.  */
name|fe_read_eeprom_ssi
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure the Ethernet (MAC) station address is of TDK's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|eeprom
operator|+
name|FE_SSI_EEP_ADDR
argument_list|,
literal|0x008098
argument_list|)
condition|)
return|return
literal|0
return|;
name|bcopy
argument_list|(
name|eeprom
operator|+
name|FE_SSI_EEP_ADDR
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* This looks like a TDK-AX031 board.  It requires an explicit 	   IRQ setting in config, since we currently don't know how we 	   can find the IRQ value assigned by ISA PnP manager.  */
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
condition|)
block|{
name|fe_irq_failure
argument_list|(
literal|"LAK-AX031"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|dev
operator|->
name|id_irq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Fill softc struct accordingly.  */
name|sc
operator|->
name|typestr
operator|=
literal|"LAK-AX031"
expr_stmt|;
name|sc
operator|->
name|mbitmap
operator|=
name|MB_HT
expr_stmt|;
name|sc
operator|->
name|defmedia
operator|=
name|MB_HT
expr_stmt|;
comment|/* We have 16 registers.  */
return|return
literal|16
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and initialization for TDK/LANX LAC-AX012/013 boards.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_lnx
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|u_char
name|eeprom
index|[
name|LNX_EEPROM_SIZE
index|]
decl_stmt|;
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for TDK/LANX boards.  */
comment|/* 300, 320, 340, and 360 are allowed.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|iobase
operator|&
operator|~
literal|0x060
operator|)
operator|!=
literal|0x300
condition|)
return|return
literal|0
return|;
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* We now have to read the config EEPROM.  We should be very            careful, since doing so destroys a register.  (Remember, we            are not yet sure we have a LAC-AX012/AX013 board here.)  */
name|fe_read_eeprom_lnx
argument_list|(
name|sc
argument_list|,
name|eeprom
argument_list|)
expr_stmt|;
comment|/* Make sure the Ethernet (MAC) station address is of TDK/LANX's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|eeprom
argument_list|,
literal|0x008098
argument_list|)
condition|)
return|return
literal|0
return|;
name|bcopy
argument_list|(
name|eeprom
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* This looks like a TDK/LANX board.  It requires an 	   explicit IRQ setting in config.  Make sure we have one, 	   determining an appropriate value for the IRQ control 	   register.  */
switch|switch
condition|(
name|dev
operator|->
name|id_irq
condition|)
block|{
case|case
name|IRQ3
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x40
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
case|case
name|IRQ4
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x20
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
case|case
name|IRQ5
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x10
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
case|case
name|IRQ9
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x80
operator||
name|LNX_CLK_LO
operator||
name|LNX_SDA_HI
expr_stmt|;
break|break;
default|default:
name|fe_irq_failure
argument_list|(
literal|"LAC-AX012/AX013"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|dev
operator|->
name|id_irq
argument_list|,
literal|"3/4/5/9"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Fill softc struct accordingly.  */
name|sc
operator|->
name|typestr
operator|=
literal|"LAC-AX012/AX013"
expr_stmt|;
name|sc
operator|->
name|init
operator|=
name|fe_init_lnx
expr_stmt|;
comment|/* We have 32 registers.  */
return|return
literal|32
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and initialization for Gateway Communications' old cards.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_gwy
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
comment|/*	{ FE_DLCR2, 0x70, 0x00 }, */
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for Gateway boards.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|iobase
operator|&
operator|~
literal|0x1E0
operator|)
operator|!=
literal|0x200
condition|)
return|return
literal|0
return|;
comment|/* Setup an I/O address mapping table and some others.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* See if the card is on its address.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Get our station address from EEPROM. */
name|inblk
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Make sure it is Gateway Communication's.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x000061
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Gateway's board requires an explicit IRQ to work, since it 	   is not possible to probe the setting of jumpers.  */
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
condition|)
block|{
name|fe_irq_failure
argument_list|(
literal|"Gateway Ethernet"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|NO_IRQ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Fill softc struct accordingly.  */
name|sc
operator|->
name|typestr
operator|=
literal|"Gateway Ethernet (Fujitsu chipset)"
expr_stmt|;
comment|/* That's all.  The card occupies 32 I/O addresses, as always.  */
return|return
literal|32
return|;
block|}
end_function

begin_comment
comment|/* Probe and initialization for Ungermann-Bass Network    K.K. "Access/PC" boards.  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_ubn
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
if|#
directive|if
literal|0
block|u_char sum;
endif|#
directive|endif
specifier|static
name|struct
name|fe_simple_probe_struct
specifier|const
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* See if the specified I/O address is possible for AccessPC/ISA.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|iobase
operator|&
operator|~
literal|0x0E0
operator|)
operator|!=
literal|0x300
condition|)
return|return
literal|0
return|;
comment|/* Setup an I/O address mapping table and some others.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Simple probe.  */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Get our station address form ID ROM and make sure it is UBN's.  */
name|inblk
argument_list|(
name|sc
argument_list|,
literal|0x18
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0x00DD01
argument_list|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
literal|0
comment|/* Calculate checksum.  */
block|sum = inb(sc->ioaddr[0x1e]); 	for (i = 0; i< ETHER_ADDR_LEN; i++) { 		sum ^= sc->sc_enaddr[i]; 	} 	if (sum != 0) return 0;
endif|#
directive|endif
comment|/* This looks like an AccessPC/ISA board.  It requires an 	   explicit IRQ setting in config.  Make sure we have one, 	   determining an appropriate value for the IRQ control 	   register.  */
switch|switch
condition|(
name|dev
operator|->
name|id_irq
condition|)
block|{
case|case
name|IRQ3
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x02
expr_stmt|;
break|break;
case|case
name|IRQ4
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x04
expr_stmt|;
break|break;
case|case
name|IRQ5
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x08
expr_stmt|;
break|break;
case|case
name|IRQ10
case|:
name|sc
operator|->
name|priv_info
operator|=
literal|0x10
expr_stmt|;
break|break;
default|default:
name|fe_irq_failure
argument_list|(
literal|"Access/PC"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|dev
operator|->
name|id_irq
argument_list|,
literal|"3/4/5/10"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Fill softc struct accordingly.  */
name|sc
operator|->
name|typestr
operator|=
literal|"Access/PC"
expr_stmt|;
name|sc
operator|->
name|init
operator|=
name|fe_init_ubn
expr_stmt|;
comment|/* We have 32 registers.  */
return|return
literal|32
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PC98 */
end_comment

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_comment
comment|/*  * Probe and initialization for Fujitsu MBH10302 PCMCIA Ethernet interface.  * Note that this is for 10302 only; MBH10304 is handled by fe_probe_tdk().  */
end_comment

begin_function
specifier|static
name|void
name|fe_init_mbh
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Minimal initialization of 86960.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Disable all interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable master interrupt flag.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_MBH0
index|]
argument_list|,
name|FE_MBH0_MAGIC
operator||
name|FE_MBH0_INTR_ENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fe_probe_mbh
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x58
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR6
block|,
literal|0xFF
block|,
literal|0xB6
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* We need an explicit IRQ.  */
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* Ethernet MAC address should *NOT* have been given by pccardd, 	   if this is a true MBH10302; i.e., Ethernet address must be 	   "all-zero" upon entry.  */
if|if
condition|(
name|sc
operator|->
name|sc_enaddr
index|[
literal|0
index|]
operator|||
name|sc
operator|->
name|sc_enaddr
index|[
literal|1
index|]
operator|||
name|sc
operator|->
name|sc_enaddr
index|[
literal|2
index|]
operator|||
name|sc
operator|->
name|sc_enaddr
index|[
literal|3
index|]
operator|||
name|sc
operator|->
name|sc_enaddr
index|[
literal|4
index|]
operator|||
name|sc
operator|->
name|sc_enaddr
index|[
literal|5
index|]
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* Fill the softc struct with default values.  */
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * See if MBH10302 is on its address. 	 * I'm not sure the following probe code works.  FIXME. 	 */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Get our station address from EEPROM.  */
name|inblk
argument_list|(
name|sc
argument_list|,
name|FE_MBH10
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Make sure we got a valid station address.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Determine the card type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"MBH10302 (PCMCIA)"
expr_stmt|;
comment|/* We seems to need our own IDENT bits...  FIXME.  */
name|sc
operator|->
name|proto_dlcr7
operator|=
name|FE_D7_BYTSWP_LH
operator||
name|FE_D7_IDENT_NICE
expr_stmt|;
comment|/* Setup hooks.  We need a special initialization procedure.  */
name|sc
operator|->
name|init
operator|=
name|fe_init_mbh
expr_stmt|;
comment|/* 	 * That's all.  MBH10302 occupies 32 I/O addresses, by the way. 	 */
return|return
literal|32
return|;
block|}
end_function

begin_comment
comment|/*  * Probe and initialization for TDK/CONTEC PCMCIA Ethernet interface.  * by MASUI Kenji<masui@cs.titech.ac.jp>  *  * (Contec uses TDK Ethenet chip -- hosokawa)  *  * This version of fe_probe_tdk has been rewrote to handle  * *generic* PC card implementation of Fujitsu MB8696x family.  The  * name _tdk is just for a historical reason. :-)  */
end_comment

begin_function
specifier|static
name|int
name|fe_probe_tdk
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|struct
name|fe_simple_probe_struct
name|probe_table
index|[]
init|=
block|{
block|{
name|FE_DLCR2
block|,
literal|0x50
block|,
literal|0x00
block|}
block|,
block|{
name|FE_DLCR4
block|,
literal|0x08
block|,
literal|0x00
block|}
block|,
comment|/*  { FE_DLCR5, 0x80, 0x00 },       Does not work well.  */
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_irq
operator|==
name|NO_IRQ
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fe_softc_defaults
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/*          * See if C-NET(PC)C is on its address.          */
if|if
condition|(
operator|!
name|fe_simple_probe
argument_list|(
name|sc
argument_list|,
name|probe_table
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Determine the card type.  */
name|sc
operator|->
name|typestr
operator|=
literal|"Generic MB8696x/78Q837x Ethernet (PCMCIA)"
expr_stmt|;
comment|/*          * Initialize constants in the per-line structure.          */
comment|/* Make sure we got a valid station address.  */
if|if
condition|(
operator|!
name|valid_Ether_p
argument_list|(
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/*          * That's all.  C-NET(PC)C occupies 16 I/O addresses. 	 * XXX: Are there any card with 32 I/O addresses?  FIXME.          */
return|return
literal|16
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCARD> 0 */
end_comment

begin_comment
comment|/*  * Install interface into kernel networking data structures  */
end_comment

begin_function
specifier|static
name|int
name|fe_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
if|#
directive|if
name|NCARD
operator|>
literal|0
specifier|static
name|int
name|already_ifattach
index|[
name|NFE
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|fe_softc
modifier|*
name|sc
init|=
operator|&
name|fe_softc
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|b
decl_stmt|;
name|dev
operator|->
name|id_ointr
operator|=
name|feintr
expr_stmt|;
comment|/* 	 * Initialize ifnet structure 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_name
operator|=
literal|"fe"
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_start
operator|=
name|fe_start
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ioctl
operator|=
name|fe_ioctl
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_watchdog
operator|=
name|fe_watchdog
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_init
operator|=
name|fe_init
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_linkmib
operator|=
operator|&
name|sc
operator|->
name|mibdata
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_linkmiblen
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|mibdata
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* I'm not sure... */
block|sc->mibdata.dot3Compliance = DOT3COMPLIANCE_COLLS;
endif|#
directive|endif
comment|/* 	 * Set fixed interface flags. 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
if|#
directive|if
literal|1
comment|/* 	 * Set maximum size of output queue, if it has not been set. 	 * It is done here as this driver may be started after the 	 * system initialization (i.e., the interface is PCMCIA.) 	 * 	 * I'm not sure this is really necessary, but, even if it is, 	 * it should be done somewhere else, e.g., in if_attach(), 	 * since it must be a common workaround for all network drivers. 	 * FIXME. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|FE_SINGLE_TRANSMISSION
comment|/* Override txb config to allocate minimum.  */
name|sc
operator|->
name|proto_dlcr6
operator|&=
operator|~
name|FE_D6_TXBSIZ
name|sc
operator|->
name|proto_dlcr6
operator||=
name|FE_D6_TXBSIZ_2x2KB
expr_stmt|;
endif|#
directive|endif
comment|/* Modify hardware config if it is requested.  */
if|if
condition|(
name|dev
operator|->
name|id_flags
operator|&
name|FE_FLAGS_OVERRIDE_DLCR6
condition|)
block|{
name|sc
operator|->
name|proto_dlcr6
operator|=
name|dev
operator|->
name|id_flags
operator|&
name|FE_FLAGS_DLCR6_VALUE
expr_stmt|;
block|}
comment|/* Find TX buffer size, based on the hardware dependent proto.  */
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_TXBSIZ
condition|)
block|{
case|case
name|FE_D6_TXBSIZ_2x2KB
case|:
name|sc
operator|->
name|txb_size
operator|=
literal|2048
expr_stmt|;
break|break;
case|case
name|FE_D6_TXBSIZ_2x4KB
case|:
name|sc
operator|->
name|txb_size
operator|=
literal|4096
expr_stmt|;
break|break;
case|case
name|FE_D6_TXBSIZ_2x8KB
case|:
name|sc
operator|->
name|txb_size
operator|=
literal|8192
expr_stmt|;
break|break;
default|default:
comment|/* Oops, we can't work with single buffer configuration.  */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: strange TXBSIZ config; fixing\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|proto_dlcr6
operator|&=
operator|~
name|FE_D6_TXBSIZ
expr_stmt|;
name|sc
operator|->
name|proto_dlcr6
operator||=
name|FE_D6_TXBSIZ_2x2KB
expr_stmt|;
name|sc
operator|->
name|txb_size
operator|=
literal|2048
expr_stmt|;
break|break;
block|}
comment|/* Initialize the if_media interface.  */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
literal|0
argument_list|,
name|fe_medchange
argument_list|,
name|fe_medstat
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|bit2media
index|[
name|b
index|]
operator|!=
literal|0
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|mbitmap
operator|&
operator|(
literal|1
operator|<<
name|b
operator|)
condition|)
block|{
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|bit2media
index|[
name|b
index|]
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|b
operator|=
literal|0
init|;
name|bit2media
index|[
name|b
index|]
operator|!=
literal|0
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|defmedia
operator|&
operator|(
literal|1
operator|<<
name|b
operator|)
condition|)
block|{
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|media
argument_list|,
name|bit2media
index|[
name|b
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Turned off; this is called later, when the interface UPs.  */
block|fe_medchange(sc);
endif|#
directive|endif
comment|/* Attach and stop the interface. */
if|#
directive|if
name|NCARD
operator|>
literal|0
if|if
condition|(
name|already_ifattach
index|[
name|dev
operator|->
name|id_unit
index|]
operator|!=
literal|1
condition|)
block|{
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
name|already_ifattach
index|[
name|dev
operator|->
name|id_unit
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|#
directive|else
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fe_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
comment|/* Print additional info when attached.  */
name|printf
argument_list|(
literal|"fe%d: address %6D, type %s%s\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|typestr
argument_list|,
operator|(
name|sc
operator|->
name|proto_dlcr4
operator|&
name|FE_D4_DSC
operator|)
condition|?
literal|", full duplex"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|int
name|buf
decl_stmt|,
name|txb
decl_stmt|,
name|bbw
decl_stmt|,
name|sbw
decl_stmt|,
name|ram
decl_stmt|;
name|buf
operator|=
name|txb
operator|=
name|bbw
operator|=
name|sbw
operator|=
name|ram
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_BUFSIZ
condition|)
block|{
case|case
name|FE_D6_BUFSIZ_8KB
case|:
name|buf
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FE_D6_BUFSIZ_16KB
case|:
name|buf
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|FE_D6_BUFSIZ_32KB
case|:
name|buf
operator|=
literal|32
expr_stmt|;
break|break;
case|case
name|FE_D6_BUFSIZ_64KB
case|:
name|buf
operator|=
literal|64
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_TXBSIZ
condition|)
block|{
case|case
name|FE_D6_TXBSIZ_2x2KB
case|:
name|txb
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|FE_D6_TXBSIZ_2x4KB
case|:
name|txb
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|FE_D6_TXBSIZ_2x8KB
case|:
name|txb
operator|=
literal|8
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_BBW
condition|)
block|{
case|case
name|FE_D6_BBW_BYTE
case|:
name|bbw
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FE_D6_BBW_WORD
case|:
name|bbw
operator|=
literal|16
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
condition|)
block|{
case|case
name|FE_D6_SBW_BYTE
case|:
name|sbw
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FE_D6_SBW_WORD
case|:
name|sbw
operator|=
literal|16
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SRAM
condition|)
block|{
case|case
name|FE_D6_SRAM_100ns
case|:
name|ram
operator|=
literal|100
expr_stmt|;
break|break;
case|case
name|FE_D6_SRAM_150ns
case|:
name|ram
operator|=
literal|150
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"fe%d: SRAM %dKB %dbit %dns, TXB %dKBx2, %dbit I/O\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|buf
argument_list|,
name|bbw
argument_list|,
name|ram
argument_list|,
name|txb
argument_list|,
name|sbw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|stability
operator|&
name|UNSTABLE_IRQ
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: warning: IRQ number may be incorrect\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|stability
operator|&
name|UNSTABLE_MAC
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: warning: above MAC address may be incorrect\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|stability
operator|&
name|UNSTABLE_TYPE
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: warning: hardware type was not validated\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NBPF
operator|>
literal|0
comment|/* If BPF is in the kernel, call the attach for it.  */
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Reset interface, after some (hardware) trouble is deteced.  */
end_comment

begin_function
specifier|static
name|void
name|fe_reset
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Record how many packets are lost by this accident.  */
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|+=
name|sc
operator|->
name|txb_sched
operator|+
name|sc
operator|->
name|txb_count
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacTransmitErrors
operator|++
expr_stmt|;
comment|/* Put the interface into known initial state.  */
name|fe_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
condition|)
name|fe_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop everything on the interface.  *  * All buffered packets, both transmitting and receiving,  * if any, will be lost by stopping the interface.  */
end_comment

begin_function
specifier|static
name|void
name|fe_stop
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Disable interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Stop interface hardware.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Clear all interrupt status.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* Put the chip in stand-by mode.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_POWER_DOWN
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Reset transmitter variables and interface flags.  */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_OACTIVE
operator||
name|IFF_RUNNING
operator|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_free
operator|=
name|sc
operator|->
name|txb_size
expr_stmt|;
name|sc
operator|->
name|txb_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_sched
operator|=
literal|0
expr_stmt|;
comment|/* MAR loading can be delayed.  */
name|sc
operator|->
name|filter_change
operator|=
literal|0
expr_stmt|;
comment|/* Call a device-specific hook.  */
if|if
condition|(
name|sc
operator|->
name|stop
condition|)
name|sc
operator|->
name|stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Device timeout/watchdog routine. Entered if the device neglects to  * generate an interrupt after a transmit has been started on it.  */
end_comment

begin_function
specifier|static
name|void
name|fe_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fe_softc
operator|*
operator|)
name|ifp
decl_stmt|;
comment|/* A "debug" message.  */
name|printf
argument_list|(
literal|"fe%d: transmission timeout (%d+%d)%s\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|sc
operator|->
name|txb_sched
argument_list|,
name|sc
operator|->
name|txb_count
argument_list|,
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|?
literal|""
else|:
literal|" when down"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: wrong IRQ setting in config?\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
name|fe_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize device.  */
end_comment

begin_function
specifier|static
name|void
name|fe_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* We need an address. */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_addrhead
argument_list|)
condition|)
block|{
comment|/* XXX unlikely */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"fe%d: init() without any address\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* Start initializing 86960.  */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Call a hook before we start initializing the chip.  */
if|if
condition|(
name|sc
operator|->
name|init
condition|)
name|sc
operator|->
name|init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure to disable the chip, also. 	 * This may also help re-programming the chip after 	 * hot insertion of PCMCIAs. 	 */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Power up the chip and select register bank for DLCRs.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_DLCR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Feed the station address.  */
name|outblk
argument_list|(
name|sc
argument_list|,
name|FE_DLCR8
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Clear multicast address filter to receive nothing.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_MAR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
name|outblk
argument_list|(
name|sc
argument_list|,
name|FE_MAR8
argument_list|,
name|fe_filter_nothing
operator|.
name|data
argument_list|,
name|FE_FILTER_LEN
argument_list|)
expr_stmt|;
comment|/* Select the BMPR bank for runtime register access.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_BMPR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
comment|/* Initialize registers.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* Clear all bits.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* ditto.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR4
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR10
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR11
index|]
argument_list|,
name|FE_B11_CTRL_SKIP
operator||
name|FE_B11_MODE1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR12
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR13
index|]
argument_list|,
name|sc
operator|->
name|proto_bmpr13
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR14
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR15
index|]
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Enable interrupts.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR2
index|]
argument_list|,
name|FE_TMASK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR3
index|]
argument_list|,
name|FE_RMASK
argument_list|)
expr_stmt|;
comment|/* Select requested media, just before enabling DLC.  */
if|if
condition|(
name|sc
operator|->
name|msel
condition|)
name|sc
operator|->
name|msel
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable transmitter and receiver.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_ENABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* 	 * Make sure to empty the receive buffer. 	 * 	 * This may be redundant, but *if* the receive buffer were full 	 * at this point, then the driver would hang.  I have experienced 	 * some strange hang-up just after UP.  I hope the following 	 * code solve the problem. 	 * 	 * I have changed the order of hardware initialization. 	 * I think the receive buffer cannot have any packets at this 	 * point in this version.  The following code *must* be 	 * redundant now.  FIXME. 	 * 	 * I've heard a rumore that on some PC card implementation of 	 * 8696x, the receive buffer can have some data at this point. 	 * The following message helps discovering the fact.  FIXME. 	 */
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|)
operator|&
name|FE_D5_BUFEMP
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: receive buffer has some data after reset\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|fe_emptybuffer
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* Do we need this here?  Actually, no.  I must be paranoia.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* Clear all bits.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* ditto.  */
endif|#
directive|endif
comment|/* Set 'running' flag, because we are now running.   */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
comment|/* 	 * At this point, the interface is running properly, 	 * except that it receives *no* packets.  we then call 	 * fe_setmode() to tell the chip what packets to be 	 * received, based on the if_flags and multicast group 	 * list.  It completes the initialization process. 	 */
name|fe_setmode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ...and attempt to start output queued packets.  */
comment|/* TURNED OFF, because the semi-auto media prober wants to UP            the interface keeping it idle.  The upper layer will soon            start the interface anyway, and there are no significant            delay.  */
block|fe_start(&sc->sc_if );
endif|#
directive|endif
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine actually starts the transmission on the interface  */
end_comment

begin_function
specifier|static
name|void
name|fe_xmit
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Set a timer just in case we never hear from the board again. 	 * We use longer timeout for multiple packet transmission. 	 * I'm not sure this timer value is appropriate.  FIXME. 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|1
operator|+
name|sc
operator|->
name|txb_count
expr_stmt|;
comment|/* Update txb variables.  */
name|sc
operator|->
name|txb_sched
operator|=
name|sc
operator|->
name|txb_count
expr_stmt|;
name|sc
operator|->
name|txb_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_free
operator|=
name|sc
operator|->
name|txb_size
expr_stmt|;
name|sc
operator|->
name|tx_excolls
operator|=
literal|0
expr_stmt|;
comment|/* Start transmitter, passing packets in TX buffer.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR10
index|]
argument_list|,
name|sc
operator|->
name|txb_sched
operator||
name|FE_B10_START
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  * We make two assumptions here:  *  1) that the current priority is set to splimp _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) that the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
end_comment

begin_function
name|void
name|fe_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* Just a sanity check.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|txb_count
operator|==
literal|0
operator|)
operator|!=
operator|(
name|sc
operator|->
name|txb_free
operator|==
name|sc
operator|->
name|txb_size
operator|)
condition|)
block|{
comment|/* 		 * Txb_count and txb_free co-works to manage the 		 * transmission buffer.  Txb_count keeps track of the 		 * used potion of the buffer, while txb_free does unused 		 * potion.  So, as long as the driver runs properly, 		 * txb_count is zero if and only if txb_free is same 		 * as txb_size (which represents whole buffer.) 		 */
name|printf
argument_list|(
literal|"fe%d: inconsistent txb variables (%d, %d)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|txb_count
argument_list|,
name|sc
operator|->
name|txb_free
argument_list|)
expr_stmt|;
comment|/* 		 * So, what should I do, then? 		 * 		 * We now know txb_count and txb_free contradicts.  We 		 * cannot, however, tell which is wrong.  More 		 * over, we cannot peek 86960 transmission buffer or 		 * reset the transmission buffer.  (In fact, we can 		 * reset the entire interface.  I don't want to do it.) 		 * 		 * If txb_count is incorrect, leaving it as-is will cause 		 * sending of garbage after next interrupt.  We have to 		 * avoid it.  Hence, we reset the txb_count here.  If 		 * txb_free was incorrect, resetting txb_count just loose 		 * some packets.  We can live with it. 		 */
name|sc
operator|->
name|txb_count
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * First, see if there are buffered packets and an idle 	 * transmitter - should never happen at this point. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|txb_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|txb_sched
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: transmitter idle with %d buffered packets\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|txb_count
argument_list|)
expr_stmt|;
name|fe_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Stop accepting more transmission packets temporarily, when 	 * a filter change request is delayed.  Updating the MARs on 	 * 86960 flushes the transmission buffer, so it is delayed 	 * until all buffered transmission packets have been sent 	 * out. 	 */
if|if
condition|(
name|sc
operator|->
name|filter_change
condition|)
block|{
comment|/* 		 * Filter change request is delayed only when the DLC is 		 * working.  DLC soon raise an interrupt after finishing 		 * the work. 		 */
goto|goto
name|indicate_active
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * See if there is room to put another packet in the buffer. 		 * We *could* do better job by peeking the send queue to 		 * know the length of the next packet.  Current version just 		 * tests against the worst case (i.e., longest packet).  FIXME. 		 * 		 * When adding the packet-peek feature, don't forget adding a 		 * test on txb_count against QUEUEING_MAX. 		 * There is a little chance the packet count exceeds 		 * the limit.  Assume transmission buffer is 8KB (2x8KB 		 * configuration) and an application sends a bunch of small 		 * (i.e., minimum packet sized) packets rapidly.  An 8KB 		 * buffer can hold 130 blocks of 62 bytes long... 		 */
if|if
condition|(
name|sc
operator|->
name|txb_free
operator|<
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
operator|+
name|FE_DATA_LEN_LEN
condition|)
block|{
comment|/* No room.  */
goto|goto
name|indicate_active
goto|;
block|}
if|#
directive|if
name|FE_SINGLE_TRANSMISSION
if|if
condition|(
name|sc
operator|->
name|txb_count
operator|>
literal|0
condition|)
block|{
comment|/* Just one packet per a transmission buffer.  */
goto|goto
name|indicate_active
goto|;
block|}
endif|#
directive|endif
comment|/* 		 * Get the next mbuf chain for a packet to send. 		 */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* No more packets to send.  */
goto|goto
name|indicate_inactive
goto|;
block|}
comment|/* 		 * Copy the mbuf chain into the transmission buffer. 		 * txb_* variables are updated as necessary. 		 */
name|fe_write_mbufs
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Start transmitter if it's idle.  */
if|if
condition|(
operator|(
name|sc
operator|->
name|txb_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|txb_sched
operator|==
literal|0
operator|)
condition|)
block|{
name|fe_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Tap off here if there is a bpf listener, 		 * and the device is *not* in promiscuous mode. 		 * (86960 receives self-generated packets if  		 * and only if it is in "receive everything" 		 * mode.) 		 */
if|#
directive|if
name|NBPF
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|indicate_inactive
label|:
comment|/* 	 * We are using the !OACTIVE flag to indicate to 	 * the outside world that we can accept an 	 * additional packet rather than that the 	 * transmitter is _actually_ active.  Indeed, the 	 * transmitter may be active, but if we haven't 	 * filled all the buffers with data then we still 	 * want to accept more. 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
name|indicate_active
label|:
comment|/* 	 * The transmitter is active, and there are no room for 	 * more outgoing packets in the transmission buffer. 	 */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Drop (skip) a packet from receive buffer in 86960 memory.  */
end_comment

begin_function
specifier|static
name|void
name|fe_droppacket
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * 86960 manual says that we have to read 8 bytes from the buffer 	 * before skip the packets and that there must be more than 8 bytes 	 * remaining in the buffer when issue a skip command. 	 * Remember, we have already read 4 bytes before come here. 	 */
if|if
condition|(
name|len
operator|>
literal|12
condition|)
block|{
comment|/* Read 4 more bytes, and skip the rest of the packet.  */
ifdef|#
directive|ifdef
name|FE_8BIT_SUPPORT
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|inw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR14
index|]
argument_list|,
name|FE_B14_SKIP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We should not come here unless receiving RUNTs.  */
ifdef|#
directive|ifdef
name|FE_8BIT_SUPPORT
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|2
control|)
block|{
operator|(
name|void
operator|)
name|inw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_comment
comment|/*  * Empty receiving buffer.  */
end_comment

begin_function
specifier|static
name|void
name|fe_emptybuffer
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|saved_dlcr5
decl_stmt|;
ifdef|#
directive|ifdef
name|FE_DEBUG
name|printf
argument_list|(
literal|"fe%d: emptying receive buffer\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Stop receiving packets, temporarily. 	 */
name|saved_dlcr5
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr5
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1300
argument_list|)
expr_stmt|;
comment|/* 	 * When we come here, the receive buffer management may 	 * have been broken.  So, we cannot use skip operation. 	 * Just discard everything in the buffer. 	 */
ifdef|#
directive|ifdef
name|FE_8BIT_SUPPORT
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|65536
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|)
operator|&
name|FE_D5_BUFEMP
condition|)
break|break;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|65536
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|)
operator|&
name|FE_D5_BUFEMP
condition|)
break|break;
operator|(
name|void
operator|)
name|inw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Double check. 	 */
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|)
operator|&
name|FE_D5_BUFEMP
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: could not empty receive buffer\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
comment|/* Hmm.  What should I do if this happens?  FIXME.  */
block|}
comment|/* 	 * Restart receiving packets. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|,
name|saved_dlcr5
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Transmission interrupt handler  * The control flow of this function looks silly.  FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|fe_tint
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|tstat
parameter_list|)
block|{
name|int
name|left
decl_stmt|;
name|int
name|col
decl_stmt|;
comment|/* 	 * Handle "excessive collision" interrupt. 	 */
if|if
condition|(
name|tstat
operator|&
name|FE_D0_COLL16
condition|)
block|{
comment|/* 		 * Find how many packets (including this collided one) 		 * are left unsent in transmission buffer. 		 */
name|left
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR10
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fe%d: excessive collision (%d/%d)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|left
argument_list|,
name|sc
operator|->
name|txb_sched
argument_list|)
expr_stmt|;
comment|/* 		 * Clear the collision flag (in 86960) here 		 * to avoid confusing statistics. 		 */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|,
name|FE_D0_COLLID
argument_list|)
expr_stmt|;
comment|/* 		 * Restart transmitter, skipping the 		 * collided packet. 		 * 		 * We *must* skip the packet to keep network running 		 * properly.  Excessive collision error is an 		 * indication of the network overload.  If we 		 * tried sending the same packet after excessive 		 * collision, the network would be filled with 		 * out-of-time packets.  Packets belonging 		 * to reliable transport (such as TCP) are resent 		 * by some upper layer. 		 */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR11
index|]
argument_list|,
name|FE_B11_CTRL_SKIP
operator||
name|FE_B11_MODE1
argument_list|)
expr_stmt|;
comment|/* Update statistics.  */
name|sc
operator|->
name|tx_excolls
operator|++
expr_stmt|;
block|}
comment|/* 	 * Handle "transmission complete" interrupt. 	 */
if|if
condition|(
name|tstat
operator|&
name|FE_D0_TXDONE
condition|)
block|{
comment|/* 		 * Add in total number of collisions on last 		 * transmission.  We also clear "collision occurred" flag 		 * here. 		 * 		 * 86960 has a design flaw on collision count on multiple 		 * packet transmission.  When we send two or more packets 		 * with one start command (that's what we do when the 		 * transmission queue is crowded), 86960 informs us number 		 * of collisions occurred on the last packet on the 		 * transmission only.  Number of collisions on previous 		 * packets are lost.  I have told that the fact is clearly 		 * stated in the Fujitsu document. 		 * 		 * I considered not to mind it seriously.  Collision 		 * count is not so important, anyway.  Any comments?  FIXME. 		 */
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|)
operator|&
name|FE_D0_COLLID
condition|)
block|{
comment|/* Clear collision flag.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|,
name|FE_D0_COLLID
argument_list|)
expr_stmt|;
comment|/* Extract collision count from 86960.  */
name|col
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR4
index|]
argument_list|)
expr_stmt|;
name|col
operator|=
operator|(
name|col
operator|&
name|FE_D4_COL
operator|)
operator|>>
name|FE_D4_COL_SHIFT
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Status register indicates collisions, 				 * while the collision count is zero. 				 * This can happen after multiple packet 				 * transmission, indicating that one or more 				 * previous packet(s) had been collided. 				 * 				 * Since the accurate number of collisions 				 * has been lost, we just guess it as 1; 				 * Am I too optimistic?  FIXME. 				 */
name|col
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
name|col
expr_stmt|;
if|if
condition|(
name|col
operator|==
literal|1
condition|)
block|{
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsSingleCollisionFrames
operator|++
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsMultipleCollisionFrames
operator|++
expr_stmt|;
block|}
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
name|col
operator|-
literal|1
index|]
operator|++
expr_stmt|;
block|}
comment|/* 		 * Update transmission statistics. 		 * Be sure to reflect number of excessive collisions. 		 */
name|col
operator|=
name|sc
operator|->
name|tx_excolls
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|+=
name|sc
operator|->
name|txb_sched
operator|-
name|col
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|+=
name|col
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|+=
name|col
operator|*
literal|16
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsExcessiveCollisions
operator|+=
name|col
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsCollFrequencies
index|[
literal|15
index|]
operator|+=
name|col
expr_stmt|;
name|sc
operator|->
name|txb_sched
operator|=
literal|0
expr_stmt|;
comment|/* 		 * The transmitter is no more active. 		 * Reset output active flag and watchdog timer. 		 */
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If more data is ready to transmit in the buffer, start 		 * transmitting them.  Otherwise keep transmitter idle, 		 * even if more data is queued.  This gives receive 		 * process a slight priority. 		 */
if|if
condition|(
name|sc
operator|->
name|txb_count
operator|>
literal|0
condition|)
name|fe_xmit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|fe_rint
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_char
name|rstat
parameter_list|)
block|{
name|u_short
name|len
decl_stmt|;
name|u_char
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Update statistics if this interrupt is caused by an error. 	 * Note that, when the system was not sufficiently fast, the 	 * receive interrupt might not be acknowledged immediately.  If 	 * one or more errornous frames were received before this routine 	 * was scheduled, they are ignored, and the following error stats 	 * give less than real values. 	 */
if|if
condition|(
name|rstat
operator|&
operator|(
name|FE_D1_OVRFLO
operator||
name|FE_D1_CRCERR
operator||
name|FE_D1_ALGERR
operator||
name|FE_D1_SRTPKT
operator|)
condition|)
block|{
if|if
condition|(
name|rstat
operator|&
name|FE_D1_OVRFLO
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
if|if
condition|(
name|rstat
operator|&
name|FE_D1_CRCERR
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsFCSErrors
operator|++
expr_stmt|;
if|if
condition|(
name|rstat
operator|&
name|FE_D1_ALGERR
condition|)
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsAlignmentErrors
operator|++
expr_stmt|;
if|#
directive|if
literal|0
comment|/* The reference MAC receiver defined in 802.3 		   silently ignores short frames (RUNTs) without 		   notifying upper layer.  RFC 1650 (dot3 MIB) is 		   based on the 802.3, and it has no stats entry for 		   RUNTs...  */
block|if ( rstat& FE_D1_SRTPKT ) 			sc->mibdata.dot3StatsFrameTooShorts++;
comment|/* :-) */
endif|#
directive|endif
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
comment|/* 	 * MB86960 has a flag indicating "receive queue empty." 	 * We just loop, checking the flag, to pull out all received 	 * packets. 	 * 	 * We limit the number of iterations to avoid infinite-loop. 	 * The upper bound is set to unrealistic high value. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FE_MAX_RECV_COUNT
operator|*
literal|2
condition|;
name|i
operator|++
control|)
block|{
comment|/* Stop the iteration if 86960 indicates no packets.  */
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|)
operator|&
name|FE_D5_BUFEMP
condition|)
return|return;
comment|/* 		 * Extract a receive status byte. 		 * As our 86960 is in 16 bit bus access mode, we have to 		 * use inw() to get the status byte.  The significant 		 * value is returned in lower 8 bits. 		 */
ifdef|#
directive|ifdef
name|FE_8BIT_SUPPORT
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
name|status
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|status
operator|=
operator|(
name|u_char
operator|)
name|inw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Extract the packet length. 		 * It is a sum of a header (14 bytes) and a payload. 		 * CRC has been stripped off by the 86960. 		 */
ifdef|#
directive|ifdef
name|FE_8BIT_SUPPORT
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
name|len
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
name|len
operator||=
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|len
operator|=
name|inw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * AS our 86960 is programed to ignore errored frame, 		 * we must not see any error indication in the 		 * receive buffer.  So, any error condition is a 		 * serious error, e.g., out-of-sync of the receive 		 * buffer pointers. 		 */
if|if
condition|(
operator|(
name|status
operator|&
literal|0xF0
operator|)
operator|!=
literal|0x20
operator|||
name|len
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
operator|||
name|len
operator|<
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: RX buffer out-of-sync\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
name|fe_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Go get a packet. 		 */
if|if
condition|(
name|fe_get_packet
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Negative return from fe_get_packet() 			 * indicates no available mbuf.  We stop 			 * receiving packets, even if there are more 			 * in the buffer.  We hope we can get more 			 * mbuf next time. 			 */
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsMissedFrames
operator|++
expr_stmt|;
name|fe_droppacket
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Successfully received a packet.  Update stat.  */
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
block|}
comment|/* Maximum number of frames has been received.  Something            strange is happening here... */
name|printf
argument_list|(
literal|"fe%d: unusual receive flood\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacReceiveErrors
operator|++
expr_stmt|;
name|fe_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ethernet interface interrupt processor  */
end_comment

begin_function
specifier|static
name|void
name|feintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
operator|&
name|fe_softc
index|[
name|unit
index|]
decl_stmt|;
name|u_char
name|tstat
decl_stmt|,
name|rstat
decl_stmt|;
name|int
name|loop_count
init|=
name|FE_MAX_LOOP
decl_stmt|;
comment|/* Loop until there are no more new interrupt conditions.  */
while|while
condition|(
name|loop_count
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Get interrupt conditions, masking unneeded flags. 		 */
name|tstat
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|)
operator|&
name|FE_TMASK
expr_stmt|;
name|rstat
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|)
operator|&
name|FE_RMASK
expr_stmt|;
if|if
condition|(
name|tstat
operator|==
literal|0
operator|&&
name|rstat
operator|==
literal|0
condition|)
return|return;
comment|/* 		 * Reset the conditions we are acknowledging. 		 */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR0
index|]
argument_list|,
name|tstat
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|,
name|rstat
argument_list|)
expr_stmt|;
comment|/* 		 * Handle transmitter interrupts. 		 */
if|if
condition|(
name|tstat
condition|)
block|{
name|fe_tint
argument_list|(
name|sc
argument_list|,
name|tstat
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Handle receiver interrupts 		 */
if|if
condition|(
name|rstat
condition|)
block|{
name|fe_rint
argument_list|(
name|sc
argument_list|,
name|rstat
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Update the multicast address filter if it is 		 * needed and possible.  We do it now, because 		 * we can make sure the transmission buffer is empty, 		 * and there is a good chance that the receive queue 		 * is empty.  It will minimize the possibility of 		 * packet loss. 		 */
if|if
condition|(
name|sc
operator|->
name|filter_change
operator|&&
name|sc
operator|->
name|txb_count
operator|==
literal|0
operator|&&
name|sc
operator|->
name|txb_sched
operator|==
literal|0
condition|)
block|{
name|fe_loadmar
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
comment|/* 		 * If it looks like the transmitter can take more data, 		 * attempt to start output on the interface. This is done 		 * after handling the receiver interrupt to give the 		 * receive operation priority. 		 * 		 * BTW, I'm not sure in what case the OACTIVE is on at 		 * this point.  Is the following test redundant? 		 * 		 * No.  This routine polls for both transmitter and 		 * receiver interrupts.  86960 can raise a receiver 		 * interrupt when the transmission buffer is full. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|fe_start
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"fe%d: too many loops\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request. This code needs some work - it looks  * pretty ugly.  */
end_comment

begin_function
specifier|static
name|int
name|fe_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
comment|/* Just an ordinary action.  */
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * Switch interface state between "running" and 		 * "stopped", reflecting the UP flag. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|fe_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
name|fe_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Promiscuous and/or multicast flags may have changed, 		 * so reprogram the multicast filter and/or receive mode. 		 */
name|fe_setmode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Done.  */
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/* 		 * Multicast list has changed; set the hardware filter 		 * accordingly. 		 */
name|fe_setmode
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
comment|/* Let if_media to handle these commands and to call 		   us back.  */
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve packet from receive buffer and send to the next level up via  * ether_input(). If there is a BPF listener, give a copy to BPF, too.  * Returns 0 if success, -1 if error (i.e., mbuf allocation failure).  */
end_comment

begin_function
specifier|static
name|int
name|fe_get_packet
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|u_short
name|len
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* 	 * NFS wants the data be aligned to the word (4 byte) 	 * boundary.  Ethernet header has 14 bytes.  There is a 	 * 2-byte gap. 	 */
define|#
directive|define
name|NFS_MAGIC_OFFSET
value|2
comment|/* 	 * This function assumes that an Ethernet packet fits in an 	 * mbuf (with a cluster attached when necessary.)  On FreeBSD 	 * 2.0 for x86, which is the primary target of this driver, an 	 * mbuf cluster has 4096 bytes, and we are happy.  On ancient 	 * BSDs, such as vanilla 4.3 for 386, a cluster size was 1024, 	 * however.  If the following #error message were printed upon 	 * compile, you need to rewrite this function. 	 */
if|#
directive|if
operator|(
name|MCLBYTES
operator|<
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
operator|+
name|NFS_MAGIC_OFFSET
operator|)
error|#
directive|error
literal|"Too small MCLBYTES to use fe driver."
endif|#
directive|endif
comment|/* 	 * Our strategy has one more problem.  There is a policy on 	 * mbuf cluster allocation.  It says that we must have at 	 * least MINCLSIZE (208 bytes on FreeBSD 2.0 for x86) to 	 * allocate a cluster.  For a packet of a size between 	 * (MHLEN - 2) to (MINCLSIZE - 2), our code violates the rule... 	 * On the other hand, the current code is short, simple, 	 * and fast, however.  It does no harmful thing, just waists 	 * some memory.  Any comments?  FIXME. 	 */
comment|/* Allocate an mbuf with packet header info.  */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Attach a cluster if this packet doesn't fit in a normal mbuf.  */
if|if
condition|(
name|len
operator|>
name|MHLEN
operator|-
name|NFS_MAGIC_OFFSET
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Initialize packet header info.  */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
comment|/* Set the length of this packet.  */
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* The following silliness is to make NFS happy */
name|m
operator|->
name|m_data
operator|+=
name|NFS_MAGIC_OFFSET
expr_stmt|;
comment|/* Get (actually just point to) the header part.  */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* Get a packet.  */
ifdef|#
directive|ifdef
name|FE_8BIT_SUPPORT
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
name|insb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|,
name|eh
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|insw
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
argument_list|,
name|eh
argument_list|,
operator|(
name|len
operator|+
literal|1
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|ETHER_ADDR_IS_MULTICAST
parameter_list|(
name|A
parameter_list|)
value|(*(char *)(A)& 1)
if|#
directive|if
name|NBPF
operator|>
literal|0
comment|/* 	 * Check if there's a BPF listener on this interface. 	 * If it is, hand off the raw packet to bpf. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BRIDGE
if|if
condition|(
name|do_bridge
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|bridge_in
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|BDG_DROP
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ifp
operator|!=
name|BDG_LOCAL
condition|)
name|bdg_forward
argument_list|(
operator|&
name|m
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* not local, need forwarding */
if|if
condition|(
name|ifp
operator|==
name|BDG_LOCAL
operator|||
name|ifp
operator|==
name|BDG_BCAST
operator|||
name|ifp
operator|==
name|BDG_MCAST
condition|)
goto|goto
name|getit
goto|;
comment|/* not local and not multicast, just drop it */
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* 	 * Make sure this packet is (or may be) directed to us. 	 * That is, the packet is either unicasted to our address, 	 * or broad/multi-casted.  If any other packets are 	 * received, it is an indication of an error -- probably 	 * 86960 is in a wrong operation mode. 	 * Promiscuous mode is an exception.  Under the mode, all 	 * packets on the media must be received.  (We must have 	 * programmed the 86960 so.) 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|!
name|ETHER_ADDR_IS_MULTICAST
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|sc_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The packet was not for us.  This is normal since 		 * we are now in promiscuous mode.  Just drop the packet. 		 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|BRIDGE
name|getit
label|:
endif|#
directive|endif
comment|/* Strip off the Ethernet header.  */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* Feed the packet to upper layer.  */
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Write an mbuf chain to the transmission buffer memory using 16 bit PIO.  * Returns number of bytes actually written, including length word.  *  * If an mbuf chain is too long for an Ethernet frame, it is not sent.  * Packets shorter than Ethernet minimum are legal, and we pad them  * before sending out.  An exception is "partial" packets which are  * shorter than mandatory Ethernet header.  */
end_comment

begin_function
specifier|static
name|void
name|fe_write_mbufs
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|u_short
name|addr_bmpr8
init|=
name|sc
operator|->
name|ioaddr
index|[
name|FE_BMPR8
index|]
decl_stmt|;
name|u_short
name|length
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|u_short
name|savebyte
decl_stmt|;
comment|/* WARNING: Architecture dependent!  */
define|#
directive|define
name|NO_PENDING_BYTE
value|0xFFFF
specifier|static
name|u_char
name|padding
index|[
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|ETHER_HDR_LEN
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* First, count up the total number of bytes to copy */
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
name|length
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
block|}
comment|/* Check if this matches the one in the packet header.  */
if|if
condition|(
name|length
operator|!=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: packet length mismatch? (%d/%d)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|length
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Just use the length value in the packet header.  */
name|length
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* 	 * Should never send big packets.  If such a packet is passed, 	 * it should be a bug of upper layer.  We just ignore it. 	 * ... Partial (too short) packets, neither. 	 */
if|if
condition|(
name|length
operator|<
name|ETHER_HDR_LEN
operator|||
name|length
operator|>
name|ETHER_MAX_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: got an out-of-spec packet (%u bytes) to send\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|mibdata
operator|.
name|dot3StatsInternalMacTransmitErrors
operator|++
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Put the length word for this frame. 	 * Does 86960 accept odd length?  -- Yes. 	 * Do we need to pad the length to minimum size by ourselves? 	 * -- Generally yes.  But for (or will be) the last 	 * packet in the transmission buffer, we can skip the 	 * padding process.  It may gain performance slightly.  FIXME. 	 */
ifdef|#
directive|ifdef
name|FE_8BIT_SUPPORT
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
name|len
operator|=
name|max
argument_list|(
name|length
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_bmpr8
argument_list|,
name|len
operator|&
literal|0x00ff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_bmpr8
argument_list|,
operator|(
name|len
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|outw
argument_list|(
name|addr_bmpr8
argument_list|,
name|max
argument_list|(
name|length
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update buffer status now. 	 * Truncate the length up to an even number, since we use outw(). 	 */
ifdef|#
directive|ifdef
name|FE_8BIT_SUPPORT
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|!=
name|FE_D6_SBW_BYTE
condition|)
endif|#
directive|endif
block|{
name|length
operator|=
operator|(
name|length
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|txb_free
operator|-=
name|FE_DATA_LEN_LEN
operator|+
name|max
argument_list|(
name|length
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|txb_count
operator|++
expr_stmt|;
comment|/* 	 * Transfer the data from mbuf chain to the transmission buffer. 	 * MB86960 seems to require that data be transferred as words, and 	 * only words.  So that we require some extra code to patch 	 * over odd-length mbufs. 	 */
ifdef|#
directive|ifdef
name|FE_8BIT_SUPPORT
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
comment|/* 8-bit cards are easy.  */
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
operator|!=
literal|0
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_len
condition|)
block|{
name|outsb
argument_list|(
name|addr_bmpr8
argument_list|,
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mp
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
endif|#
directive|endif
block|{
comment|/* 16-bit cards are a pain.  */
name|savebyte
operator|=
name|NO_PENDING_BYTE
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
operator|!=
literal|0
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
block|{
comment|/* Ignore empty mbuf.  */
name|len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
comment|/* Find the actual data to send.  */
name|data
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* Finish the last byte.  */
if|if
condition|(
name|savebyte
operator|!=
name|NO_PENDING_BYTE
condition|)
block|{
name|outw
argument_list|(
name|addr_bmpr8
argument_list|,
name|savebyte
operator||
operator|(
operator|*
name|data
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|data
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|savebyte
operator|=
name|NO_PENDING_BYTE
expr_stmt|;
block|}
comment|/* output contiguous words */
if|if
condition|(
name|len
operator|>
literal|1
condition|)
block|{
name|outsw
argument_list|(
name|addr_bmpr8
argument_list|,
name|data
argument_list|,
name|len
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|data
operator|+=
name|len
operator|&
operator|~
literal|1
expr_stmt|;
name|len
operator|&=
literal|1
expr_stmt|;
block|}
comment|/* Save a remaining byte, if there is one.  */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|savebyte
operator|=
operator|*
name|data
expr_stmt|;
block|}
block|}
comment|/* Spit the last byte, if the length is odd.  */
if|if
condition|(
name|savebyte
operator|!=
name|NO_PENDING_BYTE
condition|)
block|{
name|outw
argument_list|(
name|addr_bmpr8
argument_list|,
name|savebyte
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Pad to the Ethernet minimum length, if the packet is too short.  */
if|if
condition|(
name|length
operator|<
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
condition|)
block|{
ifdef|#
directive|ifdef
name|FE_8BIT_SUPPORT
if|if
condition|(
operator|(
name|sc
operator|->
name|proto_dlcr6
operator|&
name|FE_D6_SBW
operator|)
operator|==
name|FE_D6_SBW_BYTE
condition|)
block|{
name|outsb
argument_list|(
name|addr_bmpr8
argument_list|,
name|padding
argument_list|,
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|length
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|outsw
argument_list|(
name|addr_bmpr8
argument_list|,
name|padding
argument_list|,
operator|(
name|ETHER_MIN_LEN
operator|-
name|ETHER_CRC_LEN
operator|-
name|length
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Compute hash value for an Ethernet address  */
end_comment

begin_function
specifier|static
name|int
name|fe_hash
parameter_list|(
name|u_char
modifier|*
name|ep
parameter_list|)
block|{
define|#
directive|define
name|FE_HASH_MAGIC_NUMBER
value|0xEDB88320L
name|u_long
name|hash
init|=
literal|0xFFFFFFFFL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_char
name|b
decl_stmt|;
name|u_long
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ETHER_ADDR_LEN
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|b
operator|=
operator|*
name|ep
operator|++
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|8
init|;
operator|--
name|j
operator|>=
literal|0
condition|;
control|)
block|{
name|m
operator|=
name|hash
expr_stmt|;
name|hash
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|^
name|b
operator|)
operator|&
literal|1
condition|)
name|hash
operator|^=
name|FE_HASH_MAGIC_NUMBER
expr_stmt|;
name|b
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
call|(
name|int
call|)
argument_list|(
name|hash
operator|>>
literal|26
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the multicast address filter from the  * list of multicast addresses we need to listen to.  */
end_comment

begin_function
specifier|static
name|struct
name|fe_filter
name|fe_mcaf
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|struct
name|fe_filter
name|filter
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|filter
operator|=
name|fe_filter_nothing
expr_stmt|;
for|for
control|(
name|ifma
operator|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_multiaddrs
operator|.
name|lh_first
init|;
name|ifma
condition|;
name|ifma
operator|=
name|ifma
operator|->
name|ifma_link
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|index
operator|=
name|fe_hash
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FE_DEBUG
name|printf
argument_list|(
literal|"fe%d: hash(%6D) == %d\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|enm
operator|->
name|enm_addrlo
argument_list|,
literal|":"
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|filter
operator|.
name|data
index|[
name|index
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|index
operator|&
literal|7
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|filter
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate a new "multicast packet filter" and put the 86960  * receiver in appropriate mode.  */
end_comment

begin_function
specifier|static
name|void
name|fe_setmode
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|flags
init|=
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
decl_stmt|;
comment|/* 	 * If the interface is not running, we postpone the update 	 * process for receive modes and multicast address filter 	 * until the interface is restarted.  It reduces some 	 * complicated job on maintaining chip states.  (Earlier versions 	 * of this driver had a bug on that point...) 	 * 	 * To complete the trick, fe_init() calls fe_setmode() after 	 * restarting the interface. 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
return|return;
comment|/* 	 * Promiscuous mode is handled separately. 	 */
if|if
condition|(
name|flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* 		 * Program 86960 to receive all packets on the segment 		 * including those directed to other stations. 		 * Multicast filter stored in MARs are ignored 		 * under this setting, so we don't need to update it. 		 * 		 * Promiscuous mode in FreeBSD 2 is used solely by 		 * BPF, and BPF only listens to valid (no error) packets. 		 * So, we ignore erroneous ones even in this mode. 		 * (Older versions of fe driver mistook the point.) 		 */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr5
operator||
name|FE_D5_AFM0
operator||
name|FE_D5_AFM1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|filter_change
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * Turn the chip to the normal (non-promiscuous) mode. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR5
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr5
operator||
name|FE_D5_AFM1
argument_list|)
expr_stmt|;
comment|/* 	 * Find the new multicast filter value. 	 */
if|if
condition|(
name|flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|sc
operator|->
name|filter
operator|=
name|fe_filter_all
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|filter
operator|=
name|fe_mcaf
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|filter_change
operator|=
literal|1
expr_stmt|;
comment|/* 	 * We have to update the multicast filter in the 86960, A.S.A.P. 	 * 	 * Note that the DLC (Data Link Control unit, i.e. transmitter 	 * and receiver) must be stopped when feeding the filter, and 	 * DLC trashes all packets in both transmission and receive 	 * buffers when stopped. 	 * 	 * To reduce the packet loss, we delay the filter update 	 * process until buffers are empty. 	 */
if|if
condition|(
name|sc
operator|->
name|txb_sched
operator|==
literal|0
operator|&&
name|sc
operator|->
name|txb_count
operator|==
literal|0
operator|&&
operator|!
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR1
index|]
argument_list|)
operator|&
name|FE_D1_PKTRDY
operator|)
condition|)
block|{
comment|/* 		 * Buffers are (apparently) empty.  Load 		 * the new filter value into MARs now. 		 */
name|fe_loadmar
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Buffers are not empty.  Mark that we have to update 		 * the MARs.  The new filter will be loaded by feintr() 		 * later. 		 */
block|}
block|}
end_function

begin_comment
comment|/*  * Load a new multicast address filter into MARs.  *  * The caller must have splimp'ed before fe_loadmar.  * This function starts the DLC upon return.  So it can be called only  * when the chip is working, i.e., from the driver's point of view, when  * a device is RUNNING.  (I mistook the point in previous versions.)  */
end_comment

begin_function
specifier|static
name|void
name|fe_loadmar
parameter_list|(
name|struct
name|fe_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Stop the DLC (transmitter and receiver).  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_DISABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* Select register bank 1 for MARs.  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_MAR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
comment|/* Copy filter value into the registers.  */
name|outblk
argument_list|(
name|sc
argument_list|,
name|FE_MAR8
argument_list|,
name|sc
operator|->
name|filter
operator|.
name|data
argument_list|,
name|FE_FILTER_LEN
argument_list|)
expr_stmt|;
comment|/* Restore the bank selection for BMPRs (i.e., runtime registers).  */
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR7
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr7
operator||
name|FE_D7_RBS_BMPR
operator||
name|FE_D7_POWER_UP
argument_list|)
expr_stmt|;
comment|/* Restart the DLC.  */
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|ioaddr
index|[
name|FE_DLCR6
index|]
argument_list|,
name|sc
operator|->
name|proto_dlcr6
operator||
name|FE_D6_DLC_ENABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* We have just updated the filter.  */
name|sc
operator|->
name|filter_change
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Change the media selection.  */
end_comment

begin_function
specifier|static
name|int
name|fe_medchange
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fe_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|fe_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* If_media should not pass any request for a media which this 	   interface doesn't support.  */
name|int
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|bit2media
index|[
name|b
index|]
operator|!=
literal|0
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|bit2media
index|[
name|b
index|]
operator|==
name|sc
operator|->
name|media
operator|.
name|ifm_media
condition|)
break|break;
block|}
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|b
operator|)
operator|&
name|sc
operator|->
name|mbitmap
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"fe%d: got an unsupported media request (0x%x)\n"
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|,
name|sc
operator|->
name|media
operator|.
name|ifm_media
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
endif|#
directive|endif
comment|/* We don't actually change media when the interface is down. 	   fe_init() will do the job, instead.  Should we also wait 	   until the transmission buffer being empty?  Changing the 	   media when we are sending a frame will cause two garbages 	   on wires, one on old media and another on new.  FIXME */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|msel
condition|)
name|sc
operator|->
name|msel
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* I don't know how I can support media status callback... FIXME.  */
end_comment

begin_function
specifier|static
name|void
name|fe_medstat
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ifp
expr_stmt|;
operator|(
name|void
operator|)
name|ifmr
expr_stmt|;
block|}
end_function

end_unit

