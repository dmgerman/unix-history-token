begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 Ludd, University of Lule}, Sweden.  * All rights reserved.  *  * Written by Olof Johansson (offe@ludd.luth.se) 1995.  * Based on code written by Theo de Raadt (deraadt@fsa.ca).  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *     This product includes software developed at Ludd, University of Lule}.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* All bugs are subject to removal without further notice */
end_comment

begin_comment
comment|/*  * offe 01/07/95  *  * This version of the driver _still_ doesn't implement scatter/gather for the  * WD7000-FASST2. This is due to the fact that my controller doesn't seem to  * support it. That, and the lack of documentation makes it impossible for  * me to implement it.  * What I've done instead is allocated a local buffer, contiguous buffer big  * enough to handle the requests. I haven't seen any read/write bigger than 64k,  * so I allocate a buffer of 64+16k. The data that needs to be DMA'd to/from  * the controller is copied to/from that buffer before/after the command is  * sent to the card.  */
end_comment

begin_include
include|#
directive|include
file|"wds.h"
end_include

begin_if
if|#
directive|if
name|NWDS
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkbad.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|kdc_wds
index|[
name|NWDS
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"wds"
block|,
literal|0
block|,
block|{
name|MDDT_ISA
block|,
literal|0
block|,
literal|"bio"
block|}
block|,
name|isa_generic_externalize
block|,
literal|0
block|,
literal|0
block|,
name|ISA_EXTERNALLEN
block|,
operator|&
name|kdc_isa0
block|,
literal|0
block|,
name|DC_UNCONFIGURED
block|,
comment|/* state */
literal|"Western Digital WD-7000 SCSI host adapter"
block|,
name|DC_CLS_MISC
comment|/* class */
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scsi_device
name|wds_dev
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"wds"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   XXX   THIS SHOULD BE FIXED!   I haven't got the KERNBASE-version to work, but on my system the kernel   is at virtual address 0xFxxxxxxx, responding to physical address   0x0xxxxxxx. #define PHYSTOKV(x)	((x) + KERNBASE) */
end_comment

begin_define
define|#
directive|define
name|PHYSTOKV
parameter_list|(
name|x
parameter_list|)
value|((x) | 0xf0000000)
end_define

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_comment
comment|/* 0x10000 (64k) should be enough. But just to be sure... */
end_comment

begin_define
define|#
directive|define
name|BUFSIZ
value|0x12000
end_define

begin_comment
comment|/* WD7000 registers */
end_comment

begin_define
define|#
directive|define
name|WDS_STAT
value|0
end_define

begin_comment
comment|/* read */
end_comment

begin_define
define|#
directive|define
name|WDS_IRQSTAT
value|1
end_define

begin_comment
comment|/* read */
end_comment

begin_define
define|#
directive|define
name|WDS_CMD
value|0
end_define

begin_comment
comment|/* write */
end_comment

begin_define
define|#
directive|define
name|WDS_IRQACK
value|1
end_define

begin_comment
comment|/* write */
end_comment

begin_define
define|#
directive|define
name|WDS_HCR
value|2
end_define

begin_comment
comment|/* write */
end_comment

begin_comment
comment|/* WDS_STAT (read) defs */
end_comment

begin_define
define|#
directive|define
name|WDS_IRQ
value|0x80
end_define

begin_define
define|#
directive|define
name|WDS_RDY
value|0x40
end_define

begin_define
define|#
directive|define
name|WDS_REJ
value|0x20
end_define

begin_define
define|#
directive|define
name|WDS_INIT
value|0x10
end_define

begin_comment
comment|/* WDS_IRQSTAT (read) defs */
end_comment

begin_define
define|#
directive|define
name|WDSI_MASK
value|0xc0
end_define

begin_define
define|#
directive|define
name|WDSI_ERR
value|0x00
end_define

begin_define
define|#
directive|define
name|WDSI_MFREE
value|0x80
end_define

begin_define
define|#
directive|define
name|WDSI_MSVC
value|0xc0
end_define

begin_comment
comment|/* WDS_CMD (write) defs */
end_comment

begin_define
define|#
directive|define
name|WDSC_NOOP
value|0x00
end_define

begin_define
define|#
directive|define
name|WDSC_INIT
value|0x01
end_define

begin_define
define|#
directive|define
name|WDSC_DISUNSOL
value|0x02
end_define

begin_define
define|#
directive|define
name|WDSC_ENAUNSOL
value|0x03
end_define

begin_define
define|#
directive|define
name|WDSC_IRQMFREE
value|0x04
end_define

begin_define
define|#
directive|define
name|WDSC_SCSIRESETSOFT
value|0x05
end_define

begin_define
define|#
directive|define
name|WDSC_SCSIRESETHARD
value|0x06
end_define

begin_define
define|#
directive|define
name|WDSC_MSTART
parameter_list|(
name|m
parameter_list|)
value|(0x80 + (m))
end_define

begin_define
define|#
directive|define
name|WDSC_MMSTART
parameter_list|(
name|m
parameter_list|)
value|(0xc0 + (m))
end_define

begin_comment
comment|/* WDS_HCR (write) defs */
end_comment

begin_define
define|#
directive|define
name|WDSH_IRQEN
value|0x08
end_define

begin_define
define|#
directive|define
name|WDSH_DRQEN
value|0x04
end_define

begin_define
define|#
directive|define
name|WDSH_SCSIRESET
value|0x02
end_define

begin_define
define|#
directive|define
name|WDSH_ASCRESET
value|0x01
end_define

begin_struct
struct|struct
name|wds_cmd
block|{
name|u_char
name|cmd
decl_stmt|;
name|u_char
name|targ
decl_stmt|;
name|u_char
name|scb
index|[
literal|12
index|]
decl_stmt|;
comment|/*u_char scb[12];*/
name|u_char
name|stat
decl_stmt|;
name|u_char
name|venderr
decl_stmt|;
name|u_char
name|len
index|[
literal|3
index|]
decl_stmt|;
name|u_char
name|data
index|[
literal|3
index|]
decl_stmt|;
name|u_char
name|next
index|[
literal|3
index|]
decl_stmt|;
name|u_char
name|write
decl_stmt|;
name|u_char
name|xx
index|[
literal|6
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|wds_req
block|{
name|struct
name|wds_cmd
name|cmd
decl_stmt|;
name|struct
name|wds_cmd
name|sense
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|sxp
decl_stmt|;
name|int
name|busy
decl_stmt|,
name|polled
decl_stmt|;
name|int
name|done
decl_stmt|,
name|ret
decl_stmt|,
name|ombn
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|WDSX_SCSICMD
value|0x00
end_define

begin_define
define|#
directive|define
name|WDSX_OPEN_RCVBUF
value|0x80
end_define

begin_define
define|#
directive|define
name|WDSX_RCV_CMD
value|0x81
end_define

begin_define
define|#
directive|define
name|WDSX_RCV_DATA
value|0x82
end_define

begin_define
define|#
directive|define
name|WDSX_RCV_DATASTAT
value|0x83
end_define

begin_define
define|#
directive|define
name|WDSX_SND_DATA
value|0x84
end_define

begin_define
define|#
directive|define
name|WDSX_SND_DATASTAT
value|0x85
end_define

begin_define
define|#
directive|define
name|WDSX_SND_CMDSTAT
value|0x86
end_define

begin_define
define|#
directive|define
name|WDSX_READINIT
value|0x88
end_define

begin_define
define|#
directive|define
name|WDSX_READSCSIID
value|0x89
end_define

begin_define
define|#
directive|define
name|WDSX_SETUNSOLIRQMASK
value|0x8a
end_define

begin_define
define|#
directive|define
name|WDSX_GETUNSOLIRQMASK
value|0x8b
end_define

begin_define
define|#
directive|define
name|WDSX_GETFIRMREV
value|0x8c
end_define

begin_define
define|#
directive|define
name|WDSX_EXECDIAG
value|0x8d
end_define

begin_define
define|#
directive|define
name|WDSX_SETEXECPARM
value|0x8e
end_define

begin_define
define|#
directive|define
name|WDSX_GETEXECPARM
value|0x8f
end_define

begin_struct
struct|struct
name|wds_mb
block|{
name|u_char
name|stat
decl_stmt|;
name|u_char
name|addr
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ICMB status value */
end_comment

begin_define
define|#
directive|define
name|ICMB_OK
value|0x01
end_define

begin_define
define|#
directive|define
name|ICMB_OKERR
value|0x02
end_define

begin_define
define|#
directive|define
name|ICMB_ETIME
value|0x04
end_define

begin_define
define|#
directive|define
name|ICMB_ERESET
value|0x05
end_define

begin_define
define|#
directive|define
name|ICMB_ETARCMD
value|0x06
end_define

begin_define
define|#
directive|define
name|ICMB_ERESEL
value|0x80
end_define

begin_define
define|#
directive|define
name|ICMB_ESEL
value|0x81
end_define

begin_define
define|#
directive|define
name|ICMB_EABORT
value|0x82
end_define

begin_define
define|#
directive|define
name|ICMB_ESRESET
value|0x83
end_define

begin_define
define|#
directive|define
name|ICMB_EHRESET
value|0x84
end_define

begin_struct
struct|struct
name|wds_setup
block|{
name|u_char
name|cmd
decl_stmt|;
name|u_char
name|scsi_id
decl_stmt|;
name|u_char
name|buson_t
decl_stmt|;
name|u_char
name|busoff_t
decl_stmt|;
name|u_char
name|xx
decl_stmt|;
name|u_char
name|mbaddr
index|[
literal|3
index|]
decl_stmt|;
name|u_char
name|nomb
decl_stmt|;
name|u_char
name|nimb
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|WDS_NOMB
value|8
end_define

begin_define
define|#
directive|define
name|WDS_NIMB
value|8
end_define

begin_define
define|#
directive|define
name|MAXSIMUL
value|8
end_define

begin_decl_stmt
name|int
name|wdsunit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|wds_data
index|[
name|NWDS
index|]
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|wds_data_in_use
index|[
name|NWDS
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|wds
block|{
name|int
name|addr
decl_stmt|;
name|struct
name|wds_req
name|wdsr
index|[
name|MAXSIMUL
index|]
decl_stmt|;
name|struct
name|wds_mb
name|ombs
index|[
name|WDS_NOMB
index|]
decl_stmt|,
name|imbs
index|[
name|WDS_NIMB
index|]
decl_stmt|;
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
block|}
name|wds
index|[
name|NWDS
index|]
struct|;
end_struct

begin_function_decl
name|int
name|wdsprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|wds_minphys
parameter_list|(
name|struct
name|buf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|wds_req
modifier|*
name|wdsr_alloc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int32_t
name|wds_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int32_t
name|wds_adapter_info
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wdsintr
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wds_done
parameter_list|(
name|int
parameter_list|,
name|struct
name|wds_cmd
modifier|*
parameter_list|,
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wdsattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wds_init
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|wds_cmd
parameter_list|(
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|wds_wait
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|wdsdriver
init|=
block|{
name|wdsprobe
block|,
name|wdsattach
block|,
literal|"wds"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scsi_adapter
name|wds_switch
init|=
block|{
name|wds_scsi_cmd
block|,
name|wds_minphys
block|,
literal|0
block|,
literal|0
block|,
name|wds_adapter_info
block|,
literal|"wds"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|wdsprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|wdsunit
operator|>
name|NWDS
condition|)
return|return
literal|0
return|;
name|dev
operator|->
name|id_unit
operator|=
name|wdsunit
expr_stmt|;
comment|/* XXX WRONG! */
name|wds
index|[
name|wdsunit
index|]
operator|.
name|addr
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_unit
condition|)
name|kdc_wds
index|[
name|dev
operator|->
name|id_unit
index|]
operator|=
name|kdc_wds
index|[
literal|0
index|]
expr_stmt|;
name|kdc_wds
index|[
name|dev
operator|->
name|id_unit
index|]
operator|.
name|kdc_unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
name|kdc_wds
index|[
name|dev
operator|->
name|id_unit
index|]
operator|.
name|kdc_parentdata
operator|=
name|dev
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|kdc_wds
index|[
name|dev
operator|->
name|id_unit
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wds_init
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|wdsunit
operator|++
expr_stmt|;
return|return
literal|8
return|;
block|}
end_function

begin_function
name|void
name|wds_minphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|BUFSIZ
condition|)
name|bp
operator|->
name|b_bcount
operator|=
name|BUFSIZ
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|wds_req
modifier|*
name|wdsr_alloc
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|wds_req
modifier|*
name|r
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|i
decl_stmt|;
name|r
operator|=
name|NULL
expr_stmt|;
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSIMUL
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|wds
index|[
name|unit
index|]
operator|.
name|wdsr
index|[
name|i
index|]
operator|.
name|busy
condition|)
block|{
name|r
operator|=
operator|&
name|wds
index|[
name|unit
index|]
operator|.
name|wdsr
index|[
name|i
index|]
expr_stmt|;
name|r
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|r
operator|->
name|ombn
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WDS_NOMB
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|wds
index|[
name|unit
index|]
operator|.
name|ombs
index|[
name|i
index|]
operator|.
name|stat
condition|)
block|{
name|wds
index|[
name|unit
index|]
operator|.
name|ombs
index|[
name|i
index|]
operator|.
name|stat
operator|=
literal|1
expr_stmt|;
name|r
operator|->
name|ombn
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|->
name|ombn
operator|==
operator|-
literal|1
condition|)
block|{
name|r
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
name|int32_t
name|wds_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|sxp
parameter_list|)
block|{
name|struct
name|wds_req
modifier|*
name|r
decl_stmt|;
name|int
name|unit
init|=
name|sxp
operator|->
name|sc_link
operator|->
name|adapter_unit
decl_stmt|;
name|int
name|base
decl_stmt|;
name|u_char
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|base
operator|=
name|wds
index|[
name|unit
index|]
operator|.
name|addr
expr_stmt|;
if|if
condition|(
name|sxp
operator|->
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|printf
argument_list|(
literal|"reset!\n"
argument_list|)
expr_stmt|;
return|return
name|COMPLETE
return|;
block|}
name|r
operator|=
name|wdsr_alloc
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"no request slot available!\n"
argument_list|)
expr_stmt|;
name|sxp
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
name|TRY_AGAIN_LATER
return|;
block|}
name|r
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|sxp
operator|=
name|sxp
expr_stmt|;
if|if
condition|(
name|sxp
operator|->
name|flags
operator|&
name|SCSI_DATA_UIO
condition|)
block|{
name|printf
argument_list|(
literal|"UIO!\n"
argument_list|)
expr_stmt|;
name|sxp
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
name|TRY_AGAIN_LATER
return|;
block|}
name|scsi_uto3b
argument_list|(
name|KVTOPHYS
argument_list|(
operator|&
name|r
operator|->
name|cmd
argument_list|)
argument_list|,
name|wds
index|[
name|unit
index|]
operator|.
name|ombs
index|[
name|r
operator|->
name|ombn
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|r
operator|->
name|cmd
argument_list|,
sizeof|sizeof
name|r
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|r
operator|->
name|cmd
operator|.
name|cmd
operator|=
name|WDSX_SCSICMD
expr_stmt|;
name|r
operator|->
name|cmd
operator|.
name|targ
operator|=
operator|(
name|sxp
operator|->
name|sc_link
operator|->
name|target
operator|<<
literal|5
operator|)
operator||
name|sxp
operator|->
name|sc_link
operator|->
name|lun
expr_stmt|;
name|bcopy
argument_list|(
name|sxp
operator|->
name|cmd
argument_list|,
operator|&
name|r
operator|->
name|cmd
operator|.
name|scb
argument_list|,
name|sxp
operator|->
name|cmdlen
operator|<
literal|12
condition|?
name|sxp
operator|->
name|cmdlen
else|:
literal|12
argument_list|)
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|sxp
operator|->
name|datalen
argument_list|,
name|r
operator|->
name|cmd
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|wds_data_in_use
index|[
name|unit
index|]
condition|)
block|{
name|sxp
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
name|TRY_AGAIN_LATER
return|;
block|}
else|else
name|wds_data_in_use
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sxp
operator|->
name|datalen
operator|&&
operator|!
operator|(
name|sxp
operator|->
name|flags
operator|&
name|SCSI_DATA_IN
operator|)
condition|)
name|bcopy
argument_list|(
name|sxp
operator|->
name|data
argument_list|,
name|wds_data
index|[
name|unit
index|]
argument_list|,
name|sxp
operator|->
name|datalen
argument_list|)
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|sxp
operator|->
name|datalen
condition|?
name|KVTOPHYS
argument_list|(
name|wds_data
index|[
name|unit
index|]
argument_list|)
else|:
literal|0
argument_list|,
name|r
operator|->
name|cmd
operator|.
name|data
argument_list|)
expr_stmt|;
name|r
operator|->
name|cmd
operator|.
name|write
operator|=
operator|(
name|sxp
operator|->
name|flags
operator|&
name|SCSI_DATA_IN
operator|)
condition|?
literal|0x80
else|:
literal|0x00
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|KVTOPHYS
argument_list|(
operator|&
name|r
operator|->
name|sense
argument_list|)
argument_list|,
name|r
operator|->
name|cmd
operator|.
name|next
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|r
operator|->
name|sense
argument_list|,
sizeof|sizeof
name|r
operator|->
name|sense
argument_list|)
expr_stmt|;
name|r
operator|->
name|sense
operator|.
name|cmd
operator|=
name|r
operator|->
name|cmd
operator|.
name|cmd
expr_stmt|;
name|r
operator|->
name|sense
operator|.
name|targ
operator|=
name|r
operator|->
name|cmd
operator|.
name|targ
expr_stmt|;
name|r
operator|->
name|sense
operator|.
name|scb
index|[
literal|0
index|]
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|KVTOPHYS
argument_list|(
operator|&
name|sxp
operator|->
name|sense
argument_list|)
argument_list|,
name|r
operator|->
name|sense
operator|.
name|data
argument_list|)
expr_stmt|;
name|scsi_uto3b
argument_list|(
sizeof|sizeof
argument_list|(
name|sxp
operator|->
name|sense
argument_list|)
argument_list|,
name|r
operator|->
name|sense
operator|.
name|len
argument_list|)
expr_stmt|;
name|r
operator|->
name|sense
operator|.
name|write
operator|=
literal|0x80
expr_stmt|;
if|if
condition|(
name|sxp
operator|->
name|flags
operator|&
name|SCSI_NOMASK
condition|)
block|{
name|outb
argument_list|(
name|base
operator|+
name|WDS_HCR
argument_list|,
name|WDSH_DRQEN
argument_list|)
expr_stmt|;
name|r
operator|->
name|polled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|base
operator|+
name|WDS_HCR
argument_list|,
name|WDSH_IRQEN
operator||
name|WDSH_DRQEN
argument_list|)
expr_stmt|;
name|r
operator|->
name|polled
operator|=
literal|0
expr_stmt|;
block|}
name|c
operator|=
name|WDSC_MSTART
argument_list|(
name|r
operator|->
name|ombn
argument_list|)
expr_stmt|;
if|if
condition|(
name|wds_cmd
argument_list|(
name|base
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
name|c
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"wds%d: unable to start outgoing mbox\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|r
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|wds
index|[
name|unit
index|]
operator|.
name|ombs
index|[
name|r
operator|->
name|ombn
index|]
operator|.
name|stat
operator|=
literal|0
expr_stmt|;
return|return
name|TRY_AGAIN_LATER
return|;
block|}
if|if
condition|(
name|sxp
operator|->
name|flags
operator|&
name|SCSI_NOMASK
condition|)
block|{
name|repoll
label|:
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|base
operator|+
name|WDS_STAT
argument_list|)
operator|&
name|WDS_IRQ
operator|)
condition|)
block|{
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
literal|20
condition|)
block|{
name|outb
argument_list|(
name|base
operator|+
name|WDS_IRQACK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*r->busy = 0;*/
name|sxp
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
return|return
name|HAD_ERROR
return|;
block|}
block|}
name|wdsintr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|done
condition|)
block|{
name|r
operator|->
name|sxp
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|r
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return
name|r
operator|->
name|ret
return|;
block|}
goto|goto
name|repoll
goto|;
block|}
return|return
name|SUCCESSFULLY_QUEUED
return|;
block|}
end_function

begin_function
name|u_int32_t
name|wds_adapter_info
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|wdsintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|wds_cmd
modifier|*
name|pc
decl_stmt|,
modifier|*
name|vc
decl_stmt|;
name|struct
name|wds_mb
modifier|*
name|in
decl_stmt|;
name|u_char
name|stat
decl_stmt|;
name|u_char
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|inb
argument_list|(
name|wds
index|[
name|unit
index|]
operator|.
name|addr
operator|+
name|WDS_STAT
argument_list|)
operator|&
name|WDS_IRQ
condition|)
block|{
name|outb
argument_list|(
name|wds
index|[
name|unit
index|]
operator|.
name|addr
operator|+
name|WDS_IRQACK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|c
operator|=
name|inb
argument_list|(
name|wds
index|[
name|unit
index|]
operator|.
name|addr
operator|+
name|WDS_IRQSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
name|WDSI_MASK
operator|)
operator|==
name|WDSI_MSVC
condition|)
block|{
name|c
operator|=
name|c
operator|&
operator|~
name|WDSI_MASK
expr_stmt|;
name|in
operator|=
operator|&
name|wds
index|[
name|unit
index|]
operator|.
name|imbs
index|[
name|c
index|]
expr_stmt|;
name|pc
operator|=
operator|(
expr|struct
name|wds_cmd
operator|*
operator|)
name|scsi_3btou
argument_list|(
name|in
operator|->
name|addr
argument_list|)
expr_stmt|;
name|vc
operator|=
operator|(
expr|struct
name|wds_cmd
operator|*
operator|)
name|PHYSTOKV
argument_list|(
operator|(
name|long
operator|)
name|pc
argument_list|)
expr_stmt|;
name|stat
operator|=
name|in
operator|->
name|stat
expr_stmt|;
name|wds_done
argument_list|(
name|unit
argument_list|,
name|vc
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|in
operator|->
name|stat
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|wds
index|[
name|unit
index|]
operator|.
name|addr
operator|+
name|WDS_IRQACK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|wds_done
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|wds_cmd
modifier|*
name|c
parameter_list|,
name|u_char
name|stat
parameter_list|)
block|{
name|struct
name|wds_req
modifier|*
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|slask
index|[
literal|80
index|]
decl_stmt|;
name|r
operator|=
operator|(
expr|struct
name|wds_req
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXSIMUL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|c
operator|==
operator|&
name|wds
index|[
name|unit
index|]
operator|.
name|wdsr
index|[
name|i
index|]
operator|.
name|cmd
operator|&&
operator|!
name|wds
index|[
name|unit
index|]
operator|.
name|wdsr
index|[
name|i
index|]
operator|.
name|done
condition|)
block|{
name|r
operator|=
operator|&
name|wds
index|[
name|unit
index|]
operator|.
name|wdsr
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|==
operator|(
expr|struct
name|wds_req
operator|*
operator|)
name|NULL
condition|)
block|{
comment|/* failed to find request! */
return|return
literal|1
return|;
block|}
name|r
operator|->
name|done
operator|=
literal|1
expr_stmt|;
name|wds
index|[
name|unit
index|]
operator|.
name|ombs
index|[
name|r
operator|->
name|ombn
index|]
operator|.
name|stat
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|ret
operator|=
name|HAD_ERROR
expr_stmt|;
switch|switch
condition|(
name|stat
condition|)
block|{
case|case
name|ICMB_OK
case|:
name|r
operator|->
name|ret
operator|=
name|COMPLETE
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|sxp
condition|)
name|r
operator|->
name|sxp
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ICMB_OKERR
case|:
if|if
condition|(
operator|!
operator|(
name|r
operator|->
name|sxp
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
operator|&&
name|c
operator|->
name|stat
condition|)
block|{
name|r
operator|->
name|sxp
operator|->
name|sense
operator|.
name|error_code
operator|=
name|c
operator|->
name|venderr
expr_stmt|;
name|r
operator|->
name|sxp
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
block|}
else|else
name|r
operator|->
name|sxp
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|r
operator|->
name|ret
operator|=
name|COMPLETE
expr_stmt|;
break|break;
case|case
name|ICMB_ETIME
case|:
name|r
operator|->
name|sxp
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
name|r
operator|->
name|ret
operator|=
name|HAD_ERROR
expr_stmt|;
break|break;
case|case
name|ICMB_ERESET
case|:
case|case
name|ICMB_ETARCMD
case|:
case|case
name|ICMB_ERESEL
case|:
case|case
name|ICMB_ESEL
case|:
case|case
name|ICMB_EABORT
case|:
case|case
name|ICMB_ESRESET
case|:
case|case
name|ICMB_EHRESET
case|:
name|r
operator|->
name|sxp
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|r
operator|->
name|ret
operator|=
name|HAD_ERROR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|r
operator|->
name|sxp
condition|)
if|if
condition|(
name|r
operator|->
name|sxp
operator|->
name|datalen
operator|&&
operator|(
name|r
operator|->
name|sxp
operator|->
name|flags
operator|&
name|SCSI_DATA_IN
operator|)
condition|)
name|bcopy
argument_list|(
name|wds_data
index|[
name|unit
index|]
argument_list|,
name|r
operator|->
name|sxp
operator|->
name|data
argument_list|,
name|r
operator|->
name|sxp
operator|->
name|datalen
argument_list|)
expr_stmt|;
name|wds_data_in_use
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|r
operator|->
name|polled
condition|)
block|{
name|r
operator|->
name|sxp
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|scsi_done
argument_list|(
name|r
operator|->
name|sxp
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|wds_getvers
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|wds_req
modifier|*
name|r
decl_stmt|;
name|int
name|base
decl_stmt|;
name|u_char
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|base
operator|=
name|wds
index|[
name|unit
index|]
operator|.
name|addr
expr_stmt|;
name|r
operator|=
name|wdsr_alloc
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|printf
argument_list|(
literal|"wds%d: no request slot available!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|r
operator|->
name|done
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|sxp
operator|=
name|NULL
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|KVTOPHYS
argument_list|(
operator|&
name|r
operator|->
name|cmd
argument_list|)
argument_list|,
name|wds
index|[
name|unit
index|]
operator|.
name|ombs
index|[
name|r
operator|->
name|ombn
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|r
operator|->
name|cmd
argument_list|,
sizeof|sizeof
name|r
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|r
operator|->
name|cmd
operator|.
name|cmd
operator|=
name|WDSX_GETFIRMREV
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|WDS_HCR
argument_list|,
name|WDSH_DRQEN
argument_list|)
expr_stmt|;
name|r
operator|->
name|polled
operator|=
literal|1
expr_stmt|;
name|c
operator|=
name|WDSC_MSTART
argument_list|(
name|r
operator|->
name|ombn
argument_list|)
expr_stmt|;
if|if
condition|(
name|wds_cmd
argument_list|(
name|base
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|c
argument_list|,
sizeof|sizeof
name|c
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"wds%d: version request failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|r
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|wds
index|[
name|unit
index|]
operator|.
name|ombs
index|[
name|r
operator|->
name|ombn
index|]
operator|.
name|stat
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|base
operator|+
name|WDS_STAT
argument_list|)
operator|&
name|WDS_IRQ
operator|)
operator|==
literal|0
condition|)
block|{
name|DELAY
argument_list|(
literal|9000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
literal|20
condition|)
return|return
operator|-
literal|1
return|;
block|}
name|wdsintr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|done
condition|)
block|{
name|printf
argument_list|(
literal|"wds%d: firmware version %d.%02d\n"
argument_list|,
name|unit
argument_list|,
name|r
operator|->
name|cmd
operator|.
name|targ
argument_list|,
name|r
operator|->
name|cmd
operator|.
name|scb
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|r
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|wdsattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|masunit
decl_stmt|;
specifier|static
name|int
name|firstswitch
index|[
name|NWDS
index|]
decl_stmt|;
specifier|static
name|u_long
name|versprobe
init|=
literal|0
decl_stmt|;
comment|/* max 32 controllers */
name|int
name|r
decl_stmt|;
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
name|masunit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|versprobe
operator|&
operator|(
literal|1
operator|<<
name|masunit
operator|)
operator|)
condition|)
block|{
name|versprobe
operator||=
operator|(
literal|1
operator|<<
name|masunit
operator|)
expr_stmt|;
if|if
condition|(
name|wds_getvers
argument_list|(
name|masunit
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"wds%d: getvers failed\n"
argument_list|,
name|masunit
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"wds%d: using %d bytes for dma buffer\n"
argument_list|,
name|unit
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|wds
index|[
name|unit
index|]
operator|.
name|sc_link
operator|.
name|adapter_unit
operator|=
name|unit
expr_stmt|;
name|wds
index|[
name|unit
index|]
operator|.
name|sc_link
operator|.
name|adapter_targ
operator|=
literal|7
expr_stmt|;
name|wds
index|[
name|unit
index|]
operator|.
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|wds_switch
expr_stmt|;
name|wds
index|[
name|unit
index|]
operator|.
name|sc_link
operator|.
name|device
operator|=
operator|&
name|wds_dev
expr_stmt|;
name|wds
index|[
name|unit
index|]
operator|.
name|sc_link
operator|.
name|flags
operator|=
name|SDEV_BOUNCE
expr_stmt|;
comment|/*    * Prepare the scsibus_data area for the upperlevel    * scsi code.    */
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|wds
index|[
name|unit
index|]
operator|.
name|sc_link
expr_stmt|;
name|kdc_wds
index|[
name|unit
index|]
operator|.
name|kdc_state
operator|=
name|DC_BUSY
expr_stmt|;
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|wds_init
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|wds_setup
name|init
decl_stmt|;
name|int
name|base
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|wds_cmd
name|wc
decl_stmt|;
name|unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
name|base
operator|=
name|wds
index|[
name|unit
index|]
operator|.
name|addr
expr_stmt|;
comment|/*    * Sending a command causes the CMDRDY bit to clear.    */
name|outb
argument_list|(
name|base
operator|+
name|WDS_CMD
argument_list|,
name|WDSC_NOOP
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|base
operator|+
name|WDS_STAT
argument_list|)
operator|&
name|WDS_RDY
condition|)
return|return
literal|1
return|;
comment|/*    * the controller exists. reset and init.    */
name|outb
argument_list|(
name|base
operator|+
name|WDS_HCR
argument_list|,
name|WDSH_ASCRESET
operator||
name|WDSH_SCSIRESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|WDS_HCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|WDS_HCR
argument_list|,
name|WDSH_DRQEN
argument_list|)
expr_stmt|;
name|isa_dmacascade
argument_list|(
name|dev
operator|->
name|id_drq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|base
operator|+
name|WDS_STAT
argument_list|)
operator|&
operator|(
name|WDS_RDY
operator|)
operator|)
operator|!=
name|WDS_RDY
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|base
operator|+
name|WDS_STAT
argument_list|)
operator|&
operator|(
name|WDS_RDY
operator|)
operator|)
operator|==
name|WDS_RDY
condition|)
break|break;
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inb
argument_list|(
name|base
operator|+
name|WDS_STAT
argument_list|)
operator|&
operator|(
name|WDS_RDY
operator|)
operator|)
operator|!=
name|WDS_RDY
condition|)
comment|/* probe timeout */
return|return
literal|1
return|;
block|}
name|bzero
argument_list|(
operator|&
name|init
argument_list|,
sizeof|sizeof
name|init
argument_list|)
expr_stmt|;
name|init
operator|.
name|cmd
operator|=
name|WDSC_INIT
expr_stmt|;
name|init
operator|.
name|scsi_id
operator|=
literal|7
expr_stmt|;
name|init
operator|.
name|buson_t
operator|=
literal|24
expr_stmt|;
name|init
operator|.
name|busoff_t
operator|=
literal|48
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|KVTOPHYS
argument_list|(
name|wds
index|[
name|unit
index|]
operator|.
name|ombs
argument_list|)
argument_list|,
name|init
operator|.
name|mbaddr
argument_list|)
expr_stmt|;
name|init
operator|.
name|xx
operator|=
literal|0
expr_stmt|;
name|init
operator|.
name|nomb
operator|=
name|WDS_NOMB
expr_stmt|;
name|init
operator|.
name|nimb
operator|=
name|WDS_NIMB
expr_stmt|;
name|wds_wait
argument_list|(
name|base
operator|+
name|WDS_STAT
argument_list|,
name|WDS_RDY
argument_list|,
name|WDS_RDY
argument_list|)
expr_stmt|;
if|if
condition|(
name|wds_cmd
argument_list|(
name|base
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|init
argument_list|,
sizeof|sizeof
name|init
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"wds%d: wds_cmd failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|wds_wait
argument_list|(
name|base
operator|+
name|WDS_STAT
argument_list|,
name|WDS_INIT
argument_list|,
name|WDS_INIT
argument_list|)
expr_stmt|;
name|wds_wait
argument_list|(
name|base
operator|+
name|WDS_STAT
argument_list|,
name|WDS_RDY
argument_list|,
name|WDS_RDY
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|wc
argument_list|,
sizeof|sizeof
name|wc
argument_list|)
expr_stmt|;
name|wc
operator|.
name|cmd
operator|=
name|WDSC_DISUNSOL
expr_stmt|;
if|if
condition|(
name|wds_cmd
argument_list|(
name|base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wc
argument_list|,
sizeof|sizeof
name|wc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"wds%d: wds_cmd failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|wds_cmd
parameter_list|(
name|int
name|base
parameter_list|,
name|u_char
modifier|*
name|p
parameter_list|,
name|int
name|l
parameter_list|)
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|u_char
name|c
decl_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
block|{
do|do
block|{
name|outb
argument_list|(
name|base
operator|+
name|WDS_CMD
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|wds_wait
argument_list|(
name|base
operator|+
name|WDS_STAT
argument_list|,
name|WDS_RDY
argument_list|,
name|WDS_RDY
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inb
argument_list|(
name|base
operator|+
name|WDS_STAT
argument_list|)
operator|&
name|WDS_REJ
condition|)
do|;
name|p
operator|++
expr_stmt|;
block|}
name|wds_wait
argument_list|(
name|base
operator|+
name|WDS_STAT
argument_list|,
name|WDS_RDY
argument_list|,
name|WDS_RDY
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|wds_wait
parameter_list|(
name|int
name|reg
parameter_list|,
name|int
name|mask
parameter_list|,
name|int
name|val
parameter_list|)
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
name|reg
argument_list|)
operator|&
name|mask
operator|)
operator|!=
name|val
condition|)
empty_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

