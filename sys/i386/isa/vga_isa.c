begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999 Kazutaka YOKOTA<yokota@zodiac.mech.utsunomiya-u.ac.jp>  * Copyright (c) 1992-1998 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer as  *    the first lines of this file unmodified.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"vga.h"
end_include

begin_include
include|#
directive|include
file|"opt_vga.h"
end_include

begin_include
include|#
directive|include
file|"opt_fb.h"
end_include

begin_include
include|#
directive|include
file|"opt_syscons.h"
end_include

begin_comment
comment|/* should be removed in the future, XXX */
end_comment

begin_if
if|#
directive|if
name|NVGA
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/console.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/bios.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/fbreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/fb/vgareg.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__i386__
end_ifndef

begin_include
include|#
directive|include
file|<isa/isareg.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DRIVER_NAME
value|"vga"
end_define

begin_comment
comment|/* cdev driver declaration */
end_comment

begin_define
define|#
directive|define
name|ISAVGA_UNIT
parameter_list|(
name|dev
parameter_list|)
value|minor(dev)
end_define

begin_define
define|#
directive|define
name|ISAVGA_MKMINOR
parameter_list|(
name|unit
parameter_list|)
value|(unit)
end_define

begin_typedef
typedef|typedef
struct|struct
name|isavga_softc
block|{
name|video_adapter_t
modifier|*
name|adp
decl_stmt|;
block|}
name|isavga_softc_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|__i386__
end_ifndef

begin_define
define|#
directive|define
name|ISAVGA_SOFTC
parameter_list|(
name|unit
parameter_list|)
define|\
value|((isavga_softc_t *)devclass_get_softc(isavga_devclass, unit))
end_define

begin_decl_stmt
name|devclass_t
name|isavga_devclass
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|isavga_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isavga_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|isavga_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|isavga_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|isavga_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|isavga_driver
init|=
block|{
name|DRIVER_NAME
block|,
name|isavga_methods
block|,
name|DRIVER_TYPE_TTY
block|,
sizeof|sizeof
argument_list|(
name|isavga_softc_t
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __i386__ */
end_comment

begin_define
define|#
directive|define
name|ISAVGA_SOFTC
parameter_list|(
name|unit
parameter_list|)
value|(isavga_softc[unit])
end_define

begin_decl_stmt
specifier|static
name|isavga_softc_t
modifier|*
name|isavga_softc
index|[
name|NVGA
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|isavga_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isavga_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|vgadriver
init|=
block|{
name|isavga_probe
block|,
name|isavga_attach
block|,
name|DRIVER_NAME
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ */
end_comment

begin_function_decl
specifier|static
name|int
name|isavga_probe_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|isavga_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isavga_attach_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|isavga_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|FB_INSTALL_CDEV
end_ifdef

begin_decl_stmt
specifier|static
name|d_open_t
name|isavgaopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|isavgaclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|isavgaread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|isavgaioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|vga_cdevsw
init|=
block|{
name|isavgaopen
block|,
name|isavgaclose
block|,
name|noread
block|,
name|nowrite
block|,
comment|/* ?? */
name|isavgaioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|seltrue
block|,
name|nommap
block|,
name|NULL
block|,
name|DRIVER_NAME
block|,
name|NULL
block|,
operator|-
literal|1
block|,
name|nodump
block|,
name|nopsize
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FB_INSTALL_CDEV */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__i386__
end_ifndef

begin_function
specifier|static
name|int
name|isavga_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|isavga_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|isavga_probe_unit
argument_list|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|,
name|isa_get_flags
argument_list|(
name|dev
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isavga_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|isavga_softc_t
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|isavga_attach_unit
argument_list|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
argument_list|,
name|isa_get_flags
argument_list|(
name|dev
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* __i386__ */
end_comment

begin_function
specifier|static
name|int
name|isavga_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|isavga_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_unit
operator|>=
sizeof|sizeof
argument_list|(
name|isavga_softc
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|isavga_softc
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|sc
operator|=
name|isavga_softc
index|[
name|dev
operator|->
name|id_unit
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|error
operator|=
name|isavga_probe_unit
argument_list|(
name|dev
operator|->
name|id_unit
argument_list|,
name|sc
argument_list|,
name|dev
operator|->
name|id_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|isavga_softc
index|[
name|dev
operator|->
name|id_unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dev
operator|->
name|id_iobase
operator|=
name|sc
operator|->
name|adp
operator|->
name|va_io_base
expr_stmt|;
name|dev
operator|->
name|id_maddr
operator|=
operator|(
name|caddr_t
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|sc
operator|->
name|adp
operator|->
name|va_mem_base
argument_list|)
expr_stmt|;
name|dev
operator|->
name|id_msize
operator|=
name|sc
operator|->
name|adp
operator|->
name|va_mem_size
expr_stmt|;
return|return
name|sc
operator|->
name|adp
operator|->
name|va_io_size
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isavga_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|isavga_softc_t
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_unit
operator|>=
sizeof|sizeof
argument_list|(
name|isavga_softc
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|isavga_softc
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
name|sc
operator|=
name|isavga_softc
index|[
name|dev
operator|->
name|id_unit
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|(
name|isavga_attach_unit
argument_list|(
name|dev
operator|->
name|id_unit
argument_list|,
name|sc
argument_list|,
name|dev
operator|->
name|id_flags
argument_list|)
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ */
end_comment

begin_function
specifier|static
name|int
name|isavga_probe_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|isavga_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|video_switch_t
modifier|*
name|sw
decl_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|sw
operator|=
name|vid_get_switch
argument_list|(
name|DRIVER_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
call|(
modifier|*
name|sw
operator|->
name|probe
call|)
argument_list|(
name|unit
argument_list|,
operator|&
name|sc
operator|->
name|adp
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isavga_attach_unit
parameter_list|(
name|int
name|unit
parameter_list|,
name|isavga_softc_t
modifier|*
name|sc
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|video_switch_t
modifier|*
name|sw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sw
operator|=
name|vid_get_switch
argument_list|(
name|DRIVER_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|sw
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|error
operator|=
call|(
modifier|*
name|sw
operator|->
name|init
call|)
argument_list|(
name|unit
argument_list|,
name|sc
operator|->
name|adp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|ENXIO
return|;
ifdef|#
directive|ifdef
name|FB_INSTALL_CDEV
comment|/* attach a virtual frame buffer device */
name|error
operator|=
name|fb_attach
argument_list|(
name|makedev
argument_list|(
literal|0
argument_list|,
name|ISAVGA_MKMINOR
argument_list|(
name|unit
argument_list|)
argument_list|)
argument_list|,
name|scp
operator|->
name|adp
argument_list|,
operator|&
name|vga_cdevsw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
endif|#
directive|endif
comment|/* FB_INSTALL_CDEV */
if|if
condition|(
name|bootverbose
condition|)
operator|(
operator|*
name|vidsw
index|[
name|sc
operator|->
name|adp
operator|->
name|va_index
index|]
operator|->
name|diag
operator|)
operator|(
name|sc
operator|->
name|adp
operator|,
name|bootverbose
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* LOW-LEVEL */
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/vesa.h>
end_include

begin_define
define|#
directive|define
name|probe_done
parameter_list|(
name|adp
parameter_list|)
value|((adp)->va_flags& V_ADP_PROBED)
end_define

begin_define
define|#
directive|define
name|init_done
parameter_list|(
name|adp
parameter_list|)
value|((adp)->va_flags& V_ADP_INITIALIZED)
end_define

begin_define
define|#
directive|define
name|config_done
parameter_list|(
name|adp
parameter_list|)
value|((adp)->va_flags& V_ADP_REGISTERED)
end_define

begin_comment
comment|/* for compatibility with old kernel options */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SC_ALT_SEQACCESS
end_ifdef

begin_undef
undef|#
directive|undef
name|SC_ALT_SEQACCESS
end_undef

begin_undef
undef|#
directive|undef
name|VGA_ALT_SEQACCESS
end_undef

begin_define
define|#
directive|define
name|VGA_ALT_SEQACCESS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SLOW_VGA
end_ifdef

begin_undef
undef|#
directive|undef
name|SLOW_VGA
end_undef

begin_undef
undef|#
directive|undef
name|VGA_SLOW_IOACCESS
end_undef

begin_define
define|#
directive|define
name|VGA_SLOW_IOACCESS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* architecture dependent option */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_define
define|#
directive|define
name|VGA_NO_BIOS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* this should really be in `rtc.h' */
end_comment

begin_define
define|#
directive|define
name|RTC_EQUIPMENT
value|0x14
end_define

begin_comment
comment|/* various sizes */
end_comment

begin_define
define|#
directive|define
name|V_MODE_MAP_SIZE
value|(M_VGA_CG320 + 1)
end_define

begin_define
define|#
directive|define
name|V_MODE_PARAM_SIZE
value|64
end_define

begin_comment
comment|/* video adapter state buffer */
end_comment

begin_struct
struct|struct
name|adp_state
block|{
name|int
name|sig
decl_stmt|;
define|#
directive|define
name|V_STATE_SIG
value|0x736f6962
name|u_char
name|regs
index|[
name|V_MODE_PARAM_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|adp_state
name|adp_state_t
typedef|;
end_typedef

begin_comment
comment|/* video adapter information */
end_comment

begin_define
define|#
directive|define
name|DCC_MONO
value|0
end_define

begin_define
define|#
directive|define
name|DCC_CGA40
value|1
end_define

begin_define
define|#
directive|define
name|DCC_CGA80
value|2
end_define

begin_define
define|#
directive|define
name|DCC_EGAMONO
value|3
end_define

begin_define
define|#
directive|define
name|DCC_EGA40
value|4
end_define

begin_define
define|#
directive|define
name|DCC_EGA80
value|5
end_define

begin_comment
comment|/*   * NOTE: `va_window' should have a virtual address, but is initialized  * with a physical address in the following table, as verify_adapter()  * will perform address conversion at run-time.  */
end_comment

begin_decl_stmt
specifier|static
name|video_adapter_t
name|adapter_init_value
index|[]
init|=
block|{
comment|/* DCC_MONO */
block|{
literal|0
block|,
name|KD_MONO
block|,
literal|"mda"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|IO_MDA
block|,
name|IO_MDASIZE
block|,
name|MONO_CRTC
block|,
name|MDA_BUF_BASE
block|,
name|MDA_BUF_SIZE
block|,
name|MDA_BUF_BASE
block|,
name|MDA_BUF_SIZE
block|,
name|MDA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|, }
block|,
comment|/* DCC_CGA40 */
block|{
literal|0
block|,
name|KD_CGA
block|,
literal|"cga"
block|,
literal|0
block|,
literal|0
block|,
name|V_ADP_COLOR
block|,
name|IO_CGA
block|,
name|IO_CGASIZE
block|,
name|COLOR_CRTC
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|, }
block|,
comment|/* DCC_CGA80 */
block|{
literal|0
block|,
name|KD_CGA
block|,
literal|"cga"
block|,
literal|0
block|,
literal|0
block|,
name|V_ADP_COLOR
block|,
name|IO_CGA
block|,
name|IO_CGASIZE
block|,
name|COLOR_CRTC
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|, }
block|,
comment|/* DCC_EGAMONO */
block|{
literal|0
block|,
name|KD_EGA
block|,
literal|"ega"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|IO_MDA
block|,
literal|48
block|,
name|MONO_CRTC
block|,
name|EGA_BUF_BASE
block|,
name|EGA_BUF_SIZE
block|,
name|MDA_BUF_BASE
block|,
name|MDA_BUF_SIZE
block|,
name|MDA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|, }
block|,
comment|/* DCC_EGA40 */
block|{
literal|0
block|,
name|KD_EGA
block|,
literal|"ega"
block|,
literal|0
block|,
literal|0
block|,
name|V_ADP_COLOR
block|,
name|IO_MDA
block|,
literal|48
block|,
name|COLOR_CRTC
block|,
name|EGA_BUF_BASE
block|,
name|EGA_BUF_SIZE
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|, }
block|,
comment|/* DCC_EGA80 */
block|{
literal|0
block|,
name|KD_EGA
block|,
literal|"ega"
block|,
literal|0
block|,
literal|0
block|,
name|V_ADP_COLOR
block|,
name|IO_MDA
block|,
literal|48
block|,
name|COLOR_CRTC
block|,
name|EGA_BUF_BASE
block|,
name|EGA_BUF_SIZE
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|, }
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|video_adapter_t
name|biosadapter
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|biosadapters
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* video driver declarations */
end_comment

begin_function_decl
specifier|static
name|int
name|vga_configure
parameter_list|(
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|vga_sub_configure
function_decl|)
parameter_list|(
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vga_nop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|vi_probe_t
name|vga_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_init_t
name|vga_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_get_info_t
name|vga_get_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_query_mode_t
name|vga_query_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_mode_t
name|vga_set_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_save_font_t
name|vga_save_font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_load_font_t
name|vga_load_font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_show_font_t
name|vga_show_font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_save_palette_t
name|vga_save_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_load_palette_t
name|vga_load_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_border_t
name|vga_set_border
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_save_state_t
name|vga_save_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_load_state_t
name|vga_load_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_win_org_t
name|vga_set_origin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_read_hw_cursor_t
name|vga_read_hw_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_hw_cursor_t
name|vga_set_hw_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_hw_cursor_shape_t
name|vga_set_hw_cursor_shape
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_mmap_t
name|vga_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_diag_t
name|vga_diag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|video_switch_t
name|vgavidsw
init|=
block|{
name|vga_probe
block|,
name|vga_init
block|,
name|vga_get_info
block|,
name|vga_query_mode
block|,
name|vga_set_mode
block|,
name|vga_save_font
block|,
name|vga_load_font
block|,
name|vga_show_font
block|,
name|vga_save_palette
block|,
name|vga_load_palette
block|,
name|vga_set_border
block|,
name|vga_save_state
block|,
name|vga_load_state
block|,
name|vga_set_origin
block|,
name|vga_read_hw_cursor
block|,
name|vga_set_hw_cursor
block|,
name|vga_set_hw_cursor_shape
block|,
operator|(
name|vi_blank_display_t
operator|*
operator|)
name|vga_nop
block|,
name|vga_mmap
block|,
name|vga_diag
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VIDEO_DRIVER
argument_list|(
name|mda
argument_list|,
name|vgavidsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VIDEO_DRIVER
argument_list|(
name|cga
argument_list|,
name|vgavidsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VIDEO_DRIVER
argument_list|(
name|ega
argument_list|,
name|vgavidsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VIDEO_DRIVER
argument_list|(
name|vga
argument_list|,
name|vgavidsw
argument_list|,
name|vga_configure
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* VGA BIOS standard video modes */
end_comment

begin_define
define|#
directive|define
name|EOT
value|(-1)
end_define

begin_define
define|#
directive|define
name|NA
value|(-2)
end_define

begin_decl_stmt
specifier|static
name|video_info_t
name|bios_vmode
index|[]
init|=
block|{
comment|/* CGA */
block|{
name|M_B40x25
block|,
name|V_INFO_COLOR
block|,
literal|40
block|,
literal|25
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_C40x25
block|,
name|V_INFO_COLOR
block|,
literal|40
block|,
literal|25
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_B80x25
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_C80x25
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* EGA */
block|{
name|M_ENH_B40x25
block|,
name|V_INFO_COLOR
block|,
literal|40
block|,
literal|25
block|,
literal|8
block|,
literal|14
block|,
literal|2
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_ENH_C40x25
block|,
name|V_INFO_COLOR
block|,
literal|40
block|,
literal|25
block|,
literal|8
block|,
literal|14
block|,
literal|4
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_ENH_B80x25
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|14
block|,
literal|2
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_ENH_C80x25
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|14
block|,
literal|4
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* VGA */
block|{
name|M_VGA_C40x25
block|,
name|V_INFO_COLOR
block|,
literal|40
block|,
literal|25
block|,
literal|8
block|,
literal|16
block|,
literal|4
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_VGA_M80x25
block|,
literal|0
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|16
block|,
literal|2
block|,
literal|1
block|,
name|MDA_BUF_BASE
block|,
name|MDA_BUF_SIZE
block|,
name|MDA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_VGA_C80x25
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|16
block|,
literal|4
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* MDA */
block|{
name|M_EGAMONO80x25
block|,
literal|0
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|14
block|,
literal|2
block|,
literal|1
block|,
name|MDA_BUF_BASE
block|,
name|MDA_BUF_SIZE
block|,
name|MDA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* EGA */
block|{
name|M_ENH_B80x43
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|43
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_ENH_C80x43
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|43
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* VGA */
block|{
name|M_VGA_M80x30
block|,
literal|0
block|,
literal|80
block|,
literal|30
block|,
literal|8
block|,
literal|16
block|,
literal|2
block|,
literal|1
block|,
name|MDA_BUF_BASE
block|,
name|MDA_BUF_SIZE
block|,
name|MDA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_VGA_C80x30
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|30
block|,
literal|8
block|,
literal|16
block|,
literal|4
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_VGA_M80x50
block|,
literal|0
block|,
literal|80
block|,
literal|50
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
name|MDA_BUF_BASE
block|,
name|MDA_BUF_SIZE
block|,
name|MDA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_VGA_C80x50
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|50
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_VGA_M80x60
block|,
literal|0
block|,
literal|80
block|,
literal|60
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
name|MDA_BUF_BASE
block|,
name|MDA_BUF_SIZE
block|,
name|MDA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_VGA_C80x60
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|60
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
ifndef|#
directive|ifndef
name|VGA_NO_MODE_CHANGE
comment|/* CGA */
block|{
name|M_BG320
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|320
block|,
literal|200
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_CG320
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|320
block|,
literal|200
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_BG640
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|200
block|,
literal|8
block|,
literal|8
block|,
literal|1
block|,
literal|1
block|,
name|CGA_BUF_BASE
block|,
name|CGA_BUF_SIZE
block|,
name|CGA_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* EGA */
block|{
name|M_CG320_D
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|320
block|,
literal|200
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
name|GRAPHICS_BUF_BASE
block|,
name|GRAPHICS_BUF_SIZE
block|,
name|GRAPHICS_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_CG640_E
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|200
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
name|GRAPHICS_BUF_BASE
block|,
name|GRAPHICS_BUF_SIZE
block|,
name|GRAPHICS_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_EGAMONOAPA
block|,
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|350
block|,
literal|8
block|,
literal|14
block|,
literal|4
block|,
literal|4
block|,
name|GRAPHICS_BUF_BASE
block|,
name|GRAPHICS_BUF_SIZE
block|,
literal|64
operator|*
literal|1024
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_ENHMONOAPA2
block|,
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|350
block|,
literal|8
block|,
literal|14
block|,
literal|4
block|,
literal|4
block|,
name|GRAPHICS_BUF_BASE
block|,
name|GRAPHICS_BUF_SIZE
block|,
name|GRAPHICS_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_CG640x350
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|350
block|,
literal|8
block|,
literal|14
block|,
literal|2
block|,
literal|2
block|,
name|GRAPHICS_BUF_BASE
block|,
name|GRAPHICS_BUF_SIZE
block|,
name|GRAPHICS_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_ENH_CG640
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|350
block|,
literal|8
block|,
literal|14
block|,
literal|4
block|,
literal|4
block|,
name|GRAPHICS_BUF_BASE
block|,
name|GRAPHICS_BUF_SIZE
block|,
name|GRAPHICS_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* VGA */
block|{
name|M_BG640x480
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|480
block|,
literal|8
block|,
literal|16
block|,
literal|4
block|,
literal|4
block|,
name|GRAPHICS_BUF_BASE
block|,
name|GRAPHICS_BUF_SIZE
block|,
name|GRAPHICS_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_CG640x480
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|480
block|,
literal|8
block|,
literal|16
block|,
literal|4
block|,
literal|4
block|,
name|GRAPHICS_BUF_BASE
block|,
name|GRAPHICS_BUF_SIZE
block|,
name|GRAPHICS_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_VGA_CG320
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|320
block|,
literal|200
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|1
block|,
name|GRAPHICS_BUF_BASE
block|,
name|GRAPHICS_BUF_SIZE
block|,
name|GRAPHICS_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
name|M_VGA_MODEX
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|320
block|,
literal|240
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
name|GRAPHICS_BUF_BASE
block|,
name|GRAPHICS_BUF_SIZE
block|,
name|GRAPHICS_BUF_SIZE
block|,
literal|0
block|,
literal|0
block|}
block|,
endif|#
directive|endif
comment|/* VGA_NO_MODE_CHANGE */
block|{
name|EOT
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_done
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|video_mode_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EGA/VGA */
end_comment

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|video_mode_ptr2
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CGA/MDA */
end_comment

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|mode_map
index|[
name|V_MODE_MAP_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|adp_state_t
name|adpstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|adp_state_t
name|adpstate2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rows_offset
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local macros and functions */
end_comment

begin_define
define|#
directive|define
name|BIOS_SADDRTOLADDR
parameter_list|(
name|p
parameter_list|)
value|((((p)& 0xffff0000)>> 12) + ((p)& 0x0000ffff))
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VGA_NO_BIOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VGA_NO_MODE_CHANGE
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|map_mode_table
parameter_list|(
name|u_char
modifier|*
name|map
index|[]
parameter_list|,
name|u_char
modifier|*
name|table
parameter_list|,
name|int
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|clear_mode_map
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|map
index|[]
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|color
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VGA_NO_BIOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VGA_NO_MODE_CHANGE
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|map_mode_num
parameter_list|(
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|map_gen_mode_num
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|color
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|map_bios_mode_num
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|color
parameter_list|,
name|int
name|bios_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
modifier|*
name|get_mode_param
parameter_list|(
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|VGA_NO_BIOS
end_ifndef

begin_function_decl
specifier|static
name|void
name|fill_adapter_param
parameter_list|(
name|int
name|code
parameter_list|,
name|video_adapter_t
modifier|*
name|adp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|verify_adapter
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_adapter_info
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_info_t
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VGA_NO_BIOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VGA_NO_MODE_CHANGE
argument_list|)
end_if

begin_define
define|#
directive|define
name|COMP_IDENTICAL
value|0
end_define

begin_define
define|#
directive|define
name|COMP_SIMILAR
value|1
end_define

begin_define
define|#
directive|define
name|COMP_DIFFERENT
value|2
end_define

begin_function_decl
specifier|static
name|int
name|comp_adpregs
parameter_list|(
name|u_char
modifier|*
name|buf1
parameter_list|,
name|u_char
modifier|*
name|buf2
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|probe_adapters
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PARAM_BUFSIZE
value|6
end_define

begin_function_decl
specifier|static
name|void
name|set_font_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_normal_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_buffer
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ISMAPPED
parameter_list|(
name|pa
parameter_list|,
name|width
parameter_list|)
define|\
value|(((pa)<= (u_long)0x1000 - (width)) 		\ 	 || ((pa)>= ISA_HOLE_START&& (pa)<= 0x100000 - (width)))
end_define

begin_define
define|#
directive|define
name|prologue
parameter_list|(
name|adp
parameter_list|,
name|flag
parameter_list|,
name|err
parameter_list|)
define|\
value|if (!init_done || !((adp)->va_flags& (flag)))	\ 	    return (err)
end_define

begin_comment
comment|/* a backdoor for the console driver */
end_comment

begin_function
specifier|static
name|int
name|vga_configure
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|probe_adapters
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|biosadapters
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|probe_done
argument_list|(
operator|&
name|biosadapter
index|[
name|i
index|]
argument_list|)
condition|)
continue|continue;
name|biosadapter
index|[
name|i
index|]
operator|.
name|va_flags
operator||=
name|V_ADP_INITIALIZED
expr_stmt|;
if|if
condition|(
operator|!
name|config_done
argument_list|(
operator|&
name|biosadapter
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|vid_register
argument_list|(
operator|&
name|biosadapter
index|[
name|i
index|]
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
name|biosadapter
index|[
name|i
index|]
operator|.
name|va_flags
operator||=
name|V_ADP_REGISTERED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vga_sub_configure
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|vga_sub_configure
call|)
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|biosadapters
return|;
block|}
end_function

begin_comment
comment|/* local subroutines */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VGA_NO_BIOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VGA_NO_MODE_CHANGE
argument_list|)
end_if

begin_comment
comment|/* construct the mode parameter map */
end_comment

begin_function
specifier|static
name|void
name|map_mode_table
parameter_list|(
name|u_char
modifier|*
name|map
index|[]
parameter_list|,
name|u_char
modifier|*
name|table
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
name|map
index|[
name|i
index|]
operator|=
name|table
operator|+
name|i
operator|*
name|V_MODE_PARAM_SIZE
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|V_MODE_MAP_SIZE
condition|;
operator|++
name|i
control|)
name|map
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !VGA_NO_BIOS&& !VGA_NO_MODE_CHANGE */
end_comment

begin_function
specifier|static
name|void
name|clear_mode_map
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|map
index|[]
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|color
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * NOTE: we don't touch `bios_vmode[]' because it is shared      * by all adapters.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|vga_get_info
argument_list|(
name|adp
argument_list|,
name|i
argument_list|,
operator|&
name|info
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_COLOR
operator|)
operator|!=
name|color
condition|)
name|map
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VGA_NO_BIOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VGA_NO_MODE_CHANGE
argument_list|)
end_if

begin_comment
comment|/* map the non-standard video mode to a known mode number */
end_comment

begin_function
specifier|static
name|int
name|map_mode_num
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
block|}
name|mode_map
index|[]
init|=
block|{
block|{
name|M_ENH_B80x43
block|,
name|M_ENH_B80x25
block|}
block|,
block|{
name|M_ENH_C80x43
block|,
name|M_ENH_C80x25
block|}
block|,
block|{
name|M_VGA_M80x30
block|,
name|M_VGA_M80x25
block|}
block|,
block|{
name|M_VGA_C80x30
block|,
name|M_VGA_C80x25
block|}
block|,
block|{
name|M_VGA_M80x50
block|,
name|M_VGA_M80x25
block|}
block|,
block|{
name|M_VGA_C80x50
block|,
name|M_VGA_C80x25
block|}
block|,
block|{
name|M_VGA_M80x60
block|,
name|M_VGA_M80x25
block|}
block|,
block|{
name|M_VGA_C80x60
block|,
name|M_VGA_C80x25
block|}
block|,
block|{
name|M_VGA_MODEX
block|,
name|M_VGA_CG320
block|}
block|,     }
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mode_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mode_map
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mode_map
index|[
name|i
index|]
operator|.
name|from
operator|==
name|mode
condition|)
return|return
name|mode_map
index|[
name|i
index|]
operator|.
name|to
return|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !VGA_NO_BIOS&& !VGA_NO_MODE_CHANGE */
end_comment

begin_comment
comment|/* map a generic video mode to a known mode number */
end_comment

begin_function
specifier|static
name|int
name|map_gen_mode_num
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|color
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|from
decl_stmt|;
name|int
name|to_color
decl_stmt|;
name|int
name|to_mono
decl_stmt|;
block|}
name|mode_map
index|[]
init|=
block|{
block|{
name|M_TEXT_80x30
block|,
name|M_VGA_C80x30
block|,
name|M_VGA_M80x30
block|, }
block|,
block|{
name|M_TEXT_80x43
block|,
name|M_ENH_C80x43
block|,
name|M_ENH_B80x43
block|, }
block|,
block|{
name|M_TEXT_80x50
block|,
name|M_VGA_C80x50
block|,
name|M_VGA_M80x50
block|, }
block|,
block|{
name|M_TEXT_80x60
block|,
name|M_VGA_C80x60
block|,
name|M_VGA_M80x60
block|, }
block|,     }
struct|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|M_TEXT_80x25
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|KD_VGA
case|:
if|if
condition|(
name|color
condition|)
return|return
name|M_VGA_C80x25
return|;
else|else
return|return
name|M_VGA_M80x25
return|;
break|break;
case|case
name|KD_EGA
case|:
if|if
condition|(
name|color
condition|)
return|return
name|M_ENH_C80x25
return|;
else|else
return|return
name|M_EGAMONO80x25
return|;
break|break;
case|case
name|KD_CGA
case|:
return|return
name|M_C80x25
return|;
case|case
name|KD_MONO
case|:
case|case
name|KD_HERCULES
case|:
return|return
name|M_EGAMONO80x25
return|;
comment|/* XXX: this name is confusing */
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mode_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mode_map
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mode_map
index|[
name|i
index|]
operator|.
name|from
operator|==
name|mode
condition|)
return|return
operator|(
operator|(
name|color
operator|)
condition|?
name|mode_map
index|[
name|i
index|]
operator|.
name|to_color
else|:
name|mode_map
index|[
name|i
index|]
operator|.
name|to_mono
operator|)
return|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_comment
comment|/* turn the BIOS video number into our video mode number */
end_comment

begin_function
specifier|static
name|int
name|map_bios_mode_num
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|color
parameter_list|,
name|int
name|bios_mode
parameter_list|)
block|{
specifier|static
name|int
name|cga_modes
index|[
literal|7
index|]
init|=
block|{
name|M_B40x25
block|,
name|M_C40x25
block|,
comment|/* 0, 1 */
name|M_B80x25
block|,
name|M_C80x25
block|,
comment|/* 2, 3 */
name|M_BG320
block|,
name|M_CG320
block|,
name|M_BG640
block|,     }
decl_stmt|;
specifier|static
name|int
name|ega_modes
index|[
literal|17
index|]
init|=
block|{
name|M_ENH_B40x25
block|,
name|M_ENH_C40x25
block|,
comment|/* 0, 1 */
name|M_ENH_B80x25
block|,
name|M_ENH_C80x25
block|,
comment|/* 2, 3 */
name|M_BG320
block|,
name|M_CG320
block|,
name|M_BG640
block|,
name|M_EGAMONO80x25
block|,
comment|/* 7 */
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
name|M_CG320_D
block|,
name|M_CG640_E
block|,
name|M_ENHMONOAPA2
block|,
comment|/* XXX: video momery> 64K */
name|M_ENH_CG640
block|,
comment|/* XXX: video momery> 64K */
block|}
decl_stmt|;
specifier|static
name|int
name|vga_modes
index|[
literal|20
index|]
init|=
block|{
name|M_VGA_C40x25
block|,
name|M_VGA_C40x25
block|,
comment|/* 0, 1 */
name|M_VGA_C80x25
block|,
name|M_VGA_C80x25
block|,
comment|/* 2, 3 */
name|M_BG320
block|,
name|M_CG320
block|,
name|M_BG640
block|,
name|M_VGA_M80x25
block|,
comment|/* 7 */
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
name|M_CG320_D
block|,
name|M_CG640_E
block|,
name|M_ENHMONOAPA2
block|,
name|M_ENH_CG640
block|,
name|M_BG640x480
block|,
name|M_CG640x480
block|,
name|M_VGA_CG320
block|,     }
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|KD_VGA
case|:
if|if
condition|(
name|bios_mode
operator|<
sizeof|sizeof
argument_list|(
name|vga_modes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|vga_modes
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|vga_modes
index|[
name|bios_mode
index|]
return|;
elseif|else
if|if
condition|(
name|color
condition|)
return|return
name|M_VGA_C80x25
return|;
else|else
return|return
name|M_VGA_M80x25
return|;
break|break;
case|case
name|KD_EGA
case|:
if|if
condition|(
name|bios_mode
operator|<
sizeof|sizeof
argument_list|(
name|ega_modes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ega_modes
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|ega_modes
index|[
name|bios_mode
index|]
return|;
elseif|else
if|if
condition|(
name|color
condition|)
return|return
name|M_ENH_C80x25
return|;
else|else
return|return
name|M_EGAMONO80x25
return|;
break|break;
case|case
name|KD_CGA
case|:
if|if
condition|(
name|bios_mode
operator|<
sizeof|sizeof
argument_list|(
name|cga_modes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|cga_modes
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|cga_modes
index|[
name|bios_mode
index|]
return|;
else|else
return|return
name|M_C80x25
return|;
break|break;
case|case
name|KD_MONO
case|:
case|case
name|KD_HERCULES
case|:
return|return
name|M_EGAMONO80x25
return|;
comment|/* XXX: this name is confusing */
default|default:
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* look up a parameter table entry */
end_comment

begin_function
specifier|static
name|u_char
modifier|*
name|get_mode_param
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VGA_NO_BIOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VGA_NO_MODE_CHANGE
argument_list|)
if|if
condition|(
name|mode
operator|>=
name|V_MODE_MAP_SIZE
condition|)
name|mode
operator|=
name|map_mode_num
argument_list|(
name|mode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|mode
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|mode
operator|<
name|V_MODE_MAP_SIZE
operator|)
condition|)
return|return
name|mode_map
index|[
name|mode
index|]
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|VGA_NO_BIOS
end_ifndef

begin_function
specifier|static
name|void
name|fill_adapter_param
parameter_list|(
name|int
name|code
parameter_list|,
name|video_adapter_t
modifier|*
name|adp
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|primary
decl_stmt|;
name|int
name|secondary
decl_stmt|;
block|}
name|dcc
index|[]
init|=
block|{
block|{
name|DCC_MONO
block|,
name|DCC_EGA40
comment|/* CGA monitor */
block|}
block|,
block|{
name|DCC_MONO
block|,
name|DCC_EGA80
comment|/* CGA monitor */
block|}
block|,
block|{
name|DCC_MONO
block|,
name|DCC_EGA80
comment|/* CGA emulation */
block|}
block|,
block|{
name|DCC_MONO
block|,
name|DCC_EGA80
block|}
block|,
block|{
name|DCC_CGA40
block|,
name|DCC_EGAMONO
block|}
block|,
block|{
name|DCC_CGA80
block|,
name|DCC_EGAMONO
block|}
block|,
block|{
name|DCC_EGA40
comment|/* CGA monitor */
block|,
name|DCC_MONO
block|}
block|,
block|{
name|DCC_EGA80
comment|/* CGA monitor */
block|,
name|DCC_MONO
block|}
block|,
block|{
name|DCC_EGA80
comment|/* CGA emulation */
block|,
name|DCC_MONO
block|}
block|,
block|{
name|DCC_EGA80
block|,
name|DCC_MONO
block|}
block|,
block|{
name|DCC_EGAMONO
block|,
name|DCC_CGA40
block|}
block|,
block|{
name|DCC_EGAMONO
block|,
name|DCC_CGA40
block|}
block|,     }
struct|;
if|if
condition|(
operator|(
name|code
operator|<
literal|0
operator|)
operator|||
operator|(
name|code
operator|>=
sizeof|sizeof
argument_list|(
name|dcc
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dcc
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|adp
index|[
name|V_ADP_PRIMARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_MONO
index|]
expr_stmt|;
name|adp
index|[
name|V_ADP_SECONDARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_CGA80
index|]
expr_stmt|;
block|}
else|else
block|{
name|adp
index|[
name|V_ADP_PRIMARY
index|]
operator|=
name|adapter_init_value
index|[
name|dcc
index|[
name|code
index|]
operator|.
name|primary
index|]
expr_stmt|;
name|adp
index|[
name|V_ADP_SECONDARY
index|]
operator|=
name|adapter_init_value
index|[
name|dcc
index|[
name|code
index|]
operator|.
name|secondary
index|]
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VGA_NO_BIOS */
end_comment

begin_function
specifier|static
name|int
name|verify_adapter
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|)
block|{
specifier|volatile
name|u_int16_t
modifier|*
name|buf
decl_stmt|;
name|u_int16_t
name|v
decl_stmt|;
name|u_int32_t
name|p
decl_stmt|;
name|buf
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|adp
operator|->
name|va_window
argument_list|)
expr_stmt|;
name|v
operator|=
name|readw
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|writew
argument_list|(
name|buf
argument_list|,
literal|0xA55A
argument_list|)
expr_stmt|;
if|if
condition|(
name|readw
argument_list|(
name|buf
argument_list|)
operator|!=
literal|0xA55A
condition|)
return|return
literal|1
return|;
name|writew
argument_list|(
name|buf
argument_list|,
name|v
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|adp
operator|->
name|va_type
condition|)
block|{
case|case
name|KD_EGA
case|:
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|)
operator|==
literal|7
condition|)
block|{
name|adp
operator|->
name|va_type
operator|=
name|KD_VGA
expr_stmt|;
name|adp
operator|->
name|va_name
operator|=
literal|"vga"
expr_stmt|;
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_STATESAVE
operator||
name|V_ADP_PALETTE
expr_stmt|;
block|}
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_STATELOAD
operator||
name|V_ADP_BORDER
expr_stmt|;
comment|/* the color adapter may be in the 40x25 mode... XXX */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VGA_NO_BIOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VGA_NO_MODE_CHANGE
argument_list|)
comment|/* get the BIOS video mode pointer */
name|p
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x4a8
argument_list|)
expr_stmt|;
name|p
operator|=
name|BIOS_SADDRTOLADDR
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISMAPPED
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
condition|)
block|{
name|p
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|BIOS_SADDRTOLADDR
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISMAPPED
argument_list|(
name|p
argument_list|,
name|V_MODE_PARAM_SIZE
argument_list|)
condition|)
name|video_mode_ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|KD_CGA
case|:
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_COLOR
operator||
name|V_ADP_BORDER
expr_stmt|;
comment|/* may be in the 40x25 mode... XXX */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VGA_NO_BIOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VGA_NO_MODE_CHANGE
argument_list|)
comment|/* get the BIOS video mode pointer */
name|p
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x1d
operator|*
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|BIOS_SADDRTOLADDR
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|video_mode_ptr2
operator|=
operator|(
name|u_char
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|KD_MONO
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VGA_NO_BIOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VGA_NO_MODE_CHANGE
argument_list|)
comment|/* get the BIOS video mode pointer */
name|p
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x1d
operator|*
literal|4
argument_list|)
expr_stmt|;
name|p
operator|=
name|BIOS_SADDRTOLADDR
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|video_mode_ptr2
operator|=
operator|(
name|u_char
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_adapter_info
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_info_t
modifier|*
name|info
parameter_list|)
block|{
name|adp
operator|->
name|va_flags
operator|&=
operator|~
name|V_ADP_COLOR
expr_stmt|;
name|adp
operator|->
name|va_flags
operator||=
operator|(
name|info
operator|->
name|vi_flags
operator|&
name|V_INFO_COLOR
operator|)
condition|?
name|V_ADP_COLOR
else|:
literal|0
expr_stmt|;
name|adp
operator|->
name|va_crtc_addr
operator|=
operator|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
name|COLOR_CRTC
else|:
name|MONO_CRTC
expr_stmt|;
name|adp
operator|->
name|va_window
operator|=
name|BIOS_PADDRTOVADDR
argument_list|(
name|info
operator|->
name|vi_window
argument_list|)
expr_stmt|;
name|adp
operator|->
name|va_window_size
operator|=
name|info
operator|->
name|vi_window_size
expr_stmt|;
name|adp
operator|->
name|va_window_gran
operator|=
name|info
operator|->
name|vi_window_gran
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vi_buffer_size
operator|==
literal|0
condition|)
block|{
name|adp
operator|->
name|va_buffer
operator|=
literal|0
expr_stmt|;
name|adp
operator|->
name|va_buffer_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|adp
operator|->
name|va_buffer
operator|=
name|BIOS_PADDRTOVADDR
argument_list|(
name|info
operator|->
name|vi_buffer
argument_list|)
expr_stmt|;
name|adp
operator|->
name|va_buffer_size
operator|=
name|info
operator|->
name|vi_buffer_size
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|vi_mode
operator|==
name|M_VGA_MODEX
condition|)
block|{
name|adp
operator|->
name|va_line_width
operator|=
name|info
operator|->
name|vi_width
operator|/
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|->
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
block|{
switch|switch
condition|(
name|info
operator|->
name|vi_depth
operator|/
name|info
operator|->
name|vi_planes
condition|)
block|{
case|case
literal|1
case|:
name|adp
operator|->
name|va_line_width
operator|=
name|info
operator|->
name|vi_width
operator|/
literal|8
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|adp
operator|->
name|va_line_width
operator|=
name|info
operator|->
name|vi_width
operator|/
literal|4
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|adp
operator|->
name|va_line_width
operator|=
name|info
operator|->
name|vi_width
operator|/
literal|2
expr_stmt|;
break|break;
case|case
literal|8
case|:
default|default:
comment|/* shouldn't happen */
name|adp
operator|->
name|va_line_width
operator|=
name|info
operator|->
name|vi_width
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|adp
operator|->
name|va_line_width
operator|=
name|info
operator|->
name|vi_width
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|info
argument_list|,
operator|&
name|adp
operator|->
name|va_info
argument_list|,
sizeof|sizeof
argument_list|(
name|adp
operator|->
name|va_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VGA_NO_BIOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VGA_NO_MODE_CHANGE
argument_list|)
end_if

begin_comment
comment|/* compare two parameter table entries */
end_comment

begin_function
specifier|static
name|int
name|comp_adpregs
parameter_list|(
name|u_char
modifier|*
name|buf1
parameter_list|,
name|u_char
modifier|*
name|buf2
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|u_char
name|mask
decl_stmt|;
block|}
name|params
index|[
name|V_MODE_PARAM_SIZE
index|]
init|=
block|{
literal|0xff
block|,
literal|0x00
block|,
literal|0xff
block|,
comment|/* COLS, ROWS, POINTS */
literal|0x00
block|,
literal|0x00
block|,
comment|/* page length */
literal|0xfe
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* sequencer registers */
literal|0xf3
block|,
comment|/* misc register */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
comment|/* CRTC */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xef
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* attribute controller registers */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* GDC register */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,      }
struct|;
name|int
name|identical
init|=
name|TRUE
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|buf1
operator|==
name|NULL
operator|)
operator|||
operator|(
name|buf2
operator|==
name|NULL
operator|)
condition|)
return|return
name|COMP_DIFFERENT
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|params
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|params
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|mask
operator|==
literal|0
condition|)
comment|/* don't care */
continue|continue;
if|if
condition|(
operator|(
name|buf1
index|[
name|i
index|]
operator|&
name|params
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|!=
operator|(
name|buf2
index|[
name|i
index|]
operator|&
name|params
index|[
name|i
index|]
operator|.
name|mask
operator|)
condition|)
return|return
name|COMP_DIFFERENT
return|;
if|if
condition|(
name|buf1
index|[
name|i
index|]
operator|!=
name|buf2
index|[
name|i
index|]
condition|)
name|identical
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
operator|(
name|identical
operator|)
condition|?
name|COMP_IDENTICAL
else|:
name|COMP_SIMILAR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !VGA_NO_BIOS&& !VGA_NO_MODE_CHANGE */
end_comment

begin_comment
comment|/* probe video adapters and return the number of detected adapters */
end_comment

begin_function
specifier|static
name|int
name|probe_adapters
parameter_list|(
name|void
parameter_list|)
block|{
name|video_adapter_t
modifier|*
name|adp
decl_stmt|;
name|video_info_t
name|info
decl_stmt|;
name|u_char
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* do this test only once */
if|if
condition|(
name|init_done
condition|)
return|return
name|biosadapters
return|;
name|init_done
operator|=
name|TRUE
expr_stmt|;
comment|/*       * Locate display adapters.       * The AT architecture supports upto two adapters. `syscons' allows      * the following combinations of adapters:       *     1) MDA + CGA      *     2) MDA + EGA/VGA color       *     3) CGA + EGA/VGA mono      * Note that `syscons' doesn't bother with MCGA as it is only      * avaiable for low end PS/2 models which has 80286 or earlier CPUs,      * thus, they are not running FreeBSD!      * When there are two adapaters in the system, one becomes `primary'      * and the other `secondary'. The EGA adapter has a set of DIP       * switches on board for this information and the EGA BIOS copies       * it in the BIOS data area BIOSDATA_VIDEOSWITCH (40:88).       * The VGA BIOS has more sophisticated mechanism and has this       * information in BIOSDATA_DCCINDEX (40:8a), but it also maintains       * compatibility with the EGA BIOS by updating BIOSDATA_VIDEOSWITCH.      */
comment|/*       * Check rtc and BIOS data area.      * XXX: we don't use BIOSDATA_EQUIPMENT, since it is not a dead      * copy of RTC_EQUIPMENT.  Bits 4 and 5 of ETC_EQUIPMENT are      * zeros for EGA and VGA.  However, the EGA/VGA BIOS sets      * these bits in BIOSDATA_EQUIPMENT according to the monitor      * type detected.      */
ifndef|#
directive|ifndef
name|VGA_NO_BIOS
switch|switch
condition|(
operator|(
name|rtcin
argument_list|(
name|RTC_EQUIPMENT
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|3
condition|)
block|{
comment|/* bit 4 and 5 */
case|case
literal|0
case|:
comment|/* EGA/VGA */
name|fill_adapter_param
argument_list|(
name|readb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x488
argument_list|)
argument_list|)
operator|&
literal|0x0f
argument_list|,
name|biosadapter
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* CGA 40x25 */
comment|/* FIXME: switch to the 80x25 mode? XXX */
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_CGA40
index|]
expr_stmt|;
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_MONO
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* CGA 80x25 */
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_CGA80
index|]
expr_stmt|;
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_MONO
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* MDA */
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_MONO
index|]
expr_stmt|;
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_CGA80
index|]
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/* assume EGA/VGA? XXX */
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_EGA80
index|]
expr_stmt|;
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_MONO
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* VGA_NO_BIOS */
name|biosadapters
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verify_adapter
argument_list|(
operator|&
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|biosadapters
expr_stmt|;
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_flags
operator||=
name|V_ADP_PROBED
expr_stmt|;
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_mode
operator|=
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_initial_mode
operator|=
name|map_bios_mode_num
argument_list|(
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_type
argument_list|,
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_flags
operator|&
name|V_ADP_COLOR
argument_list|,
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_initial_bios_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_type
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|verify_adapter
argument_list|(
operator|&
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|biosadapters
expr_stmt|;
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_flags
operator||=
name|V_ADP_PROBED
expr_stmt|;
ifndef|#
directive|ifndef
name|VGA_NO_BIOS
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_initial_bios_mode
operator|=
name|readb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x449
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_initial_bios_mode
operator|=
literal|3
expr_stmt|;
comment|/* XXX */
endif|#
directive|endif
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_mode
operator|=
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_initial_mode
operator|=
name|map_bios_mode_num
argument_list|(
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_type
argument_list|,
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_flags
operator|&
name|V_ADP_COLOR
argument_list|,
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_initial_bios_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|=
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
expr_stmt|;
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_type
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|biosadapters
operator|==
literal|0
condition|)
return|return
name|biosadapters
return|;
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_unit
operator|=
name|V_ADP_PRIMARY
expr_stmt|;
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_unit
operator|=
name|V_ADP_SECONDARY
expr_stmt|;
if|#
directive|if
literal|0
comment|/* we don't need these... */
block|fb_init_struct(&biosadapter[V_ADP_PRIMARY], ...);     fb_init_struct(&biosadapter[V_ADP_SECONDARY], ...);
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/*      * We cannot have two video adapter of the same type; there must be      * only one of color or mono adapter, or one each of them.      */
block|if (biosadapters> 1) { 	if (!((biosadapter[0].va_flags ^ biosadapter[1].va_flags)& V_ADP_COLOR))
comment|/* we have two mono or color adapters!! */
block|return (biosadapters = 0);     }
endif|#
directive|endif
comment|/*      * Ensure a zero start address.  This is mainly to recover after      * switching from pcvt using userconfig().  The registers are w/o      * for old hardware so it's too hard to relocate the active screen      * memory.      * This must be done before vga_save_state() for VGA.      */
name|outb
argument_list|(
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_crtc_addr
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_crtc_addr
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_crtc_addr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_crtc_addr
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* the video mode parameter table in EGA/VGA BIOS */
comment|/* NOTE: there can be only one EGA/VGA, wheather color or mono,      * recognized by the video BIOS.      */
if|if
condition|(
operator|(
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_type
operator|==
name|KD_EGA
operator|)
operator|||
operator|(
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_type
operator|==
name|KD_VGA
operator|)
condition|)
block|{
name|adp
operator|=
operator|&
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_type
operator|==
name|KD_EGA
operator|)
operator|||
operator|(
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_type
operator|==
name|KD_VGA
operator|)
condition|)
block|{
name|adp
operator|=
operator|&
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
expr_stmt|;
block|}
else|else
block|{
name|adp
operator|=
name|NULL
expr_stmt|;
block|}
name|bzero
argument_list|(
name|mode_map
argument_list|,
sizeof|sizeof
argument_list|(
name|mode_map
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
name|vga_save_state
argument_list|(
name|adp
argument_list|,
operator|&
name|adpstate
argument_list|,
sizeof|sizeof
argument_list|(
name|adpstate
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VGA_NO_BIOS
argument_list|)
operator|||
name|defined
argument_list|(
name|VGA_NO_MODE_CHANGE
argument_list|)
name|mode_map
index|[
name|adp
operator|->
name|va_initial_mode
index|]
operator|=
name|adpstate
operator|.
name|regs
expr_stmt|;
name|rows_offset
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* VGA_NO_BIOS || VGA_NO_MODE_CHANGE */
if|if
condition|(
name|video_mode_ptr
operator|==
name|NULL
condition|)
block|{
name|mode_map
index|[
name|adp
operator|->
name|va_initial_mode
index|]
operator|=
name|adpstate
operator|.
name|regs
expr_stmt|;
name|rows_offset
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* discard the table if we are not familiar with it... */
name|map_mode_table
argument_list|(
name|mode_map
argument_list|,
name|video_mode_ptr
argument_list|,
name|M_VGA_CG320
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mp
operator|=
name|get_mode_param
argument_list|(
name|adp
operator|->
name|va_initial_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|mp
argument_list|,
name|adpstate2
operator|.
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|adpstate2
operator|.
name|regs
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|comp_adpregs
argument_list|(
name|adpstate
operator|.
name|regs
argument_list|,
name|mp
argument_list|)
condition|)
block|{
case|case
name|COMP_IDENTICAL
case|:
comment|/* 		     * OK, this parameter table looks reasonably familiar 		     * to us... 		     */
comment|/*  		     * This is a kludge for Toshiba DynaBook SS433  		     * whose BIOS video mode table entry has the actual #  		     * of rows at the offset 1; BIOSes from other  		     * manufacturers store the # of rows - 1 there. XXX 		     */
name|rows_offset
operator|=
name|adpstate
operator|.
name|regs
index|[
literal|1
index|]
operator|+
literal|1
operator|-
name|mp
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|COMP_SIMILAR
case|:
comment|/* 		     * Not exactly the same, but similar enough to be 		     * trusted. However, use the saved register values 		     * for the initial mode and other modes which are 		     * based on the initial mode. 		     */
name|mode_map
index|[
name|adp
operator|->
name|va_initial_mode
index|]
operator|=
name|adpstate
operator|.
name|regs
expr_stmt|;
name|rows_offset
operator|=
name|adpstate
operator|.
name|regs
index|[
literal|1
index|]
operator|+
literal|1
operator|-
name|mp
index|[
literal|1
index|]
expr_stmt|;
name|adpstate
operator|.
name|regs
index|[
literal|1
index|]
operator|-=
name|rows_offset
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|COMP_DIFFERENT
case|:
default|default:
comment|/* 		     * Don't use the paramter table in BIOS. It doesn't 		     * look familiar to us. Video mode switching is allowed 		     * only if the new mode is the same as or based on 		     * the initial mode.  		     */
name|video_mode_ptr
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|mode_map
argument_list|,
sizeof|sizeof
argument_list|(
name|mode_map
argument_list|)
argument_list|)
expr_stmt|;
name|mode_map
index|[
name|adp
operator|->
name|va_initial_mode
index|]
operator|=
name|adpstate
operator|.
name|regs
expr_stmt|;
name|rows_offset
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* VGA_NO_BIOS || VGA_NO_MODE_CHANGE */
ifndef|#
directive|ifndef
name|VGA_NO_MODE_CHANGE
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_MODECHANGE
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|VGA_NO_FONT_LOADING
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_FONT
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_EGA
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|VGA_NO_BIOS
argument_list|)
operator|||
name|defined
argument_list|(
name|VGA_NO_MODE_CHANGE
argument_list|)
name|rows_offset
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* VGA_NO_BIOS || VGA_NO_MODE_CHANGE */
if|if
condition|(
name|video_mode_ptr
operator|==
name|NULL
condition|)
block|{
name|rows_offset
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|map_mode_table
argument_list|(
name|mode_map
argument_list|,
name|video_mode_ptr
argument_list|,
name|M_ENH_C80x25
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX how can one validate the EGA table... */
name|mp
operator|=
name|get_mode_param
argument_list|(
name|adp
operator|->
name|va_initial_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
block|{
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_MODECHANGE
expr_stmt|;
ifndef|#
directive|ifndef
name|VGA_NO_FONT_LOADING
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_FONT
expr_stmt|;
endif|#
directive|endif
name|rows_offset
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * This is serious. We will not be able to switch video 		     * modes at all... 		     */
name|video_mode_ptr
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|mode_map
argument_list|,
sizeof|sizeof
argument_list|(
name|mode_map
argument_list|)
argument_list|)
expr_stmt|;
name|rows_offset
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* VGA_NO_BIOS || VGA_NO_MODE_CHANGE */
block|}
block|}
comment|/* remove conflicting modes if we have more than one adapter */
if|if
condition|(
name|biosadapters
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|biosadapters
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|biosadapter
index|[
name|i
index|]
operator|.
name|va_flags
operator|&
name|V_ADP_MODECHANGE
operator|)
condition|)
continue|continue;
name|clear_mode_map
argument_list|(
operator|&
name|biosadapter
index|[
name|i
index|]
argument_list|,
name|mode_map
argument_list|,
name|M_VGA_CG320
operator|+
literal|1
argument_list|,
operator|(
name|biosadapter
index|[
name|i
index|]
operator|.
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
name|V_INFO_COLOR
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|biosadapter
index|[
name|i
index|]
operator|.
name|va_type
operator|==
name|KD_VGA
operator|)
operator|||
operator|(
name|biosadapter
index|[
name|i
index|]
operator|.
name|va_type
operator|==
name|KD_EGA
operator|)
condition|)
block|{
name|biosadapter
index|[
name|i
index|]
operator|.
name|va_io_base
operator|=
operator|(
name|biosadapter
index|[
name|i
index|]
operator|.
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
name|IO_VGA
else|:
name|IO_MDA
expr_stmt|;
name|biosadapter
index|[
name|i
index|]
operator|.
name|va_io_size
operator|=
literal|32
expr_stmt|;
block|}
block|}
block|}
comment|/* buffer address */
name|vga_get_info
argument_list|(
operator|&
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
argument_list|,
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_initial_mode
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|update_adapter_info
argument_list|(
operator|&
name|biosadapter
index|[
name|V_ADP_PRIMARY
index|]
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|biosadapters
operator|>
literal|1
condition|)
block|{
name|vga_get_info
argument_list|(
operator|&
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
argument_list|,
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_initial_mode
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|update_adapter_info
argument_list|(
operator|&
name|biosadapter
index|[
name|V_ADP_SECONDARY
index|]
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
comment|/*      * XXX: we should verify the following values for the primary adapter...      * crtc I/O port address: *(u_int16_t *)BIOS_PADDRTOVADDR(0x463);      * color/mono display: (*(u_int8_t *)BIOS_PADDRTOVADDR(0x487)& 0x02)       *                     ? 0 : V_ADP_COLOR;      * columns: *(u_int8_t *)BIOS_PADDRTOVADDR(0x44a);      * rows: *(u_int8_t *)BIOS_PADDRTOVADDR(0x484);      * font size: *(u_int8_t *)BIOS_PADDRTOVADDR(0x485);      * buffer size: *(u_int16_t *)BIOS_PADDRTOVADDR(0x44c);      */
return|return
name|biosadapters
return|;
block|}
end_function

begin_comment
comment|/* entry points */
end_comment

begin_function
specifier|static
name|int
name|vga_nop
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vga_probe
parameter_list|(
name|int
name|unit
parameter_list|,
name|video_adapter_t
modifier|*
modifier|*
name|adpp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|probe_adapters
argument_list|()
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|biosadapters
condition|)
return|return
name|ENXIO
return|;
operator|*
name|adpp
operator|=
operator|&
name|biosadapter
index|[
name|unit
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vga_init
parameter_list|(
name|int
name|unit
parameter_list|,
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|(
name|unit
operator|>=
name|biosadapters
operator|)
operator|||
operator|(
name|adp
operator|==
name|NULL
operator|)
operator|||
operator|!
name|probe_done
argument_list|(
name|adp
argument_list|)
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
operator|!
name|init_done
argument_list|(
name|adp
argument_list|)
condition|)
block|{
comment|/* nothing to do really... */
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_INITIALIZED
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|config_done
argument_list|(
name|adp
argument_list|)
condition|)
block|{
if|if
condition|(
name|vid_register
argument_list|(
name|adp
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ENXIO
return|;
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_REGISTERED
expr_stmt|;
block|}
if|if
condition|(
name|vga_sub_configure
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|vga_sub_configure
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * get_info():  * Return the video_info structure of the requested video mode.  *  * all adapters  */
end_comment

begin_function
specifier|static
name|int
name|vga_get_info
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|mode
parameter_list|,
name|video_info_t
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|init_done
condition|)
return|return
literal|1
return|;
name|mode
operator|=
name|map_gen_mode_num
argument_list|(
name|adp
operator|->
name|va_type
argument_list|,
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VGA_NO_MODE_CHANGE
if|if
condition|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_MODECHANGE
condition|)
block|{
comment|/* 	 * If the parameter table entry for this mode is not found,  	 * the mode is not supported... 	 */
if|if
condition|(
name|get_mode_param
argument_list|(
name|mode
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
block|}
else|else
endif|#
directive|endif
comment|/* VGA_NO_MODE_CHANGE */
block|{
comment|/*  	 * Even if we don't support video mode switching on this adapter, 	 * the information on the initial (thus current) video mode  	 * should be made available. 	 */
if|if
condition|(
name|mode
operator|!=
name|adp
operator|->
name|va_initial_mode
condition|)
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|!=
name|EOT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|==
name|NA
condition|)
continue|continue;
if|if
condition|(
name|mode
operator|==
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
condition|)
block|{
operator|*
name|info
operator|=
name|bios_vmode
index|[
name|i
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * query_mode():  * Find a video mode matching the requested parameters.  * Fields filled with 0 are considered "don't care" fields and  * match any modes.  *  * all adapters  */
end_comment

begin_function
specifier|static
name|int
name|vga_query_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|video_info_t
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|init_done
condition|)
return|return
name|ENXIO
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|!=
name|EOT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|==
name|NA
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_width
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_width
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_width
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_height
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_height
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_height
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_cwidth
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_cwidth
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_cwidth
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_cheight
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_cheight
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_cheight
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_depth
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_depth
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_depth
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_planes
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_planes
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_planes
operator|)
condition|)
continue|continue;
comment|/* XXX: should check pixel format, memory model */
if|if
condition|(
operator|(
name|info
operator|->
name|vi_flags
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_flags
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_flags
operator|)
condition|)
continue|continue;
comment|/* verify if this mode is supported on this adapter */
if|if
condition|(
name|vga_get_info
argument_list|(
name|adp
argument_list|,
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
argument_list|,
name|info
argument_list|)
condition|)
continue|continue;
return|return
literal|0
return|;
block|}
return|return
name|ENODEV
return|;
block|}
end_function

begin_comment
comment|/*  * set_mode():  * Change the video mode.  *  * EGA/VGA  */
end_comment

begin_function
specifier|static
name|int
name|vga_set_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VGA_NO_MODE_CHANGE
name|video_info_t
name|info
decl_stmt|;
name|adp_state_t
name|params
decl_stmt|;
name|prologue
argument_list|(
name|adp
argument_list|,
name|V_ADP_MODECHANGE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mode
operator|=
name|map_gen_mode_num
argument_list|(
name|adp
operator|->
name|va_type
argument_list|,
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_COLOR
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|vga_get_info
argument_list|(
name|adp
argument_list|,
name|mode
argument_list|,
operator|&
name|info
argument_list|)
condition|)
return|return
literal|1
return|;
name|params
operator|.
name|sig
operator|=
name|V_STATE_SIG
expr_stmt|;
name|bcopy
argument_list|(
name|get_mode_param
argument_list|(
name|mode
argument_list|)
argument_list|,
name|params
operator|.
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|params
operator|.
name|regs
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|M_VGA_C80x60
case|:
case|case
name|M_VGA_M80x60
case|:
name|params
operator|.
name|regs
index|[
literal|2
index|]
operator|=
literal|0x08
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|19
index|]
operator|=
literal|0x47
expr_stmt|;
goto|goto
name|special_480l
goto|;
case|case
name|M_VGA_C80x30
case|:
case|case
name|M_VGA_M80x30
case|:
name|params
operator|.
name|regs
index|[
literal|19
index|]
operator|=
literal|0x4f
expr_stmt|;
name|special_480l
label|:
name|params
operator|.
name|regs
index|[
literal|9
index|]
operator||=
literal|0xc0
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|16
index|]
operator|=
literal|0x08
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|17
index|]
operator|=
literal|0x3e
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|26
index|]
operator|=
literal|0xea
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|28
index|]
operator|=
literal|0xdf
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|31
index|]
operator|=
literal|0xe7
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|32
index|]
operator|=
literal|0x04
expr_stmt|;
goto|goto
name|setup_mode
goto|;
case|case
name|M_ENH_C80x43
case|:
case|case
name|M_ENH_B80x43
case|:
name|params
operator|.
name|regs
index|[
literal|28
index|]
operator|=
literal|87
expr_stmt|;
goto|goto
name|special_80x50
goto|;
case|case
name|M_VGA_C80x50
case|:
case|case
name|M_VGA_M80x50
case|:
name|special_80x50
label|:
name|params
operator|.
name|regs
index|[
literal|2
index|]
operator|=
literal|8
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|19
index|]
operator|=
literal|7
expr_stmt|;
goto|goto
name|setup_mode
goto|;
case|case
name|M_VGA_C40x25
case|:
case|case
name|M_VGA_C80x25
case|:
case|case
name|M_VGA_M80x25
case|:
case|case
name|M_B40x25
case|:
case|case
name|M_C40x25
case|:
case|case
name|M_B80x25
case|:
case|case
name|M_C80x25
case|:
case|case
name|M_ENH_B40x25
case|:
case|case
name|M_ENH_C40x25
case|:
case|case
name|M_ENH_B80x25
case|:
case|case
name|M_ENH_C80x25
case|:
case|case
name|M_EGAMONO80x25
case|:
name|setup_mode
label|:
name|vga_load_state
argument_list|(
name|adp
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_VGA_MODEX
case|:
comment|/* "unchain" the VGA mode */
name|params
operator|.
name|regs
index|[
literal|5
operator|-
literal|1
operator|+
literal|0x04
index|]
operator|&=
literal|0xf7
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|5
operator|-
literal|1
operator|+
literal|0x04
index|]
operator||=
literal|0x04
expr_stmt|;
comment|/* turn off doubleword mode */
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x14
index|]
operator|&=
literal|0xbf
expr_stmt|;
comment|/* turn off word adressing */
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x17
index|]
operator||=
literal|0x40
expr_stmt|;
comment|/* set logical screen width */
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x13
index|]
operator|=
literal|80
expr_stmt|;
comment|/* set 240 lines */
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x11
index|]
operator|=
literal|0x2c
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x06
index|]
operator|=
literal|0x0d
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x07
index|]
operator|=
literal|0x3e
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x10
index|]
operator|=
literal|0xea
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x11
index|]
operator|=
literal|0xac
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x12
index|]
operator|=
literal|0xdf
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x15
index|]
operator|=
literal|0xe7
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x16
index|]
operator|=
literal|0x06
expr_stmt|;
comment|/* set vertical sync polarity to reflect aspect ratio */
name|params
operator|.
name|regs
index|[
literal|9
index|]
operator|=
literal|0xe3
expr_stmt|;
goto|goto
name|setup_grmode
goto|;
case|case
name|M_BG320
case|:
case|case
name|M_CG320
case|:
case|case
name|M_BG640
case|:
case|case
name|M_CG320_D
case|:
case|case
name|M_CG640_E
case|:
case|case
name|M_CG640x350
case|:
case|case
name|M_ENH_CG640
case|:
case|case
name|M_BG640x480
case|:
case|case
name|M_CG640x480
case|:
case|case
name|M_VGA_CG320
case|:
name|setup_grmode
label|:
name|vga_load_state
argument_list|(
name|adp
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|1
return|;
block|}
name|adp
operator|->
name|va_mode
operator|=
name|mode
expr_stmt|;
name|update_adapter_info
argument_list|(
name|adp
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* move hardware cursor out of the way */
operator|(
operator|*
name|vidsw
index|[
name|adp
operator|->
name|va_index
index|]
operator|->
name|set_hw_cursor
operator|)
operator|(
name|adp
operator|,
operator|-
literal|1
operator|,
operator|-
literal|1
operator|)
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
comment|/* VGA_NO_MODE_CHANGE */
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* VGA_NO_MODE_CHANGE */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|VGA_NO_FONT_LOADING
end_ifndef

begin_function
specifier|static
name|void
name|set_font_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
name|u_char
modifier|*
name|mp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* save register values */
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|inb
argument_list|(
name|GDCREG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|inb
argument_list|(
name|GDCREG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|inb
argument_list|(
name|GDCREG
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|inb
argument_list|(
name|ATC
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* if (adp->va_type == KD_EGA) */
block|{
comment|/*  	 * EGA cannot be read; copy parameters from the mode parameter  	 * table.  	 */
name|mp
operator|=
name|get_mode_param
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|mp
index|[
literal|5
operator|+
literal|0x02
operator|-
literal|1
index|]
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|mp
index|[
literal|5
operator|+
literal|0x04
operator|-
literal|1
index|]
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|mp
index|[
literal|55
operator|+
literal|0x04
index|]
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|mp
index|[
literal|55
operator|+
literal|0x05
index|]
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|mp
index|[
literal|55
operator|+
literal|0x06
index|]
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|mp
index|[
literal|35
operator|+
literal|0x10
index|]
expr_stmt|;
block|}
comment|/* setup vga for loading fonts */
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|buf
index|[
literal|5
index|]
operator|&
operator|~
literal|0x01
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
if|#
directive|if
name|VGA_SLOW_IOACCESS
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* VGA_SLOW_IOACCESS */
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0100
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0402
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0704
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0300
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0204
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0406
argument_list|)
expr_stmt|;
comment|/* addr = a0000, 64kb */
endif|#
directive|endif
comment|/* VGA_SLOW_IOACCESS */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_normal_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* setup vga for normal operation mode again */
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
if|#
directive|if
name|VGA_SLOW_IOACCESS
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|va_crtc_addr
operator|==
name|MONO_CRTC
condition|)
block|{
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x0c
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* VGA_SLOW_IOACCESS */
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0100
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0002
operator||
operator|(
name|buf
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0004
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0300
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0004
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0005
operator||
operator|(
name|buf
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|va_crtc_addr
operator|==
name|MONO_CRTC
condition|)
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0006
operator||
operator|(
operator|(
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x08
operator|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
else|else
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0006
operator||
operator|(
operator|(
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x0c
operator|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VGA_SLOW_IOACCESS */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VGA_NO_FONT_LOADING */
end_comment

begin_comment
comment|/*  * save_font():  * Read the font data in the requested font page from the video adapter.  *  * EGA/VGA  */
end_comment

begin_function
specifier|static
name|int
name|vga_save_font
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|fontsize
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|count
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VGA_NO_FONT_LOADING
name|u_char
name|buf
index|[
name|PARAM_BUFSIZE
index|]
decl_stmt|;
name|u_int32_t
name|segment
decl_stmt|;
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
name|int
name|s
decl_stmt|;
name|u_char
name|val
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|prologue
argument_list|(
name|adp
argument_list|,
name|V_ADP_FONT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontsize
operator|<
literal|14
condition|)
block|{
comment|/* FONT_8 */
name|fontsize
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fontsize
operator|>=
literal|32
condition|)
block|{
name|fontsize
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fontsize
operator|>=
literal|16
condition|)
block|{
comment|/* FONT_16 */
name|fontsize
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
comment|/* FONT_14 */
name|fontsize
operator|=
literal|14
expr_stmt|;
block|}
if|if
condition|(
name|page
operator|<
literal|0
operator|||
name|page
operator|>=
literal|8
condition|)
return|return
literal|1
return|;
name|segment
operator|=
name|FONT_BUF
operator|+
literal|0x4000
operator|*
name|page
expr_stmt|;
if|if
condition|(
name|page
operator|>
literal|3
condition|)
name|segment
operator|-=
literal|0xe000
expr_stmt|;
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
comment|/* what about EGA? XXX */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
comment|/* disable screen */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|val
operator||
literal|0x20
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|set_font_mode
argument_list|(
name|adp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontsize
operator|==
literal|32
condition|)
block|{
name|bcopy_fromio
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|segment
operator|+
name|ch
operator|*
literal|32
operator|)
argument_list|,
name|data
argument_list|,
name|fontsize
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|c
operator|=
name|ch
init|;
name|count
operator|>
literal|0
condition|;
operator|++
name|c
operator|,
operator|--
name|count
control|)
block|{
name|bcopy_fromio
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|segment
operator|+
name|c
operator|*
literal|32
operator|)
argument_list|,
name|data
argument_list|,
name|fontsize
argument_list|)
expr_stmt|;
name|data
operator|+=
name|fontsize
expr_stmt|;
block|}
block|}
name|set_normal_mode
argument_list|(
name|adp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|val
operator|&
literal|0xdf
argument_list|)
expr_stmt|;
comment|/* enable screen */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
else|#
directive|else
comment|/* VGA_NO_FONT_LOADING */
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* VGA_NO_FONT_LOADING */
block|}
end_function

begin_comment
comment|/*  * load_font():  * Set the font data in the requested font page.  * NOTE: it appears that some recent video adapters do not support  * the font page other than 0... XXX  *  * EGA/VGA  */
end_comment

begin_function
specifier|static
name|int
name|vga_load_font
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|fontsize
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|count
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VGA_NO_FONT_LOADING
name|u_char
name|buf
index|[
name|PARAM_BUFSIZE
index|]
decl_stmt|;
name|u_int32_t
name|segment
decl_stmt|;
name|int
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
name|int
name|s
decl_stmt|;
name|u_char
name|val
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|prologue
argument_list|(
name|adp
argument_list|,
name|V_ADP_FONT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontsize
operator|<
literal|14
condition|)
block|{
comment|/* FONT_8 */
name|fontsize
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fontsize
operator|>=
literal|32
condition|)
block|{
name|fontsize
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fontsize
operator|>=
literal|16
condition|)
block|{
comment|/* FONT_16 */
name|fontsize
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
comment|/* FONT_14 */
name|fontsize
operator|=
literal|14
expr_stmt|;
block|}
if|if
condition|(
name|page
operator|<
literal|0
operator|||
name|page
operator|>=
literal|8
condition|)
return|return
literal|1
return|;
name|segment
operator|=
name|FONT_BUF
operator|+
literal|0x4000
operator|*
name|page
expr_stmt|;
if|if
condition|(
name|page
operator|>
literal|3
condition|)
name|segment
operator|-=
literal|0xe000
expr_stmt|;
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
comment|/* what about EGA? XXX */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
comment|/* disable screen */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|val
operator||
literal|0x20
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|set_font_mode
argument_list|(
name|adp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontsize
operator|==
literal|32
condition|)
block|{
name|bcopy_toio
argument_list|(
name|data
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|segment
operator|+
name|ch
operator|*
literal|32
operator|)
argument_list|,
name|fontsize
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|c
operator|=
name|ch
init|;
name|count
operator|>
literal|0
condition|;
operator|++
name|c
operator|,
operator|--
name|count
control|)
block|{
name|bcopy_toio
argument_list|(
name|data
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|segment
operator|+
name|c
operator|*
literal|32
operator|)
argument_list|,
name|fontsize
argument_list|)
expr_stmt|;
name|data
operator|+=
name|fontsize
expr_stmt|;
block|}
block|}
name|set_normal_mode
argument_list|(
name|adp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VGA_ALT_SEQACCESS
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|val
operator|&
literal|0xdf
argument_list|)
expr_stmt|;
comment|/* enable screen */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
else|#
directive|else
comment|/* VGA_NO_FONT_LOADING */
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* VGA_NO_FONT_LOADING */
block|}
end_function

begin_comment
comment|/*  * show_font():  * Activate the requested font page.  * NOTE: it appears that some recent video adapters do not support  * the font page other than 0... XXX  *  * EGA/VGA  */
end_comment

begin_function
specifier|static
name|int
name|vga_show_font
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|page
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|VGA_NO_FONT_LOADING
specifier|static
name|u_char
name|cg
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x05
block|,
literal|0x0a
block|,
literal|0x0f
block|,
literal|0x30
block|,
literal|0x35
block|,
literal|0x3a
block|,
literal|0x3f
block|}
decl_stmt|;
name|int
name|s
decl_stmt|;
name|prologue
argument_list|(
name|adp
argument_list|,
name|V_ADP_FONT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|<
literal|0
operator|||
name|page
operator|>=
literal|8
condition|)
return|return
literal|1
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|cg
index|[
name|page
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
comment|/* VGA_NO_FONT_LOADING */
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* VGA_NO_FONT_LOADING */
block|}
end_function

begin_comment
comment|/*  * save_palette():  * Read DAC values. The values have expressed in 8 bits.  *  * VGA  */
end_comment

begin_function
specifier|static
name|int
name|vga_save_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|prologue
argument_list|(
name|adp
argument_list|,
name|V_ADP_PALETTE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*       * We store 8 bit values in the palette buffer, while the standard      * VGA has 6 bit DAC .      */
name|outb
argument_list|(
name|PALRADR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
operator|*
literal|3
condition|;
operator|++
name|i
control|)
name|palette
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|PALDATA
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip/flop */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * load_palette():  * Set DAC values.  *  * VGA  */
end_comment

begin_function
specifier|static
name|int
name|vga_load_palette
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|prologue
argument_list|(
name|adp
argument_list|,
name|V_ADP_PALETTE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PIXMASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* no pixelmask */
name|outb
argument_list|(
name|PALWADR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
operator|*
literal|3
condition|;
operator|++
name|i
control|)
name|outb
argument_list|(
name|PALDATA
argument_list|,
name|palette
index|[
name|i
index|]
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip/flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * set_border():  * Change the border color.  *  * CGA/EGA/VGA  */
end_comment

begin_function
specifier|static
name|int
name|vga_set_border
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|color
parameter_list|)
block|{
name|prologue
argument_list|(
name|adp
argument_list|,
name|V_ADP_BORDER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|adp
operator|->
name|va_type
condition|)
block|{
case|case
name|KD_EGA
case|:
case|case
name|KD_VGA
case|:
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x31
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|color
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|KD_CGA
case|:
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|5
argument_list|,
name|color
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* color select register */
break|break;
case|case
name|KD_MONO
case|:
case|case
name|KD_HERCULES
case|:
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * save_state():  * Read video register values.  * NOTE: this function only reads the standard EGA/VGA registers.  * any extra/extended registers of SVGA adapters are not saved.  *  * VGA  */
end_comment

begin_function
specifier|static
name|int
name|vga_save_state
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|crtc_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* return the required buffer size */
name|prologue
argument_list|(
name|adp
argument_list|,
name|V_ADP_STATESAVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
name|adp_state_t
argument_list|)
return|;
block|}
else|else
block|{
name|prologue
argument_list|(
name|adp
argument_list|,
name|V_ADP_STATESAVE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|adp_state_t
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|sig
operator|=
name|V_STATE_SIG
expr_stmt|;
name|buf
operator|=
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|regs
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|V_MODE_PARAM_SIZE
argument_list|)
expr_stmt|;
name|crtc_addr
operator|=
name|adp
operator|->
name|va_crtc_addr
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* stop sequencer */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|5
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|TSIDX
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|9
index|]
operator|=
name|inb
argument_list|(
name|MISC
operator|+
literal|10
argument_list|)
expr_stmt|;
comment|/* dot-clock */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* start sequencer */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|10
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
block|{
comment|/* crtc */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|35
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
comment|/* attribute ctrl */
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
name|inb
argument_list|(
name|ATC
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|55
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
comment|/* graph data ctrl */
name|outb
argument_list|(
name|GDCIDX
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
name|inb
argument_list|(
name|GDCREG
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|vga_get_info
argument_list|(
name|adp
argument_list|,
name|adp
operator|->
name|va_mode
argument_list|,
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|info
operator|.
name|vi_width
operator|/
name|info
operator|.
name|vi_cwidth
expr_stmt|;
comment|/* COLS */
name|buf
index|[
literal|1
index|]
operator|=
name|info
operator|.
name|vi_height
operator|/
name|info
operator|.
name|vi_cheight
operator|-
literal|1
expr_stmt|;
comment|/* ROWS */
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|info
operator|.
name|vi_width
expr_stmt|;
comment|/* COLS */
name|buf
index|[
literal|1
index|]
operator|=
name|info
operator|.
name|vi_height
operator|-
literal|1
expr_stmt|;
comment|/* ROWS */
block|}
name|buf
index|[
literal|2
index|]
operator|=
name|info
operator|.
name|vi_cheight
expr_stmt|;
comment|/* POINTS */
block|}
else|else
block|{
comment|/* XXX: shouldn't be happening... */
name|printf
argument_list|(
literal|"vga%d: %s: failed to obtain mode info. (vga_save_state())\n"
argument_list|,
name|adp
operator|->
name|va_unit
argument_list|,
name|adp
operator|->
name|va_name
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|buf
index|[
literal|0
index|]
operator|=
name|readb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x44a
argument_list|)
argument_list|)
expr_stmt|;
comment|/* COLS */
name|buf
index|[
literal|1
index|]
operator|=
name|readb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x484
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ROWS */
name|buf
index|[
literal|2
index|]
operator|=
name|readb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x485
argument_list|)
argument_list|)
expr_stmt|;
comment|/* POINTS */
name|buf
index|[
literal|3
index|]
operator|=
name|readb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x44c
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|readb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x44d
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * load_state():  * Set video registers at once.  * NOTE: this function only updates the standard EGA/VGA registers.  * any extra/extended registers of SVGA adapters are not changed.  *  * EGA/VGA  */
end_comment

begin_function
specifier|static
name|int
name|vga_load_state
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|crtc_addr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|prologue
argument_list|(
name|adp
argument_list|,
name|V_ADP_STATELOAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|sig
operator|!=
name|V_STATE_SIG
condition|)
return|return
literal|1
return|;
name|buf
operator|=
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|regs
expr_stmt|;
name|crtc_addr
operator|=
name|adp
operator|->
name|va_crtc_addr
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* stop sequencer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
comment|/* program sequencer */
name|outb
argument_list|(
name|TSIDX
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|buf
index|[
name|i
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|MISC
argument_list|,
name|buf
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/* set dot-clock */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* start sequencer */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|)
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
operator|++
name|i
control|)
block|{
comment|/* program crtc */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
name|buf
index|[
name|i
operator|+
literal|10
index|]
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
operator|++
name|i
control|)
block|{
comment|/* program attribute ctrl */
name|outb
argument_list|(
name|ATC
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|buf
index|[
name|i
operator|+
literal|35
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
operator|++
name|i
control|)
block|{
comment|/* program graph data ctrl */
name|outb
argument_list|(
name|GDCIDX
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
name|buf
index|[
name|i
operator|+
literal|55
index|]
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
if|#
directive|if
name|notyet
comment|/* a temporary workaround for kernel panic, XXX */
ifndef|#
directive|ifndef
name|VGA_NO_BIOS
if|if
condition|(
name|adp
operator|->
name|va_unit
operator|==
name|V_ADP_PRIMARY
condition|)
block|{
name|writeb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x44a
argument_list|)
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* COLS */
name|writeb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x484
argument_list|)
argument_list|,
name|buf
index|[
literal|1
index|]
operator|+
name|rows_offset
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* ROWS */
name|writeb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x485
argument_list|)
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* POINTS */
if|#
directive|if
literal|0
block|writeb(BIOS_PADDRTOVADDR(0x44c), buf[3]); 	writeb(BIOS_PADDRTOVADDR(0x44d), buf[4]);
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* VGA_NO_BIOS */
endif|#
directive|endif
comment|/* notyet */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * set_origin():  * Change the origin (window mapping) of the banked frame buffer.  */
end_comment

begin_function
specifier|static
name|int
name|vga_set_origin
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
comment|/*       * The standard video modes do not require window mapping;       * always return error.      */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * read_hw_cursor():  * Read the position of the hardware text cursor.  *  * all adapters  */
end_comment

begin_function
specifier|static
name|int
name|vga_read_hw_cursor
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
modifier|*
name|col
parameter_list|,
name|int
modifier|*
name|row
parameter_list|)
block|{
name|u_int16_t
name|off
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|init_done
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|adp
operator|->
name|va_info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
return|return
literal|1
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|off
operator|=
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
name|off
operator|<<
literal|8
operator|)
operator||
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
name|row
operator|=
name|off
operator|/
name|adp
operator|->
name|va_info
operator|.
name|vi_width
expr_stmt|;
operator|*
name|col
operator|=
name|off
operator|%
name|adp
operator|->
name|va_info
operator|.
name|vi_width
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * set_hw_cursor():  * Move the hardware text cursor.  If col and row are both -1,   * the cursor won't be shown.  *  * all adapters  */
end_comment

begin_function
specifier|static
name|int
name|vga_set_hw_cursor
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|col
parameter_list|,
name|int
name|row
parameter_list|)
block|{
name|u_int16_t
name|off
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|init_done
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|col
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|row
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|off
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|adp
operator|->
name|va_info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
return|return
literal|1
return|;
name|off
operator|=
name|row
operator|*
name|adp
operator|->
name|va_info
operator|.
name|vi_width
operator|+
name|col
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|1
argument_list|,
name|off
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|1
argument_list|,
name|off
operator|&
literal|0x00ff
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * set_hw_cursor_shape():  * Change the shape of the hardware text cursor. If the height is  * zero or negative, the cursor won't be shown.  *  * all adapters  */
end_comment

begin_function
specifier|static
name|int
name|vga_set_hw_cursor_shape
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|base
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|celsize
parameter_list|,
name|int
name|blink
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|init_done
condition|)
return|return
literal|1
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|adp
operator|->
name|va_type
condition|)
block|{
case|case
name|KD_VGA
case|:
case|case
name|KD_CGA
case|:
case|case
name|KD_MONO
case|:
case|case
name|KD_HERCULES
case|:
default|default:
if|if
condition|(
name|height
operator|<=
literal|0
condition|)
block|{
comment|/* make the cursor invisible */
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|1
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|1
argument_list|,
name|celsize
operator|-
name|base
operator|-
name|height
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|1
argument_list|,
name|celsize
operator|-
name|base
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KD_EGA
case|:
if|if
condition|(
name|height
operator|<=
literal|0
condition|)
block|{
comment|/* make the cursor invisible */
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|1
argument_list|,
name|celsize
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|1
argument_list|,
name|celsize
operator|-
name|base
operator|-
name|height
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|1
argument_list|,
name|celsize
operator|-
name|base
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * mmap():  * Mmap frame buffer.  *  * all adapters  */
end_comment

begin_function
specifier|static
name|int
name|vga_mmap
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|>
literal|0x20000
operator|-
name|PAGE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
ifdef|#
directive|ifdef
name|__i386__
return|return
name|i386_btop
argument_list|(
operator|(
name|VIDEO_BUF_BASE
operator|+
name|offset
operator|)
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__alpha__
return|return
name|alpha_btop
argument_list|(
operator|(
name|VIDEO_BUF_BASE
operator|+
name|offset
operator|)
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|dump_buffer
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"%02x "
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|++
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * diag():  * Print some information about the video adapter and video modes,  * with requested level of details.  *  * all adapters  */
end_comment

begin_function
specifier|static
name|int
name|vga_diag
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|level
parameter_list|)
block|{
if|#
directive|if
name|FB_DEBUG
operator|>
literal|1
name|video_info_t
name|info
decl_stmt|;
endif|#
directive|endif
name|u_char
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
operator|!
name|init_done
condition|)
return|return
literal|1
return|;
if|#
directive|if
name|FB_DEBUG
operator|>
literal|1
ifndef|#
directive|ifndef
name|VGA_NO_BIOS
name|printf
argument_list|(
literal|"vga: RTC equip. code:0x%02x, DCC code:0x%02x\n"
argument_list|,
name|rtcin
argument_list|(
name|RTC_EQUIPMENT
argument_list|)
argument_list|,
name|readb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x488
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vga: CRTC:0x%x, video option:0x%02x, "
argument_list|,
name|readw
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x463
argument_list|)
argument_list|)
argument_list|,
name|readb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x487
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rows:%d, cols:%d, font height:%d\n"
argument_list|,
name|readb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x44a
argument_list|)
argument_list|)
argument_list|,
name|readb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x484
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|,
name|readb
argument_list|(
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x485
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VGA_NO_BIOS */
name|printf
argument_list|(
literal|"vga: param table EGA/VGA:%p"
argument_list|,
name|video_mode_ptr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", CGA/MDA:%p\n"
argument_list|,
name|video_mode_ptr2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vga: rows_offset:%d\n"
argument_list|,
name|rows_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FB_DEBUG> 1 */
name|fb_dump_adp_info
argument_list|(
name|DRIVER_NAME
argument_list|,
name|adp
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|#
directive|if
name|FB_DEBUG
operator|>
literal|1
if|if
condition|(
name|adp
operator|->
name|va_flags
operator|&
name|V_ADP_MODECHANGE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|!=
name|EOT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|==
name|NA
condition|)
continue|continue;
if|if
condition|(
name|get_mode_param
argument_list|(
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|fb_dump_mode_info
argument_list|(
name|DRIVER_NAME
argument_list|,
name|adp
argument_list|,
operator|&
name|bios_vmode
index|[
name|i
index|]
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|vga_get_info
argument_list|(
name|adp
argument_list|,
name|adp
operator|->
name|va_initial_mode
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* shouldn't fail */
name|fb_dump_mode_info
argument_list|(
name|DRIVER_NAME
argument_list|,
name|adp
argument_list|,
operator|&
name|info
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* FB_DEBUG> 1 */
if|if
condition|(
operator|(
name|adp
operator|->
name|va_type
operator|!=
name|KD_EGA
operator|)
operator|&&
operator|(
name|adp
operator|->
name|va_type
operator|!=
name|KD_VGA
operator|)
condition|)
return|return
literal|0
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|VGA_NO_BIOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|VGA_NO_MODE_CHANGE
argument_list|)
if|if
condition|(
name|video_mode_ptr
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"vga%d: %s: WARNING: video mode switching is not "
literal|"fully supported on this adapter\n"
argument_list|,
name|adp
operator|->
name|va_unit
argument_list|,
name|adp
operator|->
name|va_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|level
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
name|printf
argument_list|(
literal|"VGA parameters upon power-up\n"
argument_list|)
expr_stmt|;
name|dump_buffer
argument_list|(
name|adpstate
operator|.
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|adpstate
operator|.
name|regs
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"VGA parameters in BIOS for mode %d\n"
argument_list|,
name|adp
operator|->
name|va_initial_mode
argument_list|)
expr_stmt|;
name|dump_buffer
argument_list|(
name|adpstate2
operator|.
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|adpstate2
operator|.
name|regs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mp
operator|=
name|get_mode_param
argument_list|(
name|adp
operator|->
name|va_initial_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
comment|/* this shouldn't be happening */
return|return
literal|0
return|;
name|printf
argument_list|(
literal|"EGA/VGA parameters to be used for mode %d\n"
argument_list|,
name|adp
operator|->
name|va_initial_mode
argument_list|)
expr_stmt|;
name|dump_buffer
argument_list|(
name|mp
argument_list|,
name|V_MODE_PARAM_SIZE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NVGA> 0 */
end_comment

end_unit

