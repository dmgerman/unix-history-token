begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) Comtrol Corporation<support@comtrol.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted prodived that the follwoing conditions  * are met.  * 1. Redistributions of source code must retain the above copyright   *    notive, this list of conditions and the following disclainer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials prodided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *       This product includes software developed by Comtrol Corporation.  * 4. The name of Comtrol Corporation may not be used to endorse or   *    promote products derived from this software without specific   *    prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY COMTROL CORPORATION ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL COMTROL CORPORATION BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, LIFE OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*   * rp.c - for RocketPort FreeBSD  */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_define
define|#
directive|define
name|ROCKET_C
end_define

begin_include
include|#
directive|include
file|<i386/isa/rpreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/rpvar.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|Byte_t
name|RData
index|[
name|RDATASIZE
index|]
init|=
block|{
literal|0x00
block|,
literal|0x09
block|,
literal|0xf6
block|,
literal|0x82
block|,
literal|0x02
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0xfb
block|,
literal|0x04
block|,
literal|0x09
block|,
literal|0x00
block|,
literal|0x0a
block|,
literal|0x06
block|,
literal|0x09
block|,
literal|0x01
block|,
literal|0x0a
block|,
literal|0x08
block|,
literal|0x09
block|,
literal|0x8a
block|,
literal|0x13
block|,
literal|0x0a
block|,
literal|0x09
block|,
literal|0xc5
block|,
literal|0x11
block|,
literal|0x0c
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0x85
block|,
literal|0x0e
block|,
literal|0x09
block|,
literal|0x20
block|,
literal|0x0a
block|,
literal|0x10
block|,
literal|0x09
block|,
literal|0x21
block|,
literal|0x0a
block|,
literal|0x12
block|,
literal|0x09
block|,
literal|0x41
block|,
literal|0xff
block|,
literal|0x14
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x00
block|,
literal|0x16
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x7b
block|,
literal|0x18
block|,
literal|0x09
block|,
literal|0x8a
block|,
literal|0x7d
block|,
literal|0x1a
block|,
literal|0x09
block|,
literal|0x88
block|,
literal|0x81
block|,
literal|0x1c
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0x7a
block|,
literal|0x1e
block|,
literal|0x09
block|,
literal|0x84
block|,
literal|0x81
block|,
literal|0x20
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x7c
block|,
literal|0x22
block|,
literal|0x09
block|,
literal|0x0a
block|,
literal|0x0a
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Byte_t
name|RRegData
index|[
name|RREGDATASIZE
index|]
init|=
block|{
literal|0x00
block|,
literal|0x09
block|,
literal|0xf6
block|,
literal|0x82
block|,
comment|/* 00: Stop Rx processor */
literal|0x08
block|,
literal|0x09
block|,
literal|0x8a
block|,
literal|0x13
block|,
comment|/* 04: Tx software flow control */
literal|0x0a
block|,
literal|0x09
block|,
literal|0xc5
block|,
literal|0x11
block|,
comment|/* 08: XON char */
literal|0x0c
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0x85
block|,
comment|/* 0c: XANY */
literal|0x12
block|,
literal|0x09
block|,
literal|0x41
block|,
literal|0xff
block|,
comment|/* 10: Rx mask char */
literal|0x14
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x00
block|,
comment|/* 14: Compare/Ignore #0 */
literal|0x16
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x7b
block|,
comment|/* 18: Compare #1 */
literal|0x18
block|,
literal|0x09
block|,
literal|0x8a
block|,
literal|0x7d
block|,
comment|/* 1c: Compare #2 */
literal|0x1a
block|,
literal|0x09
block|,
literal|0x88
block|,
literal|0x81
block|,
comment|/* 20: Interrupt #1 */
literal|0x1c
block|,
literal|0x09
block|,
literal|0x86
block|,
literal|0x7a
block|,
comment|/* 24: Ignore/Replace #1 */
literal|0x1e
block|,
literal|0x09
block|,
literal|0x84
block|,
literal|0x81
block|,
comment|/* 28: Interrupt #2 */
literal|0x20
block|,
literal|0x09
block|,
literal|0x82
block|,
literal|0x7c
block|,
comment|/* 2c: Ignore/Replace #2 */
literal|0x22
block|,
literal|0x09
block|,
literal|0x0a
block|,
literal|0x0a
comment|/* 30: Rx FIFO Enable */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CONTROLLER_T
name|sController
index|[
name|CTL_SIZE
index|]
init|=
block|{
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* IRQ number to MUDBAC register 2 mapping */
end_comment

begin_endif
unit|Byte_t sIRQMap[16] = {    0,0,0,0x10,0x20,0x30,0,0,0,0x40,0x50,0x60,0x70,0,0,0x80 };
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|Byte_t
name|sBitMapClrTbl
index|[
literal|8
index|]
init|=
block|{
literal|0xfe
block|,
literal|0xfd
block|,
literal|0xfb
block|,
literal|0xf7
block|,
literal|0xef
block|,
literal|0xdf
block|,
literal|0xbf
block|,
literal|0x7f
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Byte_t
name|sBitMapSetTbl
index|[
literal|8
index|]
init|=
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************************************************************** Function: sInitController Purpose:  Initialization of controller global registers and controller 	  structure. Call:	  sInitController(CtlP,CtlNum,MudbacIO,AiopIOList,AiopIOListSize, 			  IRQNum,Frequency,PeriodicOnly) 	  CONTROLLER_T *CtlP; Ptr to controller structure 	  int CtlNum; Controller number 	  ByteIO_t MudbacIO; Mudbac base I/O address. 	  ByteIO_t *AiopIOList; List of I/O addresses for each AIOP. 	     This list must be in the order the AIOPs will be found on the 	     controller.  Once an AIOP in the list is not found, it is 	     assumed that there are no more AIOPs on the controller. 	  int AiopIOListSize; Number of addresses in AiopIOList 	  int IRQNum; Interrupt Request number.  Can be any of the following: 			 0: Disable global interrupts 			 3: IRQ 3 			 4: IRQ 4 			 5: IRQ 5 			 9: IRQ 9 			 10: IRQ 10 			 11: IRQ 11 			 12: IRQ 12 			 15: IRQ 15 	  Byte_t Frequency: A flag identifying the frequency 		   of the periodic interrupt, can be any one of the following: 		      FREQ_DIS - periodic interrupt disabled 		      FREQ_137HZ - 137 Hertz 		      FREQ_69HZ - 69 Hertz 		      FREQ_34HZ - 34 Hertz 		      FREQ_17HZ - 17 Hertz 		      FREQ_9HZ - 9 Hertz 		      FREQ_4HZ - 4 Hertz 		   If IRQNum is set to 0 the Frequency parameter is 		   overidden, it is forced to a value of FREQ_DIS. 	  int PeriodicOnly: TRUE if all interrupts except the periodic 			       interrupt are to be blocked. 			    FALSE is both the periodic interrupt and 			       other channel interrupts are allowed. 			    If IRQNum is set to 0 the PeriodicOnly parameter is 			       overidden, it is forced to a value of FALSE. Return:   int: Number of AIOPs on the controller, or CTLID_NULL if controller 	       initialization failed.  Comments: 	  If periodic interrupts are to be disabled but AIOP interrupts 	  are allowed, set Frequency to FREQ_DIS and PeriodicOnly to FALSE.  	  If interrupts are to be completely disabled set IRQNum to 0.  	  Setting Frequency to FREQ_DIS and PeriodicOnly to TRUE is an 	  invalid combination.  	  This function performs initialization of global interrupt modes, 	  but it does not actually enable global interrupts.  To enable 	  and disable global interrupts use functions sEnGlobalInt() and 	  sDisGlobalInt().  Enabling of global interrupts is normally not 	  done until all other initializations are complete.  	  Even if interrupts are globally enabled, they must also be 	  individually enabled for each channel that is to generate 	  interrupts.  Warnings: No range checking on any of the parameters is done.  	  No context switches are allowed while executing this function.  	  After this function all AIOPs on the controller are disabled, 	  they can be enabled with sEnAiop(). */
end_comment

begin_function
name|int
name|sInitController
parameter_list|(
name|CONTROLLER_T
modifier|*
name|CtlP
parameter_list|,
name|int
name|CtlNum
parameter_list|,
name|ByteIO_t
name|MudbacIO
parameter_list|,
name|ByteIO_t
modifier|*
name|AiopIOList
parameter_list|,
name|int
name|AiopIOListSize
parameter_list|,
name|int
name|IRQNum
parameter_list|,
name|Byte_t
name|Frequency
parameter_list|,
name|int
name|PeriodicOnly
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ByteIO_t
name|io
decl_stmt|;
name|CtlP
operator|->
name|CtlNum
operator|=
name|CtlNum
expr_stmt|;
name|CtlP
operator|->
name|BusType
operator|=
name|isISA
expr_stmt|;
name|CtlP
operator|->
name|CtlID
operator|=
name|CTLID_0001
expr_stmt|;
comment|/* controller release 1 */
name|CtlP
operator|->
name|MBaseIO
operator|=
name|MudbacIO
expr_stmt|;
name|CtlP
operator|->
name|MReg1IO
operator|=
name|MudbacIO
operator|+
literal|1
expr_stmt|;
name|CtlP
operator|->
name|MReg2IO
operator|=
name|MudbacIO
operator|+
literal|2
expr_stmt|;
name|CtlP
operator|->
name|MReg3IO
operator|=
name|MudbacIO
operator|+
literal|3
expr_stmt|;
if|#
directive|if
literal|1
name|CtlP
operator|->
name|MReg2
operator|=
literal|0
expr_stmt|;
comment|/* interrupt disable */
name|CtlP
operator|->
name|MReg3
operator|=
literal|0
expr_stmt|;
comment|/* no periodic interrupts */
else|#
directive|else
if|if
condition|(
name|sIRQMap
index|[
name|IRQNum
index|]
operator|==
literal|0
condition|)
comment|/* interrupts globally disabled */
block|{
name|CtlP
operator|->
name|MReg2
operator|=
literal|0
expr_stmt|;
comment|/* interrupt disable */
name|CtlP
operator|->
name|MReg3
operator|=
literal|0
expr_stmt|;
comment|/* no periodic interrupts */
block|}
else|else
block|{
name|CtlP
operator|->
name|MReg2
operator|=
name|sIRQMap
index|[
name|IRQNum
index|]
expr_stmt|;
comment|/* set IRQ number */
name|CtlP
operator|->
name|MReg3
operator|=
name|Frequency
expr_stmt|;
comment|/* set frequency */
if|if
condition|(
name|PeriodicOnly
condition|)
comment|/* periodic interrupt only */
block|{
name|CtlP
operator|->
name|MReg3
operator||=
name|PERIODIC_ONLY
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|sOutB
argument_list|(
name|CtlP
operator|->
name|MReg2IO
argument_list|,
name|CtlP
operator|->
name|MReg2
argument_list|)
expr_stmt|;
name|sOutB
argument_list|(
name|CtlP
operator|->
name|MReg3IO
argument_list|,
name|CtlP
operator|->
name|MReg3
argument_list|)
expr_stmt|;
name|sControllerEOI
argument_list|(
name|CtlP
argument_list|)
expr_stmt|;
comment|/* clear EOI if warm init */
comment|/* Init AIOPs */
name|CtlP
operator|->
name|NumAiop
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AiopIOListSize
condition|;
name|i
operator|++
control|)
block|{
name|io
operator|=
name|AiopIOList
index|[
name|i
index|]
expr_stmt|;
name|CtlP
operator|->
name|AiopIO
index|[
name|i
index|]
operator|=
operator|(
name|WordIO_t
operator|)
name|io
expr_stmt|;
name|CtlP
operator|->
name|AiopIntChanIO
index|[
name|i
index|]
operator|=
name|io
operator|+
name|_INT_CHAN
expr_stmt|;
name|sOutB
argument_list|(
name|CtlP
operator|->
name|MReg2IO
argument_list|,
name|CtlP
operator|->
name|MReg2
operator||
operator|(
name|i
operator|&
literal|0x03
operator|)
argument_list|)
expr_stmt|;
comment|/* AIOP index */
name|sOutB
argument_list|(
name|MudbacIO
argument_list|,
call|(
name|Byte_t
call|)
argument_list|(
name|io
operator|>>
literal|6
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set up AIOP I/O in MUDBAC */
name|sEnAiop
argument_list|(
name|CtlP
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* enable the AIOP */
name|CtlP
operator|->
name|AiopID
index|[
name|i
index|]
operator|=
name|sReadAiopID
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* read AIOP ID */
if|if
condition|(
name|CtlP
operator|->
name|AiopID
index|[
name|i
index|]
operator|==
name|AIOPID_NULL
condition|)
comment|/* if AIOP does not exist */
block|{
name|sDisAiop
argument_list|(
name|CtlP
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* disable AIOP */
break|break;
comment|/* done looking for AIOPs */
block|}
name|CtlP
operator|->
name|AiopNumChan
index|[
name|i
index|]
operator|=
name|sReadAiopNumChan
argument_list|(
operator|(
name|WordIO_t
operator|)
name|io
argument_list|)
expr_stmt|;
comment|/* num channels in AIOP */
name|sOutW
argument_list|(
operator|(
name|WordIO_t
operator|)
name|io
operator|+
name|_INDX_ADDR
argument_list|,
name|_CLK_PRE
argument_list|)
expr_stmt|;
comment|/* clock prescaler */
name|sOutB
argument_list|(
name|io
operator|+
name|_INDX_DATA
argument_list|,
name|CLOCK_PRESC
argument_list|)
expr_stmt|;
name|CtlP
operator|->
name|NumAiop
operator|++
expr_stmt|;
comment|/* bump count of AIOPs */
name|sDisAiop
argument_list|(
name|CtlP
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* disable AIOP */
block|}
if|if
condition|(
name|CtlP
operator|->
name|NumAiop
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|CtlP
operator|->
name|NumAiop
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sPCIInitController
parameter_list|(
name|CONTROLLER_T
modifier|*
name|CtlP
parameter_list|,
name|int
name|CtlNum
parameter_list|,
name|ByteIO_t
modifier|*
name|AiopIOList
parameter_list|,
name|int
name|AiopIOListSize
parameter_list|,
name|int
name|IRQNum
parameter_list|,
name|Byte_t
name|Frequency
parameter_list|,
name|int
name|PeriodicOnly
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ByteIO_t
name|io
decl_stmt|;
name|CtlP
operator|->
name|CtlNum
operator|=
name|CtlNum
expr_stmt|;
name|CtlP
operator|->
name|BusType
operator|=
name|isPCI
expr_stmt|;
name|CtlP
operator|->
name|CtlID
operator|=
name|CTLID_0001
expr_stmt|;
comment|/* controller release 1 */
name|CtlP
operator|->
name|PCIIO
operator|=
call|(
name|WordIO_t
call|)
argument_list|(
operator|(
name|ByteIO_t
operator|)
name|AiopIOList
index|[
literal|0
index|]
operator|+
name|_PCI_INT_FUNC
argument_list|)
expr_stmt|;
name|sPCIControllerEOI
argument_list|(
name|CtlP
argument_list|)
expr_stmt|;
comment|/* Init AIOPs */
name|CtlP
operator|->
name|NumAiop
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AiopIOListSize
condition|;
name|i
operator|++
control|)
block|{
name|io
operator|=
name|AiopIOList
index|[
name|i
index|]
expr_stmt|;
name|CtlP
operator|->
name|AiopIO
index|[
name|i
index|]
operator|=
operator|(
name|WordIO_t
operator|)
name|io
expr_stmt|;
name|CtlP
operator|->
name|AiopIntChanIO
index|[
name|i
index|]
operator|=
name|io
operator|+
name|_INT_CHAN
expr_stmt|;
name|CtlP
operator|->
name|AiopID
index|[
name|i
index|]
operator|=
name|sReadAiopID
argument_list|(
name|io
argument_list|)
expr_stmt|;
comment|/* read AIOP ID */
if|if
condition|(
name|CtlP
operator|->
name|AiopID
index|[
name|i
index|]
operator|==
name|AIOPID_NULL
condition|)
comment|/* if AIOP does not exist */
block|{
break|break;
comment|/* done looking for AIOPs */
block|}
name|CtlP
operator|->
name|AiopNumChan
index|[
name|i
index|]
operator|=
name|sReadAiopNumChan
argument_list|(
operator|(
name|WordIO_t
operator|)
name|io
argument_list|)
expr_stmt|;
comment|/* num channels in AIOP */
name|sOutW
argument_list|(
operator|(
name|WordIO_t
operator|)
name|io
operator|+
name|_INDX_ADDR
argument_list|,
name|_CLK_PRE
argument_list|)
expr_stmt|;
comment|/* clock prescaler */
name|sOutB
argument_list|(
name|io
operator|+
name|_INDX_DATA
argument_list|,
name|CLOCK_PRESC
argument_list|)
expr_stmt|;
name|CtlP
operator|->
name|NumAiop
operator|++
expr_stmt|;
comment|/* bump count of AIOPs */
block|}
if|if
condition|(
name|CtlP
operator|->
name|NumAiop
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|CtlP
operator|->
name|NumAiop
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sReadAiopID Purpose:  Read the AIOP idenfication number directly from an AIOP. Call:	  sReadAiopID(io) 	  ByteIO_t io: AIOP base I/O address Return:   int: Flag AIOPID_XXXX if a valid AIOP is found, where X 		 is replace by an identifying number. 	  Flag AIOPID_NULL if no valid AIOP is found Warnings: No context switches are allowed while executing this function.  */
end_comment

begin_function
name|int
name|sReadAiopID
parameter_list|(
name|ByteIO_t
name|io
parameter_list|)
block|{
name|Byte_t
name|AiopID
decl_stmt|;
comment|/* ID byte from AIOP */
name|sOutB
argument_list|(
name|io
operator|+
name|_CMD_REG
argument_list|,
name|RESET_ALL
argument_list|)
expr_stmt|;
comment|/* reset AIOP */
name|sOutB
argument_list|(
name|io
operator|+
name|_CMD_REG
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|AiopID
operator|=
name|sInB
argument_list|(
name|io
operator|+
name|_CHN_STAT0
argument_list|)
operator|&
literal|0x07
expr_stmt|;
if|if
condition|(
name|AiopID
operator|==
literal|0x06
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
comment|/* AIOP does not exist */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sReadAiopNumChan Purpose:  Read the number of channels available in an AIOP directly from 	  an AIOP. Call:	  sReadAiopNumChan(io) 	  WordIO_t io: AIOP base I/O address Return:   int: The number of channels available Comments: The number of channels is determined by write/reads from identical 	  offsets within the SRAM address spaces for channels 0 and 4. 	  If the channel 4 space is mirrored to channel 0 it is a 4 channel 	  AIOP, otherwise it is an 8 channel. Warnings: No context switches are allowed while executing this function. */
end_comment

begin_function
name|int
name|sReadAiopNumChan
parameter_list|(
name|WordIO_t
name|io
parameter_list|)
block|{
name|Word_t
name|x
decl_stmt|;
name|sOutDW
argument_list|(
operator|(
name|DWordIO_t
operator|)
name|io
operator|+
name|_INDX_ADDR
argument_list|,
literal|0x12340000L
argument_list|)
expr_stmt|;
comment|/* write to chan 0 SRAM */
name|sOutW
argument_list|(
name|io
operator|+
name|_INDX_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* read from SRAM, chan 0 */
name|x
operator|=
name|sInW
argument_list|(
name|io
operator|+
name|_INDX_DATA
argument_list|)
expr_stmt|;
name|sOutW
argument_list|(
name|io
operator|+
name|_INDX_ADDR
argument_list|,
literal|0x4000
argument_list|)
expr_stmt|;
comment|/* read from SRAM, chan 4 */
if|if
condition|(
name|x
operator|!=
name|sInW
argument_list|(
name|io
operator|+
name|_INDX_DATA
argument_list|)
condition|)
comment|/* if different must be 8 chan */
return|return
operator|(
literal|8
operator|)
return|;
else|else
return|return
operator|(
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sInitChan Purpose:  Initialization of a channel and channel structure Call:	  sInitChan(CtlP,ChP,AiopNum,ChanNum) 	  CONTROLLER_T *CtlP; Ptr to controller structure 	  CHANNEL_T *ChP; Ptr to channel structure 	  int AiopNum; AIOP number within controller 	  int ChanNum; Channel number within AIOP Return:   int: TRUE if initialization succeeded, FALSE if it fails because channel 	       number exceeds number of channels available in AIOP. Comments: This function must be called before a channel can be used. Warnings: No range checking on any of the parameters is done.  	  No context switches are allowed while executing this function. */
end_comment

begin_function
name|int
name|sInitChan
parameter_list|(
name|CONTROLLER_T
modifier|*
name|CtlP
parameter_list|,
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|,
name|int
name|AiopNum
parameter_list|,
name|int
name|ChanNum
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|WordIO_t
name|AiopIO
decl_stmt|;
name|WordIO_t
name|ChIOOff
decl_stmt|;
name|Byte_t
modifier|*
name|ChR
decl_stmt|;
name|Word_t
name|ChOff
decl_stmt|;
specifier|static
name|Byte_t
name|R
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|ChanNum
operator|>=
name|CtlP
operator|->
name|AiopNumChan
index|[
name|AiopNum
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* exceeds num chans in AIOP */
comment|/* Channel, AIOP, and controller identifiers */
name|ChP
operator|->
name|CtlP
operator|=
name|CtlP
expr_stmt|;
name|ChP
operator|->
name|ChanID
operator|=
name|CtlP
operator|->
name|AiopID
index|[
name|AiopNum
index|]
expr_stmt|;
name|ChP
operator|->
name|AiopNum
operator|=
name|AiopNum
expr_stmt|;
name|ChP
operator|->
name|ChanNum
operator|=
name|ChanNum
expr_stmt|;
comment|/* Global direct addresses */
name|AiopIO
operator|=
name|CtlP
operator|->
name|AiopIO
index|[
name|AiopNum
index|]
expr_stmt|;
name|ChP
operator|->
name|Cmd
operator|=
operator|(
name|ByteIO_t
operator|)
name|AiopIO
operator|+
name|_CMD_REG
expr_stmt|;
name|ChP
operator|->
name|IntChan
operator|=
operator|(
name|ByteIO_t
operator|)
name|AiopIO
operator|+
name|_INT_CHAN
expr_stmt|;
name|ChP
operator|->
name|IntMask
operator|=
operator|(
name|ByteIO_t
operator|)
name|AiopIO
operator|+
name|_INT_MASK
expr_stmt|;
name|ChP
operator|->
name|IndexAddr
operator|=
operator|(
name|DWordIO_t
operator|)
name|AiopIO
operator|+
name|_INDX_ADDR
expr_stmt|;
name|ChP
operator|->
name|IndexData
operator|=
name|AiopIO
operator|+
name|_INDX_DATA
expr_stmt|;
comment|/* Channel direct addresses */
name|ChIOOff
operator|=
name|AiopIO
operator|+
name|ChP
operator|->
name|ChanNum
operator|*
literal|2
expr_stmt|;
name|ChP
operator|->
name|TxRxData
operator|=
name|ChIOOff
operator|+
name|_TD0
expr_stmt|;
name|ChP
operator|->
name|ChanStat
operator|=
name|ChIOOff
operator|+
name|_CHN_STAT0
expr_stmt|;
name|ChP
operator|->
name|TxRxCount
operator|=
name|ChIOOff
operator|+
name|_FIFO_CNT0
expr_stmt|;
name|ChP
operator|->
name|IntID
operator|=
operator|(
name|ByteIO_t
operator|)
name|AiopIO
operator|+
name|ChP
operator|->
name|ChanNum
operator|+
name|_INT_ID0
expr_stmt|;
comment|/* Initialize the channel from the RData array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RDATASIZE
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|R
index|[
literal|0
index|]
operator|=
name|RData
index|[
name|i
index|]
expr_stmt|;
name|R
index|[
literal|1
index|]
operator|=
name|RData
index|[
name|i
operator|+
literal|1
index|]
operator|+
literal|0x10
operator|*
name|ChanNum
expr_stmt|;
name|R
index|[
literal|2
index|]
operator|=
name|RData
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|R
index|[
literal|3
index|]
operator|=
name|RData
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
name|sOutDW
argument_list|(
name|ChP
operator|->
name|IndexAddr
argument_list|,
operator|*
operator|(
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|R
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|ChR
operator|=
name|ChP
operator|->
name|R
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RREGDATASIZE
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|ChR
index|[
name|i
index|]
operator|=
name|RRegData
index|[
name|i
index|]
expr_stmt|;
name|ChR
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|RRegData
index|[
name|i
operator|+
literal|1
index|]
operator|+
literal|0x10
operator|*
name|ChanNum
expr_stmt|;
name|ChR
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|RRegData
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|ChR
index|[
name|i
operator|+
literal|3
index|]
operator|=
name|RRegData
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
comment|/* Indexed registers */
name|ChOff
operator|=
operator|(
name|Word_t
operator|)
name|ChanNum
operator|*
literal|0x1000
expr_stmt|;
name|ChP
operator|->
name|BaudDiv
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_BAUD
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|BaudDiv
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_BAUD
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|BaudDiv
index|[
literal|2
index|]
operator|=
operator|(
name|Byte_t
operator|)
name|BRD9600
expr_stmt|;
name|ChP
operator|->
name|BaudDiv
index|[
literal|3
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|BRD9600
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|sOutDW
argument_list|(
name|ChP
operator|->
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|BaudDiv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TX_CTRL
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TX_CTRL
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sOutDW
argument_list|(
name|ChP
operator|->
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxControl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|RxControl
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_RX_CTRL
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|RxControl
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_RX_CTRL
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|RxControl
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|RxControl
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sOutDW
argument_list|(
name|ChP
operator|->
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|RxControl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxEnables
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TX_ENBLS
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxEnables
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TX_ENBLS
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxEnables
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxEnables
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sOutDW
argument_list|(
name|ChP
operator|->
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxEnables
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxCompare
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TXCMP1
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxCompare
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TXCMP1
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxCompare
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxCompare
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sOutDW
argument_list|(
name|ChP
operator|->
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxCompare
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace1
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TXREP1B1
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace1
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TXREP1B1
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace1
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxReplace1
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sOutDW
argument_list|(
name|ChP
operator|->
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxReplace1
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace2
index|[
literal|0
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
name|ChOff
operator|+
name|_TXREP2
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace2
index|[
literal|1
index|]
operator|=
call|(
name|Byte_t
call|)
argument_list|(
operator|(
name|ChOff
operator|+
name|_TXREP2
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxReplace2
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ChP
operator|->
name|TxReplace2
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sOutDW
argument_list|(
name|ChP
operator|->
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxReplace2
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxFIFOPtrs
operator|=
name|ChOff
operator|+
name|_TXF_OUTP
expr_stmt|;
name|ChP
operator|->
name|TxFIFO
operator|=
name|ChOff
operator|+
name|_TX_FIFO
expr_stmt|;
name|sOutB
argument_list|(
name|ChP
operator|->
name|Cmd
argument_list|,
operator|(
name|Byte_t
operator|)
name|ChanNum
operator||
name|RESTXFCNT
argument_list|)
expr_stmt|;
comment|/* apply reset Tx FIFO count */
name|sOutB
argument_list|(
name|ChP
operator|->
name|Cmd
argument_list|,
operator|(
name|Byte_t
operator|)
name|ChanNum
argument_list|)
expr_stmt|;
comment|/* remove reset Tx FIFO count */
name|sOutW
argument_list|(
operator|(
name|WordIO_t
operator|)
name|ChP
operator|->
name|IndexAddr
argument_list|,
name|ChP
operator|->
name|TxFIFOPtrs
argument_list|)
expr_stmt|;
comment|/* clear Tx in/out ptrs */
name|sOutW
argument_list|(
name|ChP
operator|->
name|IndexData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|RxFIFOPtrs
operator|=
name|ChOff
operator|+
name|_RXF_OUTP
expr_stmt|;
name|ChP
operator|->
name|RxFIFO
operator|=
name|ChOff
operator|+
name|_RX_FIFO
expr_stmt|;
name|sOutB
argument_list|(
name|ChP
operator|->
name|Cmd
argument_list|,
operator|(
name|Byte_t
operator|)
name|ChanNum
operator||
name|RESRXFCNT
argument_list|)
expr_stmt|;
comment|/* apply reset Rx FIFO count */
name|sOutB
argument_list|(
name|ChP
operator|->
name|Cmd
argument_list|,
operator|(
name|Byte_t
operator|)
name|ChanNum
argument_list|)
expr_stmt|;
comment|/* remove reset Rx FIFO count */
name|sOutW
argument_list|(
operator|(
name|WordIO_t
operator|)
name|ChP
operator|->
name|IndexAddr
argument_list|,
name|ChP
operator|->
name|RxFIFOPtrs
argument_list|)
expr_stmt|;
comment|/* clear Rx out ptr */
name|sOutW
argument_list|(
name|ChP
operator|->
name|IndexData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sOutW
argument_list|(
operator|(
name|WordIO_t
operator|)
name|ChP
operator|->
name|IndexAddr
argument_list|,
name|ChP
operator|->
name|RxFIFOPtrs
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* clear Rx in ptr */
name|sOutW
argument_list|(
name|ChP
operator|->
name|IndexData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxPrioCnt
operator|=
name|ChOff
operator|+
name|_TXP_CNT
expr_stmt|;
name|sOutW
argument_list|(
operator|(
name|WordIO_t
operator|)
name|ChP
operator|->
name|IndexAddr
argument_list|,
name|ChP
operator|->
name|TxPrioCnt
argument_list|)
expr_stmt|;
name|sOutB
argument_list|(
name|ChP
operator|->
name|IndexData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxPrioPtr
operator|=
name|ChOff
operator|+
name|_TXP_PNTR
expr_stmt|;
name|sOutW
argument_list|(
operator|(
name|WordIO_t
operator|)
name|ChP
operator|->
name|IndexAddr
argument_list|,
name|ChP
operator|->
name|TxPrioPtr
argument_list|)
expr_stmt|;
name|sOutB
argument_list|(
name|ChP
operator|->
name|IndexData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxPrioBuf
operator|=
name|ChOff
operator|+
name|_TXP_BUF
expr_stmt|;
name|sEnRxProcessor
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* start the Rx processor */
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sStopRxProcessor Purpose:  Stop the receive processor from processing a channel. Call:	  sStopRxProcessor(ChP) 	  CHANNEL_T *ChP; Ptr to channel structure  Comments: The receive processor can be started again with sStartRxProcessor(). 	  This function causes the receive processor to skip over the 	  stopped channel.  It does not stop it from processing other channels.  Warnings: No context switches are allowed while executing this function.  	  Do not leave the receive processor stopped for more than one 	  character time.  	  After calling this function a delay of 4 uS is required to ensure 	  that the receive processor is no longer processing this channel. */
end_comment

begin_function
name|void
name|sStopRxProcessor
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|)
block|{
name|Byte_t
name|R
index|[
literal|4
index|]
decl_stmt|;
name|R
index|[
literal|0
index|]
operator|=
name|ChP
operator|->
name|R
index|[
literal|0
index|]
expr_stmt|;
name|R
index|[
literal|1
index|]
operator|=
name|ChP
operator|->
name|R
index|[
literal|1
index|]
expr_stmt|;
name|R
index|[
literal|2
index|]
operator|=
literal|0x0a
expr_stmt|;
name|R
index|[
literal|3
index|]
operator|=
name|ChP
operator|->
name|R
index|[
literal|3
index|]
expr_stmt|;
name|sOutDW
argument_list|(
name|ChP
operator|->
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|R
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sFlushRxFIFO Purpose:  Flush the Rx FIFO Call:	  sFlushRxFIFO(ChP) 	  CHANNEL_T *ChP; Ptr to channel structure Return:   void Comments: To prevent data from being enqueued or dequeued in the Tx FIFO 	  while it is being flushed the receive processor is stopped 	  and the transmitter is disabled.  After these operations a 	  4 uS delay is done before clearing the pointers to allow 	  the receive processor to stop.  These items are handled inside 	  this function. Warnings: No context switches are allowed while executing this function. */
end_comment

begin_function
name|void
name|sFlushRxFIFO
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Byte_t
name|Ch
decl_stmt|;
comment|/* channel number within AIOP */
name|int
name|RxFIFOEnabled
decl_stmt|;
comment|/* TRUE if Rx FIFO enabled */
if|if
condition|(
name|sGetRxCnt
argument_list|(
name|ChP
argument_list|)
operator|==
literal|0
condition|)
comment|/* Rx FIFO empty */
return|return;
comment|/* don't need to flush */
name|RxFIFOEnabled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ChP
operator|->
name|R
index|[
literal|0x32
index|]
operator|==
literal|0x08
condition|)
comment|/* Rx FIFO is enabled */
block|{
name|RxFIFOEnabled
operator|=
name|TRUE
expr_stmt|;
name|sDisRxFIFO
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* disable it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2000
operator|/
literal|200
condition|;
name|i
operator|++
control|)
comment|/* delay 2 uS to allow proc to disable FIFO*/
name|sInB
argument_list|(
name|ChP
operator|->
name|IntChan
argument_list|)
expr_stmt|;
comment|/* depends on bus i/o timing */
block|}
name|sGetChanStatus
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* clear any pending Rx errors in chan stat */
name|Ch
operator|=
operator|(
name|Byte_t
operator|)
name|sGetChanNum
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
name|sOutB
argument_list|(
name|ChP
operator|->
name|Cmd
argument_list|,
name|Ch
operator||
name|RESRXFCNT
argument_list|)
expr_stmt|;
comment|/* apply reset Rx FIFO count */
name|sOutB
argument_list|(
name|ChP
operator|->
name|Cmd
argument_list|,
name|Ch
argument_list|)
expr_stmt|;
comment|/* remove reset Rx FIFO count */
name|sOutW
argument_list|(
operator|(
name|WordIO_t
operator|)
name|ChP
operator|->
name|IndexAddr
argument_list|,
name|ChP
operator|->
name|RxFIFOPtrs
argument_list|)
expr_stmt|;
comment|/* clear Rx out ptr */
name|sOutW
argument_list|(
name|ChP
operator|->
name|IndexData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sOutW
argument_list|(
operator|(
name|WordIO_t
operator|)
name|ChP
operator|->
name|IndexAddr
argument_list|,
name|ChP
operator|->
name|RxFIFOPtrs
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* clear Rx in ptr */
name|sOutW
argument_list|(
name|ChP
operator|->
name|IndexData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|RxFIFOEnabled
condition|)
name|sEnRxFIFO
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* enable Rx FIFO */
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sFlushTxFIFO Purpose:  Flush the Tx FIFO Call:	  sFlushTxFIFO(ChP) 	  CHANNEL_T *ChP; Ptr to channel structure Return:   void Comments: To prevent data from being enqueued or dequeued in the Tx FIFO 	  while it is being flushed the receive processor is stopped 	  and the transmitter is disabled.  After these operations a 	  4 uS delay is done before clearing the pointers to allow 	  the receive processor to stop.  These items are handled inside 	  this function. Warnings: No context switches are allowed while executing this function. */
end_comment

begin_function
name|void
name|sFlushTxFIFO
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Byte_t
name|Ch
decl_stmt|;
comment|/* channel number within AIOP */
name|int
name|TxEnabled
decl_stmt|;
comment|/* TRUE if transmitter enabled */
if|if
condition|(
name|sGetTxCnt
argument_list|(
name|ChP
argument_list|)
operator|==
literal|0
condition|)
comment|/* Tx FIFO empty */
return|return;
comment|/* don't need to flush */
name|TxEnabled
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ChP
operator|->
name|TxControl
index|[
literal|3
index|]
operator|&
name|TX_ENABLE
condition|)
block|{
name|TxEnabled
operator|=
name|TRUE
expr_stmt|;
name|sDisTransmit
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* disable transmitter */
block|}
name|sStopRxProcessor
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* stop Rx processor */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4000
operator|/
literal|200
condition|;
name|i
operator|++
control|)
comment|/* delay 4 uS to allow proc to stop */
name|sInB
argument_list|(
name|ChP
operator|->
name|IntChan
argument_list|)
expr_stmt|;
comment|/* depends on bus i/o timing */
name|Ch
operator|=
operator|(
name|Byte_t
operator|)
name|sGetChanNum
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
name|sOutB
argument_list|(
name|ChP
operator|->
name|Cmd
argument_list|,
name|Ch
operator||
name|RESTXFCNT
argument_list|)
expr_stmt|;
comment|/* apply reset Tx FIFO count */
name|sOutB
argument_list|(
name|ChP
operator|->
name|Cmd
argument_list|,
name|Ch
argument_list|)
expr_stmt|;
comment|/* remove reset Tx FIFO count */
name|sOutW
argument_list|(
operator|(
name|WordIO_t
operator|)
name|ChP
operator|->
name|IndexAddr
argument_list|,
name|ChP
operator|->
name|TxFIFOPtrs
argument_list|)
expr_stmt|;
comment|/* clear Tx in/out ptrs */
name|sOutW
argument_list|(
name|ChP
operator|->
name|IndexData
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TxEnabled
condition|)
name|sEnTransmit
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* enable transmitter */
name|sStartRxProcessor
argument_list|(
name|ChP
argument_list|)
expr_stmt|;
comment|/* restart Rx processor */
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sWriteTxPrioByte Purpose:  Write a byte of priority transmit data to a channel Call:	  sWriteTxPrioByte(ChP,Data) 	  CHANNEL_T *ChP; Ptr to channel structure 	  Byte_t Data; The transmit data byte  Return:   int: 1 if the bytes is successfully written, otherwise 0.  Comments: The priority byte is transmitted before any data in the Tx FIFO.  Warnings: No context switches are allowed while executing this function. */
end_comment

begin_function
name|int
name|sWriteTxPrioByte
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|,
name|Byte_t
name|Data
parameter_list|)
block|{
name|Byte_t
name|DWBuf
index|[
literal|4
index|]
decl_stmt|;
comment|/* buffer for double word writes */
name|Word_t
modifier|*
name|WordPtr
decl_stmt|;
comment|/* must be far because Win SS != DS */
specifier|register
name|DWordIO_t
name|IndexAddr
decl_stmt|;
if|if
condition|(
name|sGetTxCnt
argument_list|(
name|ChP
argument_list|)
operator|>
literal|1
condition|)
comment|/* write it to Tx priority buffer */
block|{
name|IndexAddr
operator|=
name|ChP
operator|->
name|IndexAddr
expr_stmt|;
name|sOutW
argument_list|(
operator|(
name|WordIO_t
operator|)
name|IndexAddr
argument_list|,
name|ChP
operator|->
name|TxPrioCnt
argument_list|)
expr_stmt|;
comment|/* get priority buffer status */
if|if
condition|(
name|sInB
argument_list|(
operator|(
name|ByteIO_t
operator|)
name|ChP
operator|->
name|IndexData
argument_list|)
operator|&
name|PRI_PEND
condition|)
comment|/* priority buffer busy */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* nothing sent */
name|WordPtr
operator|=
operator|(
name|Word_t
operator|*
operator|)
operator|(
operator|&
name|DWBuf
index|[
literal|0
index|]
operator|)
expr_stmt|;
operator|*
name|WordPtr
operator|=
name|ChP
operator|->
name|TxPrioBuf
expr_stmt|;
comment|/* data byte address */
name|DWBuf
index|[
literal|2
index|]
operator|=
name|Data
expr_stmt|;
comment|/* data byte value */
name|sOutDW
argument_list|(
name|IndexAddr
argument_list|,
operator|*
operator|(
operator|(
name|DWord_t
operator|*
operator|)
operator|(
operator|&
name|DWBuf
index|[
literal|0
index|]
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* write it out */
operator|*
name|WordPtr
operator|=
name|ChP
operator|->
name|TxPrioCnt
expr_stmt|;
comment|/* Tx priority count address */
name|DWBuf
index|[
literal|2
index|]
operator|=
name|PRI_PEND
operator|+
literal|1
expr_stmt|;
comment|/* indicate 1 byte pending */
name|DWBuf
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* priority buffer pointer */
name|sOutDW
argument_list|(
name|IndexAddr
argument_list|,
operator|*
operator|(
operator|(
name|DWord_t
operator|*
operator|)
operator|(
operator|&
name|DWBuf
index|[
literal|0
index|]
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* write it out */
block|}
else|else
comment|/* write it to Tx FIFO */
block|{
name|sWriteTxByte
argument_list|(
name|sGetTxRxDataIO
argument_list|(
name|ChP
argument_list|)
argument_list|,
name|Data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 1 byte sent */
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sEnInterrupts Purpose:  Enable one or more interrupts for a channel Call:	  sEnInterrupts(ChP,Flags) 	  CHANNEL_T *ChP; Ptr to channel structure 	  Word_t Flags: Interrupt enable flags, can be any combination 	     of the following flags: 		TXINT_EN:   Interrupt on Tx FIFO empty 		RXINT_EN:   Interrupt on Rx FIFO at trigger level (see 			    sSetRxTrigger()) 		SRCINT_EN:  Interrupt on SRC (Special Rx Condition) 		MCINT_EN:   Interrupt on modem input change 		CHANINT_EN: Allow channel interrupt signal to the AIOP's 			    Interrupt Channel Register. Return:   void Comments: If an interrupt enable flag is set in Flags, that interrupt will be 	  enabled.  If an interrupt enable flag is not set in Flags, that 	  interrupt will not be changed.  Interrupts can be disabled with 	  function sDisInterrupts().  	  This function sets the appropriate bit for the channel in the AIOP's 	  Interrupt Mask Register if the CHANINT_EN flag is set.  This allows 	  this channel's bit to be set in the AIOP's Interrupt Channel Register.  	  Interrupts must also be globally enabled before channel interrupts 	  will be passed on to the host.  This is done with function 	  sEnGlobalInt().  	  In some cases it may be desirable to disable interrupts globally but 	  enable channel interrupts.  This would allow the global interrupt 	  status register to be used to determine which AIOPs need service. */
end_comment

begin_function
name|void
name|sEnInterrupts
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|,
name|Word_t
name|Flags
parameter_list|)
block|{
name|Byte_t
name|Mask
decl_stmt|;
comment|/* Interrupt Mask Register */
name|ChP
operator|->
name|RxControl
index|[
literal|2
index|]
operator||=
operator|(
operator|(
name|Byte_t
operator|)
name|Flags
operator|&
operator|(
name|RXINT_EN
operator||
name|SRCINT_EN
operator||
name|MCINT_EN
operator|)
operator|)
expr_stmt|;
name|sOutDW
argument_list|(
name|ChP
operator|->
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|RxControl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|2
index|]
operator||=
operator|(
operator|(
name|Byte_t
operator|)
name|Flags
operator|&
name|TXINT_EN
operator|)
expr_stmt|;
name|sOutDW
argument_list|(
name|ChP
operator|->
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxControl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Flags
operator|&
name|CHANINT_EN
condition|)
block|{
name|Mask
operator|=
name|sInB
argument_list|(
name|ChP
operator|->
name|IntMask
argument_list|)
operator||
name|sBitMapSetTbl
index|[
name|ChP
operator|->
name|ChanNum
index|]
expr_stmt|;
name|sOutB
argument_list|(
name|ChP
operator|->
name|IntMask
argument_list|,
name|Mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*************************************************************************** Function: sDisInterrupts Purpose:  Disable one or more interrupts for a channel Call:	  sDisInterrupts(ChP,Flags) 	  CHANNEL_T *ChP; Ptr to channel structure 	  Word_t Flags: Interrupt flags, can be any combination 	     of the following flags: 		TXINT_EN:   Interrupt on Tx FIFO empty 		RXINT_EN:   Interrupt on Rx FIFO at trigger level (see 			    sSetRxTrigger()) 		SRCINT_EN:  Interrupt on SRC (Special Rx Condition) 		MCINT_EN:   Interrupt on modem input change 		CHANINT_EN: Disable channel interrupt signal to the 			    AIOP's Interrupt Channel Register. Return:   void Comments: If an interrupt flag is set in Flags, that interrupt will be 	  disabled.  If an interrupt flag is not set in Flags, that 	  interrupt will not be changed.  Interrupts can be enabled with 	  function sEnInterrupts().  	  This function clears the appropriate bit for the channel in the AIOP's 	  Interrupt Mask Register if the CHANINT_EN flag is set.  This blocks 	  this channel's bit from being set in the AIOP's Interrupt Channel 	  Register. */
end_comment

begin_function
name|void
name|sDisInterrupts
parameter_list|(
name|CHANNEL_T
modifier|*
name|ChP
parameter_list|,
name|Word_t
name|Flags
parameter_list|)
block|{
name|Byte_t
name|Mask
decl_stmt|;
comment|/* Interrupt Mask Register */
name|ChP
operator|->
name|RxControl
index|[
literal|2
index|]
operator|&=
operator|~
operator|(
operator|(
name|Byte_t
operator|)
name|Flags
operator|&
operator|(
name|RXINT_EN
operator||
name|SRCINT_EN
operator||
name|MCINT_EN
operator|)
operator|)
expr_stmt|;
name|sOutDW
argument_list|(
name|ChP
operator|->
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|RxControl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ChP
operator|->
name|TxControl
index|[
literal|2
index|]
operator|&=
operator|~
operator|(
operator|(
name|Byte_t
operator|)
name|Flags
operator|&
name|TXINT_EN
operator|)
expr_stmt|;
name|sOutDW
argument_list|(
name|ChP
operator|->
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
name|ChP
operator|->
name|TxControl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|Flags
operator|&
name|CHANINT_EN
condition|)
block|{
name|Mask
operator|=
name|sInB
argument_list|(
name|ChP
operator|->
name|IntMask
argument_list|)
operator|&
name|sBitMapClrTbl
index|[
name|ChP
operator|->
name|ChanNum
index|]
expr_stmt|;
name|sOutB
argument_list|(
name|ChP
operator|->
name|IntMask
argument_list|,
name|Mask
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*********************************************************************   Begin FreeBsd-specific driver code **********************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|int
name|rpprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rpattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|rp_pciprobe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rp_pciattach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_long
name|rp_pcicount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|rp_pcidevice
init|=
block|{
literal|"rp"
block|,
name|rp_pciprobe
block|,
name|rp_pciattach
block|,
operator|&
name|rp_pcicount
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|COMPAT_PCI_DRIVER
argument_list|(
name|rp_pci
argument_list|,
name|rp_pcidevice
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|rpdtrwakeup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|rpdriver
init|=
block|{
name|rpprobe
block|,
name|rpattach
block|,
literal|"rp"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|driver_name
index|[]
init|=
literal|"rp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|rpopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|rpclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|rpwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|rpioctl
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|81
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|rp_cdevsw
init|=
block|{
comment|/* open */
name|rpopen
block|,
comment|/* close */
name|rpclose
block|,
comment|/* read */
name|ttyread
block|,
comment|/* write */
name|rpwrite
block|,
comment|/* ioctl */
name|rpioctl
block|,
comment|/* poll */
name|ttypoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
name|driver_name
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
name|D_TTY
operator||
name|D_KQFILTER
block|,
comment|/* bmaj */
operator|-
literal|1
block|,
comment|/* kqfilter */
name|ttykqfilter
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rp_controller_port
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rp_num_ports_open
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ndevs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|minor_to_unit
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static	struct	tty	rp_tty[128];
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|rp_num_ports
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of ports on each controller */
end_comment

begin_define
define|#
directive|define
name|_INLINE_
value|__inline
end_define

begin_define
define|#
directive|define
name|POLL_INTERVAL
value|1
end_define

begin_define
define|#
directive|define
name|CALLOUT_MASK
value|0x80
end_define

begin_define
define|#
directive|define
name|CONTROL_MASK
value|0x60
end_define

begin_define
define|#
directive|define
name|CONTROL_INIT_STATE
value|0x20
end_define

begin_define
define|#
directive|define
name|CONTROL_LOCK_STATE
value|0x40
end_define

begin_define
define|#
directive|define
name|DEV_UNIT
parameter_list|(
name|dev
parameter_list|)
value|(MINOR_TO_UNIT(minor(dev))
end_define

begin_define
define|#
directive|define
name|MINOR_MAGIC_MASK
value|(CALLOUT_MASK | CONTROL_MASK)
end_define

begin_define
define|#
directive|define
name|MINOR_MAGIC
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev))& ~MINOR_MAGIC_MASK)
end_define

begin_define
define|#
directive|define
name|IS_CALLOUT
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& CALLOUT_MASK)
end_define

begin_define
define|#
directive|define
name|IS_CONTROL
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& CONTROL_MASK)
end_define

begin_define
define|#
directive|define
name|RP_ISMULTIPORT
parameter_list|(
name|dev
parameter_list|)
value|((dev)->id_flags& 0x1)
end_define

begin_define
define|#
directive|define
name|RP_MPMASTER
parameter_list|(
name|dev
parameter_list|)
value|(((dev)->id_flags>> 8)& 0xff)
end_define

begin_define
define|#
directive|define
name|RP_NOTAST4
parameter_list|(
name|dev
parameter_list|)
value|((dev)->id_flags& 0x04)
end_define

begin_decl_stmt
specifier|static
name|struct
name|rp_port
modifier|*
name|p_rp_addr
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rp_port
modifier|*
name|p_rp_table
index|[
name|MAX_RP_PORTS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|rp_addr
parameter_list|(
name|unit
parameter_list|)
value|(p_rp_addr[unit])
end_define

begin_define
define|#
directive|define
name|rp_table
parameter_list|(
name|port
parameter_list|)
value|(p_rp_table[port])
end_define

begin_comment
comment|/*  * The top-level routines begin here  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rpparam
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|,
expr|struct
name|termios
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rpstart
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rpstop
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rphardclose
name|__P
argument_list|(
operator|(
expr|struct
name|rp_port
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|rp_disc_optim
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|termios
operator|*
name|t
operator|,
expr|struct
name|rp_port
operator|*
name|rp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|_INLINE_
name|void
name|rp_do_receive
parameter_list|(
name|struct
name|rp_port
modifier|*
name|rp
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|CHANNEL_t
modifier|*
name|cp
parameter_list|,
name|unsigned
name|int
name|ChanStatus
parameter_list|)
block|{
name|int
name|spl
decl_stmt|;
name|unsigned
name|int
name|CharNStat
decl_stmt|;
name|int
name|ToRecv
decl_stmt|,
name|ch
decl_stmt|;
name|ToRecv
operator|=
name|sGetRxCnt
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ToRecv
operator|==
literal|0
condition|)
return|return;
comment|/*	If status indicates there are errored characters in the 	FIFO, then enter status mode (a word in FIFO holds 	characters and status) */
if|if
condition|(
name|ChanStatus
operator|&
operator|(
name|RXFOVERFL
operator||
name|RXBREAK
operator||
name|RXFRAME
operator||
name|RXPARITY
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ChanStatus
operator|&
name|STATMODE
operator|)
condition|)
block|{
name|ChanStatus
operator||=
name|STATMODE
expr_stmt|;
name|sEnRxStatusMode
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	if we previously entered status mode then read down the 	FIFO one word at a time, pulling apart the character and 	the status. Update error counters depending on status. */
if|if
condition|(
name|ChanStatus
operator|&
name|STATMODE
condition|)
block|{
while|while
condition|(
name|ToRecv
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
condition|)
block|{
break|break;
block|}
name|CharNStat
operator|=
name|sInW
argument_list|(
name|sGetTxRxDataIO
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|ch
operator|=
name|CharNStat
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|CharNStat
operator|&
name|STMBREAK
operator|)
operator|||
operator|(
name|CharNStat
operator|&
name|STMFRAMEH
operator|)
condition|)
name|ch
operator||=
name|TTY_FE
expr_stmt|;
elseif|else
if|if
condition|(
name|CharNStat
operator|&
name|STMPARITYH
condition|)
name|ch
operator||=
name|TTY_PE
expr_stmt|;
elseif|else
if|if
condition|(
name|CharNStat
operator|&
name|STMRCVROVRH
condition|)
name|rp
operator|->
name|rp_overflows
operator|++
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|ch
operator|,
name|tp
operator|)
expr_stmt|;
name|ToRecv
operator|--
expr_stmt|;
block|}
comment|/* 	After emtying FIFO in status mode, turn off status mode */
if|if
condition|(
name|sGetRxCnt
argument_list|(
name|cp
argument_list|)
operator|==
literal|0
condition|)
name|sDisRxStatusMode
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|ToRecv
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
condition|)
block|{
break|break;
block|}
name|ch
operator|=
operator|(
name|u_char
operator|)
name|sInB
argument_list|(
name|sGetTxRxDataIO
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|spl
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|ch
operator|,
name|tp
operator|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
name|ToRecv
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|_INLINE_
name|void
name|rp_handle_port
parameter_list|(
name|struct
name|rp_port
modifier|*
name|rp
parameter_list|)
block|{
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|int
name|IntMask
decl_stmt|,
name|ChanStatus
decl_stmt|;
comment|/*	int	oldcts; */
if|if
condition|(
operator|!
name|rp
condition|)
return|return;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
name|IntMask
operator|=
name|sGetChanIntID
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|IntMask
operator|=
name|IntMask
operator|&
name|rp
operator|->
name|rp_intmask
expr_stmt|;
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|IntMask
operator|&
name|RXF_TRIG
condition|)
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|rp_do_receive
argument_list|(
name|rp
argument_list|,
name|tp
argument_list|,
name|cp
argument_list|,
name|ChanStatus
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IntMask
operator|&
name|DELTA_CD
condition|)
block|{
if|if
condition|(
name|ChanStatus
operator|&
name|CD_ACT
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
name|rphardclose
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*	oldcts = rp->rp_cts; 	rp->rp_cts = ((ChanStatus& CTS_ACT) != 0); 	if(oldcts != rp->rp_cts) { 		printf("CTS change (now %s)... on port %d\n", rp->rp_cts ? "on" : "off", rp->rp_port); 	} */
block|}
end_function

begin_function
specifier|static
name|void
name|rp_do_poll
parameter_list|(
name|void
modifier|*
name|not_used
parameter_list|)
block|{
name|CONTROLLER_t
modifier|*
name|ctl
decl_stmt|;
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|aiop
decl_stmt|,
name|ch
decl_stmt|,
name|line
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|char
name|CtlMask
decl_stmt|,
name|AiopMask
decl_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<=
name|ndevs
condition|;
name|unit
operator|++
control|)
block|{
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|rp
operator|->
name|rp_ctlp
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|BusType
operator|==
name|isPCI
condition|)
name|CtlMask
operator|=
name|sPCIGetControllerIntStatus
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
else|else
name|CtlMask
operator|=
name|sGetControllerIntStatus
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
for|for
control|(
name|aiop
operator|=
literal|0
init|;
name|CtlMask
condition|;
name|CtlMask
operator|>>=
literal|1
operator|,
name|aiop
operator|++
control|)
block|{
if|if
condition|(
name|CtlMask
operator|&
literal|1
condition|)
block|{
name|AiopMask
operator|=
name|sGetAiopIntStatus
argument_list|(
name|ctl
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|AiopMask
condition|;
name|AiopMask
operator|>>=
literal|1
operator|,
name|ch
operator|++
control|)
block|{
if|if
condition|(
name|AiopMask
operator|&
literal|1
condition|)
block|{
name|line
operator|=
operator|(
name|unit
operator|<<
literal|5
operator|)
operator||
operator|(
name|aiop
operator|<<
literal|3
operator|)
operator||
name|ch
expr_stmt|;
name|rp
operator|=
name|rp_table
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|rp_handle_port
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
for|for
control|(
name|line
operator|=
literal|0
operator|,
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
init|;
name|line
operator|<
name|rp_num_ports
index|[
name|unit
index|]
condition|;
name|line
operator|++
operator|,
name|rp
operator|++
control|)
block|{
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
condition|)
block|{
name|count
operator|=
name|sGetTxCnt
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_state
operator|&=
operator|~
operator|(
name|TS_BUSY
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|&&
operator|(
name|count
operator|<=
name|rp
operator|->
name|rp_restart
operator|)
condition|)
block|{
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|rp_num_ports_open
condition|)
name|timeout
argument_list|(
name|rp_do_poll
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|POLL_INTERVAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rp_pciprobe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
name|int
name|vendor_id
decl_stmt|;
name|vendor_id
operator|=
name|type
operator|&
literal|0xffff
expr_stmt|;
switch|switch
condition|(
name|vendor_id
condition|)
case|case
literal|0x11fe
case|:
return|return
operator|(
literal|"rp"
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rpprobe
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|controller
decl_stmt|,
name|unit
decl_stmt|;
name|int
name|aiop
decl_stmt|,
name|num_aiops
decl_stmt|;
name|unsigned
name|int
name|aiopio
index|[
name|MAX_AIOPS_PER_BOARD
index|]
decl_stmt|;
name|CONTROLLER_t
modifier|*
name|ctlp
decl_stmt|;
name|unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_unit
operator|>=
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"rpprobe: unit number %d invalid.\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|printf
argument_list|(
literal|"probing for RocketPort(ISA) unit %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp_controller_port
condition|)
name|controller
operator|=
name|rp_controller_port
expr_stmt|;
else|else
block|{
name|controller
operator|=
name|dev
operator|->
name|id_iobase
operator|+
literal|0x40
expr_stmt|;
block|}
for|for
control|(
name|aiop
operator|=
literal|0
init|;
name|aiop
operator|<
name|MAX_AIOPS_PER_BOARD
condition|;
name|aiop
operator|++
control|)
name|aiopio
index|[
name|aiop
index|]
operator|=
name|dev
operator|->
name|id_iobase
operator|+
operator|(
name|aiop
operator|*
literal|0x400
operator|)
expr_stmt|;
name|ctlp
operator|=
name|sCtlNumToCtlPtr
argument_list|(
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|num_aiops
operator|=
name|sInitController
argument_list|(
name|ctlp
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|controller
operator|+
operator|(
operator|(
name|unit
operator|-
name|rp_pcicount
operator|)
operator|*
literal|0x400
operator|)
argument_list|,
name|aiopio
argument_list|,
name|MAX_AIOPS_PER_BOARD
argument_list|,
literal|0
argument_list|,
name|FREQ_DIS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_aiops
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"board%d init failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|rp_controller_port
condition|)
block|{
name|dev
operator|->
name|id_msize
operator|=
literal|64
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|id_msize
operator|=
literal|68
expr_stmt|;
name|rp_controller_port
operator|=
name|controller
expr_stmt|;
block|}
name|dev
operator|->
name|id_irq
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rp_pciattach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|int
name|success
decl_stmt|,
name|oldspl
decl_stmt|;
name|u_short
name|iobase
decl_stmt|;
name|int
name|num_ports
decl_stmt|,
name|num_chan
decl_stmt|,
name|num_aiops
decl_stmt|;
name|int
name|aiop
decl_stmt|,
name|chan
decl_stmt|,
name|port
decl_stmt|;
name|int
name|ChanStatus
decl_stmt|,
name|line
decl_stmt|,
name|i
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|int
name|aiopio
index|[
name|MAX_AIOPS_PER_BOARD
index|]
decl_stmt|;
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tty
decl_stmt|;
name|CONTROLLER_t
modifier|*
name|ctlp
decl_stmt|;
name|success
operator|=
name|pci_map_port
argument_list|(
name|tag
argument_list|,
literal|0x10
argument_list|,
operator|&
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
name|printf
argument_list|(
literal|"ioaddr mapping failed for RocketPort(PCI)\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|aiop
operator|=
literal|0
init|;
name|aiop
operator|<
name|MAX_AIOPS_PER_BOARD
condition|;
name|aiop
operator|++
control|)
name|aiopio
index|[
name|aiop
index|]
operator|=
name|iobase
operator|+
operator|(
name|aiop
operator|*
literal|0x40
operator|)
expr_stmt|;
name|ctlp
operator|=
name|sCtlNumToCtlPtr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|num_aiops
operator|=
name|sPCIInitController
argument_list|(
name|ctlp
argument_list|,
name|unit
argument_list|,
name|aiopio
argument_list|,
name|MAX_AIOPS_PER_BOARD
argument_list|,
literal|0
argument_list|,
name|FREQ_DIS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num_ports
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|aiop
operator|=
literal|0
init|;
name|aiop
operator|<
name|num_aiops
condition|;
name|aiop
operator|++
control|)
block|{
name|sResetAiopByNum
argument_list|(
name|ctlp
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
name|num_ports
operator|+=
name|sGetAiopNumChan
argument_list|(
name|ctlp
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"RocketPort%d = %d ports\n"
argument_list|,
name|unit
argument_list|,
name|num_ports
argument_list|)
expr_stmt|;
name|rp_num_ports
index|[
name|unit
index|]
operator|=
name|num_ports
expr_stmt|;
name|rp
operator|=
operator|(
expr|struct
name|rp_port
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rp_port
argument_list|)
operator|*
name|num_ports
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"rp_attach: Could not malloc rp_ports structures\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|count
operator|=
name|unit
operator|*
literal|32
expr_stmt|;
comment|/* board times max ports per card SG */
for|for
control|(
name|i
operator|=
name|count
init|;
name|i
operator|<
operator|(
name|count
operator|+
name|rp_num_ports
index|[
name|unit
index|]
operator|)
condition|;
name|i
operator|++
control|)
name|minor_to_unit
index|[
name|i
index|]
operator|=
name|unit
expr_stmt|;
name|bzero
argument_list|(
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rp_port
argument_list|)
operator|*
name|num_ports
argument_list|)
expr_stmt|;
name|tty
operator|=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tty
argument_list|)
operator|*
name|num_ports
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"rp_attach: Could not malloc tty structures\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tty
argument_list|)
operator|*
name|num_ports
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|=
name|rp
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|rp_cdevsw
argument_list|)
expr_stmt|;
name|port
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|aiop
operator|=
literal|0
init|;
name|aiop
operator|<
name|num_aiops
condition|;
name|aiop
operator|++
control|)
block|{
name|num_chan
operator|=
name|sGetAiopNumChan
argument_list|(
name|ctlp
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|num_chan
condition|;
name|chan
operator|++
operator|,
name|port
operator|++
operator|,
name|rp
operator|++
operator|,
name|tty
operator|++
control|)
block|{
name|rp
operator|->
name|rp_tty
operator|=
name|tty
expr_stmt|;
name|rp
operator|->
name|rp_port
operator|=
name|port
expr_stmt|;
name|rp
operator|->
name|rp_ctlp
operator|=
name|ctlp
expr_stmt|;
name|rp
operator|->
name|rp_unit
operator|=
name|unit
expr_stmt|;
name|rp
operator|->
name|rp_chan
operator|=
name|chan
expr_stmt|;
name|rp
operator|->
name|rp_aiop
operator|=
name|aiop
expr_stmt|;
name|tty
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
comment|/*		tty->t_termios = deftermios; 	*/
name|rp
operator|->
name|dtr_wait
operator|=
literal|3
operator|*
name|hz
expr_stmt|;
name|rp
operator|->
name|it_in
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|rp
operator|->
name|it_in
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|rp
operator|->
name|it_in
operator|.
name|c_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|rp
operator|->
name|it_in
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|termioschars
argument_list|(
operator|&
name|rp
operator|->
name|it_in
argument_list|)
expr_stmt|;
comment|/*		termioschars(&tty->t_termios); 	*/
name|rp
operator|->
name|it_in
operator|.
name|c_ispeed
operator|=
name|rp
operator|->
name|it_in
operator|.
name|c_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
name|rp
operator|->
name|it_out
operator|=
name|rp
operator|->
name|it_in
expr_stmt|;
name|rp
operator|->
name|rp_intmask
operator|=
name|RXF_TRIG
operator||
name|TXFIFO_MT
operator||
name|SRC_INT
operator||
name|DELTA_CD
operator||
name|DELTA_CTS
operator||
name|DELTA_DSR
expr_stmt|;
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|sInitChan
argument_list|(
name|ctlp
argument_list|,
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|aiop
argument_list|,
name|chan
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"RocketPort sInitChan(%d, %d, %d) failed 					\n"
argument_list|,
name|unit
argument_list|,
name|aiop
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return;
block|}
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_cts
operator|=
operator|(
name|ChanStatus
operator|&
name|CTS_ACT
operator|)
operator|!=
literal|0
expr_stmt|;
name|line
operator|=
operator|(
name|unit
operator|<<
literal|5
operator|)
operator||
operator|(
name|aiop
operator|<<
literal|3
operator|)
operator||
name|chan
expr_stmt|;
name|rp_table
argument_list|(
name|line
argument_list|)
operator|=
name|rp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|rpattach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|iobase
decl_stmt|,
name|unit
decl_stmt|,
comment|/*rpmajor,*/
name|oldspl
decl_stmt|;
name|int
name|num_ports
decl_stmt|,
name|num_chan
decl_stmt|,
name|num_aiops
decl_stmt|;
name|int
name|aiop
decl_stmt|,
name|chan
decl_stmt|,
name|port
decl_stmt|;
name|int
name|ChanStatus
decl_stmt|,
name|line
decl_stmt|,
name|i
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|int
name|aiopio
index|[
name|MAX_AIOPS_PER_BOARD
index|]
decl_stmt|;
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tty
decl_stmt|;
name|CONTROLLER_t
modifier|*
name|ctlp
decl_stmt|;
name|iobase
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
name|unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
name|ndevs
operator|=
name|unit
expr_stmt|;
for|for
control|(
name|aiop
operator|=
literal|0
init|;
name|aiop
operator|<
name|MAX_AIOPS_PER_BOARD
condition|;
name|aiop
operator|++
control|)
name|aiopio
index|[
name|aiop
index|]
operator|=
name|iobase
operator|+
operator|(
name|aiop
operator|*
literal|0x400
operator|)
expr_stmt|;
name|ctlp
operator|=
name|sCtlNumToCtlPtr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|num_aiops
operator|=
name|sInitController
argument_list|(
name|ctlp
argument_list|,
name|unit
argument_list|,
name|rp_controller_port
operator|+
operator|(
operator|(
name|unit
operator|-
name|rp_pcicount
operator|)
operator|*
literal|0x400
operator|)
argument_list|,
name|aiopio
argument_list|,
name|MAX_AIOPS_PER_BOARD
argument_list|,
literal|0
argument_list|,
name|FREQ_DIS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|num_ports
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|aiop
operator|=
literal|0
init|;
name|aiop
operator|<
name|num_aiops
condition|;
name|aiop
operator|++
control|)
block|{
name|sResetAiopByNum
argument_list|(
name|ctlp
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
name|sEnAiop
argument_list|(
name|ctlp
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
name|num_ports
operator|+=
name|sGetAiopNumChan
argument_list|(
name|ctlp
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"RocketPort%d = %d ports\n"
argument_list|,
name|unit
argument_list|,
name|num_ports
argument_list|)
expr_stmt|;
name|rp_num_ports
index|[
name|unit
index|]
operator|=
name|num_ports
expr_stmt|;
name|rp
operator|=
operator|(
expr|struct
name|rp_port
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rp_port
argument_list|)
operator|*
name|num_ports
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"rp_attach: Could not malloc rp_ports structures\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|count
operator|=
name|unit
operator|*
literal|32
expr_stmt|;
comment|/* board # times max ports per card  SG */
for|for
control|(
name|i
operator|=
name|count
init|;
name|i
operator|<
operator|(
name|count
operator|+
name|rp_num_ports
index|[
name|unit
index|]
operator|)
condition|;
name|i
operator|++
control|)
name|minor_to_unit
index|[
name|i
index|]
operator|=
name|unit
expr_stmt|;
name|bzero
argument_list|(
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rp_port
argument_list|)
operator|*
name|num_ports
argument_list|)
expr_stmt|;
name|tty
operator|=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tty
argument_list|)
operator|*
name|num_ports
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"rp_attach: Could not malloc tty structures\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bzero
argument_list|(
name|tty
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tty
argument_list|)
operator|*
name|num_ports
argument_list|)
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|=
name|rp
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|rp_cdevsw
argument_list|)
expr_stmt|;
name|port
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|aiop
operator|=
literal|0
init|;
name|aiop
operator|<
name|num_aiops
condition|;
name|aiop
operator|++
control|)
block|{
name|num_chan
operator|=
name|sGetAiopNumChan
argument_list|(
name|ctlp
argument_list|,
name|aiop
argument_list|)
expr_stmt|;
for|for
control|(
name|chan
operator|=
literal|0
init|;
name|chan
operator|<
name|num_chan
condition|;
name|chan
operator|++
operator|,
name|port
operator|++
operator|,
name|rp
operator|++
operator|,
name|tty
operator|++
control|)
block|{
name|rp
operator|->
name|rp_tty
operator|=
name|tty
expr_stmt|;
name|rp
operator|->
name|rp_port
operator|=
name|port
expr_stmt|;
name|rp
operator|->
name|rp_ctlp
operator|=
name|ctlp
expr_stmt|;
name|rp
operator|->
name|rp_unit
operator|=
name|unit
expr_stmt|;
name|rp
operator|->
name|rp_chan
operator|=
name|chan
expr_stmt|;
name|rp
operator|->
name|rp_aiop
operator|=
name|aiop
expr_stmt|;
name|tty
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
comment|/*		tty->t_termios = deftermios; 	*/
name|rp
operator|->
name|dtr_wait
operator|=
literal|3
operator|*
name|hz
expr_stmt|;
name|rp
operator|->
name|it_in
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|rp
operator|->
name|it_in
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|rp
operator|->
name|it_in
operator|.
name|c_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|rp
operator|->
name|it_in
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|termioschars
argument_list|(
operator|&
name|rp
operator|->
name|it_in
argument_list|)
expr_stmt|;
comment|/*		termioschars(&tty->t_termios); 	*/
name|rp
operator|->
name|it_in
operator|.
name|c_ispeed
operator|=
name|rp
operator|->
name|it_in
operator|.
name|c_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
name|rp
operator|->
name|it_out
operator|=
name|rp
operator|->
name|it_in
expr_stmt|;
name|rp
operator|->
name|rp_intmask
operator|=
name|RXF_TRIG
operator||
name|TXFIFO_MT
operator||
name|SRC_INT
operator||
name|DELTA_CD
operator||
name|DELTA_CTS
operator||
name|DELTA_DSR
expr_stmt|;
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|sInitChan
argument_list|(
name|ctlp
argument_list|,
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|aiop
argument_list|,
name|chan
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"RocketPort sInitChan(%d, %d, %d) failed 					\n"
argument_list|,
name|unit
argument_list|,
name|aiop
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_cts
operator|=
operator|(
name|ChanStatus
operator|&
name|CTS_ACT
operator|)
operator|!=
literal|0
expr_stmt|;
name|line
operator|=
operator|(
name|unit
operator|<<
literal|5
operator|)
operator||
operator|(
name|aiop
operator|<<
literal|3
operator|)
operator||
name|chan
expr_stmt|;
name|rp_table
argument_list|(
name|line
argument_list|)
operator|=
name|rp
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rpopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|port
decl_stmt|,
name|mynor
decl_stmt|,
name|umynor
decl_stmt|,
name|flags
decl_stmt|;
comment|/* SG */
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|oldspl
decl_stmt|,
name|error
decl_stmt|;
name|unsigned
name|int
name|IntMask
decl_stmt|,
name|ChanStatus
decl_stmt|;
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
if|if
condition|(
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|IS_CONTROL
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
comment|/*	rp->rp_tty =&rp_tty[rp->rp_port]; */
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
name|dev
operator|->
name|si_tty
operator|=
name|tp
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|open_top
label|:
while|while
condition|(
name|rp
operator|->
name|state
operator|&
operator|~
name|SET_DTR
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|rp
operator|->
name|dtr_wait
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"rpdtr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
condition|)
block|{
if|if
condition|(
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|rp
operator|->
name|active_out
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|rp
operator|->
name|active_out
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|rp
operator|->
name|active_out
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"rpbi"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
goto|goto
name|open_top
goto|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|suser
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
else|else
block|{
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|rpparam
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|rpstart
expr_stmt|;
name|tp
operator|->
name|t_stop
operator|=
name|rpstop
expr_stmt|;
name|tp
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|=
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|?
name|rp
operator|->
name|it_out
else|:
name|rp
operator|->
name|it_in
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|flags
operator||=
name|SET_RTS
expr_stmt|;
name|flags
operator||=
name|SET_DTR
expr_stmt|;
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator|&
operator|~
operator|(
name|SET_RTS
operator||
name|SET_DTR
operator|)
operator|)
operator||
name|flags
operator|)
expr_stmt|;
name|sOutDW
argument_list|(
name|rp
operator|->
name|rp_channel
operator|.
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
operator|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|sSetRxTrigger
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|TRIG_1
argument_list|)
expr_stmt|;
name|sDisRxStatusMode
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sFlushRxFIFO
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sFlushTxFIFO
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sEnInterrupts
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
operator|(
name|TXINT_EN
operator||
name|MCINT_EN
operator||
name|RXINT_EN
operator||
name|SRCINT_EN
operator||
name|CHANINT_EN
operator|)
argument_list|)
expr_stmt|;
name|sSetRxTrigger
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|,
name|TRIG_1
argument_list|)
expr_stmt|;
name|sDisRxStatusMode
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sClrTxXOFF
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
comment|/*		sDisRTSFlowCtl(&rp->rp_channel); 		sDisCTSFlowCtl(&rp->rp_channel); */
name|sDisTxSoftFlowCtl
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sStartRxProcessor
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sEnRxFIFO
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sEnTransmit
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
comment|/*		sSetDTR(&rp->rp_channel); 		sSetRTS(&rp->rp_channel); */
operator|++
name|rp
operator|->
name|wopeners
expr_stmt|;
name|error
operator|=
name|rpparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
operator|--
name|rp
operator|->
name|wopeners
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|rp_num_ports_open
operator|++
expr_stmt|;
name|IntMask
operator|=
name|sGetChanIntID
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|IntMask
operator|=
name|IntMask
operator|&
name|rp
operator|->
name|rp_intmask
expr_stmt|;
name|ChanStatus
operator|=
name|sGetChanStatus
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IntMask
operator|&
name|DELTA_CD
operator|)
operator|||
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ChanStatus
operator|&
name|CD_ACT
operator|)
operator|||
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
argument_list|)
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rp_num_ports_open
operator|==
literal|1
condition|)
name|timeout
argument_list|(
name|rp_do_poll
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|POLL_INTERVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|&&
operator|!
operator|(
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
operator|)
condition|)
block|{
operator|++
name|rp
operator|->
name|wopeners
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"rpdcd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|--
name|rp
operator|->
name|wopeners
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
goto|goto
name|open_top
goto|;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
name|rp_disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|&&
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|)
name|rp
operator|->
name|active_out
operator|=
name|TRUE
expr_stmt|;
comment|/*	if(rp_num_ports_open == 1) 		timeout(rp_do_poll, (void *)NULL, POLL_INTERVAL); */
name|out
label|:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
name|rp
operator|->
name|wopeners
operator|==
literal|0
condition|)
block|{
name|rphardclose
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rpclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|oldspl
decl_stmt|,
name|unit
decl_stmt|,
name|mynor
decl_stmt|,
name|umynor
decl_stmt|,
name|port
decl_stmt|;
comment|/* SG */
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
comment|/* SG */
if|if
condition|(
name|IS_CONTROL
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|rp_disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|rpstop
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|rphardclose
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rphardclose
parameter_list|(
name|struct
name|rp_port
modifier|*
name|rp
parameter_list|)
block|{
name|int
name|mynor
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
name|mynor
operator|=
name|MINOR_MAGIC
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
name|sFlushRxFIFO
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sFlushTxFIFO
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sDisTransmit
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sDisInterrupts
argument_list|(
name|cp
argument_list|,
name|TXINT_EN
operator||
name|MCINT_EN
operator||
name|RXINT_EN
operator||
name|SRCINT_EN
operator||
name|CHANINT_EN
argument_list|)
expr_stmt|;
name|sDisRTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sDisCTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sDisTxSoftFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sClrTxXOFF
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
operator|||
operator|!
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|||
operator|!
name|rp
operator|->
name|active_out
condition|)
block|{
name|sClrDTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_CALLOUT
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
condition|)
block|{
name|sClrDTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|dtr_wait
operator|!=
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|rpdtrwakeup
argument_list|,
name|rp
argument_list|,
name|rp
operator|->
name|dtr_wait
argument_list|)
expr_stmt|;
name|rp
operator|->
name|state
operator||=
operator|~
name|SET_DTR
expr_stmt|;
block|}
name|rp
operator|->
name|active_out
operator|=
name|FALSE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|rp
operator|->
name|active_out
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rpwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|mynor
decl_stmt|,
name|port
decl_stmt|,
name|umynor
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
comment|/* SG */
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
comment|/* SG */
if|if
condition|(
name|IS_CONTROL
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
while|while
condition|(
name|rp
operator|->
name|rp_disable_writes
condition|)
block|{
name|rp
operator|->
name|rp_waiting
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|ttysleep
argument_list|(
name|tp
argument_list|,
operator|(
name|caddr_t
operator|)
name|rp
argument_list|,
name|TTOPRI
operator||
name|PCATCH
argument_list|,
literal|"rp_write"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpdtrwakeup
parameter_list|(
name|void
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|rp
operator|=
operator|(
expr|struct
name|rp_port
operator|*
operator|)
name|chan
expr_stmt|;
name|rp
operator|->
name|state
operator|&=
name|SET_DTR
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|rp
operator|->
name|dtr_wait
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rpioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|mynor
decl_stmt|,
name|port
decl_stmt|,
name|umynor
decl_stmt|;
comment|/* SG */
name|int
name|oldspl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|arg
decl_stmt|,
name|flags
decl_stmt|,
name|result
decl_stmt|,
name|ChanStatus
decl_stmt|;
name|int
name|oldcmd
decl_stmt|;
name|struct
name|termios
name|term
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
if|if
condition|(
name|IS_CONTROL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|struct
name|termios
modifier|*
name|ct
decl_stmt|;
switch|switch
condition|(
name|IS_CONTROL
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|CONTROL_INIT_STATE
case|:
name|ct
operator|=
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|?
operator|&
name|rp
operator|->
name|it_out
else|:
operator|&
name|rp
operator|->
name|it_in
expr_stmt|;
break|break;
case|case
name|CONTROL_LOCK_STATE
case|:
name|ct
operator|=
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|?
operator|&
name|rp
operator|->
name|lt_out
else|:
operator|&
name|rp
operator|->
name|lt_in
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* /dev/nodev */
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSETA
case|:
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|ct
operator|=
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETA
case|:
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|=
operator|*
name|ct
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TTYDISC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGWINSZ
case|:
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|winsize
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
name|tp
operator|=
name|rp
operator|->
name|rp_tty
expr_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
name|term
operator|=
name|tp
operator|->
name|t_termios
expr_stmt|;
name|oldcmd
operator|=
name|cmd
expr_stmt|;
name|error
operator|=
name|ttsetcompat
argument_list|(
name|tp
argument_list|,
operator|&
name|cmd
argument_list|,
name|data
argument_list|,
operator|&
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|cmd
operator|!=
name|oldcmd
condition|)
block|{
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|term
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|cmd
operator|==
name|TIOCSETA
operator|)
operator|||
operator|(
name|cmd
operator|==
name|TIOCSETAW
operator|)
operator|||
operator|(
name|cmd
operator|==
name|TIOCSETAF
operator|)
condition|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|termios
modifier|*
name|dt
init|=
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|termios
modifier|*
name|lt
init|=
name|IS_CALLOUT
argument_list|(
name|dev
argument_list|)
condition|?
operator|&
name|rp
operator|->
name|lt_out
else|:
operator|&
name|rp
operator|->
name|lt_in
decl_stmt|;
name|dt
operator|->
name|c_iflag
operator|=
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|lt
operator|->
name|c_iflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_iflag
operator|&
operator|~
name|lt
operator|->
name|c_iflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_oflag
operator|=
operator|(
name|tp
operator|->
name|t_oflag
operator|&
name|lt
operator|->
name|c_oflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_oflag
operator|&
operator|~
name|lt
operator|->
name|c_oflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_cflag
operator|=
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|lt
operator|->
name|c_cflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_cflag
operator|&
operator|~
name|lt
operator|->
name|c_cflag
operator|)
expr_stmt|;
name|dt
operator|->
name|c_lflag
operator|=
operator|(
name|tp
operator|->
name|t_lflag
operator|&
name|lt
operator|->
name|c_lflag
operator|)
operator||
operator|(
name|dt
operator|->
name|c_lflag
operator|&
operator|~
name|lt
operator|->
name|c_lflag
operator|)
expr_stmt|;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
name|NCCS
condition|;
operator|++
name|cc
control|)
if|if
condition|(
name|lt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_cc
index|[
name|cc
index|]
operator|=
name|tp
operator|->
name|t_cc
index|[
name|cc
index|]
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ispeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ispeed
operator|=
name|tp
operator|->
name|t_ispeed
expr_stmt|;
if|if
condition|(
name|lt
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
name|dt
operator|->
name|c_ospeed
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
block|}
name|t
operator|=
operator|&
name|tp
operator|->
name|t_termios
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|flags
operator|=
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
expr_stmt|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|flags
operator|=
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
expr_stmt|;
name|rp_disc_optim
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
block|{
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
name|sSendBreak
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
name|sClrBreak
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCSDTR
case|:
name|sSetDTR
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|sSetRTS
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
name|sClrDTR
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
name|arg
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|&
name|TIOCM_RTS
condition|)
name|flags
operator||=
name|SET_RTS
expr_stmt|;
if|if
condition|(
name|arg
operator|&
name|TIOCM_DTR
condition|)
name|flags
operator||=
name|SET_DTR
expr_stmt|;
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator|&
operator|~
operator|(
name|SET_RTS
operator||
name|SET_DTR
operator|)
operator|)
operator||
name|flags
operator|)
expr_stmt|;
name|sOutDW
argument_list|(
name|rp
operator|->
name|rp_channel
operator|.
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
operator|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
name|arg
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|&
name|TIOCM_RTS
condition|)
name|flags
operator||=
name|SET_RTS
expr_stmt|;
if|if
condition|(
name|arg
operator|&
name|TIOCM_DTR
condition|)
name|flags
operator||=
name|SET_DTR
expr_stmt|;
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator||=
name|flags
expr_stmt|;
name|sOutDW
argument_list|(
name|rp
operator|->
name|rp_channel
operator|.
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
operator|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
name|arg
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|&
name|TIOCM_RTS
condition|)
name|flags
operator||=
name|SET_RTS
expr_stmt|;
if|if
condition|(
name|arg
operator|&
name|TIOCM_DTR
condition|)
name|flags
operator||=
name|SET_DTR
expr_stmt|;
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
operator|&=
operator|~
name|flags
expr_stmt|;
name|sOutDW
argument_list|(
name|rp
operator|->
name|rp_channel
operator|.
name|IndexAddr
argument_list|,
operator|*
operator|(
name|DWord_t
operator|*
operator|)
operator|&
operator|(
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
name|ChanStatus
operator|=
name|sGetChanStatusLo
argument_list|(
operator|&
name|rp
operator|->
name|rp_channel
argument_list|)
expr_stmt|;
name|flags
operator|=
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
expr_stmt|;
name|result
operator|=
name|TIOCM_LE
expr_stmt|;
comment|/* always on while open for some reason */
name|result
operator||=
operator|(
operator|(
operator|(
name|flags
operator|&
name|SET_DTR
operator|)
condition|?
name|TIOCM_DTR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|flags
operator|&
name|SET_RTS
operator|)
condition|?
name|TIOCM_RTS
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|ChanStatus
operator|&
name|CD_ACT
operator|)
condition|?
name|TIOCM_CAR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|ChanStatus
operator|&
name|DSR_ACT
operator|)
condition|?
name|TIOCM_DSR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|ChanStatus
operator|&
name|CTS_ACT
operator|)
condition|?
name|TIOCM_CTS
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rp_channel
operator|.
name|RxControl
index|[
literal|2
index|]
operator|&
name|RTSFC_EN
condition|)
block|{
name|result
operator||=
name|TIOCM_RTS
expr_stmt|;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|result
expr_stmt|;
break|break;
case|case
name|TIOCMSDTRWAIT
case|:
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|rp
operator|->
name|dtr_wait
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|*
name|hz
operator|/
literal|100
expr_stmt|;
break|break;
case|case
name|TIOCMGDTRWAIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|rp
operator|->
name|dtr_wait
operator|*
literal|100
operator|/
name|hz
expr_stmt|;
break|break;
default|default:
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
name|ENOTTY
return|;
block|}
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|speedtab
name|baud_table
index|[]
init|=
block|{
block|{
name|B0
block|,
literal|0
block|}
block|,
block|{
name|B50
block|,
name|BRD50
block|}
block|,
block|{
name|B75
block|,
name|BRD75
block|}
block|,
block|{
name|B110
block|,
name|BRD110
block|}
block|,
block|{
name|B134
block|,
name|BRD134
block|}
block|,
block|{
name|B150
block|,
name|BRD150
block|}
block|,
block|{
name|B200
block|,
name|BRD200
block|}
block|,
block|{
name|B300
block|,
name|BRD300
block|}
block|,
block|{
name|B600
block|,
name|BRD600
block|}
block|,
block|{
name|B1200
block|,
name|BRD1200
block|}
block|,
block|{
name|B1800
block|,
name|BRD1800
block|}
block|,
block|{
name|B2400
block|,
name|BRD2400
block|}
block|,
block|{
name|B4800
block|,
name|BRD4800
block|}
block|,
block|{
name|B9600
block|,
name|BRD9600
block|}
block|,
block|{
name|B19200
block|,
name|BRD19200
block|}
block|,
block|{
name|B38400
block|,
name|BRD38400
block|}
block|,
block|{
name|B7200
block|,
name|BRD7200
block|}
block|,
block|{
name|B14400
block|,
name|BRD14400
block|}
block|,
block|{
name|B57600
block|,
name|BRD57600
block|}
block|,
block|{
name|B76800
block|,
name|BRD76800
block|}
block|,
block|{
name|B115200
block|,
name|BRD115200
block|}
block|,
block|{
name|B230400
block|,
name|BRD230400
block|}
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|rpparam
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|mynor
decl_stmt|,
name|port
decl_stmt|,
name|umynor
decl_stmt|;
comment|/* SG */
name|int
name|oldspl
decl_stmt|,
name|cflag
decl_stmt|,
name|iflag
decl_stmt|,
name|oflag
decl_stmt|,
name|lflag
decl_stmt|;
name|int
name|ospeed
decl_stmt|;
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|oldspl
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|cflag
operator|=
name|t
operator|->
name|c_cflag
expr_stmt|;
name|iflag
operator|=
name|t
operator|->
name|c_iflag
expr_stmt|;
name|oflag
operator|=
name|t
operator|->
name|c_oflag
expr_stmt|;
name|lflag
operator|=
name|t
operator|->
name|c_lflag
expr_stmt|;
name|ospeed
operator|=
name|ttspeedtab
argument_list|(
name|t
operator|->
name|c_ispeed
argument_list|,
name|baud_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|ospeed
operator|<
literal|0
operator|||
name|t
operator|->
name|c_ispeed
operator|!=
name|t
operator|->
name|c_ospeed
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|cflag
expr_stmt|;
name|tp
operator|->
name|t_iflag
operator|=
name|iflag
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|oflag
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|lflag
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|==
literal|0
condition|)
block|{
name|sClrDTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rp
operator|->
name|rp_fifo_lw
operator|=
operator|(
operator|(
name|t
operator|->
name|c_ospeed
operator|*
literal|2
operator|)
operator|/
literal|1000
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Set baud rate ----- we only pay attention to ispeed */
name|sSetDTR
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sSetRTS
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sSetBaud
argument_list|(
name|cp
argument_list|,
name|ospeed
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|CSTOPB
condition|)
block|{
name|sSetStop2
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sSetStop1
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
block|{
name|sEnParity
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|PARODD
condition|)
block|{
name|sSetOddParity
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sSetEvenParity
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sDisParity
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cflag
operator|&
name|CSIZE
operator|)
operator|==
name|CS8
condition|)
block|{
name|sSetData8
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_imask
operator|=
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|sSetData7
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_imask
operator|=
literal|0x7F
expr_stmt|;
block|}
if|if
condition|(
name|iflag
operator|&
name|ISTRIP
condition|)
block|{
name|rp
operator|->
name|rp_imask
operator|&=
literal|0x7F
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|CLOCAL
condition|)
block|{
name|rp
operator|->
name|rp_intmask
operator|&=
operator|~
name|DELTA_CD
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|->
name|rp_intmask
operator||=
name|DELTA_CD
expr_stmt|;
block|}
comment|/* Put flow control stuff here */
if|if
condition|(
name|cflag
operator|&
name|CCTS_OFLOW
condition|)
block|{
name|sEnCTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sDisCTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|CRTS_IFLOW
condition|)
block|{
name|rp
operator|->
name|rp_rts_iflow
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rp
operator|->
name|rp_rts_iflow
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|&
name|CRTS_IFLOW
condition|)
block|{
name|sEnRTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sDisRTSFlowCtl
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|rp_disc_optim
argument_list|(
name|tp
argument_list|,
name|t
argument_list|,
name|rp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|CLOCAL
operator|)
operator|||
operator|(
name|sGetChanStatusLo
argument_list|(
name|cp
argument_list|)
operator|&
name|CD_ACT
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*	tp->t_state |= TS_CAN_BYPASS_L_RINT; 	flags = rp->rp_channel.TxControl[3]; 	if(flags& SET_DTR) 	else 	if(flags& SET_RTS) 	else */
name|splx
argument_list|(
name|oldspl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rp_disc_optim
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|,
name|rp
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|ICRNL
operator||
name|IGNCR
operator||
name|IMAXBEL
operator||
name|INLCR
operator||
name|ISTRIP
operator||
name|IXON
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|BRKINT
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|IGNBRK
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|t
operator|->
name|c_iflag
operator|&
name|PARMRK
operator|)
operator|||
operator|(
name|t
operator|->
name|c_iflag
operator|&
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|==
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|&&
operator|!
operator|(
name|t
operator|->
name|c_lflag
operator|&
operator|(
name|ECHO
operator||
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
operator||
name|PENDIN
operator|)
operator|)
operator|&&
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|==
name|ttyinput
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpstart
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|struct
name|clist
modifier|*
name|qp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|mynor
decl_stmt|,
name|port
decl_stmt|,
name|umynor
decl_stmt|;
comment|/* SG */
name|char
name|ch
decl_stmt|,
name|flags
decl_stmt|;
name|int
name|spl
decl_stmt|,
name|xmit_fifo_room
decl_stmt|;
name|int
name|count
decl_stmt|;
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|flags
operator|=
name|rp
operator|->
name|rp_channel
operator|.
name|TxControl
index|[
literal|3
index|]
expr_stmt|;
name|spl
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
condition|)
block|{
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rp
operator|->
name|rp_xmit_stopped
condition|)
block|{
name|sEnTransmit
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_xmit_stopped
operator|=
literal|0
expr_stmt|;
block|}
name|count
operator|=
name|sGetTxCnt
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
operator|)
operator|&&
operator|(
name|count
operator|==
literal|0
operator|)
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
block|}
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
return|return;
block|}
name|xmit_fifo_room
operator|=
name|TXFIFO_SIZE
operator|-
name|sGetTxCnt
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|qp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xmit_fifo_room
operator|>
literal|0
operator|&&
name|qp
operator|->
name|c_cc
operator|>
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
block|}
while|while
condition|(
name|xmit_fifo_room
operator|>
literal|0
operator|&&
name|qp
operator|->
name|c_cc
operator|>
literal|0
condition|)
block|{
name|ch
operator|=
name|getc
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|sOutB
argument_list|(
name|sGetTxRxDataIO
argument_list|(
name|cp
argument_list|)
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|xmit_fifo_room
operator|--
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|rp
operator|->
name|rp_restart
operator|=
operator|(
name|qp
operator|->
name|c_cc
operator|>
literal|0
operator|)
condition|?
name|rp
operator|->
name|rp_fifo_lw
else|:
literal|0
expr_stmt|;
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpstop
parameter_list|(
name|tp
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|rp_port
modifier|*
name|rp
decl_stmt|;
name|CHANNEL_t
modifier|*
name|cp
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|mynor
decl_stmt|,
name|port
decl_stmt|,
name|umynor
decl_stmt|;
comment|/* SG */
name|int
name|spl
decl_stmt|;
name|umynor
operator|=
operator|(
operator|(
operator|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|>>
literal|16
operator|)
operator|-
literal|1
operator|)
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* SG */
name|port
operator|=
operator|(
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
comment|/* SG */
name|mynor
operator|=
operator|(
name|port
operator|+
name|umynor
operator|)
expr_stmt|;
comment|/* SG */
name|unit
operator|=
name|minor_to_unit
index|[
name|mynor
index|]
expr_stmt|;
name|rp
operator|=
name|rp_addr
argument_list|(
name|unit
argument_list|)
operator|+
name|port
expr_stmt|;
name|cp
operator|=
operator|&
name|rp
operator|->
name|rp_channel
expr_stmt|;
name|spl
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_BUSY
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
block|{
name|sFlushTxFIFO
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rp
operator|->
name|rp_xmit_stopped
operator|==
literal|0
condition|)
block|{
name|sDisTransmit
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_xmit_stopped
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|spl
argument_list|)
expr_stmt|;
name|rpstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

