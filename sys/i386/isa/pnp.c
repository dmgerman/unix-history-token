begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, Sujal M. Patel  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      $Id: pnp.c,v 1.3 1997/09/19 15:20:24 jmg Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* for DATA_SET	*/
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/pnp.h>
end_include

begin_decl_stmt
name|int
name|num_pnp_cards
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pnp_id
name|pnp_devices
index|[
name|MAX_PNP_CARDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pnp_dlist_node
modifier|*
name|pnp_device_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pnp_dlist_node
modifier|*
modifier|*
name|pnp_device_list_last_ptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * these entries are initialized using the autoconfig menu  * The struct is invalid (and must be initialized) if the first  * CSN is zero. The init code fills invalid entries with CSN 255  * which is not a supported value.  */
end_comment

begin_decl_stmt
name|struct
name|pnp_cinfo
name|pnp_ldn_overrides
index|[
name|MAX_PNP_LDN
index|]
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * the following is a flag which tells if the data is valid.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|doing_pnp_probe
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_csn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_pnp_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_pnp_serial
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * the following block is an example on what is needed for  * a PnP device driver.  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|nullpnp_probe
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vendor_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nullpnp_attach
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vendor_id
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_long
name|nullpnp_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pnp_device
name|nullpnp_device
init|=
block|{
literal|"goodpnp"
block|,
name|nullpnp_probe
block|,
name|nullpnp_attach
block|,
operator|&
name|nullpnp_count
block|,
name|NULL
comment|/* imask */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pnpdevice_set
argument_list|,
name|nullpnp_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|char
modifier|*
name|nullpnp_probe
parameter_list|(
name|u_long
name|tag
parameter_list|,
name|u_long
name|type
parameter_list|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Called nullpnp_probe with tag 0x%08lx, type 0x%08lx\n"
argument_list|,
name|tag
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nullpnp_attach
parameter_list|(
name|u_long
name|csn
parameter_list|,
name|u_long
name|vend_id
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|printf
argument_list|(
literal|"nullpnp_attach: csn %ld, vend_id 0x%08lx name %s unit %d\n"
argument_list|,
name|csn
argument_list|,
name|vend_id
argument_list|,
name|name
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* The READ_DATA port that we are using currently */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pnp_rd_port
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|pnp_send_Initiation_LFSR
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pnp_get_serial
parameter_list|(
name|pnp_id
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|config_pnp_device
parameter_list|(
name|pnp_id
modifier|*
name|p
parameter_list|,
name|int
name|csn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pnp_isolation_protocol
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pnp_write
parameter_list|(
name|int
name|d
parameter_list|,
name|u_char
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_char
name|pnp_read
parameter_list|(
name|int
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|pnp_write
parameter_list|(
name|int
name|d
parameter_list|,
name|u_char
name|r
parameter_list|)
block|{
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PNP_WRITE_DATA
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_char
name|pnp_read
parameter_list|(
name|int
name|d
parameter_list|)
block|{
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|inb
argument_list|(
literal|3
operator||
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send Initiation LFSR as described in "Plug and Play ISA Specification",  * Intel May 94.  */
end_comment

begin_function
name|void
name|pnp_send_Initiation_LFSR
parameter_list|()
block|{
name|int
name|cur
decl_stmt|,
name|i
decl_stmt|;
comment|/* Reset the LSFR */
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* yes, we do need it twice! */
name|cur
operator|=
literal|0x6a
expr_stmt|;
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|cur
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|cur
operator|=
operator|(
name|cur
operator|>>
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|cur
operator|^
operator|(
name|cur
operator|>>
literal|1
operator|)
operator|)
operator|<<
literal|7
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get the device's serial number.  Returns 1 if the serial is valid.  */
end_comment

begin_function
name|int
name|pnp_get_serial
parameter_list|(
name|pnp_id
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|bit
decl_stmt|,
name|valid
init|=
literal|0
decl_stmt|,
name|sum
init|=
literal|0x6a
decl_stmt|;
name|u_char
modifier|*
name|data
init|=
operator|(
name|u_char
operator|*
operator|)
name|p
decl_stmt|;
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|9
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|SERIAL_ISOLATION
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|72
condition|;
name|i
operator|++
control|)
block|{
name|bit
operator|=
name|inb
argument_list|(
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
operator|==
literal|0x55
expr_stmt|;
name|DELAY
argument_list|(
literal|250
argument_list|)
expr_stmt|;
comment|/* Delay 250 usec */
comment|/* Can't Short Circuit the next evaluation, so 'and' is last */
name|bit
operator|=
operator|(
name|inb
argument_list|(
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
operator|==
literal|0xaa
operator|)
operator|&&
name|bit
expr_stmt|;
name|DELAY
argument_list|(
literal|250
argument_list|)
expr_stmt|;
comment|/* Delay 250 usec */
name|valid
operator|=
name|valid
operator|||
name|bit
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|64
condition|)
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|sum
operator|^
operator|(
name|sum
operator|>>
literal|1
operator|)
operator|^
name|bit
operator|)
operator|<<
literal|7
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|data
index|[
name|i
operator|/
literal|8
index|]
operator|=
operator|(
name|data
index|[
name|i
operator|/
literal|8
index|]
operator|>>
literal|1
operator|)
operator||
operator|(
name|bit
condition|?
literal|0x80
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|valid
operator|=
name|valid
operator|&&
operator|(
name|data
index|[
literal|8
index|]
operator|==
name|sum
operator|)
expr_stmt|;
return|return
name|valid
return|;
block|}
end_function

begin_comment
comment|/*  * read_pnp_parms loads pnp parameters from the currently selected  * device into the struct pnp_cinfo parameter passed.  * The second argument specifies the Logical Device to use.  */
end_comment

begin_function
name|int
name|read_pnp_parms
parameter_list|(
name|struct
name|pnp_cinfo
modifier|*
name|d
parameter_list|,
name|int
name|ldn
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|doing_pnp_probe
operator|==
literal|0
operator|||
name|d
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* fail */
name|bzero
argument_list|(
name|d
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pnp_cinfo
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|vendor_id
operator|=
name|current_pnp_id
expr_stmt|;
name|d
operator|->
name|serial
operator|=
name|current_pnp_serial
expr_stmt|;
name|d
operator|->
name|csn
operator|=
name|current_csn
expr_stmt|;
name|d
operator|->
name|ldn
operator|=
name|ldn
expr_stmt|;
comment|/* XXX this should be different ... */
name|pnp_write
argument_list|(
name|SET_LDN
argument_list|,
name|ldn
argument_list|)
expr_stmt|;
name|i
operator|=
name|pnp_read
argument_list|(
name|SET_LDN
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ldn
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: LDN %d does not exist\n"
argument_list|,
name|ldn
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|->
name|port
index|[
name|i
index|]
operator|=
name|pnp_read
argument_list|(
name|IO_CONFIG_BASE
operator|+
name|i
operator|*
literal|2
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|d
operator|->
name|port
index|[
name|i
index|]
operator||=
name|pnp_read
argument_list|(
name|IO_CONFIG_BASE
operator|+
name|i
operator|*
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|4
condition|)
block|{
name|d
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|base
operator|=
name|pnp_read
argument_list|(
name|MEM_CONFIG
operator|+
name|i
operator|*
literal|8
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|d
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|base
operator||=
name|pnp_read
argument_list|(
name|MEM_CONFIG
operator|+
name|i
operator|*
literal|8
operator|+
literal|1
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|d
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|control
operator|=
name|pnp_read
argument_list|(
name|MEM_CONFIG
operator|+
name|i
operator|*
literal|8
operator|+
literal|2
argument_list|)
expr_stmt|;
name|d
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|range
operator|=
name|pnp_read
argument_list|(
name|MEM_CONFIG
operator|+
name|i
operator|*
literal|8
operator|+
literal|3
argument_list|)
operator|<<
literal|16
expr_stmt|;
name|d
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|range
operator||=
name|pnp_read
argument_list|(
name|MEM_CONFIG
operator|+
name|i
operator|*
literal|8
operator|+
literal|4
argument_list|)
operator|<<
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
literal|2
condition|)
block|{
name|d
operator|->
name|irq
index|[
name|i
index|]
operator|=
name|pnp_read
argument_list|(
name|IRQ_CONFIG
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|d
operator|->
name|irq_type
index|[
name|i
index|]
operator|=
name|pnp_read
argument_list|(
name|IRQ_CONFIG
operator|+
literal|1
operator|+
name|i
operator|*
literal|2
argument_list|)
expr_stmt|;
name|d
operator|->
name|drq
index|[
name|i
index|]
operator|=
name|pnp_read
argument_list|(
name|DRQ_CONFIG
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|enable
operator|=
name|pnp_read
argument_list|(
name|ACTIVATE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PNP_LDN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|csn
operator|==
name|d
operator|->
name|csn
operator|&&
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|ldn
operator|==
name|ldn
condition|)
block|{
name|d
operator|->
name|flags
operator|=
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
name|d
operator|->
name|override
operator|=
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|override
expr_stmt|;
break|break ;
block|}
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"port 0x%04x 0x%04x 0x%04x 0x%04x irq %d:%d drq %d:%d en %d\n"
argument_list|,
name|d
operator|->
name|port
index|[
literal|0
index|]
argument_list|,
name|d
operator|->
name|port
index|[
literal|1
index|]
argument_list|,
name|d
operator|->
name|port
index|[
literal|2
index|]
argument_list|,
name|d
operator|->
name|port
index|[
literal|3
index|]
argument_list|,
name|d
operator|->
name|irq
index|[
literal|0
index|]
argument_list|,
name|d
operator|->
name|irq
index|[
literal|1
index|]
argument_list|,
name|d
operator|->
name|drq
index|[
literal|0
index|]
argument_list|,
name|d
operator|->
name|drq
index|[
literal|1
index|]
argument_list|,
name|d
operator|->
name|enable
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*  * write_pnp_parms initializes a logical device with the parms  * in d, and then activates the board if the last parameter is 1.  */
end_comment

begin_function
name|int
name|write_pnp_parms
parameter_list|(
name|struct
name|pnp_cinfo
modifier|*
name|d
parameter_list|,
name|int
name|ldn
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|empty
init|=
operator|-
literal|1
decl_stmt|;
comment|/*      * some safety checks first.      */
if|if
condition|(
name|doing_pnp_probe
operator|==
literal|0
operator|||
name|d
operator|==
name|NULL
operator|||
name|d
operator|->
name|vendor_id
operator|!=
name|current_pnp_id
condition|)
return|return
literal|0
return|;
comment|/* fail */
name|pnp_write
argument_list|(
name|SET_LDN
argument_list|,
name|ldn
argument_list|)
expr_stmt|;
name|i
operator|=
name|pnp_read
argument_list|(
name|SET_LDN
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ldn
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: LDN %d does not exist\n"
argument_list|,
name|ldn
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|pnp_write
argument_list|(
name|IO_CONFIG_BASE
operator|+
name|i
operator|*
literal|2
argument_list|,
name|d
operator|->
name|port
index|[
name|i
index|]
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|IO_CONFIG_BASE
operator|+
name|i
operator|*
literal|2
operator|+
literal|1
argument_list|,
name|d
operator|->
name|port
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|pnp_write
argument_list|(
name|MEM_CONFIG
operator|+
name|i
operator|*
literal|8
argument_list|,
operator|(
name|d
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|base
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|MEM_CONFIG
operator|+
name|i
operator|*
literal|8
operator|+
literal|1
argument_list|,
operator|(
name|d
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|base
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|MEM_CONFIG
operator|+
name|i
operator|*
literal|8
operator|+
literal|2
argument_list|,
name|d
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|control
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|MEM_CONFIG
operator|+
name|i
operator|*
literal|8
operator|+
literal|3
argument_list|,
operator|(
name|d
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|range
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|MEM_CONFIG
operator|+
name|i
operator|*
literal|8
operator|+
literal|4
argument_list|,
operator|(
name|d
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|range
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|pnp_write
argument_list|(
name|IRQ_CONFIG
operator|+
name|i
operator|*
literal|2
argument_list|,
name|d
operator|->
name|irq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|IRQ_CONFIG
operator|+
name|i
operator|*
literal|2
operator|+
literal|1
argument_list|,
name|d
operator|->
name|irq_type
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|DRQ_CONFIG
operator|+
name|i
argument_list|,
name|d
operator|->
name|drq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/*      * store parameters read into the current kernel      * so manual editing next time is easier      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PNP_LDN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|csn
operator|==
name|d
operator|->
name|csn
operator|&&
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|ldn
operator|==
name|ldn
condition|)
block|{
name|d
operator|->
name|flags
operator|=
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|=
operator|*
name|d
expr_stmt|;
break|break ;
block|}
elseif|else
if|if
condition|(
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|csn
operator|<
literal|1
operator|||
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|csn
operator|==
literal|255
condition|)
name|empty
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|MAX_PNP_LDN
operator|&&
name|empty
operator|!=
operator|-
literal|1
condition|)
name|pnp_ldn_overrides
index|[
name|empty
index|]
operator|=
operator|*
name|d
expr_stmt|;
comment|/*      * Here should really perform the range check, and      * return a failure if not successful.      */
name|pnp_write
argument_list|(
name|IO_RANGE_CHECK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* XXX is it really necessary ? */
name|pnp_write
argument_list|(
name|ACTIVATE
argument_list|,
name|d
operator|->
name|enable
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* XXX is it really necessary ? */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * To finalize a card's initialization, and before accessing its  * registers, we need to bring the card in WaitForKey. To this purpose,  * we need to issue a WaitForKey command, which brings _all_ cards  * in that state. So, before configuring the next board, we must also  * sent the Init-Key to bring cards to the SLEEP state again.  *  * In fact, one could hope that cards respond to normal I/O accesses  * even in the SLEEP state, which could be done by issuing a WAKE[0].  * This seems to work on the CS4236, but not on the CS4232 on my Zappa  * motherboard .  */
end_comment

begin_function
name|int
name|enable_pnp_card
parameter_list|()
block|{
comment|/* the next wake should bring the card in WaitForKey ? */
name|pnp_write
argument_list|(
name|WAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|CONFIG_CONTROL
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* All cards in WaitForKey */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* XXX is it really necessary ? */
return|return
literal|1
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*  * Configure PnP devices. pnp_id is made of:  *	4 bytes: board id (which can be printed as an ascii string);  *	4 bytes: board serial number (often 0 or -1 ?)  */
end_comment

begin_function
name|void
name|config_pnp_device
parameter_list|(
name|pnp_id
modifier|*
name|p
parameter_list|,
name|int
name|csn
parameter_list|)
block|{
specifier|static
name|struct
name|pnp_dlist_node
modifier|*
name|nod
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_char
modifier|*
name|data
init|=
operator|(
name|u_char
operator|*
operator|)
name|p
decl_stmt|;
comment|/* these are for autoconfigure a-la pci */
name|struct
name|pnp_device
modifier|*
name|dvp
decl_stmt|,
modifier|*
modifier|*
name|dvpp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|printf
argument_list|(
literal|"CSN %d Vendor ID: %c%c%c%02x%02x [0x%08lx] Serial 0x%08lx\n"
argument_list|,
name|csn
argument_list|,
operator|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x7c
operator|)
operator|>>
literal|2
operator|)
operator|+
literal|'@'
argument_list|,
operator|(
operator|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
operator|)
operator|)
operator|+
literal|'@'
argument_list|,
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0x1f
operator|)
operator|+
literal|'@'
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|,
name|p
operator|->
name|vendor_id
argument_list|,
name|p
operator|->
name|serial
argument_list|)
expr_stmt|;
name|doing_pnp_probe
operator|=
literal|1
expr_stmt|;
name|current_csn
operator|=
name|csn
expr_stmt|;
name|current_pnp_id
operator|=
name|p
operator|->
name|vendor_id
expr_stmt|;
name|current_pnp_serial
operator|=
name|p
operator|->
name|serial
expr_stmt|;
comment|/*      * use kernel table to override possible devices      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PNP_LDN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|csn
operator|==
name|csn
operator|&&
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|override
operator|==
literal|1
condition|)
block|{
name|struct
name|pnp_cinfo
name|d
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"PnP: override config for CSN %d LDN %d "
literal|"vend_id 0x%08x\n"
argument_list|,
name|csn
argument_list|,
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|ldn
argument_list|,
name|current_pnp_id
argument_list|)
expr_stmt|;
comment|/* next assignement is done otherwise read fails */
name|d
operator|.
name|vendor_id
operator|=
name|current_pnp_id
expr_stmt|;
name|read_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|ldn
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|enable
operator|==
literal|0
condition|)
block|{
comment|/* just disable ... */
name|d
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
name|write_pnp_parms
argument_list|(
operator|&
name|d
argument_list|,
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|ldn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set all parameters */
comment|/* next assignement is done otherwise write fails */
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|vendor_id
operator|=
name|current_pnp_id
expr_stmt|;
name|write_pnp_parms
argument_list|(
operator|&
name|pnp_ldn_overrides
index|[
name|i
index|]
argument_list|,
name|pnp_ldn_overrides
index|[
name|i
index|]
operator|.
name|ldn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* lookup device in ioconfiguration */
name|dvpp
operator|=
operator|(
expr|struct
name|pnp_device
operator|*
operator|*
operator|)
name|pnpdevice_set
operator|.
name|ls_items
expr_stmt|;
while|while
condition|(
operator|(
name|dvp
operator|=
operator|*
name|dvpp
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|dvp
operator|->
name|pd_probe
condition|)
block|{
if|if
condition|(
operator|(
name|name
operator|=
call|(
modifier|*
name|dvp
operator|->
name|pd_probe
call|)
argument_list|(
name|csn
argument_list|,
name|p
operator|->
name|vendor_id
argument_list|)
operator|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|dvp
operator|&&
name|name
operator|&&
name|dvp
operator|->
name|pd_count
condition|)
block|{
comment|/* found a matching device */
name|int
name|unit
decl_stmt|;
comment|/* pnpcb->pnpcb_seen |= ( 1ul<< csn ) ; */
comment|/* get and increment the unit */
name|unit
operator|=
operator|(
operator|*
name|dvp
operator|->
name|pd_count
operator|)
operator|++
expr_stmt|;
comment|/* 	 * now call the attach routine. The board has not been 	 * configured yet, so better not access isa registers in 	 * the attach routine until enable_pnp_card() has been done. 	 */
if|if
condition|(
name|nod
operator|==
name|NULL
condition|)
name|nod
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pnp_dlist_node
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nod
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"malloc failed for PnP resource use"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|nod
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nod
argument_list|)
argument_list|)
expr_stmt|;
name|nod
operator|->
name|pnp
operator|=
name|dvp
expr_stmt|;
name|nod
operator|->
name|dev
operator|.
name|id_unit
operator|=
name|unit
expr_stmt|;
if|if
condition|(
name|dvp
operator|->
name|pd_attach
condition|)
call|(
modifier|*
name|dvp
operator|->
name|pd_attach
call|)
argument_list|(
name|csn
argument_list|,
name|p
operator|->
name|vendor_id
argument_list|,
name|name
argument_list|,
operator|&
operator|(
name|nod
operator|->
name|dev
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d (%s<%s> sn 0x%08lx)"
argument_list|,
name|nod
operator|->
name|dev
operator|.
name|id_driver
operator|&&
name|nod
operator|->
name|dev
operator|.
name|id_driver
operator|->
name|name
condition|?
name|nod
operator|->
name|dev
operator|.
name|id_driver
operator|->
name|name
else|:
literal|"unknown"
argument_list|,
name|unit
argument_list|,
name|dvp
operator|->
name|pd_name
argument_list|,
name|name
argument_list|,
name|p
operator|->
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|nod
operator|->
name|dev
operator|.
name|id_alive
condition|)
block|{
if|if
condition|(
name|nod
operator|->
name|dev
operator|.
name|id_irq
condition|)
block|{
comment|/* the board uses interrupts. Register it. */
if|if
condition|(
name|dvp
operator|->
name|imask
condition|)
name|INTRMASK
argument_list|(
operator|*
operator|(
name|dvp
operator|->
name|imask
operator|)
argument_list|,
name|nod
operator|->
name|dev
operator|.
name|id_irq
argument_list|)
expr_stmt|;
name|register_intr
argument_list|(
name|ffs
argument_list|(
name|nod
operator|->
name|dev
operator|.
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|,
name|nod
operator|->
name|dev
operator|.
name|id_id
argument_list|,
name|nod
operator|->
name|dev
operator|.
name|id_ri_flags
argument_list|,
name|nod
operator|->
name|dev
operator|.
name|id_intr
argument_list|,
name|dvp
operator|->
name|imask
argument_list|,
name|nod
operator|->
name|dev
operator|.
name|id_unit
argument_list|)
expr_stmt|;
name|INTREN
argument_list|(
name|nod
operator|->
name|dev
operator|.
name|id_irq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nod
operator|->
name|dev
operator|.
name|id_alive
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nod
operator|->
name|dev
operator|.
name|id_iobase
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|" at ?"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|" at 0x%x"
argument_list|,
name|nod
operator|->
name|dev
operator|.
name|id_iobase
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nod
operator|->
name|dev
operator|.
name|id_iobase
operator|+
name|nod
operator|->
name|dev
operator|.
name|id_alive
operator|-
literal|1
operator|)
operator|!=
name|nod
operator|->
name|dev
operator|.
name|id_iobase
condition|)
block|{
name|printf
argument_list|(
literal|"-0x%x"
argument_list|,
name|nod
operator|->
name|dev
operator|.
name|id_iobase
operator|+
name|nod
operator|->
name|dev
operator|.
name|id_alive
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nod
operator|->
name|dev
operator|.
name|id_irq
condition|)
name|printf
argument_list|(
literal|" irq %d"
argument_list|,
name|ffs
argument_list|(
name|nod
operator|->
name|dev
operator|.
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nod
operator|->
name|dev
operator|.
name|id_drq
operator|!=
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|" drq %d"
argument_list|,
name|nod
operator|->
name|dev
operator|.
name|id_drq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nod
operator|->
name|dev
operator|.
name|id_maddr
condition|)
name|printf
argument_list|(
literal|" maddr 0x%lx"
argument_list|,
name|kvtop
argument_list|(
name|nod
operator|->
name|dev
operator|.
name|id_maddr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nod
operator|->
name|dev
operator|.
name|id_msize
condition|)
name|printf
argument_list|(
literal|" msize %d"
argument_list|,
name|nod
operator|->
name|dev
operator|.
name|id_msize
argument_list|)
expr_stmt|;
if|if
condition|(
name|nod
operator|->
name|dev
operator|.
name|id_flags
condition|)
name|printf
argument_list|(
literal|" flags 0x%x"
argument_list|,
name|nod
operator|->
name|dev
operator|.
name|id_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|nod
operator|->
name|dev
operator|.
name|id_iobase
operator|&&
operator|!
operator|(
name|nod
operator|->
name|dev
operator|.
name|id_iobase
operator|&
literal|0xf300
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" on motherboard"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" id %d"
argument_list|,
name|nod
operator|->
name|dev
operator|.
name|id_id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nod
operator|->
name|dev
operator|.
name|id_iobase
operator|>=
literal|0x1000
operator|&&
operator|!
operator|(
name|nod
operator|->
name|dev
operator|.
name|id_iobase
operator|&
literal|0x300
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" on eisa slot %d"
argument_list|,
name|nod
operator|->
name|dev
operator|.
name|id_iobase
operator|>>
literal|12
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" on isa"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnp_device_list_last_ptr
operator|==
name|NULL
condition|)
name|pnp_device_list
operator|=
name|nod
expr_stmt|;
else|else
operator|*
name|pnp_device_list_last_ptr
operator|=
name|nod
expr_stmt|;
name|pnp_device_list_last_ptr
operator|=
operator|&
operator|(
name|nod
operator|->
name|next
operator|)
expr_stmt|;
name|nod
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|" failed to attach\n"
argument_list|)
expr_stmt|;
block|}
name|doing_pnp_probe
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Run the isolation protocol. Use pnp_rd_port as the READ_DATA port  * value (caller should try multiple READ_DATA locations before giving  * up). Upon exiting, all cards are aware that they should use  * pnp_rd_port as the READ_DATA port.  *  * In the first pass, a csn is assigned to each board and pnp_id's  * are saved to an array, pnp_devices. In the second pass, each  * card is woken up and the device configuration is called.  */
end_comment

begin_function
name|int
name|pnp_isolation_protocol
parameter_list|()
block|{
name|int
name|csn
decl_stmt|;
name|pnp_send_Initiation_LFSR
argument_list|()
expr_stmt|;
name|pnp_write
argument_list|(
name|CONFIG_CONTROL
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Reset CSN for All Cards */
for|for
control|(
name|csn
operator|=
literal|1
init|;
operator|(
name|csn
operator|<
name|MAX_PNP_CARDS
operator|)
condition|;
name|csn
operator|++
control|)
block|{
comment|/* Wake up cards without a CSN */
name|pnp_write
argument_list|(
name|WAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pnp_write
argument_list|(
name|SET_RD_DATA
argument_list|,
name|pnp_rd_port
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PNP_ADDRESS
argument_list|,
name|SERIAL_ISOLATION
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Delay 1 msec */
if|if
condition|(
name|pnp_get_serial
argument_list|(
operator|&
operator|(
name|pnp_devices
index|[
name|csn
operator|-
literal|1
index|]
operator|)
argument_list|)
condition|)
block|{
name|pnp_write
argument_list|(
name|SET_CSN
argument_list|,
name|csn
argument_list|)
expr_stmt|;
comment|/* pnp_write(CONFIG_CONTROL, 2); */
block|}
else|else
break|break;
block|}
name|num_pnp_cards
operator|=
name|csn
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|csn
operator|=
literal|1
init|;
name|csn
operator|<=
name|num_pnp_cards
condition|;
name|csn
operator|++
control|)
block|{
comment|/* 	 * make sure cards are in SLEEP state 	 */
name|pnp_send_Initiation_LFSR
argument_list|()
expr_stmt|;
name|pnp_write
argument_list|(
name|WAKE
argument_list|,
name|csn
argument_list|)
expr_stmt|;
name|config_pnp_device
argument_list|(
operator|&
operator|(
name|pnp_devices
index|[
name|csn
operator|-
literal|1
index|]
operator|)
argument_list|,
name|csn
argument_list|)
expr_stmt|;
comment|/* 	 * Put all cards in WaitForKey, just in case the previous 	 * attach routine forgot it. 	 */
name|pnp_write
argument_list|(
name|CONFIG_CONTROL
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* XXX is it really necessary ? */
block|}
return|return
name|num_pnp_cards
return|;
block|}
end_function

begin_comment
comment|/*  * pnp_configure()  *  * autoconfiguration of pnp devices. This routine just runs the  * isolation protocol over several ports, until one is successful.  *  * may be called more than once ?  *  */
end_comment

begin_function
name|void
name|pnp_configure
parameter_list|()
block|{
name|int
name|num_pnp_devs
decl_stmt|;
if|if
condition|(
name|pnp_ldn_overrides
index|[
literal|0
index|]
operator|.
name|csn
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Initializing PnP override table\n"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pnp_ldn_overrides
argument_list|,
sizeof|sizeof
argument_list|(
name|pnp_ldn_overrides
argument_list|)
argument_list|)
expr_stmt|;
name|pnp_ldn_overrides
index|[
literal|0
index|]
operator|.
name|csn
operator|=
literal|255
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Probing for PnP devices:\n"
argument_list|)
expr_stmt|;
comment|/* Try various READ_DATA ports from 0x203-0x3ff */
for|for
control|(
name|pnp_rd_port
operator|=
literal|0x80
init|;
operator|(
name|pnp_rd_port
operator|<
literal|0xff
operator|)
condition|;
name|pnp_rd_port
operator|+=
literal|0x10
control|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Trying Read_Port at %x\n"
argument_list|,
operator|(
name|pnp_rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
expr_stmt|;
name|num_pnp_devs
operator|=
name|pnp_isolation_protocol
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_pnp_devs
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|num_pnp_devs
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"No Plug-n-Play devices were found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

end_unit

