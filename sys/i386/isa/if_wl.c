begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain all copyright   *    notices, this list of conditions and the following disclaimer.  * 2. The names of the authors may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   */
end_comment

begin_comment
comment|/*  * if_wl.c - original MACH, then BSDI ISA wavelan driver  *	ported to mach by Anders Klemets  *	to BSDI by Robert Morris  *	to FreeBSD by Jim Binkley  *      to FreeBSD 2.2+ by Michael Smith  *  * 2.2 update:  * Changed interface to match 2.1-2.2 differences.  * Implement IRQ selection logic in wlprobe()  * Implement PSA updating.  * Pruned heading comments for relevance.  * Ripped out all the 'interface counters' cruft.  * Cut the missing-interrupt timer back to 100ms.  * 2.2.1 update:  * now supports all multicast mode (mrouted will work),  *	but unfortunately must do that by going into promiscuous mode  * NWID sysctl added so that normally promiscuous mode is NWID-specific  *	but can be made NWID-inspecific  *			7/14/97 jrb  *  * Work done:  * Ported to FreeBSD, got promiscuous mode working with bpfs,  * and rewired timer routine.  The i82586 will hang occasionally on output   * and the watchdog timer will kick it if so and log an entry.  * 2 second timeout there.  Apparently the chip loses an interrupt.  * Code borrowed from if_ie.c for watchdog timer.  *  * The wavelan card is a 2mbit radio modem that emulates ethernet;  * i.e., it uses MAC addresses.  This should not be a surprise since  * it uses an ethernet controller as a major hw item.  * It can broadcast, unicast or apparently multicast in a base cell   * using a omni-directional antennae that is   * about 800 feet around the base cell barring walls and metal.    * With directional antennae, it can be used point to point over a mile  * or so apparently (haven't tried that).  *  * There are ISA and pcmcia versions (not supported by this code).  * The ISA card has an Intel 82586 lan controller on it.  It consists  * of 2 pieces of hw, the lan controller (intel) and a radio-modem.  * The latter has an extra set of controller registers that has nothing  * to do with the i82586 and allows setting and monitoring of radio  * signal strength, etc.  There is a nvram area called the PSA that  * contains a number of setup variables including the IRQ and so-called  * NWID or Network ID.  The NWID must be set the same for all radio  * cards to communicate (unless you are using the ATT/NCR roaming feature  * with their access points.  There is no support for that here. Roaming  * involves a link-layer beacon sent out from the access points.  End  * stations monitor the signal strength and only use the strongest  * access point).  This driver assumes that the base ISA port, IRQ,   * and NWID are first set in nvram via the dos-side "instconf.exe" utility   * supplied with the card. This driver takes the ISA port from   * the kernel configuration setup, and then determines the IRQ either   * from the kernel config (if an explicit IRQ is set) or from the   * PSA on the card if not.  * The hw also magically just uses the IRQ set in the nvram.  * The NWID is used magically as well by the radio-modem  * to determine which packets to keep or throw out.    *  * sample config:  *  * device wl0 at isa? port 0x300 net irq ?  *  * Ifdefs:  * 1. WLDEBUG. (off) - if turned on enables IFF_DEBUG set via ifconfig debug  * 2. MULTICAST (on) - turned on and works up to and including mrouted  * 3. WLCACHE (off) -  define to turn on a signal strength   * (and other metric) cache that is indexed by sender MAC address.    * Apps can read this out to learn the remote signal strength of a   * sender.  Note that it has a switch so that it only stores   * broadcast/multicast senders but it could be set to store unicast   * too only.  Size is hardwired in if_wl_wavelan.h  *  * one further note: promiscuous mode is a curious thing.  In this driver,  * promiscuous mode apparently CAN catch ALL packets and ignore the NWID  * setting.  This is probably more useful in a sense (for snoopers) if  * you are interested in all traffic as opposed to if you are interested  * in just your own.  There is a driver specific sysctl to turn promiscuous  * from just promiscuous to wildly promiscuous...  *  * This driver also knows how to load the synthesizers in the 2.4 Gz  * ISA Half-card, Product number 847647476 (USA/FCC IEEE Channel set).  * This product consists of a "mothercard" that contains the 82586,  * NVRAM that holds the PSA, and the ISA-buss interface custom ASIC.   * The radio transceiver is a "daughtercard" called the WaveMODEM which  * connects to the mothercard through two single-inline connectors: a  * 20-pin connector provides DC-power and modem signals, and a 3-pin  * connector which exports the antenna connection. The code herein  * loads the receive and transmit synthesizers and the corresponding  * transmitter output power value from an EEPROM controlled through  * additional registers via the MMC. The EEPROM address selected  * are those whose values are preset by the DOS utility programs  * provided with the product, and this provides compatible operation  * with the DOS Packet Driver software. A future modification will  * add the necessary functionality to this driver and to the wlconfig  * utility to completely replace the DOS Configuration Utilities.  * The 2.4 Gz WaveMODEM is described in document number 407-024692/E,  * and is available through Lucent Technologies OEM supply channels.  * --RAB 1997/06/08.  */
end_comment

begin_define
define|#
directive|define
name|MULTICAST
value|1
end_define

begin_comment
comment|/*   *	Olivetti PC586 Mach Ethernet driver v1.0  *	Copyright Ing. C. Olivetti& C. S.p.A. 1988, 1989  *	All rights reserved.  *  */
end_comment

begin_comment
comment|/*   Copyright 1988, 1989 by Olivetti Advanced Technology Center, Inc., Cupertino, California.  		All Rights Reserved    Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appears in all copies and that both the copyright notice and this permission notice appear in supporting documentation, and that the name of Olivetti not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    OLIVETTI DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL OLIVETTI BE LIABLE FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUR OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
end_comment

begin_comment
comment|/*   Copyright 1988, 1989 by Intel Corporation, Santa Clara, California.  		All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appears in all copies and that both the copyright notice and this permission notice appear in supporting documentation, and that the name of Intel not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  INTEL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL INTEL BE LIABLE FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
end_comment

begin_comment
comment|/*  * NOTE:  *		by rvb:  *  1.	The best book on the 82586 is:  *		LAN Components User's Manual by Intel  *	The copy I found was dated 1984.  This really tells you  *	what the state machines are doing  *  2.	In the current design, we only do one write at a time,  *	though the hardware is capable of chaining and possibly  *	even batching.  The problem is that we only make one  *	transmit buffer available in sram space.  */
end_comment

begin_include
include|#
directive|include
file|"wl.h"
end_include

begin_include
include|#
directive|include
file|"opt_wavelan.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ic/if_wl_i82586.h>
end_include

begin_comment
comment|/* Definitions for the Intel chip */
end_comment

begin_comment
comment|/* was 1000 in original, fed to DELAY(x) */
end_comment

begin_define
define|#
directive|define
name|DELAYCONST
value|1000
end_define

begin_include
include|#
directive|include
file|<i386/isa/if_wl.h>
end_include

begin_include
include|#
directive|include
file|<machine/if_wl_wavelan.h>
end_include

begin_decl_stmt
specifier|static
name|char
name|t_packet
index|[
name|ETHERMTU
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|wl_softc
block|{
name|struct
name|arpcom
name|wl_ac
decl_stmt|;
comment|/* Ethernet common part */
define|#
directive|define
name|wl_if
value|wl_ac.ac_if
comment|/* network visible interface */
define|#
directive|define
name|wl_addr
value|wl_ac.ac_enaddr
comment|/* hardware address */
name|u_char
name|psa
index|[
literal|0x40
index|]
decl_stmt|;
name|u_char
name|nwid
index|[
literal|2
index|]
decl_stmt|;
comment|/* current radio modem nwid */
name|short
name|base
decl_stmt|;
name|short
name|unit
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|tbusy
decl_stmt|;
comment|/* flag to determine if xmit is busy */
name|u_short
name|begin_fd
decl_stmt|;
name|u_short
name|end_fd
decl_stmt|;
name|u_short
name|end_rbd
decl_stmt|;
name|u_short
name|hacr
decl_stmt|;
comment|/* latest host adapter CR command */
name|short
name|mode
decl_stmt|;
name|u_char
name|chan24
decl_stmt|;
comment|/* 2.4 Gz: channel number/EEPROM Area # */
name|u_short
name|freq24
decl_stmt|;
comment|/* 2.4 Gz: resulting frequency  */
name|struct
name|callout_handle
name|watchdog_ch
decl_stmt|;
ifdef|#
directive|ifdef
name|WLCACHE
name|int
name|w_sigitems
decl_stmt|;
comment|/* number of cached entries */
comment|/*  array of cache entries */
name|struct
name|w_sigcache
name|w_sigcache
index|[
name|MAXCACHEITEMS
index|]
decl_stmt|;
name|int
name|w_nextcache
decl_stmt|;
comment|/* next free cache entry */
name|int
name|w_wrapindex
decl_stmt|;
comment|/* next "free" cache entry */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|wl_softc
name|wl_softc
index|[
name|NWL
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|WLSOFTC
parameter_list|(
name|unit
parameter_list|)
value|((struct wl_softc *)(&wl_softc[unit]))
end_define

begin_function_decl
specifier|static
name|int
name|wlprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wlattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|wldriver
init|=
block|{
name|wlprobe
block|,
name|wlattach
block|,
literal|"wl"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX  The Wavelan appears to be prone to dropping stuff if you talk to  * it too fast.  This disgusting hack inserts a delay after each packet  * is queued which helps avoid this behaviour on fast systems.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wl_xmit_delay
init|=
literal|250
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|wl_xmit_delay
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|wl_xmit_delay
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*   * not XXX, but ZZZ (bizarre).  * promiscuous mode can be toggled to ignore NWIDs.  By default,  * it does not.  Caution should be exercised about combining  * this mode with IFF_ALLMULTI which puts this driver in  * promiscuous mode.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wl_ignore_nwid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|wl_ignore_nwid
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|wl_ignore_nwid
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Emit diagnostics about transmission problems  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|xmt_watch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|wl_xmit_watch
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|xmt_watch
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Collect SNR statistics  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gathersnr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|wl_gather_snr
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|gathersnr
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|wlstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wlinit
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wlioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|wlwatchdog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ointhand2_t
name|wlintr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|wlxmt
parameter_list|(
name|int
name|unt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wldiag
parameter_list|(
name|int
name|unt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wlconfig
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wlcmd
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wlmmcstat
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|wlbldru
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|wlmmcread
parameter_list|(
name|u_int
name|base
parameter_list|,
name|u_short
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wlinitmmc
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wlhwrst
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wlrustrt
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wlbldcu
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wlack
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wlread
parameter_list|(
name|int
name|unit
parameter_list|,
name|u_short
name|fd_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|getsnr
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wlrcv
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wlrequeue
parameter_list|(
name|int
name|unit
parameter_list|,
name|u_short
name|fd_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wlsftwsleaze
parameter_list|(
name|u_short
modifier|*
name|countp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|mb_pp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|tm_pp
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wlhdwsleaze
parameter_list|(
name|u_short
modifier|*
name|countp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|mb_pp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|tm_pp
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wltbd
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wlgetpsa
parameter_list|(
name|int
name|base
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wlsetpsa
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|wlpsacrc
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wldump
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|WLCACHE
end_ifdef

begin_function_decl
specifier|static
name|void
name|wl_cache_store
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|ether_header
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wl_cache_zero
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MULTICAST
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|<
literal|300000
end_if

begin_function_decl
specifier|static
name|int
name|check_allmulti
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* array for maping irq numbers to values for the irq parameter register */
end_comment

begin_decl_stmt
specifier|static
name|int
name|irqvals
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x04
block|,
literal|0
block|,
literal|0x08
block|,
literal|0
block|,
literal|0
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0
block|,
literal|0
block|,
literal|0x80
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mask of valid IRQs */
end_comment

begin_define
define|#
directive|define
name|WL_IRQS
value|(IRQ3|IRQ4|IRQ5|IRQ7|IRQ10|IRQ11|IRQ12|IRQ15)
end_define

begin_comment
comment|/*  * wlprobe:  *  *	This function "probes" or checks for the WaveLAN board on the bus to  *	see if it is there.  As far as I can tell, the best break between this  *	routine and the attach code is to simply determine whether the board  *	is configured in properly.  Currently my approach to this is to write  *	and read a word from the SRAM on the board being probed.  If the word  *	comes back properly then we assume the board is there.  The config  *	code expects to see a successful return from the probe routine before  *	attach will be called.  *  * input	: address device is mapped to, and unit # being checked  * output	: a '1' is returned if the board exists, and a 0 otherwise  *  */
end_comment

begin_function
specifier|static
name|int
name|wlprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|wl_softc
modifier|*
name|sc
init|=
operator|&
name|wl_softc
index|[
name|id
operator|->
name|id_unit
index|]
decl_stmt|;
specifier|register
name|short
name|base
init|=
name|id
operator|->
name|id_iobase
decl_stmt|;
name|char
modifier|*
name|str
init|=
literal|"wl%d: board out of range [0..%d]\n"
decl_stmt|;
name|u_char
name|inbuf
index|[
literal|100
index|]
decl_stmt|;
name|unsigned
name|long
name|oldpri
decl_stmt|;
name|int
name|irq
decl_stmt|;
comment|/* TBD. not true.      * regular CMD() will not work, since no softc yet       */
define|#
directive|define
name|PCMD
parameter_list|(
name|base
parameter_list|,
name|hacr
parameter_list|)
value|outw((base), (hacr))
name|oldpri
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|PCMD
argument_list|(
name|base
argument_list|,
name|HACR_RESET
argument_list|)
expr_stmt|;
comment|/* reset the board */
name|DELAY
argument_list|(
name|DELAYCONST
argument_list|)
expr_stmt|;
comment|/*>> 4 clocks at 6MHz */
name|PCMD
argument_list|(
name|base
argument_list|,
name|HACR_RESET
argument_list|)
expr_stmt|;
comment|/* reset the board */
name|DELAY
argument_list|(
name|DELAYCONST
argument_list|)
expr_stmt|;
comment|/*>> 4 clocks at 6MHz */
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
comment|/* clear reset command and set PIO#1 in autoincrement mode */
name|PCMD
argument_list|(
name|base
argument_list|,
name|HACR_DEFAULT
argument_list|)
expr_stmt|;
name|PCMD
argument_list|(
name|base
argument_list|,
name|HACR_DEFAULT
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* go to beginning of RAM */
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* write string */
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* rewind */
name|insw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|inbuf
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
operator|/
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* read result */
if|if
condition|(
name|bcmp
argument_list|(
name|str
argument_list|,
name|inbuf
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|->
name|chan24
operator|=
literal|0
expr_stmt|;
comment|/* 2.4 Gz: config channel */
name|sc
operator|->
name|freq24
operator|=
literal|0
expr_stmt|;
comment|/* 2.4 Gz: frequency    */
comment|/* read the PSA from the board into temporary storage */
name|wlgetpsa
argument_list|(
name|base
argument_list|,
name|inbuf
argument_list|)
expr_stmt|;
comment|/* We read the IRQ value from the PSA on the board. */
for|for
control|(
name|irq
operator|=
literal|15
init|;
name|irq
operator|>=
literal|0
condition|;
name|irq
operator|--
control|)
if|if
condition|(
name|irqvals
index|[
name|irq
index|]
operator|==
name|inbuf
index|[
name|WLPSA_IRQNO
index|]
condition|)
break|break;
if|if
condition|(
operator|(
name|irq
operator|==
literal|0
operator|)
operator|||
operator|(
name|irqvals
index|[
name|irq
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d: PSA corrupt (invalid IRQ value)\n"
argument_list|,
name|id
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|id
operator|->
name|id_irq
operator|=
literal|0
expr_stmt|;
comment|/* no interrupt */
block|}
else|else
block|{
comment|/* 	 * If the IRQ requested by the PSA is already claimed by another 	 * device, the board won't work, but the user can still access the 	 * driver to change the IRQ. 	 */
name|id
operator|->
name|id_irq
operator|=
operator|(
literal|1
operator|<<
name|irq
operator|)
expr_stmt|;
comment|/* use IRQ from PSA */
block|}
return|return
operator|(
literal|16
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * wlattach:  *  *	This function attaches a WaveLAN board to the "system".  The rest of  *	runtime structures are initialized here (this routine is called after  *	a successful probe of the board).  Once the ethernet address is read  *	and stored, the board's ifnet structure is attached and readied.  *  * input	: isa_dev structure setup in autoconfig  * output	: board structs and ifnet is setup  *  */
end_comment

begin_function
specifier|static
name|int
name|wlattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|wl_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|wl_softc
operator|*
operator|)
operator|&
name|wl_softc
index|[
name|id
operator|->
name|id_unit
index|]
decl_stmt|;
specifier|register
name|short
name|base
init|=
name|id
operator|->
name|id_iobase
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_char
name|unit
init|=
name|id
operator|->
name|id_unit
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|wl_if
decl_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
name|printf
argument_list|(
literal|"wlattach: base %x, unit %d\n"
argument_list|,
name|base
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|id
operator|->
name|id_ointr
operator|=
name|wlintr
expr_stmt|;
name|sc
operator|->
name|base
operator|=
name|base
expr_stmt|;
name|sc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|hacr
operator|=
name|HACR_RESET
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|watchdog_ch
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* reset the board */
name|DELAY
argument_list|(
name|DELAYCONST
argument_list|)
expr_stmt|;
comment|/*>> 4 clocks at 6MHz */
comment|/* clear reset command and set PIO#2 in parameter access mode */
name|sc
operator|->
name|hacr
operator|=
operator|(
name|HACR_DEFAULT
operator|&
operator|~
name|HACR_16BITS
operator|)
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* Read the PSA from the board for our later reference */
name|wlgetpsa
argument_list|(
name|base
argument_list|,
name|sc
operator|->
name|psa
argument_list|)
expr_stmt|;
comment|/* fetch NWID */
name|sc
operator|->
name|nwid
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|psa
index|[
name|WLPSA_NWID
index|]
expr_stmt|;
name|sc
operator|->
name|nwid
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|psa
index|[
name|WLPSA_NWID
operator|+
literal|1
index|]
expr_stmt|;
comment|/* fetch MAC address - decide which one first */
if|if
condition|(
name|sc
operator|->
name|psa
index|[
name|WLPSA_MACSEL
index|]
operator|&
literal|1
condition|)
block|{
name|j
operator|=
name|WLPSA_LOCALMAC
expr_stmt|;
block|}
else|else
block|{
name|j
operator|=
name|WLPSA_UNIMAC
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WAVELAN_ADDR_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|sc
operator|->
name|wl_addr
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|psa
index|[
name|j
operator|+
name|i
index|]
expr_stmt|;
block|}
comment|/* enter normal 16 bit mode operation */
name|sc
operator|->
name|hacr
operator|=
name|HACR_DEFAULT
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|wlinitmmc
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* address of scb_crcerrs */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear scb_crcerrs */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear scb_alnerrs */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear scb_rscerrs */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* clear scb_ovrnerrs */
name|bzero
argument_list|(
name|ifp
argument_list|,
sizeof|sizeof
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|id
operator|->
name|id_unit
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|WAVELAN_MTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_DEBUG
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MULTICAST
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_MULTICAST
expr_stmt|;
endif|#
directive|endif
comment|/* MULTICAST */
name|ifp
operator|->
name|if_name
operator|=
literal|"wl"
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|wlinit
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|wlstart
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|wlioctl
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* paranoia */
comment|/* no entries        ifp->if_watchdog        ifp->if_done        ifp->if_reset        */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|wl_addr
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|wl_ac
operator|.
name|ac_enaddr
argument_list|,
name|WAVELAN_ADDR_SIZE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d: address %6D, NWID 0x%02x%02x"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|sc
operator|->
name|wl_ac
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|nwid
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|nwid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|freq24
condition|)
name|printf
argument_list|(
literal|", Freq %d MHz"
argument_list|,
name|sc
operator|->
name|freq24
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz       */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz       */
if|if
condition|(
name|bootverbose
condition|)
name|wldump
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print out interesting information about the 82596.  */
end_comment

begin_function
specifier|static
name|void
name|wldump
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sp
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|int
name|base
init|=
name|sp
operator|->
name|base
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"hasr %04x\n"
argument_list|,
name|inw
argument_list|(
name|HASR
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"scb at %04x:\n "
argument_list|,
name|OFFSET_SCB
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%04x "
argument_list|,
name|inw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cu at %04x:\n "
argument_list|,
name|OFFSET_CU
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%04x "
argument_list|,
name|inw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tbd at %04x:\n "
argument_list|,
name|OFFSET_TBD
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_TBD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%04x "
argument_list|,
name|inw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the Modem Management Controller */
end_comment

begin_function
specifier|static
name|void
name|wlinitmmc
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sp
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|int
name|base
init|=
name|sp
operator|->
name|base
decl_stmt|;
name|int
name|configured
decl_stmt|;
name|int
name|mode
init|=
name|sp
operator|->
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 2.4 Gz               */
comment|/* enter 8 bit operation */
name|sp
operator|->
name|hacr
operator|=
operator|(
name|HACR_DEFAULT
operator|&
operator|~
name|HACR_16BITS
operator|)
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|configured
operator|=
name|sp
operator|->
name|psa
index|[
name|WLPSA_CONFIGURED
index|]
operator|&
literal|1
expr_stmt|;
comment|/*      * Set default modem control parameters.  Taken from NCR document      *  407-0024326 Rev. A       */
name|MMC_WRITE
argument_list|(
name|MMC_JABBER_ENABLE
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|MMC_WRITE
argument_list|(
name|MMC_ANTEN_SEL
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|MMC_WRITE
argument_list|(
name|MMC_IFS
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|MMC_WRITE
argument_list|(
name|MMC_MOD_DELAY
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|MMC_WRITE
argument_list|(
name|MMC_JAM_TIME
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|MMC_WRITE
argument_list|(
name|MMC_DECAY_PRM
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* obsolete ? */
name|MMC_WRITE
argument_list|(
name|MMC_DECAY_UPDAT_PRM
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|configured
condition|)
block|{
name|MMC_WRITE
argument_list|(
name|MMC_LOOPT_SEL
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|psa
index|[
name|WLPSA_COMPATNO
index|]
operator|&
literal|1
condition|)
block|{
name|MMC_WRITE
argument_list|(
name|MMC_THR_PRE_SET
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* 0x04 for AT and 0x01 for MCA */
block|}
else|else
block|{
name|MMC_WRITE
argument_list|(
name|MMC_THR_PRE_SET
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* 0x04 for AT and 0x01 for MCA */
block|}
name|MMC_WRITE
argument_list|(
name|MMC_QUALITY_THR
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use configuration defaults from parameter storage area */
if|if
condition|(
name|sp
operator|->
name|psa
index|[
name|WLPSA_NWIDENABLE
index|]
operator|&
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|mode
operator|&
operator|(
name|MOD_PROM
operator||
name|MOD_ENAL
operator|)
operator|)
operator|&&
name|wl_ignore_nwid
condition|)
block|{
name|MMC_WRITE
argument_list|(
name|MMC_LOOPT_SEL
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MMC_WRITE
argument_list|(
name|MMC_LOOPT_SEL
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|MMC_WRITE
argument_list|(
name|MMC_LOOPT_SEL
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
comment|/* disable network id check */
block|}
name|MMC_WRITE
argument_list|(
name|MMC_THR_PRE_SET
argument_list|,
name|sp
operator|->
name|psa
index|[
name|WLPSA_THRESH
index|]
argument_list|)
expr_stmt|;
name|MMC_WRITE
argument_list|(
name|MMC_QUALITY_THR
argument_list|,
name|sp
operator|->
name|psa
index|[
name|WLPSA_QUALTHRESH
index|]
argument_list|)
expr_stmt|;
block|}
name|MMC_WRITE
argument_list|(
name|MMC_FREEZE
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|MMC_WRITE
argument_list|(
name|MMC_ENCR_ENABLE
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|MMC_WRITE
argument_list|(
name|MMC_NETW_ID_L
argument_list|,
name|sp
operator|->
name|nwid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* set NWID */
name|MMC_WRITE
argument_list|(
name|MMC_NETW_ID_H
argument_list|,
name|sp
operator|->
name|nwid
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* enter normal 16 bit mode operation */
name|sp
operator|->
name|hacr
operator|=
name|HACR_DEFAULT
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* virtualpc1 needs this! */
if|if
condition|(
name|sp
operator|->
name|psa
index|[
name|WLPSA_COMPATNO
index|]
operator|==
comment|/* 2.4 Gz: half-card ver     */
name|WLPSA_COMPATNO_WL24B
condition|)
block|{
comment|/* 2.4 Gz		     */
name|i
operator|=
name|sp
operator|->
name|chan24
operator|<<
literal|4
expr_stmt|;
comment|/* 2.4 Gz: position ch #     */
name|MMC_WRITE
argument_list|(
name|MMC_EEADDR
argument_list|,
name|i
operator|+
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz: named ch, wc=16   */
name|MMC_WRITE
argument_list|(
name|MMC_EECTRL
argument_list|,
name|MMC_EECTRL_DWLD
operator|+
comment|/* 2.4 Gz: Download Synths   */
name|MMC_EECTRL_EEOP_READ
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz: Read EEPROM	     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
operator|++
name|i
control|)
block|{
comment|/* 2.4 Gz: wait for download */
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz	      */
if|if
condition|(
operator|(
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_EECTRLstat
argument_list|)
comment|/* 2.4 Gz: check DWLD and    */
operator|&
operator|(
name|MMC_EECTRLstat_DWLD
comment|/* 2.4 Gz:	 EEBUSY	     */
operator|+
name|MMC_EECTRLstat_EEBUSY
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* 2.4 Gz:		     */
break|break;
comment|/* 2.4 Gz: download finished */
block|}
comment|/* 2.4 Gz		     */
if|if
condition|(
name|i
operator|==
literal|1000
condition|)
name|printf
argument_list|(
literal|"wl: synth load failed\n"
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz	*/
name|MMC_WRITE
argument_list|(
name|MMC_EEADDR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz: default pwr, wc=2 */
name|MMC_WRITE
argument_list|(
name|MMC_EECTRL
argument_list|,
name|MMC_EECTRL_DWLD
operator|+
comment|/* 2.4 Gz: Download Xmit Pwr */
name|MMC_EECTRL_EEOP_READ
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz: Read EEPROM	     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
operator|++
name|i
control|)
block|{
comment|/* 2.4 Gz: wait for download */
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz	      */
if|if
condition|(
operator|(
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_EECTRLstat
argument_list|)
comment|/* 2.4 Gz: check DWLD and    */
operator|&
operator|(
name|MMC_EECTRLstat_DWLD
comment|/* 2.4 Gz:	 EEBUSY	     */
operator|+
name|MMC_EECTRLstat_EEBUSY
operator|)
operator|)
operator|==
literal|0
condition|)
comment|/* 2.4 Gz:		     */
break|break;
comment|/* 2.4 Gz: download finished */
block|}
comment|/* 2.4 Gz		     */
if|if
condition|(
name|i
operator|==
literal|1000
condition|)
name|printf
argument_list|(
literal|"wl: xmit pwr load failed\n"
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz	     */
name|MMC_WRITE
argument_list|(
name|MMC_ANALCTRL
argument_list|,
comment|/* 2.4 Gz: EXT ant+polarity  */
name|MMC_ANALCTRL_ANTPOL
operator|+
comment|/* 2.4 Gz:		     */
name|MMC_ANALCTRL_EXTANT
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz:		     */
name|i
operator|=
name|sp
operator|->
name|chan24
operator|<<
literal|4
expr_stmt|;
comment|/* 2.4 Gz: position ch #     */
name|MMC_WRITE
argument_list|(
name|MMC_EEADDR
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz: get frequency     */
name|MMC_WRITE
argument_list|(
name|MMC_EECTRL
argument_list|,
comment|/* 2.4 Gz: EEPROM read	    */
name|MMC_EECTRL_EEOP_READ
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz:		    */
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz		     */
name|i
operator|=
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_EEDATALrv
argument_list|)
comment|/* 2.4 Gz: freq val	     */
operator|+
operator|(
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_EEDATAHrv
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* 2.4 Gz		     */
name|sp
operator|->
name|freq24
operator|=
operator|(
name|i
operator|>>
literal|6
operator|)
operator|+
literal|2400
expr_stmt|;
comment|/* 2.4 Gz: save real freq    */
block|}
block|}
end_function

begin_comment
comment|/*  * wlinit:  *  *	Another routine that interfaces the "if" layer to this driver.    *	Simply resets the structures that are used by "upper layers".    *	As well as calling wlhwrst that does reset the WaveLAN board.  *  * input	: softc pointer for this interface  * output	: structures (if structs) and board are reset  *  */
end_comment

begin_function
specifier|static
name|void
name|wlinit
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|wl_if
decl_stmt|;
name|int
name|stat
decl_stmt|;
name|u_long
name|oldpri
decl_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d: entered wlinit()\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|300000
if|if
condition|(
name|ifp
operator|->
name|if_addrhead
operator|.
name|tqh_first
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|ifp
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
block|{
endif|#
directive|endif
return|return;
block|}
name|oldpri
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|=
name|wlhwrst
argument_list|(
name|sc
operator|->
name|unit
argument_list|)
operator|)
operator|==
name|TRUE
condition|)
block|{
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
comment|/* same as DSF_RUNNING */
comment|/*  	 * OACTIVE is used by upper-level routines 	 * and must be set 	 */
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* same as tbusy below */
name|sc
operator|->
name|flags
operator||=
name|DSF_RUNNING
expr_stmt|;
name|sc
operator|->
name|tbusy
operator|=
literal|0
expr_stmt|;
name|untimeout
argument_list|(
name|wlwatchdog
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|watchdog_ch
argument_list|)
expr_stmt|;
name|wlstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"wl%d init(): trouble resetting board.\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
block|}
comment|/*  * wlhwrst:  *  *	This routine resets the WaveLAN board that corresponds to the   *	board number passed in.  *  * input	: board number to do a hardware reset  * output	: board is reset  *  */
specifier|static
name|int
name|wlhwrst
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d: entered wlhwrst()\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|hacr
operator|=
name|HACR_RESET
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* reset the board */
comment|/* clear reset command and set PIO#1 in autoincrement mode */
name|sc
operator|->
name|hacr
operator|=
name|HACR_DEFAULT
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|wlmmcstat
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* Display MMC registers */
endif|#
directive|endif
comment|/* WLDEBUG */
name|wlbldcu
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* set up command unit structures */
if|if
condition|(
name|wldiag
argument_list|(
name|unit
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|wlconfig
argument_list|(
name|unit
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*       * insert code for loopback test here      */
name|wlrustrt
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* start receive unit */
comment|/* enable interrupts */
name|sc
operator|->
name|hacr
operator|=
operator|(
name|HACR_DEFAULT
operator||
name|HACR_INTRON
operator|)
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * wlbldcu:  *  *	This function builds up the command unit structures.  It inits  *	the scp, iscp, scb, cb, tbd, and tbuf.  *  */
specifier|static
name|void
name|wlbldcu
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|scp_t
name|scp
decl_stmt|;
name|iscp_t
name|iscp
decl_stmt|;
name|scb_t
name|scb
decl_stmt|;
name|ac_t
name|cb
decl_stmt|;
name|tbd_t
name|tbd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scp
argument_list|,
sizeof|sizeof
argument_list|(
name|scp
argument_list|)
argument_list|)
expr_stmt|;
name|scp
operator|.
name|scp_sysbus
operator|=
literal|0
expr_stmt|;
name|scp
operator|.
name|scp_iscp
operator|=
name|OFFSET_ISCP
expr_stmt|;
name|scp
operator|.
name|scp_iscp_base
operator|=
literal|0
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCP
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|scp
argument_list|,
sizeof|sizeof
argument_list|(
name|scp_t
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|iscp
argument_list|,
sizeof|sizeof
argument_list|(
name|iscp
argument_list|)
argument_list|)
expr_stmt|;
name|iscp
operator|.
name|iscp_busy
operator|=
literal|1
expr_stmt|;
name|iscp
operator|.
name|iscp_scb_offset
operator|=
name|OFFSET_SCB
expr_stmt|;
name|iscp
operator|.
name|iscp_scb
operator|=
literal|0
expr_stmt|;
name|iscp
operator|.
name|iscp_scb_base
operator|=
literal|0
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_ISCP
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|iscp
argument_list|,
sizeof|sizeof
argument_list|(
name|iscp_t
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|scb
operator|.
name|scb_status
operator|=
literal|0
expr_stmt|;
name|scb
operator|.
name|scb_command
operator|=
name|SCB_RESET
expr_stmt|;
name|scb
operator|.
name|scb_cbl_offset
operator|=
name|OFFSET_CU
expr_stmt|;
name|scb
operator|.
name|scb_rfa_offset
operator|=
name|OFFSET_RU
expr_stmt|;
name|scb
operator|.
name|scb_crcerrs
operator|=
literal|0
expr_stmt|;
name|scb
operator|.
name|scb_alnerrs
operator|=
literal|0
expr_stmt|;
name|scb
operator|.
name|scb_rscerrs
operator|=
literal|0
expr_stmt|;
name|scb
operator|.
name|scb_ovrnerrs
operator|=
literal|0
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|scb
argument_list|,
sizeof|sizeof
argument_list|(
name|scb_t
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|SET_CHAN_ATTN
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_ISCP
operator|+
literal|0
argument_list|)
expr_stmt|;
comment|/* address of iscp_busy */
for|for
control|(
name|i
operator|=
literal|1000000
init|;
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&&
operator|(
name|i
operator|--
operator|>
literal|0
operator|)
condition|;
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|printf
argument_list|(
literal|"wl%d bldcu(): iscp_busy timeout.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
operator|+
literal|0
argument_list|)
expr_stmt|;
comment|/* address of scb_status */
for|for
control|(
name|i
operator|=
name|STATUS_TRIES
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|==
operator|(
name|SCB_SW_CX
operator||
name|SCB_SW_CNA
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|printf
argument_list|(
literal|"wl%d bldcu(): not ready after reset.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|wlack
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|cb
operator|.
name|ac_status
operator|=
literal|0
expr_stmt|;
name|cb
operator|.
name|ac_command
operator|=
name|AC_CW_EL
expr_stmt|;
comment|/* NOP */
name|cb
operator|.
name|ac_link_offset
operator|=
name|OFFSET_CU
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|cb
argument_list|,
literal|6
operator|/
literal|2
argument_list|)
expr_stmt|;
name|tbd
operator|.
name|act_count
operator|=
literal|0
expr_stmt|;
name|tbd
operator|.
name|next_tbd_offset
operator|=
name|I82586NULL
expr_stmt|;
name|tbd
operator|.
name|buffer_addr
operator|=
literal|0
expr_stmt|;
name|tbd
operator|.
name|buffer_base
operator|=
literal|0
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_TBD
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|tbd
argument_list|,
sizeof|sizeof
argument_list|(
name|tbd_t
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*  * wlstart:  *  *	send a packet  *  * input	: board number  * output	: stuff sent to board if any there  *  */
specifier|static
name|void
name|wlstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|unit
init|=
name|ifp
operator|->
name|if_unit
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|int
name|scb_status
decl_stmt|,
name|cu_status
decl_stmt|,
name|scb_command
decl_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d: entered wlstart()\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
argument_list|)
expr_stmt|;
name|cu_status
operator|=
name|inw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
operator|+
literal|0
argument_list|)
expr_stmt|;
comment|/* scb_status */
name|scb_status
operator|=
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
operator|+
literal|2
argument_list|)
expr_stmt|;
name|scb_command
operator|=
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * don't need OACTIVE check as tbusy here checks to see      * if we are already busy       */
if|if
condition|(
name|sc
operator|->
name|tbusy
condition|)
block|{
if|if
condition|(
operator|(
name|scb_status
operator|&
literal|0x0700
operator|)
operator|==
name|SCB_CUS_IDLE
operator|&&
operator|(
name|cu_status
operator|&
name|AC_SW_B
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tbusy
operator|=
literal|0
expr_stmt|;
name|untimeout
argument_list|(
name|wlwatchdog
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|watchdog_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wl_ac
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* 	     * This is probably just a race.  The xmt'r is just 	     * became idle but WE have masked interrupts so ... 	     */
ifdef|#
directive|ifdef
name|WLDEBUG
name|printf
argument_list|(
literal|"wl%d: CU idle, scb %04x %04x cu %04x\n"
argument_list|,
name|unit
argument_list|,
name|scb_status
argument_list|,
name|scb_command
argument_list|,
name|cu_status
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|xmt_watch
condition|)
name|printf
argument_list|(
literal|"!!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return;
comment|/* genuinely still busy */
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|scb_status
operator|&
literal|0x0700
operator|)
operator|==
name|SCB_CUS_ACTV
operator|||
operator|(
name|cu_status
operator|&
name|AC_SW_B
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|WLDEBUG
name|printf
argument_list|(
literal|"wl%d: CU unexpectedly busy; scb %04x cu %04x\n"
argument_list|,
name|unit
argument_list|,
name|scb_status
argument_list|,
name|cu_status
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|xmt_watch
condition|)
name|printf
argument_list|(
literal|"wl%d: busy?!"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
comment|/* hey, why are we busy? */
block|}
comment|/* get ourselves some data */
name|ifp
operator|=
operator|&
operator|(
name|sc
operator|->
name|wl_if
operator|)
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
block|{
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* let BPF see it before we commit it */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|tbusy
operator|++
expr_stmt|;
comment|/* set the watchdog timer so that if the board 	 * fails to interrupt we will restart 	 */
comment|/* try 10 ticks, not very long */
name|sc
operator|->
name|watchdog_ch
operator|=
name|timeout
argument_list|(
name|wlwatchdog
argument_list|,
name|sc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wl_ac
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|wl_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|wlxmt
argument_list|(
name|unit
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|wl_ac
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
return|return;
block|}
comment|/*  * wlread:  *  *	This routine does the actual copy of data (including ethernet header  *	structure) from the WaveLAN to an mbuf chain that will be passed up  *	to the "if" (network interface) layer.  NOTE:  we currently  *	don't handle trailer protocols, so if that is needed, it will  *	(at least in part) be added here.  For simplicities sake, this  *	routine copies the receive buffers from the board into a local (stack)  *	buffer until the frame has been copied from the board.  Once in  *	the local buffer, the contents are copied to an mbuf chain that  *	is then enqueued onto the appropriate "if" queue.  *  * input	: board number, and an frame descriptor address  * output	: the packet is put into an mbuf chain, and passed up  * assumes	: if any errors occur, packet is "dropped on the floor"  *  */
specifier|static
name|int
name|wlread
parameter_list|(
name|int
name|unit
parameter_list|,
name|u_short
name|fd_p
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|wl_if
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|fd_t
name|fd
decl_stmt|;
name|struct
name|ether_header
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|tm
decl_stmt|;
name|rbd_t
name|rbd
decl_stmt|;
name|u_char
modifier|*
name|mb_p
decl_stmt|;
name|u_short
name|mlen
decl_stmt|,
name|len
decl_stmt|,
name|clen
decl_stmt|;
name|u_short
name|bytes_in_msg
decl_stmt|,
name|bytes_in_mbuf
decl_stmt|,
name|bytes
decl_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d: entered wlread()\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
operator|)
operator|!=
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d read(): board is not running.\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|hacr
operator|&=
operator|~
name|HACR_INTRON
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* turn off interrupts */
block|}
comment|/* read ether_header info out of device memory. doesn't      * go into mbuf.  goes directly into eh structure      */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* 14 bytes */
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|fd_p
argument_list|)
expr_stmt|;
name|insw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|fd
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|fd_t
argument_list|)
operator|-
name|len
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|insw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|eh
argument_list|,
operator|(
name|len
operator|-
literal|2
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|eh
operator|.
name|ether_type
operator|=
name|ntohs
argument_list|(
name|inw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"wlread: rcv packet, type is %x\n"
argument_list|,
name|eh
operator|.
name|ether_type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * WARNING.  above is done now in ether_input, above may be      * useful for debug. jrb      */
name|eh
operator|.
name|ether_type
operator|=
name|htons
argument_list|(
name|eh
operator|.
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|.
name|rbd_offset
operator|==
name|I82586NULL
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d read(): Invalid buffer\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|wlhwrst
argument_list|(
name|unit
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d read(): hwrst trouble.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|fd
operator|.
name|rbd_offset
argument_list|)
expr_stmt|;
name|insw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|rbd
argument_list|,
sizeof|sizeof
argument_list|(
name|rbd_t
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|bytes_in_msg
operator|=
name|rbd
operator|.
name|status
operator|&
name|RBD_SW_COUNT
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|tm
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|m
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* 	 * not only do we want to return, we need to drop the packet on 	 * the floor to clear the interrupt. 	 * 	 */
if|if
condition|(
name|wlhwrst
argument_list|(
name|unit
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
name|sc
operator|->
name|hacr
operator|&=
operator|~
name|HACR_INTRON
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* turn off interrupts */
name|printf
argument_list|(
literal|"wl%d read(): hwrst trouble.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|m
operator|->
name|m_next
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
comment|/* don't know this yet */
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
comment|/* always use a cluster. jrb       */
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|wlhwrst
argument_list|(
name|unit
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
name|sc
operator|->
name|hacr
operator|&=
operator|~
name|HACR_INTRON
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* turn off interrupts */
name|printf
argument_list|(
literal|"wl%d read(): hwrst trouble.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|mlen
operator|=
literal|0
expr_stmt|;
name|clen
operator|=
name|mlen
expr_stmt|;
name|bytes_in_mbuf
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|mb_p
operator|=
name|mtod
argument_list|(
name|tm
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|min
argument_list|(
name|bytes_in_mbuf
argument_list|,
name|bytes_in_msg
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|bytes
operator|&
literal|1
condition|)
block|{
name|len
operator|=
name|bytes
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|bytes
expr_stmt|;
block|}
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|rbd
operator|.
name|buffer_addr
argument_list|)
expr_stmt|;
name|insw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|mb_p
argument_list|,
name|len
operator|/
literal|2
argument_list|)
expr_stmt|;
name|clen
operator|+=
name|bytes
expr_stmt|;
name|mlen
operator|+=
name|bytes
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bytes_in_mbuf
operator|-=
name|bytes
operator|)
condition|)
block|{
name|MGET
argument_list|(
name|tm
operator|->
name|m_next
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|tm
operator|=
name|tm
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|tm
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wl%d read(): No mbuf nth\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|wlhwrst
argument_list|(
name|unit
argument_list|)
operator|!=
name|TRUE
condition|)
block|{
name|sc
operator|->
name|hacr
operator|&=
operator|~
name|HACR_INTRON
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* turn off interrupts */
name|printf
argument_list|(
literal|"wl%d read(): hwrst trouble.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|mlen
operator|=
literal|0
expr_stmt|;
name|tm
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
name|bytes_in_mbuf
operator|=
name|MLEN
expr_stmt|;
name|mb_p
operator|=
name|mtod
argument_list|(
name|tm
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mb_p
operator|+=
name|bytes
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|bytes_in_msg
operator|-=
name|bytes
operator|)
condition|)
block|{
if|if
condition|(
name|rbd
operator|.
name|status
operator|&
name|RBD_SW_EOF
operator|||
name|rbd
operator|.
name|next_rbd_offset
operator|==
name|I82586NULL
condition|)
block|{
name|tm
operator|->
name|m_len
operator|=
name|mlen
expr_stmt|;
break|break;
block|}
else|else
block|{
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|rbd
operator|.
name|next_rbd_offset
argument_list|)
expr_stmt|;
name|insw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|rbd
argument_list|,
sizeof|sizeof
argument_list|(
name|rbd_t
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|bytes_in_msg
operator|=
name|rbd
operator|.
name|status
operator|&
name|RBD_SW_COUNT
expr_stmt|;
block|}
block|}
else|else
block|{
name|rbd
operator|.
name|buffer_addr
operator|+=
name|bytes
expr_stmt|;
block|}
name|bytes
operator|=
name|min
argument_list|(
name|bytes_in_mbuf
argument_list|,
name|bytes_in_msg
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|clen
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/*      * Check if there's a BPF listener on this interface. If so, hand off      * the raw packet to bpf.      */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
comment|/* bpf assumes header is in mbufs.  It isn't.  We can 	 * fool it without allocating memory as follows. 	 * Trick borrowed from if_ie.c 	 */
name|struct
name|mbuf
name|m0
decl_stmt|;
name|m0
operator|.
name|m_len
operator|=
sizeof|sizeof
name|eh
expr_stmt|;
name|m0
operator|.
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|eh
expr_stmt|;
name|m0
operator|.
name|m_next
operator|=
name|m
expr_stmt|;
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
operator|&
name|m0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*      * If hw is in promiscuous mode (note that I said hardware, not if      * IFF_PROMISC is set in ifnet flags), then if this is a unicast      * packet and the MAC dst is not us, drop it.  This check was formerly      * inside the bpf if, above, but IFF_MULTI causes hw promisc without      * a bpf listener, so this is wrong.      *		Greg Troxel<gdt@ir.bbn.com>, 1998-08-07      */
comment|/*      * TBD: also discard packets where NWID does not match.      * However, there does not appear to be a way to read the nwid      * for a received packet.  -gdt 1998-08-07      */
if|if
condition|(
ifdef|#
directive|ifdef
name|WL_USE_IFNET_PROMISC_CHECK
comment|/* not defined */
operator|(
name|sc
operator|->
name|wl_ac
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
else|#
directive|else
comment|/* hw is in promisc mode if this is true */
operator|(
name|sc
operator|->
name|mode
operator|&
operator|(
name|MOD_PROM
operator||
name|MOD_ENAL
operator|)
operator|)
endif|#
directive|endif
operator|&&
operator|(
name|eh
operator|.
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
comment|/* !mcast and !bcast */
name|bcmp
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|,
name|sc
operator|->
name|wl_ac
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d: wlrecv %d bytes\n"
argument_list|,
name|unit
argument_list|,
name|clen
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WLCACHE
name|wl_cache_store
argument_list|(
name|unit
argument_list|,
name|base
argument_list|,
operator|&
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * received packet is now in a chain of mbuf's.  next step is      * to pass the packet upwards.      *      */
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|wl_if
argument_list|,
operator|&
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*  * wlioctl:  *  *	This routine processes an ioctl request from the "if" layer  *	above.  *  * input	: pointer the appropriate "if" struct, command, and data  * output	: based on command appropriate action is taken on the  *	 	  WaveLAN board(s) or related structures  * return	: error is returned containing exit conditions  *  */
specifier|static
name|int
name|wlioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|unit
init|=
name|ifp
operator|->
name|if_unit
decl_stmt|;
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|short
name|mode
init|=
literal|0
decl_stmt|;
name|int
name|opri
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|int
name|irq
decl_stmt|,
name|irqval
decl_stmt|,
name|i
decl_stmt|,
name|isroot
decl_stmt|,
name|size
decl_stmt|;
name|caddr_t
name|up
decl_stmt|;
name|char
modifier|*
name|cpt
decl_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d: entered wlioctl()\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|opri
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
comment|/* Set own IP address and enable interface */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|wlinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|arp_ifinit
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|ds
operator|->
name|wl_addr
operator|)
expr_stmt|;
else|else
name|wlsetaddr
argument_list|(
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|wlinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|wlinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|mode
operator||=
name|MOD_ENAL
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|mode
operator||=
name|MOD_PROM
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
condition|)
block|{
name|mode
operator||=
name|MOD_PROM
expr_stmt|;
block|}
comment|/* 	 * force a complete reset if the recieve multicast/ 	 * promiscuous mode changes so that these take  	 * effect immediately. 	 * 	 */
if|if
condition|(
name|sc
operator|->
name|mode
operator|!=
name|mode
condition|)
block|{
name|sc
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|DSF_RUNNING
condition|)
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|DSF_RUNNING
expr_stmt|;
name|wlinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if interface is marked DOWN and still running then 	 * stop it. 	 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|sc
operator|->
name|flags
operator|&
name|DSF_RUNNING
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d ioctl(): board is not running\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|DSF_RUNNING
expr_stmt|;
name|sc
operator|->
name|hacr
operator|&=
operator|~
name|HACR_INTRON
expr_stmt|;
name|CMD
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* turn off interrupts */
block|}
comment|/* else if interface is UP and RUNNING, start it 		*/
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|sc
operator|->
name|flags
operator|&
name|DSF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|wlinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* if WLDEBUG set on interface, then printf rf-modem regs 	*/
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|wlmmcstat
argument_list|(
name|unit
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|MULTICAST
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|<
literal|300000
if|if
condition|(
name|cmd
operator|==
name|SIOCADDMULTI
condition|)
block|{
name|error
operator|=
name|ether_addmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|wl_ac
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ether_delmulti
argument_list|(
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|wl_ac
argument_list|)
expr_stmt|;
block|}
comment|/* see if we should be in all multicast mode 	 * note that 82586 cannot do that, must simulate with 	 * promiscuous mode 	 */
if|if
condition|(
name|check_allmulti
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
name|sc
operator|->
name|mode
operator||=
name|MOD_ENAL
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|DSF_RUNNING
expr_stmt|;
name|wlinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|DSF_RUNNING
condition|)
block|{
name|sc
operator|->
name|flags
operator|&=
operator|~
name|DSF_RUNNING
expr_stmt|;
name|wlinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|wlinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
comment|/* MULTICAST */
comment|/* DEVICE SPECIFIC */
comment|/* copy the PSA out to the caller */
case|case
name|SIOCGWLPSA
case|:
comment|/* pointer to buffer in user space */
name|up
operator|=
operator|(
name|void
operator|*
operator|)
name|ifr
operator|->
name|ifr_data
expr_stmt|;
comment|/* work out if they're root */
name|isroot
operator|=
operator|(
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x40
condition|;
name|i
operator|++
control|)
block|{
comment|/* don't hand the DES key out to non-root users */
if|if
condition|(
operator|(
name|i
operator|>
name|WLPSA_DESKEY
operator|)
operator|&&
operator|(
name|i
operator|<
operator|(
name|WLPSA_DESKEY
operator|+
literal|8
operator|)
operator|)
operator|&&
operator|!
name|isroot
condition|)
continue|continue;
if|if
condition|(
name|subyte
argument_list|(
operator|(
name|up
operator|+
name|i
operator|)
argument_list|,
name|sc
operator|->
name|psa
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
break|break;
comment|/* copy the PSA in from the caller; we only copy _some_ values */
case|case
name|SIOCSWLPSA
case|:
comment|/* root only */
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
break|break;
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* assume the worst */
comment|/* pointer to buffer in user space containing data */
name|up
operator|=
operator|(
name|void
operator|*
operator|)
name|ifr
operator|->
name|ifr_data
expr_stmt|;
comment|/* check validity of input range */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x40
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fubyte
argument_list|(
name|up
operator|+
name|i
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* check IRQ value */
name|irqval
operator|=
name|fubyte
argument_list|(
name|up
operator|+
name|WLPSA_IRQNO
argument_list|)
expr_stmt|;
for|for
control|(
name|irq
operator|=
literal|15
init|;
name|irq
operator|>=
literal|0
condition|;
name|irq
operator|--
control|)
if|if
condition|(
name|irqvals
index|[
name|irq
index|]
operator|==
name|irqval
condition|)
break|break;
if|if
condition|(
name|irq
operator|==
literal|0
condition|)
comment|/* oops */
break|break;
comment|/* new IRQ */
name|sc
operator|->
name|psa
index|[
name|WLPSA_IRQNO
index|]
operator|=
name|irqval
expr_stmt|;
comment|/* local MAC */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|psa
index|[
name|WLPSA_LOCALMAC
operator|+
name|i
index|]
operator|=
name|fubyte
argument_list|(
name|up
operator|+
name|WLPSA_LOCALMAC
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* MAC select */
name|sc
operator|->
name|psa
index|[
name|WLPSA_MACSEL
index|]
operator|=
name|fubyte
argument_list|(
name|up
operator|+
name|WLPSA_MACSEL
argument_list|)
expr_stmt|;
comment|/* default nwid */
name|sc
operator|->
name|psa
index|[
name|WLPSA_NWID
index|]
operator|=
name|fubyte
argument_list|(
name|up
operator|+
name|WLPSA_NWID
argument_list|)
expr_stmt|;
name|sc
operator|->
name|psa
index|[
name|WLPSA_NWID
operator|+
literal|1
index|]
operator|=
name|fubyte
argument_list|(
name|up
operator|+
name|WLPSA_NWID
operator|+
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|wlsetpsa
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* update the PSA */
break|break;
comment|/* get the current NWID out of the sc since we stored it there */
case|case
name|SIOCGWLCNWID
case|:
name|ifr
operator|->
name|ifr_data
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|sc
operator|->
name|nwid
index|[
literal|0
index|]
operator|<<
literal|8
operator||
name|sc
operator|->
name|nwid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * change the nwid dynamically.  This 	 * ONLY changes the radio modem and does not 	 * change the PSA. 	 * 	 * 2 steps: 	 *	1. save in softc "soft registers" 	 *	2. save in radio modem (MMC) 	 */
case|case
name|SIOCSWLCNWID
case|:
comment|/* root only */
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* only allowed while up */
block|}
else|else
block|{
comment|/*  	     * soft c nwid shadows radio modem setting 	     */
name|sc
operator|->
name|nwid
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|ifr
operator|->
name|ifr_data
operator|>>
literal|8
expr_stmt|;
name|sc
operator|->
name|nwid
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|)
name|ifr
operator|->
name|ifr_data
operator|&
literal|0xff
expr_stmt|;
name|MMC_WRITE
argument_list|(
name|MMC_NETW_ID_L
argument_list|,
name|sc
operator|->
name|nwid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|MMC_WRITE
argument_list|(
name|MMC_NETW_ID_H
argument_list|,
name|sc
operator|->
name|nwid
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* copy the EEPROM in 2.4 Gz WaveMODEM  out to the caller */
case|case
name|SIOCGWLEEPROM
case|:
comment|/* root only */
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
break|break;
comment|/* pointer to buffer in user space */
name|up
operator|=
operator|(
name|void
operator|*
operator|)
name|ifr
operator|->
name|ifr_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x00
init|;
name|i
operator|<
literal|0x80
condition|;
operator|++
name|i
control|)
block|{
comment|/* 2.4 Gz: size of EEPROM   */
name|MMC_WRITE
argument_list|(
name|MMC_EEADDR
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz: get frequency    */
name|MMC_WRITE
argument_list|(
name|MMC_EECTRL
argument_list|,
comment|/* 2.4 Gz: EEPROM read	    */
name|MMC_EECTRL_EEOP_READ
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz:		    */
name|DELAY
argument_list|(
literal|40
argument_list|)
expr_stmt|;
comment|/* 2.4 Gz		    */
if|if
condition|(
name|subyte
argument_list|(
name|up
operator|+
literal|2
operator|*
name|i
argument_list|,
comment|/* 2.4 Gz: pass low byte of */
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_EEDATALrv
argument_list|)
argument_list|)
comment|/* 2.4 Gz: EEPROM word      */
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 2.4 Gz:		    */
if|if
condition|(
name|subyte
argument_list|(
name|up
operator|+
literal|2
operator|*
name|i
operator|+
literal|1
argument_list|,
comment|/* 2.4 Gz: pass hi byte of  */
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_EEDATALrv
argument_list|)
argument_list|)
comment|/* 2.4 Gz: EEPROM word      */
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 2.4 Gz:		    */
block|}
break|break;
ifdef|#
directive|ifdef
name|WLCACHE
comment|/* zero (Delete) the wl cache */
case|case
name|SIOCDWLCACHE
case|:
comment|/* root only */
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
break|break;
name|wl_cache_zero
argument_list|(
name|unit
argument_list|)
expr_stmt|;
break|break;
comment|/* read out the number of used cache elements */
case|case
name|SIOCGWLCITEM
case|:
name|ifr
operator|->
name|ifr_data
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|w_sigitems
expr_stmt|;
break|break;
comment|/* read out the wl cache */
case|case
name|SIOCGWLCACHE
case|:
comment|/* pointer to buffer in user space */
name|up
operator|=
operator|(
name|void
operator|*
operator|)
name|ifr
operator|->
name|ifr_data
expr_stmt|;
name|cpt
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|w_sigcache
index|[
literal|0
index|]
expr_stmt|;
name|size
operator|=
name|sc
operator|->
name|w_sigitems
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|w_sigcache
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|subyte
argument_list|(
operator|(
name|up
operator|+
name|i
operator|)
argument_list|,
operator|*
name|cpt
operator|++
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * wlwatchdog():  *  * Called if the timer set in wlstart expires before an interrupt is received  * from the wavelan.   It seems to lose interrupts sometimes.  * The watchdog routine gets called if the transmitter failed to interrupt  *  * input	: which board is timing out  * output	: board reset   *  */
specifier|static
name|void
name|wlwatchdog
parameter_list|(
name|void
modifier|*
name|vsc
parameter_list|)
block|{
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|vsc
decl_stmt|;
name|int
name|unit
init|=
name|sc
operator|->
name|unit
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"wl%d: wavelan device timeout on xmit\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wl_ac
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|wlinit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/*  * wlintr:  *  *	This function is the interrupt handler for the WaveLAN  *	board.  This routine will be called whenever either a packet  *	is received, or a packet has successfully been transfered and  *	the unit is ready to transmit another packet.  *  * input	: board number that interrupted  * output	: either a packet is received, or a packet is transfered  *  */
specifier|static
name|void
name|wlintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
operator|&
name|wl_softc
index|[
name|unit
index|]
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|int
name|ac_status
decl_stmt|;
name|u_short
name|int_type
decl_stmt|,
name|int_type1
decl_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d: wlintr() called\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|int_type
operator|=
name|inw
argument_list|(
name|HASR
argument_list|(
name|base
argument_list|)
argument_list|)
operator|)
operator|&
name|HASR_MMC_INTR
condition|)
block|{
comment|/* handle interrupt from the modem management controler */
comment|/* This will clear the interrupt condition */
operator|(
name|void
operator|)
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_DCE_STATUS
argument_list|)
expr_stmt|;
comment|/* ignored for now */
block|}
if|if
condition|(
operator|!
operator|(
name|int_type
operator|&
name|HASR_INTR
operator|)
condition|)
block|{
comment|/* return if no interrupt from 82586 */
comment|/* commented out. jrb.  it happens when reinit occurs 	   printf("wlintr: int_type %x, dump follows\n", int_type); 	   wldump(unit); 	   */
return|return;
block|}
if|if
condition|(
name|gathersnr
condition|)
name|getsnr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
operator|+
literal|0
argument_list|)
expr_stmt|;
comment|/* get scb status */
name|int_type
operator|=
operator|(
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&
name|SCB_SW_INT
operator|)
expr_stmt|;
if|if
condition|(
name|int_type
operator|==
literal|0
condition|)
comment|/* no interrupts left */
break|break;
name|int_type1
operator|=
name|wlack
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* acknowledge interrupt(s) */
comment|/* make sure no bits disappeared (others may appear) */
if|if
condition|(
operator|(
name|int_type
operator|&
name|int_type1
operator|)
operator|!=
name|int_type
condition|)
name|printf
argument_list|(
literal|"wlack() int bits disappeared : %04x != int_type %04x\n"
argument_list|,
name|int_type1
argument_list|,
name|int_type
argument_list|)
expr_stmt|;
name|int_type
operator|=
name|int_type1
expr_stmt|;
comment|/* go with the new status */
comment|/*  	 * incoming packet 	 */
if|if
condition|(
name|int_type
operator|&
name|SCB_SW_FR
condition|)
block|{
name|sc
operator|->
name|wl_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|wlrcv
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * receiver not ready 	 */
if|if
condition|(
name|int_type
operator|&
name|SCB_SW_RNR
condition|)
block|{
name|sc
operator|->
name|wl_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d intr(): receiver overrun! begin_fd = %x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|begin_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wlrustrt
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * CU not ready 	 */
if|if
condition|(
name|int_type
operator|&
name|SCB_SW_CNA
condition|)
block|{
comment|/* 	     * At present, we don't care about CNA's.  We 	     * believe they are a side effect of XMT. 	     */
block|}
if|if
condition|(
name|int_type
operator|&
name|SCB_SW_CX
condition|)
block|{
comment|/* 	     * At present, we only request Interrupt for 	     * XMT. 	     */
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
argument_list|)
expr_stmt|;
comment|/* get command status */
name|ac_status
operator|=
name|inw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmt_watch
condition|)
block|{
comment|/* report some anomalies */
if|if
condition|(
name|sc
operator|->
name|tbusy
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d: xmt intr but not busy, CU %04x\n"
argument_list|,
name|unit
argument_list|,
name|ac_status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ac_status
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d: xmt intr but ac_status == 0\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ac_status
operator|&
name|AC_SW_A
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d: xmt aborted\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|ac_status
operator|&
name|TC_CARRIER
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d: no carrier\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* notdef */
if|if
condition|(
name|ac_status
operator|&
name|TC_CLS
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d: no CTS\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ac_status
operator|&
name|TC_DMA
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d: DMA underrun\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ac_status
operator|&
name|TC_DEFER
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d: xmt deferred\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ac_status
operator|&
name|TC_SQE
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d: heart beat\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ac_status
operator|&
name|TC_COLLISION
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d: too many collisions\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if the transmit actually failed, or returned some status */
if|if
condition|(
operator|(
operator|!
operator|(
name|ac_status
operator|&
name|AC_SW_OK
operator|)
operator|)
operator|||
operator|(
name|ac_status
operator|&
literal|0xfff
operator|)
condition|)
block|{
if|if
condition|(
name|ac_status
operator|&
operator|(
name|TC_COLLISION
operator||
name|TC_CLS
operator||
name|TC_DMA
operator|)
condition|)
block|{
name|sc
operator|->
name|wl_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
comment|/* count collisions */
name|sc
operator|->
name|wl_if
operator|.
name|if_collisions
operator|+=
operator|(
name|ac_status
operator|&
literal|0xf
operator|)
expr_stmt|;
comment|/* if TC_COLLISION set and collision count zero, 16 collisions */
if|if
condition|(
operator|(
name|ac_status
operator|&
literal|0x20
operator|)
operator|==
literal|0x20
condition|)
block|{
name|sc
operator|->
name|wl_if
operator|.
name|if_collisions
operator|+=
literal|0x10
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|tbusy
operator|=
literal|0
expr_stmt|;
name|untimeout
argument_list|(
name|wlwatchdog
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|watchdog_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wl_ac
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|wlstart
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|wl_if
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
comment|/*  * wlrcv:  *  *	This routine is called by the interrupt handler to initiate a  *	packet transfer from the board to the "if" layer above this  *	driver.  This routine checks if a buffer has been successfully  *	received by the WaveLAN.  If so, the routine wlread is called  *	to do the actual transfer of the board data (including the  *	ethernet header) into a packet (consisting of an mbuf chain).  *  * input	: number of the board to check  * output	: if a packet is available, it is "sent up"  *  */
specifier|static
name|void
name|wlrcv
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|u_short
name|fd_p
decl_stmt|,
name|status
decl_stmt|,
name|offset
decl_stmt|,
name|link_offset
decl_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d: entered wlrcv()\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|fd_p
operator|=
name|sc
operator|->
name|begin_fd
init|;
name|fd_p
operator|!=
name|I82586NULL
condition|;
name|fd_p
operator|=
name|sc
operator|->
name|begin_fd
control|)
block|{
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|fd_p
operator|+
literal|0
argument_list|)
expr_stmt|;
comment|/* address of status */
name|status
operator|=
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|fd_p
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* address of link_offset */
name|link_offset
operator|=
name|inw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|inw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* rbd_offset */
if|if
condition|(
name|status
operator|==
literal|0xffff
operator|||
name|offset
operator|==
literal|0xffff
comment|/*I82586NULL*/
condition|)
block|{
if|if
condition|(
name|wlhwrst
argument_list|(
name|unit
argument_list|)
operator|!=
name|TRUE
condition|)
name|printf
argument_list|(
literal|"wl%d rcv(): hwrst ffff trouble.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|AC_SW_C
condition|)
block|{
if|if
condition|(
name|status
operator|==
operator|(
name|RFD_DONE
operator||
name|RFD_RSC
operator|)
condition|)
block|{
comment|/* lost one */
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d RCV: RSC %x\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|wl_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|RFD_OK
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d RCV: !OK %x\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wl_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
literal|0xfff
condition|)
block|{
comment|/* can't happen */
name|printf
argument_list|(
literal|"wl%d RCV: ERRs %x\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wl_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|wlread
argument_list|(
name|unit
argument_list|,
name|fd_p
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|wlrequeue
argument_list|(
name|unit
argument_list|,
name|fd_p
argument_list|)
condition|)
block|{
comment|/* abort on chain error */
if|if
condition|(
name|wlhwrst
argument_list|(
name|unit
argument_list|)
operator|!=
name|TRUE
condition|)
name|printf
argument_list|(
literal|"wl%d rcv(): hwrst trouble.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|begin_fd
operator|=
name|link_offset
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
return|return;
block|}
comment|/*  * wlrequeue:  *  *	This routine puts rbd's used in the last receive back onto the  *	free list for the next receive.  *  */
specifier|static
name|int
name|wlrequeue
parameter_list|(
name|int
name|unit
parameter_list|,
name|u_short
name|fd_p
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|fd_t
name|fd
decl_stmt|;
name|u_short
name|l_rbdp
decl_stmt|,
name|f_rbdp
decl_stmt|,
name|rbd_offset
decl_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|fd_p
operator|+
literal|6
argument_list|)
expr_stmt|;
name|rbd_offset
operator|=
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|f_rbdp
operator|=
name|rbd_offset
operator|)
operator|!=
name|I82586NULL
condition|)
block|{
name|l_rbdp
operator|=
name|f_rbdp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|l_rbdp
operator|+
literal|0
argument_list|)
expr_stmt|;
comment|/* address of status */
if|if
condition|(
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&
name|RBD_SW_EOF
condition|)
break|break;
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|l_rbdp
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* next_rbd_offset */
if|if
condition|(
operator|(
name|l_rbdp
operator|=
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|)
operator|==
name|I82586NULL
condition|)
break|break;
block|}
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|l_rbdp
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* next_rbd_offset */
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|I82586NULL
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|l_rbdp
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* address of size */
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator||
name|AC_CW_EL
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|sc
operator|->
name|end_rbd
operator|+
literal|2
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|f_rbdp
argument_list|)
expr_stmt|;
comment|/* end_rbd->next_rbd_offset */
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|sc
operator|->
name|end_rbd
operator|+
literal|8
argument_list|)
expr_stmt|;
comment|/* size */
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&
operator|~
name|AC_CW_EL
argument_list|)
expr_stmt|;
name|sc
operator|->
name|end_rbd
operator|=
name|l_rbdp
expr_stmt|;
block|}
name|fd
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|fd
operator|.
name|command
operator|=
name|AC_CW_EL
expr_stmt|;
name|fd
operator|.
name|link_offset
operator|=
name|I82586NULL
expr_stmt|;
name|fd
operator|.
name|rbd_offset
operator|=
name|I82586NULL
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|fd_p
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|fd
argument_list|,
literal|8
operator|/
literal|2
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|sc
operator|->
name|end_fd
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* addr of command */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* command = 0 */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|fd_p
argument_list|)
expr_stmt|;
comment|/* end_fd->link_offset = fd_p */
name|sc
operator|->
name|end_fd
operator|=
name|fd_p
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|WLDEBUG
specifier|static
name|int
name|xmt_debug
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* WLDEBUG */
comment|/*  * wlxmt:  *  *	This routine fills in the appropriate registers and memory  *	locations on the WaveLAN board and starts the board off on  *	the transmit.  *  * input	: board number of interest, and a pointer to the mbuf  * output	: board memory and registers are set for xfer and attention  *  */
specifier|static
name|void
name|wlxmt
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
specifier|register
name|u_short
name|xmtdata_p
init|=
name|OFFSET_TBUF
decl_stmt|;
specifier|register
name|u_short
name|xmtshort_p
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|tm_p
init|=
name|m
decl_stmt|;
specifier|register
name|struct
name|ether_header
modifier|*
name|eh_p
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
decl_stmt|;
name|u_char
modifier|*
name|mb_p
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
decl_stmt|;
name|u_short
name|count
init|=
name|m
operator|->
name|m_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
decl_stmt|;
name|ac_t
name|cb
decl_stmt|;
name|u_short
name|tbd_p
init|=
name|OFFSET_TBD
decl_stmt|;
name|u_short
name|len
decl_stmt|,
name|clen
init|=
literal|0
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|int
name|spin
decl_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d: entered wlxmt()\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cb
operator|.
name|ac_status
operator|=
literal|0
expr_stmt|;
name|cb
operator|.
name|ac_command
operator|=
operator|(
name|AC_CW_EL
operator||
name|AC_TRANSMIT
operator||
name|AC_CW_I
operator|)
expr_stmt|;
name|cb
operator|.
name|ac_link_offset
operator|=
name|I82586NULL
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|cb
argument_list|,
literal|6
operator|/
literal|2
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_TBD
argument_list|)
expr_stmt|;
comment|/* cb.cmd.transmit.tbd_offset */
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|eh_p
operator|->
name|ether_dhost
argument_list|,
name|WAVELAN_ADDR_SIZE
operator|/
literal|2
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|eh_p
operator|->
name|ether_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
if|if
condition|(
name|xmt_debug
condition|)
block|{
name|printf
argument_list|(
literal|"XMT    mbuf: L%d @%p "
argument_list|,
name|count
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mb_p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ether type %x\n"
argument_list|,
name|eh_p
operator|->
name|ether_type
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* WLDEBUG */
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_TBD
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* act_count */
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_TBD
operator|+
literal|4
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|xmtdata_p
argument_list|)
expr_stmt|;
comment|/* buffer_addr */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* buffer_base */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|clen
operator|+
name|count
operator|>
name|WAVELAN_MTU
condition|)
break|break;
if|if
condition|(
name|count
operator|&
literal|1
condition|)
name|len
operator|=
name|count
operator|+
literal|1
expr_stmt|;
else|else
name|len
operator|=
name|count
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|xmtdata_p
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|mb_p
argument_list|,
name|len
operator|/
literal|2
argument_list|)
expr_stmt|;
name|clen
operator|+=
name|count
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|tbd_p
argument_list|)
expr_stmt|;
comment|/* address of act_count */
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|+
name|count
argument_list|)
expr_stmt|;
name|xmtdata_p
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|tm_p
operator|=
name|tm_p
operator|->
name|m_next
operator|)
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
break|break;
if|if
condition|(
name|count
operator|&
literal|1
condition|)
block|{
comment|/* go to the next descriptor */
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|tbd_p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|tbd_p
operator|+=
sizeof|sizeof
argument_list|(
name|tbd_t
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|tbd_p
argument_list|)
expr_stmt|;
comment|/* next_tbd_offset */
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|tbd_p
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* act_count */
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|tbd_p
operator|+
literal|4
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|xmtdata_p
argument_list|)
expr_stmt|;
comment|/* buffer_addr */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* buffer_base */
comment|/* at the end -> coallesce remaining mbufs */
if|if
condition|(
name|tbd_p
operator|==
name|OFFSET_TBD
operator|+
operator|(
name|N_TBD
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tbd_t
argument_list|)
condition|)
block|{
name|wlsftwsleaze
argument_list|(
operator|&
name|count
argument_list|,
operator|&
name|mb_p
argument_list|,
operator|&
name|tm_p
argument_list|,
name|unit
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* next mbuf short -> coallesce as needed */
if|if
condition|(
operator|(
name|tm_p
operator|->
name|m_next
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
operator|)
operator|||
define|#
directive|define
name|HDW_THRESHOLD
value|55
name|tm_p
operator|->
name|m_len
operator|>
name|HDW_THRESHOLD
condition|)
comment|/* ok */
empty_stmt|;
else|else
block|{
name|wlhdwsleaze
argument_list|(
operator|&
name|count
argument_list|,
operator|&
name|mb_p
argument_list|,
operator|&
name|tm_p
argument_list|,
name|unit
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|tm_p
operator|=
name|tm_p
operator|->
name|m_next
operator|)
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
break|break;
name|count
operator|=
name|tm_p
operator|->
name|m_len
expr_stmt|;
name|mb_p
operator|=
name|mtod
argument_list|(
name|tm_p
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
if|if
condition|(
name|xmt_debug
condition|)
name|printf
argument_list|(
literal|"mbuf+ L%d @%p "
argument_list|,
name|count
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mb_p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WLDEBUG */
block|}
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
if|if
condition|(
name|xmt_debug
condition|)
name|printf
argument_list|(
literal|"CLEN = %d\n"
argument_list|,
name|clen
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WLDEBUG */
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|tbd_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|<
name|ETHERMIN
condition|)
block|{
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|+
name|ETHERMIN
operator|-
name|clen
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|xmtdata_p
argument_list|)
expr_stmt|;
for|for
control|(
name|xmtshort_p
operator|=
name|xmtdata_p
init|;
name|clen
operator|<
name|ETHERMIN
condition|;
name|clen
operator|+=
literal|2
control|)
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator||
name|TBD_SW_EOF
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|tbd_p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|I82586NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
if|if
condition|(
name|xmt_debug
condition|)
block|{
name|wltbd
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* WLDEBUG */
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* address of scb_command */
comment|/*       * wait for 586 to clear previous command, complain if it takes      * too long      */
for|for
control|(
name|spin
operator|=
literal|1
init|;
condition|;
name|spin
operator|=
operator|(
name|spin
operator|+
literal|1
operator|)
operator|%
literal|10000
control|)
block|{
if|if
condition|(
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* it's done, we can go */
break|break;
block|}
if|if
condition|(
operator|(
name|spin
operator|==
literal|0
operator|)
operator|&&
name|xmt_watch
condition|)
block|{
comment|/* not waking up, and we care */
name|printf
argument_list|(
literal|"wl%d: slow accepting xmit\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|SCB_CU_STRT
argument_list|)
expr_stmt|;
comment|/* new command */
name|SET_CHAN_ATTN
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* XXX       * Pause to avoid transmit overrun problems.      * The required delay tends to vary with platform type, and may be      * related to interrupt loss.      */
if|if
condition|(
name|wl_xmit_delay
condition|)
block|{
name|DELAY
argument_list|(
name|wl_xmit_delay
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/*  * wlbldru:  *  *	This function builds the linear linked lists of fd's and  *	rbd's.  Based on page 4-32 of 1986 Intel microcom handbook.  *  */
specifier|static
name|u_short
name|wlbldru
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|fd_t
name|fd
decl_stmt|;
name|rbd_t
name|rbd
decl_stmt|;
name|u_short
name|fd_p
init|=
name|OFFSET_RU
decl_stmt|;
name|u_short
name|rbd_p
init|=
name|OFFSET_RBD
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|begin_fd
operator|=
name|fd_p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_FD
condition|;
name|i
operator|++
control|)
block|{
name|fd
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|fd
operator|.
name|command
operator|=
literal|0
expr_stmt|;
name|fd
operator|.
name|link_offset
operator|=
name|fd_p
operator|+
sizeof|sizeof
argument_list|(
name|fd_t
argument_list|)
expr_stmt|;
name|fd
operator|.
name|rbd_offset
operator|=
name|I82586NULL
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|fd_p
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|fd
argument_list|,
literal|8
operator|/
literal|2
argument_list|)
expr_stmt|;
name|fd_p
operator|=
name|fd
operator|.
name|link_offset
expr_stmt|;
block|}
name|fd_p
operator|-=
sizeof|sizeof
argument_list|(
name|fd_t
argument_list|)
expr_stmt|;
name|sc
operator|->
name|end_fd
operator|=
name|fd_p
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|fd_p
operator|+
literal|2
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|AC_CW_EL
argument_list|)
expr_stmt|;
comment|/* command */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|I82586NULL
argument_list|)
expr_stmt|;
comment|/* link_offset */
name|fd_p
operator|=
name|OFFSET_RU
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|fd_p
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* address of rbd_offset */
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|rbd_p
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|rbd_p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N_RBD
condition|;
name|i
operator|++
control|)
block|{
name|rbd
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|rbd
operator|.
name|buffer_addr
operator|=
name|rbd_p
operator|+
sizeof|sizeof
argument_list|(
name|rbd_t
argument_list|)
operator|+
literal|2
expr_stmt|;
name|rbd
operator|.
name|buffer_base
operator|=
literal|0
expr_stmt|;
name|rbd
operator|.
name|size
operator|=
name|RCVBUFSIZE
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|N_RBD
operator|-
literal|1
condition|)
block|{
name|rbd_p
operator|+=
sizeof|sizeof
argument_list|(
name|ru_t
argument_list|)
expr_stmt|;
name|rbd
operator|.
name|next_rbd_offset
operator|=
name|rbd_p
expr_stmt|;
block|}
else|else
block|{
name|rbd
operator|.
name|next_rbd_offset
operator|=
name|I82586NULL
expr_stmt|;
name|rbd
operator|.
name|size
operator||=
name|AC_CW_EL
expr_stmt|;
name|sc
operator|->
name|end_rbd
operator|=
name|rbd_p
expr_stmt|;
block|}
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|rbd
argument_list|,
sizeof|sizeof
argument_list|(
name|rbd_t
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|rbd_p
argument_list|)
expr_stmt|;
block|}
return|return
name|sc
operator|->
name|begin_fd
return|;
block|}
comment|/*  * wlrustrt:  *  *	This routine starts the receive unit running.  First checks if the  *	board is actually ready, then the board is instructed to receive  *	packets again.  *  */
specifier|static
name|void
name|wlrustrt
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|u_short
name|rfa
decl_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d: entered wlrustrt()\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
argument_list|)
expr_stmt|;
if|if
condition|(
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&
name|SCB_RUS_READY
condition|)
block|{
name|printf
argument_list|(
literal|"wlrustrt: RUS_READY\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
operator|+
literal|2
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|SCB_RU_STRT
argument_list|)
expr_stmt|;
comment|/* command */
name|rfa
operator|=
name|wlbldru
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* address of scb_rfa_offset */
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|rfa
argument_list|)
expr_stmt|;
name|SET_CHAN_ATTN
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * wldiag:  *  *	This routine does a 586 op-code number 7, and obtains the  *	diagnose status for the WaveLAN.  *  */
specifier|static
name|int
name|wldiag
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|short
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d: entered wldiag()\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
argument_list|)
expr_stmt|;
name|status
operator|=
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|SCB_SW_INT
condition|)
block|{
comment|/* state is 2000 which seems ok 		   printf("wl%d diag(): unexpected initial state %\n", 		   unit, inw(PIOP0(base))); 		*/
name|wlack
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ac_status */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|AC_DIAGNOSE
operator||
name|AC_CW_EL
argument_list|)
expr_stmt|;
comment|/* ac_command */
if|if
condition|(
name|wlcmd
argument_list|(
name|unit
argument_list|,
literal|"diag()"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
argument_list|)
expr_stmt|;
if|if
condition|(
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&
literal|0x0800
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d: i82586 Self Test failed!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|TRUE
return|;
block|}
comment|/*  * wlconfig:  *  *	This routine does a standard config of the WaveLAN board.  *  */
specifier|static
name|int
name|wlconfig
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|configure_t
name|configure
decl_stmt|;
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
if|#
directive|if
name|MULTICAST
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|300000
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|u_char
modifier|*
name|addrp
decl_stmt|;
else|#
directive|else
name|struct
name|ether_multi
modifier|*
name|enm
decl_stmt|;
name|struct
name|ether_multistep
name|step
decl_stmt|;
endif|#
directive|endif
name|int
name|cnt
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* MULTICAST */
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d: entered wlconfig()\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
argument_list|)
expr_stmt|;
if|if
condition|(
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&
name|SCB_SW_INT
condition|)
block|{
comment|/* 	  printf("wl%d config(): unexpected initial state %x\n", 	  unit, inw(PIOP0(base))); 	  */
block|}
name|wlack
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ac_status */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|AC_CONFIGURE
operator||
name|AC_CW_EL
argument_list|)
expr_stmt|;
comment|/* ac_command */
comment|/* jrb hack */
name|configure
operator|.
name|fifolim_bytecnt
operator|=
literal|0x080c
expr_stmt|;
name|configure
operator|.
name|addrlen_mode
operator|=
literal|0x0600
expr_stmt|;
name|configure
operator|.
name|linprio_interframe
operator|=
literal|0x2060
expr_stmt|;
name|configure
operator|.
name|slot_time
operator|=
literal|0xf200
expr_stmt|;
name|configure
operator|.
name|hardware
operator|=
literal|0x0008
expr_stmt|;
comment|/* tx even w/o CD */
name|configure
operator|.
name|min_frame_len
operator|=
literal|0x0040
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This is the configuration block suggested by Marc Meertens      *<mmeerten@obelix.utrecht.NCR.COM> in an e-mail message to John      * Ioannidis on 10 Nov 92.      */
block|configure.fifolim_bytecnt 	= 0x040c;     configure.addrlen_mode  	= 0x0600;     configure.linprio_interframe	= 0x2060;     configure.slot_time      	= 0xf000;     configure.hardware	     	= 0x0008;
comment|/* tx even w/o CD */
block|configure.min_frame_len   	= 0x0040;
else|#
directive|else
comment|/*      * below is the default board configuration from p2-28 from 586 book      */
name|configure
operator|.
name|fifolim_bytecnt
operator|=
literal|0x080c
expr_stmt|;
name|configure
operator|.
name|addrlen_mode
operator|=
literal|0x2600
expr_stmt|;
name|configure
operator|.
name|linprio_interframe
operator|=
literal|0x7820
expr_stmt|;
comment|/* IFS=120, ACS=2 */
name|configure
operator|.
name|slot_time
operator|=
literal|0xf00c
expr_stmt|;
comment|/* slottime=12    */
name|configure
operator|.
name|hardware
operator|=
literal|0x0008
expr_stmt|;
comment|/* tx even w/o CD */
name|configure
operator|.
name|min_frame_len
operator|=
literal|0x0040
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|mode
operator|&
operator|(
name|MOD_PROM
operator||
name|MOD_ENAL
operator|)
condition|)
block|{
name|configure
operator|.
name|hardware
operator||=
literal|1
expr_stmt|;
block|}
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
operator|+
literal|6
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|configure
argument_list|,
sizeof|sizeof
argument_list|(
name|configure_t
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|wlcmd
argument_list|(
name|unit
argument_list|,
literal|"config()-configure"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|#
directive|if
name|MULTICAST
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ac_status */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|AC_MCSETUP
operator||
name|AC_CW_EL
argument_list|)
expr_stmt|;
comment|/* ac_command */
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
operator|+
literal|8
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|>=
literal|300000
for|for
control|(
name|ifma
operator|=
name|sc
operator|->
name|wl_if
operator|.
name|if_multiaddrs
operator|.
name|lh_first
init|;
name|ifma
condition|;
name|ifma
operator|=
name|ifma
operator|->
name|ifma_link
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|addrp
operator|=
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|addrp
index|[
literal|0
index|]
operator|+
operator|(
name|addrp
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|addrp
index|[
literal|2
index|]
operator|+
operator|(
name|addrp
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|addrp
index|[
literal|4
index|]
operator|+
operator|(
name|addrp
index|[
literal|5
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
else|#
directive|else
name|ETHER_FIRST_MULTI
argument_list|(
name|step
argument_list|,
operator|&
name|sc
operator|->
name|wl_ac
argument_list|,
name|enm
argument_list|)
expr_stmt|;
while|while
condition|(
name|enm
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|;
comment|/* break if setting a multicast range, else we would crash */
if|if
condition|(
name|bcmp
argument_list|(
name|enm
operator|->
name|enm_addrlo
argument_list|,
name|enm
operator|->
name|enm_addrhi
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
name|lo
operator|=
operator|(
name|enm
operator|->
name|enm_addrlo
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|enm
operator|->
name|enm_addrlo
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|enm
operator|->
name|enm_addrlo
index|[
literal|5
index|]
expr_stmt|;
name|hi
operator|=
operator|(
name|enm
operator|->
name|enm_addrhi
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator|+
operator|(
name|enm
operator|->
name|enm_addrhi
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|enm
operator|->
name|enm_addrhi
index|[
literal|5
index|]
expr_stmt|;
while|while
condition|(
name|lo
operator|<=
name|hi
condition|)
block|{
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|0
index|]
operator|+
operator|(
name|enm
operator|->
name|enm_addrlo
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|2
index|]
operator|+
operator|(
operator|(
name|lo
operator|>>
literal|8
operator|)
operator|&
literal|0xff00
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|(
operator|(
name|lo
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|lo
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
argument_list|)
expr_stmt|;
comment|/* #define MCASTDEBUG */
ifdef|#
directive|ifdef
name|MCASTDEBUG
name|printf
argument_list|(
literal|"mcast_addr[%d,%d,%d] %x %x %x %x %x %x\n"
argument_list|,
name|lo
argument_list|,
name|hi
argument_list|,
name|cnt
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|0
index|]
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|1
index|]
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|2
index|]
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|3
index|]
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|4
index|]
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|cnt
expr_stmt|;
operator|++
name|lo
expr_stmt|;
block|}
name|ETHER_NEXT_MULTI
argument_list|(
name|step
argument_list|,
name|enm
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* mc-cnt */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|cnt
operator|*
name|WAVELAN_ADDR_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|wlcmd
argument_list|(
name|unit
argument_list|,
literal|"config()-mcaddress"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* MULTICAST */
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* ac_status */
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|AC_IASETUP
operator||
name|AC_CW_EL
argument_list|)
expr_stmt|;
comment|/* ac_command */
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
operator|+
literal|6
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|sc
operator|->
name|wl_addr
argument_list|,
name|WAVELAN_ADDR_SIZE
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|wlcmd
argument_list|(
name|unit
argument_list|,
literal|"config()-address"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|wlinitmmc
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * wlcmd:  *  * Set channel attention bit and busy wait until command has  * completed. Then acknowledge the command completion.  */
specifier|static
name|int
name|wlcmd
parameter_list|(
name|int
name|unit
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|int
name|i
decl_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* address of scb_command */
name|outw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|,
name|SCB_CU_STRT
argument_list|)
expr_stmt|;
name|SET_CHAN_ATTN
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0xffff
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&
name|AC_SW_C
condition|)
break|break;
if|if
condition|(
name|i
operator|==
literal|0xffff
operator|||
operator|!
operator|(
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&
name|AC_SW_OK
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"wl%d: %s failed; status = %d, inw = %x, outw = %x\n"
argument_list|,
name|unit
argument_list|,
name|str
argument_list|,
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&
name|AC_SW_OK
argument_list|,
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|,
name|inw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"scb_status %x\n"
argument_list|,
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"scb_command %x\n"
argument_list|,
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
operator|+
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"scb_cbl %x\n"
argument_list|,
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_CU
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cu_cmd %x\n"
argument_list|,
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&
name|SCB_SW_INT
operator|)
operator|&&
operator|(
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|!=
name|SCB_SW_CNA
operator|)
condition|)
block|{
comment|/* 	  printf("wl%d %s: unexpected final state %x\n", 	  unit, str, inw(PIOP0(base))); 	  */
block|}
name|wlack
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/*  * wlack: if the 82596 wants attention because it has finished  * sending or receiving a packet, acknowledge its desire and  * return bits indicating the kind of attention. wlack() returns  * these bits so that the caller can service exactly the  * conditions that wlack() acknowledged.  */
specifier|static
name|int
name|wlack
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|register
name|u_short
name|cmd
decl_stmt|;
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cmd
operator|=
operator|(
name|inw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&
name|SCB_SW_INT
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|WLDEBUG
if|if
condition|(
name|sc
operator|->
name|wl_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"wl%d: doing a wlack()\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|SET_CHAN_ATTN
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR0
argument_list|(
name|base
argument_list|)
argument_list|,
name|OFFSET_SCB
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* address of scb_command */
for|for
control|(
name|i
operator|=
literal|1000000
init|;
name|inw
argument_list|(
name|PIOP0
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&&
operator|(
name|i
operator|--
operator|>
literal|0
operator|)
condition|;
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
literal|1
condition|)
name|printf
argument_list|(
literal|"wl%d wlack(): board not accepting command.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|)
return|;
block|}
specifier|static
name|void
name|wltbd
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|u_short
name|tbd_p
init|=
name|OFFSET_TBD
decl_stmt|;
name|tbd_t
name|tbd
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|sum
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|outw
argument_list|(
name|PIOR1
argument_list|(
name|base
argument_list|)
argument_list|,
name|tbd_p
argument_list|)
expr_stmt|;
name|insw
argument_list|(
name|PIOP1
argument_list|(
name|base
argument_list|)
argument_list|,
operator|&
name|tbd
argument_list|,
sizeof|sizeof
argument_list|(
name|tbd_t
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|tbd
operator|.
name|act_count
operator|&
operator|~
name|TBD_SW_EOF
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d: addr %x, count %d (%d), next %x, base %x\n"
argument_list|,
name|i
operator|++
argument_list|,
name|tbd
operator|.
name|buffer_addr
argument_list|,
operator|(
name|tbd
operator|.
name|act_count
operator|&
operator|~
name|TBD_SW_EOF
operator|)
argument_list|,
name|sum
argument_list|,
name|tbd
operator|.
name|next_tbd_offset
argument_list|,
name|tbd
operator|.
name|buffer_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbd
operator|.
name|act_count
operator|&
name|TBD_SW_EOF
condition|)
break|break;
name|tbd_p
operator|=
name|tbd
operator|.
name|next_tbd_offset
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|wlhdwsleaze
parameter_list|(
name|u_short
modifier|*
name|countp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|mb_pp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|tm_pp
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|tm_p
init|=
operator|*
name|tm_pp
decl_stmt|;
name|u_char
modifier|*
name|mb_p
init|=
operator|*
name|mb_pp
decl_stmt|;
name|u_short
name|count
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/*      * can we get a run that will be coallesced or      * that terminates before breaking      */
do|do
block|{
name|count
operator|+=
name|tm_p
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|tm_p
operator|->
name|m_len
operator|&
literal|1
condition|)
break|break;
block|}
do|while
condition|(
operator|(
name|tm_p
operator|=
name|tm_p
operator|->
name|m_next
operator|)
operator|!=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
do|;
if|if
condition|(
operator|(
name|tm_p
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
operator|)
operator|||
name|count
operator|>
name|HDW_THRESHOLD
condition|)
block|{
operator|*
name|countp
operator|=
operator|(
operator|*
name|tm_pp
operator|)
operator|->
name|m_len
expr_stmt|;
operator|*
name|mb_pp
operator|=
name|mtod
argument_list|(
operator|(
operator|*
name|tm_pp
operator|)
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* we need to copy */
name|tm_p
operator|=
operator|*
name|tm_pp
expr_stmt|;
name|mb_p
operator|=
operator|*
name|mb_pp
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|t_packet
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|tm_p
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|cp
argument_list|,
name|len
operator|=
name|tm_p
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|count
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|HDW_THRESHOLD
condition|)
break|break;
name|cp
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|tm_p
operator|->
name|m_next
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
break|break;
name|tm_p
operator|=
name|tm_p
operator|->
name|m_next
expr_stmt|;
block|}
operator|*
name|countp
operator|=
name|count
expr_stmt|;
operator|*
name|mb_pp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|t_packet
expr_stmt|;
operator|*
name|tm_pp
operator|=
name|tm_p
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|wlsftwsleaze
parameter_list|(
name|u_short
modifier|*
name|countp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|mb_pp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|tm_pp
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|tm_p
init|=
operator|*
name|tm_pp
decl_stmt|;
name|u_short
name|count
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|cp
init|=
operator|(
name|u_char
operator|*
operator|)
name|t_packet
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* we need to copy */
for|for
control|(
init|;
condition|;
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|tm_p
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|cp
argument_list|,
name|len
operator|=
name|tm_p
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|count
operator|+=
name|len
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|tm_p
operator|->
name|m_next
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
break|break;
name|tm_p
operator|=
name|tm_p
operator|->
name|m_next
expr_stmt|;
block|}
operator|*
name|countp
operator|=
name|count
expr_stmt|;
operator|*
name|mb_pp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|t_packet
expr_stmt|;
operator|*
name|tm_pp
operator|=
name|tm_p
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|wlmmcstat
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|u_short
name|tmp
decl_stmt|;
name|printf
argument_list|(
literal|"wl%d: DCE_STATUS: 0x%x, "
argument_list|,
name|unit
argument_list|,
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_DCE_STATUS
argument_list|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_CORRECT_NWID_H
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|tmp
operator||=
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_CORRECT_NWID_L
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Correct NWID's: %d, "
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_WRONG_NWID_H
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|tmp
operator||=
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_WRONG_NWID_L
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Wrong NWID's: %d\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"THR_PRE_SET: 0x%x, "
argument_list|,
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_THR_PRE_SET
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SIGNAL_LVL: %d, SILENCE_LVL: %d\n"
argument_list|,
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_SIGNAL_LVL
argument_list|)
argument_list|,
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_SILENCE_LVL
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SIGN_QUAL: 0x%x, NETW_ID: %x:%x, DES: %d\n"
argument_list|,
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_SIGN_QUAL
argument_list|)
argument_list|,
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_NETW_ID_H
argument_list|)
argument_list|,
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_NETW_ID_L
argument_list|)
argument_list|,
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_DES_AVAIL
argument_list|)
argument_list|)
expr_stmt|;
block|}
specifier|static
name|u_short
name|wlmmcread
parameter_list|(
name|u_int
name|base
parameter_list|,
name|u_short
name|reg
parameter_list|)
block|{
while|while
condition|(
name|inw
argument_list|(
name|HASR
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&
name|HASR_MMC_BUSY
condition|)
empty_stmt|;
name|outw
argument_list|(
name|MMCR
argument_list|(
name|base
argument_list|)
argument_list|,
name|reg
operator|<<
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|HASR
argument_list|(
name|base
argument_list|)
argument_list|)
operator|&
name|HASR_MMC_BUSY
condition|)
empty_stmt|;
return|return
operator|(
name|u_short
operator|)
name|inw
argument_list|(
name|MMCR
argument_list|(
name|base
argument_list|)
argument_list|)
operator|>>
literal|8
return|;
block|}
specifier|static
name|void
name|getsnr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|MMC_WRITE
argument_list|(
name|MMC_FREEZE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*       * SNR retrieval procedure :      *      * read signal level : wlmmcread(base, MMC_SIGNAL_LVL);      * read silence level : wlmmcread(base, MMC_SILENCE_LVL);      */
name|MMC_WRITE
argument_list|(
name|MMC_FREEZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * SNR is signal:silence ratio.      */
block|}
comment|/* ** wlgetpsa ** ** Reads the psa for the wavelan at (base) into (buf) */
specifier|static
name|void
name|wlgetpsa
parameter_list|(
name|int
name|base
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|PCMD
argument_list|(
name|base
argument_list|,
name|HACR_DEFAULT
operator|&
operator|~
name|HACR_16BITS
argument_list|)
expr_stmt|;
name|PCMD
argument_list|(
name|base
argument_list|,
name|HACR_DEFAULT
operator|&
operator|~
name|HACR_16BITS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x40
condition|;
name|i
operator|++
control|)
block|{
name|outw
argument_list|(
name|PIOR2
argument_list|(
name|base
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|PIOP2
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|PCMD
argument_list|(
name|base
argument_list|,
name|HACR_DEFAULT
argument_list|)
expr_stmt|;
name|PCMD
argument_list|(
name|base
argument_list|,
name|HACR_DEFAULT
argument_list|)
expr_stmt|;
block|}
comment|/* ** wlsetpsa ** ** Writes the psa for wavelan (unit) from the softc back to the ** board.  Updates the CRC and sets the CRC OK flag. ** ** Do not call this when the board is operating, as it doesn't  ** preserve the hacr. */
specifier|static
name|void
name|wlsetpsa
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|int
name|i
decl_stmt|,
name|oldpri
decl_stmt|;
name|u_short
name|crc
decl_stmt|;
name|crc
operator|=
name|wlpsacrc
argument_list|(
name|sc
operator|->
name|psa
argument_list|)
expr_stmt|;
comment|/* calculate CRC of PSA */
name|sc
operator|->
name|psa
index|[
name|WLPSA_CRCLOW
index|]
operator|=
name|crc
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|psa
index|[
name|WLPSA_CRCHIGH
index|]
operator|=
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|psa
index|[
name|WLPSA_CRCOK
index|]
operator|=
literal|0x55
expr_stmt|;
comment|/* default to 'bad' until programming complete */
name|oldpri
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* ick, long pause */
name|PCMD
argument_list|(
name|base
argument_list|,
name|HACR_DEFAULT
operator|&
operator|~
name|HACR_16BITS
argument_list|)
expr_stmt|;
name|PCMD
argument_list|(
name|base
argument_list|,
name|HACR_DEFAULT
operator|&
operator|~
name|HACR_16BITS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x40
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
name|DELAYCONST
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR2
argument_list|(
name|base
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* write param memory */
name|DELAY
argument_list|(
name|DELAYCONST
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PIOP2
argument_list|(
name|base
argument_list|)
argument_list|,
name|sc
operator|->
name|psa
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|DELAY
argument_list|(
name|DELAYCONST
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|PIOR2
argument_list|(
name|base
argument_list|)
argument_list|,
name|WLPSA_CRCOK
argument_list|)
expr_stmt|;
comment|/* update CRC flag*/
name|DELAY
argument_list|(
name|DELAYCONST
argument_list|)
expr_stmt|;
name|sc
operator|->
name|psa
index|[
name|WLPSA_CRCOK
index|]
operator|=
literal|0xaa
expr_stmt|;
comment|/* OK now */
name|outb
argument_list|(
name|PIOP2
argument_list|(
name|base
argument_list|)
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
comment|/* all OK */
name|DELAY
argument_list|(
name|DELAYCONST
argument_list|)
expr_stmt|;
name|PCMD
argument_list|(
name|base
argument_list|,
name|HACR_DEFAULT
argument_list|)
expr_stmt|;
name|PCMD
argument_list|(
name|base
argument_list|,
name|HACR_DEFAULT
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|oldpri
argument_list|)
expr_stmt|;
block|}
comment|/*  ** CRC routine provided by Christopher Giordano<cgiordan@gdeb.com>, ** from original code by Tomi Mikkonen (tomitm@remedy.fi) */
specifier|static
name|u_int
name|crc16_table
index|[
literal|16
index|]
init|=
block|{
literal|0x0000
block|,
literal|0xCC01
block|,
literal|0xD801
block|,
literal|0x1400
block|,
literal|0xF001
block|,
literal|0x3C00
block|,
literal|0x2800
block|,
literal|0xE401
block|,
literal|0xA001
block|,
literal|0x6C00
block|,
literal|0x7800
block|,
literal|0xB401
block|,
literal|0x5000
block|,
literal|0x9C01
block|,
literal|0x8801
block|,
literal|0x4400
block|}
decl_stmt|;
specifier|static
name|u_short
name|wlpsacrc
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
name|u_short
name|crc
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|r1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x3d
condition|;
name|i
operator|++
operator|,
name|buf
operator|++
control|)
block|{
comment|/* lower 4 bits */
name|r1
operator|=
name|crc16_table
index|[
name|crc
operator|&
literal|0xF
index|]
expr_stmt|;
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|4
operator|)
operator|&
literal|0x0FFF
expr_stmt|;
name|crc
operator|=
name|crc
operator|^
name|r1
operator|^
name|crc16_table
index|[
operator|*
name|buf
operator|&
literal|0xF
index|]
expr_stmt|;
comment|/* upper 4 bits */
name|r1
operator|=
name|crc16_table
index|[
name|crc
operator|&
literal|0xF
index|]
expr_stmt|;
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|4
operator|)
operator|&
literal|0x0FFF
expr_stmt|;
name|crc
operator|=
name|crc
operator|^
name|r1
operator|^
name|crc16_table
index|[
operator|(
operator|*
name|buf
operator|>>
literal|4
operator|)
operator|&
literal|0xF
index|]
expr_stmt|;
block|}
return|return
operator|(
name|crc
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|WLCACHE
comment|/*  * wl_cache_store  *  * take input packet and cache various radio hw characteristics  * indexed by MAC address.  *  * Some things to think about:  *	note that no space is malloced.   *	We might hash the mac address if the cache were bigger.  *	It is not clear that the cache is big enough.  *		It is also not clear how big it should be.  *	The cache is IP-specific.  We don't care about that as  *		we want it to be IP-specific.  *	The last N recv. packets are saved.  This will tend  *		to reward agents and mobile hosts that beacon.  *		That is probably fine for mobile ip.  */
comment|/* globals for wavelan signal strength cache */
comment|/* this should go into softc structure above.  */
comment|/* set true if you want to limit cache items to broadcast/mcast   * only packets (not unicast)  */
specifier|static
name|int
name|wl_cache_mcastonly
init|=
literal|1
decl_stmt|;
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|wl_cache_mcastonly
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|wl_cache_mcastonly
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* set true if you want to limit cache items to IP packets only */
specifier|static
name|int
name|wl_cache_iponly
init|=
literal|1
decl_stmt|;
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|wl_cache_iponly
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|wl_cache_iponly
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* zero out the cache */
specifier|static
name|void
name|wl_cache_zero
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|w_sigcache
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|w_sigcache
argument_list|)
operator|*
name|MAXCACHEITEMS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|w_sigitems
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|w_nextcache
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|w_wrapindex
operator|=
literal|0
expr_stmt|;
block|}
comment|/* store hw signal info in cache.  * index is MAC address, but an ip src gets stored too  * There are two filters here controllable via sysctl:  *	throw out unicast (on by default, but can be turned off)  *	throw out non-ip (on by default, but can be turned off)  */
specifier|static
name|void
name|wl_cache_store
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|base
parameter_list|,
name|struct
name|ether_header
modifier|*
name|eh
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
comment|/* Avoid GCC warning */
name|int
name|i
decl_stmt|;
name|int
name|signal
decl_stmt|,
name|silence
decl_stmt|;
name|int
name|w_insertcache
decl_stmt|;
comment|/* computed index for cache entry storage */
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|int
name|ipflag
init|=
name|wl_cache_iponly
decl_stmt|;
comment|/* filters: 	 * 1. ip only 	 * 2. configurable filter to throw out unicast packets, 	 * keep multicast only. 	 */
ifdef|#
directive|ifdef
name|INET
comment|/* reject if not IP packet 	*/
if|if
condition|(
name|wl_cache_iponly
operator|&&
operator|(
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|!=
literal|0x800
operator|)
condition|)
block|{
return|return;
block|}
comment|/* check if broadcast or multicast packet.  we toss 	 * unicast packets 	 */
if|if
condition|(
name|wl_cache_mcastonly
operator|&&
operator|(
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return;
block|}
comment|/* find the ip header.  we want to store the ip_src 	 * address.  use the mtod macro(in mbuf.h)  	 * to typecast m to struct ip * 	 */
if|if
condition|(
name|ipflag
condition|)
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* do a linear search for a matching MAC address  	 * in the cache table 	 * . MAC address is 6 bytes, 	 * . var w_nextcache holds total number of entries already cached 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|w_nextcache
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|w_sigcache
index|[
name|i
index|]
operator|.
name|macsrc
argument_list|,
literal|6
argument_list|)
condition|)
block|{
comment|/* Match!, 			 * so we already have this entry, 			 * update the data, and LRU age 			 */
break|break;
block|}
block|}
comment|/* did we find a matching mac address? 	 * if yes, then overwrite a previously existing cache entry 	 */
if|if
condition|(
name|i
operator|<
name|sc
operator|->
name|w_nextcache
condition|)
block|{
name|w_insertcache
operator|=
name|i
expr_stmt|;
block|}
comment|/* else, have a new address entry,so 	 * add this new entry, 	 * if table full, then we need to replace entry 	 */
else|else
block|{
comment|/* check for space in cache table  		 * note: w_nextcache also holds number of entries 		 * added in the cache table  		 */
if|if
condition|(
name|sc
operator|->
name|w_nextcache
operator|<
name|MAXCACHEITEMS
condition|)
block|{
name|w_insertcache
operator|=
name|sc
operator|->
name|w_nextcache
expr_stmt|;
name|sc
operator|->
name|w_nextcache
operator|++
expr_stmt|;
name|sc
operator|->
name|w_sigitems
operator|=
name|sc
operator|->
name|w_nextcache
expr_stmt|;
block|}
comment|/* no space found, so simply wrap with wrap index 		 * and "zap" the next entry 		 */
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|w_wrapindex
operator|==
name|MAXCACHEITEMS
condition|)
block|{
name|sc
operator|->
name|w_wrapindex
operator|=
literal|0
expr_stmt|;
block|}
name|w_insertcache
operator|=
name|sc
operator|->
name|w_wrapindex
operator|++
expr_stmt|;
block|}
block|}
comment|/* invariant: w_insertcache now points at some slot 	 * in cache. 	 */
if|if
condition|(
name|w_insertcache
operator|<
literal|0
operator|||
name|w_insertcache
operator|>=
name|MAXCACHEITEMS
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"wl_cache_store, bad index: %d of [0..%d], gross cache error\n"
argument_list|,
name|w_insertcache
argument_list|,
name|MAXCACHEITEMS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  store items in cache 	 *  .ipsrc 	 *  .macsrc 	 *  .signal (0..63) ,silence (0..63) ,quality (0..15) 	 */
if|if
condition|(
name|ipflag
condition|)
block|{
name|sc
operator|->
name|w_sigcache
index|[
name|w_insertcache
index|]
operator|.
name|ipsrc
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|sc
operator|->
name|w_sigcache
index|[
name|w_insertcache
index|]
operator|.
name|macsrc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|signal
operator|=
name|sc
operator|->
name|w_sigcache
index|[
name|w_insertcache
index|]
operator|.
name|signal
operator|=
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_SIGNAL_LVL
argument_list|)
operator|&
literal|0x3f
expr_stmt|;
name|silence
operator|=
name|sc
operator|->
name|w_sigcache
index|[
name|w_insertcache
index|]
operator|.
name|silence
operator|=
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_SILENCE_LVL
argument_list|)
operator|&
literal|0x3f
expr_stmt|;
name|sc
operator|->
name|w_sigcache
index|[
name|w_insertcache
index|]
operator|.
name|quality
operator|=
name|wlmmcread
argument_list|(
name|base
argument_list|,
name|MMC_SIGN_QUAL
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|signal
operator|>
literal|0
condition|)
name|sc
operator|->
name|w_sigcache
index|[
name|w_insertcache
index|]
operator|.
name|snr
operator|=
name|signal
operator|-
name|silence
expr_stmt|;
else|else
name|sc
operator|->
name|w_sigcache
index|[
name|w_insertcache
index|]
operator|.
name|snr
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* INET */
block|}
endif|#
directive|endif
comment|/* WLCACHE */
comment|/*  * determine if in all multicast mode or not  *   * returns: 1 if IFF_ALLMULTI should be set  *	    else 0  */
ifdef|#
directive|ifdef
name|MULTICAST
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|__FreeBSD_version
operator|<
literal|300000
comment|/* not required */
specifier|static
name|int
name|check_allmulti
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|wl_softc
modifier|*
name|sc
init|=
name|WLSOFTC
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|short
name|base
init|=
name|sc
operator|->
name|base
decl_stmt|;
name|struct
name|ether_multi
modifier|*
name|enm
decl_stmt|;
name|struct
name|ether_multistep
name|step
decl_stmt|;
name|ETHER_FIRST_MULTI
argument_list|(
name|step
argument_list|,
operator|&
name|sc
operator|->
name|wl_ac
argument_list|,
name|enm
argument_list|)
expr_stmt|;
while|while
condition|(
name|enm
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|;
ifdef|#
directive|ifdef
name|MDEBUG
name|printf
argument_list|(
literal|"enm_addrlo %x:%x:%x:%x:%x:%x\n"
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|0
index|]
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|1
index|]
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|2
index|]
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|3
index|]
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|4
index|]
argument_list|,
name|enm
operator|->
name|enm_addrlo
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"enm_addrhi %x:%x:%x:%x:%x:%x\n"
argument_list|,
name|enm
operator|->
name|enm_addrhi
index|[
literal|0
index|]
argument_list|,
name|enm
operator|->
name|enm_addrhi
index|[
literal|1
index|]
argument_list|,
name|enm
operator|->
name|enm_addrhi
index|[
literal|2
index|]
argument_list|,
name|enm
operator|->
name|enm_addrhi
index|[
literal|3
index|]
argument_list|,
name|enm
operator|->
name|enm_addrhi
index|[
literal|4
index|]
argument_list|,
name|enm
operator|->
name|enm_addrhi
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bcmp
argument_list|(
name|enm
operator|->
name|enm_addrlo
argument_list|,
name|enm
operator|->
name|enm_addrhi
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ETHER_NEXT_MULTI
argument_list|(
name|step
argument_list|,
name|enm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

