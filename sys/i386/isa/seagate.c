begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * (Free/Net/386)BSD ST01/02, Future Domain TMC-885, TMC-950 SCSI driver for  * Julians SCSI-code  *  * Copyright 1994, Kent Palmkvist (kentp@isy.liu.se)  * Copyright 1994, Robert Knier (rknier@qgraph.com)  * Copyright 1992, 1994 Drew Eckhardt (drew@colorado.edu)  * Copyright 1994, Julian Elischer (julian@tfs.com)  * Copyright 1994, Serge Vakulenko (vak@cronyx.ru)  *  * Others that has contributed by example code is  * 		Glen Overby (overby@cray.com)  *		Tatu Yllnen  *		Brian E Litzinger  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE DEVELOPERS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE DEVELOPERS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * kentp  940307 alpha version based on newscsi-03 version of Julians SCSI-code  * kentp  940314 Added possibility to not use messages  * rknier 940331 Added fast transfer code  * rknier 940407 Added assembler coded data transfers  * vak    941226 New probe algorithm, based on expected behaviour  *               instead of BIOS signatures analysis, better timeout handling,  *               new asm fragments for data input/output, target-dependent  *               delays, device flags, polling mode, generic cleanup  *  * $Id: seagate.c,v 1.3 1994/06/16 13:26:14 sean Exp $  */
end_comment

begin_comment
comment|/*  * What should really be done:  *  * Restructure interrupt enable/disable code (runs too long with int disabled)  * Find bug? giving problem with tape status  * Add code to handle Future Domain 840, 841, 880 and 881  * add code to use tagged commands in SCSI2  * Add code to handle slow devices better (sleep if device not disconnecting)  * Fix unnecessary interrupts  */
end_comment

begin_comment
comment|/* Note to users trying to share a disk between DOS and unix:  * The ST01/02 is a translating host-adapter. It is not giving DOS  * the same number of heads/tracks/sectors as specified by the disk.  * It is therefore important to look at what numbers DOS thinks the  * disk has. Use these to disklabel your disk in an appropriate manner  *  * About ST02+IDE coexistence: the original Seagate ST02  * BIOS cannot coexist with IDE or any other disk controller  * because it does not share BIOS disk drive numbers (80h, 81h)  * with others.  New probing code allows using ST02 controller  * without BIOS: just unplug the ST02 BIOS chip from the board.  *  * Another problem is the floppy adapter on ST02 which could not be  * disabled by jumpers.  I commonly use ST02 adapter as a cheap solution  * for atttaching the tape and CD-ROM drives, and an extra floppy controller  * is just a headache.  I found a simple workaround: cutting off  * the AEN signal (A11 contact on ISA connector).  AEN then goes high and  * disables the floppy adapter port address decoder.  *  * I also had a problem with ST02 conflicting with IDE during  * IDE data write phase.  It seems than ST02 makes some noise  * on /IOW line.  The /IOW line is used only for floppy controller  * part of ST02, and because I don't need it, I cut off the /IOW (contact B13)  * and it helped. (vak)  *  * Tested on the following hardware:  *   Adapter: Seagate ST02  *      Disk: HP D1686  * Streamers: Archive Viper 150, Wangtek 5525  *   CD-ROMs: Toshiba XM-3401, NEC CDR-25  *  * Maximum data rate is about 270-280 kbytes/sec (on 386DX/40).  * (vak)  */
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_include
include|#
directive|include
file|"sea.h"
end_include

begin_if
if|#
directive|if
name|NSEA
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|PRINT
parameter_list|(
name|s
parameter_list|)
value|printf s
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PRINT
parameter_list|(
name|s
parameter_list|)
end_define

begin_comment
comment|/*void*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SEA_SCB_MAX
value|8
end_define

begin_comment
comment|/* allow maximally 8 scsi control blocks */
end_comment

begin_define
define|#
directive|define
name|SCB_TABLE_SIZE
value|8
end_define

begin_comment
comment|/* start with 8 scb entries in table */
end_comment

begin_define
define|#
directive|define
name|BLOCK_SIZE
value|512
end_define

begin_comment
comment|/* size of READ/WRITE areas on SCSI card */
end_comment

begin_define
define|#
directive|define
name|SEA_SCSI_ADDR
value|7
end_define

begin_comment
comment|/* address of the adapter on the SCSI bus */
end_comment

begin_comment
comment|/*  * Defice config flags  */
end_comment

begin_define
define|#
directive|define
name|FLAG_NOPARITY
value|0x01
end_define

begin_comment
comment|/* disable SCSI bus parity check */
end_comment

begin_define
define|#
directive|define
name|FLAG_SENSEFIRST
value|0x02
end_define

begin_comment
comment|/* place REQUEST_SENSE ops ahead of queue */
end_comment

begin_comment
comment|/*  * Board CONTROL register  */
end_comment

begin_define
define|#
directive|define
name|CMD_RST
value|0x01
end_define

begin_comment
comment|/* scsi reset */
end_comment

begin_define
define|#
directive|define
name|CMD_SEL
value|0x02
end_define

begin_comment
comment|/* scsi select */
end_comment

begin_define
define|#
directive|define
name|CMD_BSY
value|0x04
end_define

begin_comment
comment|/* scsi busy */
end_comment

begin_define
define|#
directive|define
name|CMD_ATTN
value|0x08
end_define

begin_comment
comment|/* scsi attention */
end_comment

begin_define
define|#
directive|define
name|CMD_START_ARB
value|0x10
end_define

begin_comment
comment|/* start arbitration bit */
end_comment

begin_define
define|#
directive|define
name|CMD_EN_PARITY
value|0x20
end_define

begin_comment
comment|/* enable scsi parity generation */
end_comment

begin_define
define|#
directive|define
name|CMD_INTR
value|0x40
end_define

begin_comment
comment|/* enable scsi interrupts */
end_comment

begin_define
define|#
directive|define
name|CMD_DRVR_ENABLE
value|0x80
end_define

begin_comment
comment|/* scsi enable */
end_comment

begin_comment
comment|/*  * Board STATUS register  */
end_comment

begin_define
define|#
directive|define
name|STAT_BSY
value|0x01
end_define

begin_comment
comment|/* scsi busy */
end_comment

begin_define
define|#
directive|define
name|STAT_MSG
value|0x02
end_define

begin_comment
comment|/* scsi msg */
end_comment

begin_define
define|#
directive|define
name|STAT_IO
value|0x04
end_define

begin_comment
comment|/* scsi I/O */
end_comment

begin_define
define|#
directive|define
name|STAT_CD
value|0x08
end_define

begin_comment
comment|/* scsi C/D */
end_comment

begin_define
define|#
directive|define
name|STAT_REQ
value|0x10
end_define

begin_comment
comment|/* scsi req */
end_comment

begin_define
define|#
directive|define
name|STAT_SEL
value|0x20
end_define

begin_comment
comment|/* scsi select */
end_comment

begin_define
define|#
directive|define
name|STAT_PARITY
value|0x40
end_define

begin_comment
comment|/* parity error bit */
end_comment

begin_define
define|#
directive|define
name|STAT_ARB_CMPL
value|0x80
end_define

begin_comment
comment|/* arbitration complete bit */
end_comment

begin_define
define|#
directive|define
name|STAT_BITS
value|"\20\1bsy\2msg\3i/o\4c/d\5req\6sel\7parity\10arb"
end_define

begin_comment
comment|/*  * SCSI bus requests  */
end_comment

begin_define
define|#
directive|define
name|REQ_MASK
value|(STAT_MSG | STAT_CD | STAT_IO)
end_define

begin_define
define|#
directive|define
name|REQ_DATAOUT
value|0
end_define

begin_define
define|#
directive|define
name|REQ_DATAIN
value|STAT_IO
end_define

begin_define
define|#
directive|define
name|REQ_CMDOUT
value|STAT_CD
end_define

begin_define
define|#
directive|define
name|REQ_STATIN
value|(STAT_CD | STAT_IO)
end_define

begin_define
define|#
directive|define
name|REQ_MSGOUT
value|(STAT_MSG | STAT_CD)
end_define

begin_define
define|#
directive|define
name|REQ_MSGIN
value|(STAT_MSG | STAT_CD | STAT_IO)
end_define

begin_define
define|#
directive|define
name|REQ_UNKNOWN
value|0xff
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sea_phase_name
index|[]
init|=
block|{
literal|"DATAOUT"
block|,
literal|"Phase1?"
block|,
literal|"Phase2?"
block|,
literal|"Phase3?"
block|,
literal|"DATAIN"
block|,
literal|"Phase5?"
block|,
literal|"Phase6?"
block|,
literal|"Phase7?"
block|,
literal|"CMDOUT"
block|,
literal|"Phase9?"
block|,
literal|"MSGOUT"
block|,
literal|"Phase11?"
block|,
literal|"STATIN"
block|,
literal|"Phase13?"
block|,
literal|"MSGIN"
block|,
literal|"Phase15?"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * SCSI message codes  */
end_comment

begin_define
define|#
directive|define
name|MSG_COMMAND_COMPLETE
value|0x00
end_define

begin_define
define|#
directive|define
name|MSG_SAVE_POINTERS
value|0x02
end_define

begin_define
define|#
directive|define
name|MSG_RESTORE_POINTERS
value|0x03
end_define

begin_define
define|#
directive|define
name|MSG_DISCONNECT
value|0x04
end_define

begin_define
define|#
directive|define
name|MSG_ABORT
value|0x06
end_define

begin_define
define|#
directive|define
name|MSG_MESSAGE_REJECT
value|0x07
end_define

begin_define
define|#
directive|define
name|MSG_NOP
value|0x08
end_define

begin_define
define|#
directive|define
name|MSG_BUS_DEV_RESET
value|0x0c
end_define

begin_define
define|#
directive|define
name|MSG_IDENTIFY
parameter_list|(
name|lun
parameter_list|)
value|(0xc0 | ((lun)& 0x7))
end_define

begin_define
define|#
directive|define
name|MSG_ISIDENT
parameter_list|(
name|m
parameter_list|)
value|((m)& 0x80)
end_define

begin_comment
comment|/*  * SCSI control block used to keep info about a scsi command  */
end_comment

begin_struct
struct|struct
name|sea_scb
block|{
name|int
name|flags
decl_stmt|;
comment|/* status of the instruction */
define|#
directive|define
name|SCB_FREE
value|0
define|#
directive|define
name|SCB_ACTIVE
value|1
define|#
directive|define
name|SCB_ABORTED
value|2
define|#
directive|define
name|SCB_TIMEOUT
value|4
define|#
directive|define
name|SCB_ERROR
value|8
define|#
directive|define
name|SCB_TIMECHK
value|16
comment|/* We have set a timeout on this one */
name|struct
name|sea_scb
modifier|*
name|next
decl_stmt|;
comment|/* in free list */
name|struct
name|scsi_xfer
modifier|*
name|xfer
decl_stmt|;
comment|/* the scsi_xfer for this cmd */
name|u_char
modifier|*
name|data
decl_stmt|;
comment|/* position in data buffer so far */
name|int32
name|datalen
decl_stmt|;
comment|/* bytes remaining to transfer */
empty_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTLR_NONE
block|,
name|CTLR_SEAGATE
block|,
name|CTLR_FUTURE_DOMAIN
block|, }
name|ctlr_t
typedef|;
end_typedef

begin_decl_stmt
name|char
modifier|*
name|sea_name
index|[]
init|=
block|{
literal|"Unknown"
block|,
literal|"Seagate ST01/ST02"
block|,
literal|"Future Domain TMC-885/TMC-950"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flags for waiting for REQ deassert during some SCSI bus phases.  */
end_comment

begin_struct
struct|struct
name|sea_phase
block|{
name|unsigned
name|cmdout1
range|:
literal|1
decl_stmt|;
comment|/* after CMDOUT[0] byte */
name|unsigned
name|cmdout
range|:
literal|1
decl_stmt|;
comment|/* after CMDOUT[1..N] bytes */
name|unsigned
name|msgout
range|:
literal|1
decl_stmt|;
comment|/* after MSGOUT byte */
name|unsigned
name|statin
range|:
literal|1
decl_stmt|;
comment|/* after STATIN byte */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Data structure describing the target state.  */
end_comment

begin_struct
struct|struct
name|sea_target
block|{
name|struct
name|sea_data
modifier|*
name|adapter
decl_stmt|;
comment|/* pointer to the adapter structure */
specifier|volatile
name|u_char
name|busy
decl_stmt|;
comment|/* mask of busy luns at device target */
name|u_long
name|perrcnt
decl_stmt|;
comment|/* counter of target parity errors */
name|struct
name|sea_phase
name|ndelay
decl_stmt|;
comment|/* "don't delay" flags */
name|struct
name|sea_phase
name|init
decl_stmt|;
comment|/* "initialized" flags */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Data structure describing current status of the scsi bus. One for each  * controller card.  */
end_comment

begin_struct
struct|struct
name|sea_data
block|{
name|ctlr_t
name|type
decl_stmt|;
comment|/* Seagate or Future Domain */
specifier|volatile
name|u_char
modifier|*
name|addr
decl_stmt|;
comment|/* base address for card */
specifier|volatile
name|u_char
modifier|*
name|CONTROL
decl_stmt|;
comment|/* address of control register */
specifier|volatile
name|u_char
modifier|*
name|STATUS
decl_stmt|;
comment|/* address of status register */
specifier|volatile
name|u_char
modifier|*
name|DATA
decl_stmt|;
comment|/* address of data register */
name|u_char
name|scsi_addr
decl_stmt|;
comment|/* our scsi address, 0..7 */
name|u_char
name|scsi_id
decl_stmt|;
comment|/* our scsi id mask */
name|u_char
name|parity
decl_stmt|;
comment|/* parity flag: CMD_EN_PARITY or 0 */
name|u_char
name|irq
decl_stmt|;
comment|/* IRQ number used or 0 if no IRQ */
name|unsigned
name|sensefirst
range|:
literal|1
decl_stmt|;
comment|/* place REQUEST_SENSE ops ahead */
name|unsigned
name|timeout_active
range|:
literal|1
decl_stmt|;
comment|/* sea_timeout active (requested) */
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
comment|/* struct connecting different data */
name|struct
name|sea_scb
modifier|*
name|connected
decl_stmt|;
comment|/* currently connected command */
name|struct
name|sea_scb
modifier|*
name|issue_queue
decl_stmt|;
comment|/* waiting to be issued */
name|struct
name|sea_scb
modifier|*
name|disconnected_queue
decl_stmt|;
comment|/* waiting to reconnect */
name|int
name|numscb
decl_stmt|;
comment|/* number of scsi control blocks */
name|struct
name|sea_scb
name|scbs
index|[
name|SCB_TABLE_SIZE
index|]
decl_stmt|;
name|struct
name|sea_scb
modifier|*
name|free_scb
decl_stmt|;
comment|/* free scb list */
name|struct
name|sea_target
name|target
index|[
literal|8
index|]
decl_stmt|;
comment|/* target state data */
block|}
name|seadata
index|[
name|NSEA
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|IS_BUSY
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)->target[(b)->xfer->sc_link->target].busy&\ 				(1<< (b)->xfer->sc_link->lun))
end_define

begin_define
define|#
directive|define
name|SET_BUSY
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)->target[(b)->xfer->sc_link->target].busy |=\ 				(1<< (b)->xfer->sc_link->lun))
end_define

begin_define
define|#
directive|define
name|CLEAR_BUSY
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)->target[(b)->xfer->sc_link->target].busy&=\ 				~(1<< (b)->xfer->sc_link->lun))
end_define

begin_comment
comment|/*  * Wait for condition, given as an boolean expression.  * Print the message on timeout (approx 10 msec).  */
end_comment

begin_define
define|#
directive|define
name|WAITFOR
parameter_list|(
name|condition
parameter_list|,
name|message
parameter_list|)
value|{\ 	register long cnt = 100000; char *msg = message;\ 	while (cnt--&& ! (condition)) continue;\ 	if (cnt == -1&& msg)\ 		printf ("sea: timeout waiting for %s\n", msg); }
end_define

begin_comment
comment|/*  * Seagate adapter does not support in hardware  * waiting for REQ deassert after transferring each data byte.  * We must do it in software.  * The problem is that some SCSI devices deassert REQ so fast that  * we can miss it.  We the flag for each target sayind if we should (not)  * wait for REQ deassert.  This flag is initialized when the first  * operation on the target is done.  * 1) Test if we don't need to wait for REQ deassert (`nodelay' flag).  *    Initially the flag is off, i.e. wait.  If the flag is set,  *    go to the step 4.  * 2) Wait for REQ deassert (call sea_wait_for_req_deassert function).  *    If REQ deassert got, go to the step 4.  If REQ did not cleared  *    during timeout period, go to the next step.  * 3) If `nodelay' flag did not initialized yet (`init' flag),  *    then set `ndelay' flag.  * 4) Set `init' flag.  Done.  */
end_comment

begin_define
define|#
directive|define
name|WAITREQ
parameter_list|(
name|t
parameter_list|,
name|op
parameter_list|,
name|cnt
parameter_list|)
value|{\ 	if (! t->ndelay.op&&\ 	    ! sea_wait_for_req_deassert (t->adapter, cnt, #op)&&\ 	    ! t->init.op)\ 		t->ndelay.op = 1;\ 	t->init.op = 1; }
end_define

begin_function_decl
name|int
name|sea_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_detect
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|seaintr
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int32
name|sea_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int32
name|sea_adapter_info
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sea_timeout
parameter_list|(
name|void
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|seaminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sea_done
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|sea_scb
modifier|*
name|sea_get_scb
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sea_free_scb
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sea_start
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sea_information_transfer
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_poll
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_init
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_send_scb
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_reselect
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_select
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sea_abort
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sea_msg_output
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|u_char
name|msg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_char
name|sea_msg_input
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|scsi_adapter
name|sea_switch
init|=
block|{
name|sea_scsi_cmd
block|,
name|seaminphys
block|,
literal|0
block|,
literal|0
block|,
name|sea_adapter_info
block|,
literal|"sea"
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the below structure is so we have a default dev struct for our link struct */
end_comment

begin_decl_stmt
name|struct
name|scsi_device
name|sea_dev
init|=
block|{
name|NULL
block|,
comment|/* use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"sea"
block|,
literal|0
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|seadriver
init|=
block|{
name|sea_probe
block|,
name|sea_attach
block|,
literal|"sea"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check if the device can be found at the port given and if so,  * detect the type of board. Set it up ready for further work.  * Takes the isa_dev structure from autoconf as an argument.  * Returns 1 if card recognized, 0 if errors.  */
end_comment

begin_function
name|int
name|sea_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|sea_data
modifier|*
name|sea
init|=
operator|&
name|seadata
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
specifier|static
specifier|const
name|addrtab
index|[]
operator|=
block|{
literal|0xc8000
block|,
literal|0xca000
block|,
literal|0xcc000
block|,
literal|0xce000
block|,
literal|0xdc000
block|,
literal|0xde000
block|,
literal|0
block|, 	}
expr_stmt|;
name|int
name|i
decl_stmt|;
name|dev
operator|->
name|id_msize
operator|=
literal|0x4000
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|id_maddr
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|addrtab
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
name|dev
operator|->
name|id_maddr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|KERNBASE
operator|+
name|addrtab
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sea_detect
argument_list|(
name|sea
argument_list|,
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sea_detect
argument_list|(
name|sea
argument_list|,
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sea
operator|->
name|type
operator|=
name|CTLR_NONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sea_detect
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|sea
operator|->
name|addr
operator|=
name|dev
operator|->
name|id_maddr
expr_stmt|;
comment|/* Try Seagate. */
name|sea
operator|->
name|type
operator|=
name|CTLR_SEAGATE
expr_stmt|;
name|sea
operator|->
name|CONTROL
operator|=
name|sea
operator|->
name|addr
operator|+
literal|0x1a00
expr_stmt|;
comment|/* ST01/ST02 register offsets */
name|sea
operator|->
name|STATUS
operator|=
name|sea
operator|->
name|addr
operator|+
literal|0x1a00
expr_stmt|;
name|sea
operator|->
name|DATA
operator|=
name|sea
operator|->
name|addr
operator|+
literal|0x1c00
expr_stmt|;
if|if
condition|(
name|sea_init
argument_list|(
name|sea
argument_list|,
name|dev
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Try Future Domain. */
name|sea
operator|->
name|type
operator|=
name|CTLR_FUTURE_DOMAIN
expr_stmt|;
name|sea
operator|->
name|CONTROL
operator|=
name|sea
operator|->
name|addr
operator|+
literal|0x1c00
expr_stmt|;
comment|/* TMC-885/TMC-950 reg. offsets */
name|sea
operator|->
name|STATUS
operator|=
name|sea
operator|->
name|addr
operator|+
literal|0x1c00
expr_stmt|;
name|sea
operator|->
name|DATA
operator|=
name|sea
operator|->
name|addr
operator|+
literal|0x1e00
expr_stmt|;
if|if
condition|(
name|sea_init
argument_list|(
name|sea
argument_list|,
name|dev
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe the adapter, and if found,  * reset the board and the scsi bus.  */
end_comment

begin_function
name|int
name|sea_init
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
specifier|volatile
name|u_char
modifier|*
name|p
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check that STATUS..STATUS+200h are equal. */
name|p
operator|=
name|sea
operator|->
name|STATUS
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0xff
condition|)
return|return
operator|(
literal|2
operator|)
return|;
while|while
condition|(
operator|++
name|p
operator|<
name|sea
operator|->
name|STATUS
operator|+
literal|0x200
condition|)
if|if
condition|(
operator|*
name|p
operator|!=
name|c
condition|)
return|return
operator|(
literal|3
operator|)
return|;
comment|/* Check that DATA..DATA+200h are equal. */
for|for
control|(
name|p
operator|=
name|sea
operator|->
name|DATA
operator|,
name|c
operator|=
operator|*
name|p
operator|++
init|;
name|p
operator|<
name|sea
operator|->
name|DATA
operator|+
literal|0x200
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|!=
name|c
condition|)
return|return
operator|(
literal|4
operator|)
return|;
comment|/* Check that addr..addr+1800h are not writable. */
for|for
control|(
name|p
operator|=
name|sea
operator|->
name|addr
init|;
name|p
operator|<
name|sea
operator|->
name|addr
operator|+
literal|0x1800
condition|;
operator|++
name|p
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
operator|~
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
operator|~
name|c
condition|)
block|{
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|5
operator|)
return|;
block|}
block|}
comment|/* Check that addr+1800h..addr+1880h are writable. */
for|for
control|(
name|p
operator|=
name|sea
operator|->
name|addr
operator|+
literal|0x1800
init|;
name|p
operator|<
name|sea
operator|->
name|addr
operator|+
literal|0x1880
condition|;
operator|++
name|p
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|0x55
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0x55
condition|)
block|{
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|6
operator|)
return|;
block|}
operator|*
name|p
operator|=
literal|0xaa
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0xaa
condition|)
block|{
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|7
operator|)
return|;
block|}
block|}
comment|/* Parse device flags. */
name|sea
operator|->
name|parity
operator|=
operator|(
name|dev
operator|->
name|id_flags
operator|&
name|FLAG_NOPARITY
operator|)
condition|?
literal|0
else|:
name|CMD_EN_PARITY
expr_stmt|;
comment|/* Reset the scsi bus (I don't know if this is needed). */
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_RST
operator||
name|CMD_DRVR_ENABLE
expr_stmt|;
comment|/* Hold reset for at least 25 microseconds. */
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
comment|/* Check that status cleared. */
if|if
condition|(
operator|*
name|sea
operator|->
name|STATUS
operator|!=
literal|0
condition|)
block|{
operator|*
name|sea
operator|->
name|CONTROL
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|8
operator|)
return|;
block|}
comment|/* Check that DATA register is writable. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|sea
operator|->
name|DATA
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|sea
operator|->
name|DATA
operator|!=
name|i
condition|)
block|{
operator|*
name|sea
operator|->
name|CONTROL
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|9
operator|)
return|;
block|}
block|}
comment|/* Enable the adapter. */
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|sea
operator|->
name|parity
expr_stmt|;
comment|/* Wait a Bus Clear Delay (800 ns + bus free delay 800 ns). */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Check that DATA register is NOT writable. */
name|c
operator|=
operator|*
name|sea
operator|->
name|DATA
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|sea
operator|->
name|DATA
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|sea
operator|->
name|DATA
operator|!=
name|c
condition|)
block|{
operator|*
name|sea
operator|->
name|CONTROL
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|10
operator|)
return|;
block|}
block|}
comment|/* Init fields used by our routines */
name|sea
operator|->
name|sensefirst
operator|=
operator|(
name|dev
operator|->
name|id_flags
operator|&
name|FLAG_SENSEFIRST
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|sea
operator|->
name|scsi_addr
operator|=
name|SEA_SCSI_ADDR
expr_stmt|;
name|sea
operator|->
name|scsi_id
operator|=
literal|1
operator|<<
name|sea
operator|->
name|scsi_addr
expr_stmt|;
name|sea
operator|->
name|irq
operator|=
name|dev
operator|->
name|id_irq
condition|?
name|ffs
argument_list|(
name|dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|sea
operator|->
name|connected
operator|=
literal|0
expr_stmt|;
name|sea
operator|->
name|issue_queue
operator|=
literal|0
expr_stmt|;
name|sea
operator|->
name|disconnected_queue
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|sea
operator|->
name|target
index|[
name|i
index|]
operator|.
name|adapter
operator|=
name|sea
expr_stmt|;
name|sea
operator|->
name|target
index|[
name|i
index|]
operator|.
name|busy
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Link up the free list of scbs */
name|sea
operator|->
name|numscb
operator|=
name|SCB_TABLE_SIZE
expr_stmt|;
name|sea
operator|->
name|free_scb
operator|=
name|sea
operator|->
name|scbs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|SCB_TABLE_SIZE
condition|;
name|i
operator|++
control|)
name|sea
operator|->
name|scbs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|sea
operator|->
name|scbs
operator|+
name|i
expr_stmt|;
name|sea
operator|->
name|scbs
index|[
name|SCB_TABLE_SIZE
operator|-
literal|1
index|]
operator|.
name|next
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|sea_description
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|sea_kdc
index|[
name|NSEA
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"sea"
block|,
literal|0
block|,
block|{
name|MDDT_ISA
block|,
literal|0
block|,
literal|"bio"
block|}
block|,
name|isa_generic_externalize
block|,
literal|0
block|,
literal|0
block|,
name|ISA_EXTERNALLEN
block|,
operator|&
name|kdc_isa0
block|,
literal|0
block|,
name|DC_BUSY
block|,
name|sea_description
block|, }
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Attach all sub-devices we can find.  */
end_comment

begin_function
name|int
name|sea_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|sea_data
modifier|*
name|sea
init|=
operator|&
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|sea_description
argument_list|,
literal|"%s SCSI controller"
argument_list|,
name|sea_name
index|[
name|sea
operator|->
name|type
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sea%d: type %s%s%s\n"
argument_list|,
name|unit
argument_list|,
name|sea_name
index|[
name|sea
operator|->
name|type
index|]
argument_list|,
operator|(
name|dev
operator|->
name|id_flags
operator|&
name|FLAG_NOPARITY
operator|)
condition|?
literal|", no parity"
else|:
literal|""
argument_list|,
operator|(
name|dev
operator|->
name|id_flags
operator|&
name|FLAG_SENSEFIRST
operator|)
condition|?
literal|", sense ahead"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* fill in the prototype scsi_link */
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|unit
expr_stmt|;
name|sea
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|sea
operator|->
name|scsi_addr
expr_stmt|;
name|sea
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|sea_switch
expr_stmt|;
name|sea
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|sea_dev
expr_stmt|;
comment|/* ask the adapter what subunits are present */
name|scsi_attachdevs
argument_list|(
operator|&
operator|(
name|sea
operator|->
name|sc_link
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_unit
condition|)
name|sea_kdc
index|[
name|dev
operator|->
name|id_unit
index|]
operator|=
name|sea_kdc
index|[
literal|0
index|]
expr_stmt|;
name|sea_kdc
index|[
name|dev
operator|->
name|id_unit
index|]
operator|.
name|kdc_unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
name|sea_kdc
index|[
name|dev
operator|->
name|id_unit
index|]
operator|.
name|kdc_isa
operator|=
name|dev
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|sea_kdc
index|[
name|dev
operator|->
name|id_unit
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return some information to the caller about  * the adapter and its capabilities.  */
end_comment

begin_function
name|u_int32
name|sea_adapter_info
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|seaminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Catch an interrupt from the adaptor.  */
end_comment

begin_function
name|int
name|seaintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|sea_data
modifier|*
name|sea
init|=
operator|&
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d: interrupt status=%b\n"
operator|,
name|unit
operator|,
operator|*
name|sea
operator|->
name|STATUS
operator|,
name|STAT_BITS
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator|)
operator|)
operator|==
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator|)
condition|)
block|{
comment|/* Reselect interrupt */
name|sea_reselect
argument_list|(
name|sea
argument_list|)
expr_stmt|;
name|sea_start
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a free scb. If there are none, see if we can allocate a new one. If so,  * put it in the hash table too, otherwise return an error or sleep.  */
end_comment

begin_function
name|struct
name|sea_scb
modifier|*
name|sea_get_scb
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|sea_data
modifier|*
name|sea
init|=
operator|&
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|sea_scb
modifier|*
name|scbp
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * If we can and have to, sleep waiting for one to come free 	 * but only if we can't allocate a new one. 	 */
while|while
condition|(
operator|!
operator|(
name|scbp
operator|=
name|sea
operator|->
name|free_scb
operator|)
condition|)
if|if
condition|(
name|sea
operator|->
name|numscb
operator|<
name|SEA_SCB_MAX
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"malloced new scb\n"
operator|)
argument_list|)
expr_stmt|;
name|scbp
operator|=
operator|(
expr|struct
name|sea_scb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sea_scb
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbp
condition|)
block|{
name|bzero
argument_list|(
name|scbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sea_scb
argument_list|)
argument_list|)
expr_stmt|;
name|sea
operator|->
name|numscb
operator|++
expr_stmt|;
name|scbp
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
name|scbp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"sea%d: can't malloc scb\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sea
operator|->
name|free_scb
argument_list|,
name|PRIBIO
argument_list|,
literal|"seascb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbp
condition|)
block|{
comment|/* Get SCB from free list */
name|sea
operator|->
name|free_scb
operator|=
name|scbp
operator|->
name|next
expr_stmt|;
name|scbp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|scbp
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
block|}
name|ret
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|scbp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sea_free_scb
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|sea_data
modifier|*
name|sea
init|=
operator|&
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|x
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|scb
operator|->
name|next
operator|=
name|sea
operator|->
name|free_scb
expr_stmt|;
name|sea
operator|->
name|free_scb
operator|=
name|scb
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_FREE
expr_stmt|;
comment|/* 	 * If there were none, wake anybody waiting for one to come free, 	 * starting with queued entries. 	 */
if|if
condition|(
operator|!
name|scb
operator|->
name|next
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sea
operator|->
name|free_scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a scsi operation given the command and the data address.  * Also needs the unit, target and lu.  Get a free scb and set it up.  * Call send_scb.  Either start timer or wait until done.  */
end_comment

begin_function
name|int32
name|sea_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|int
name|unit
init|=
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
decl_stmt|,
name|flags
init|=
name|xs
operator|->
name|flags
decl_stmt|,
name|x
init|=
literal|0
decl_stmt|;
name|struct
name|sea_data
modifier|*
name|sea
init|=
operator|&
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|sea_scb
modifier|*
name|scb
decl_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d:%d:%d command 0x%x\n"
operator|,
name|unit
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|xs
operator|->
name|cmd
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
name|flags
operator||=
name|SCSI_NOSLEEP
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"sea%d: already done?"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sea%d: not in use?"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
name|scb
operator|=
name|sea_get_scb
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scb
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
comment|/* Put all the arguments for the xfer in the scb */
name|scb
operator|->
name|xfer
operator|=
name|xs
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|scb
operator|->
name|data
operator|=
name|xs
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
comment|/* Try to send a reset command to the card. This is done 		 * by calling the Reset function. Should then return COMPLETE. 		 * Need to take care of the possible current connected command. 		 * Not implemented right now. */
name|printf
argument_list|(
literal|"sea%d: got a SCSI_RESET!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* Setup the scb to contain necessary values. 	 * The interesting values can be read from the xs that is saved. 	 * I therefore think that the structure can be kept very small. 	 * The driver doesn't use DMA so the scatter/gather is not needed? */
comment|/* A check is done to see if the command contains 	 * a REQUEST_SENSE command, and if so the command is put first 	 * in the queue, otherwise the command is added to the end 	 * of the queue. ?? Not correct ?? */
if|if
condition|(
operator|!
name|sea
operator|->
name|issue_queue
operator|||
operator|(
name|sea
operator|->
name|sensefirst
operator|&&
name|xs
operator|->
name|cmd
operator|->
name|opcode
operator|==
name|REQUEST_SENSE
operator|)
condition|)
block|{
name|scb
operator|->
name|next
operator|=
name|sea
operator|->
name|issue_queue
expr_stmt|;
name|sea
operator|->
name|issue_queue
operator|=
name|scb
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sea_scb
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|sea
operator|->
name|issue_queue
init|;
name|q
operator|->
name|next
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
continue|continue;
name|q
operator|->
name|next
operator|=
name|scb
expr_stmt|;
name|scb
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* placed at the end of the queue */
block|}
comment|/* Try to send this command to the board. Because this board 	 * does not use any mailboxes, this routine simply adds the command 	 * to the queue held by the sea_data structure. */
name|sea_start
argument_list|()
expr_stmt|;
comment|/* Usually return SUCCESSFULLY QUEUED. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
comment|/* Timeout timer not started, already finished. 			 * Tried to return COMPLETE but the machine hanged 			 * with this. */
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
name|timeout
argument_list|(
name|sea_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMECHK
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d:%d:%d command queued\n"
operator|,
name|unit
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
comment|/* If we can't use interrupts, poll on completion. */
if|if
condition|(
operator|!
name|sea_poll
argument_list|(
name|xs
argument_list|)
condition|)
block|{
comment|/* We timed out, so call the timeout handler manually, 		 * accounting for the fact that the clock is not running yet 		 * by taking out the clock queue entry it makes. */
name|sea_timeout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|scb
argument_list|)
expr_stmt|;
comment|/* Because we are polling, take out the timeout entry 		 * sea_timeout made. */
name|untimeout
argument_list|(
name|sea_timeout
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sea_poll
argument_list|(
name|xs
argument_list|)
condition|)
comment|/* We timed out again... This is bad. Notice that 			 * this time there is no clock queue entry to remove. */
name|sea_timeout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|scb
argument_list|)
expr_stmt|;
block|}
name|PRINT
argument_list|(
operator|(
literal|"sea%d:%d:%d command %s\n"
operator|,
name|unit
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|xs
operator|->
name|error
condition|?
literal|"failed"
else|:
literal|"done"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|xs
operator|->
name|error
condition|?
name|HAD_ERROR
else|:
name|COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Coroutine that runs as long as more work can be done.  * Both sea_scsi_cmd and sea_intr will try to start it in  * case it is not running.  * Always called with interrupts disabled.  */
end_comment

begin_function
specifier|static
name|void
name|sea_start
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|unit
decl_stmt|,
name|done
decl_stmt|;
name|again
label|:
name|done
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|NSEA
operator|&&
name|seadata
index|[
name|unit
index|]
operator|.
name|type
condition|;
operator|++
name|unit
control|)
block|{
name|struct
name|sea_data
modifier|*
name|sea
init|=
operator|&
name|seadata
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|sea
operator|->
name|connected
condition|)
block|{
comment|/* Search through the issue_queue for a command 			 * destined for a target that's not busy. */
name|struct
name|sea_scb
modifier|*
name|q
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
for|for
control|(
name|q
operator|=
name|sea
operator|->
name|issue_queue
init|;
name|q
condition|;
name|prev
operator|=
name|q
operator|,
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|IS_BUSY
argument_list|(
name|sea
argument_list|,
name|q
argument_list|)
condition|)
continue|continue;
comment|/* First check that if any device has tried 				 * a reconnect while we have done other things 				 * with interrupts disabled. */
if|if
condition|(
operator|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator|)
operator|)
operator|==
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator|)
condition|)
block|{
name|sea_reselect
argument_list|(
name|sea
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* When we find the command, remove it 				 * from the issue queue. */
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
else|else
name|sea
operator|->
name|issue_queue
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* Attempt to establish an I_T_L nexus here. 				 * On success, sea->connected is set. 				 * On failure, we must add the command back to 				 * the issue queue so we can keep trying. */
if|if
condition|(
name|sea_select
argument_list|(
name|sea
argument_list|,
name|q
argument_list|)
condition|)
break|break;
name|q
operator|->
name|next
operator|=
name|sea
operator|->
name|issue_queue
expr_stmt|;
name|sea
operator|->
name|issue_queue
operator|=
name|q
expr_stmt|;
name|printf
argument_list|(
literal|"sea_start: select failed\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sea
operator|->
name|connected
condition|)
block|{
comment|/* We are connected. Do the task. */
name|sea_information_transfer
argument_list|(
name|sea
argument_list|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
goto|goto
name|again
goto|;
block|}
end_function

begin_function
name|void
name|sea_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sea_scb
modifier|*
name|scb
init|=
operator|(
expr|struct
name|sea_scb
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|unit
init|=
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|adapter_unit
decl_stmt|;
name|int
name|x
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|xfer
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|printf
argument_list|(
literal|"sea%d:%d:%d (%s%d) timed out\n"
argument_list|,
name|unit
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|dev_unit
argument_list|)
expr_stmt|;
comment|/* 	 * If it has been through before, then a previous abort has failed, 	 * don't try abort again. 	 */
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORTED
operator|)
comment|/*&& sea_abort (unit, scb)*/
condition|)
block|{
name|sea_abort
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 2 seconds for the abort */
name|timeout
argument_list|(
name|sea_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
operator|(
name|SCB_ABORTED
operator||
name|SCB_TIMECHK
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort timed out */
name|scb
operator|->
name|flags
operator||=
name|SCB_ABORTED
expr_stmt|;
name|scb
operator|->
name|xfer
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
name|sea_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Establish I_T_L or I_T_L_Q nexus for new or existing command  * including ARBITRATION, SELECTION, and initial message out  * for IDENTIFY and queue messages.  * Return 0 if selection could not execute for some reason, 1 if selection  * succeded or failed because the target did not respond.  */
end_comment

begin_function
name|int
name|sea_select
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"sea%d:%d:%d select\n"
operator|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|sea
operator|->
name|parity
expr_stmt|;
operator|*
name|sea
operator|->
name|DATA
operator|=
name|sea
operator|->
name|scsi_id
expr_stmt|;
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_START_ARB
operator||
name|sea
operator|->
name|parity
expr_stmt|;
comment|/* Wait for arbitration to complete. */
name|WAITFOR
argument_list|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
name|STAT_ARB_CMPL
argument_list|,
literal|"arbitration"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
name|STAT_ARB_CMPL
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
name|STAT_SEL
condition|)
block|{
name|printf
argument_list|(
literal|"sea: arbitration lost\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ERROR
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"sea: arbitration timeout\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMEOUT
expr_stmt|;
block|}
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|sea
operator|->
name|parity
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|*
name|sea
operator|->
name|DATA
operator|=
operator|(
literal|1
operator|<<
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|)
operator||
name|sea
operator|->
name|scsi_id
expr_stmt|;
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_DRVR_ENABLE
operator||
name|CMD_SEL
operator||
name|CMD_ATTN
operator||
name|sea
operator|->
name|parity
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Wait for a bsy from target. 	 * If the target is not present on the bus, we get 	 * the timeout.  Don't PRINT any message -- it's not an error. */
name|WAITFOR
argument_list|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
name|STAT_BSY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
name|STAT_BSY
operator|)
condition|)
block|{
comment|/* The target does not respond.  Not an error, though. 		 * Should return some error to the higher level driver? */
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|sea
operator|->
name|parity
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMEOUT
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Try to make the target to take a message from us. */
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_DRVR_ENABLE
operator||
name|CMD_ATTN
operator||
name|sea
operator|->
name|parity
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Should start a msg_out phase. */
name|WAITFOR
argument_list|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
name|STAT_REQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
name|STAT_REQ
operator|)
condition|)
block|{
comment|/* This should not be taken as an error, but more like 		 * an unsupported feature! 		 * Should set a flag indicating that the target don't support 		 * messages, and continue without failure. 		 * (THIS IS NOT AN ERROR!) 		 */
name|printf
argument_list|(
literal|"sea: target does not support messages, canceled\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ERROR
expr_stmt|;
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|sea
operator|->
name|parity
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sea
operator|->
name|connected
operator|=
name|scb
expr_stmt|;
name|SET_BUSY
argument_list|(
name|sea
argument_list|,
name|scb
argument_list|)
expr_stmt|;
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_DRVR_ENABLE
operator||
name|sea
operator|->
name|parity
expr_stmt|;
comment|/* Allow disconnects. */
name|sea_msg_output
argument_list|(
name|sea
argument_list|,
name|MSG_IDENTIFY
argument_list|(
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
name|STAT_BSY
operator|)
condition|)
name|printf
argument_list|(
literal|"sea: target disconnected after successful arbitrate\n"
argument_list|)
expr_stmt|;
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|CMD_DRVR_ENABLE
operator||
name|sea
operator|->
name|parity
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sea_reselect
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|)
block|{
name|struct
name|sea_scb
modifier|*
name|q
init|=
literal|0
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|u_char
name|msg
decl_stmt|,
name|target_mask
decl_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d reselect: "
operator|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
name|STAT_SEL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sea: wrong state 0x%x\n"
argument_list|,
operator|*
name|sea
operator|->
name|STATUS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Wait for a device to win the reselection phase. */
comment|/* Signals this by asserting the I/O signal. */
name|WAITFOR
argument_list|(
operator|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator||
name|STAT_BSY
operator|)
operator|)
operator|==
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator|)
argument_list|,
literal|"reselection phase"
argument_list|)
expr_stmt|;
comment|/* The data bus contains original initiator id ORed with target id. */
comment|/* See that we really are the initiator. */
name|target_mask
operator|=
operator|*
name|sea
operator|->
name|DATA
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|target_mask
operator|&
name|sea
operator|->
name|scsi_id
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sea: polled reselection was not for me: %x\n"
argument_list|,
name|target_mask
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Find target who won. */
comment|/* Host responds by asserting the BSY signal. */
comment|/* Target should respond by deasserting the SEL signal. */
name|target_mask
operator|&=
operator|~
name|sea
operator|->
name|scsi_id
expr_stmt|;
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_DRVR_ENABLE
operator||
name|CMD_BSY
operator||
name|sea
operator|->
name|parity
expr_stmt|;
name|WAITFOR
argument_list|(
operator|!
operator|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
name|STAT_SEL
operator|)
argument_list|,
literal|"reselection acknowledge"
argument_list|)
expr_stmt|;
comment|/* Remove the busy status. */
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|CMD_DRVR_ENABLE
operator||
name|sea
operator|->
name|parity
expr_stmt|;
comment|/* We are connected. Now we wait for the MSGIN condition. */
name|WAITFOR
argument_list|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
name|STAT_REQ
argument_list|,
literal|"identify message"
argument_list|)
expr_stmt|;
comment|/* Hope we get an IDENTIFY message. */
name|msg
operator|=
name|sea_msg_input
argument_list|(
name|sea
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|MSG_ISIDENT
argument_list|(
name|msg
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sea: expecting IDENTIFY message, got 0x%x\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Find the command corresponding to the I_T_L or I_T_L_Q 		 * nexus we just restablished, and remove it from 		 * the disconnected queue. */
name|unsigned
name|char
name|lun
init|=
operator|(
name|msg
operator|&
literal|7
operator|)
decl_stmt|;
for|for
control|(
name|q
operator|=
name|sea
operator|->
name|disconnected_queue
init|;
name|q
condition|;
name|prev
operator|=
name|q
operator|,
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|target_mask
operator|!=
operator|(
literal|1
operator|<<
name|q
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|)
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|!=
name|q
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
condition|)
continue|continue;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
else|else
name|sea
operator|->
name|disconnected_queue
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|sea
operator|->
name|connected
operator|=
name|q
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"lun %d done\n"
operator|,
name|lun
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Since we have an established nexus that we can't 		 * do anything with, we must abort it. */
name|PRINT
argument_list|(
operator|(
literal|"lun %d aborted\n"
operator|,
name|lun
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Abort the connection. */
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|CMD_DRVR_ENABLE
operator||
name|CMD_ATTN
operator||
name|sea
operator|->
name|parity
expr_stmt|;
name|sea_msg_output
argument_list|(
name|sea
argument_list|,
name|MSG_ABORT
argument_list|)
expr_stmt|;
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|CMD_DRVR_ENABLE
operator||
name|sea
operator|->
name|parity
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send an abort to the target.  * Return 1 success, 0 on failure.  * Called on splbio level.  */
end_comment

begin_function
name|int
name|sea_abort
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|sea_data
modifier|*
name|sea
init|=
operator|&
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|sea_scb
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
comment|/* If the command hasn't been issued yet, we simply remove it 	 * from the issue queue. */
name|prev
operator|=
operator|&
name|sea
operator|->
name|issue_queue
expr_stmt|;
for|for
control|(
name|q
operator|=
name|sea
operator|->
name|issue_queue
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|scb
operator|==
name|q
condition|)
block|{
operator|(
operator|*
name|prev
operator|)
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|next
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|prev
operator|=
operator|&
name|q
operator|->
name|next
expr_stmt|;
block|}
comment|/* If any commands are connected, we're going to fail the abort 	 * and let the high level SCSI driver retry at a later time 	 * or issue a reset. */
if|if
condition|(
name|sea
operator|->
name|connected
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If the command is currently disconnected from the bus, 	 * and there are no connected commands, we reconnect 	 * the I_T_L or I_T_L_Q nexus associated with it, 	 * go into message out, and send an abort message. */
for|for
control|(
name|q
operator|=
name|sea
operator|->
name|disconnected_queue
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|scb
operator|!=
name|q
condition|)
continue|continue;
if|if
condition|(
operator|!
name|sea_select
argument_list|(
name|sea
argument_list|,
name|scb
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|CMD_DRVR_ENABLE
operator||
name|CMD_ATTN
operator||
name|sea
operator|->
name|parity
expr_stmt|;
name|sea_msg_output
argument_list|(
name|sea
argument_list|,
name|MSG_ABORT
argument_list|)
expr_stmt|;
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|CMD_DRVR_ENABLE
operator||
name|sea
operator|->
name|parity
expr_stmt|;
name|prev
operator|=
operator|&
name|sea
operator|->
name|disconnected_queue
expr_stmt|;
for|for
control|(
name|q
operator|=
name|sea
operator|->
name|disconnected_queue
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|scb
operator|==
name|q
condition|)
block|{
operator|*
name|prev
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* Set some type of error result 				 * for the operation. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|prev
operator|=
operator|&
name|q
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Command not found in any queue, race condition in the code? */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sea_done
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|sea_scb
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|scb
operator|->
name|xfer
decl_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TIMECHK
condition|)
name|untimeout
argument_list|(
name|sea_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
comment|/* How much of the buffer was not touched. */
name|xs
operator|->
name|resid
operator|=
name|scb
operator|->
name|datalen
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|!=
name|SCB_ACTIVE
operator|&&
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
condition|)
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
operator|(
name|SCB_TIMEOUT
operator||
name|SCB_ABORTED
operator|)
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ERROR
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|sea_free_scb
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for completion of command in polled mode.  * Always called with interrupts masked out.  */
end_comment

begin_function
name|int
name|sea_poll
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|1000
condition|;
operator|++
name|count
control|)
block|{
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Try to do something. */
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
name|sea_start
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait until REQ goes down.  This is needed for some devices (CDROMs)  * after every MSGOUT, MSGIN, CMDOUT, STATIN request.  * Return true if REQ deassert found.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|sea_wait_for_req_deassert
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|int
name|cnt
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
asm|asm (" 	1:      testb $0x10, %2 		jz 2f 		loop 1b 	2:" 	: "=c" (cnt)
comment|/* output */
asm|: "0" (cnt), "m" (*sea->STATUS));
comment|/* input */
if|if
condition|(
operator|!
name|cnt
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"sea%d:%d:%d (%s) timeout waiting for !REQ\n"
operator|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|sea
operator|->
name|connected
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|sea
operator|->
name|connected
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* PRINT (("sea_wait_for_req_deassert %s count=%d\n", msg, cnt)); */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send the command to the target.  */
end_comment

begin_function
name|void
name|sea_cmd_output
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|u_char
modifier|*
name|cmd
parameter_list|,
name|int
name|cmdlen
parameter_list|)
block|{
name|struct
name|sea_target
modifier|*
name|t
init|=
operator|&
name|sea
operator|->
name|target
index|[
name|sea
operator|->
name|connected
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|cmdlen
operator|||
operator|!
name|cmd
condition|)
block|{
name|printf
argument_list|(
literal|"sea%d:%d:%d no command\n"
argument_list|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|sea
operator|->
name|connected
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|sea
operator|->
name|connected
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
operator|*
name|sea
operator|->
name|DATA
operator|=
literal|0
expr_stmt|;
name|sea_wait_for_req_deassert
argument_list|(
name|sea
argument_list|,
literal|1000
argument_list|,
literal|"ZCMDOUT"
argument_list|)
expr_stmt|;
return|return;
block|}
name|PRINT
argument_list|(
operator|(
literal|"sea%d:%d:%d (CMDOUT) send %d bytes "
operator|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|sea
operator|->
name|connected
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|sea
operator|->
name|connected
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|cmdlen
operator|)
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"%x"
operator|,
operator|*
name|cmd
operator|)
argument_list|)
expr_stmt|;
operator|*
name|sea
operator|->
name|DATA
operator|=
operator|*
name|cmd
operator|++
expr_stmt|;
name|WAITREQ
argument_list|(
name|t
argument_list|,
name|cmdout1
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
while|while
condition|(
name|cmdlen
condition|)
block|{
comment|/* Check for target disconnect. */
name|u_char
name|sts
init|=
operator|*
name|sea
operator|->
name|STATUS
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|STAT_BSY
operator|)
condition|)
break|break;
comment|/* Check for phase mismatch. */
if|if
condition|(
operator|(
name|sts
operator|&
name|REQ_MASK
operator|)
operator|!=
name|REQ_CMDOUT
condition|)
block|{
name|printf
argument_list|(
literal|"sea: sending command: invalid phase %s\n"
argument_list|,
name|sea_phase_name
index|[
name|sts
operator|&
name|REQ_MASK
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Wait for REQ. */
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|STAT_REQ
operator|)
condition|)
continue|continue;
name|PRINT
argument_list|(
operator|(
literal|"-%x"
operator|,
operator|*
name|cmd
operator|)
argument_list|)
expr_stmt|;
operator|*
name|sea
operator|->
name|DATA
operator|=
operator|*
name|cmd
operator|++
expr_stmt|;
name|WAITREQ
argument_list|(
name|t
argument_list|,
name|cmdout
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
block|}
name|PRINT
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send the message to the target.  */
end_comment

begin_function
name|void
name|sea_msg_output
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|,
name|u_char
name|msg
parameter_list|)
block|{
name|struct
name|sea_target
modifier|*
name|t
init|=
name|sea
operator|->
name|connected
condition|?
operator|&
name|sea
operator|->
name|target
index|[
name|sea
operator|->
name|connected
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
index|]
else|:
literal|0
decl_stmt|;
specifier|register
name|u_long
name|cnt
init|=
literal|0
decl_stmt|;
specifier|register
name|u_char
name|sts
decl_stmt|;
comment|/* Wait for REQ, after which the phase bits will be valid. */
name|again
label|:
name|sts
operator|=
operator|*
name|sea
operator|->
name|STATUS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|STAT_REQ
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|cnt
operator|>
literal|1000000L
condition|)
block|{
name|printf
argument_list|(
literal|"sea: sending message: no REQ\n"
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|again
goto|;
block|}
comment|/* Check for phase mismatch. */
if|if
condition|(
operator|(
name|sts
operator|&
name|REQ_MASK
operator|)
operator|!=
name|REQ_MSGOUT
condition|)
block|{
name|printf
argument_list|(
literal|"sea: sending message: invalid phase %s\n"
argument_list|,
name|sea_phase_name
index|[
name|sts
operator|&
name|REQ_MASK
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|sea
operator|->
name|DATA
operator|=
name|msg
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
name|sea_wait_for_req_deassert
argument_list|(
name|sea
argument_list|,
literal|1000
argument_list|,
literal|"MSG_OUTPUT"
argument_list|)
expr_stmt|;
else|else
name|WAITREQ
argument_list|(
name|t
argument_list|,
name|msgout
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d:%d:%d (MSGOUT) send 0x%x\n"
operator|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|sea
operator|->
name|connected
condition|?
name|sea
operator|->
name|connected
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
else|:
literal|9
operator|,
name|sea
operator|->
name|connected
condition|?
name|sea
operator|->
name|connected
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
else|:
literal|9
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the message from the target.  * Return the length of the received message.  */
end_comment

begin_function
name|u_char
name|sea_msg_input
parameter_list|(
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|)
block|{
specifier|register
name|u_long
name|cnt
init|=
literal|0
decl_stmt|;
specifier|register
name|u_char
name|sts
decl_stmt|,
name|msg
decl_stmt|;
comment|/* Wait for REQ, after which the phase bits will be valid. */
name|again
label|:
name|sts
operator|=
operator|*
name|sea
operator|->
name|STATUS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|STAT_REQ
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|cnt
operator|>
literal|1000000L
condition|)
block|{
name|printf
argument_list|(
literal|"sea: receiving message: no REQ\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|MSG_ABORT
operator|)
return|;
block|}
goto|goto
name|again
goto|;
block|}
comment|/* Check for phase mismatch. 	 * Reached if the target decides that it has finished 	 * the transfer. */
if|if
condition|(
operator|(
name|sts
operator|&
name|REQ_MASK
operator|)
operator|!=
name|REQ_MSGIN
condition|)
block|{
name|printf
argument_list|(
literal|"sea: sending message: invalid phase %s\n"
argument_list|,
name|sea_phase_name
index|[
name|sts
operator|&
name|REQ_MASK
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|MSG_ABORT
operator|)
return|;
block|}
comment|/* Do actual transfer from SCSI bus to/from memory. */
name|msg
operator|=
operator|*
name|sea
operator|->
name|DATA
expr_stmt|;
name|sea_wait_for_req_deassert
argument_list|(
name|sea
argument_list|,
literal|1000
argument_list|,
literal|"MSG_INPUT"
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d:%d:%d (MSG_INPUT) got 0x%x\n"
operator|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|sea
operator|->
name|connected
condition|?
name|sea
operator|->
name|connected
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
else|:
literal|9
operator|,
name|sea
operator|->
name|connected
condition|?
name|sea
operator|->
name|connected
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
else|:
literal|9
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is used in the case when we have no IRQ line (sea->irq == 0).  * It is called every timer tick and polls for reconnect from target.  */
end_comment

begin_function
name|void
name|sea_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sea_data
modifier|*
name|sea
init|=
name|arg
decl_stmt|;
name|int
name|x
init|=
name|splbio
argument_list|()
decl_stmt|;
name|sea
operator|->
name|timeout_active
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|sea
operator|->
name|STATUS
operator|&
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator|)
operator|)
operator|==
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator|)
condition|)
block|{
comment|/* Reselect interrupt */
name|sea_reselect
argument_list|(
name|sea
argument_list|)
expr_stmt|;
name|sea_start
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|sea
operator|->
name|disconnected_queue
operator|&&
operator|!
name|sea
operator|->
name|timeout_active
condition|)
block|{
name|timeout
argument_list|(
name|sea_tick
argument_list|,
name|sea
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sea
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do the transfer. We know we are connected. Update the flags,  * call sea_done when task accomplished. Dialog controlled by the target.  * Always called with interrupts disabled.  */
end_comment

begin_function
specifier|static
name|void
name|sea_information_transfer
parameter_list|(
specifier|register
name|struct
name|sea_data
modifier|*
name|sea
parameter_list|)
block|{
name|struct
name|sea_scb
modifier|*
name|scb
init|=
name|sea
operator|->
name|connected
decl_stmt|;
comment|/* current control block */
name|u_char
modifier|*
name|data
init|=
name|scb
operator|->
name|data
decl_stmt|;
comment|/* current data buffer */
name|u_long
name|datalen
init|=
name|scb
operator|->
name|datalen
decl_stmt|;
comment|/* current data transfer size */
name|struct
name|sea_target
modifier|*
name|t
init|=
operator|&
name|sea
operator|->
name|target
index|[
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
index|]
decl_stmt|;
specifier|register
name|u_char
name|sts
decl_stmt|;
name|u_char
name|msg
decl_stmt|;
while|while
condition|(
operator|(
name|sts
operator|=
operator|*
name|sea
operator|->
name|STATUS
operator|)
operator|&
name|STAT_BSY
condition|)
block|{
comment|/* We only have a valid SCSI phase when REQ is asserted. */
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|STAT_REQ
operator|)
condition|)
continue|continue;
if|if
condition|(
name|sts
operator|&
name|STAT_PARITY
condition|)
block|{
name|int
name|target
init|=
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
decl_stmt|;
if|if
condition|(
operator|++
name|sea
operator|->
name|target
index|[
name|target
index|]
operator|.
name|perrcnt
operator|<
literal|8
condition|)
name|printf
argument_list|(
literal|"sea%d:%d:%d parity error\n"
argument_list|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sea
operator|->
name|target
index|[
name|target
index|]
operator|.
name|perrcnt
operator|==
literal|8
condition|)
name|printf
argument_list|(
literal|"sea%d:%d:%d too many parity errors, not logging any more\n"
argument_list|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sts
operator|&
name|REQ_MASK
condition|)
block|{
case|case
name|REQ_DATAOUT
case|:
if|if
condition|(
name|datalen
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sea%d:%d:%d data length underflow\n"
argument_list|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
operator|*
name|sea
operator|->
name|DATA
operator|=
literal|0
expr_stmt|;
break|break;
block|}
asm|asm ("cld 			1:      movb (%%ebx), %%al 				xorb $1, %%al 				testb $0xf, %%al 				jnz 2f 				testb $0x10, %%al 				jz 1b 				lodsb 				movb %%al, (%%edi) 				loop 1b 			2:" 			: "=S" (data), "=c" (datalen)
comment|/* output */
asm|: "D" (sea->DATA), "b" (sea->STATUS),
comment|/* input */
asm|"0" (data), "1" (datalen) 			: "eax", "ebx", "edi");
comment|/* clobbered */
name|PRINT
argument_list|(
operator|(
literal|"sea%d:%d:%d (DATAOUT) send %ld bytes\n"
operator|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|scb
operator|->
name|datalen
operator|-
name|datalen
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REQ_DATAIN
case|:
if|if
condition|(
name|datalen
operator|<=
literal|0
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"@"
operator|)
argument_list|)
expr_stmt|;
name|sts
operator|=
operator|*
name|sea
operator|->
name|DATA
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|datalen
operator|>=
literal|512
condition|)
block|{
asm|asm ("  cld 				1:      movb (%%esi), %%al 					xorb $5, %%al 					testb $0xf, %%al 					jnz 2f 					testb $0x10, %%al 					jz 1b 					movb (%%ebx), %%al 					stosb 					loop 1b 				2:" 				: "=D" (data), "=c" (datalen)
comment|/* output */
asm|: "b" (sea->DATA), "S" (sea->STATUS), 					"0" (data), "1" (datalen)
comment|/* input */
asm|: "eax", "ebx", "esi");
comment|/* clobbered */
block|}
else|else
block|{
asm|asm ("  cld 				1:      movb (%%esi), %%al 					xorb $5, %%al 					testb $0xf, %%al 					jnz 2f 					testb $0x10, %%al 					jz 1b 					movb (%%ebx), %%al 					stosb 					movb $1000, %%al 				3:      testb $0x10, (%%esi) 					jz 4f 					dec %%al 					jnz 3b 				4:      loop 1b 				2:" 				: "=D" (data), "=c" (datalen)
comment|/* output */
asm|: "b" (sea->DATA), "S" (sea->STATUS), 					"0" (data), "1" (datalen)
comment|/* input */
asm|: "eax", "ebx", "esi");
comment|/* clobbered */
block|}
name|PRINT
argument_list|(
operator|(
literal|"sea%d:%d:%d (DATAIN) got %ld bytes\n"
operator|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|scb
operator|->
name|datalen
operator|-
name|datalen
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REQ_CMDOUT
case|:
name|sea_cmd_output
argument_list|(
name|sea
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|scb
operator|->
name|xfer
operator|->
name|cmd
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|REQ_STATIN
case|:
name|scb
operator|->
name|xfer
operator|->
name|status
operator|=
operator|*
name|sea
operator|->
name|DATA
expr_stmt|;
name|WAITREQ
argument_list|(
name|t
argument_list|,
name|statin
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d:%d:%d (STATIN) got 0x%x\n"
operator|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|,
operator|(
name|u_char
operator|)
name|scb
operator|->
name|xfer
operator|->
name|status
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REQ_MSGOUT
case|:
operator|*
name|sea
operator|->
name|DATA
operator|=
name|MSG_NOP
expr_stmt|;
name|sea_wait_for_req_deassert
argument_list|(
name|sea
argument_list|,
literal|1000
argument_list|,
literal|"MSGOUT"
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d:%d:%d (MSGOUT) send NOP\n"
operator|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REQ_MSGIN
case|:
comment|/* Don't handle multi-byte messages here, because they 			 * should not be present here. */
name|msg
operator|=
operator|*
name|sea
operator|->
name|DATA
expr_stmt|;
name|sea_wait_for_req_deassert
argument_list|(
name|sea
argument_list|,
literal|2000
argument_list|,
literal|"MSGIN"
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d:%d:%d (MSGIN) got 0x%x\n"
operator|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
condition|)
block|{
case|case
name|MSG_COMMAND_COMPLETE
case|:
name|scb
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|MSG_ABORT
case|:
name|printf
argument_list|(
literal|"sea: command aborted by target\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ABORTED
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|MSG_DISCONNECT
case|:
name|scb
operator|->
name|next
operator|=
name|sea
operator|->
name|disconnected_queue
expr_stmt|;
name|sea
operator|->
name|disconnected_queue
operator|=
name|scb
expr_stmt|;
name|sea
operator|->
name|connected
operator|=
literal|0
expr_stmt|;
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|sea
operator|->
name|parity
expr_stmt|;
if|if
condition|(
operator|!
name|sea
operator|->
name|irq
operator|&&
operator|!
name|sea
operator|->
name|timeout_active
condition|)
block|{
name|timeout
argument_list|(
name|sea_tick
argument_list|,
name|sea
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sea
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
block|}
return|return;
case|case
name|MSG_SAVE_POINTERS
case|:
name|scb
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
break|break;
case|case
name|MSG_RESTORE_POINTERS
case|:
name|data
operator|=
name|scb
operator|->
name|data
expr_stmt|;
name|datalen
operator|=
name|scb
operator|->
name|datalen
expr_stmt|;
break|break;
case|case
name|MSG_MESSAGE_REJECT
case|:
name|PRINT
argument_list|(
operator|(
literal|"sea: message_reject received\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"sea%d:%d:%d unknown message: 0x%x\n"
argument_list|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"sea: unknown phase: %b\n"
argument_list|,
name|sts
operator|&
name|REQ_MASK
argument_list|,
name|STAT_BITS
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"sea%d:%d:%d unexpected target disconnect\n"
argument_list|,
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ERROR
expr_stmt|;
name|done
label|:
name|sea
operator|->
name|connected
operator|=
literal|0
expr_stmt|;
name|CLEAR_BUSY
argument_list|(
name|sea
argument_list|,
name|scb
argument_list|)
expr_stmt|;
operator|*
name|sea
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|sea
operator|->
name|parity
expr_stmt|;
name|sea_done
argument_list|(
name|sea
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSEA */
end_comment

end_unit

