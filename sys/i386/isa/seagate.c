begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * (Free/Net/386)BSD ST01/02, Future Domain TMC-885, TMC-950 SCSI driver for  * Julians SCSI-code  *  * Copyright 1994, Kent Palmkvist (kentp@isy.liu.se)  * Copyright 1994, Robert Knier (rknier@qgraph.com)  * Copyright 1992, 1994 Drew Eckhardt (drew@colorado.edu)  * Copyright 1994, Julian Elischer (julian@tfs.com)  * Copyright 1994-1995, Serge Vakulenko (vak@cronyx.ru)  * Copyright 1995 Stephen Hocking (sysseh@devetir.qld.gov.au)  *  * Others that has contributed by example code is  * 		Glen Overby (overby@cray.com)  *		Tatu Yllnen  *		Brian E Litzinger  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE DEVELOPERS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE DEVELOPERS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * kentp  940307 alpha version based on newscsi-03 version of Julians SCSI-code  * kentp  940314 Added possibility to not use messages  * rknier 940331 Added fast transfer code  * rknier 940407 Added assembler coded data transfers  * vak    941226 New probe algorithm, based on expected behaviour  *               instead of BIOS signatures analysis, better timeout handling,  *               new asm fragments for data input/output, target-dependent  *               delays, device flags, polling mode, generic cleanup  * vak    950115 Added request-sense ops  * seh    950701 Fixed up Future Domain TMC-885 problems with disconnects,  *               weird phases and the like. (we could probably investigate  *               what the board's idea of the phases are, but that requires  *               doco that I don't have). Note that it is slower than the  *               2.0R driver with both SEA_BLINDTRANSFER& SEA_ASSEMBLER  *               defined by a factor of more than 2. I'll look at that later!  * seh    950712 The performance release 8^). Put in the blind transfer code  *               from the 2.0R source. Don't use it by commenting out the   *               SEA_BLINDTRANSFER below. Note that it only kicks in during  *               DATAOUT or DATAIN and then only when the transfer is a  *               multiple of BLOCK_SIZE bytes (512). Most devices fit into  *               that category, with the possible exception of scanners and  *               some of the older MO drives.  *  * $Id: seagate.c,v 1.25 1997/08/25 23:06:29 bde Exp $  */
end_comment

begin_comment
comment|/*  * What should really be done:  *  * Restructure interrupt enable/disable code (runs too long with int disabled)  * Add code to handle Future Domain 840, 841, 880 and 881  * Add code to use tagged commands in SCSI2  * Add code to handle slow devices better (sleep if device not disconnecting)  * Fix unnecessary interrupts  */
end_comment

begin_comment
comment|/* Note to users trying to share a disk between DOS and unix:  * The ST01/02 is a translating host-adapter. It is not giving DOS  * the same number of heads/tracks/sectors as specified by the disk.  * It is therefore important to look at what numbers DOS thinks the  * disk has. Use these to disklabel your disk in an appropriate manner  *  * About ST02+IDE coexistence: the original Seagate ST02  * BIOS cannot coexist with IDE or any other disk controller  * because it does not share BIOS disk drive numbers (80h, 81h)  * with others.  New probing code allows using ST02 controller  * without BIOS: just unplug the ST02 BIOS chip from the board.  *  * Another problem is the floppy adapter on ST02 which could not be  * disabled by jumpers.  I commonly use ST02 adapter as a cheap solution  * for atttaching the tape and CD-ROM drives, and an extra floppy controller  * is just a headache.  I found a simple workaround: cutting off  * the AEN signal (A11 contact on ISA connector).  AEN then goes high and  * disables the floppy adapter port address decoder.  *  * I also had a problem with ST02 conflicting with IDE during  * IDE data write phase.  It seems than ST02 makes some noise  * on /IOW line.  The /IOW line is used only for floppy controller  * part of ST02, and because I don't need it, I cut off the /IOW (contact B13)  * and it helped. (vak)  *  * Tested on the following hardware:  *   Adapter: Seagate ST02  *      Disk: HP D1686  * Streamers: Archive Viper 150, Wangtek 5525  *   CD-ROMs: Toshiba XM-3401, NEC CDR-25  *  * Maximum data rate is about 270-280 kbytes/sec (on 386DX/40).  * (vak)  */
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_include
include|#
directive|include
file|"sea.h"
end_include

begin_if
if|#
directive|if
name|NSEA
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|"ioconf.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|PRINT
parameter_list|(
name|s
parameter_list|)
value|printf s
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PRINT
parameter_list|(
name|s
parameter_list|)
end_define

begin_comment
comment|/*void*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SCB_TABLE_SIZE
value|8
end_define

begin_comment
comment|/* start with 8 scb entries in table */
end_comment

begin_define
define|#
directive|define
name|BLOCK_SIZE
value|512
end_define

begin_comment
comment|/* size of READ/WRITE areas on SCSI card */
end_comment

begin_define
define|#
directive|define
name|HOST_SCSI_ADDR
value|7
end_define

begin_comment
comment|/* address of the adapter on the SCSI bus */
end_comment

begin_define
define|#
directive|define
name|SEA_BLINDTRANSFER
value|1
end_define

begin_comment
comment|/* for quicker than quick xfers */
end_comment

begin_comment
comment|/*  * Define config flags  */
end_comment

begin_define
define|#
directive|define
name|FLAG_NOPARITY
value|0x01
end_define

begin_comment
comment|/* disable SCSI bus parity check */
end_comment

begin_comment
comment|/*  * Board CONTROL register  */
end_comment

begin_define
define|#
directive|define
name|CMD_RST
value|0x01
end_define

begin_comment
comment|/* scsi reset */
end_comment

begin_define
define|#
directive|define
name|CMD_SEL
value|0x02
end_define

begin_comment
comment|/* scsi select */
end_comment

begin_define
define|#
directive|define
name|CMD_BSY
value|0x04
end_define

begin_comment
comment|/* scsi busy */
end_comment

begin_define
define|#
directive|define
name|CMD_ATTN
value|0x08
end_define

begin_comment
comment|/* scsi attention */
end_comment

begin_define
define|#
directive|define
name|CMD_START_ARB
value|0x10
end_define

begin_comment
comment|/* start arbitration bit */
end_comment

begin_define
define|#
directive|define
name|CMD_EN_PARITY
value|0x20
end_define

begin_comment
comment|/* enable scsi parity generation */
end_comment

begin_define
define|#
directive|define
name|CMD_INTR
value|0x40
end_define

begin_comment
comment|/* enable scsi interrupts */
end_comment

begin_define
define|#
directive|define
name|CMD_DRVR_ENABLE
value|0x80
end_define

begin_comment
comment|/* scsi enable */
end_comment

begin_comment
comment|/*  * Board STATUS register  */
end_comment

begin_define
define|#
directive|define
name|STAT_BSY
value|0x01
end_define

begin_comment
comment|/* scsi busy */
end_comment

begin_define
define|#
directive|define
name|STAT_MSG
value|0x02
end_define

begin_comment
comment|/* scsi msg */
end_comment

begin_define
define|#
directive|define
name|STAT_IO
value|0x04
end_define

begin_comment
comment|/* scsi I/O */
end_comment

begin_define
define|#
directive|define
name|STAT_CD
value|0x08
end_define

begin_comment
comment|/* scsi C/D */
end_comment

begin_define
define|#
directive|define
name|STAT_REQ
value|0x10
end_define

begin_comment
comment|/* scsi req */
end_comment

begin_define
define|#
directive|define
name|STAT_SEL
value|0x20
end_define

begin_comment
comment|/* scsi select */
end_comment

begin_define
define|#
directive|define
name|STAT_PARITY
value|0x40
end_define

begin_comment
comment|/* parity error bit */
end_comment

begin_define
define|#
directive|define
name|STAT_ARB_CMPL
value|0x80
end_define

begin_comment
comment|/* arbitration complete bit */
end_comment

begin_define
define|#
directive|define
name|STAT_BITS
value|"\20\1bsy\2msg\3i/o\4c/d\5req\6sel\7parity\10arb"
end_define

begin_comment
comment|/*  * SCSI bus phases  */
end_comment

begin_define
define|#
directive|define
name|PHASE_MASK
value|(STAT_MSG | STAT_CD | STAT_IO)
end_define

begin_define
define|#
directive|define
name|PHASE_DATAOUT
value|0
end_define

begin_define
define|#
directive|define
name|PHASE_DATAIN
value|STAT_IO
end_define

begin_define
define|#
directive|define
name|PHASE_CMDOUT
value|STAT_CD
end_define

begin_define
define|#
directive|define
name|PHASE_STATIN
value|(STAT_CD | STAT_IO)
end_define

begin_define
define|#
directive|define
name|PHASE_MSGOUT
value|(STAT_MSG | STAT_CD)
end_define

begin_define
define|#
directive|define
name|PHASE_MSGIN
value|(STAT_MSG | STAT_CD | STAT_IO)
end_define

begin_define
define|#
directive|define
name|PHASE_NAME
parameter_list|(
name|ph
parameter_list|)
value|phase_name[(ph)>>2]
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|phase_name
index|[]
init|=
block|{
literal|"DATAOUT"
block|,
literal|"Phase1?"
block|,
literal|"Phase2?"
block|,
literal|"Phase3?"
block|,
literal|"DATAIN"
block|,
literal|"Phase5?"
block|,
literal|"Phase6?"
block|,
literal|"Phase7?"
block|,
literal|"CMDOUT"
block|,
literal|"Phase9?"
block|,
literal|"MSGOUT"
block|,
literal|"Phase11?"
block|,
literal|"STATIN"
block|,
literal|"Phase13?"
block|,
literal|"MSGIN"
block|,
literal|"Phase15?"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * SCSI message codes  */
end_comment

begin_define
define|#
directive|define
name|MSG_COMMAND_COMPLETE
value|0x00
end_define

begin_define
define|#
directive|define
name|MSG_SAVE_POINTERS
value|0x02
end_define

begin_define
define|#
directive|define
name|MSG_RESTORE_POINTERS
value|0x03
end_define

begin_define
define|#
directive|define
name|MSG_DISCONNECT
value|0x04
end_define

begin_define
define|#
directive|define
name|MSG_ABORT
value|0x06
end_define

begin_define
define|#
directive|define
name|MSG_MESSAGE_REJECT
value|0x07
end_define

begin_define
define|#
directive|define
name|MSG_NOP
value|0x08
end_define

begin_define
define|#
directive|define
name|MSG_BUS_DEV_RESET
value|0x0c
end_define

begin_define
define|#
directive|define
name|MSG_IDENTIFY
parameter_list|(
name|lun
parameter_list|)
value|(0xc0 | ((lun)& 0x7))
end_define

begin_define
define|#
directive|define
name|MSG_ISIDENT
parameter_list|(
name|m
parameter_list|)
value|((m)& 0x80)
end_define

begin_comment
comment|/*  * SCSI control block used to keep info about a scsi command  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|scb
block|{
name|int
name|flags
decl_stmt|;
comment|/* status of the instruction */
define|#
directive|define
name|SCB_FREE
value|0x00
define|#
directive|define
name|SCB_ACTIVE
value|0x01
define|#
directive|define
name|SCB_ABORTED
value|0x02
define|#
directive|define
name|SCB_TIMEOUT
value|0x04
define|#
directive|define
name|SCB_ERROR
value|0x08
define|#
directive|define
name|SCB_TIMECHK
value|0x10
comment|/* we have set a timeout on this one */
define|#
directive|define
name|SCB_SENSE
value|0x20
comment|/* sensed data available */
define|#
directive|define
name|SCB_TBUSY
value|0x40
comment|/* target busy */
name|struct
name|scb
modifier|*
name|next
decl_stmt|;
comment|/* in free list */
name|struct
name|scsi_xfer
modifier|*
name|xfer
decl_stmt|;
comment|/* the scsi_xfer for this cmd */
name|u_char
modifier|*
name|data
decl_stmt|;
comment|/* position in data buffer so far */
name|int32_t
name|datalen
decl_stmt|;
comment|/* bytes remaining to transfer */
block|}
name|scb_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CTLR_NONE
block|,
name|CTLR_SEAGATE
block|,
name|CTLR_FUTURE_DOMAIN
block|}
name|ctlr_t
typedef|;
end_typedef

begin_comment
comment|/*  * Flags for waiting for REQ deassert during some SCSI bus phases.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|cmdout1
range|:
literal|1
decl_stmt|;
comment|/* after CMDOUT[0] byte */
name|unsigned
name|cmdout
range|:
literal|1
decl_stmt|;
comment|/* after CMDOUT[1..N] bytes */
name|unsigned
name|msgout
range|:
literal|1
decl_stmt|;
comment|/* after MSGOUT byte */
name|unsigned
name|statin
range|:
literal|1
decl_stmt|;
comment|/* after STATIN byte */
block|}
name|phase_t
typedef|;
end_typedef

begin_comment
comment|/*  * Data structure describing the target state.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|adapter
modifier|*
name|adapter
decl_stmt|;
comment|/* pointer to the adapter structure */
name|u_char
name|busy
decl_stmt|;
comment|/* mask of busy luns at device target */
name|u_long
name|perrcnt
decl_stmt|;
comment|/* counter of target parity errors */
name|phase_t
name|ndelay
decl_stmt|;
comment|/* "don't delay" flags */
name|phase_t
name|init
decl_stmt|;
comment|/* "initialized" flags */
block|}
name|target_t
typedef|;
end_typedef

begin_comment
comment|/*  * Data structure describing current status of the scsi bus. One for each  * controller card.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|adapter
block|{
name|ctlr_t
name|type
decl_stmt|;
comment|/* Seagate or Future Domain */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* adapter name */
specifier|volatile
name|u_char
modifier|*
name|addr
decl_stmt|;
comment|/* base address for card */
specifier|volatile
name|u_char
modifier|*
name|CONTROL
decl_stmt|;
comment|/* address of control register */
specifier|volatile
name|u_char
modifier|*
name|STATUS
decl_stmt|;
comment|/* address of status register */
specifier|volatile
name|u_char
modifier|*
name|DATA
decl_stmt|;
comment|/* address of data register */
name|u_char
name|scsi_addr
decl_stmt|;
comment|/* our scsi address, 0..7 */
name|u_char
name|scsi_id
decl_stmt|;
comment|/* our scsi id mask */
name|u_char
name|parity
decl_stmt|;
comment|/* parity flag: CMD_EN_PARITY or 0 */
name|u_char
name|irq
decl_stmt|;
comment|/* IRQ number used or 0 if no IRQ */
name|u_int
name|timeout_active
range|:
literal|1
decl_stmt|;
comment|/* timeout() active (requested) */
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
comment|/* struct connecting different data */
name|scb_t
modifier|*
name|queue
decl_stmt|;
comment|/* waiting to be issued */
name|scb_t
modifier|*
name|disconnected_queue
decl_stmt|;
comment|/* waiting to reconnect */
name|int
name|numscb
decl_stmt|;
comment|/* number of scsi control blocks */
name|scb_t
modifier|*
name|free_scb
decl_stmt|;
comment|/* free scb list */
name|scb_t
name|scbs
index|[
name|SCB_TABLE_SIZE
index|]
decl_stmt|;
name|target_t
name|target
index|[
literal|8
index|]
decl_stmt|;
comment|/* target state data */
block|}
name|adapter_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|adapter_t
name|seadata
index|[
name|NSEA
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_BUSY
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)->target[(b)->xfer->sc_link->target].busy&\ 				(1<< (b)->xfer->sc_link->lun))
end_define

begin_define
define|#
directive|define
name|SET_BUSY
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)->target[(b)->xfer->sc_link->target].busy |=\ 				(1<< (b)->xfer->sc_link->lun))
end_define

begin_define
define|#
directive|define
name|CLEAR_BUSY
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)->target[(b)->xfer->sc_link->target].busy&=\ 				~(1<< (b)->xfer->sc_link->lun))
end_define

begin_comment
comment|/*  * Wait for condition, given as an boolean expression.  * Print the message on timeout.  */
end_comment

begin_define
define|#
directive|define
name|WAITFOR
parameter_list|(
name|condition
parameter_list|,
name|message
parameter_list|)
value|{\ 	register u_long cnt = 100000; char *msg = message;\ 	while (cnt--&& ! (condition)) continue;\ 	if (cnt == -1&& msg)\ 		printf ("sea: %s timeout\n", msg); }
end_define

begin_define
define|#
directive|define
name|WAITFOR10
parameter_list|(
name|condition
parameter_list|,
name|message
parameter_list|)
value|{\ 	register u_long cnt = 1000000; char *msg = message;\ 	while (cnt--&& ! (condition)) continue;\ 	if (cnt == -1&& msg)\ 		printf ("sea: %s timeout\n", msg); }
end_define

begin_comment
comment|/*  * Seagate adapter does not support in hardware  * waiting for REQ deassert after transferring each data byte.  * We must do it in software.  * The problem is that some SCSI devices deassert REQ so fast that  * we can miss it.  We the flag for each target sayind if we should (not)  * wait for REQ deassert.  This flag is initialized when the first  * operation on the target is done.  * 1) Test if we don't need to wait for REQ deassert (`nodelay' flag).  *    Initially the flag is off, i.e. wait.  If the flag is set,  *    go to the step 4.  * 2) Wait for REQ deassert (call sea_wait_for_req_deassert function).  *    If REQ deassert got, go to the step 4.  If REQ did not cleared  *    during timeout period, go to the next step.  * 3) If `nodelay' flag did not initialized yet (`init' flag),  *    then set `ndelay' flag.  * 4) Set `init' flag.  Done.  */
end_comment

begin_define
define|#
directive|define
name|WAITREQ
parameter_list|(
name|t
parameter_list|,
name|op
parameter_list|,
name|cnt
parameter_list|)
value|{\ 	if (! (t)->ndelay.op&&\ 	    ! sea_wait_for_req_deassert ((t)->adapter, cnt, #op)&&\ 	    ! (t)->init.op)\ 		(t)->ndelay.op = 1;\ 	(t)->init.op = 1; }
end_define

begin_function_decl
specifier|static
name|int
name|sea_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sea_detect
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sea_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|sea_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|sea_adapter_info
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sea_timeout
parameter_list|(
name|void
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seaminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sea_done
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sea_start
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sea_information_transfer
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sea_poll
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sea_init
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sea_reselect
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sea_select
parameter_list|(
specifier|volatile
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sea_abort
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sea_send_abort
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
name|sea_msg_input
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sea_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sea_sense
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sea_data_output
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|u_char
modifier|*
modifier|*
name|pdata
parameter_list|,
name|u_long
modifier|*
name|plen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sea_data_input
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|u_char
modifier|*
modifier|*
name|pdata
parameter_list|,
name|u_long
modifier|*
name|plen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sea_cmd_output
parameter_list|(
name|target_t
modifier|*
name|z
parameter_list|,
name|u_char
modifier|*
name|cmd
parameter_list|,
name|int
name|cmdlen
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|sea_switch
init|=
block|{
name|sea_scsi_cmd
block|,
name|seaminphys
block|,
literal|0
block|,
literal|0
block|,
name|sea_adapter_info
block|,
literal|"sea"
block|,
block|{
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|sea_dev
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"sea"
block|,
literal|0
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|seadriver
init|=
block|{
name|sea_probe
block|,
name|sea_attach
block|,
literal|"sea"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FD TMC885's can't handle detach& re-attach */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sea_select_cmd
init|=
name|CMD_DRVR_ENABLE
operator||
name|CMD_ATTN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check if the device can be found at the port given and if so,  * detect the type of board. Set it up ready for further work.  * Takes the isa_dev structure from autoconf as an argument.  * Returns 1 if card recognized, 0 if errors.  */
end_comment

begin_function
name|int
name|sea_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|adapter_t
modifier|*
name|z
init|=
operator|&
name|seadata
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
specifier|static
specifier|const
name|addrtab
index|[]
operator|=
block|{
literal|0xc8000
block|,
literal|0xca000
block|,
literal|0xcc000
block|,
literal|0xce000
block|,
literal|0xdc000
block|,
literal|0xde000
block|,
literal|0
block|, 	}
expr_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Init fields used by our routines */
name|z
operator|->
name|parity
operator|=
operator|(
name|dev
operator|->
name|id_flags
operator|&
name|FLAG_NOPARITY
operator|)
condition|?
literal|0
else|:
name|CMD_EN_PARITY
expr_stmt|;
name|z
operator|->
name|scsi_addr
operator|=
name|HOST_SCSI_ADDR
expr_stmt|;
name|z
operator|->
name|scsi_id
operator|=
literal|1
operator|<<
name|z
operator|->
name|scsi_addr
expr_stmt|;
name|z
operator|->
name|irq
operator|=
name|dev
operator|->
name|id_irq
condition|?
name|ffs
argument_list|(
name|dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
else|:
literal|0
expr_stmt|;
name|z
operator|->
name|queue
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|disconnected_queue
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|z
operator|->
name|target
index|[
name|i
index|]
operator|.
name|adapter
operator|=
name|z
expr_stmt|;
name|z
operator|->
name|target
index|[
name|i
index|]
operator|.
name|busy
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Link up the free list of scbs */
name|z
operator|->
name|numscb
operator|=
name|SCB_TABLE_SIZE
expr_stmt|;
name|z
operator|->
name|free_scb
operator|=
name|z
operator|->
name|scbs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|SCB_TABLE_SIZE
condition|;
name|i
operator|++
control|)
name|z
operator|->
name|scbs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|z
operator|->
name|scbs
operator|+
name|i
expr_stmt|;
name|z
operator|->
name|scbs
index|[
name|SCB_TABLE_SIZE
operator|-
literal|1
index|]
operator|.
name|next
operator|=
literal|0
expr_stmt|;
comment|/* Detect the adapter. */
name|dev
operator|->
name|id_msize
operator|=
literal|0x4000
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|id_maddr
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|addrtab
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
block|{
name|dev
operator|->
name|id_maddr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|KERNBASE
operator|+
name|addrtab
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sea_detect
argument_list|(
name|z
argument_list|,
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sea_detect
argument_list|(
name|z
argument_list|,
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|bzero
argument_list|(
name|z
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|z
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sea_detect
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|z
operator|->
name|addr
operator|=
name|dev
operator|->
name|id_maddr
expr_stmt|;
comment|/* Try Seagate. */
name|z
operator|->
name|type
operator|=
name|CTLR_SEAGATE
expr_stmt|;
name|z
operator|->
name|name
operator|=
literal|"Seagate ST01/ST02"
expr_stmt|;
name|z
operator|->
name|CONTROL
operator|=
name|z
operator|->
name|addr
operator|+
literal|0x1a00
expr_stmt|;
comment|/* ST01/ST02 register offsets */
name|z
operator|->
name|STATUS
operator|=
name|z
operator|->
name|addr
operator|+
literal|0x1a00
expr_stmt|;
name|z
operator|->
name|DATA
operator|=
name|z
operator|->
name|addr
operator|+
literal|0x1c00
expr_stmt|;
if|if
condition|(
name|sea_init
argument_list|(
name|z
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Try Future Domain. */
name|z
operator|->
name|type
operator|=
name|CTLR_FUTURE_DOMAIN
expr_stmt|;
name|z
operator|->
name|name
operator|=
literal|"Future Domain TMC-885/TMC-950"
expr_stmt|;
name|z
operator|->
name|CONTROL
operator|=
name|z
operator|->
name|addr
operator|+
literal|0x1c00
expr_stmt|;
comment|/* TMC-885/TMC-950 reg. offsets */
name|z
operator|->
name|STATUS
operator|=
name|z
operator|->
name|addr
operator|+
literal|0x1c00
expr_stmt|;
name|z
operator|->
name|DATA
operator|=
name|z
operator|->
name|addr
operator|+
literal|0x1e00
expr_stmt|;
comment|/* FD TMC885's can't handle detach& re-attach */
name|sea_select_cmd
operator|=
name|CMD_DRVR_ENABLE
expr_stmt|;
comment|/* FD TMC-885 is supposed to be at id 6. How strange. */
name|z
operator|->
name|scsi_addr
operator|=
name|HOST_SCSI_ADDR
operator|-
literal|1
expr_stmt|;
name|z
operator|->
name|scsi_id
operator|=
literal|1
operator|<<
name|z
operator|->
name|scsi_addr
expr_stmt|;
if|if
condition|(
name|sea_init
argument_list|(
name|z
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Probe the adapter, and if found, reset the board and the scsi bus.  * Return 0 if the adapter found.  */
end_comment

begin_function
name|int
name|sea_init
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
block|{
specifier|volatile
name|u_char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
comment|/* Check that STATUS..STATUS+200h are equal. */
name|p
operator|=
name|z
operator|->
name|STATUS
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0xff
condition|)
return|return
operator|(
literal|2
operator|)
return|;
while|while
condition|(
operator|++
name|p
operator|<
name|z
operator|->
name|STATUS
operator|+
literal|0x200
condition|)
if|if
condition|(
operator|*
name|p
operator|!=
name|c
condition|)
return|return
operator|(
literal|3
operator|)
return|;
comment|/* Check that DATA..DATA+200h are equal. */
for|for
control|(
name|p
operator|=
name|z
operator|->
name|DATA
operator|,
name|c
operator|=
operator|*
name|p
operator|++
init|;
name|p
operator|<
name|z
operator|->
name|DATA
operator|+
literal|0x200
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|!=
name|c
condition|)
return|return
operator|(
literal|4
operator|)
return|;
comment|/* Check that addr..addr+1800h are not writable. */
for|for
control|(
name|p
operator|=
name|z
operator|->
name|addr
init|;
name|p
operator|<
name|z
operator|->
name|addr
operator|+
literal|0x1800
condition|;
operator|++
name|p
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
operator|~
name|c
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
operator|~
name|c
condition|)
block|{
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|5
operator|)
return|;
block|}
block|}
comment|/* Check that addr+1800h..addr+1880h are writable. */
for|for
control|(
name|p
operator|=
name|z
operator|->
name|addr
operator|+
literal|0x1800
init|;
name|p
operator|<
name|z
operator|->
name|addr
operator|+
literal|0x1880
condition|;
operator|++
name|p
control|)
block|{
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|0x55
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0x55
condition|)
block|{
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|6
operator|)
return|;
block|}
operator|*
name|p
operator|=
literal|0xaa
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0xaa
condition|)
block|{
operator|*
name|p
operator|=
name|c
expr_stmt|;
return|return
operator|(
literal|7
operator|)
return|;
block|}
block|}
comment|/* Reset the scsi bus (I don't know if this is needed). */
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_RST
operator||
name|CMD_DRVR_ENABLE
operator||
name|z
operator|->
name|parity
operator||
name|CMD_INTR
expr_stmt|;
comment|/* Hold reset for at least 25 microseconds. */
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
comment|/* Check that status cleared. */
if|if
condition|(
operator|*
name|z
operator|->
name|STATUS
operator|!=
literal|0
condition|)
block|{
operator|*
name|z
operator|->
name|CONTROL
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|8
operator|)
return|;
block|}
comment|/* Check that DATA register is writable. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|z
operator|->
name|DATA
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|->
name|DATA
operator|!=
name|i
condition|)
block|{
operator|*
name|z
operator|->
name|CONTROL
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|9
operator|)
return|;
block|}
block|}
comment|/* Enable the adapter. */
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|z
operator|->
name|parity
expr_stmt|;
comment|/* Wait a Bus Clear Delay (800 ns + bus free delay 800 ns). */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Check that DATA register is NOT writable. */
name|c
operator|=
operator|*
name|z
operator|->
name|DATA
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|z
operator|->
name|DATA
operator|=
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|->
name|DATA
operator|!=
name|c
condition|)
block|{
operator|*
name|z
operator|->
name|CONTROL
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|10
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach all sub-devices we can find.  */
end_comment

begin_function
name|int
name|sea_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|adapter_t
modifier|*
name|z
init|=
operator|&
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
name|printf
argument_list|(
literal|"\nsea%d: type %s%s\n"
argument_list|,
name|unit
argument_list|,
name|z
operator|->
name|name
argument_list|,
operator|(
name|dev
operator|->
name|id_flags
operator|&
name|FLAG_NOPARITY
operator|)
condition|?
literal|", no parity"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* fill in the prototype scsi_link */
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|unit
expr_stmt|;
name|z
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|z
operator|->
name|scsi_addr
expr_stmt|;
name|z
operator|->
name|sc_link
operator|.
name|adapter_softc
operator|=
name|z
expr_stmt|;
name|z
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|sea_switch
expr_stmt|;
name|z
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|sea_dev
expr_stmt|;
comment|/* 	 * Prepare the scsibus_data area for the upperlevel 	 * scsi code. 	 */
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|z
operator|->
name|sc_link
expr_stmt|;
comment|/* ask the adapter what subunits are present */
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return some information to the caller about  * the adapter and its capabilities.  */
end_comment

begin_function
name|u_int32_t
name|sea_adapter_info
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|seaminphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Catch an interrupt from the adaptor.  */
end_comment

begin_function
name|void
name|seaintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|adapter_t
modifier|*
name|z
init|=
operator|&
name|seadata
index|[
name|unit
index|]
decl_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d: interrupt status=%b\n"
operator|,
name|unit
operator|,
operator|*
name|z
operator|->
name|STATUS
operator|,
name|STAT_BITS
operator|)
argument_list|)
expr_stmt|;
name|sea_start
argument_list|(
name|z
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is used in the case when we have no IRQ line (z->irq == 0).  * It is called every timer tick and polls for reconnect from target.  */
end_comment

begin_function
name|void
name|sea_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|adapter_t
modifier|*
name|z
init|=
name|arg
decl_stmt|;
name|int
name|x
init|=
name|splbio
argument_list|()
decl_stmt|;
name|z
operator|->
name|timeout_active
operator|=
literal|0
expr_stmt|;
name|sea_start
argument_list|(
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|disconnected_queue
operator|&&
operator|!
name|z
operator|->
name|timeout_active
condition|)
block|{
name|timeout
argument_list|(
name|sea_tick
argument_list|,
name|z
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|z
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a scsi operation given the command and the data address.  * Also needs the unit, target and lu.  Get a free scb and set it up.  * Call send_scb.  Either start timer or wait until done.  */
end_comment

begin_function
name|int32_t
name|sea_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|int
name|flags
init|=
name|xs
operator|->
name|flags
decl_stmt|,
name|x
init|=
literal|0
decl_stmt|;
name|adapter_t
modifier|*
name|z
init|=
operator|(
name|adapter_t
operator|*
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|adapter_softc
decl_stmt|;
name|scb_t
modifier|*
name|scb
decl_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d/%d/%d command 0x%x\n"
operator|,
name|unit
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|xs
operator|->
name|cmd
operator|->
name|opcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
name|flags
operator||=
name|SCSI_NOSLEEP
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"sea%d: already done?"
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sea%d: not in use?"
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
name|printf
argument_list|(
literal|"sea%d: SCSI_RESET not implemented\n"
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* Get a free scb. 	 * If we can and have to, sleep waiting for one to come free. */
while|while
condition|(
operator|!
operator|(
name|scb
operator|=
name|z
operator|->
name|free_scb
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|SCSI_NOSLEEP
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|z
operator|->
name|free_scb
argument_list|,
name|PRIBIO
argument_list|,
literal|"seascb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Get scb from free list. */
name|z
operator|->
name|free_scb
operator|=
name|scb
operator|->
name|next
expr_stmt|;
name|scb
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
comment|/* Put all the arguments for the xfer in the scb */
name|scb
operator|->
name|xfer
operator|=
name|xs
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|scb
operator|->
name|data
operator|=
name|xs
operator|->
name|data
expr_stmt|;
comment|/* Setup the scb to contain necessary values. 	 * The interesting values can be read from the xs that is saved. 	 * I therefore think that the structure can be kept very small. 	 * The driver doesn't use DMA so the scatter/gather is not needed? */
if|if
condition|(
operator|!
name|z
operator|->
name|queue
condition|)
block|{
name|scb
operator|->
name|next
operator|=
name|z
operator|->
name|queue
expr_stmt|;
name|z
operator|->
name|queue
operator|=
name|scb
expr_stmt|;
block|}
else|else
block|{
name|scb_t
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|z
operator|->
name|queue
init|;
name|q
operator|->
name|next
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
continue|continue;
name|q
operator|->
name|next
operator|=
name|scb
expr_stmt|;
name|scb
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* placed at the end of the queue */
block|}
comment|/* Try to send this command to the board. */
name|sea_start
argument_list|(
name|z
argument_list|)
expr_stmt|;
comment|/* Usually return SUCCESSFULLY QUEUED. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
comment|/* Timeout timer not started, already finished. 			 * Tried to return COMPLETE but the machine hanged 			 * with this. */
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
name|xs
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|sea_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMECHK
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d/%d/%d command queued\n"
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
comment|/* If we can't use interrupts, poll on completion. */
if|if
condition|(
operator|!
name|sea_poll
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
condition|)
block|{
comment|/* We timed out, so call the timeout handler manually, 		 * accounting for the fact that the clock is not running yet 		 * by taking out the clock queue entry it makes. */
name|sea_timeout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|scb
argument_list|)
expr_stmt|;
comment|/* Because we are polling, take out the timeout entry 		 * sea_timeout made. */
name|untimeout
argument_list|(
name|sea_timeout
argument_list|,
operator|(
name|void
operator|*
operator|)
name|scb
argument_list|,
name|xs
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sea_poll
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
condition|)
comment|/* We timed out again... This is bad. Notice that 			 * this time there is no clock queue entry to remove. */
name|sea_timeout
argument_list|(
operator|(
name|void
operator|*
operator|)
name|scb
argument_list|)
expr_stmt|;
block|}
name|PRINT
argument_list|(
operator|(
literal|"sea%d/%d/%d command %s\n"
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|xs
operator|->
name|error
condition|?
literal|"failed"
else|:
literal|"done"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|xs
operator|->
name|error
condition|?
name|HAD_ERROR
else|:
name|COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Coroutine that runs as long as more work can be done.  * Both scsi_cmd() and intr() will try to start it in  * case it is not running.  * Always called with interrupts disabled.  */
end_comment

begin_function
name|void
name|sea_start
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
block|{
name|scb_t
modifier|*
name|q
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|again
label|:
comment|/* First check that if any device has tried 	 * a reconnect while we have done other things 	 * with interrupts disabled. */
if|if
condition|(
name|sea_reselect
argument_list|(
name|z
argument_list|)
condition|)
goto|goto
name|again
goto|;
comment|/* Search through the queue for a command 	 * destined for a target that's not busy. */
for|for
control|(
name|q
operator|=
name|z
operator|->
name|queue
operator|,
name|prev
operator|=
literal|0
init|;
name|q
condition|;
name|prev
operator|=
name|q
operator|,
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
comment|/* Attempt to establish an I_T_L nexus here. */
if|if
condition|(
name|IS_BUSY
argument_list|(
name|z
argument_list|,
name|q
argument_list|)
operator|||
operator|!
name|sea_select
argument_list|(
name|z
argument_list|,
name|q
argument_list|)
condition|)
continue|continue;
comment|/* Remove the command from the issue queue. */
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
else|else
name|z
operator|->
name|queue
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* We are connected. Do the task. */
name|sea_information_transfer
argument_list|(
name|z
argument_list|,
name|q
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
end_function

begin_function
name|void
name|sea_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|scb_t
modifier|*
name|scb
init|=
operator|(
name|scb_t
operator|*
operator|)
name|arg
decl_stmt|;
name|adapter_t
modifier|*
name|z
init|=
operator|(
name|adapter_t
operator|*
operator|)
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|adapter_softc
decl_stmt|;
name|int
name|x
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|xfer
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|printf
argument_list|(
literal|"sea%d/%d/%d (%s%d) timed out\n"
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|dev_unit
argument_list|)
expr_stmt|;
comment|/* If it has been through before, then a previous abort has failed, 	 * don't try abort again. */
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORTED
operator|)
condition|)
block|{
name|sea_abort
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 2 seconds for the abort */
name|scb
operator|->
name|xfer
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|sea_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
operator|(
name|SCB_ABORTED
operator||
name|SCB_TIMECHK
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort timed out */
name|scb
operator|->
name|flags
operator||=
name|SCB_ABORTED
expr_stmt|;
name|scb
operator|->
name|xfer
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
name|sea_done
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait until REQ goes down.  This is needed for some devices (CDROMs)  * after every MSGOUT, MSGIN, CMDOUT, STATIN request.  * Return true if REQ deassert found.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|sea_wait_for_req_deassert
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|int
name|cnt
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
asm|asm (" 	1:      testb $0x10, %2 		jz 2f 		loop 1b 	2:" 	: "=c" (cnt)
comment|/* output */
asm|: "0" (cnt), "m" (*z->STATUS));
comment|/* input */
if|if
condition|(
operator|!
name|cnt
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"sea%d (%s) timeout waiting for !REQ\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* PRINT (("sea_wait_for_req_deassert %s count=%d\n", msg, cnt)); */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Establish I_T_L or I_T_L_Q nexus for new or existing command  * including ARBITRATION, SELECTION, and initial message out  * for IDENTIFY and queue messages.  * Return 1 if selection succeded.  */
end_comment

begin_function
name|int
name|sea_select
parameter_list|(
specifier|volatile
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
block|{
comment|/* Start arbitration. */
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|z
operator|->
name|parity
operator||
name|CMD_INTR
expr_stmt|;
operator|*
name|z
operator|->
name|DATA
operator|=
name|z
operator|->
name|scsi_id
expr_stmt|;
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_START_ARB
operator||
name|z
operator|->
name|parity
expr_stmt|;
comment|/* Wait for arbitration to complete. */
name|WAITFOR
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_ARB_CMPL
argument_list|,
literal|"arbitration"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_ARB_CMPL
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_SEL
condition|)
block|{
name|printf
argument_list|(
literal|"sea: arbitration lost\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ERROR
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"sea: arbitration timeout\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMEOUT
expr_stmt|;
block|}
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|z
operator|->
name|parity
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|*
name|z
operator|->
name|DATA
operator|=
operator|(
literal|1
operator|<<
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|)
operator||
name|z
operator|->
name|scsi_id
expr_stmt|;
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|sea_select_cmd
operator||
name|CMD_SEL
operator||
name|z
operator|->
name|parity
expr_stmt|;
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Wait for a bsy from target. 	 * If the target is not present on the bus, we get 	 * the timeout.  Don't PRINT any message -- it's not an error. */
name|WAITFOR
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_BSY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_BSY
operator|)
condition|)
block|{
comment|/* The target does not respond.  Not an error, though. */
name|PRINT
argument_list|(
operator|(
literal|"sea%d/%d/%d target does not respond\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|z
operator|->
name|parity
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMEOUT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Try to make the target to take a message from us. 	 * Should start a MSGOUT phase. */
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|sea_select_cmd
operator||
name|z
operator|->
name|parity
expr_stmt|;
name|DELAY
argument_list|(
literal|15
argument_list|)
expr_stmt|;
name|WAITFOR
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|CTLR_FUTURE_DOMAIN
condition|)
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|z
operator|->
name|parity
operator||
name|CMD_DRVR_ENABLE
expr_stmt|;
name|WAITFOR
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
operator|)
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"sea%d/%d/%d timeout waiting for REQ\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ERROR
expr_stmt|;
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|z
operator|->
name|parity
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check for phase mismatch. FD 885 always seems to get this wrong! */
if|if
condition|(
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_MSGOUT
operator|&&
name|z
operator|->
name|type
operator|!=
name|CTLR_FUTURE_DOMAIN
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"sea%d/%d/%d waiting for MSGOUT: invalid phase %s\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|PHASE_NAME
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|PHASE_MASK
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ERROR
expr_stmt|;
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|z
operator|->
name|parity
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Allow disconnects. (except for FD controllers) */
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|CTLR_SEAGATE
condition|)
block|{
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_DRVR_ENABLE
operator||
name|z
operator|->
name|parity
expr_stmt|;
operator|*
name|z
operator|->
name|DATA
operator|=
name|MSG_IDENTIFY
argument_list|(
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
name|WAITREQ
argument_list|(
operator|&
name|z
operator|->
name|target
index|[
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
index|]
argument_list|,
name|msgout
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
block|}
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|CMD_DRVR_ENABLE
operator||
name|z
operator|->
name|parity
expr_stmt|;
name|SET_BUSY
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sea_reselect
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
block|{
name|scb_t
modifier|*
name|q
init|=
literal|0
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|u_char
name|msg
decl_stmt|,
name|target_mask
decl_stmt|,
name|lun
decl_stmt|;
name|again
label|:
comment|/* Wait for a device to win the reselection phase. */
comment|/* Signals this by asserting the I/O signal. */
if|if
condition|(
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator||
name|STAT_BSY
operator|)
operator|)
operator|!=
operator|(
name|STAT_SEL
operator||
name|STAT_IO
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The data bus contains original initiator id ORed with target id. */
comment|/* See that we really are the initiator. */
name|target_mask
operator|=
operator|*
name|z
operator|->
name|DATA
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|target_mask
operator|&
name|z
operator|->
name|scsi_id
operator|)
condition|)
block|{
name|PRINT
argument_list|(
operator|(
literal|"sea%d reselect not for me: mask=0x%x, status=%b\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|target_mask
operator|,
operator|*
name|z
operator|->
name|STATUS
operator|,
name|STAT_BITS
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* Find target who won. */
comment|/* Host responds by asserting the BSY signal. */
comment|/* Target should respond by deasserting the SEL signal. */
name|target_mask
operator|&=
operator|~
name|z
operator|->
name|scsi_id
expr_stmt|;
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_DRVR_ENABLE
operator||
name|CMD_BSY
operator||
name|z
operator|->
name|parity
operator||
name|CMD_INTR
expr_stmt|;
name|WAITFOR
argument_list|(
operator|!
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_SEL
operator|)
argument_list|,
literal|"reselection acknowledge"
argument_list|)
expr_stmt|;
comment|/* Remove the busy status. */
comment|/* Target should set the MSGIN phase. */
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|CMD_DRVR_ENABLE
operator||
name|z
operator|->
name|parity
expr_stmt|;
name|WAITFOR
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
argument_list|,
literal|"identify message"
argument_list|)
expr_stmt|;
comment|/* Hope we get an IDENTIFY message. */
name|msg
operator|=
name|sea_msg_input
argument_list|(
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|MSG_ISIDENT
argument_list|(
name|msg
argument_list|)
condition|)
block|{
comment|/* Find the command corresponding to the I_T_L or I_T_L_Q 		 * nexus we just restablished, and remove it from 		 * the disconnected queue. */
name|lun
operator|=
operator|(
name|msg
operator|&
literal|7
operator|)
expr_stmt|;
for|for
control|(
name|q
operator|=
name|z
operator|->
name|disconnected_queue
init|;
name|q
condition|;
name|prev
operator|=
name|q
operator|,
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|target_mask
operator|!=
operator|(
literal|1
operator|<<
name|q
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|)
condition|)
continue|continue;
if|if
condition|(
name|lun
operator|!=
name|q
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
condition|)
continue|continue;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|q
operator|->
name|next
expr_stmt|;
else|else
name|z
operator|->
name|disconnected_queue
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d/%d/%d reselect done\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|ffs
argument_list|(
name|target_mask
argument_list|)
operator|-
literal|1
operator|,
name|lun
operator|)
argument_list|)
expr_stmt|;
name|sea_information_transfer
argument_list|(
name|z
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|WAITFOR
argument_list|(
operator|!
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_BSY
operator|)
argument_list|,
literal|"reselect !busy"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"sea%d reselect: expecting IDENTIFY, got 0x%x\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* Since we have an established nexus that we can't 	 * do anything with, we must abort it. */
name|sea_send_abort
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d reselect aborted\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|)
argument_list|)
expr_stmt|;
name|WAITFOR
argument_list|(
operator|!
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_BSY
operator|)
argument_list|,
literal|"bus free after reselect abort"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
end_function

begin_comment
comment|/*  * Send an abort to the target.  * Return 1 success, 0 on failure.  * Called on splbio level.  */
end_comment

begin_function
name|int
name|sea_abort
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
block|{
name|scb_t
modifier|*
name|q
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
comment|/* If the command hasn't been issued yet, we simply remove it 	 * from the issue queue. */
name|prev
operator|=
operator|&
name|z
operator|->
name|queue
expr_stmt|;
for|for
control|(
name|q
operator|=
name|z
operator|->
name|queue
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|scb
operator|==
name|q
condition|)
block|{
operator|(
operator|*
name|prev
operator|)
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|next
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|prev
operator|=
operator|&
name|q
operator|->
name|next
expr_stmt|;
block|}
comment|/* If the command is currently disconnected from the bus, 	 * we reconnect the I_T_L or I_T_L_Q nexus associated with it, 	 * go into message out, and send an abort message. */
for|for
control|(
name|q
operator|=
name|z
operator|->
name|disconnected_queue
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|scb
operator|!=
name|q
condition|)
continue|continue;
if|if
condition|(
operator|!
name|sea_select
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sea_send_abort
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|prev
operator|=
operator|&
name|z
operator|->
name|disconnected_queue
expr_stmt|;
for|for
control|(
name|q
operator|=
name|z
operator|->
name|disconnected_queue
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|next
control|)
block|{
if|if
condition|(
name|scb
operator|==
name|q
condition|)
block|{
operator|*
name|prev
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|q
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* Set some type of error result 				 * for the operation. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|prev
operator|=
operator|&
name|q
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* Command not found in any queue. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The task accomplished, mark the i/o control block as done.  * Always called with interrupts disabled.  */
end_comment

begin_function
name|void
name|sea_done
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|scb
operator|->
name|xfer
decl_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TIMECHK
condition|)
name|untimeout
argument_list|(
name|sea_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
name|xs
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
comment|/* How much of the buffer was not touched. */
name|xs
operator|->
name|resid
operator|=
name|scb
operator|->
name|datalen
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|!=
name|SCB_ACTIVE
operator|&&
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
condition|)
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
operator|(
name|SCB_TIMEOUT
operator||
name|SCB_ABORTED
operator|)
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ERROR
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TBUSY
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
comment|/* Free the control block. */
name|scb
operator|->
name|next
operator|=
name|z
operator|->
name|free_scb
expr_stmt|;
name|z
operator|->
name|free_scb
operator|=
name|scb
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_FREE
expr_stmt|;
comment|/* If there were none, wake anybody waiting for one to come free, 	 * starting with queued entries. */
if|if
condition|(
operator|!
name|scb
operator|->
name|next
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|z
operator|->
name|free_scb
argument_list|)
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for completion of command in polled mode.  * Always called with interrupts masked out.  */
end_comment

begin_function
name|int
name|sea_poll
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|30
condition|;
operator|++
name|count
control|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* delay for a while */
name|sea_start
argument_list|(
name|z
argument_list|)
expr_stmt|;
comment|/* retry operation */
if|if
condition|(
name|scb
operator|->
name|xfer
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* all is done */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TIMEOUT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* no target present */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send data to the target.  */
end_comment

begin_function
name|void
name|sea_data_output
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|u_char
modifier|*
modifier|*
name|pdata
parameter_list|,
name|u_long
modifier|*
name|plen
parameter_list|)
block|{
specifier|volatile
name|u_char
modifier|*
name|data
init|=
operator|*
name|pdata
decl_stmt|;
specifier|volatile
name|u_long
name|len
init|=
operator|*
name|plen
decl_stmt|;
ifdef|#
directive|ifdef
name|SEA_BLINDTRANSFER
if|if
condition|(
name|len
operator|&&
operator|!
operator|(
name|len
operator|%
name|BLOCK_SIZE
operator|)
condition|)
block|{
while|while
condition|(
name|len
condition|)
block|{
name|WAITFOR10
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
argument_list|,
literal|"blind block read"
argument_list|)
expr_stmt|;
asm|asm(" 			shr $2, %%ecx; 			cld; 			rep; 			movsl; " : : 			"D" (z->DATA), "S" (data), "c" (BLOCK_SIZE) : 			"cx", "si", "di" );
name|data
operator|+=
name|BLOCK_SIZE
expr_stmt|;
name|len
operator|-=
name|BLOCK_SIZE
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
asm|asm ("cld 		1:      movb (%%ebx), %%al 			xorb $1, %%al 			testb $0xf, %%al 			jnz 2f 			testb $0x10, %%al 			jz 1b 			lodsb 			movb %%al, (%%edi) 			loop 1b 		2:" 		: "=S" (data), "=c" (len)
comment|/* output */
asm|: "D" (z->DATA), "b" (z->STATUS),
comment|/* input */
asm|"0" (data), "1" (len) 		: "eax", "ebx", "edi");
comment|/* clobbered */
ifdef|#
directive|ifdef
name|SEA_BLINDTRANSFER
block|}
endif|#
directive|endif
name|PRINT
argument_list|(
operator|(
literal|"sea (DATAOUT) send %ld bytes\n"
operator|,
operator|*
name|plen
operator|-
name|len
operator|)
argument_list|)
expr_stmt|;
operator|*
name|plen
operator|=
name|len
expr_stmt|;
operator|*
name|pdata
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Receive data from the target.  */
end_comment

begin_function
name|void
name|sea_data_input
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|u_char
modifier|*
modifier|*
name|pdata
parameter_list|,
name|u_long
modifier|*
name|plen
parameter_list|)
block|{
specifier|volatile
name|u_char
modifier|*
name|data
init|=
operator|*
name|pdata
decl_stmt|;
specifier|volatile
name|u_long
name|len
init|=
operator|*
name|plen
decl_stmt|;
ifdef|#
directive|ifdef
name|SEA_BLINDTRANSFER
if|if
condition|(
name|len
operator|&&
operator|!
operator|(
name|len
operator|%
name|BLOCK_SIZE
operator|)
condition|)
block|{
while|while
condition|(
name|len
condition|)
block|{
name|WAITFOR10
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
argument_list|,
literal|"blind block read"
argument_list|)
expr_stmt|;
asm|asm(" 			shr $2, %%ecx; 			cld; 			rep; 			movsl; " : : 			"S" (z->DATA), "D" (data), "c" (BLOCK_SIZE) : 			"cx", "si", "di" );
name|data
operator|+=
name|BLOCK_SIZE
expr_stmt|;
name|len
operator|-=
name|BLOCK_SIZE
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
if|if
condition|(
name|len
operator|>=
literal|512
condition|)
block|{
asm|asm ("  cld 			1:      movb (%%esi), %%al 				xorb $5, %%al 				testb $0xf, %%al 				jnz 2f 				testb $0x10, %%al 				jz 1b 				movb (%%ebx), %%al 				stosb 				loop 1b 			2:" 			: "=D" (data), "=c" (len)
comment|/* output */
asm|: "b" (z->DATA), "S" (z->STATUS), 				"0" (data), "1" (len)
comment|/* input */
asm|: "eax", "ebx", "esi");
comment|/* clobbered */
block|}
else|else
block|{
asm|asm ("  cld 			1:      movb (%%esi), %%al 				xorb $5, %%al 				testb $0xf, %%al 				jnz 2f 				testb $0x10, %%al 				jz 1b 				movb (%%ebx), %%al 				stosb 				movb $1000, %%al 			3:      testb $0x10, (%%esi) 				jz 4f 				dec %%al 				jnz 3b 			4:      loop 1b 			2:" 			: "=D" (data), "=c" (len)
comment|/* output */
asm|: "b" (z->DATA), "S" (z->STATUS), 				"0" (data), "1" (len)
comment|/* input */
asm|: "eax", "ebx", "esi");
comment|/* clobbered */
block|}
ifdef|#
directive|ifdef
name|SEA_BLINDTRANSFER
block|}
endif|#
directive|endif
name|PRINT
argument_list|(
operator|(
literal|"sea (DATAIN) got %ld bytes\n"
operator|,
operator|*
name|plen
operator|-
name|len
operator|)
argument_list|)
expr_stmt|;
operator|*
name|plen
operator|=
name|len
expr_stmt|;
operator|*
name|pdata
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send the command to the target.  */
end_comment

begin_function
name|void
name|sea_cmd_output
parameter_list|(
name|target_t
modifier|*
name|t
parameter_list|,
name|u_char
modifier|*
name|cmd
parameter_list|,
name|int
name|cmdlen
parameter_list|)
block|{
name|adapter_t
modifier|*
name|z
init|=
name|t
operator|->
name|adapter
decl_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d send command (%d bytes) "
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|cmdlen
operator|)
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"%x"
operator|,
operator|*
name|cmd
operator|)
argument_list|)
expr_stmt|;
operator|*
name|z
operator|->
name|DATA
operator|=
operator|*
name|cmd
operator|++
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|CTLR_SEAGATE
condition|)
name|WAITREQ
argument_list|(
name|t
argument_list|,
name|cmdout1
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
while|while
condition|(
name|cmdlen
condition|)
block|{
comment|/* Check for target disconnect. */
name|u_char
name|sts
init|=
operator|*
name|z
operator|->
name|STATUS
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|STAT_BSY
operator|)
condition|)
break|break;
comment|/* Check for phase mismatch. FD 885 seems to get this wrong! */
if|if
condition|(
operator|(
name|sts
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_CMDOUT
operator|&&
name|z
operator|->
name|type
operator|!=
name|CTLR_FUTURE_DOMAIN
condition|)
block|{
name|printf
argument_list|(
literal|"sea: sea_cmd_output: invalid phase %s\n"
argument_list|,
name|PHASE_NAME
argument_list|(
name|sts
operator|&
name|PHASE_MASK
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Wait for REQ. */
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|STAT_REQ
operator|)
condition|)
continue|continue;
name|PRINT
argument_list|(
operator|(
literal|"-%x"
operator|,
operator|*
name|cmd
operator|)
argument_list|)
expr_stmt|;
operator|*
name|z
operator|->
name|DATA
operator|=
operator|*
name|cmd
operator|++
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|CTLR_SEAGATE
condition|)
name|WAITREQ
argument_list|(
name|t
argument_list|,
name|cmdout
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
operator|--
name|cmdlen
expr_stmt|;
block|}
name|PRINT
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send the message to the target.  */
end_comment

begin_function
name|void
name|sea_send_abort
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
block|{
name|u_char
name|sts
decl_stmt|;
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|CMD_DRVR_ENABLE
operator||
name|CMD_ATTN
operator||
name|z
operator|->
name|parity
expr_stmt|;
comment|/* Wait for REQ, after which the phase bits will be valid. */
name|WAITFOR
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
argument_list|,
literal|"abort message"
argument_list|)
expr_stmt|;
name|sts
operator|=
operator|*
name|z
operator|->
name|STATUS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|STAT_REQ
operator|)
condition|)
goto|goto
name|ret
goto|;
comment|/* Check for phase mismatch. */
if|if
condition|(
operator|(
name|sts
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_MSGOUT
condition|)
block|{
name|printf
argument_list|(
literal|"sea: sending MSG_ABORT: invalid phase %s\n"
argument_list|,
name|PHASE_NAME
argument_list|(
name|sts
operator|&
name|PHASE_MASK
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
operator|*
name|z
operator|->
name|DATA
operator|=
name|MSG_ABORT
expr_stmt|;
name|sea_wait_for_req_deassert
argument_list|(
name|z
argument_list|,
literal|1000
argument_list|,
literal|"MSG_OUTPUT"
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d send abort message\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|)
argument_list|)
expr_stmt|;
name|ret
label|:
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|CMD_DRVR_ENABLE
operator||
name|z
operator|->
name|parity
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the message from the target.  * Return the length of the received message.  */
end_comment

begin_function
name|u_char
name|sea_msg_input
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|)
block|{
name|u_char
name|sts
decl_stmt|,
name|msg
decl_stmt|;
comment|/* Wait for REQ, after which the phase bits will be valid. */
name|WAITFOR
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
argument_list|,
literal|"message input"
argument_list|)
expr_stmt|;
name|sts
operator|=
operator|*
name|z
operator|->
name|STATUS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|STAT_REQ
operator|)
condition|)
return|return
operator|(
name|MSG_ABORT
operator|)
return|;
comment|/* Check for phase mismatch. 	 * Reached if the target decides that it has finished the transfer. */
if|if
condition|(
operator|(
name|sts
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_MSGIN
condition|)
block|{
name|printf
argument_list|(
literal|"sea: sea_msg_input: invalid phase %s\n"
argument_list|,
name|PHASE_NAME
argument_list|(
name|sts
operator|&
name|PHASE_MASK
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|MSG_ABORT
operator|)
return|;
block|}
comment|/* Do actual transfer from SCSI bus to/from memory. */
name|msg
operator|=
operator|*
name|z
operator|->
name|DATA
expr_stmt|;
name|sea_wait_for_req_deassert
argument_list|(
name|z
argument_list|,
literal|1000
argument_list|,
literal|"MSG_INPUT"
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d (MSG_INPUT) got 0x%x\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send request-sense op to the target.  * Return 1 success, 0 on failure.  * Called on splbio level.  */
end_comment

begin_function
name|int
name|sea_sense
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
block|{
name|u_char
name|cmd
index|[
literal|6
index|]
decl_stmt|,
name|status
decl_stmt|,
name|msg
decl_stmt|,
modifier|*
name|data
decl_stmt|;
name|u_long
name|len
decl_stmt|;
comment|/* Wait for target to disconnect. */
name|WAITFOR
argument_list|(
operator|!
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_BSY
operator|)
argument_list|,
literal|"sense bus free"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_BSY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Select the target again. */
if|if
condition|(
operator|!
name|sea_select
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Wait for CMDOUT phase. */
name|WAITFOR
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
argument_list|,
literal|"sense CMDOUT"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
operator|)
operator|||
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_CMDOUT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Send command. */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|scb
operator|->
name|xfer
operator|->
name|sense
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|cmd
index|[
literal|1
index|]
operator|=
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|<<
literal|5
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|cmd
index|[
literal|4
index|]
operator|=
name|len
expr_stmt|;
name|cmd
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|sea_cmd_output
argument_list|(
operator|&
name|z
operator|->
name|target
index|[
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
index|]
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wait for DATAIN phase. */
name|WAITFOR
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
argument_list|,
literal|"sense DATAIN"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
operator|)
operator|||
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_DATAIN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|scb
operator|->
name|xfer
operator|->
name|sense
expr_stmt|;
name|sea_data_input
argument_list|(
name|z
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d sense %x-%x-%x-%x-%x-%x-%x-%x\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|error_code
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|segment
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|flags
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sense
operator|.
name|ext
operator|.
name|extended
operator|.
name|extra_len
operator|)
argument_list|)
expr_stmt|;
comment|/* Wait for STATIN phase. */
name|WAITFOR
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
argument_list|,
literal|"sense STATIN"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
operator|)
operator|||
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_STATIN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|status
operator|=
operator|*
name|z
operator|->
name|DATA
expr_stmt|;
comment|/* Wait for MSGIN phase. */
name|WAITFOR
argument_list|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
argument_list|,
literal|"sense MSGIN"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|STAT_REQ
operator|)
operator|||
operator|(
operator|*
name|z
operator|->
name|STATUS
operator|&
name|PHASE_MASK
operator|)
operator|!=
name|PHASE_MSGIN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|msg
operator|=
operator|*
name|z
operator|->
name|DATA
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
operator|||
name|msg
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"sea%d: bad sense status=0x%x, msg=0x%x\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|status
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do the transfer. We know we are connected. Update the flags,  * call sea_done when task accomplished. Dialog controlled by the target.  * Always called with interrupts disabled.  */
end_comment

begin_function
name|void
name|sea_information_transfer
parameter_list|(
name|adapter_t
modifier|*
name|z
parameter_list|,
name|scb_t
modifier|*
name|scb
parameter_list|)
block|{
name|u_char
modifier|*
name|data
init|=
name|scb
operator|->
name|data
decl_stmt|;
comment|/* current data buffer */
name|u_long
name|datalen
init|=
name|scb
operator|->
name|datalen
decl_stmt|;
comment|/* current data transfer size */
name|target_t
modifier|*
name|t
init|=
operator|&
name|z
operator|->
name|target
index|[
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
index|]
decl_stmt|;
specifier|register
name|u_char
name|sts
decl_stmt|;
name|u_char
name|msg
decl_stmt|;
while|while
condition|(
operator|(
name|sts
operator|=
operator|*
name|z
operator|->
name|STATUS
operator|)
operator|&
name|STAT_BSY
condition|)
block|{
comment|/* We only have a valid SCSI phase when REQ is asserted. */
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|STAT_REQ
operator|)
condition|)
continue|continue;
if|if
condition|(
name|sts
operator|&
name|STAT_PARITY
condition|)
block|{
name|int
name|target
init|=
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
decl_stmt|;
if|if
condition|(
operator|++
name|z
operator|->
name|target
index|[
name|target
index|]
operator|.
name|perrcnt
operator|<=
literal|8
condition|)
name|printf
argument_list|(
literal|"sea%d/%d/%d parity error\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|target
index|[
name|target
index|]
operator|.
name|perrcnt
operator|==
literal|8
condition|)
name|printf
argument_list|(
literal|"sea%d/%d/%d too many parity errors, not logging any more\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sts
operator|&
name|PHASE_MASK
condition|)
block|{
case|case
name|PHASE_DATAOUT
case|:
if|if
condition|(
name|datalen
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sea%d/%d/%d data length underflow\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
comment|/* send zero byte */
operator|*
name|z
operator|->
name|DATA
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|sea_data_output
argument_list|(
name|z
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|datalen
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_DATAIN
case|:
if|if
condition|(
name|datalen
operator|<=
literal|0
condition|)
block|{
comment|/* Get extra data.  Some devices (e.g. CDROMs) 				 * use fixed-length blocks (e.g. 2k), 				 * even if we need less. */
name|PRINT
argument_list|(
operator|(
literal|"@"
operator|)
argument_list|)
expr_stmt|;
name|sts
operator|=
operator|*
name|z
operator|->
name|DATA
expr_stmt|;
break|break;
block|}
name|sea_data_input
argument_list|(
name|z
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|datalen
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_CMDOUT
case|:
name|sea_cmd_output
argument_list|(
name|t
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|scb
operator|->
name|xfer
operator|->
name|cmd
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_STATIN
case|:
name|scb
operator|->
name|xfer
operator|->
name|status
operator|=
operator|*
name|z
operator|->
name|DATA
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|type
operator|==
name|CTLR_SEAGATE
condition|)
name|WAITREQ
argument_list|(
name|t
argument_list|,
name|statin
argument_list|,
literal|2000
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d/%d/%d (STATIN) got 0x%x\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|,
operator|(
name|u_char
operator|)
name|scb
operator|->
name|xfer
operator|->
name|status
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_MSGOUT
case|:
comment|/* Send no-op message. */
operator|*
name|z
operator|->
name|DATA
operator|=
name|MSG_NOP
expr_stmt|;
name|sea_wait_for_req_deassert
argument_list|(
name|z
argument_list|,
literal|1000
argument_list|,
literal|"MSGOUT"
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d/%d/%d (MSGOUT) send NOP\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PHASE_MSGIN
case|:
comment|/* Don't handle multi-byte messages here, because they 			 * should not be present here. */
name|msg
operator|=
operator|*
name|z
operator|->
name|DATA
expr_stmt|;
name|sea_wait_for_req_deassert
argument_list|(
name|z
argument_list|,
literal|2000
argument_list|,
literal|"MSGIN"
argument_list|)
expr_stmt|;
name|PRINT
argument_list|(
operator|(
literal|"sea%d/%d/%d (MSGIN) got 0x%x\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|,
name|msg
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
condition|)
block|{
case|case
name|MSG_COMMAND_COMPLETE
case|:
name|scb
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
comment|/* In the case of check-condition status, 				 * perform the request-sense op. */
switch|switch
condition|(
name|scb
operator|->
name|xfer
operator|->
name|status
operator|&
literal|0x1e
condition|)
block|{
case|case
name|SCSI_CHECK
case|:
if|if
condition|(
name|sea_sense
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
condition|)
name|scb
operator|->
name|flags
operator|=
name|SCB_SENSE
expr_stmt|;
break|break;
case|case
name|SCSI_BUSY
case|:
name|scb
operator|->
name|flags
operator|=
name|SCB_TBUSY
expr_stmt|;
break|break;
block|}
goto|goto
name|done
goto|;
case|case
name|MSG_ABORT
case|:
name|printf
argument_list|(
literal|"sea: command aborted by target\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ABORTED
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|MSG_MESSAGE_REJECT
case|:
name|printf
argument_list|(
literal|"sea: message rejected\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ABORTED
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|MSG_DISCONNECT
case|:
name|scb
operator|->
name|next
operator|=
name|z
operator|->
name|disconnected_queue
expr_stmt|;
name|z
operator|->
name|disconnected_queue
operator|=
name|scb
expr_stmt|;
if|if
condition|(
operator|!
name|z
operator|->
name|irq
operator|&&
operator|!
name|z
operator|->
name|timeout_active
condition|)
block|{
name|timeout
argument_list|(
name|sea_tick
argument_list|,
name|z
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|z
operator|->
name|timeout_active
operator|=
literal|1
expr_stmt|;
block|}
name|PRINT
argument_list|(
operator|(
literal|"sea%d/%d/%d disconnected\n"
operator|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
operator|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
case|case
name|MSG_SAVE_POINTERS
case|:
name|scb
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
break|break;
case|case
name|MSG_RESTORE_POINTERS
case|:
name|data
operator|=
name|scb
operator|->
name|data
expr_stmt|;
name|datalen
operator|=
name|scb
operator|->
name|datalen
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"sea%d/%d/%d unknown message: 0x%x\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"sea: unknown phase: %b\n"
argument_list|,
name|sts
argument_list|,
name|STAT_BITS
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"sea%d/%d/%d unexpected target disconnect\n"
argument_list|,
name|z
operator|->
name|sc_link
operator|.
name|adapter_unit
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ERROR
expr_stmt|;
name|done
label|:
name|CLEAR_BUSY
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|sea_done
argument_list|(
name|z
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ret
label|:
operator|*
name|z
operator|->
name|CONTROL
operator|=
name|CMD_INTR
operator||
name|z
operator|->
name|parity
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSEA */
end_comment

end_unit

