begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Isolan AT 4141-0 Ethernet driver  * Isolink 4110   *  * By Paul Richards   *  * Copyright (C) 1993, Paul Richards. This software may be used, modified,  *   copied, distributed, and sold, in both source and binary form provided  *   that the above copyright and these terms are retained. Under no  *   circumstances is the author responsible for the proper functioning  *   of this software, nor does the author assume any responsibility  *   for damages incurred with its use.  *  * $Id: if_is.c,v 1.32 1994/11/24 14:29:22 davidg Exp $  */
end_comment

begin_comment
comment|/* TODO  1) Add working multicast support 2) Use better allocation of memory to card 3) Advertise for more packets until all transmit buffers are full 4) Add more of the timers/counters e.g. arpcom.opackets etc. */
end_comment

begin_include
include|#
directive|include
file|"is.h"
end_include

begin_if
if|#
directive|if
name|NIS
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_isreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_define
define|#
directive|define
name|ETHER_MIN_LEN
value|64
end_define

begin_define
define|#
directive|define
name|ETHER_MAX_LEN
value|1518
end_define

begin_define
define|#
directive|define
name|ETHER_ADDR_LEN
value|6
end_define

begin_decl_stmt
name|char
modifier|*
name|card_type
index|[]
init|=
block|{
literal|"Unknown"
block|,
literal|"BICC Isolan"
block|,
literal|"NE2100"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|ic_type
index|[]
init|=
block|{
literal|"Unknown"
block|,
literal|"Am7990 LANCE"
block|,
literal|"Am79960 PCnet_ISA"
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|is_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common part */
name|int
name|iobase
decl_stmt|;
name|int
name|rap
decl_stmt|;
name|int
name|rdp
decl_stmt|;
name|int
name|ic_type
decl_stmt|;
comment|/* Am 7990 or Am79960 */
name|int
name|card_type
decl_stmt|;
name|int
name|is_debug
decl_stmt|;
name|struct
name|init_block
modifier|*
name|init_block
decl_stmt|;
comment|/* Lance initialisation block */
name|struct
name|mds
modifier|*
name|rd
decl_stmt|;
name|struct
name|mds
modifier|*
name|td
decl_stmt|;
name|unsigned
name|char
modifier|*
name|rbuf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tbuf
decl_stmt|;
name|int
name|last_rd
decl_stmt|;
name|int
name|last_td
decl_stmt|;
name|int
name|no_td
decl_stmt|;
name|caddr_t
name|bpf
decl_stmt|;
comment|/* BPF "magic cookie" */
block|}
name|is_softc
index|[
name|NIS
index|]
struct|;
end_struct

begin_comment
comment|/* Function prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|is_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|is_watchdog
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|is_init
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|is_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|istint
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ISDEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|recv_print
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xmit_print
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|ISDEBUG
end_endif

begin_function_decl
specifier|static
name|int
name|ne2100_probe
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bicc_probe
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lance_probe
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|is_rint
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|isread
parameter_list|(
name|struct
name|is_softc
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|mbuf
modifier|*
name|isget
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|isdriver
init|=
block|{
name|is_probe
block|,
name|is_attach
block|,
literal|"is"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|iswrcsr
parameter_list|(
name|unit
parameter_list|,
name|port
parameter_list|,
name|val
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|u_short
name|val
decl_stmt|;
block|{
name|outw
argument_list|(
name|is_softc
index|[
name|unit
index|]
operator|.
name|rap
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|is_softc
index|[
name|unit
index|]
operator|.
name|rdp
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_short
name|isrdcsr
parameter_list|(
name|unit
parameter_list|,
name|port
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_short
name|port
decl_stmt|;
block|{
name|outw
argument_list|(
name|is_softc
index|[
name|unit
index|]
operator|.
name|rap
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|inw
argument_list|(
name|is_softc
index|[
name|unit
index|]
operator|.
name|rdp
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|kdc_is
index|[
name|NIS
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* filled in by dev_attach */
literal|"is"
block|,
literal|0
block|,
block|{
name|MDDT_ISA
block|,
literal|0
block|,
literal|"net"
block|}
block|,
name|isa_generic_externalize
block|,
literal|0
block|,
literal|0
block|,
name|ISA_EXTERNALLEN
block|,
operator|&
name|kdc_isa0
block|,
comment|/* parent */
literal|0
block|,
comment|/* parentdata */
name|DC_BUSY
block|,
comment|/* network interfaces are always busy */
literal|"Isolan AT 4141-0, Isolink 4110, or NE2100 Ethernet adapter"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|is_registerdev
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
if|if
condition|(
name|id
operator|->
name|id_unit
condition|)
name|kdc_is
index|[
name|id
operator|->
name|id_unit
index|]
operator|=
name|kdc_is
index|[
literal|0
index|]
expr_stmt|;
name|kdc_is
index|[
name|id
operator|->
name|id_unit
index|]
operator|.
name|kdc_unit
operator|=
name|id
operator|->
name|id_unit
expr_stmt|;
name|kdc_is
index|[
name|id
operator|->
name|id_unit
index|]
operator|.
name|kdc_isa
operator|=
name|id
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|kdc_is
index|[
name|id
operator|->
name|id_unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|is_probe
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|isa_dev
operator|->
name|id_unit
decl_stmt|;
name|int
name|nports
decl_stmt|;
name|is_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|=
name|isa_dev
operator|->
name|id_iobase
expr_stmt|;
comment|/* 	 * It's impossible to do a non-invasive probe of the  	 * LANCE and PCnet_ISA. The LANCE requires setting the 	 * STOP bit to access the registers and the PCnet_ISA 	 * address port resets to an unknown state!! 	 */
comment|/* 	 * Check for BICC cards first since for the NE2100 and 	 * PCnet-ISA cards this write will hit the Address PROM.  	 */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Dumping io space for is%d starting at %x\n"
argument_list|,
name|unit
argument_list|,
name|is_softc
index|[
name|unit
index|]
operator|.
name|iobase
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %x "
argument_list|,
name|inb
argument_list|(
name|is_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG*/
name|nports
operator|=
name|bicc_probe
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|nports
condition|)
return|return
operator|(
name|nports
operator|)
return|;
name|nports
operator|=
name|ne2100_probe
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|nports
condition|)
return|return
operator|(
name|nports
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ne2100_probe
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|is_softc
modifier|*
name|is
init|=
operator|&
name|is_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|is
operator|->
name|rap
operator|=
name|is
operator|->
name|iobase
operator|+
name|NE2100_RAP
expr_stmt|;
name|is
operator|->
name|rdp
operator|=
name|is
operator|->
name|iobase
operator|+
name|NE2100_RDP
expr_stmt|;
name|is
operator|->
name|ic_type
operator|=
name|lance_probe
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|ic_type
condition|)
block|{
name|is
operator|->
name|card_type
operator|=
name|NE2100
expr_stmt|;
comment|/*  		 * Extract the physical MAC address from ROM 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|is
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|is
operator|->
name|iobase
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/*  		 * Return number of I/O ports used by card  		 */
return|return
operator|(
literal|24
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bicc_probe
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|is_softc
modifier|*
name|is
init|=
operator|&
name|is_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|is
operator|->
name|rap
operator|=
name|is
operator|->
name|iobase
operator|+
name|BICC_RAP
expr_stmt|;
name|is
operator|->
name|rdp
operator|=
name|is
operator|->
name|iobase
operator|+
name|BICC_RDP
expr_stmt|;
name|is
operator|->
name|ic_type
operator|=
name|lance_probe
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|is
operator|->
name|ic_type
condition|)
block|{
name|is
operator|->
name|card_type
operator|=
name|BICC
expr_stmt|;
comment|/* 		 * Extract the physical ethernet address from ROM 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|is
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|is
operator|->
name|iobase
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|)
expr_stmt|;
comment|/*  		 * Return number of I/O ports used by card  		 */
return|return
operator|(
literal|16
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Determine which, if any, of the LANCE or   * PCnet-ISA are present on the card.  */
end_comment

begin_function
name|int
name|lance_probe
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|type
init|=
literal|0
decl_stmt|;
comment|/*  	 * Have to reset the LANCE to get any  	 * stable information from it. 	 */
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|STOP
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|isrdcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
operator|!=
name|STOP
condition|)
comment|/*  		 * This either isn't a LANCE  		 * or there's a major problem. 		 */
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  	 * Depending on which controller it is, CSR3 will have  	 * different settable bits. Write to them all and see which ones 	 * get set. 	 */
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|3
argument_list|,
name|LANCE_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|isrdcsr
argument_list|(
name|unit
argument_list|,
literal|3
argument_list|)
operator|==
name|LANCE_MASK
condition|)
name|type
operator|=
name|LANCE
expr_stmt|;
if|if
condition|(
name|isrdcsr
argument_list|(
name|unit
argument_list|,
literal|3
argument_list|)
operator|==
name|PCnet_ISA_MASK
condition|)
name|type
operator|=
name|PCnet_ISA
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset of interface.  */
end_comment

begin_function
specifier|static
name|void
name|is_reset
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
if|if
condition|(
name|unit
operator|>=
name|NIS
condition|)
return|return;
name|printf
argument_list|(
literal|"is%d: reset\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|is_init
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  We get the ethernet address here.  */
end_comment

begin_function
name|int
name|is_attach
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|isa_dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|is_softc
modifier|*
name|is
init|=
operator|&
name|is_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|is
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
name|isdriver
operator|.
name|name
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_NOTRAILERS
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|is_init
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|is_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|is_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_reset
operator|=
name|is_reset
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|is_watchdog
expr_stmt|;
comment|/* 	 * XXX -- not sure this is right place to do this 	 * Allocate memory for use by Lance 	 * Memory allocated for: 	 * 	initialisation block, 	 * 	ring descriptors, 	 * 	transmit and receive buffers. 	 */
comment|/* 	 * XXX - hopefully have better way to get dma'able memory later, 	 * this code assumes that the physical memory address returned 	 * from malloc will be below 16Mb. The Lance's address registers 	 * are only 16 bits wide! 	 */
define|#
directive|define
name|ISMAXMEM
value|((NRBUF+NTBUF)*(BUFSIZE) + (NRBUF+NTBUF)*sizeof(struct mds) \                  + sizeof(struct init_block) + 8)
name|is
operator|->
name|init_block
operator|=
operator|(
expr|struct
name|init_block
operator|*
operator|)
name|malloc
argument_list|(
name|ISMAXMEM
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is
operator|->
name|init_block
condition|)
block|{
name|printf
argument_list|(
literal|"is%d : Couldn't allocate memory for card\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * XXX -- should take corrective action if not 	 * quadword alilgned, the 8 byte slew factor in ISMAXMEM 	 * allows for this. 	 */
if|if
condition|(
operator|(
name|u_long
operator|)
name|is
operator|->
name|init_block
operator|&
literal|0x3
condition|)
name|printf
argument_list|(
literal|"is%d: memory allocated not quadword aligned\n"
argument_list|,
name|isa_dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
comment|/* Set up DMA */
name|isa_dmacascade
argument_list|(
name|isa_dev
operator|->
name|id_drq
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|is_registerdev
argument_list|(
name|isa_dev
argument_list|)
expr_stmt|;
comment|/* 	 * Search down the ifa address list looking  	 * for the AF_LINK type entry 	 */
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
expr_stmt|;
while|while
condition|(
operator|(
name|ifa
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
operator|)
condition|)
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
expr_stmt|;
comment|/* 	 * If we find an AF_LINK type entry, we will fill 	 * in the hardware address for this interface. 	 */
if|if
condition|(
operator|(
name|ifa
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Fill in the link level address for this interface 		 */
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ETHER_ADDR_LEN
expr_stmt|;
name|sdl
operator|->
name|sdl_slen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|is
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"is%d: address %s\n"
argument_list|,
name|unit
argument_list|,
name|ether_sprintf
argument_list|(
name|is
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s, %s\n"
argument_list|,
name|ic_type
index|[
name|is
operator|->
name|ic_type
index|]
argument_list|,
name|card_type
index|[
name|is
operator|->
name|card_type
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|is
operator|->
name|bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|is_watchdog
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"is%d: device timeout\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|is_reset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lance initialisation block set up */
end_comment

begin_function
name|void
name|init_mem
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|void
modifier|*
name|temp
decl_stmt|;
name|struct
name|is_softc
modifier|*
name|is
init|=
operator|&
name|is_softc
index|[
name|unit
index|]
decl_stmt|;
comment|/* 	 * At this point we assume that the 	 * memory allocated to the Lance is 	 * quadword aligned. If it isn't 	 * then the initialisation is going 	 * fail later on. 	 */
comment|/*  	 * Set up lance initialisation block 	 */
name|temp
operator|=
operator|(
name|void
operator|*
operator|)
name|is
operator|->
name|init_block
expr_stmt|;
name|temp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|init_block
argument_list|)
expr_stmt|;
name|is
operator|->
name|rd
operator|=
operator|(
expr|struct
name|mds
operator|*
operator|)
name|temp
expr_stmt|;
name|is
operator|->
name|td
operator|=
operator|(
expr|struct
name|mds
operator|*
operator|)
operator|(
name|temp
operator|+
operator|(
name|NRBUF
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mds
argument_list|)
operator|)
operator|)
expr_stmt|;
name|temp
operator|+=
operator|(
name|NRBUF
operator|+
name|NTBUF
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mds
argument_list|)
expr_stmt|;
name|is
operator|->
name|init_block
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|is
operator|->
name|init_block
operator|->
name|padr
index|[
name|i
index|]
operator|=
name|is
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|is
operator|->
name|init_block
operator|->
name|ladrf
index|[
name|i
index|]
operator|=
name|MULTI_INIT_ADDR
expr_stmt|;
name|is
operator|->
name|init_block
operator|->
name|rdra
operator|=
name|kvtop
argument_list|(
name|is
operator|->
name|rd
argument_list|)
expr_stmt|;
name|is
operator|->
name|init_block
operator|->
name|rlen
operator|=
operator|(
operator|(
name|kvtop
argument_list|(
name|is
operator|->
name|rd
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|RLEN
operator|<<
literal|13
operator|)
expr_stmt|;
name|is
operator|->
name|init_block
operator|->
name|tdra
operator|=
name|kvtop
argument_list|(
name|is
operator|->
name|td
argument_list|)
expr_stmt|;
name|is
operator|->
name|init_block
operator|->
name|tlen
operator|=
operator|(
operator|(
name|kvtop
argument_list|(
name|is
operator|->
name|td
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
operator|(
name|TLEN
operator|<<
literal|13
operator|)
expr_stmt|;
comment|/*  	 * Set up receive ring descriptors 	 */
name|is
operator|->
name|rbuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|temp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NRBUF
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|is
operator|->
name|rd
operator|+
name|i
operator|)
operator|->
name|addr
operator|=
name|kvtop
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|(
name|is
operator|->
name|rd
operator|+
name|i
operator|)
operator|->
name|flags
operator|=
operator|(
operator|(
name|kvtop
argument_list|(
name|temp
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator||
name|OWN
expr_stmt|;
operator|(
name|is
operator|->
name|rd
operator|+
name|i
operator|)
operator|->
name|bcnt
operator|=
operator|-
name|BUFSIZE
expr_stmt|;
operator|(
name|is
operator|->
name|rd
operator|+
name|i
operator|)
operator|->
name|mcnt
operator|=
literal|0
expr_stmt|;
name|temp
operator|+=
name|BUFSIZE
expr_stmt|;
block|}
comment|/*  	 * Set up transmit ring descriptors 	 */
name|is
operator|->
name|tbuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|temp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTBUF
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|is
operator|->
name|td
operator|+
name|i
operator|)
operator|->
name|addr
operator|=
name|kvtop
argument_list|(
name|temp
argument_list|)
expr_stmt|;
operator|(
name|is
operator|->
name|td
operator|+
name|i
operator|)
operator|->
name|flags
operator|=
operator|(
operator|(
name|kvtop
argument_list|(
name|temp
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
operator|(
name|is
operator|->
name|td
operator|+
name|i
operator|)
operator|->
name|bcnt
operator|=
literal|0
expr_stmt|;
operator|(
name|is
operator|->
name|td
operator|+
name|i
operator|)
operator|->
name|mcnt
operator|=
literal|0
expr_stmt|;
name|temp
operator|+=
name|BUFSIZE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialization of interface; set up initialization block  * and transmit/receive descriptor rings.  */
end_comment

begin_function
specifier|static
name|void
name|is_init
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|is_softc
modifier|*
name|is
init|=
operator|&
name|is_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|is
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|;
specifier|register
name|i
expr_stmt|;
comment|/* Address not known */
if|if
condition|(
name|ifp
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/*  	 * Lance must be stopped 	 * to access registers. 	 */
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|STOP
argument_list|)
expr_stmt|;
name|is
operator|->
name|last_rd
operator|=
name|is
operator|->
name|last_td
operator|=
name|is
operator|->
name|no_td
operator|=
literal|0
expr_stmt|;
comment|/* Set up lance's memory area */
name|init_mem
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* No byte swapping etc */
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Give lance the physical address of its memory area */
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|1
argument_list|,
name|kvtop
argument_list|(
name|is
operator|->
name|init_block
argument_list|)
argument_list|)
expr_stmt|;
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|2
argument_list|,
operator|(
name|kvtop
argument_list|(
name|is
operator|->
name|init_block
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* OK, let's try and initialise the Lance */
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|INIT
argument_list|)
expr_stmt|;
comment|/* Wait for initialisation to finish */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isrdcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
operator|&
name|IDON
condition|)
break|break;
block|}
if|if
condition|(
name|isrdcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
operator|&
name|IDON
condition|)
block|{
comment|/* Start lance */
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|STRT
operator||
name|IDON
operator||
name|INEA
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|is_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"is%d: card failed to initialise\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup output on interface.  * Get another datagram to send off of the interface queue,  * and map it to the interface before starting the output.  * called only at splimp or interrupt level.  */
end_comment

begin_function
specifier|static
name|void
name|is_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|int
name|unit
init|=
name|ifp
operator|->
name|if_unit
decl_stmt|;
specifier|register
name|struct
name|is_softc
modifier|*
name|is
init|=
operator|&
name|is_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|struct
name|mds
modifier|*
name|cdm
decl_stmt|;
if|if
condition|(
operator|(
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
do|do
block|{
name|cdm
operator|=
operator|(
name|is
operator|->
name|td
operator|+
name|is
operator|->
name|last_td
operator|)
expr_stmt|;
if|if
condition|(
name|cdm
operator|->
name|flags
operator|&
name|OWN
condition|)
return|return;
name|IF_DEQUEUE
argument_list|(
operator|&
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
comment|/* 	 	* Copy the mbuf chain into the transmit buffer 	 	*/
name|buffer
operator|=
name|is
operator|->
name|tbuf
operator|+
operator|(
name|BUFSIZE
operator|*
name|is
operator|->
name|last_td
operator|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|is
operator|->
name|bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|is
operator|->
name|bpf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|len
operator|=
name|max
argument_list|(
name|len
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
comment|/* 	 	* Init transmit registers, and set transmit start flag. 	 	*/
name|cdm
operator|->
name|flags
operator||=
operator|(
name|OWN
operator||
name|STP
operator||
name|ENP
operator|)
expr_stmt|;
name|cdm
operator|->
name|bcnt
operator|=
operator|-
name|len
expr_stmt|;
name|cdm
operator|->
name|mcnt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ISDEBUG
if|if
condition|(
name|is
operator|->
name|is_debug
condition|)
name|xmit_print
argument_list|(
name|unit
argument_list|,
name|is
operator|->
name|last_td
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|TDMD
operator||
name|INEA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|is
operator|->
name|last_td
operator|>=
name|NTBUF
condition|)
name|is
operator|->
name|last_td
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|is
operator|->
name|no_td
operator|<
name|NTBUF
condition|)
do|;
name|is
operator|->
name|no_td
operator|=
name|NTBUF
expr_stmt|;
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
ifdef|#
directive|ifdef
name|ISDEBUG
if|if
condition|(
name|is
operator|->
name|is_debug
condition|)
name|printf
argument_list|(
literal|"no_td = %x, last_td = %x\n"
argument_list|,
name|is
operator|->
name|no_td
argument_list|,
name|is
operator|->
name|last_td
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Controller interrupt.  */
end_comment

begin_function
name|void
name|isintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|is_softc
modifier|*
name|is
init|=
operator|&
name|is_softc
index|[
name|unit
index|]
decl_stmt|;
name|u_short
name|isr
decl_stmt|;
while|while
condition|(
operator|(
name|isr
operator|=
name|isrdcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
operator|)
operator|&
name|INTR
condition|)
block|{
if|if
condition|(
name|isr
operator|&
name|ERR
condition|)
block|{
if|if
condition|(
name|isr
operator|&
name|BABL
condition|)
block|{
name|printf
argument_list|(
literal|"is%d: BABL\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isr
operator|&
name|CERR
condition|)
block|{
name|printf
argument_list|(
literal|"is%d: CERR\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isr
operator|&
name|MISS
condition|)
block|{
name|printf
argument_list|(
literal|"is%d: MISS\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isr
operator|&
name|MERR
condition|)
name|printf
argument_list|(
literal|"is%d: MERR\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|BABL
operator||
name|CERR
operator||
name|MISS
operator||
name|MERR
operator||
name|INEA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|isr
operator|&
name|RXON
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"is%d: !(isr&RXON)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|is_reset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|isr
operator|&
name|TXON
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"is%d: !(isr&TXON)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|is_reset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isr
operator|&
name|RINT
condition|)
block|{
comment|/* reset watchdog timer */
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|is_rint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isr
operator|&
name|TINT
condition|)
block|{
comment|/* reset watchdog timer */
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|TINT
operator||
name|INEA
argument_list|)
expr_stmt|;
name|istint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|istint
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|is_softc
modifier|*
name|is
init|=
operator|&
name|is_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|is
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|i
decl_stmt|,
name|loopcount
init|=
literal|0
decl_stmt|;
name|struct
name|mds
modifier|*
name|cdm
decl_stmt|;
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|is
operator|->
name|last_td
operator|-
name|is
operator|->
name|no_td
operator|)
operator|<
literal|0
condition|)
name|i
operator|+=
name|NTBUF
expr_stmt|;
name|cdm
operator|=
operator|(
name|is
operator|->
name|td
operator|+
name|i
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISDEBUG
if|if
condition|(
name|is
operator|->
name|is_debug
condition|)
name|printf
argument_list|(
literal|"Trans cdm = %x\n"
argument_list|,
name|cdm
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cdm
operator|->
name|flags
operator|&
name|OWN
condition|)
block|{
if|if
condition|(
name|loopcount
condition|)
break|break;
return|return;
block|}
name|loopcount
operator|++
expr_stmt|;
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|is
operator|->
name|no_td
operator|>
literal|0
condition|)
do|;
name|is_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NEXTRDS
define|\
value|if (++rmd == NRBUF) rmd=0, cdm=is->rd; else ++cdm
end_define

begin_comment
comment|/* only called from one place, so may as well integrate */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|is_rint
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|is_softc
modifier|*
name|is
init|=
operator|&
name|is_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|rmd
init|=
name|is
operator|->
name|last_rd
decl_stmt|;
name|struct
name|mds
modifier|*
name|cdm
init|=
operator|(
name|is
operator|->
name|rd
operator|+
name|rmd
operator|)
decl_stmt|;
comment|/* Out of sync with hardware, should never happen */
if|if
condition|(
name|cdm
operator|->
name|flags
operator|&
name|OWN
condition|)
block|{
name|printf
argument_list|(
literal|"is%d: error: out of sync\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|RINT
operator||
name|INEA
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Process all buffers with valid data */
while|while
condition|(
operator|!
operator|(
name|cdm
operator|->
name|flags
operator|&
name|OWN
operator|)
condition|)
block|{
comment|/* Clear interrupt to avoid race condition */
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|RINT
operator||
name|INEA
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdm
operator|->
name|flags
operator|&
name|ERR
condition|)
block|{
if|if
condition|(
name|cdm
operator|->
name|flags
operator|&
name|FRAM
condition|)
name|printf
argument_list|(
literal|"is%d: FRAM\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdm
operator|->
name|flags
operator|&
name|OFLO
condition|)
name|printf
argument_list|(
literal|"is%d: OFLO\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdm
operator|->
name|flags
operator|&
name|CRC
condition|)
name|printf
argument_list|(
literal|"is%d: CRC\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdm
operator|->
name|flags
operator|&
name|RBUFF
condition|)
name|printf
argument_list|(
literal|"is%d: RBUFF\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cdm
operator|->
name|flags
operator|&
operator|(
name|STP
operator||
name|ENP
operator|)
operator|!=
operator|(
name|STP
operator||
name|ENP
operator|)
condition|)
block|{
do|do
block|{
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|RINT
operator||
name|INEA
argument_list|)
expr_stmt|;
name|cdm
operator|->
name|mcnt
operator|=
literal|0
expr_stmt|;
name|cdm
operator|->
name|flags
operator||=
name|OWN
expr_stmt|;
name|NEXTRDS
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|cdm
operator|->
name|flags
operator|&
operator|(
name|OWN
operator||
name|ERR
operator||
name|STP
operator||
name|ENP
operator|)
operator|)
condition|)
do|;
name|is
operator|->
name|last_rd
operator|=
name|rmd
expr_stmt|;
name|printf
argument_list|(
literal|"is%d: Chained buffer\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cdm
operator|->
name|flags
operator|&
operator|(
name|OWN
operator||
name|ERR
operator||
name|STP
operator||
name|ENP
operator|)
operator|)
operator|!=
name|ENP
condition|)
block|{
name|is_reset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ISDEBUG
if|if
condition|(
name|is
operator|->
name|is_debug
condition|)
name|recv_print
argument_list|(
name|unit
argument_list|,
name|is
operator|->
name|last_rd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isread
argument_list|(
name|is
argument_list|,
name|is
operator|->
name|rbuf
operator|+
operator|(
name|BUFSIZE
operator|*
name|rmd
operator|)
argument_list|,
operator|(
name|int
operator|)
name|cdm
operator|->
name|mcnt
argument_list|)
expr_stmt|;
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
block|}
name|cdm
operator|->
name|flags
operator||=
name|OWN
expr_stmt|;
name|cdm
operator|->
name|mcnt
operator|=
literal|0
expr_stmt|;
name|NEXTRDS
expr_stmt|;
ifdef|#
directive|ifdef
name|ISDEBUG
if|if
condition|(
name|is
operator|->
name|is_debug
condition|)
name|printf
argument_list|(
literal|"is->last_rd = %x, cdm = %x\n"
argument_list|,
name|is
operator|->
name|last_rd
argument_list|,
name|cdm
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* while */
name|is
operator|->
name|last_rd
operator|=
name|rmd
expr_stmt|;
block|}
end_function

begin_comment
comment|/* is_rint */
end_comment

begin_comment
comment|/*  * Pass a packet to the higher levels.  * We deal with the trailer protocol here.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|isread
parameter_list|(
name|struct
name|is_softc
modifier|*
name|is
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|register
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|buf
expr_stmt|;
name|len
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
comment|/*          * Pull packet off interface.  Off is nonzero if packet          * has trailing header; neget will then force this header          * information to be at the front, but we still have to drop          * the type and length which are at the front of any trailer data.          */
name|m
operator|=
name|isget
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|&
name|is
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/*          * Check if there's a BPF listener on this interface.          * If so, hand off the raw packet to bpf.           */
if|if
condition|(
name|is
operator|->
name|bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|is
operator|->
name|bpf
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/*                  * Note that the interface cannot be in promiscuous mode if                  * there are no BPF listeners.  And if we are in promiscuous                  * mode, we have to check if this packet is really ours.                  *                  * XXX This test does not support multicasts.                  */
if|if
condition|(
operator|(
name|is
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|is
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|ether_input
argument_list|(
operator|&
name|is
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Supporting routines  */
end_comment

begin_comment
comment|/*  * Pull read data off a interface.  * Len is length of data, with local net header stripped.  * Off is non-zero if a trailer protocol was used, and  * gives the offset of the trailer information.  * We copy the trailer information and then all the normal  * data into mbufs.  When full cluster sized units are present  * we copy into clusters.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|isget
parameter_list|(
name|buf
parameter_list|,
name|totlen
parameter_list|,
name|off0
parameter_list|,
name|ifp
parameter_list|)
name|caddr_t
name|buf
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|off0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|off
init|=
name|off0
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|caddr_t
name|cp
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|epkt
decl_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
name|epkt
operator|=
name|cp
operator|+
name|totlen
expr_stmt|;
if|if
condition|(
name|off
condition|)
block|{
name|cp
operator|+=
name|off
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|totlen
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
name|len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|epkt
operator|-
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|m
operator|->
name|m_len
operator|=
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
else|else
block|{
comment|/*                          * Place initial small packet/header at end of mbuf.                          */
if|if
condition|(
name|len
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
name|top
operator|==
literal|0
operator|&&
name|len
operator|+
name|max_linkhdr
operator|<=
name|m
operator|->
name|m_len
condition|)
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
else|else
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|epkt
condition|)
name|cp
operator|=
name|buf
expr_stmt|;
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_function
name|int
name|is_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|unit
init|=
name|ifp
operator|->
name|if_unit
decl_stmt|;
specifier|register
name|struct
name|is_softc
modifier|*
name|is
init|=
operator|&
name|is_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|is_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
name|arp_ifinit
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
comment|/*                  * XXX - This code is probably wrong                  */
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|is
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
comment|/*  				 * 				 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|is
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|is
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*                          * Set new address                          */
name|is_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|is_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/*                  * If interface is marked down and it is running, then stop it                  */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|iswrcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|STOP
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
else|else
block|{
comment|/*                  * If interface is marked up and it is stopped, then start it                  */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|is_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ISDEBUG
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|is
operator|->
name|is_debug
operator|=
literal|1
expr_stmt|;
else|else
name|is
operator|->
name|is_debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/*                          * Set promiscuous mode on interface.                          *      XXX - for multicasts to work, we would need to                          *              write 1's in all bits of multicast                          *              hashing array. For now we assume that                          *              this was done in is_init().                          */
name|is
operator|->
name|init_block
operator|->
name|mode
operator|=
name|PROM
expr_stmt|;
block|}
else|else
comment|/*                          * XXX - for multicasts to work, we would need to                          *      rewrite the multicast hashing array with the                          *      proper hash (would have been destroyed above).                          */
block|{
comment|/* Don't know about this */
block|}
empty_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|notdef
case|case
name|SIOCGHWADDR
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|is
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|is
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SIOCSIFMTU
case|:
comment|/* 		 * Set the interface MTU. 		 */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ISDEBUG
end_ifdef

begin_function
name|staic
name|void
name|recv_print
parameter_list|(
name|unit
parameter_list|,
name|no
parameter_list|)
name|int
name|unit
decl_stmt|,
name|no
decl_stmt|;
block|{
specifier|register
name|struct
name|is_softc
modifier|*
name|is
init|=
operator|&
name|is_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|mds
modifier|*
name|rmd
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|,
name|printed
init|=
literal|0
decl_stmt|;
name|rmd
operator|=
operator|(
name|is
operator|->
name|rd
operator|+
name|no
operator|)
expr_stmt|;
name|len
operator|=
name|rmd
operator|->
name|mcnt
expr_stmt|;
name|printf
argument_list|(
literal|"is%d: Receive buffer %d, len = %d\n"
argument_list|,
name|unit
argument_list|,
name|no
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"is%d: Status %x\n"
argument_list|,
name|unit
argument_list|,
name|isrdcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|printed
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"is%d: data: "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%x "
argument_list|,
operator|*
operator|(
name|is
operator|->
name|rbuf
operator|+
operator|(
name|BUFSIZE
operator|*
name|no
operator|)
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|printed
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xmit_print
parameter_list|(
name|unit
parameter_list|,
name|no
parameter_list|)
name|int
name|unit
decl_stmt|,
name|no
decl_stmt|;
block|{
specifier|register
name|struct
name|is_softc
modifier|*
name|is
init|=
operator|&
name|is_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|mds
modifier|*
name|rmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|printed
init|=
literal|0
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|rmd
operator|=
operator|(
name|is
operator|->
name|td
operator|+
name|no
operator|)
expr_stmt|;
name|len
operator|=
operator|-
operator|(
name|rmd
operator|->
name|bcnt
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"is%d: Transmit buffer %d, len = %d\n"
argument_list|,
name|unit
argument_list|,
name|no
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"is%d: Status %x\n"
argument_list|,
name|unit
argument_list|,
name|isrdcsr
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"is%d: addr %x, flags %x, bcnt %x, mcnt %x\n"
argument_list|,
name|unit
argument_list|,
name|rmd
operator|->
name|addr
argument_list|,
name|rmd
operator|->
name|flags
argument_list|,
name|rmd
operator|->
name|bcnt
argument_list|,
name|rmd
operator|->
name|mcnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|printed
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"is%d: data: "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%x "
argument_list|,
operator|*
operator|(
name|is
operator|->
name|tbuf
operator|+
operator|(
name|BUFSIZE
operator|*
name|no
operator|)
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|printed
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISDEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NIS> 0 */
end_comment

end_unit

