begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|ZP_DEBUG
value|1
end_define

begin_comment
comment|/*  * This code is based on  *  (1) FreeBSD implementation on ISA/EISA Ethelink III by Herb Peyerl  *  (2) Linux implementation on PCMCIA Etherlink III by Devid Hinds  *  (3) FreeBSD implementation on PCMCIA IBM Ethernet Card I/II   *      by David Greenman  *  (4) RT-Mach implementation on PCMCIA/ISA/EISA Etherlink III  *      by Seiji Murata  *  *  Copyright (c) by HOSOKAWA, Tatsumi<hosokawa@mt.cs.keio.ac.jp>  *  Copyright (c) by Seiji Murata<seiji@mt.cs.keio.ac.jp>  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1993 Herb Peyerl<hpeyerl@novatel.ca>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	From: if_ep.c,v 1.9 1994/01/25 10:46:29 deraadt Exp $  *	$Id: if_zp.c,v 1.1 1995/02/17 02:22:52 phk Exp $  */
end_comment

begin_comment
comment|/*-  * TODO:  * [1] integrate into current if_ed.c  * [2] parse tuples to find out where to map the shared memory buffer,  *     and what to write into the configuration register  * [3] move pcic-specific code into a separate module.  *   * Device driver for IBM PCMCIA Credit Card Adapter for Ethernet,  * if_ze.c  *  * Based on the Device driver for National Semiconductor DS8390 ethernet  * adapters by David Greenman.  Modifications for PCMCIA by Keith Moore.  * Adapted for FreeBSD 1.1.5 by Jordan Hubbard.  *  * Currently supports only the IBM Credit Card Adapter for Ethernet, but  * could probably work with other PCMCIA cards also, if it were modified  * to get the locations of the PCMCIA configuration option register (COR)  * by parsing the configuration tuples, rather than by hard-coding in  * the value expected by IBM's card.  *  * Sources for data on the PCMCIA/IBM CCAE specific portions of the driver:  *  * [1] _Local Area Network Credit Card Adapters Technical Reference_,  *     IBM Corp., SC30-3585-00, part # 33G9243.  * [2] "pre-alpha" PCMCIA support code for Linux by Barry Jaspan.  * [3] Intel 82536SL PC Card Interface Controller Data Sheet, Intel  *     Order Number 290423-002  * [4] National Semiconductor DP83902A ST-NIC (tm) Serial Network  *     Interface Controller for Twisted Pair data sheet.  *  *  * Copyright (C) 1993, David Greenman. This software may be used, modified,  *   copied, distributed, and sold, in both source and binary form provided  *   that the above copyright and these terms are retained. Under no  *   circumstances is the author responsible for the proper functioning  *   of this software, nor does the author assume any responsibility  *   for damages incurred with its use.  */
end_comment

begin_comment
comment|/*======================================================================      A PCMCIA ethernet driver for the 3com 3c589 card.          Written by David Hinds, dhinds@allegro.stanford.edu      The network driver code is based on Donald Becker's 3c589 code:          Written 1994 by Donald Becker.     Copyright 1993 United States Government as represented by the     Director, National Security Agency.  This software may be used and     distributed according to the terms of the GNU Public License,     incorporated herein by reference.     Donald Becker may be reached at becker@cesdis1.gsfc.nasa.gov      ======================================================================*/
end_comment

begin_comment
comment|/*  * I doubled delay loops in this file because it is not enough for some  * laptop machines' PCIC (especially, on my Chaplet ILFA 350 ^^;).   *                        HOSOKAWA, Tatsumi<hosokawa@mt.cs.keio.ac.jp>  */
end_comment

begin_comment
comment|/*  * Very small patch for IBM Ethernet PCMCIA Card II and IBM ThinkPad230Cs.  *			ETO, Toshihisa<eto@osl.fujitsu.co.jp>  */
end_comment

begin_include
include|#
directive|include
file|"zp.h"
end_include

begin_if
if|#
directive|if
name|NZP
operator|>
literal|0
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|MACH_KERNEL
end_ifdef

begin_define
define|#
directive|define
name|IF_CNTRS
value|MACH
end_define

begin_include
include|#
directive|include
file|<mach_ttd.h>
end_include

begin_include
include|#
directive|include
file|<kern/time_out.h>
end_include

begin_include
include|#
directive|include
file|<device/device_types.h>
end_include

begin_include
include|#
directive|include
file|<device/errno.h>
end_include

begin_include
include|#
directive|include
file|<device/io_req.h>
end_include

begin_include
include|#
directive|include
file|<device/if_hdr.h>
end_include

begin_include
include|#
directive|include
file|<device/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<device/net_status.h>
end_include

begin_include
include|#
directive|include
file|<device/net_io.h>
end_include

begin_include
include|#
directive|include
file|<i386/ipl.h>
end_include

begin_include
include|#
directive|include
file|<chips/busses.h>
end_include

begin_include
include|#
directive|include
file|<i386at/if_zpreg.h>
end_include

begin_define
define|#
directive|define
name|SPLNET
value|spl6
end_define

begin_if
if|#
directive|if
name|MACH_TTD
end_if

begin_include
include|#
directive|include
file|<ttd/ttd_stub.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MACH_TTD */
end_comment

begin_include
include|#
directive|include
file|"i82365.h"
end_include

begin_define
define|#
directive|define
name|MAXSLOT
value|8
end_define

begin_define
define|#
directive|define
name|SHARED_MEMORY
end_define

begin_enum
enum|enum
name|memtype
block|{
name|COMMON
block|,
name|ATTRIBUTE
block|}
enum|;
end_enum

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MACH_KERNEL */
end_comment

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_zpreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/pcic.h>
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MACH_KERNEL */
end_comment

begin_define
define|#
directive|define
name|ETHER_MIN_LEN
value|64
end_define

begin_define
define|#
directive|define
name|ETHER_MAX_LEN
value|1518
end_define

begin_define
define|#
directive|define
name|ETHER_ADDR_LEN
value|6
end_define

begin_escape
end_escape

begin_comment
comment|/*****************************************************************************  *                       Driver for Ethernet Adapter                         *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * zp_softc: per line info and status  */
end_comment

begin_struct
struct|struct
name|zp_softc
block|{
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|struct
name|ifnet
name|ds_if
decl_stmt|;
comment|/* generic interface header */
name|u_char
name|ds_addr
index|[
literal|6
index|]
decl_stmt|;
comment|/* Ethernet hardware address */
else|#
directive|else
comment|/* MACH_KERNEL */
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common part		*/
define|#
directive|define
name|MAX_MBS
value|8
comment|/* # of mbufs we keep around	*/
name|struct
name|mbuf
modifier|*
name|mb
index|[
name|MAX_MBS
index|]
decl_stmt|;
comment|/* spare mbuf storage.		*/
name|int
name|next_mb
decl_stmt|;
comment|/* Which mbuf to use next. 	*/
name|int
name|last_mb
decl_stmt|;
comment|/* Last mbuf.			*/
name|caddr_t
name|bpf
decl_stmt|;
comment|/* BPF  "magic cookie"		*/
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|short
name|ep_io_addr
decl_stmt|;
comment|/* i/o bus address		*/
name|char
name|ep_connectors
decl_stmt|;
comment|/* Connectors on this card.	*/
name|int
name|tx_start_thresh
decl_stmt|;
comment|/* Current TX_start_thresh.	*/
name|char
name|bus32bit
decl_stmt|;
comment|/* 32bit access possible	*/
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|u_char
name|attached
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ORIGINAL
name|u_short
name|if_port
decl_stmt|;
endif|#
directive|endif
comment|/* ORIGINAL */
name|u_char
name|last_alive
decl_stmt|;
comment|/* information for reconfiguration */
name|u_char
name|last_up
decl_stmt|;
comment|/* information for reconfiguration */
name|int
name|slot
decl_stmt|;
comment|/* PCMCIA slot */
if|#
directive|if
name|NAPM
operator|>
literal|0
name|struct
name|apmhook
name|s_hook
decl_stmt|;
comment|/* reconfiguration support */
name|struct
name|apmhook
name|r_hook
decl_stmt|;
comment|/* reconfiguration support */
endif|#
directive|endif
comment|/* NAPM> 0 */
block|}
name|zp_softc
index|[
name|NZP
index|]
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|MACH_KERNEL
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|send_ID_sequence
argument_list|()
decl_stmt|,
name|f_is_eeprom_busy
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|u_short
name|get_eeprom_data
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|zpprobe
argument_list|()
decl_stmt|,
name|zpopen
argument_list|()
decl_stmt|,
name|zpoutput
argument_list|()
decl_stmt|,
name|zpsetinput
argument_list|()
decl_stmt|,
name|zpgetstat
argument_list|()
decl_stmt|,
name|zpsetstat
argument_list|()
decl_stmt|,
name|zpintr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|zpattach
argument_list|()
decl_stmt|,
name|zpinit
argument_list|()
decl_stmt|,
name|zpstart
argument_list|()
decl_stmt|,
name|zpread
argument_list|()
decl_stmt|,
name|zpreset
argument_list|()
decl_stmt|,
name|zpwatchdog
argument_list|()
decl_stmt|,
name|zpstop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|zp_std
index|[
name|NZP
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bus_device
modifier|*
name|zp_info
index|[
name|NZP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bus_driver
name|zpdriver
init|=
block|{
name|zpprobe
block|,
literal|0
block|,
name|zpattach
block|,
literal|0
block|,
name|zp_std
block|,
literal|"zp"
block|,
name|zp_info
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|zp_softc
name|zp_softc_t
typedef|;
end_typedef

begin_decl_stmt
name|char
modifier|*
name|zp_name
init|=
literal|"zp"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|card_info
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|splnet
value|spl7
end_define

begin_define
define|#
directive|define
name|splimp
value|spl7
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MACH_KERNEL */
end_comment

begin_decl_stmt
name|int
name|zpprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zpattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zpioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|int
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|read_eeprom_data
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|zpinit
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|zpintr
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|zpmbuffill
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zpmbufempty
name|__P
argument_list|(
operator|(
expr|struct
name|zp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|zpread
name|__P
argument_list|(
operator|(
expr|struct
name|zp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|zpreset
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|zpstart
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|zpstop
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|zpwatchdog
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|zpdriver
init|=
block|{
name|zpprobe
block|,
name|zpattach
block|,
literal|"zp"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|send_ID_sequence
name|__P
argument_list|(
operator|(
name|u_short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|get_eeprom_data
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|f_is_eeprom_busy
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MACH_KERNEL */
end_comment

begin_define
define|#
directive|define
name|CARD_INFO
value|"3Com Corporation~3C589"
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|card_info
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * scan the card information structure looking for the version/product info  * tuple.  when we find it, compare it to the string we are looking for.  * return 1 if we find it, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|zp_check_cis
parameter_list|(
name|unsigned
name|char
modifier|*
name|scratch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|card_info
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|scratch
index|[
name|i
index|]
operator|!=
literal|0xff
operator|&&
name|i
operator|<
literal|1024
condition|)
block|{
name|unsigned
name|char
name|link
init|=
name|scratch
index|[
name|i
operator|+
literal|2
index|]
decl_stmt|;
if|#
directive|if
literal|0
block|printf ("[%02x] %02x ", i, link); 	for (j = 4; j< 2 * link + 4&& j< 32; j += 2) 	    printf ("%02x ", scratch[j + i]); 	printf ("\n");
endif|#
directive|endif
if|if
condition|(
name|scratch
index|[
name|i
index|]
operator|==
literal|0x15
condition|)
block|{
comment|/* 	     * level 1 version/product info 	     * copy to card_info, translating '\0' to '~' 	     */
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|8
init|;
name|scratch
index|[
name|j
index|]
operator|!=
literal|0xff
condition|;
name|j
operator|+=
literal|2
control|)
name|card_info
index|[
name|k
operator|++
index|]
operator|=
name|scratch
index|[
name|j
index|]
operator|==
literal|'\0'
condition|?
literal|'~'
else|:
name|scratch
index|[
name|j
index|]
expr_stmt|;
name|card_info
index|[
name|k
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"card info = %s\n"
argument_list|,
name|card_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"result = %d\n"
argument_list|,
name|memcmp
argument_list|(
name|card_info
argument_list|,
name|CARD_INFO
argument_list|,
sizeof|sizeof
argument_list|(
name|CARD_INFO
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|memcmp
argument_list|(
name|card_info
argument_list|,
name|CARD_INFO
argument_list|,
sizeof|sizeof
argument_list|(
name|CARD_INFO
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
name|i
operator|+=
literal|4
operator|+
literal|2
operator|*
name|link
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Probe each slot looking for an IBM Credit Card Adapter for Ethernet  * For each card that we find, map its card information structure  * into system memory at 'scratch' and see whether it's one of ours.  * Return the slot number if we find a card, or -1 otherwise.   *  * Side effects:  * + On success, leaves CIS mapped into memory at 'scratch';  *   caller must free it.  * + On success, leaves ethernet address in enet_addr.  * + Leaves product/vendor id of last card probed in 'card_info'  */
end_comment

begin_decl_stmt
name|int
name|prev_slot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zp_find_adapter
parameter_list|(
name|unsigned
name|char
modifier|*
name|scratch
parameter_list|,
name|int
name|reconfig
parameter_list|)
block|{
name|int
name|slot
decl_stmt|;
for|for
control|(
name|slot
operator|=
name|prev_slot
init|;
name|slot
operator|<
name|MAXSLOT
condition|;
operator|++
name|slot
control|)
block|{
comment|/* 	 * see if there's a PCMCIA controller here 	 * Intel PCMCIA controllers use 0x82 and 0x83 	 * IBM clone chips use 0x88 and 0x89, apparently 	 */
comment|/* 	 * IBM ThinkPad230Cs use 0x84. 	 */
name|unsigned
name|char
name|idbyte
init|=
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_ID_REV
argument_list|)
decl_stmt|;
if|if
condition|(
name|idbyte
operator|!=
literal|0x82
operator|&&
name|idbyte
operator|!=
literal|0x83
operator|&&
name|idbyte
operator|!=
literal|0x84
operator|&&
comment|/* for IBM ThinkPad 230Cs */
name|idbyte
operator|!=
literal|0x88
operator|&&
name|idbyte
operator|!=
literal|0x89
condition|)
block|{
if|#
directive|if
literal|0
block|printf ("ibmccae: pcic slot %d: wierd id/rev code 0x%02x\n", 		    slot, idbyte);
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
operator|(
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_STATUS
argument_list|)
operator|&
name|PCIC_CD
operator|)
operator|!=
name|PCIC_CD
condition|)
block|{
if|if
condition|(
operator|!
name|reconfig
condition|)
block|{
name|printf
argument_list|(
literal|"zp: slot %d: no card in slot\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"zp: slot %d: no card in slot\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
comment|/* no card in slot */
continue|continue;
block|}
name|pcic_power_on
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|pcic_reset
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* 	 * map the card's attribute memory and examine its  	 * card information structure tuples for something 	 * we recognize. 	 */
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|pcic_map_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|scratch
argument_list|,
literal|0L
argument_list|,
literal|0xFFFL
argument_list|,
name|ATTRIBUTE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|pcic_map_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|kvtop
argument_list|(
name|scratch
argument_list|)
argument_list|,
literal|0L
argument_list|,
literal|0xFFFL
argument_list|,
name|ATTRIBUTE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
if|if
condition|(
operator|(
name|zp_check_cis
argument_list|(
name|scratch
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* found it */
if|if
condition|(
operator|!
name|reconfig
condition|)
block|{
name|printf
argument_list|(
literal|"zp: found card in slot %d\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"zp: found card in slot %d\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
name|prev_slot
operator|=
operator|(
name|prev_slot
operator|==
name|MAXSLOT
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|prev_slot
operator|+
literal|1
expr_stmt|;
return|return
name|slot
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|reconfig
condition|)
block|{
name|printf
argument_list|(
literal|"zp: pcmcia slot %d: %s\n"
argument_list|,
name|slot
argument_list|,
name|card_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"zp: pcmcia slot %d: %s\n"
argument_list|,
name|slot
argument_list|,
name|card_info
argument_list|)
expr_stmt|;
block|}
block|}
name|pcic_unmap_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|prev_slot
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * macros to handle casting unsigned long to (char *) so we can  * read/write into physical memory space.  */
end_comment

begin_define
define|#
directive|define
name|PEEK
parameter_list|(
name|addr
parameter_list|)
value|(*((unsigned char *)(addr)))
end_define

begin_define
define|#
directive|define
name|POKE
parameter_list|(
name|addr
parameter_list|,
name|val
parameter_list|)
value|do { PEEK(addr) = (val); } while (0)
end_define

begin_comment
comment|/*  * Determine if the device is present  *  *   on entry:  * 	a pointer to an isa_device struct  *   on exit:  *	NULL if device not found  *	or # of i/o addresses used (if found)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MACH_KERNEL
end_ifdef

begin_decl_stmt
name|int
name|zpprobe
argument_list|(
name|port
argument_list|,
name|dev
argument_list|)
decl|struct
name|bus_device
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MACH_KERNEL */
end_comment

begin_function
name|int
name|zpprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|isa_dev
parameter_list|)
endif|#
directive|endif
comment|/* MACH_KERNEL */
block|{
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|zp_softc_t
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|dev
operator|->
name|unit
index|]
decl_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
name|u_int
name|memsize
decl_stmt|;
name|u_char
name|iptr
decl_stmt|,
name|memwidth
decl_stmt|,
name|sum
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|u_short
name|k
decl_stmt|;
name|int
name|id_port
init|=
literal|0x100
decl_stmt|;
comment|/* XXX */
name|int
name|re_init_flag
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpprobe ####\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|cngetc
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
endif|#
directive|endif
comment|/* ZP_DEBUG */
ifdef|#
directive|ifdef
name|MACH_KERNEL
define|#
directive|define
name|DELAY
parameter_list|(
name|x
parameter_list|)
value|delay(x * 10)
name|sc
operator|->
name|attached
operator|=
literal|0
expr_stmt|;
name|BASE
operator|=
name|dev
operator|->
name|address
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
if|if
condition|(
operator|(
name|slot
operator|=
name|zp_find_adapter
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|,
name|isa_dev
operator|->
name|id_reconfig
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* 	 * okay, we found a card, so set it up 	 */
comment|/* 	 * Inhibit 16 bit memory delay. 	 * POINTETH.SYS apparently does this, for what reason I don't know. 	 */
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_CDGC
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_CDGC
argument_list|)
operator||
name|PCIC_16_DL_INH
argument_list|)
expr_stmt|;
comment|/* 	 * things to map 	 * (1) card's EEPROM is already mapped by the find_adapter routine 	 *     but we still need to get the card's ethernet address. 	 *     after that we unmap that part of attribute memory. 	 * (2) card configuration registers need to be mapped in so we 	 *     can set the configuration and socket # registers. 	 * (3) shared memory packet buffer 	 * (4) i/o ports 	 * (5) IRQ 	 */
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * Sigh.  Location of the ethernet address isn't documented in [1]. 	 * It was derived by doing a hex dump of all of attribute memory 	 * and looking for the IBM vendor prefix. 	 */
name|enet_addr
index|[
literal|0
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff0
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|1
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff2
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|2
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff4
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|3
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff6
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|4
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff8
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|5
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xffa
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|pcic_unmap_memory (slot, 0);
endif|#
directive|endif
name|re_init_flag
operator|=
literal|0
expr_stmt|;
name|re_init
label|:
comment|/* 	 * (2) map card configuration registers.  these are offset 	 * in card memory space by 0x20000.  normally we could get 	 * this offset from the card information structure, but I'm 	 * too lazy and am not quite sure if I understand the CIS anyway. 	 * 	 * XXX IF YOU'RE TRYING TO PORT THIS DRIVER FOR A DIFFERENT 	 * PCMCIA CARD, the most likely thing to change is the constant 	 * 0x20000 in the next statement.  Oh yes, also change the 	 * card id string that we probe for. 	 */
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|pcic_map_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|dev
operator|->
name|phys_address
argument_list|,
literal|0x10000
argument_list|,
literal|8L
argument_list|,
name|ATTRIBUTE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|POKE
argument_list|(
name|phystokv
argument_list|(
name|dev
operator|->
name|phys_address
argument_list|)
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* reset the card (how long?) */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
else|#
directive|else
name|pcic_map_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|kvtop
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|)
argument_list|,
literal|0x10000
argument_list|,
literal|8L
argument_list|,
name|ATTRIBUTE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|POKE
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* reset the card (how long?) */
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set the configuration index.  According to [1], the adapter won't 	 * respond to any i/o signals until we do this; it uses the 	 * Memory Only interface (whatever that is; it's not documented). 	 * Also turn on "level" (not pulse) interrupts. 	 * 	 * XXX probably should init the socket and copy register also, 	 * so that we can deal with multiple instances of the same card. 	 */
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|POKE
argument_list|(
name|phystokv
argument_list|(
name|dev
operator|->
name|phys_address
argument_list|)
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
name|pcic_unmap_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|POKE
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
name|pcic_unmap_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL*/
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * (3) now map in the shared memory buffer.  This has to be mapped 	 * as words, not bytes, and on a 16k boundary.  The offset value 	 * was derived by installing IBM's POINTETH.SYS under DOS and 	 * looking at the PCIC registers; it's not documented in IBM's 	 * tech ref manual ([1]). 	 */
name|pcic_map_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|kvtop
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|)
argument_list|,
literal|0x4000L
argument_list|,
literal|0x4000L
argument_list|,
name|COMMON
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * (4) map i/o ports. 	 * 	 * XXX is it possible that the config file leaves this unspecified, 	 * in which case we have to pick one? 	 * 	 * At least one PCMCIA device driver I'v seen maps a block 	 * of 32 consecutive i/o ports as two windows of 16 ports each. 	 * Maybe some other pcic chips are restricted to 16-port windows; 	 * the 82365SL doesn't seem to have that problem.  But since 	 * we have an extra window anyway... 	 */
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|pcic_map_io
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|dev
operator|->
name|address
argument_list|,
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
literal|1
name|pcic_map_io
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|isa_dev
operator|->
name|id_iobase
argument_list|,
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
name|pcic_map_io
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|isa_dev
operator|->
name|id_iobase
argument_list|,
literal|16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pcic_map_io
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|,
name|isa_dev
operator|->
name|id_iobase
operator|+
literal|16
argument_list|,
literal|16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * (5) configure the card for the desired interrupt 	 * 	 * XXX is it possible that the config file leaves this unspecified? 	 */
name|pcic_map_irq
argument_list|(
name|slot
argument_list|,
name|ffs
argument_list|(
name|isa_dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* tell the PCIC that this is an I/O card (not memory) */
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_INT_GEN
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_INT_GEN
argument_list|)
operator||
name|PCIC_CARDTYPE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* tell the PCIC to use level-mode interrupts */
comment|/* XXX this register may not be present on all controllers */
block|pcic_putb (slot, PCIC_GLO_CTRL, 		   pcic_getb (slot, PCIC_GLO_CTRL) | PCIC_LVL_MODE);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|pcic_print_regs
argument_list|(
name|slot
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notdef
comment|/* I couldn't find the following part in linux. seiji */
comment|/* 	 * Setup i/o addresses 	 */
name|sc
operator|->
name|nic_addr
operator|=
name|isa_dev
operator|->
name|id_iobase
expr_stmt|;
if|#
directive|if
literal|0
block|sc->vector = isa_dev->id_irq;
endif|#
directive|endif
name|sc
operator|->
name|smem_start
operator|=
operator|(
name|caddr_t
operator|)
name|isa_dev
operator|->
name|id_maddr
expr_stmt|;
if|#
directive|if
literal|0
block|sc->vendor = ZE_VENDOR_IBM; 	sc->type = xxx;
endif|#
directive|endif
comment|/* reset card to force it into a known state */
name|tmp
operator|=
name|inb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ZE_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ZE_RESET
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
comment|/* 	 * query MAM bit in misc register for 10base2 	 */
name|tmp
operator|=
name|inb
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|ZE_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
operator|&&
operator|!
name|re_init_flag
condition|)
block|{
name|re_init_flag
operator|++
expr_stmt|;
goto|goto
name|re_init
goto|;
block|}
name|sc
operator|->
name|mau
operator|=
name|tmp
operator|&
literal|0x09
condition|?
literal|"10base2"
else|:
literal|"10baseT"
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|sc
operator|->
name|ep_io_addr
operator|=
name|dev
operator|->
name|address
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|sc
operator|->
name|ep_io_addr
operator|=
name|isa_dev
operator|->
name|id_iobase
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|k = get_eeprom_data(BASE, EEPROM_ADDR_CFG);
comment|/* get addr cfg */
endif|#
directive|endif
name|k
operator|=
name|read_eeprom_data
argument_list|(
name|BASE
argument_list|,
name|EEPROM_ADDR_CFG
argument_list|)
expr_stmt|;
comment|/* get addr cfg */
ifndef|#
directive|ifndef
name|ORIGINAL
name|sc
operator|->
name|if_port
operator|=
name|k
operator|>>
literal|14
expr_stmt|;
endif|#
directive|endif
comment|/* ORIGINAL */
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"EEPROM data = 0x%x\n"
argument_list|,
name|k
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|k
operator|=
operator|(
name|k
operator|&
literal|0x1f
operator|)
operator|*
literal|0x10
operator|+
literal|0x200
expr_stmt|;
comment|/* decode base addr. */
ifdef|#
directive|ifdef
name|MACH_KERNEL
if|if
condition|(
name|k
operator|!=
operator|(
name|u_short
operator|)
name|dev
operator|->
name|address
condition|)
else|#
directive|else
comment|/* MACH_KERNEL */
if|if
condition|(
name|k
operator|!=
operator|(
name|u_short
operator|)
name|isa_dev
operator|->
name|id_iobase
condition|)
endif|#
directive|endif
comment|/* MACH_KERNEL */
block|{
if|if
condition|(
operator|!
name|re_init_flag
condition|)
block|{
name|re_init_flag
operator|++
expr_stmt|;
goto|goto
name|re_init
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|k
operator|=
name|read_eeprom_data
argument_list|(
name|BASE
argument_list|,
name|EEPROM_RESOURCE_CFG
argument_list|)
expr_stmt|;
name|k
operator|>>=
literal|12
expr_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"!!!IRQ Mach config: %d, board config: %d!!!\n"
argument_list|,
name|dev
operator|->
name|sysdep1
argument_list|,
operator|(
name|k
operator|==
literal|2
operator|)
condition|?
literal|9
else|:
name|k
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|cngetc
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
endif|#
directive|endif
comment|/* ZP_DEBUG */
if|if
condition|(
name|dev
operator|->
name|sysdep1
operator|!=
operator|(
operator|(
name|k
operator|==
literal|2
operator|)
condition|?
literal|9
else|:
name|k
operator|)
condition|)
else|#
directive|else
comment|/* MACH_KERNEL */
if|if
condition|(
name|isa_dev
operator|->
name|id_irq
operator|!=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|k
operator|==
literal|2
operator|)
condition|?
literal|9
else|:
name|k
operator|)
operator|)
condition|)
endif|#
directive|endif
comment|/* MACH_KERNEL */
ifdef|#
directive|ifdef
name|ZP_DEBUG
block|{
name|printf
argument_list|(
literal|"Unmatched !!!!!!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
comment|/* ZP_DEBUG */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
if|#
directive|if
literal|0
block|outb(id_port, ACTIVATE_ADAPTER_TO_CONFIG);
else|#
directive|else
name|outb
argument_list|(
name|BASE
argument_list|,
name|ACTIVATE_ADAPTER_TO_CONFIG
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|dev
operator|->
name|name
operator|=
name|zp_name
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
comment|/* MACH_KERNEL */
comment|/* information for reconfiguration */
name|sc
operator|->
name|last_alive
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|last_up
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
return|return
operator|(
literal|0x10
operator|)
return|;
comment|/* 16 bytes of I/O space used. */
endif|#
directive|endif
comment|/* MACH_KERNEL */
block|}
end_function

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_function
specifier|static
name|int
name|zp_suspend
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|pcic_power_off
argument_list|(
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zp_resume
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
name|prev_slot
operator|=
literal|0
expr_stmt|;
name|reconfig_isadev
argument_list|(
name|isa_dev
argument_list|,
operator|&
name|net_imask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

begin_comment
comment|/*  * Install interface into kernel networking data structures  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MACH_KERNEL
end_ifdef

begin_decl_stmt
name|void
name|zpattach
argument_list|(
name|dev
argument_list|)
decl|struct
name|bus_device
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MACH_KERNEL */
end_comment

begin_function
name|int
name|zpattach
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
block|{
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|zp_softc_t
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|dev
operator|->
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
operator|(
name|sc
operator|->
name|ds_if
operator|)
decl_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|u_short
name|i
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|int
name|pl
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpattach ####\n"
argument_list|)
expr_stmt|;
name|cngetc
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
comment|/* PCMCIA card can be offlined. Reconfiguration is required */
if|if
condition|(
name|isa_dev
operator|->
name|id_reconfig
condition|)
block|{
name|zpreset
argument_list|(
name|isa_dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isa_dev
operator|->
name|id_alive
operator|&&
name|sc
operator|->
name|last_alive
condition|)
block|{
name|pl
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|last_up
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
expr_stmt|;
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
name|sc
operator|->
name|last_alive
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|isa_dev
operator|->
name|id_alive
operator|&&
operator|!
name|sc
operator|->
name|last_alive
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|last_up
condition|)
block|{
name|pl
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|if_up
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|last_alive
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
else|else
block|{
name|sc
operator|->
name|last_alive
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|printf
argument_list|(
literal|", port = %x, spl = %d, pic = %d. "
argument_list|,
name|dev
operator|->
name|address
argument_list|,
name|dev
operator|->
name|sysdep
argument_list|,
name|dev
operator|->
name|sysdep1
argument_list|)
expr_stmt|;
name|take_dev_irq
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ep_io_addr
operator|=
name|dev
operator|->
name|address
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|sc
operator|->
name|ep_io_addr
operator|=
name|isa_dev
operator|->
name|id_iobase
expr_stmt|;
name|printf
argument_list|(
literal|"zp%d: "
argument_list|,
name|isa_dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|sc
operator|->
name|ep_connectors
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|i
operator|=
name|inw
argument_list|(
name|sc
operator|->
name|ep_io_addr
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|i
operator|=
name|inw
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
ifdef|#
directive|ifdef
name|ZP_DEBUG
block|{
name|short
name|if_port
decl_stmt|;
name|if_port
operator|=
name|read_eeprom_data
argument_list|(
name|BASE
argument_list|,
literal|8
argument_list|)
operator|>>
literal|14
expr_stmt|;
name|sc
operator|->
name|if_port
operator|=
name|if_port
expr_stmt|;
name|printf
argument_list|(
literal|"Linux select:%x\n"
argument_list|,
name|if_port
argument_list|)
expr_stmt|;
name|cngetc
argument_list|()
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"SELECT connectors:%x\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
if|if
condition|(
name|i
operator|&
name|IS_AUI
condition|)
block|{
name|printf
argument_list|(
literal|"aui"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ep_connectors
operator||=
name|AUI
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
name|IS_BNC
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ep_connectors
condition|)
name|printf
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bnc"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ep_connectors
operator||=
name|BNC
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
name|IS_UTP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ep_connectors
condition|)
name|printf
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"utp"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ep_connectors
operator||=
name|UTP
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|ep_connectors
condition|)
name|printf
argument_list|(
literal|"no connectors!"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
ifndef|#
directive|ifndef
name|ORIGINAL
name|printf
argument_list|(
literal|":%s was selected.\n"
argument_list|,
name|if_names
index|[
name|sc
operator|->
name|if_port
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|cngetc
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* EP_DEBUG */
endif|#
directive|endif
comment|/* ORIGINAL */
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|{
name|short
name|tmp_addr
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|tmp_addr
index|[
name|i
index|]
operator|=
name|htons
argument_list|(
name|read_eeprom_data
argument_list|(
name|BASE
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|bcopy
argument_list|(
name|tmp_addr
argument_list|,
name|sc
operator|->
name|ds_addr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|bcopy
argument_list|(
name|tmp_addr
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
block|}
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|printf
argument_list|(
literal|"id [%x:%x:%x:%x:%x:%x]"
argument_list|,
name|sc
operator|->
name|ds_addr
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|ds_addr
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|ds_addr
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|ds_addr
index|[
literal|3
index|]
argument_list|,
name|sc
operator|->
name|ds_addr
index|[
literal|4
index|]
argument_list|,
name|sc
operator|->
name|ds_addr
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" address %s\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|ds_addr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|cngetc
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
else|#
directive|else
comment|/* MACH_KERNEL */
name|printf
argument_list|(
literal|" address %s\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|dev
operator|->
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_header_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_header_format
operator|=
name|HDR_ETHERNET
expr_stmt|;
name|ifp
operator|->
name|if_address_size
operator|=
literal|6
expr_stmt|;
name|ifp
operator|->
name|if_address
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|ds_addr
index|[
literal|0
index|]
expr_stmt|;
define|#
directive|define
name|IFF_ALTPHYS
value|0x8000
ifdef|#
directive|ifdef
name|ORIGINAL
comment|/*       * This is a temporary.       * Mach can not select link with ifconfig,      * so I select AUI statically.      */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALTPHYS
expr_stmt|;
else|#
directive|else
else|ORIGINAL
comment|/*       * Select connector according to board setting.      */
if|if
condition|(
name|sc
operator|->
name|if_port
operator|!=
literal|3
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALTPHYS
expr_stmt|;
block|}
endif|#
directive|endif
endif|ORIGINAL
name|if_init_queues
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|attached
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_NOTRAILERS
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|isa_dev
operator|->
name|id_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"zp"
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|zpinit
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|zpstart
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|zpioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|zpwatchdog
expr_stmt|;
comment|/*  	 * Select connector according to board setting. 	 */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|#
directive|if
literal|0
block|if (sc->if_port != 3) { 		ifp->if_flags |= IFF_LINK0; 	}
else|#
directive|else
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LINK0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* __NetBSD__ || __FreeBSD__ */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
ifndef|#
directive|ifndef
name|MACH_KERNEL
comment|/* 	 * Fill the hardware address into ifa_addr if we find an 	 * AF_LINK entry. We need to do this so bpf's can get the hardware 	 * addr of this card. netstat likes this too! 	 */
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
expr_stmt|;
while|while
condition|(
operator|(
name|ifa
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
operator|)
condition|)
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
expr_stmt|;
if|if
condition|(
operator|(
name|ifa
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
literal|0
operator|)
condition|)
block|{
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ETHER_ADDR_LEN
expr_stmt|;
name|sdl
operator|->
name|sdl_slen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NAPM
operator|>
literal|0
name|sc
operator|->
name|s_hook
operator|.
name|ah_fun
operator|=
name|zp_suspend
expr_stmt|;
name|sc
operator|->
name|s_hook
operator|.
name|ah_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|isa_dev
expr_stmt|;
name|sc
operator|->
name|s_hook
operator|.
name|ah_name
operator|=
literal|"3Com PCMCIA Etherlink III 3C589"
expr_stmt|;
name|sc
operator|->
name|s_hook
operator|.
name|ah_order
operator|=
name|APM_MID_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_SUSPEND
argument_list|,
operator|&
name|sc
operator|->
name|s_hook
argument_list|)
expr_stmt|;
name|sc
operator|->
name|r_hook
operator|.
name|ah_fun
operator|=
name|zp_resume
expr_stmt|;
name|sc
operator|->
name|r_hook
operator|.
name|ah_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|isa_dev
expr_stmt|;
name|sc
operator|->
name|r_hook
operator|.
name|ah_name
operator|=
literal|"3Com PCMCIA Etherlink III 3C589"
expr_stmt|;
name|sc
operator|->
name|r_hook
operator|.
name|ah_order
operator|=
name|APM_MID_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_RESUME
argument_list|,
operator|&
name|sc
operator|->
name|r_hook
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAPM> 0 */
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
block|}
end_function

begin_comment
comment|/*  * The order in here seems important. Otherwise we may not receive  * interrupts. ?!  */
end_comment

begin_function
name|void
name|zpinit
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|ds_if
decl_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpinit ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
ifndef|#
directive|ifndef
name|MACH_KERNEL
if|if
condition|(
name|ifp
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable the card */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable the card */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
name|ENABLE_DRQ_IRQ
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Reload the ether_addr. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W2_ADDR_0
operator|+
name|i
argument_list|,
name|sc
operator|->
name|ds_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W2_ADDR_0
operator|+
name|i
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
comment|/* Window 1 is operating window */
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|)
expr_stmt|;
comment|/* get rid of stray intr's */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|ACK_INTR
operator||
literal|0xff
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RD_0_MASK
operator||
name|S_CARD_FAILURE
operator||
name|S_RX_COMPLETE
operator||
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_INTR_MASK
operator||
name|S_CARD_FAILURE
operator||
name|S_RX_COMPLETE
operator||
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ORIGINAL
ifndef|#
directive|ifndef
name|IFF_MULTICAST
define|#
directive|define
name|IFF_MULTICAST
value|0x10000
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_FILTER
operator||
name|FIL_INDIVIDUAL
operator||
operator|(
operator|(
name|sc
operator|->
name|ds_if
operator|.
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
condition|?
name|FIL_GROUP
else|:
literal|0
operator|)
operator||
name|FIL_BRDCST
operator||
operator|(
operator|(
name|sc
operator|->
name|ds_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
name|FIL_ALL
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_FILTER
operator||
name|FIL_INDIVIDUAL
operator||
operator|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
condition|?
name|FIL_GROUP
else|:
literal|0
operator|)
operator||
name|FIL_BRDCST
operator||
operator|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
name|FIL_ALL
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MACH_KERNEL
else|#
directive|else
comment|/* ORIGINAL */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_FILTER
operator||
name|FIL_INDIVIDUAL
operator||
name|FIL_GROUP
operator||
name|FIL_BRDCST
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ORIGINAL */
comment|/* 	 * you can `ifconfig (link0|-link0) ep0' to get the following 	 * behaviour: 	 *	-link0	disable AUI/UTP. enable BNC. 	 *	link0	disable BNC. enable AUI. if the card has a UTP 	 *		connector, that is enabled too. not sure, but it 	 * 		seems you have to be careful to not plug things 	 *		into both AUI& UTP. 	 */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|ep_connectors
operator|&
name|BNC
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
operator|)
operator|&&
operator|(
name|sc
operator|->
name|ep_connectors
operator|&
name|BNC
operator|)
condition|)
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"START TRANCEIVER"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|START_TRANSCEIVER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|ep_connectors
operator|&
name|UTP
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
operator|)
operator|&&
operator|(
name|sc
operator|->
name|ep_connectors
operator|&
name|UTP
operator|)
condition|)
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"ENABLE UTP"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
name|GO_WINDOW
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W4_MEDIA_TYPE
argument_list|,
name|ENABLE_UTP
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_ENABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
ifndef|#
directive|ifndef
name|MACH_KERNEL
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* just in case */
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|sc
operator|->
name|tx_start_thresh
operator|=
literal|20
expr_stmt|;
comment|/* probably a good starting point. */
ifndef|#
directive|ifndef
name|MACH_KERNEL
comment|/* 	 * Store up a bunch of mbuf's for use later. (MAX_MBS). First we 	 * free up any that we had in case we're being called from intr or 	 * somewhere else. 	 */
name|sc
operator|->
name|last_mb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|next_mb
operator|=
literal|0
expr_stmt|;
name|zpmbuffill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
ifdef|#
directive|ifdef
name|MACH_KERNEL
if|#
directive|if
literal|0
comment|/* seiji */
block|sc->tbusy = 0;
endif|#
directive|endif
name|zpstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|zpstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpinit done ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
block|}
specifier|static
specifier|const
name|char
name|padmap
index|[]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|void
name|zpstart
argument_list|(
name|unit
argument_list|)
name|int
name|unit
decl_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|void
name|zpstart
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
block|{
ifdef|#
directive|ifdef
name|MACH_KERNEL
specifier|register
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|ds_if
decl_stmt|;
name|io_req_t
name|m
decl_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
specifier|register
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|top
decl_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|pad
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpstart ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"head1 = 0x%x\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
operator|.
name|ifq_head
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BASE = 0x%x\n"
argument_list|,
name|BASE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|MACH_KERNEL
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpstart oactive ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
return|return;
block|}
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|startagain
label|:
ifdef|#
directive|ifdef
name|MACH_KERNEL
if|#
directive|if
literal|0
comment|/* seiji */
block|if (sc->tbusy) { 	    return; 	}
endif|#
directive|endif
comment|/* Sneak a peek at the next packet */
name|m
operator|=
call|(
name|io_req_t
call|)
argument_list|(
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|.
name|next
operator|==
operator|(
name|queue_t
operator|)
operator|&
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|)
operator|)
operator|?
literal|0
operator|:
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|.
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpstart none data 1 ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
return|return;
block|}
if|#
directive|if
literal|0
block|IF_DEQUEUE(&ifp->if_snd, m); 	if (NULL == m) { 	    return; 	}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* seiji */
block|sc->tbusy++; 	zp_cntrs[unit].xmt++;
endif|#
directive|endif
name|len
operator|=
name|m
operator|->
name|io_count
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
comment|/* Sneak a peek at the next packet */
name|m
operator|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
operator|.
name|ifq_head
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"head2 = 0x%x\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
operator|.
name|ifq_head
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpstart none data 2 ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EP_DEBUG */
return|return;
block|}
if|#
directive|if
literal|0
block|len = m->m_pkthdr.len;
else|#
directive|else
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|top
operator|=
name|m
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|pad
operator|=
name|padmap
index|[
name|len
operator|&
literal|3
index|]
expr_stmt|;
comment|/* 	 * The 3c509 automatically pads short packets to minimum ethernet 	 * length, but we drop packets that are too large. Perhaps we should 	 * truncate them instead? 	 */
if|if
condition|(
name|len
operator|+
name|pad
operator|>
name|ETHER_MAX_LEN
condition|)
block|{
comment|/* packet is obviously too large: toss it */
ifdef|#
directive|ifdef
name|MACH_KERNEL
operator|++
operator|(
name|ifp
operator|->
name|if_oerrors
operator|)
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
operator|(
name|ifp
operator|->
name|if_snd
operator|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|iodone
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
goto|goto
name|readcheck
goto|;
block|}
if|#
directive|if
literal|1
if|if
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_FREE_TX
argument_list|)
operator|<
name|len
operator|+
name|pad
operator|+
literal|4
condition|)
block|{
comment|/* no room in FIFO */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_TX_AVAIL_THRESH
operator||
operator|(
name|len
operator|+
name|pad
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MACH_KERNEL
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpstart no room ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EP_DEBUG */
return|return;
block|}
else|#
directive|else
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_FREE_TX
argument_list|)
operator|)
operator|<
name|len
operator|+
name|pad
operator|+
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"BASE + EP_W1_FREE_TX = 0x%x\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* no room in FIFO */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_TX_AVAIL_THRESH
operator||
operator|(
name|len
operator|+
name|pad
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MACH_KERNEL
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"### zpstart no room ####\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"BASE + EP_W1_FREE_TX = 0x%x\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|IF_DEQUEUE
argument_list|(
operator|&
operator|(
name|ifp
operator|->
name|if_snd
operator|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
comment|/* not really needed */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpstart ??? ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
return|return;
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_TX_START_THRESH
operator||
operator|(
name|len
operator|/
literal|4
operator|+
name|sc
operator|->
name|tx_start_thresh
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* Second dword meaningless */
ifdef|#
directive|ifdef
name|MACH_KERNEL
if|if
condition|(
name|sc
operator|->
name|bus32bit
condition|)
block|{
name|loutl
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|m
operator|->
name|io_data
argument_list|,
name|len
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|3
condition|)
name|loutb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|m
operator|->
name|io_data
operator|+
operator|(
name|len
operator|&
operator|~
literal|3
operator|)
argument_list|,
name|len
operator|&
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|loutw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|m
operator|->
name|io_data
argument_list|,
name|len
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&
literal|1
condition|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
operator|*
operator|(
name|m
operator|->
name|io_data
operator|+
name|len
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* MACH_KERNEL */
for|for
control|(
name|top
operator|=
name|m
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|bus32bit
condition|)
block|{
name|outsl
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|&
literal|3
condition|)
name|outsb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|/
literal|4
argument_list|,
name|m
operator|->
name|m_len
operator|&
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"Output len = %d\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
name|outsw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|&
literal|1
condition|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* MACH_KERNEL */
while|while
condition|(
name|pad
operator|--
condition|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Padding */
ifndef|#
directive|ifndef
name|MACH_KERNEL
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|bpf
condition|)
block|{
if|#
directive|if
literal|0
block|u_short etype; 		int     off, datasize, resid; 		struct ether_header *eh; 		struct trailer_header { 			u_short ether_type; 			u_short ether_residual; 		}       trailer_header; 		char    ether_packet[ETHER_MAX_LEN]; 		char   *ep;  		ep = ether_packet;
comment|/* 		 * We handle trailers below: 		 * Copy ether header first, then residual data, 		 * then data. Put all this in a temporary buffer 		 * 'ether_packet' and send off to bpf. Since the 		 * system has generated this packet, we assume 		 * that all of the offsets in the packet are 		 * correct; if they're not, the system will almost 		 * certainly crash in m_copydata. 		 * We make no assumptions about how the data is 		 * arranged in the mbuf chain (i.e. how much 		 * data is in each mbuf, if mbuf clusters are 		 * used, etc.), which is why we use m_copydata 		 * to get the ether header rather than assume 		 * that this is located in the first mbuf. 		 */
comment|/* copy ether header */
block|m_copydata(top, 0, sizeof(struct ether_header), ep); 		eh = (struct ether_header *) ep; 		ep += sizeof(struct ether_header); 		eh->ether_type = etype = ntohs(eh->ether_type); 		if (etype>= ETHERTYPE_TRAIL&& 		    etype< ETHERTYPE_TRAIL + ETHERTYPE_NTRAILER) { 			datasize = ((etype - ETHERTYPE_TRAIL)<< 9); 			off = datasize + sizeof(struct ether_header);
comment|/* copy trailer_header into a data structure */
block|m_copydata(top, off, sizeof(struct trailer_header), 			    (caddr_t)&trailer_header.ether_type);
comment|/* copy residual data */
block|resid = trailer_header.ether_residual - 			    sizeof(struct trailer_header); 			resid = ntohs(resid); 			m_copydata(top, off + sizeof(struct trailer_header), 			    resid, ep); 			ep += resid;
comment|/* copy data */
block|m_copydata(top, sizeof(struct ether_header), 			    datasize, ep); 			ep += datasize;
comment|/* restore original ether packet type */
block|eh->ether_type = trailer_header.ether_type;  			bpf_tap(sc->bpf, ether_packet, ep - ether_packet); 		} else 			bpf_mtap(sc->bpf, top);
endif|#
directive|endif
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|bpf
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* MACH_KERNEL */
ifdef|#
directive|ifdef
name|MACH_KERNEL
operator|++
operator|(
name|ifp
operator|->
name|if_opackets
operator|)
expr_stmt|;
name|iodone
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
comment|/* 	 * Is another packet coming in? We don't want to overflow the 	 * tiny RX fifo. 	 */
name|readcheck
label|:
if|if
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_STATUS
argument_list|)
operator|&
name|RX_BYTES_MASK
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpstart done ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
return|return;
block|}
ifdef|#
directive|ifdef
name|ZP_DEBUG2
name|printf
argument_list|(
literal|"### zpstart startagain ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
goto|goto
name|startagain
goto|;
block|}
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|int
name|zpopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpopen ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
if|if
condition|(
name|unit
operator|<
literal|0
operator|||
name|unit
operator|>=
name|NZP
operator|||
name|zp_softc
index|[
name|unit
index|]
operator|.
name|attached
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|zp_softc
index|[
name|unit
index|]
operator|.
name|ds_if
operator|.
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|zpinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|int
name|zpoutput
parameter_list|(
name|dev
parameter_list|,
name|ior
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|io_req_t
name|ior
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|io_return_t
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpoutput ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
if|if
condition|(
name|unit
operator|<
literal|0
operator|||
name|unit
operator|>=
name|NZP
operator|||
name|zp_softc
index|[
name|unit
index|]
operator|.
name|attached
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|result
operator|=
name|net_write
argument_list|(
operator|&
name|zp_softc
index|[
name|unit
index|]
operator|.
name|ds_if
argument_list|,
name|zpstart
argument_list|,
name|ior
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpoutput done ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
return|return
operator|(
name|result
operator|)
return|;
block|}
name|int
name|zpsetinput
parameter_list|(
name|dev
parameter_list|,
name|receive_port
parameter_list|,
name|priority
parameter_list|,
name|filter
parameter_list|,
name|filter_count
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|mach_port_t
name|receive_port
decl_stmt|;
name|int
name|priority
decl_stmt|;
name|filter_t
name|filter
index|[]
decl_stmt|;
name|unsigned
name|int
name|filter_count
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpsetinput ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
if|if
condition|(
name|unit
operator|<
literal|0
operator|||
name|unit
operator|>=
name|NZP
operator|||
name|zp_softc
index|[
name|unit
index|]
operator|.
name|attached
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|net_set_filter
argument_list|(
operator|&
name|zp_softc
index|[
name|unit
index|]
operator|.
name|ds_if
argument_list|,
name|receive_port
argument_list|,
name|priority
argument_list|,
name|filter
argument_list|,
name|filter_count
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* MACH_KERNEL */
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|int
else|#
directive|else
comment|/* MACH_KERNEL */
name|void
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|zpintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|status
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|ds_if
decl_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpintr ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
name|status
operator|=
literal|0
expr_stmt|;
name|checkintr
label|:
name|status
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
operator|(
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
operator||
name|S_RX_COMPLETE
operator||
name|S_CARD_FAILURE
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ORIGINAL
name|checkintr2
label|:
endif|#
directive|endif
comment|/* ORIGINAL */
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* No interrupts. */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpintr done ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
ifndef|#
directive|ifndef
name|ORIGINAL
if|if
condition|(
name|status
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
operator|(
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
operator||
name|S_RX_COMPLETE
operator||
name|S_CARD_FAILURE
operator|)
condition|)
block|{
goto|goto
name|checkintr2
goto|;
block|}
endif|#
directive|endif
comment|/* ORIGINAL */
ifdef|#
directive|ifdef
name|MACH_KERNEL
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* MACH_KERNEL */
return|return;
endif|#
directive|endif
comment|/* MACH_KERNEL */
block|}
comment|/* important that we do this first. */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|ACK_INTR
operator||
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|S_TX_AVAIL
condition|)
block|{
name|status
operator|&=
operator|~
name|S_TX_AVAIL
expr_stmt|;
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_FREE_TX
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|zpstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|zpstart
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
block|}
if|if
condition|(
name|status
operator|&
name|S_RX_COMPLETE
condition|)
block|{
name|status
operator|&=
operator|~
name|S_RX_COMPLETE
expr_stmt|;
name|zpread
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|S_CARD_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"zp%d: reset (status: %x)\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
name|zpinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpintr error ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
ifdef|#
directive|ifdef
name|MACH_KERNEL
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* MACH_KERNEL */
return|return;
endif|#
directive|endif
comment|/* MACH_KERNEL */
block|}
if|if
condition|(
name|status
operator|&
name|S_TX_COMPLETE
condition|)
block|{
name|status
operator|&=
operator|~
name|S_TX_COMPLETE
expr_stmt|;
comment|/* 		 * We need to read TX_STATUS until we get a 0 status in 		 * order to turn off the interrupt flag. 		 */
while|while
condition|(
operator|(
name|i
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|)
operator|)
operator|&
name|TXS_COMPLETE
condition|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|#
directive|if
name|ZE_DEBUG
name|printf
argument_list|(
literal|"EP_W1_TX_STATUS = 0x%x\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|&
operator|(
name|TXS_MAX_COLLISION
operator||
name|TXS_JABBER
operator||
name|TXS_UNDERRUN
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|&
name|TXS_MAX_COLLISION
condition|)
ifdef|#
directive|ifdef
name|MACH_KERNEL
operator|++
operator|(
name|ifp
operator|->
name|if_collisions
operator|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
if|if
condition|(
name|i
operator|&
operator|(
name|TXS_JABBER
operator||
name|TXS_UNDERRUN
operator|)
condition|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|TXS_UNDERRUN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_start_thresh
operator|<
name|ETHER_MAX_LEN
condition|)
block|{
name|sc
operator|->
name|tx_start_thresh
operator|+=
literal|20
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_TX_START_THRESH
operator||
name|sc
operator|->
name|tx_start_thresh
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
operator|++
operator|(
name|ifp
operator|->
name|if_oerrors
operator|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
block|}
block|}
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|zpstart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|zpstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
block|}
goto|goto
name|checkintr
goto|;
block|}
name|void
name|zpread
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|zp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|struct
name|ether_header
name|eth
decl_stmt|;
name|ipc_kmsg_t
name|new_kmsg
decl_stmt|;
name|struct
name|packet_header
modifier|*
name|pkt
decl_stmt|;
name|int
name|totlen
decl_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|struct
name|mbuf
modifier|*
name|mcur
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|top
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|lenthisone
decl_stmt|;
name|int
name|save_totlen
decl_stmt|;
name|u_short
name|etype
decl_stmt|;
name|int
name|off
decl_stmt|,
name|resid
decl_stmt|;
name|int
name|count
decl_stmt|,
name|spinwait
decl_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpread ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
name|totlen
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_STATUS
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MACH_KERNEL
name|off
operator|=
literal|0
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
if|if
condition|(
name|totlen
operator|&
name|ERR_RX
condition|)
block|{
ifdef|#
directive|ifdef
name|MACH_KERNEL
operator|++
operator|(
name|sc
operator|->
name|ds_if
operator|.
name|if_ierrors
operator|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|totlen
operator|&=
name|RX_BYTES_MASK
expr_stmt|;
comment|/* Lower 11 bits = RX bytes. */
else|#
directive|else
comment|/* MACH_KERNEL */
name|save_totlen
operator|=
name|totlen
operator|&=
name|RX_BYTES_MASK
expr_stmt|;
comment|/* Lower 11 bits = RX bytes. */
endif|#
directive|endif
comment|/* MACH_KERNEL */
ifdef|#
directive|ifdef
name|MACH_KERNEL
comment|/* Get Etherheader */
name|linw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eth
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|totlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|new_kmsg
operator|=
name|net_kmsg_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_kmsg
operator|==
name|IKM_NULL
condition|)
block|{
comment|/* Drop the packet */
operator|++
operator|(
name|sc
operator|->
name|ds_if
operator|.
name|if_rcvdrops
operator|)
expr_stmt|;
comment|/*  	     * Is this true ? 	     * Do I have to remove the packet ? 	     * Maybe out discard incoming packet.  	     */
goto|goto
name|out
goto|;
block|}
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
operator|(
operator|&
name|net_kmsg
argument_list|(
name|new_kmsg
argument_list|)
operator|->
name|header
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|pkt
operator|=
operator|(
expr|struct
name|packet_header
operator|*
operator|)
operator|(
operator|&
name|net_kmsg
argument_list|(
name|new_kmsg
argument_list|)
operator|->
name|packet
index|[
literal|0
index|]
operator|)
expr_stmt|;
operator|*
name|eh
operator|=
name|eth
expr_stmt|;
comment|/* Is this true ? */
if|if
condition|(
name|sc
operator|->
name|bus32bit
condition|)
block|{
name|linl
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|+
literal|1
operator|)
argument_list|,
name|totlen
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|totlen
operator|&
literal|3
condition|)
name|linb
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|+
literal|1
operator|)
operator|+
operator|(
name|totlen
operator|&
operator|~
literal|3
operator|)
argument_list|,
name|totlen
operator|&
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|linw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|+
literal|1
operator|)
argument_list|,
name|totlen
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|totlen
operator|&
literal|1
condition|)
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pkt
operator|+
literal|1
operator|)
operator|+
name|totlen
operator|-
literal|1
operator|)
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|)
expr_stmt|;
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
operator|++
operator|(
name|sc
operator|->
name|ds_if
operator|.
name|if_ipackets
operator|)
expr_stmt|;
name|pkt
operator|->
name|type
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
name|pkt
operator|->
name|length
operator|=
name|totlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|packet_header
argument_list|)
expr_stmt|;
name|net_packet
argument_list|(
operator|&
operator|(
name|sc
operator|->
name|ds_if
operator|)
argument_list|,
name|new_kmsg
argument_list|,
name|pkt
operator|->
name|length
argument_list|,
name|ethernet_priority
argument_list|(
name|new_kmsg
argument_list|,
name|pkt
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpread done ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
return|return;
else|#
directive|else
comment|/* MACH_KERNEL */
name|m
operator|=
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* Convert one of our saved mbuf's */
name|sc
operator|->
name|next_mb
operator|=
operator|(
name|sc
operator|->
name|next_mb
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_pktdat
expr_stmt|;
name|m
operator|->
name|m_flags
operator|=
name|M_PKTHDR
expr_stmt|;
block|}
name|top
operator|=
name|m0
operator|=
name|m
expr_stmt|;
comment|/* We assign top so we can "goto out" */
define|#
directive|define
name|EROUND
value|((sizeof(struct ether_header) + 3)& ~3)
define|#
directive|define
name|EOFF
value|(EROUND - sizeof(struct ether_header))
name|m0
operator|->
name|m_data
operator|+=
name|EOFF
expr_stmt|;
comment|/* Read what should be the header. */
name|insw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|totlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/*  	 * mostly deal with trailer here.  (untested) 	 * We do this in a couple of parts.  First we check for a trailer, if 	 * we have one we convert the mbuf back to a regular mbuf and set the offset and 	 * subtract sizeof(struct ether_header) from the pktlen. 	 * After we've read the packet off the interface (all except for the trailer 	 * header, we then get a header mbuf, read the trailer into it, and fix up 	 * the mbuf pointer chain. 	 */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|etype
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|etype
operator|>=
name|ETHERTYPE_TRAIL
operator|&&
name|etype
operator|<
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
condition|)
block|{
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_dat
expr_stmt|;
comment|/* Convert back to regular mbuf.  */
name|m
operator|->
name|m_flags
operator|=
literal|0
expr_stmt|;
comment|/* This sucks but non-trailers are the norm */
name|off
operator|=
operator|(
name|etype
operator|-
name|ETHERTYPE_TRAIL
operator|)
operator|*
literal|512
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|ETHERMTU
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
comment|/* sanity */
block|}
name|totlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* We don't read the trailer */
name|m
operator|->
name|m_data
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
comment|/* Get rid of type& len */
block|}
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
name|lenthisone
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lenthisone
operator|==
literal|0
condition|)
block|{
comment|/* no room in this one */
name|mcur
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|timeout
argument_list|(
name|zpmbuffill
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|next_mb
operator|=
operator|(
name|sc
operator|->
name|next_mb
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
block|}
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|mcur
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|lenthisone
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bus32bit
condition|)
block|{
name|insl
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|lenthisone
operator|/
literal|4
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
operator|(
name|lenthisone
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|lenthisone
operator|&
literal|3
condition|)
name|insb
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|lenthisone
operator|&
literal|3
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
operator|(
name|lenthisone
operator|&
literal|3
operator|)
expr_stmt|;
block|}
else|else
block|{
name|insw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|lenthisone
operator|/
literal|2
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|lenthisone
expr_stmt|;
if|if
condition|(
name|lenthisone
operator|&
literal|1
condition|)
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|)
expr_stmt|;
block|}
name|totlen
operator|-=
name|lenthisone
expr_stmt|;
block|}
if|if
condition|(
name|off
condition|)
block|{
name|top
operator|=
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|top
operator|==
literal|0
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
literal|0
condition|)
block|{
name|top
operator|=
name|m0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
comment|/* Convert one of our saved mbuf's */
name|sc
operator|->
name|next_mb
operator|=
operator|(
name|sc
operator|->
name|next_mb
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
name|top
operator|->
name|m_data
operator|=
name|top
operator|->
name|m_pktdat
expr_stmt|;
name|top
operator|->
name|m_flags
operator|=
name|M_PKTHDR
expr_stmt|;
block|}
name|insw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|top
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|top
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|top
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* XXX Accomodate for type and len from beginning of trailer */
name|top
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|save_totlen
operator|-
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
name|m0
expr_stmt|;
name|top
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|save_totlen
expr_stmt|;
block|}
name|top
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ipackets
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|bpf
argument_list|,
name|top
argument_list|)
expr_stmt|;
comment|/* 		 * Note that the interface cannot be in promiscuous mode if 		 * there are no BPF listeners.  And if we are in promiscuous 		 * mode, we have to check if this packet is really ours. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|m_adj
argument_list|(
name|top
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|,
name|top
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|out
label|:
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
ifndef|#
directive|ifndef
name|MACH_KERNEL
if|if
condition|(
name|top
condition|)
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpread Error ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
block|}
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|int
name|zpgetstat
parameter_list|(
name|dev
parameter_list|,
name|flavor
parameter_list|,
name|status
parameter_list|,
name|count
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flavor
decl_stmt|;
name|dev_status_t
name|status
decl_stmt|;
name|unsigned
name|int
modifier|*
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpgetstat ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
if|if
condition|(
name|unit
operator|<
literal|0
operator|||
name|unit
operator|>=
name|NZP
operator|||
name|zp_softc
index|[
name|unit
index|]
operator|.
name|attached
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|net_getstat
argument_list|(
operator|&
name|zp_softc
index|[
name|unit
index|]
operator|.
name|ds_if
argument_list|,
name|flavor
argument_list|,
name|status
argument_list|,
name|count
argument_list|)
operator|)
return|;
block|}
name|int
name|zpsetstat
parameter_list|(
name|dev
parameter_list|,
name|flavor
parameter_list|,
name|status
parameter_list|,
name|count
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flavor
decl_stmt|;
name|dev_status_t
name|status
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|int
name|unit
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|zp_softc_t
modifier|*
name|sc
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpsetstat ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
if|if
condition|(
name|unit
operator|<
literal|0
operator|||
name|unit
operator|>=
name|NZP
operator|||
name|zp_softc
index|[
name|unit
index|]
operator|.
name|attached
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|=
operator|&
name|zp_softc
index|[
name|unit
index|]
expr_stmt|;
switch|switch
condition|(
name|flavor
condition|)
block|{
case|case
name|NET_STATUS
case|:
block|{
specifier|register
name|struct
name|net_status
modifier|*
name|ns
init|=
operator|(
expr|struct
name|net_status
operator|*
operator|)
name|status
decl_stmt|;
if|if
condition|(
name|count
operator|<
name|NET_STATUS_COUNT
condition|)
block|{
return|return
operator|(
name|D_INVALID_SIZE
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|ds_if
operator|.
name|if_flags
operator|!=
name|ns
operator|->
name|flags
condition|)
block|{
name|sc
operator|->
name|ds_if
operator|.
name|if_flags
operator|=
name|ns
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ds_if
operator|.
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|zpinit
argument_list|(
name|sc
operator|->
name|ds_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
default|default:
return|return
operator|(
name|D_INVALID_OPERATION
operator|)
return|;
block|}
return|return
operator|(
name|D_SUCCESS
operator|)
return|;
block|}
else|#
directive|else
comment|/* MACH_KERNEL */
comment|/*  * Look familiar?  */
specifier|static
name|int
name|zpioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpioctl ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|zpinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
if|#
directive|if
literal|1
name|arp_ifinit
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zpinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|zpinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|zpstop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|zpmbufempty
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|zpinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|notdef
case|case
name|SIOCGHWADDR
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|void
name|zpreset
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpreset ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
name|zpstop
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|zpinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|void
name|zpwatchdog
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpwatchdog ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
ifdef|#
directive|ifdef
name|MACH_KERNEL
operator|++
name|sc
operator|->
name|ds_if
operator|.
name|if_oerrors
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"zp%d: watchdog\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
name|zpreset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
name|void
name|zpstop
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpstop ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_DISABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|STOP_TRANSCEIVER
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RD_0_MASK
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_INTR_MASK
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_FILTER
argument_list|)
expr_stmt|;
block|}
comment|/*  * This is adapted straight from the book. There's probably a better way.  */
specifier|static
name|int
name|send_ID_sequence
parameter_list|(
name|port
parameter_list|)
name|u_short
name|port
decl_stmt|;
block|{
name|char
name|cx
decl_stmt|,
name|al
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG2
name|printf
argument_list|(
literal|"### send_ID_sequence ####\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|cngetc
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
endif|#
directive|endif
comment|/* ZP_DEBUG */
name|cx
operator|=
literal|0x0ff
expr_stmt|;
name|al
operator|=
literal|0x0ff
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|loop1
label|:
name|cx
operator|--
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|al
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|al
operator|&
literal|0x80
operator|)
condition|)
block|{
name|al
operator|=
name|al
operator|<<
literal|1
expr_stmt|;
goto|goto
name|loop1
goto|;
block|}
name|al
operator|=
name|al
operator|<<
literal|1
expr_stmt|;
name|al
operator|^=
literal|0xcf
expr_stmt|;
if|if
condition|(
name|cx
condition|)
goto|goto
name|loop1
goto|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*  * We get eeprom data from the id_port given an offset into the  * eeprom.  Basically; after the ID_sequence is sent to all of  * the cards; they enter the ID_CMD state where they will accept  * command requests. 0x80-0xbf loads the eeprom data.  We then  * read the port 16 times and with every read; the cards check  * for contention (ie: if one card writes a 0 bit and another  * writes a 1 bit then the host sees a 0. At the end of the cycle;  * each card compares the data on the bus; if there is a difference  * then that card goes into ID_WAIT state again). In the meantime;  * one bit of data is returned in the AX register which is conveniently  * returned to us by inb().  Hence; we read 16 times getting one  * bit of data with each read.  */
specifier|static
name|u_short
name|get_eeprom_data
parameter_list|(
name|id_port
parameter_list|,
name|offset
parameter_list|)
name|int
name|id_port
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|data
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG2
name|printf
argument_list|(
literal|"### get_eeprom_data ####\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|cngetc
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
endif|#
directive|endif
comment|/* ZP_DEBUG */
name|outb
argument_list|(
name|id_port
argument_list|,
literal|0x80
operator|+
name|offset
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|data
operator|=
operator|(
name|data
operator|<<
literal|1
operator|)
operator||
operator|(
name|inw
argument_list|(
name|id_port
argument_list|)
operator|&
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
specifier|static
name|u_short
name|read_eeprom_data
parameter_list|(
name|id_port
parameter_list|,
name|offset
parameter_list|)
name|int
name|id_port
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|data
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### read_eeprom_data ####\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|cngetc
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
endif|#
directive|endif
comment|/* ZP_DEBUG */
name|outb
argument_list|(
name|id_port
operator|+
literal|10
argument_list|,
literal|0x80
operator|+
name|offset
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
name|inw
argument_list|(
name|id_port
operator|+
literal|12
argument_list|)
return|;
block|}
specifier|static
name|int
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|f_is_eeprom_busy
parameter_list|(
name|dev
parameter_list|)
name|struct
name|bus_device
modifier|*
name|dev
decl_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
function|f_is_eeprom_busy
parameter_list|(
name|is
parameter_list|)
name|struct
name|isa_device
modifier|*
name|is
decl_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
specifier|register
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|dev
operator|->
name|unit
index|]
decl_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
specifier|register
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|is
operator|->
name|id_unit
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### f_is_eeprom_busy ####\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BASE: %x\n"
argument_list|,
name|BASE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|cngetc
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
endif|#
directive|endif
comment|/* ZP_DEBUG */
while|while
condition|(
name|i
operator|++
operator|<
literal|100
condition|)
block|{
name|j
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W0_EEPROM_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|EEPROM_BUSY
condition|)
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|i
operator|>=
literal|100
condition|)
block|{
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|printf
argument_list|(
literal|"\nzp%d: eeprom failed to come ready.\n"
argument_list|,
name|dev
operator|->
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|printf
argument_list|(
literal|"\nzp%d: eeprom failed to come ready.\n"
argument_list|,
name|is
operator|->
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|j
operator|&
name|EEPROM_TST_MODE
condition|)
block|{
ifdef|#
directive|ifdef
name|MACH_KERNEL
name|printf
argument_list|(
literal|"\nzp%d: 3c589 in test mode. Erase pencil mark!\n"
argument_list|,
name|dev
operator|->
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MACH_KERNEL */
name|printf
argument_list|(
literal|"\nzp%d: 3c589 in test mode. Erase pencil mark!\n"
argument_list|,
name|is
operator|->
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MACH_KERNEL */
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|MACH_KERNEL
name|void
name|zpmbuffill
parameter_list|(
name|sp
parameter_list|)
name|void
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|zp_softc
operator|*
operator|)
name|sp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpmbuffill ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|i
operator|=
name|sc
operator|->
name|last_mb
expr_stmt|;
do|do
block|{
if|if
condition|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|MGET
argument_list|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|sc
operator|->
name|next_mb
condition|)
do|;
name|sc
operator|->
name|last_mb
operator|=
name|i
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|zpmbufempty
parameter_list|(
name|sc
parameter_list|)
name|struct
name|zp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ZP_DEBUG
name|printf
argument_list|(
literal|"### zpmbufempty ####\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZP_DEBUG */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MBS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|last_mb
operator|=
name|sc
operator|->
name|next_mb
operator|=
literal|0
expr_stmt|;
name|untimeout
argument_list|(
name|zpmbuffill
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MACH_KERNEL */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NZP> 0 */
end_comment

end_unit

