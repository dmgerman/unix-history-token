begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This code is based on  *  (1) FreeBSD implementation on ISA/EISA Ethelink III by Herb Peyerl  *  (2) Linux implementation on PCMCIA Etherlink III by David Hinds  *  (3) FreeBSD implementation on PCMCIA IBM Ethernet Card I/II  *      by David Greenman  *  (4) RT-Mach implementation on PCMCIA/ISA/EISA Etherlink III  *      by Seiji Murata  *  *  Copyright (c) by HOSOKAWA, Tatsumi<hosokawa@mt.cs.keio.ac.jp>  *  Copyright (c) by Seiji Murata<seiji@mt.cs.keio.ac.jp>  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1993 Herb Peyerl<hpeyerl@novatel.ca>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	From: if_ep.c,v 1.9 1994/01/25 10:46:29 deraadt Exp $  *	$Id: if_zp.c,v 1.51 1999/04/19 06:56:24 imp Exp $  */
end_comment

begin_comment
comment|/*-  * TODO:  * [1] integrate into current if_ed.c  * [2] parse tuples to find out where to map the shared memory buffer,  *     and what to write into the configuration register  * [3] move pcic-specific code into a separate module.  *  * Device driver for IBM PCMCIA Credit Card Adapter for Ethernet,  * if_ze.c  *  * Based on the Device driver for National Semiconductor DS8390 ethernet  * adapters by David Greenman.  Modifications for PCMCIA by Keith Moore.  * Adapted for FreeBSD 1.1.5 by Jordan Hubbard.  *  * Currently supports only the IBM Credit Card Adapter for Ethernet, but  * could probably work with other PCMCIA cards also, if it were modified  * to get the locations of the PCMCIA configuration option register (COR)  * by parsing the configuration tuples, rather than by hard-coding in  * the value expected by IBM's card.  *  * Sources for data on the PCMCIA/IBM CCAE specific portions of the driver:  *  * [1] _Local Area Network Credit Card Adapters Technical Reference_,  *     IBM Corp., SC30-3585-00, part # 33G9243.  * [2] "pre-alpha" PCMCIA support code for Linux by Barry Jaspan.  * [3] Intel 82536SL PC Card Interface Controller Data Sheet, Intel  *     Order Number 290423-002  * [4] National Semiconductor DP83902A ST-NIC (tm) Serial Network  *     Interface Controller for Twisted Pair data sheet.  *  *  * Copyright (C) 1993, David Greenman. This software may be used, modified,  *   copied, distributed, and sold, in both source and binary form provided  *   that the above copyright and these terms are retained. Under no  *   circumstances is the author responsible for the proper functioning  *   of this software, nor does the author assume any responsibility  *   for damages incurred with its use.  */
end_comment

begin_comment
comment|/*======================================================================      A PCMCIA ethernet driver for the 3com 3c589 card.      Written by David Hinds, dhinds@allegro.stanford.edu      The network driver code is based on Donald Becker's 3c589 code:      Written 1994 by Donald Becker.     Copyright 1993 United States Government as represented by the     Director, National Security Agency.  This software may be used and     distributed according to the terms of the GNU Public License,     incorporated herein by reference.     Donald Becker may be reached at becker@cesdis1.gsfc.nasa.gov  ======================================================================*/
end_comment

begin_comment
comment|/*  * I doubled delay loops in this file because it is not enough for some  * laptop machines' PCIC (especially, on my Chaplet ILFA 350 ^^;).  *                        HOSOKAWA, Tatsumi<hosokawa@mt.cs.keio.ac.jp>  */
end_comment

begin_comment
comment|/*  * Very small patch for IBM Ethernet PCMCIA Card II and IBM ThinkPad230Cs.  *			ETO, Toshihisa<eto@osl.fujitsu.co.jp>  */
end_comment

begin_comment
comment|/* XXX don't mix different PCCARD support code. */
end_comment

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_include
include|#
directive|include
file|"pcic.h"
end_include

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
operator|||
name|NPCIC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"opt_lint.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILING_LINT
end_ifdef

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zpdummy
index|[]
init|=
literal|"code to use the includes of card.h and pcic.h"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Dedicated PCMCIA drivers and generic PCMCIA support can't be mixed"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"zp.h"
end_include

begin_include
include|#
directive|include
file|"bpf.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipx.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPX
end_ifdef

begin_include
include|#
directive|include
file|<netipx/ipx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPF
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_zpreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/pcic.h>
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

begin_comment
comment|/*****************************************************************************  *                       Driver for Ethernet Adapter                         *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * zp_softc: per line info and status  */
end_comment

begin_struct
specifier|static
struct|struct
name|zp_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common part		 */
define|#
directive|define
name|MAX_MBS
value|8
comment|/* # of mbufs we keep around	 */
name|struct
name|mbuf
modifier|*
name|mb
index|[
name|MAX_MBS
index|]
decl_stmt|;
comment|/* spare mbuf storage.		 */
name|int
name|next_mb
decl_stmt|;
comment|/* Which mbuf to use next. 	 */
name|int
name|last_mb
decl_stmt|;
comment|/* Last mbuf.			 */
name|int
name|ep_io_addr
decl_stmt|;
comment|/* i/o bus address		 */
name|char
name|ep_connectors
decl_stmt|;
comment|/* Connectors on this card.	 */
name|int
name|tx_start_thresh
decl_stmt|;
comment|/* Current TX_start_thresh.	 */
name|char
name|bus32bit
decl_stmt|;
comment|/* 32bit access possible	 */
name|u_short
name|if_port
decl_stmt|;
name|u_char
name|last_alive
decl_stmt|;
comment|/* information for reconfiguration */
name|u_char
name|last_up
decl_stmt|;
comment|/* information for reconfiguration */
name|int
name|slot
decl_stmt|;
comment|/* PCMCIA slot */
name|struct
name|callout_handle
name|ch
decl_stmt|;
comment|/* Callout handle for timeouts  */
name|int
name|buffill_pending
decl_stmt|;
if|#
directive|if
name|NAPM
operator|>
literal|0
name|struct
name|apmhook
name|s_hook
decl_stmt|;
comment|/* reconfiguration support */
name|struct
name|apmhook
name|r_hook
decl_stmt|;
comment|/* reconfiguration support */
endif|#
directive|endif
comment|/* NAPM> 0 */
block|}
name|zp_softc
index|[
name|NZP
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|zpprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zpattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zp_suspend
name|__P
argument_list|(
operator|(
name|void
operator|*
name|visa_dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zp_resume
name|__P
argument_list|(
operator|(
name|void
operator|*
name|visa_dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|zpioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|u_long
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|read_eeprom_data
name|__P
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zpinit
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ointhand2_t
name|zpintr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zpmbuffill
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zpmbufempty
name|__P
argument_list|(
operator|(
expr|struct
name|zp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zpread
name|__P
argument_list|(
operator|(
expr|struct
name|zp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zpreset
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zpstart
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zpstop
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|zpwatchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|zpdriver
init|=
block|{
name|zpprobe
block|,
name|zpattach
block|,
literal|"zp"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CARD_INFO
value|"3Com Corporation~3C589"
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|card_info
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * scan the card information structure looking for the version/product info  * tuple.  when we find it, compare it to the string we are looking for.  * return 1 if we find it, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|zp_check_cis
parameter_list|(
name|unsigned
name|char
modifier|*
name|scratch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|card_info
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|scratch
index|[
name|i
index|]
operator|!=
literal|0xff
operator|&&
name|i
operator|<
literal|1024
condition|)
block|{
name|unsigned
name|char
name|link
init|=
name|scratch
index|[
name|i
operator|+
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|scratch
index|[
name|i
index|]
operator|==
literal|0x15
condition|)
block|{
comment|/* level 1 version/product info copy to card_info, 			 * translating '\0' to '~' */
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|8
init|;
name|scratch
index|[
name|j
index|]
operator|!=
literal|0xff
condition|;
name|j
operator|+=
literal|2
control|)
name|card_info
index|[
name|k
operator|++
index|]
operator|=
name|scratch
index|[
name|j
index|]
operator|==
literal|'\0'
condition|?
literal|'~'
else|:
name|scratch
index|[
name|j
index|]
expr_stmt|;
name|card_info
index|[
name|k
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|bcmp
argument_list|(
name|card_info
argument_list|,
name|CARD_INFO
argument_list|,
sizeof|sizeof
argument_list|(
name|CARD_INFO
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
name|i
operator|+=
literal|4
operator|+
literal|2
operator|*
name|link
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Probe each slot looking for an IBM Credit Card Adapter for Ethernet  * For each card that we find, map its card information structure  * into system memory at 'scratch' and see whether it's one of ours.  * Return the slot number if we find a card, or -1 otherwise.  *  * Side effects:  * + On success, leaves CIS mapped into memory at 'scratch';  *   caller must free it.  * + On success, leaves ethernet address in enet_addr.  * + Leaves product/vendor id of last card probed in 'card_info'  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_slot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zp_find_adapter
parameter_list|(
name|unsigned
name|char
modifier|*
name|scratch
parameter_list|,
name|int
name|reconfig
parameter_list|)
block|{
name|int
name|slot
decl_stmt|;
for|for
control|(
name|slot
operator|=
name|prev_slot
init|;
name|slot
operator|<
name|MAXSLOT
condition|;
operator|++
name|slot
control|)
block|{
comment|/* see if there's a PCMCIA controller here Intel PCMCIA 		 * controllers use 0x82 and 0x83 IBM clone chips use 0x88 and 		 * 0x89, apparently */
comment|/* IBM ThinkPad230Cs use 0x84. */
name|unsigned
name|char
name|idbyte
init|=
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_ID_REV
argument_list|)
decl_stmt|;
if|if
condition|(
name|idbyte
operator|!=
literal|0x82
operator|&&
name|idbyte
operator|!=
literal|0x83
operator|&&
name|idbyte
operator|!=
literal|0x84
operator|&&
comment|/* for IBM ThinkPad 230Cs */
name|idbyte
operator|!=
literal|0x88
operator|&&
name|idbyte
operator|!=
literal|0x89
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_STATUS
argument_list|)
operator|&
name|PCIC_CD
operator|)
operator|!=
name|PCIC_CD
condition|)
block|{
if|if
condition|(
operator|!
name|reconfig
condition|)
block|{
name|printf
argument_list|(
literal|"zp: slot %d: no card in slot\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"zp: slot %d: no card in slot\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
comment|/* no card in slot */
continue|continue;
block|}
name|pcic_power_on
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|pcic_reset
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
comment|/* map the card's attribute memory and examine its card 		 * information structure tuples for something we recognize. */
name|pcic_map_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|kvtop
argument_list|(
name|scratch
argument_list|)
argument_list|,
literal|0L
argument_list|,
literal|0xFFFL
argument_list|,
name|ATTRIBUTE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zp_check_cis
argument_list|(
name|scratch
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* found it */
if|if
condition|(
operator|!
name|reconfig
condition|)
block|{
name|printf
argument_list|(
literal|"zp: found card in slot %d\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"zp: found card in slot %d\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
name|prev_slot
operator|=
operator|(
name|prev_slot
operator|==
name|MAXSLOT
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|prev_slot
operator|+
literal|1
expr_stmt|;
return|return
name|slot
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|reconfig
condition|)
block|{
name|printf
argument_list|(
literal|"zp: pcmcia slot %d: %s\n"
argument_list|,
name|slot
argument_list|,
name|card_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"zp: pcmcia slot %d: %s\n"
argument_list|,
name|slot
argument_list|,
name|card_info
argument_list|)
expr_stmt|;
block|}
block|}
name|pcic_unmap_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|prev_slot
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * macros to handle casting unsigned long to (char *) so we can  * read/write into physical memory space.  */
end_comment

begin_define
define|#
directive|define
name|PEEK
parameter_list|(
name|addr
parameter_list|)
value|(*((unsigned char *)(addr)))
end_define

begin_define
define|#
directive|define
name|POKE
parameter_list|(
name|addr
parameter_list|,
name|val
parameter_list|)
value|do { PEEK(addr) = (val); } while (0)
end_define

begin_comment
comment|/*  * Determine if the device is present  *  *   on entry:  * 	a pointer to an isa_device struct  *   on exit:  *	NULL if device not found  *	or # of i/o addresses used (if found)  */
end_comment

begin_function
specifier|static
name|int
name|zpprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|isa_dev
parameter_list|)
block|{
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|slot
decl_stmt|;
name|u_short
name|k
decl_stmt|;
name|int
name|re_init_flag
decl_stmt|;
if|if
condition|(
operator|(
name|slot
operator|=
name|zp_find_adapter
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|,
name|isa_dev
operator|->
name|id_reconfig
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* okay, we found a card, so set it up */
comment|/* Inhibit 16 bit memory delay. POINTETH.SYS apparently does this, for 	 * what reason I don't know. */
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_CDGC
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_CDGC
argument_list|)
operator||
name|PCIC_16_DL_INH
argument_list|)
expr_stmt|;
comment|/* things to map (1) card's EEPROM is already mapped by the 	 * find_adapter routine but we still need to get the card's ethernet 	 * address. after that we unmap that part of attribute memory. (2) 	 * card configuration registers need to be mapped in so we can set the 	 * configuration and socket # registers. (3) shared memory packet 	 * buffer (4) i/o ports (5) IRQ */
ifdef|#
directive|ifdef
name|notdef
comment|/* Sigh.  Location of the ethernet address isn't documented in [1]. It 	 * was derived by doing a hex dump of all of attribute memory and 	 * looking for the IBM vendor prefix. */
name|enet_addr
index|[
literal|0
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff0
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|1
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff2
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|2
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff4
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|3
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff6
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|4
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff8
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|5
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xffa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|re_init_flag
operator|=
literal|0
expr_stmt|;
name|re_init
label|:
comment|/* (2) map card configuration registers.  these are offset in card 	 * memory space by 0x20000.  normally we could get this offset from 	 * the card information structure, but I'm too lazy and am not quite 	 * sure if I understand the CIS anyway. 	 *  	 * XXX IF YOU'RE TRYING TO PORT THIS DRIVER FOR A DIFFERENT PCMCIA CARD, 	 * the most likely thing to change is the constant 0x20000 in the next 	 * statement.  Oh yes, also change the card id string that we probe 	 * for. */
name|pcic_map_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|kvtop
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|)
argument_list|,
literal|0x10000
argument_list|,
literal|8L
argument_list|,
name|ATTRIBUTE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|OLD_3C589B_CARDS
name|POKE
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* reset the card (how long?) */
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Set the configuration index.  According to [1], the adapter won't 	 * respond to any i/o signals until we do this; it uses the Memory 	 * Only interface (whatever that is; it's not documented). Also turn 	 * on "level" (not pulse) interrupts. 	 *  	 * XXX probably should init the socket and copy register also, so that we 	 * can deal with multiple instances of the same card. */
name|POKE
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
name|pcic_unmap_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* (4) map i/o ports. 	 *  	 * XXX is it possible that the config file leaves this unspecified, in 	 * which case we have to pick one? 	 *  	 * At least one PCMCIA device driver I'v seen maps a block of 32 	 * consecutive i/o ports as two windows of 16 ports each. Maybe some 	 * other pcic chips are restricted to 16-port windows; the 82365SL 	 * doesn't seem to have that problem.  But since we have an extra 	 * window anyway... */
name|pcic_map_io
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|isa_dev
operator|->
name|id_iobase
argument_list|,
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* (5) configure the card for the desired interrupt 	 *  	 * XXX is it possible that the config file leaves this unspecified? */
name|pcic_map_irq
argument_list|(
name|slot
argument_list|,
name|ffs
argument_list|(
name|isa_dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* tell the PCIC that this is an I/O card (not memory) */
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_INT_GEN
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_INT_GEN
argument_list|)
operator||
name|PCIC_CARDTYPE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ep_io_addr
operator|=
name|isa_dev
operator|->
name|id_iobase
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|k
operator|=
name|read_eeprom_data
argument_list|(
name|BASE
argument_list|,
name|EEPROM_ADDR_CFG
argument_list|)
expr_stmt|;
comment|/* get addr cfg */
name|sc
operator|->
name|if_port
operator|=
name|k
operator|>>
literal|14
expr_stmt|;
name|k
operator|=
operator|(
name|k
operator|&
literal|0x1f
operator|)
operator|*
literal|0x10
operator|+
literal|0x200
expr_stmt|;
comment|/* decode base addr. */
if|if
condition|(
name|k
operator|!=
operator|(
name|u_short
operator|)
name|isa_dev
operator|->
name|id_iobase
condition|)
block|{
if|if
condition|(
operator|!
name|re_init_flag
condition|)
block|{
name|re_init_flag
operator|++
expr_stmt|;
goto|goto
name|re_init
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|k
operator|=
name|read_eeprom_data
argument_list|(
name|BASE
argument_list|,
name|EEPROM_RESOURCE_CFG
argument_list|)
expr_stmt|;
name|k
operator|>>=
literal|12
expr_stmt|;
if|if
condition|(
name|isa_dev
operator|->
name|id_irq
operator|!=
operator|(
literal|1
operator|<<
operator|(
operator|(
name|k
operator|==
literal|2
operator|)
condition|?
literal|9
else|:
name|k
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|outb
argument_list|(
name|BASE
argument_list|,
name|ACTIVATE_ADAPTER_TO_CONFIG
argument_list|)
expr_stmt|;
comment|/* information for reconfiguration */
name|sc
operator|->
name|last_alive
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|last_up
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
return|return
operator|(
literal|0x10
operator|)
return|;
comment|/* 16 bytes of I/O space used. */
block|}
end_function

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_function
specifier|static
name|int
name|zp_suspend
parameter_list|(
name|visa_dev
parameter_list|)
name|void
modifier|*
name|visa_dev
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|struct isa_device *isa_dev = visa_dev; 	struct zp_softc *sc =&zp_softc[isa_dev->id_unit];  	pcic_power_off(sc->slot);
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zp_resume
parameter_list|(
name|visa_dev
parameter_list|)
name|void
modifier|*
name|visa_dev
decl_stmt|;
block|{
name|struct
name|isa_device
modifier|*
name|isa_dev
init|=
name|visa_dev
decl_stmt|;
name|prev_slot
operator|=
literal|0
expr_stmt|;
name|reconfig_isadev
argument_list|(
name|isa_dev
argument_list|,
operator|&
name|net_imask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

begin_comment
comment|/*  * Install interface into kernel networking data structures  */
end_comment

begin_function
specifier|static
name|int
name|zpattach
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|u_short
name|i
decl_stmt|;
name|int
name|pl
decl_stmt|;
name|isa_dev
operator|->
name|id_ointr
operator|=
name|zpintr
expr_stmt|;
comment|/* PCMCIA card can be offlined. Reconfiguration is required */
if|if
condition|(
name|isa_dev
operator|->
name|id_reconfig
condition|)
block|{
if|if
condition|(
operator|!
name|isa_dev
operator|->
name|id_alive
operator|&&
name|sc
operator|->
name|last_alive
condition|)
block|{
name|pl
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|last_up
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
expr_stmt|;
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
name|sc
operator|->
name|last_alive
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|isa_dev
operator|->
name|id_alive
operator|&&
operator|!
name|sc
operator|->
name|last_alive
condition|)
block|{
name|zpreset
argument_list|(
name|isa_dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|last_up
condition|)
block|{
name|pl
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|if_up
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|last_alive
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
else|else
block|{
name|sc
operator|->
name|last_alive
operator|=
literal|1
expr_stmt|;
block|}
name|sc
operator|->
name|ep_io_addr
operator|=
name|isa_dev
operator|->
name|id_iobase
expr_stmt|;
name|printf
argument_list|(
literal|"zp%d: "
argument_list|,
name|isa_dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|buffill_pending
operator|=
literal|0
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ep_connectors
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|inw
argument_list|(
name|isa_dev
operator|->
name|id_iobase
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|IS_AUI
condition|)
block|{
name|printf
argument_list|(
literal|"aui"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ep_connectors
operator||=
name|AUI
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
name|IS_BNC
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ep_connectors
condition|)
name|printf
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bnc"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ep_connectors
operator||=
name|BNC
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
name|IS_UTP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|ep_connectors
condition|)
name|printf
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"utp"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ep_connectors
operator||=
name|UTP
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sc
operator|->
name|ep_connectors
condition|)
name|printf
argument_list|(
literal|"no connectors!"
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|{
name|short
name|tmp_addr
index|[
literal|3
index|]
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
block|{
name|tmp_addr
index|[
name|j
index|]
operator|=
name|htons
argument_list|(
name|read_eeprom_data
argument_list|(
name|BASE
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|tmp_addr
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" address %6D\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|isa_dev
operator|->
name|id_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"zp"
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|zpstart
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|zpioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|zpwatchdog
expr_stmt|;
comment|/* Select connector according to board setting. */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_LINK0
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPF
operator|>
literal|0
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|NAPM
operator|>
literal|0
name|sc
operator|->
name|s_hook
operator|.
name|ah_fun
operator|=
name|zp_suspend
expr_stmt|;
name|sc
operator|->
name|s_hook
operator|.
name|ah_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|isa_dev
expr_stmt|;
name|sc
operator|->
name|s_hook
operator|.
name|ah_name
operator|=
literal|"3Com PCMCIA Etherlink III 3C589"
expr_stmt|;
name|sc
operator|->
name|s_hook
operator|.
name|ah_order
operator|=
name|APM_MID_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_SUSPEND
argument_list|,
operator|&
name|sc
operator|->
name|s_hook
argument_list|)
expr_stmt|;
name|sc
operator|->
name|r_hook
operator|.
name|ah_fun
operator|=
name|zp_resume
expr_stmt|;
name|sc
operator|->
name|r_hook
operator|.
name|ah_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|isa_dev
expr_stmt|;
name|sc
operator|->
name|r_hook
operator|.
name|ah_name
operator|=
literal|"3Com PCMCIA Etherlink III 3C589"
expr_stmt|;
name|sc
operator|->
name|r_hook
operator|.
name|ah_order
operator|=
name|APM_MID_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_RESUME
argument_list|,
operator|&
name|sc
operator|->
name|r_hook
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAPM> 0 */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * The order in here seems important. Otherwise we may not receive  * interrupts. ?!  */
end_comment

begin_function
specifier|static
name|void
name|zpinit
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_addrhead
argument_list|)
condition|)
comment|/* XXX unlikely */
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable the card */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable the card */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
name|ENABLE_DRQ_IRQ
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Reload the ether_addr. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W2_ADDR_0
operator|+
name|i
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
comment|/* Window 1 is operating window */
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|)
expr_stmt|;
comment|/* get rid of stray intr's */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|ACK_INTR
operator||
literal|0xff
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RD_0_MASK
operator||
name|S_CARD_FAILURE
operator||
name|S_RX_COMPLETE
operator||
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_INTR_MASK
operator||
name|S_CARD_FAILURE
operator||
name|S_RX_COMPLETE
operator||
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IFF_MULTICAST
define|#
directive|define
name|IFF_MULTICAST
value|0x10000
endif|#
directive|endif
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_FILTER
operator||
name|FIL_INDIVIDUAL
operator||
operator|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
condition|?
name|FIL_GROUP
else|:
literal|0
operator|)
operator||
name|FIL_BRDCST
operator||
operator|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|?
name|FIL_ALL
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* you can `ifconfig (link0|-link0) ep0' to get the following 	 * behaviour: -link0	disable AUI/UTP. enable BNC. link0 disable 	 * BNC. enable AUI. if the card has a UTP connector, that is enabled 	 * too. not sure, but it seems you have to be careful to not plug 	 * things into both AUI& UTP. */
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|ep_connectors
operator|&
name|BNC
operator|)
condition|)
block|{
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* set the xcvr */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_ADDRESS_CFG
argument_list|,
literal|3
operator|<<
literal|14
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|START_TRANSCEIVER
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|ep_connectors
operator|&
name|UTP
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
operator|)
operator|&&
operator|(
name|sc
operator|->
name|ep_connectors
operator|&
name|UTP
operator|)
condition|)
block|{
endif|#
directive|endif
name|GO_WINDOW
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W4_MEDIA_TYPE
argument_list|,
name|ENABLE_UTP
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_ENABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* just in case */
name|sc
operator|->
name|tx_start_thresh
operator|=
literal|20
expr_stmt|;
comment|/* probably a good starting point. */
comment|/* Store up a bunch of mbuf's for use later. (MAX_MBS). First we free 	 * up any that we had in case we're being called from intr or 	 * somewhere else. */
name|sc
operator|->
name|last_mb
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|next_mb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|buffill_pending
operator|!=
literal|0
condition|)
block|{
name|untimeout
argument_list|(
name|zpmbuffill
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|buffill_pending
operator|=
literal|0
expr_stmt|;
block|}
name|zpmbuffill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|zpstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|const
name|char
name|padmap
index|[]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
specifier|static
name|void
name|zpstart
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|struct
name|zp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|top
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|pad
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|startagain
label|:
comment|/* Sneak a peek at the next packet */
name|m
operator|=
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
operator|.
name|ifq_head
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|top
operator|=
name|m
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|pad
operator|=
name|padmap
index|[
name|len
operator|&
literal|3
index|]
expr_stmt|;
comment|/* The 3c509 automatically pads short packets to minimum ethernet 	 * length, but we drop packets that are too large. Perhaps we should 	 * truncate them instead? */
if|if
condition|(
name|len
operator|+
name|pad
operator|>
name|ETHER_MAX_LEN
condition|)
block|{
comment|/* packet is obviously too large: toss it */
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|readcheck
goto|;
block|}
if|if
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_FREE_TX
argument_list|)
operator|<
name|len
operator|+
name|pad
operator|+
literal|4
condition|)
block|{
comment|/* no room in FIFO */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_TX_AVAIL_THRESH
operator||
operator|(
name|len
operator|+
name|pad
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
comment|/* not really needed */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_TX_START_THRESH
operator||
operator|(
name|len
operator|/
literal|4
operator|+
name|sc
operator|->
name|tx_start_thresh
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* Second dword meaningless */
for|for
control|(
name|top
operator|=
name|m
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|bus32bit
condition|)
block|{
name|outsl
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|&
literal|3
condition|)
name|outsb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
operator|(
name|m
operator|->
name|m_len
operator|&
operator|(
operator|~
literal|3
operator|)
operator|)
argument_list|,
name|m
operator|->
name|m_len
operator|&
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outsw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|&
literal|1
condition|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|pad
operator|--
condition|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Padding */
if|#
directive|if
name|NBPF
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|top
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
expr_stmt|;
comment|/* Is another packet coming in? We don't want to overflow the tiny RX 	 * fifo. */
name|readcheck
label|:
if|if
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_STATUS
argument_list|)
operator|&
name|RX_BYTES_MASK
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|startagain
goto|;
block|}
specifier|static
name|void
name|zpintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|status
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
name|checkintr
label|:
name|status
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
operator|(
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
operator||
name|S_RX_COMPLETE
operator||
name|S_CARD_FAILURE
operator|)
expr_stmt|;
name|checkintr2
label|:
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* No interrupts. */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
name|status
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
operator|(
name|S_TX_COMPLETE
operator||
name|S_TX_AVAIL
operator||
name|S_RX_COMPLETE
operator||
name|S_CARD_FAILURE
operator|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
goto|goto
name|checkintr2
goto|;
return|return;
block|}
comment|/* important that we do this first. */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|ACK_INTR
operator||
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|S_TX_AVAIL
condition|)
block|{
name|status
operator|&=
operator|~
name|S_TX_AVAIL
expr_stmt|;
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_FREE_TX
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|zpstart
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|S_RX_COMPLETE
condition|)
block|{
name|status
operator|&=
operator|~
name|S_RX_COMPLETE
expr_stmt|;
name|zpread
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|S_CARD_FAILURE
condition|)
block|{
name|printf
argument_list|(
literal|"zp%d: reset (status: %x)\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
name|zpinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|status
operator|&
name|S_TX_COMPLETE
condition|)
block|{
name|status
operator|&=
operator|~
name|S_TX_COMPLETE
expr_stmt|;
comment|/* We need to read TX_STATUS until we get a 0 status in order 		 * to turn off the interrupt flag. */
while|while
condition|(
operator|(
name|i
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|)
operator|)
operator|&
name|TXS_COMPLETE
condition|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|TXS_MAX_COLLISION
operator||
name|TXS_JABBER
operator||
name|TXS_UNDERRUN
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|&
name|TXS_MAX_COLLISION
condition|)
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|TXS_JABBER
operator||
name|TXS_UNDERRUN
operator|)
condition|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
name|TXS_UNDERRUN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|tx_start_thresh
operator|<
name|ETHER_MAX_LEN
condition|)
block|{
name|sc
operator|->
name|tx_start_thresh
operator|+=
literal|20
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_TX_START_THRESH
operator||
name|sc
operator|->
name|tx_start_thresh
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
expr_stmt|;
block|}
block|}
name|zpstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|checkintr
goto|;
block|}
specifier|static
name|void
name|zpread
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|zp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mcur
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|top
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|lenthisone
decl_stmt|;
name|int
name|save_totlen
decl_stmt|;
name|int
name|off
decl_stmt|;
name|totlen
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_STATUS
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|totlen
operator|&
name|ERR_RX
condition|)
block|{
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|save_totlen
operator|=
name|totlen
operator|&=
name|RX_BYTES_MASK
expr_stmt|;
comment|/* Lower 11 bits = RX bytes. */
name|m
operator|=
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* Convert one of our saved mbuf's */
name|sc
operator|->
name|next_mb
operator|=
operator|(
name|sc
operator|->
name|next_mb
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_pktdat
expr_stmt|;
name|m
operator|->
name|m_flags
operator|=
name|M_PKTHDR
expr_stmt|;
block|}
name|top
operator|=
name|m0
operator|=
name|m
expr_stmt|;
comment|/* We assign top so we can "goto out" */
define|#
directive|define
name|EROUND
value|((sizeof(struct ether_header) + 3)& ~3)
define|#
directive|define
name|EOFF
value|(EROUND - sizeof(struct ether_header))
name|m0
operator|->
name|m_data
operator|+=
name|EOFF
expr_stmt|;
comment|/* Read what should be the header. */
name|insw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|totlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* mostly deal with trailer here.  (untested) We do this in a couple 	 * of parts.  First we check for a trailer, if we have one we convert 	 * the mbuf back to a regular mbuf and set the offset and subtract 	 * sizeof(struct ether_header) from the pktlen. After we've read the 	 * packet off the interface (all except for the trailer header, we 	 * then get a header mbuf, read the trailer into it, and fix up the 	 * mbuf pointer chain. */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
name|lenthisone
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lenthisone
operator|==
literal|0
condition|)
block|{
comment|/* no room in this one */
name|mcur
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|buffill_pending
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|ch
operator|=
name|timeout
argument_list|(
name|zpmbuffill
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|buffill_pending
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|next_mb
operator|=
operator|(
name|sc
operator|->
name|next_mb
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
block|}
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|mcur
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|lenthisone
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|bus32bit
condition|)
block|{
name|insl
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|lenthisone
operator|/
literal|4
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
operator|(
name|lenthisone
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|lenthisone
operator|&
literal|3
condition|)
name|insb
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|lenthisone
operator|&
literal|3
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
operator|(
name|lenthisone
operator|&
literal|3
operator|)
expr_stmt|;
block|}
else|else
block|{
name|insw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|lenthisone
operator|/
literal|2
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|lenthisone
expr_stmt|;
if|if
condition|(
name|lenthisone
operator|&
literal|1
condition|)
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|)
expr_stmt|;
block|}
name|totlen
operator|-=
name|lenthisone
expr_stmt|;
block|}
if|if
condition|(
name|off
condition|)
block|{
name|top
operator|=
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|sc
operator|->
name|next_mb
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|top
operator|==
literal|0
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
literal|0
condition|)
block|{
name|top
operator|=
name|m0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
comment|/* Convert one of our saved mbuf's */
name|sc
operator|->
name|next_mb
operator|=
operator|(
name|sc
operator|->
name|next_mb
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
name|top
operator|->
name|m_data
operator|=
name|top
operator|->
name|m_pktdat
expr_stmt|;
name|top
operator|->
name|m_flags
operator|=
name|M_PKTHDR
expr_stmt|;
block|}
name|insw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|mtod
argument_list|(
name|top
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|top
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|top
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* XXX Accomodate for type and len from beginning of trailer */
name|top
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|save_totlen
operator|-
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
name|m0
expr_stmt|;
name|top
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|save_totlen
expr_stmt|;
block|}
name|top
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ipackets
expr_stmt|;
if|#
directive|if
name|NBPF
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|top
argument_list|)
expr_stmt|;
comment|/* Note that the interface cannot be in promiscuous mode if 		 * there are no BPF listeners.  And if we are in promiscuous 		 * mode, we have to check if this packet is really ours. */
if|if
condition|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|m_adj
argument_list|(
name|top
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|,
name|top
argument_list|)
expr_stmt|;
return|return;
name|out
label|:
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
if|if
condition|(
name|top
condition|)
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
comment|/*  * Look familiar?  */
specifier|static
name|int
name|zpioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|zp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|zpinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
name|arp_ifinit
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPX
case|case
name|AF_IPX
case|:
block|{
specifier|register
name|struct
name|ipx_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SIPX
argument_list|(
name|ifa
argument_list|)
operator|->
name|sipx_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ipx_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ipx_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zpinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zpinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|zpinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|zpstop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|zpmbufempty
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|zpinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
specifier|static
name|void
name|zpreset
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|zpstop
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|zpinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|zpwatchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"zp%d: watchdog\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|zpreset
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|zpstop
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|&
name|zp_softc
index|[
name|unit
index|]
decl_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_DISABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|STOP_TRANSCEIVER
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RD_0_MASK
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_INTR_MASK
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_FILTER
argument_list|)
expr_stmt|;
block|}
specifier|static
name|u_short
name|read_eeprom_data
parameter_list|(
name|id_port
parameter_list|,
name|offset
parameter_list|)
name|int
name|id_port
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|outb
argument_list|(
name|id_port
operator|+
literal|10
argument_list|,
literal|0x80
operator|+
name|offset
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
name|inw
argument_list|(
name|id_port
operator|+
literal|12
argument_list|)
return|;
block|}
specifier|static
name|void
name|zpmbuffill
parameter_list|(
name|sp
parameter_list|)
name|void
modifier|*
name|sp
decl_stmt|;
block|{
name|struct
name|zp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|zp_softc
operator|*
operator|)
name|sp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|i
operator|=
name|sc
operator|->
name|last_mb
expr_stmt|;
do|do
block|{
if|if
condition|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|MGET
argument_list|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|MAX_MBS
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|sc
operator|->
name|next_mb
condition|)
do|;
name|sc
operator|->
name|buffill_pending
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|last_mb
operator|=
name|i
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|zpmbufempty
parameter_list|(
name|sc
parameter_list|)
name|struct
name|zp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MBS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|mb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mb
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|last_mb
operator|=
name|sc
operator|->
name|next_mb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|buffill_pending
operator|!=
literal|0
condition|)
block|{
name|untimeout
argument_list|(
name|zpmbuffill
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|buffill_pending
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

