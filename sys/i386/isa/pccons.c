begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz and Don Ahn.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)pccons.c	5.11 (Berkeley) 5/21/91  *	$Id: pccons.c,v 1.12 1994/01/03 07:55:45 davidg Exp $  */
end_comment

begin_comment
comment|/*  * code to work keyboard& display for PC-style console  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"callout.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/icu.h"
end_include

begin_include
include|#
directive|include
file|"i386/i386/cons.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/ic/i8042.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/kbd.h"
end_include

begin_include
include|#
directive|include
file|"machine/pc/display.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XSERVER
end_ifdef

begin_comment
comment|/* 15 Aug 92*/
end_comment

begin_decl_stmt
name|int
name|pc_xmode
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XSERVER */
end_comment

begin_decl_stmt
name|struct
name|tty
name|pccons
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|pcconsoftc
block|{
name|char
name|cs_flags
decl_stmt|;
define|#
directive|define
name|CSF_ACTIVE
value|0x1
comment|/* timeout active */
define|#
directive|define
name|CSF_POLLING
value|0x2
comment|/* polling for input */
name|char
name|cs_lastc
decl_stmt|;
comment|/* last char sent */
name|int
name|cs_timo
decl_stmt|;
comment|/* timeouts since interrupt */
name|u_long
name|cs_wedgecnt
decl_stmt|;
comment|/* times restarted */
block|}
name|pcconsoftc
struct|;
end_struct

begin_struct
struct|struct
name|kbdsoftc
block|{
name|char
name|kbd_flags
decl_stmt|;
define|#
directive|define
name|KBDF_ACTIVE
value|0x1
comment|/* timeout active */
define|#
directive|define
name|KBDF_POLLING
value|0x2
comment|/* polling for input */
define|#
directive|define
name|KBDF_RAW
value|0x4
comment|/* pass thru scan codes for input */
name|char
name|kbd_lastc
decl_stmt|;
comment|/* last char sent */
block|}
name|kbdsoftc
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|video_state
block|{
name|char
name|esc
decl_stmt|;
comment|/* seen escape */
name|char
name|ebrac
decl_stmt|;
comment|/* seen escape bracket */
name|char
name|eparm
decl_stmt|;
comment|/* seen escape and parameters */
name|char
name|so
decl_stmt|;
comment|/* in standout mode? */
name|int
name|cx
decl_stmt|;
comment|/* "x" parameter */
name|int
name|cy
decl_stmt|;
comment|/* "y" parameter */
name|int
name|row
decl_stmt|,
name|col
decl_stmt|;
comment|/* current cursor position */
name|int
name|nrow
decl_stmt|,
name|ncol
decl_stmt|;
comment|/* current screen geometry */
name|char
name|fg_at
decl_stmt|,
name|bg_at
decl_stmt|;
comment|/* normal attributes */
name|char
name|so_at
decl_stmt|;
comment|/* standout attribute */
name|char
name|kern_fg_at
decl_stmt|,
name|kern_bg_at
decl_stmt|;
name|char
name|color
decl_stmt|;
comment|/* color or mono display */
block|}
name|vs
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|pcprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|pcdriver
init|=
block|{
name|pcprobe
block|,
name|pcattach
block|,
literal|"pc"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COL
value|80
end_define

begin_define
define|#
directive|define
name|ROW
value|25
end_define

begin_define
define|#
directive|define
name|CHR
value|2
end_define

begin_define
define|#
directive|define
name|MONO_BASE
value|0x3B4
end_define

begin_define
define|#
directive|define
name|MONO_BUF
value|(KERNBASE + 0xB0000)
end_define

begin_define
define|#
directive|define
name|CGA_BASE
value|0x3D4
end_define

begin_define
define|#
directive|define
name|CGA_BUF
value|(KERNBASE + 0xB8000)
end_define

begin_define
define|#
directive|define
name|IOPHYSMEM
value|0xA0000
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|addr_6845
init|=
name|MONO_BASE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
modifier|*
name|Crtat
init|=
operator|(
name|u_short
operator|*
operator|)
name|MONO_BUF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|openf
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|sgetc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|char
modifier|*
name|more_chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|char_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We check the console periodically to make sure  * that it hasn't wedged.  Unfortunately, if an XOFF  * is typed on the console, that can't be distinguished  * from more catastrophic failure.  */
end_comment

begin_define
define|#
directive|define
name|CN_TIMERVAL
value|(hz)
end_define

begin_comment
comment|/* frequency at which to check cons */
end_comment

begin_define
define|#
directive|define
name|CN_TIMO
value|(2*60)
end_define

begin_comment
comment|/* intervals to allow for output char */
end_comment

begin_function_decl
name|void
name|pcstart
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pcparam
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|struct
name|termios
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
name|partab
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|cursor
parameter_list|(
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sput
parameter_list|(
name|int
comment|/*u_char*/
parameter_list|,
name|int
comment|/*u_char*/
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pc_xmode_on
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pc_xmode_off
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pcopen
parameter_list|(
name|int
comment|/*dev_t*/
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Wait for CP to accept last CP command sent  * before setting up next command.  */
end_comment

begin_define
define|#
directive|define
name|waitforlast
parameter_list|(
name|timo
parameter_list|)
value|{ \ 	if (pclast) { \ 		(timo) = 10000; \ 		do \ 			uncache((char *)&pclast->cp_unit); \ 		while ((pclast->cp_unit&CPTAKE) == 0&& --(timo)); \ 	} \ }
end_define

begin_comment
comment|/*  * Pass command to keyboard controller (8042)  */
end_comment

begin_function
specifier|static
name|int
name|kbc_8042cmd
parameter_list|(
name|val
parameter_list|)
name|int
name|val
decl_stmt|;
block|{
name|unsigned
name|timeo
decl_stmt|;
name|timeo
operator|=
literal|100000
expr_stmt|;
comment|/*> 100 msec */
while|while
condition|(
name|inb
argument_list|(
name|KBSTATP
argument_list|)
operator|&
name|KBS_IBF
condition|)
if|if
condition|(
operator|--
name|timeo
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|outb
argument_list|(
name|KBCMDP
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pass command to keyboard itself  */
end_comment

begin_function
name|int
name|kbd_cmd
parameter_list|(
name|val
parameter_list|)
name|int
name|val
decl_stmt|;
block|{
name|unsigned
name|timeo
decl_stmt|;
name|timeo
operator|=
literal|100000
expr_stmt|;
comment|/*> 100 msec */
while|while
condition|(
name|inb
argument_list|(
name|KBSTATP
argument_list|)
operator|&
name|KBS_IBF
condition|)
if|if
condition|(
operator|--
name|timeo
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|outb
argument_list|(
name|KBOUTP
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read response from keyboard  */
end_comment

begin_function
name|int
name|kbd_response
parameter_list|()
block|{
name|unsigned
name|timeo
decl_stmt|;
name|timeo
operator|=
literal|500000
expr_stmt|;
comment|/*> 500 msec (KBR_RSTDONE requires 87) */
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|KBSTATP
argument_list|)
operator|&
name|KBS_DIB
operator|)
condition|)
if|if
condition|(
operator|--
name|timeo
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|(
name|u_char
operator|)
name|inb
argument_list|(
name|KBDATAP
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * these are both bad jokes  */
end_comment

begin_function
name|int
name|pcprobe
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|again
init|=
literal|0
decl_stmt|;
name|int
name|response
decl_stmt|;
comment|/* Enable interrupts and keyboard, etc. */
if|if
condition|(
name|kbc_8042cmd
argument_list|(
name|K_LDCMDBYTE
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Timeout specifying load of keyboard command byte\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbd_cmd
argument_list|(
name|CMDBYTE
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Timeout writing keyboard command byte\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Discard any stale keyboard activity.  The 0.1 boot code isn't 	 * very careful and sometimes leaves a KBR_RESEND. 	 */
while|while
condition|(
name|inb
argument_list|(
name|KBSTATP
argument_list|)
operator|&
name|KBS_DIB
condition|)
name|kbd_response
argument_list|()
expr_stmt|;
comment|/* Start keyboard reset */
if|if
condition|(
name|kbd_cmd
argument_list|(
name|KBC_RESET
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Timeout for keyboard reset command\n"
argument_list|)
expr_stmt|;
comment|/* Wait for the first response to reset and handle retries */
while|while
condition|(
operator|(
name|response
operator|=
name|kbd_response
argument_list|()
operator|)
operator|!=
name|KBR_ACK
condition|)
block|{
if|if
condition|(
name|response
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Timeout for keyboard reset ack byte #1\n"
argument_list|)
expr_stmt|;
name|response
operator|=
name|KBR_RESEND
expr_stmt|;
block|}
if|if
condition|(
name|response
operator|==
name|KBR_RESEND
condition|)
block|{
if|if
condition|(
operator|!
name|again
condition|)
block|{
name|printf
argument_list|(
literal|"KEYBOARD disconnected: RECONNECT\n"
argument_list|)
expr_stmt|;
name|again
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|kbd_cmd
argument_list|(
name|KBC_RESET
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Timeout for keyboard reset command\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Other responses are harmless.  They may occur for new 		 * keystrokes. 		 */
block|}
comment|/* Wait for the second response to reset */
while|while
condition|(
operator|(
name|response
operator|=
name|kbd_response
argument_list|()
operator|)
operator|!=
name|KBR_RSTDONE
condition|)
block|{
if|if
condition|(
name|response
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Timeout for keyboard reset ack byte #2\n"
argument_list|)
expr_stmt|;
comment|/* 			 * If KBR_RSTDONE never arrives, the loop will 			 * finish here unless the keyboard babbles or 			 * KBS_DIB gets stuck. 			 */
break|break;
block|}
block|}
return|return
operator|(
name|IO_KBDSIZE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcattach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|u_short
modifier|*
name|cp
init|=
name|Crtat
operator|+
operator|(
name|CGA_BUF
operator|-
name|MONO_BUF
operator|)
operator|/
name|CHR
decl_stmt|;
name|u_short
name|was
decl_stmt|;
if|if
condition|(
name|vs
operator|.
name|color
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"pc%d: type monochrome\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"pc%d: type color\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|cursor
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|pcopen
parameter_list|(
name|int
comment|/*dev_t*/
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
else|#
directive|else
function|pcopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|=
operator|&
name|pccons
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|pcstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|pcparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|openf
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
name|pcparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|,
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
operator|(
operator|*
name|linesw
index|[
name|pccons
operator|.
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
operator|&
name|pccons
operator|,
name|flag
operator|)
expr_stmt|;
name|ttyclose
argument_list|(
operator|&
name|pccons
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|pcread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|pccons
operator|.
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
operator|&
name|pccons
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|pcwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|pccons
operator|.
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
operator|&
name|pccons
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Got a console receive interrupt -  * the console processor wants to give us a character.  * Catch the character, and see who it goes to.  */
end_comment

begin_function
name|void
name|pcrint
parameter_list|(
name|dev
parameter_list|,
name|irq
parameter_list|,
name|cpl
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|irq
decl_stmt|;
comment|/* XXX ??? */
name|int
name|cpl
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|sgetc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|pcconsoftc
operator|.
name|cs_flags
operator|&
name|CSF_POLLING
condition|)
return|return;
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|kdbrintr
argument_list|(
name|c
argument_list|,
operator|&
name|pccons
argument_list|)
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
operator|!
name|openf
condition|)
return|return;
ifdef|#
directive|ifdef
name|XSERVER
comment|/* 15 Aug 92*/
comment|/* send at least one character, because cntl-space is a null */
operator|(
operator|*
name|linesw
index|[
name|pccons
operator|.
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|*
name|cp
operator|++
operator|&
literal|0xff
operator|,
operator|&
name|pccons
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* XSERVER */
while|while
condition|(
operator|*
name|cp
condition|)
operator|(
operator|*
name|linesw
index|[
name|pccons
operator|.
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|*
name|cp
operator|++
operator|&
literal|0xff
operator|,
operator|&
name|pccons
operator|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XSERVER
end_ifdef

begin_comment
comment|/* 15 Aug 92*/
end_comment

begin_define
define|#
directive|define
name|CONSOLE_X_MODE_ON
value|_IO('t',121)
end_define

begin_define
define|#
directive|define
name|CONSOLE_X_MODE_OFF
value|_IO('t',122)
end_define

begin_define
define|#
directive|define
name|CONSOLE_X_BELL
value|_IOW('t',123,int[2])
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XSERVER */
end_comment

begin_function
name|int
name|pcioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|pccons
decl_stmt|;
specifier|register
name|error
expr_stmt|;
ifdef|#
directive|ifdef
name|XSERVER
comment|/* 15 Aug 92*/
if|if
condition|(
name|cmd
operator|==
name|CONSOLE_X_MODE_ON
condition|)
block|{
name|pc_xmode_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|CONSOLE_X_MODE_OFF
condition|)
block|{
name|pc_xmode_off
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|CONSOLE_X_BELL
condition|)
block|{
comment|/* if set, data is a pointer to a length 2 array of 		   integers. data[0] is the pitch in Hz and data[1] 		   is the duration in msec.  */
if|if
condition|(
name|data
condition|)
block|{
name|sysbeep
argument_list|(
literal|1187500
operator|/
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|1
index|]
operator|*
name|hz
operator|/
literal|3000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sysbeep
argument_list|(
literal|0x31b
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* XSERVER */
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|pcconsintr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Got a console transmission interrupt -  * the console processor wants another character.  */
end_comment

begin_function
name|void
name|pcxint
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
if|if
condition|(
operator|!
name|pcconsintr
condition|)
return|return;
name|pccons
operator|.
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|pcconsoftc
operator|.
name|cs_timo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pccons
operator|.
name|t_line
condition|)
operator|(
operator|*
name|linesw
index|[
name|pccons
operator|.
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
operator|&
name|pccons
operator|)
expr_stmt|;
else|else
name|pcstart
argument_list|(
operator|&
name|pccons
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pcstart
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
do|do
block|{
if|if
condition|(
name|RB_LEN
argument_list|(
operator|&
name|tp
operator|->
name|t_out
argument_list|)
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_wsel
condition|)
block|{
name|selwakeup
argument_list|(
name|tp
operator|->
name|t_wsel
argument_list|,
name|tp
operator|->
name|t_state
operator|&
name|TS_WCOLL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_wsel
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_WCOLL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|RB_LEN
argument_list|(
operator|&
name|tp
operator|->
name|t_out
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|c
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
comment|/* 21 Aug 92*/
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sput
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spltty
argument_list|()
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
comment|/* 21 Aug 92*/
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pccnprobe
parameter_list|(
name|cp
parameter_list|)
name|struct
name|consdev
modifier|*
name|cp
decl_stmt|;
block|{
name|int
name|maj
decl_stmt|;
comment|/* locate the major number */
for|for
control|(
name|maj
operator|=
literal|0
init|;
name|maj
operator|<
name|nchrdev
condition|;
name|maj
operator|++
control|)
if|if
condition|(
name|cdevsw
index|[
name|maj
index|]
operator|.
name|d_open
operator|==
name|pcopen
condition|)
break|break;
comment|/* initialize required fields */
name|cp
operator|->
name|cn_dev
operator|=
name|makedev
argument_list|(
name|maj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cn_tp
operator|=
operator|&
name|pccons
expr_stmt|;
name|cp
operator|->
name|cn_pri
operator|=
name|CN_INTERNAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|pccninit
parameter_list|(
name|cp
parameter_list|)
name|struct
name|consdev
modifier|*
name|cp
decl_stmt|;
block|{
comment|/* 	 * For now, don't screw with it. 	 */
comment|/* crtat = 0; */
block|}
end_function

begin_expr_stmt
specifier|static
name|__color
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|pccnputc
parameter_list|(
name|dev
parameter_list|,
name|c
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|sput
argument_list|(
literal|'\r'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sput
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print a character on console.  */
end_comment

begin_function
name|void
name|pcputchar
parameter_list|(
name|c
parameter_list|,
name|tp
parameter_list|)
name|char
name|c
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|sput
argument_list|(
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*if (c=='\n') getchar();*/
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|pccngetc
parameter_list|(
name|dev
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
block|{
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
ifdef|#
directive|ifdef
name|XSERVER
comment|/* 15 Aug 92*/
if|if
condition|(
name|pc_xmode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* XSERVER */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* block pcrint while we poll */
name|cp
operator|=
name|sgetc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\r'
condition|)
return|return
operator|(
literal|'\n'
operator|)
return|;
return|return
operator|(
operator|*
name|cp
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcgetchar
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
ifdef|#
directive|ifdef
name|XSERVER
comment|/* 15 Aug 92*/
if|if
condition|(
name|pc_xmode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* XSERVER */
name|cp
operator|=
name|sgetc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|cp
operator|&
literal|0xff
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set line parameters  */
end_comment

begin_function
name|int
name|pcparam
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|int
name|cflag
init|=
name|t
operator|->
name|c_cflag
decl_stmt|;
comment|/* and copy to tty */
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|cflag
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KDB
end_ifdef

begin_comment
comment|/*  * Turn input polling on/off (used by debugger).  */
end_comment

begin_macro
name|pcpoll
argument_list|(
argument|onoff
argument_list|)
end_macro

begin_decl_stmt
name|int
name|onoff
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * cursor():  *   reassigns cursor position, updated by the rescheduling clock  *   which is a index (0-1999) into the text area. Note that the  *   cursor is a "foreground" character, it's color determined by  *   the fg_at attribute. Thus if fg_at is left as 0, (FG_BLACK),  *   as when a portion of screen memory is 0, the cursor may dissappear.  */
end_comment

begin_decl_stmt
specifier|static
name|u_short
modifier|*
name|crtat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|cursor
parameter_list|(
name|caddr_t
name|rock
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
name|int
name|pos
init|=
name|crtat
operator|-
name|Crtat
decl_stmt|;
ifdef|#
directive|ifdef
name|XSERVER
comment|/* 15 Aug 92*/
if|if
condition|(
operator|!
name|pc_xmode
condition|)
block|{
endif|#
directive|endif
comment|/* XSERVER */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|pos
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|pos
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FAT_CURSOR
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|18
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FAT_CURSOR */
if|if
condition|(
name|rock
operator|==
literal|0
condition|)
name|timeout
argument_list|(
name|cursor
argument_list|,
literal|0
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XSERVER
comment|/* 15 Aug 92*/
block|}
endif|#
directive|endif
comment|/* XSERVER */
block|}
end_function

begin_decl_stmt
specifier|static
name|u_char
name|shift_down
decl_stmt|,
name|ctrl_down
decl_stmt|,
name|alt_down
decl_stmt|,
name|caps
decl_stmt|,
name|num
decl_stmt|,
name|scroll
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|wrtchar
parameter_list|(
name|c
parameter_list|,
name|at
parameter_list|)
define|\
value|{ char *cp = (char *)crtat; *cp++ = (c); *cp = (at); crtat++; vs.col++; }
end_define

begin_comment
comment|/* translate ANSI color codes to standard pc ones */
end_comment

begin_decl_stmt
specifier|static
name|char
name|fgansitopc
index|[]
init|=
block|{
name|FG_BLACK
block|,
name|FG_RED
block|,
name|FG_GREEN
block|,
name|FG_BROWN
block|,
name|FG_BLUE
block|,
name|FG_MAGENTA
block|,
name|FG_CYAN
block|,
name|FG_LIGHTGREY
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|bgansitopc
index|[]
init|=
block|{
name|BG_BLACK
block|,
name|BG_RED
block|,
name|BG_GREEN
block|,
name|BG_BROWN
block|,
name|BG_BLUE
block|,
name|BG_MAGENTA
block|,
name|BG_CYAN
block|,
name|BG_LIGHTGREY
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|move_up
parameter_list|(
name|u_short
modifier|*
name|s
parameter_list|,
name|u_short
modifier|*
name|d
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|s
operator|+=
name|len
expr_stmt|;
name|d
operator|+=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
operator|*
operator|--
name|d
operator|=
operator|*
operator|--
name|s
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|move_down
parameter_list|(
name|u_short
modifier|*
name|s
parameter_list|,
name|u_short
modifier|*
name|d
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *   sput has support for emulation of the 'pc3' termcap entry.  *   if ka, use kernel attributes.  */
end_comment

begin_function
specifier|static
name|void
name|sput
parameter_list|(
name|c
parameter_list|,
name|ka
parameter_list|)
name|u_char
name|c
decl_stmt|;
name|u_char
name|ka
decl_stmt|;
block|{
name|int
name|sc
init|=
literal|1
decl_stmt|;
comment|/* do scroll check */
name|char
name|fg_at
decl_stmt|,
name|bg_at
decl_stmt|,
name|at
decl_stmt|;
ifdef|#
directive|ifdef
name|XSERVER
comment|/* 15 Aug 92*/
if|if
condition|(
name|pc_xmode
condition|)
return|return;
endif|#
directive|endif
comment|/* XSERVER */
if|if
condition|(
name|crtat
operator|==
literal|0
condition|)
block|{
name|u_short
specifier|volatile
modifier|*
name|cp
init|=
name|Crtat
operator|+
operator|(
name|CGA_BUF
operator|-
name|MONO_BUF
operator|)
operator|/
name|CHR
decl_stmt|;
name|u_short
name|was
decl_stmt|;
name|unsigned
name|cursorat
decl_stmt|;
comment|/* 		 *   Crtat  initialized  to  point  to  MONO  buffer  if not present 		 *   change   to  CGA_BUF  offset  ONLY  ADD  the  difference  since 		 *   locore.s adds in the remapped offset at the right time 		 */
name|was
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
operator|(
name|u_short
operator|)
literal|0xA55A
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|0xA55A
condition|)
block|{
name|addr_6845
operator|=
name|MONO_BASE
expr_stmt|;
name|vs
operator|.
name|color
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|=
name|was
expr_stmt|;
name|addr_6845
operator|=
name|CGA_BASE
expr_stmt|;
name|Crtat
operator|=
name|Crtat
operator|+
operator|(
name|CGA_BUF
operator|-
name|MONO_BUF
operator|)
operator|/
name|CHR
expr_stmt|;
name|vs
operator|.
name|color
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Extract cursor location */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|cursorat
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|cursorat
operator||=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|crtat
operator|=
name|Crtat
operator|+
name|cursorat
expr_stmt|;
name|vs
operator|.
name|ncol
operator|=
name|COL
expr_stmt|;
name|vs
operator|.
name|nrow
operator|=
name|ROW
expr_stmt|;
name|vs
operator|.
name|fg_at
operator|=
name|FG_LIGHTGREY
expr_stmt|;
name|vs
operator|.
name|bg_at
operator|=
name|BG_BLACK
expr_stmt|;
if|if
condition|(
name|vs
operator|.
name|color
operator|==
literal|0
condition|)
block|{
name|vs
operator|.
name|kern_fg_at
operator|=
name|FG_UNDERLINE
expr_stmt|;
name|vs
operator|.
name|so_at
operator|=
name|FG_BLACK
operator||
name|BG_LIGHTGREY
expr_stmt|;
block|}
else|else
block|{
name|vs
operator|.
name|kern_fg_at
operator|=
name|FG_LIGHTGREY
expr_stmt|;
name|vs
operator|.
name|so_at
operator|=
name|FG_YELLOW
operator||
name|BG_BLACK
expr_stmt|;
block|}
name|vs
operator|.
name|kern_bg_at
operator|=
name|BG_BLACK
expr_stmt|;
name|fillw
argument_list|(
operator|(
operator|(
name|vs
operator|.
name|bg_at
operator||
name|vs
operator|.
name|fg_at
operator|)
operator|<<
literal|8
operator|)
operator||
literal|' '
argument_list|,
name|crtat
argument_list|,
name|COL
operator|*
name|ROW
operator|-
name|cursorat
argument_list|)
expr_stmt|;
block|}
comment|/* which attributes do we use? */
if|if
condition|(
name|ka
condition|)
block|{
name|fg_at
operator|=
name|vs
operator|.
name|kern_fg_at
expr_stmt|;
name|bg_at
operator|=
name|vs
operator|.
name|kern_bg_at
expr_stmt|;
block|}
else|else
block|{
name|fg_at
operator|=
name|vs
operator|.
name|fg_at
expr_stmt|;
name|bg_at
operator|=
name|vs
operator|.
name|bg_at
expr_stmt|;
block|}
name|at
operator|=
name|fg_at
operator||
name|bg_at
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
name|int
name|inccol
decl_stmt|;
case|case
literal|0x1B
case|:
if|if
condition|(
name|vs
operator|.
name|esc
condition|)
name|wrtchar
argument_list|(
name|c
argument_list|,
name|vs
operator|.
name|so_at
argument_list|)
expr_stmt|;
name|vs
operator|.
name|esc
operator|=
literal|1
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|inccol
operator|=
operator|(
literal|8
operator|-
name|vs
operator|.
name|col
operator|%
literal|8
operator|)
expr_stmt|;
comment|/* non-destructive tab */
name|crtat
operator|+=
name|inccol
expr_stmt|;
name|vs
operator|.
name|col
operator|+=
name|inccol
expr_stmt|;
break|break;
case|case
literal|'\010'
case|:
name|crtat
operator|--
expr_stmt|;
name|vs
operator|.
name|col
operator|--
expr_stmt|;
if|if
condition|(
name|vs
operator|.
name|col
operator|<
literal|0
condition|)
name|vs
operator|.
name|col
operator|+=
name|vs
operator|.
name|ncol
expr_stmt|;
comment|/* non-destructive backspace */
break|break;
case|case
literal|'\r'
case|:
name|crtat
operator|-=
operator|(
name|crtat
operator|-
name|Crtat
operator|)
operator|%
name|vs
operator|.
name|ncol
expr_stmt|;
name|vs
operator|.
name|col
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|crtat
operator|+=
name|vs
operator|.
name|ncol
expr_stmt|;
break|break;
default|default:
name|bypass
label|:
if|if
condition|(
name|vs
operator|.
name|esc
condition|)
block|{
if|if
condition|(
name|vs
operator|.
name|ebrac
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
name|int
name|pos
decl_stmt|,
name|posy
decl_stmt|,
name|count
decl_stmt|;
name|u_short
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
case|case
literal|'m'
case|:
if|if
condition|(
operator|!
name|vs
operator|.
name|cx
condition|)
name|vs
operator|.
name|so
operator|=
literal|0
expr_stmt|;
else|else
name|vs
operator|.
name|so
operator|=
literal|1
expr_stmt|;
name|vs
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* back cx rows */
if|if
condition|(
name|vs
operator|.
name|cx
operator|<=
literal|0
condition|)
name|vs
operator|.
name|cx
operator|=
literal|1
expr_stmt|;
name|pos
operator|=
name|crtat
operator|-
name|Crtat
expr_stmt|;
name|pos
operator|-=
name|vs
operator|.
name|ncol
operator|*
name|vs
operator|.
name|cx
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|pos
operator|+=
name|vs
operator|.
name|nrow
operator|*
name|vs
operator|.
name|ncol
expr_stmt|;
name|crtat
operator|=
name|Crtat
operator|+
name|pos
expr_stmt|;
name|sc
operator|=
name|vs
operator|.
name|esc
operator|=
name|vs
operator|.
name|ebrac
operator|=
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* down cx rows */
if|if
condition|(
name|vs
operator|.
name|cx
operator|<=
literal|0
condition|)
name|vs
operator|.
name|cx
operator|=
literal|1
expr_stmt|;
name|pos
operator|=
name|crtat
operator|-
name|Crtat
expr_stmt|;
name|pos
operator|+=
name|vs
operator|.
name|ncol
operator|*
name|vs
operator|.
name|cx
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|vs
operator|.
name|nrow
operator|*
name|vs
operator|.
name|ncol
condition|)
name|pos
operator|-=
name|vs
operator|.
name|nrow
operator|*
name|vs
operator|.
name|ncol
expr_stmt|;
name|crtat
operator|=
name|Crtat
operator|+
name|pos
expr_stmt|;
name|sc
operator|=
name|vs
operator|.
name|esc
operator|=
name|vs
operator|.
name|ebrac
operator|=
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* right cursor */
if|if
condition|(
name|vs
operator|.
name|cx
operator|<=
literal|0
condition|)
name|vs
operator|.
name|cx
operator|=
literal|1
expr_stmt|;
name|pos
operator|=
name|crtat
operator|-
name|Crtat
expr_stmt|;
name|pos
operator|+=
name|vs
operator|.
name|cx
expr_stmt|;
name|vs
operator|.
name|col
operator|+=
name|vs
operator|.
name|cx
expr_stmt|;
if|if
condition|(
name|vs
operator|.
name|col
operator|>=
name|vs
operator|.
name|ncol
condition|)
block|{
name|vs
operator|.
name|col
operator|-=
name|vs
operator|.
name|ncol
expr_stmt|;
name|pos
operator|-=
name|vs
operator|.
name|ncol
expr_stmt|;
comment|/* cursor stays on same line */
block|}
name|crtat
operator|=
name|Crtat
operator|+
name|pos
expr_stmt|;
name|sc
operator|=
name|vs
operator|.
name|esc
operator|=
name|vs
operator|.
name|ebrac
operator|=
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* left cursor */
if|if
condition|(
name|vs
operator|.
name|cx
operator|<=
literal|0
condition|)
name|vs
operator|.
name|cx
operator|=
literal|1
expr_stmt|;
name|pos
operator|=
name|crtat
operator|-
name|Crtat
expr_stmt|;
name|pos
operator|-=
name|vs
operator|.
name|cx
expr_stmt|;
name|vs
operator|.
name|col
operator|-=
name|vs
operator|.
name|cx
expr_stmt|;
if|if
condition|(
name|vs
operator|.
name|col
operator|<
literal|0
condition|)
block|{
name|vs
operator|.
name|col
operator|+=
name|vs
operator|.
name|ncol
expr_stmt|;
name|pos
operator|+=
name|vs
operator|.
name|ncol
expr_stmt|;
comment|/* cursor stays on same line */
block|}
name|crtat
operator|=
name|Crtat
operator|+
name|pos
expr_stmt|;
name|sc
operator|=
name|vs
operator|.
name|esc
operator|=
name|vs
operator|.
name|ebrac
operator|=
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* Clear ... */
if|if
condition|(
name|vs
operator|.
name|cx
operator|==
literal|0
condition|)
comment|/* ... to end of display */
name|fillw
argument_list|(
operator|(
name|at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|crtat
argument_list|,
name|Crtat
operator|+
name|vs
operator|.
name|ncol
operator|*
name|vs
operator|.
name|nrow
operator|-
name|crtat
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vs
operator|.
name|cx
operator|==
literal|1
condition|)
comment|/* ... to next location */
name|fillw
argument_list|(
operator|(
name|at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|Crtat
argument_list|,
name|crtat
operator|-
name|Crtat
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vs
operator|.
name|cx
operator|==
literal|2
condition|)
comment|/* ... whole display */
name|fillw
argument_list|(
operator|(
name|at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|Crtat
argument_list|,
name|vs
operator|.
name|ncol
operator|*
name|vs
operator|.
name|nrow
argument_list|)
expr_stmt|;
name|vs
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
comment|/* Clear line ... */
if|if
condition|(
name|vs
operator|.
name|cx
operator|==
literal|0
condition|)
comment|/* ... current to EOL */
name|fillw
argument_list|(
operator|(
name|at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|crtat
argument_list|,
name|vs
operator|.
name|ncol
operator|-
operator|(
name|crtat
operator|-
name|Crtat
operator|)
operator|%
name|vs
operator|.
name|ncol
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vs
operator|.
name|cx
operator|==
literal|1
condition|)
comment|/* ... beginning to next */
name|fillw
argument_list|(
operator|(
name|at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|crtat
operator|-
operator|(
name|crtat
operator|-
name|Crtat
operator|)
operator|%
name|vs
operator|.
name|ncol
argument_list|,
operator|(
operator|(
name|crtat
operator|-
name|Crtat
operator|)
operator|%
name|vs
operator|.
name|ncol
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vs
operator|.
name|cx
operator|==
literal|2
condition|)
comment|/* ... entire line */
name|fillw
argument_list|(
operator|(
name|at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|crtat
operator|-
operator|(
name|crtat
operator|-
name|Crtat
operator|)
operator|%
name|vs
operator|.
name|ncol
argument_list|,
name|vs
operator|.
name|ncol
argument_list|)
expr_stmt|;
name|vs
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* in system V consoles */
case|case
literal|'H'
case|:
comment|/* Cursor move */
if|if
condition|(
operator|(
operator|!
name|vs
operator|.
name|cx
operator|)
operator|||
operator|(
operator|!
name|vs
operator|.
name|cy
operator|)
condition|)
block|{
name|crtat
operator|=
name|Crtat
expr_stmt|;
name|vs
operator|.
name|col
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|crtat
operator|=
name|Crtat
operator|+
operator|(
name|vs
operator|.
name|cx
operator|-
literal|1
operator|)
operator|*
name|vs
operator|.
name|ncol
operator|+
name|vs
operator|.
name|cy
operator|-
literal|1
expr_stmt|;
name|vs
operator|.
name|col
operator|=
name|vs
operator|.
name|cy
operator|-
literal|1
expr_stmt|;
block|}
name|vs
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* scroll up cx lines */
if|if
condition|(
name|vs
operator|.
name|cx
operator|<=
literal|0
condition|)
name|vs
operator|.
name|cx
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|Crtat
operator|+
name|vs
operator|.
name|ncol
operator|*
name|vs
operator|.
name|cx
argument_list|,
name|Crtat
argument_list|,
name|vs
operator|.
name|ncol
operator|*
operator|(
name|vs
operator|.
name|nrow
operator|-
name|vs
operator|.
name|cx
operator|)
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
operator|(
name|at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
operator|(
name|Crtat
operator|+
name|vs
operator|.
name|ncol
operator|*
operator|(
name|vs
operator|.
name|nrow
operator|-
name|vs
operator|.
name|cx
operator|)
operator|)
argument_list|,
name|vs
operator|.
name|ncol
operator|*
name|vs
operator|.
name|cx
argument_list|)
expr_stmt|;
comment|/* crtat -= vs.ncol*vs.cx;*/
comment|/* XXX */
name|vs
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
comment|/* scroll down cx lines */
if|if
condition|(
name|vs
operator|.
name|cx
operator|<=
literal|0
condition|)
name|vs
operator|.
name|cx
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|Crtat
argument_list|,
name|Crtat
operator|+
name|vs
operator|.
name|ncol
operator|*
name|vs
operator|.
name|cx
argument_list|,
name|vs
operator|.
name|ncol
operator|*
operator|(
name|vs
operator|.
name|nrow
operator|-
name|vs
operator|.
name|cx
operator|)
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
operator|(
name|at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|Crtat
argument_list|,
name|vs
operator|.
name|ncol
operator|*
name|vs
operator|.
name|cx
argument_list|)
expr_stmt|;
comment|/* crtat += vs.ncol*vs.cx;*/
comment|/* XXX */
name|vs
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Insert cx lines */
if|if
condition|(
name|vs
operator|.
name|cx
operator|<=
literal|0
condition|)
name|vs
operator|.
name|cx
operator|=
literal|1
expr_stmt|;
name|posy
operator|=
operator|(
name|crtat
operator|-
name|Crtat
operator|)
operator|/
name|vs
operator|.
name|ncol
expr_stmt|;
if|if
condition|(
name|vs
operator|.
name|cx
operator|>
name|vs
operator|.
name|nrow
operator|-
name|posy
condition|)
name|vs
operator|.
name|cx
operator|=
name|vs
operator|.
name|nrow
operator|-
name|posy
expr_stmt|;
name|src
operator|=
name|Crtat
operator|+
name|posy
operator|*
name|vs
operator|.
name|ncol
expr_stmt|;
name|dst
operator|=
name|src
operator|+
name|vs
operator|.
name|cx
operator|*
name|vs
operator|.
name|ncol
expr_stmt|;
name|count
operator|=
name|vs
operator|.
name|nrow
operator|-
operator|(
name|posy
operator|+
name|vs
operator|.
name|cx
operator|)
expr_stmt|;
name|move_up
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
name|vs
operator|.
name|ncol
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
operator|(
name|at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|src
argument_list|,
name|vs
operator|.
name|cx
operator|*
name|vs
operator|.
name|ncol
argument_list|)
expr_stmt|;
name|vs
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* Delete cx lines */
if|if
condition|(
name|vs
operator|.
name|cx
operator|<=
literal|0
condition|)
name|vs
operator|.
name|cx
operator|=
literal|1
expr_stmt|;
name|posy
operator|=
operator|(
name|crtat
operator|-
name|Crtat
operator|)
operator|/
name|vs
operator|.
name|ncol
expr_stmt|;
if|if
condition|(
name|vs
operator|.
name|cx
operator|>
name|vs
operator|.
name|nrow
operator|-
name|posy
condition|)
name|vs
operator|.
name|cx
operator|=
name|vs
operator|.
name|nrow
operator|-
name|posy
expr_stmt|;
name|dst
operator|=
name|Crtat
operator|+
name|posy
operator|*
name|vs
operator|.
name|ncol
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|vs
operator|.
name|cx
operator|*
name|vs
operator|.
name|ncol
expr_stmt|;
name|count
operator|=
name|vs
operator|.
name|nrow
operator|-
operator|(
name|posy
operator|+
name|vs
operator|.
name|cx
operator|)
expr_stmt|;
name|move_down
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|count
operator|*
name|vs
operator|.
name|ncol
argument_list|)
expr_stmt|;
name|src
operator|=
name|dst
operator|+
name|count
operator|*
name|vs
operator|.
name|ncol
expr_stmt|;
name|fillw
argument_list|(
operator|(
name|at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|src
argument_list|,
name|vs
operator|.
name|cx
operator|*
name|vs
operator|.
name|ncol
argument_list|)
expr_stmt|;
name|vs
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|';'
case|:
comment|/* Switch params in cursor def */
name|vs
operator|.
name|eparm
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|vs
operator|.
name|so_at
operator|=
operator|(
name|vs
operator|.
name|cx
operator|&
literal|0x0f
operator|)
operator||
operator|(
operator|(
name|vs
operator|.
name|cy
operator|&
literal|0x0f
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|vs
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* set attributes */
switch|switch
condition|(
name|vs
operator|.
name|cx
condition|)
block|{
case|case
literal|0
case|:
comment|/* reset to normal attributes */
name|bg_at
operator|=
name|BG_BLACK
expr_stmt|;
if|if
condition|(
name|ka
condition|)
name|fg_at
operator|=
name|vs
operator|.
name|color
condition|?
name|FG_LIGHTGREY
else|:
name|FG_UNDERLINE
expr_stmt|;
else|else
name|fg_at
operator|=
name|FG_LIGHTGREY
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* ansi background */
if|if
condition|(
name|vs
operator|.
name|color
condition|)
name|bg_at
operator|=
name|bgansitopc
index|[
name|vs
operator|.
name|cy
operator|&
literal|7
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* ansi foreground */
if|if
condition|(
name|vs
operator|.
name|color
condition|)
name|fg_at
operator|=
name|fgansitopc
index|[
name|vs
operator|.
name|cy
operator|&
literal|7
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* pc text attribute */
if|if
condition|(
name|vs
operator|.
name|eparm
condition|)
block|{
name|fg_at
operator|=
name|vs
operator|.
name|cy
operator|&
literal|0x8f
expr_stmt|;
name|bg_at
operator|=
name|vs
operator|.
name|cy
operator|&
literal|0x70
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|ka
condition|)
block|{
name|vs
operator|.
name|kern_fg_at
operator|=
name|fg_at
expr_stmt|;
name|vs
operator|.
name|kern_bg_at
operator|=
name|bg_at
expr_stmt|;
block|}
else|else
block|{
name|vs
operator|.
name|fg_at
operator|=
name|fg_at
expr_stmt|;
name|vs
operator|.
name|bg_at
operator|=
name|bg_at
expr_stmt|;
block|}
name|vs
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* Only numbers valid here */
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
if|if
condition|(
name|vs
operator|.
name|eparm
condition|)
block|{
name|vs
operator|.
name|cy
operator|*=
literal|10
expr_stmt|;
name|vs
operator|.
name|cy
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|vs
operator|.
name|cx
operator|*=
literal|10
expr_stmt|;
name|vs
operator|.
name|cx
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
else|else
block|{
name|vs
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'c'
condition|)
block|{
comment|/* Clear screen& home */
name|fillw
argument_list|(
operator|(
name|at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|Crtat
argument_list|,
name|vs
operator|.
name|ncol
operator|*
name|vs
operator|.
name|nrow
argument_list|)
expr_stmt|;
name|crtat
operator|=
name|Crtat
expr_stmt|;
name|vs
operator|.
name|col
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
comment|/* Start ESC [ sequence */
name|vs
operator|.
name|ebrac
operator|=
literal|1
expr_stmt|;
name|vs
operator|.
name|cx
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|cy
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Invalid, clear state */
name|vs
operator|.
name|esc
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|ebrac
operator|=
literal|0
expr_stmt|;
name|vs
operator|.
name|eparm
operator|=
literal|0
expr_stmt|;
name|wrtchar
argument_list|(
name|c
argument_list|,
name|vs
operator|.
name|so_at
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|7
condition|)
name|sysbeep
argument_list|(
literal|0x31b
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|vs
operator|.
name|so
condition|)
block|{
name|wrtchar
argument_list|(
name|c
argument_list|,
name|vs
operator|.
name|so_at
argument_list|)
expr_stmt|;
block|}
else|else
name|wrtchar
argument_list|(
name|c
argument_list|,
name|at
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
operator|.
name|col
operator|>=
name|vs
operator|.
name|ncol
condition|)
name|vs
operator|.
name|col
operator|=
literal|0
expr_stmt|;
break|break ;
block|}
block|}
block|}
if|if
condition|(
name|sc
operator|&&
name|crtat
operator|>=
name|Crtat
operator|+
name|vs
operator|.
name|ncol
operator|*
name|vs
operator|.
name|nrow
condition|)
block|{
comment|/* scroll check */
if|if
condition|(
name|openf
condition|)
do|do
operator|(
name|void
operator|)
name|sgetc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
name|scroll
condition|)
do|;
name|bcopy
argument_list|(
name|Crtat
operator|+
name|vs
operator|.
name|ncol
argument_list|,
name|Crtat
argument_list|,
name|vs
operator|.
name|ncol
operator|*
operator|(
name|vs
operator|.
name|nrow
operator|-
literal|1
operator|)
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
operator|(
name|at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|Crtat
operator|+
name|vs
operator|.
name|ncol
operator|*
operator|(
name|vs
operator|.
name|nrow
operator|-
literal|1
operator|)
argument_list|,
name|vs
operator|.
name|ncol
argument_list|)
expr_stmt|;
name|crtat
operator|-=
name|vs
operator|.
name|ncol
expr_stmt|;
block|}
if|if
condition|(
name|ka
condition|)
name|cursor
argument_list|(
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|__debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*0xffe */
end_comment

begin_decl_stmt
specifier|static
name|char
name|scantokey
index|[]
init|=
block|{
literal|0
block|,
literal|120
block|,
comment|/* F9 */
literal|0
block|,
literal|116
block|,
comment|/* F5 */
literal|114
block|,
comment|/* F3 */
literal|112
block|,
comment|/* F1 */
literal|113
block|,
comment|/* F2 */
literal|123
block|,
comment|/* F12 */
literal|0
block|,
literal|121
block|,
comment|/* F10 */
literal|119
block|,
comment|/* F8 */
literal|117
block|,
comment|/* F6 */
literal|115
block|,
comment|/* F4 */
literal|16
block|,
comment|/* TAB */
literal|1
block|,
comment|/* ` */
literal|0
block|,
literal|0
block|,
literal|60
block|,
comment|/* ALT (left) */
literal|44
block|,
comment|/* SHIFT (left) */
literal|0
block|,
literal|58
block|,
comment|/* CTRL (left) */
literal|17
block|,
comment|/* Q */
literal|2
block|,
comment|/* 1 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|46
block|,
comment|/* Z */
literal|32
block|,
comment|/* S */
literal|31
block|,
comment|/* A */
literal|18
block|,
comment|/* W */
literal|3
block|,
comment|/* 2 */
literal|0
block|,
literal|0
block|,
literal|48
block|,
comment|/* C */
literal|47
block|,
comment|/* X */
literal|33
block|,
comment|/* D */
literal|19
block|,
comment|/* E */
literal|5
block|,
comment|/* 4 */
literal|4
block|,
comment|/* 3 */
literal|0
block|,
literal|0
block|,
literal|61
block|,
comment|/* SPACE */
literal|49
block|,
comment|/* V */
literal|34
block|,
comment|/* F */
literal|21
block|,
comment|/* T */
literal|20
block|,
comment|/* R */
literal|6
block|,
comment|/* 5 */
literal|0
block|,
literal|0
block|,
literal|51
block|,
comment|/* N */
literal|50
block|,
comment|/* B */
literal|36
block|,
comment|/* H */
literal|35
block|,
comment|/* G */
literal|22
block|,
comment|/* Y */
literal|7
block|,
comment|/* 6 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|52
block|,
comment|/* M */
literal|37
block|,
comment|/* J */
literal|23
block|,
comment|/* U */
literal|8
block|,
comment|/* 7 */
literal|9
block|,
comment|/* 8 */
literal|0
block|,
literal|0
block|,
literal|53
block|,
comment|/* , */
literal|38
block|,
comment|/* K */
literal|24
block|,
comment|/* I */
literal|25
block|,
comment|/* O */
literal|11
block|,
comment|/* 0 */
literal|10
block|,
comment|/* 9 */
literal|0
block|,
literal|0
block|,
literal|54
block|,
comment|/* . */
literal|55
block|,
comment|/* / */
literal|39
block|,
comment|/* L */
literal|40
block|,
comment|/* ; */
literal|26
block|,
comment|/* P */
literal|12
block|,
comment|/* - */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|41
block|,
comment|/* " */
literal|0
block|,
literal|27
block|,
comment|/* [ */
literal|13
block|,
comment|/* + */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|57
block|,
comment|/* SHIFT (right) */
literal|43
block|,
comment|/* ENTER */
literal|28
block|,
comment|/* ] */
literal|0
block|,
literal|29
block|,
comment|/* \ */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|45
block|,
comment|/* na*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|15
block|,
comment|/* backspace */
literal|0
block|,
literal|0
block|,
comment|/* keypad */
literal|93
block|,
comment|/* 1 */
literal|0
block|,
literal|92
block|,
comment|/* 4 */
literal|91
block|,
comment|/* 7 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|99
block|,
comment|/* 0 */
literal|104
block|,
comment|/* . */
literal|98
block|,
comment|/* 2 */
literal|97
block|,
comment|/* 5 */
literal|102
block|,
comment|/* 6 */
literal|96
block|,
comment|/* 8 */
literal|110
block|,
comment|/* ESC */
literal|90
block|,
comment|/* Num Lock */
literal|122
block|,
comment|/* F11 */
literal|106
block|,
comment|/* + */
literal|103
block|,
comment|/* 3 */
literal|105
block|,
comment|/* - */
literal|100
block|,
comment|/* * */
literal|101
block|,
comment|/* 9 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|118
block|,
comment|/* F7 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|extscantokey
index|[]
init|=
block|{
literal|0
block|,
literal|120
block|,
comment|/* F9 */
literal|0
block|,
literal|116
block|,
comment|/* F5 */
literal|114
block|,
comment|/* F3 */
literal|112
block|,
comment|/* F1 */
literal|113
block|,
comment|/* F2 */
literal|123
block|,
comment|/* F12 */
literal|0
block|,
literal|121
block|,
comment|/* F10 */
literal|119
block|,
comment|/* F8 */
literal|117
block|,
comment|/* F6 */
literal|115
block|,
comment|/* F4 */
literal|16
block|,
comment|/* TAB */
literal|1
block|,
comment|/* ` */
literal|0
block|,
literal|0
block|,
literal|62
block|,
comment|/* ALT (right) */
literal|124
block|,
comment|/* Print Screen */
literal|0
block|,
literal|64
block|,
comment|/* CTRL (right) */
literal|17
block|,
comment|/* Q */
literal|2
block|,
comment|/* 1 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|46
block|,
comment|/* Z */
literal|32
block|,
comment|/* S */
literal|31
block|,
comment|/* A */
literal|18
block|,
comment|/* W */
literal|3
block|,
comment|/* 2 */
literal|0
block|,
literal|0
block|,
literal|48
block|,
comment|/* C */
literal|47
block|,
comment|/* X */
literal|33
block|,
comment|/* D */
literal|19
block|,
comment|/* E */
literal|5
block|,
comment|/* 4 */
literal|4
block|,
comment|/* 3 */
literal|0
block|,
literal|0
block|,
literal|61
block|,
comment|/* SPACE */
literal|49
block|,
comment|/* V */
literal|34
block|,
comment|/* F */
literal|21
block|,
comment|/* T */
literal|20
block|,
comment|/* R */
literal|6
block|,
comment|/* 5 */
literal|0
block|,
literal|0
block|,
literal|51
block|,
comment|/* N */
literal|50
block|,
comment|/* B */
literal|36
block|,
comment|/* H */
literal|35
block|,
comment|/* G */
literal|22
block|,
comment|/* Y */
literal|7
block|,
comment|/* 6 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|52
block|,
comment|/* M */
literal|37
block|,
comment|/* J */
literal|23
block|,
comment|/* U */
literal|8
block|,
comment|/* 7 */
literal|9
block|,
comment|/* 8 */
literal|0
block|,
literal|0
block|,
literal|53
block|,
comment|/* , */
literal|38
block|,
comment|/* K */
literal|24
block|,
comment|/* I */
literal|25
block|,
comment|/* O */
literal|11
block|,
comment|/* 0 */
literal|10
block|,
comment|/* 9 */
literal|0
block|,
literal|0
block|,
literal|54
block|,
comment|/* . */
literal|95
block|,
comment|/* / */
literal|39
block|,
comment|/* L */
literal|40
block|,
comment|/* ; */
literal|26
block|,
comment|/* P */
literal|12
block|,
comment|/* - */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|41
block|,
comment|/* " */
literal|0
block|,
literal|27
block|,
comment|/* [ */
literal|13
block|,
comment|/* + */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|57
block|,
comment|/* SHIFT (right) */
literal|108
block|,
comment|/* ENTER */
literal|28
block|,
comment|/* ] */
literal|0
block|,
literal|29
block|,
comment|/* \ */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|45
block|,
comment|/* na*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|15
block|,
comment|/* backspace */
literal|0
block|,
literal|0
block|,
comment|/* keypad */
literal|81
block|,
comment|/* end */
literal|0
block|,
literal|79
block|,
comment|/* left arrow */
literal|80
block|,
comment|/* home */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|75
block|,
comment|/* ins */
literal|76
block|,
comment|/* del */
literal|84
block|,
comment|/* down arrow */
literal|97
block|,
comment|/* 5 */
literal|89
block|,
comment|/* right arrow */
literal|83
block|,
comment|/* up arrow */
literal|110
block|,
comment|/* ESC */
literal|90
block|,
comment|/* Num Lock */
literal|122
block|,
comment|/* F11 */
literal|106
block|,
comment|/* + */
literal|86
block|,
comment|/* page down */
literal|105
block|,
comment|/* - */
literal|124
block|,
comment|/* print screen */
literal|85
block|,
comment|/* page up */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|118
block|,
comment|/* F7 */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CODE_SIZE
value|4
end_define

begin_comment
comment|/* Use a max of 4 for now... */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_short
name|type
decl_stmt|;
name|char
name|unshift
index|[
name|CODE_SIZE
index|]
decl_stmt|;
name|char
name|shift
index|[
name|CODE_SIZE
index|]
decl_stmt|;
name|char
name|ctrl
index|[
name|CODE_SIZE
index|]
decl_stmt|;
block|}
name|Scan_def
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SHIFT
value|0x0002
end_define

begin_comment
comment|/* keyboard shift */
end_comment

begin_define
define|#
directive|define
name|ALT
value|0x0004
end_define

begin_comment
comment|/* alternate shift -- alternate chars */
end_comment

begin_define
define|#
directive|define
name|NUM
value|0x0008
end_define

begin_comment
comment|/* numeric shift  cursors vs. numeric */
end_comment

begin_define
define|#
directive|define
name|CTL
value|0x0010
end_define

begin_comment
comment|/* control shift  -- allows ctl function */
end_comment

begin_define
define|#
directive|define
name|CAPS
value|0x0020
end_define

begin_comment
comment|/* caps shift -- swaps case of letter */
end_comment

begin_define
define|#
directive|define
name|ASCII
value|0x0040
end_define

begin_comment
comment|/* ascii code for this key */
end_comment

begin_define
define|#
directive|define
name|SCROLL
value|0x0080
end_define

begin_comment
comment|/* stop output */
end_comment

begin_define
define|#
directive|define
name|FUNC
value|0x0100
end_define

begin_comment
comment|/* function key */
end_comment

begin_define
define|#
directive|define
name|KP
value|0x0200
end_define

begin_comment
comment|/* Keypad keys */
end_comment

begin_define
define|#
directive|define
name|NONE
value|0x0400
end_define

begin_comment
comment|/* no function */
end_comment

begin_decl_stmt
specifier|static
name|Scan_def
name|scan_codes
index|[]
init|=
block|{
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 0 unused */
name|ASCII
block|,
literal|"\033"
block|,
literal|"\033"
block|,
literal|"\033"
block|,
comment|/* 1 ESCape */
name|ASCII
block|,
literal|"1"
block|,
literal|"!"
block|,
literal|"!"
block|,
comment|/* 2 1 */
name|ASCII
block|,
literal|"2"
block|,
literal|"@"
block|,
literal|"\000"
block|,
comment|/* 3 2 */
name|ASCII
block|,
literal|"3"
block|,
literal|"#"
block|,
literal|"#"
block|,
comment|/* 4 3 */
name|ASCII
block|,
literal|"4"
block|,
literal|"$"
block|,
literal|"$"
block|,
comment|/* 5 4 */
name|ASCII
block|,
literal|"5"
block|,
literal|"%"
block|,
literal|"%"
block|,
comment|/* 6 5 */
name|ASCII
block|,
literal|"6"
block|,
literal|"^"
block|,
literal|"\036"
block|,
comment|/* 7 6 */
name|ASCII
block|,
literal|"7"
block|,
literal|"&"
block|,
literal|"&"
block|,
comment|/* 8 7 */
name|ASCII
block|,
literal|"8"
block|,
literal|"*"
block|,
literal|"\010"
block|,
comment|/* 9 8 */
name|ASCII
block|,
literal|"9"
block|,
literal|"("
block|,
literal|"("
block|,
comment|/* 10 9 */
name|ASCII
block|,
literal|"0"
block|,
literal|")"
block|,
literal|")"
block|,
comment|/* 11 0 */
name|ASCII
block|,
literal|"-"
block|,
literal|"_"
block|,
literal|"\037"
block|,
comment|/* 12 - */
name|ASCII
block|,
literal|"="
block|,
literal|"+"
block|,
literal|"+"
block|,
comment|/* 13 = */
name|ASCII
block|,
literal|"\177"
block|,
literal|"\177"
block|,
literal|"\010"
block|,
comment|/* 14 backspace */
name|ASCII
block|,
literal|"\t"
block|,
literal|"\177\t"
block|,
literal|"\t"
block|,
comment|/* 15 tab */
name|ASCII
block|,
literal|"q"
block|,
literal|"Q"
block|,
literal|"\021"
block|,
comment|/* 16 q */
name|ASCII
block|,
literal|"w"
block|,
literal|"W"
block|,
literal|"\027"
block|,
comment|/* 17 w */
name|ASCII
block|,
literal|"e"
block|,
literal|"E"
block|,
literal|"\005"
block|,
comment|/* 18 e */
name|ASCII
block|,
literal|"r"
block|,
literal|"R"
block|,
literal|"\022"
block|,
comment|/* 19 r */
name|ASCII
block|,
literal|"t"
block|,
literal|"T"
block|,
literal|"\024"
block|,
comment|/* 20 t */
name|ASCII
block|,
literal|"y"
block|,
literal|"Y"
block|,
literal|"\031"
block|,
comment|/* 21 y */
name|ASCII
block|,
literal|"u"
block|,
literal|"U"
block|,
literal|"\025"
block|,
comment|/* 22 u */
name|ASCII
block|,
literal|"i"
block|,
literal|"I"
block|,
literal|"\011"
block|,
comment|/* 23 i */
name|ASCII
block|,
literal|"o"
block|,
literal|"O"
block|,
literal|"\017"
block|,
comment|/* 24 o */
name|ASCII
block|,
literal|"p"
block|,
literal|"P"
block|,
literal|"\020"
block|,
comment|/* 25 p */
name|ASCII
block|,
literal|"["
block|,
literal|"{"
block|,
literal|"\033"
block|,
comment|/* 26 [ */
name|ASCII
block|,
literal|"]"
block|,
literal|"}"
block|,
literal|"\035"
block|,
comment|/* 27 ] */
name|ASCII
block|,
literal|"\r"
block|,
literal|"\r"
block|,
literal|"\n"
block|,
comment|/* 28 return */
name|CTL
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 29 control */
name|ASCII
block|,
literal|"a"
block|,
literal|"A"
block|,
literal|"\001"
block|,
comment|/* 30 a */
name|ASCII
block|,
literal|"s"
block|,
literal|"S"
block|,
literal|"\023"
block|,
comment|/* 31 s */
name|ASCII
block|,
literal|"d"
block|,
literal|"D"
block|,
literal|"\004"
block|,
comment|/* 32 d */
name|ASCII
block|,
literal|"f"
block|,
literal|"F"
block|,
literal|"\006"
block|,
comment|/* 33 f */
name|ASCII
block|,
literal|"g"
block|,
literal|"G"
block|,
literal|"\007"
block|,
comment|/* 34 g */
name|ASCII
block|,
literal|"h"
block|,
literal|"H"
block|,
literal|"\010"
block|,
comment|/* 35 h */
name|ASCII
block|,
literal|"j"
block|,
literal|"J"
block|,
literal|"\n"
block|,
comment|/* 36 j */
name|ASCII
block|,
literal|"k"
block|,
literal|"K"
block|,
literal|"\013"
block|,
comment|/* 37 k */
name|ASCII
block|,
literal|"l"
block|,
literal|"L"
block|,
literal|"\014"
block|,
comment|/* 38 l */
name|ASCII
block|,
literal|";"
block|,
literal|":"
block|,
literal|";"
block|,
comment|/* 39 ; */
name|ASCII
block|,
literal|"'"
block|,
literal|"\""
block|,
literal|"'"
block|,
comment|/* 40 ' */
name|ASCII
block|,
literal|"`"
block|,
literal|"~"
block|,
literal|"`"
block|,
comment|/* 41 ` */
name|SHIFT
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 42 shift */
name|ASCII
block|,
literal|"\\"
block|,
literal|"|"
block|,
literal|"\034"
block|,
comment|/* 43 \ */
name|ASCII
block|,
literal|"z"
block|,
literal|"Z"
block|,
literal|"\032"
block|,
comment|/* 44 z */
name|ASCII
block|,
literal|"x"
block|,
literal|"X"
block|,
literal|"\030"
block|,
comment|/* 45 x */
name|ASCII
block|,
literal|"c"
block|,
literal|"C"
block|,
literal|"\003"
block|,
comment|/* 46 c */
name|ASCII
block|,
literal|"v"
block|,
literal|"V"
block|,
literal|"\026"
block|,
comment|/* 47 v */
name|ASCII
block|,
literal|"b"
block|,
literal|"B"
block|,
literal|"\002"
block|,
comment|/* 48 b */
name|ASCII
block|,
literal|"n"
block|,
literal|"N"
block|,
literal|"\016"
block|,
comment|/* 49 n */
name|ASCII
block|,
literal|"m"
block|,
literal|"M"
block|,
literal|"\r"
block|,
comment|/* 50 m */
name|ASCII
block|,
literal|","
block|,
literal|"<"
block|,
literal|"<"
block|,
comment|/* 51 , */
name|ASCII
block|,
literal|"."
block|,
literal|">"
block|,
literal|">"
block|,
comment|/* 52 . */
name|ASCII
block|,
literal|"/"
block|,
literal|"?"
block|,
literal|"\177"
block|,
comment|/* 53 / */
name|SHIFT
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 54 shift */
name|KP
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"*"
block|,
comment|/* 55 kp * */
name|ALT
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 56 alt */
name|ASCII
block|,
literal|" "
block|,
literal|" "
block|,
literal|" "
block|,
comment|/* 57 space */
name|CAPS
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 58 caps */
name|FUNC
block|,
literal|"\033[M"
block|,
literal|"\033[Y"
block|,
literal|"\033[k"
block|,
comment|/* 59 f1 */
name|FUNC
block|,
literal|"\033[N"
block|,
literal|"\033[Z"
block|,
literal|"\033[l"
block|,
comment|/* 60 f2 */
name|FUNC
block|,
literal|"\033[O"
block|,
literal|"\033[a"
block|,
literal|"\033[m"
block|,
comment|/* 61 f3 */
name|FUNC
block|,
literal|"\033[P"
block|,
literal|"\033[b"
block|,
literal|"\033[n"
block|,
comment|/* 62 f4 */
name|FUNC
block|,
literal|"\033[Q"
block|,
literal|"\033[c"
block|,
literal|"\033[o"
block|,
comment|/* 63 f5 */
name|FUNC
block|,
literal|"\033[R"
block|,
literal|"\033[d"
block|,
literal|"\033[p"
block|,
comment|/* 64 f6 */
name|FUNC
block|,
literal|"\033[S"
block|,
literal|"\033[e"
block|,
literal|"\033[q"
block|,
comment|/* 65 f7 */
name|FUNC
block|,
literal|"\033[T"
block|,
literal|"\033[f"
block|,
literal|"\033[r"
block|,
comment|/* 66 f8 */
name|FUNC
block|,
literal|"\033[U"
block|,
literal|"\033[g"
block|,
literal|"\033[s"
block|,
comment|/* 67 f9 */
name|FUNC
block|,
literal|"\033[V"
block|,
literal|"\033[h"
block|,
literal|"\033[t"
block|,
comment|/* 68 f10 */
name|NUM
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 69 num lock */
name|SCROLL
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 70 scroll lock */
name|KP
block|,
literal|"7"
block|,
literal|"\033[H"
block|,
literal|"7"
block|,
comment|/* 71 kp 7 */
name|KP
block|,
literal|"8"
block|,
literal|"\033[A"
block|,
literal|"8"
block|,
comment|/* 72 kp 8 */
name|KP
block|,
literal|"9"
block|,
literal|"\033[I"
block|,
literal|"9"
block|,
comment|/* 73 kp 9 */
name|KP
block|,
literal|"-"
block|,
literal|"-"
block|,
literal|"-"
block|,
comment|/* 74 kp - */
name|KP
block|,
literal|"4"
block|,
literal|"\033[D"
block|,
literal|"4"
block|,
comment|/* 75 kp 4 */
name|KP
block|,
literal|"5"
block|,
literal|"\033[E"
block|,
literal|"5"
block|,
comment|/* 76 kp 5 */
name|KP
block|,
literal|"6"
block|,
literal|"\033[C"
block|,
literal|"6"
block|,
comment|/* 77 kp 6 */
name|KP
block|,
literal|"+"
block|,
literal|"+"
block|,
literal|"+"
block|,
comment|/* 78 kp + */
name|KP
block|,
literal|"1"
block|,
literal|"\033[F"
block|,
literal|"1"
block|,
comment|/* 79 kp 1 */
name|KP
block|,
literal|"2"
block|,
literal|"\033[B"
block|,
literal|"2"
block|,
comment|/* 80 kp 2 */
name|KP
block|,
literal|"3"
block|,
literal|"\033[G"
block|,
literal|"3"
block|,
comment|/* 81 kp 3 */
name|KP
block|,
literal|"0"
block|,
literal|"\033[L"
block|,
literal|"0"
block|,
comment|/* 82 kp 0 */
name|KP
block|,
literal|"."
block|,
literal|"\177"
block|,
literal|"."
block|,
comment|/* 83 kp . */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 84 0 */
name|NONE
block|,
literal|"100"
block|,
literal|""
block|,
literal|""
block|,
comment|/* 85 0 */
name|NONE
block|,
literal|"101"
block|,
literal|""
block|,
literal|""
block|,
comment|/* 86 0 */
name|FUNC
block|,
literal|"\033[W"
block|,
literal|"\033[i"
block|,
literal|"\033[u"
block|,
comment|/* 87 f11 */
name|FUNC
block|,
literal|"\033[X"
block|,
literal|"\033[j"
block|,
literal|"\033[v"
block|,
comment|/* 88 f12 */
name|NONE
block|,
literal|"102"
block|,
literal|""
block|,
literal|""
block|,
comment|/* 89 0 */
name|NONE
block|,
literal|"103"
block|,
literal|""
block|,
literal|""
block|,
comment|/* 90 0 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 91 0 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 92 0 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 93 0 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 94 0 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 95 0 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 96 0 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 97 0 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 98 0 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 99 0 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 100 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 101 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 102 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 103 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 104 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 105 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 106 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 107 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 108 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 109 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 110 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 111 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 112 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 113 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 114 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 115 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 116 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 117 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 118 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 119 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 120 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 121 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 122 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 123 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 124 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 125 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 126 */
name|NONE
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
comment|/* 127 */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|update_led
parameter_list|()
block|{
name|int
name|response
decl_stmt|;
if|if
condition|(
name|kbd_cmd
argument_list|(
name|KBC_STSIND
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Timeout for keyboard LED command\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * XXX This is quite questionable, but seems to fix 		 * the problem reported. 		 * some keyboard controllers need some time after they 		 * get a command.  Without this the keyboard 'hangs'. 		 * This seems to be the only place where two commands 		 * are just one behind another.  		 */
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbd_cmd
argument_list|(
name|scroll
operator||
operator|(
name|num
operator|<<
literal|1
operator|)
operator||
operator|(
name|caps
operator|<<
literal|2
operator|)
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Timeout for keyboard LED data\n"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|else if ((response = kbd_response())< 0) 		printf("Timeout for keyboard LED ack\n"); 	else if (response != KBR_ACK) 		printf("Unexpected keyboard LED ack %d\n", response);
else|#
directive|else
comment|/* 	 * Skip waiting for and checking the response.  The waiting 	 * would be too long (about 3 msec) and the checking might eat 	 * fresh keystrokes.  The waiting should be done using timeout() 	 * and the checking should be done in the interrupt handler. 	 */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *   sgetc(noblock):  get  characters  from  the  keyboard.  If  *   noblock  ==  0  wait  until a key is gotten. Otherwise return a  *    if no characters are present 0.  */
end_comment

begin_function
name|char
modifier|*
name|sgetc
parameter_list|(
name|noblock
parameter_list|)
name|int
name|noblock
decl_stmt|;
block|{
name|u_char
name|dt
decl_stmt|;
name|unsigned
name|key
decl_stmt|;
specifier|static
name|u_char
name|extended
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|capchar
index|[
literal|2
index|]
decl_stmt|;
comment|/* 	 *   First see if there is something in the keyboard port 	 */
name|loop
label|:
ifdef|#
directive|ifdef
name|XSERVER
comment|/* 15 Aug 92*/
if|if
condition|(
name|inb
argument_list|(
name|KBSTATP
argument_list|)
operator|&
name|KBS_DIB
condition|)
block|{
name|dt
operator|=
name|inb
argument_list|(
name|KBDATAP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REVERSE_CAPS_CTRL
comment|/* switch the caps lock and control keys */
if|if
condition|(
operator|(
name|dt
operator|&
literal|0x7f
operator|)
operator|==
literal|29
condition|)
name|dt
operator|=
operator|(
name|dt
operator|&
literal|0x80
operator|)
operator||
literal|58
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dt
operator|&
literal|0x7f
operator|)
operator|==
literal|58
condition|)
name|dt
operator|=
operator|(
name|dt
operator|&
literal|0x80
operator|)
operator||
literal|29
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pc_xmode
condition|)
block|{
name|capchar
index|[
literal|0
index|]
operator|=
name|dt
expr_stmt|;
comment|/* 			 *   Check for locking keys 			 */
if|if
condition|(
operator|!
operator|(
name|dt
operator|&
literal|0x80
operator|)
condition|)
block|{
name|dt
operator|=
name|dt
operator|&
literal|0x7f
expr_stmt|;
switch|switch
condition|(
name|scan_codes
index|[
name|dt
index|]
operator|.
name|type
condition|)
block|{
case|case
name|NUM
case|:
name|num
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
break|break;
case|case
name|CAPS
case|:
name|caps
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
break|break;
case|case
name|SCROLL
case|:
name|scroll
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
operator|&
name|capchar
index|[
literal|0
index|]
operator|)
return|;
block|}
block|}
else|#
directive|else
comment|/* !XSERVER*/
if|if
condition|(
name|inb
argument_list|(
name|KBSTATP
argument_list|)
operator|&
name|KBS_DIB
condition|)
block|{
name|dt
operator|=
name|inb
argument_list|(
name|KBDATAP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REVERSE_CAPS_CTRL
comment|/* switch the caps lock and control keys */
if|if
condition|(
operator|(
name|dt
operator|&
literal|0x7f
operator|)
operator|==
literal|29
condition|)
name|dt
operator|=
operator|(
name|dt
operator|&
literal|0x80
operator|)
operator||
literal|58
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dt
operator|&
literal|0x7f
operator|)
operator|==
literal|58
condition|)
name|dt
operator|=
operator|(
name|dt
operator|&
literal|0x80
operator|)
operator||
literal|29
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* !XSERVER*/
else|else
block|{
if|if
condition|(
name|noblock
condition|)
return|return
literal|0
return|;
else|else
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|dt
operator|==
literal|0xe0
condition|)
block|{
name|extended
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|XSERVER
comment|/* 15 Aug 92*/
goto|goto
name|loop
goto|;
else|#
directive|else
comment|/* !XSERVER*/
if|if
condition|(
name|noblock
condition|)
return|return
literal|0
return|;
else|else
goto|goto
name|loop
goto|;
endif|#
directive|endif
comment|/* !XSERVER*/
block|}
include|#
directive|include
file|"ddb.h"
if|#
directive|if
name|NDDB
operator|>
literal|0
comment|/* 	 *   Check for cntl-alt-esc 	 */
if|if
condition|(
operator|(
name|dt
operator|==
literal|1
operator|)
operator|&&
name|ctrl_down
operator|&&
name|alt_down
condition|)
block|{
name|Debugger
argument_list|(
literal|"manual escape to debugger"
argument_list|)
expr_stmt|;
name|dt
operator||=
literal|0x80
expr_stmt|;
comment|/* discard esc (ddb discarded ctrl-alt) */
block|}
endif|#
directive|endif
comment|/* 	 *   Check for make/break 	 */
if|if
condition|(
name|dt
operator|&
literal|0x80
condition|)
block|{
comment|/* 		 *   break 		 */
name|dt
operator|=
name|dt
operator|&
literal|0x7f
expr_stmt|;
switch|switch
condition|(
name|scan_codes
index|[
name|dt
index|]
operator|.
name|type
condition|)
block|{
case|case
name|SHIFT
case|:
name|shift_down
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ALT
case|:
name|alt_down
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CTL
case|:
name|ctrl_down
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 		 *   Make 		 */
name|dt
operator|=
name|dt
operator|&
literal|0x7f
expr_stmt|;
switch|switch
condition|(
name|scan_codes
index|[
name|dt
index|]
operator|.
name|type
condition|)
block|{
comment|/* 			 *   Locking keys 			 */
case|case
name|NUM
case|:
name|num
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
break|break;
case|case
name|CAPS
case|:
name|caps
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
break|break;
case|case
name|SCROLL
case|:
name|scroll
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
break|break;
comment|/* 			 *   Non-locking keys 			 */
case|case
name|SHIFT
case|:
name|shift_down
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ALT
case|:
name|alt_down
operator|=
literal|0x80
expr_stmt|;
break|break;
case|case
name|CTL
case|:
name|ctrl_down
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ASCII
case|:
ifdef|#
directive|ifdef
name|XSERVER
comment|/* 15 Aug 92*/
comment|/*  * 18 Sep 92	Terry Lambert	I find that this behaviour is questionable --  *				I believe that this should be conditional on  *				the value of pc_xmode rather than always  *				done.  In particular, "case NONE" seems to  *				not cause a scancode return.  This may  *				invalidate alt-"=" and alt-"-" as well as the  *				F11 and F12 keys, and some keys on lap-tops,  *				Especially Toshibal T1100 and Epson Equity 1  *				and Equity 1+ when not in pc_xmode.  */
comment|/* control has highest priority */
if|if
condition|(
name|ctrl_down
condition|)
name|capchar
index|[
literal|0
index|]
operator|=
name|scan_codes
index|[
name|dt
index|]
operator|.
name|ctrl
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|shift_down
condition|)
name|capchar
index|[
literal|0
index|]
operator|=
name|scan_codes
index|[
name|dt
index|]
operator|.
name|shift
index|[
literal|0
index|]
expr_stmt|;
else|else
name|capchar
index|[
literal|0
index|]
operator|=
name|scan_codes
index|[
name|dt
index|]
operator|.
name|unshift
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|caps
operator|&&
operator|(
name|capchar
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|capchar
index|[
literal|0
index|]
operator|<=
literal|'z'
operator|)
condition|)
block|{
name|capchar
index|[
literal|0
index|]
operator|=
name|capchar
index|[
literal|0
index|]
operator|-
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
block|}
name|capchar
index|[
literal|0
index|]
operator||=
name|alt_down
expr_stmt|;
name|extended
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|&
name|capchar
index|[
literal|0
index|]
operator|)
return|;
else|#
directive|else
comment|/* !XSERVER*/
case|case
name|NONE
case|:
endif|#
directive|endif
comment|/* !XSERVER*/
case|case
name|FUNC
case|:
if|if
condition|(
name|shift_down
condition|)
name|more_chars
operator|=
name|scan_codes
index|[
name|dt
index|]
operator|.
name|shift
expr_stmt|;
elseif|else
if|if
condition|(
name|ctrl_down
condition|)
name|more_chars
operator|=
name|scan_codes
index|[
name|dt
index|]
operator|.
name|ctrl
expr_stmt|;
else|else
name|more_chars
operator|=
name|scan_codes
index|[
name|dt
index|]
operator|.
name|unshift
expr_stmt|;
ifndef|#
directive|ifndef
name|XSERVER
comment|/* 15 Aug 92*/
comment|/* XXX */
if|if
condition|(
name|caps
operator|&&
name|more_chars
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
operator|(
name|more_chars
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|more_chars
index|[
literal|0
index|]
operator|<=
literal|'z'
operator|)
condition|)
block|{
name|capchar
index|[
literal|0
index|]
operator|=
operator|*
name|more_chars
operator|-
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
name|more_chars
operator|=
name|capchar
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !XSERVER*/
name|extended
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|more_chars
operator|)
return|;
case|case
name|KP
case|:
if|if
condition|(
name|shift_down
operator|||
name|ctrl_down
operator|||
operator|!
name|num
operator|||
name|extended
condition|)
name|more_chars
operator|=
name|scan_codes
index|[
name|dt
index|]
operator|.
name|shift
expr_stmt|;
else|else
name|more_chars
operator|=
name|scan_codes
index|[
name|dt
index|]
operator|.
name|unshift
expr_stmt|;
name|extended
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|more_chars
operator|)
return|;
ifdef|#
directive|ifdef
name|XSERVER
comment|/* 15 Aug 92*/
case|case
name|NONE
case|:
break|break;
endif|#
directive|endif
comment|/* XSERVER*/
block|}
block|}
name|extended
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|XSERVER
comment|/* 15 Aug 92*/
goto|goto
name|loop
goto|;
else|#
directive|else
comment|/* !XSERVER*/
if|if
condition|(
name|noblock
condition|)
return|return
literal|0
return|;
else|else
goto|goto
name|loop
goto|;
endif|#
directive|endif
comment|/* !XSERVER*/
block|}
end_function

begin_comment
comment|/* special characters */
end_comment

begin_define
define|#
directive|define
name|bs
value|8
end_define

begin_define
define|#
directive|define
name|lf
value|10
end_define

begin_define
define|#
directive|define
name|cr
value|13
end_define

begin_define
define|#
directive|define
name|cntlc
value|3
end_define

begin_define
define|#
directive|define
name|del
value|0177
end_define

begin_define
define|#
directive|define
name|cntld
value|4
end_define

begin_function
name|int
name|getchar
parameter_list|()
block|{
name|char
name|thechar
decl_stmt|;
specifier|register
name|delay
expr_stmt|;
name|int
name|x
decl_stmt|;
name|pcconsoftc
operator|.
name|cs_flags
operator||=
name|CSF_POLLING
expr_stmt|;
name|x
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|sput
argument_list|(
literal|'>'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*while (1) {*/
name|thechar
operator|=
operator|*
operator|(
name|sgetc
argument_list|(
literal|0
argument_list|)
operator|)
expr_stmt|;
name|pcconsoftc
operator|.
name|cs_flags
operator|&=
operator|~
name|CSF_POLLING
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|thechar
condition|)
block|{
default|default:
if|if
condition|(
name|thechar
operator|>=
literal|' '
condition|)
name|sput
argument_list|(
name|thechar
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|thechar
operator|)
return|;
case|case
name|cr
case|:
case|case
name|lf
case|:
name|sput
argument_list|(
literal|'\r'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sput
argument_list|(
literal|'\n'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|lf
operator|)
return|;
case|case
name|bs
case|:
case|case
name|del
case|:
name|sput
argument_list|(
literal|'\b'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sput
argument_list|(
literal|' '
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sput
argument_list|(
literal|'\b'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|thechar
operator|)
return|;
case|case
name|cntlc
case|:
name|sput
argument_list|(
literal|'^'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sput
argument_list|(
literal|'C'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sput
argument_list|(
literal|'\r'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sput
argument_list|(
literal|'\n'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cpu_reset
argument_list|()
expr_stmt|;
case|case
name|cntld
case|:
name|sput
argument_list|(
literal|'^'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sput
argument_list|(
literal|'D'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sput
argument_list|(
literal|'\r'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sput
argument_list|(
literal|'\n'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*}*/
block|}
end_function

begin_include
include|#
directive|include
file|"machine/stdarg.h"
end_include

begin_expr_stmt
specifier|static
name|nrow
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DPAUSE
value|1
end_define

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|dprintf
parameter_list|(
name|unsigned
name|flgs
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|dprintf
parameter_list|(
name|flgs
parameter_list|,
name|fmt
comment|/*, va_alist */
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|unsigned
name|flgs
decl_stmt|;
endif|#
directive|endif
block|{
specifier|extern
name|unsigned
name|__debug
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|(
name|flgs
operator|&
name|__debug
operator|)
operator|>
name|DPAUSE
condition|)
block|{
name|__color
operator|=
name|ffs
argument_list|(
name|flgs
operator|&
name|__debug
argument_list|)
operator|+
literal|1
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|kprintf
argument_list|(
name|fmt
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|tty
operator|*
operator|)
literal|0
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|flgs
operator|&
name|DPAUSE
operator|||
name|nrow
operator|%
literal|24
operator|==
literal|23
condition|)
block|{
name|int
name|x
decl_stmt|;
name|x
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|nrow
operator|%
literal|24
operator|==
literal|23
condition|)
name|nrow
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sgetc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
name|__color
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|consinit
parameter_list|()
block|{}
end_function

begin_comment
comment|/* -hv- 22-Apr-93: to make init_main more portable */
end_comment

begin_function
name|void
name|cons_highlight
parameter_list|()
block|{
comment|/* pc text attribute */
name|vs
operator|.
name|kern_fg_at
operator|=
literal|0x0f
expr_stmt|;
name|vs
operator|.
name|kern_bg_at
operator|=
literal|0x00
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cons_normal
parameter_list|()
block|{
comment|/* reset to normal attributes */
name|vs
operator|.
name|bg_at
operator|=
name|BG_BLACK
expr_stmt|;
comment|/* we are in kernel mode */
name|vs
operator|.
name|fg_at
operator|=
name|vs
operator|.
name|color
condition|?
name|FG_LIGHTGREY
else|:
name|FG_UNDERLINE
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcmmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|>
literal|0x20000
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i386_btop
argument_list|(
operator|(
literal|0xa0000
operator|+
name|offset
operator|)
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XSERVER
end_ifdef

begin_comment
comment|/* 15 Aug 92*/
end_comment

begin_include
include|#
directive|include
file|"machine/psl.h"
end_include

begin_include
include|#
directive|include
file|"machine/frame.h"
end_include

begin_function
specifier|static
name|void
name|pc_xmode_on
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|trapframe
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|pc_xmode
condition|)
return|return;
name|pc_xmode
operator|=
literal|1
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
name|curproc
operator|->
name|p_regs
expr_stmt|;
name|fp
operator|->
name|tf_eflags
operator||=
name|PSL_IOPL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pc_xmode_off
parameter_list|()
block|{
name|struct
name|trapframe
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|pc_xmode
operator|==
literal|0
condition|)
return|return;
name|pc_xmode
operator|=
literal|0
expr_stmt|;
name|cursor
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
name|curproc
operator|->
name|p_regs
expr_stmt|;
name|fp
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_IOPL
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XSERVER*/
end_comment

begin_comment
comment|/*  * EOF -- File has not been truncated  */
end_comment

end_unit

