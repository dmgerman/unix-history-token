begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * snd/sound.c  *   * Main sound driver for FreeBSD. This file provides the main  * entry points for probe/attach and all i/o demultiplexing, including  * default routines for generic devices.  *   * (C) 1997 Luigi Rizzo (luigi@iet.unipi.it)  *   * Redistribution and use in source and binary forms, with or  * without modification, are permitted provided that the following  * conditions are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above  *    copyright notice, this list of conditions and the following  *    disclaimer in the documentation and/or other materials provided  *    with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS  * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE  * AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * For each card type a template "snddev_info" structure contains  * all the relevant parameters, both for configuration and runtime.  *  * In this file we build tables of pointers to the descriptors for  * the various supported cards. The generic probe routine scans  * the table(s) looking for a matching entry, then invokes the  * board-specific probe routine. If successful, a pointer to the  * correct snddev_info is stored in snddev_last_probed, for subsequent  * use in the attach routine. The generic attach routine copies  * the template to a permanent descriptor (pcm_info[unit] and  * friends), initializes all generic parameters, and calls the  * board-specific attach routine.  *  * On device calls, the generic routines do the checks on unit and  * device parameters, then call the board-specific routines if  * available, or try to perform the task using the default code.  *  */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/snd/sound.h>
end_include

begin_if
if|#
directive|if
name|NPCM
operator|>
literal|0
end_if

begin_comment
comment|/* from "snd.h" */
end_comment

begin_define
define|#
directive|define
name|SNDSTAT_BUF_SIZE
value|4000
end_define

begin_decl_stmt
specifier|static
name|char
name|status_buf
index|[
name|SNDSTAT_BUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|status_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|init_status
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|sndopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|sndclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|sndioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|sndread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|sndwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|sndmmap
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|30
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|snd_cdevsw
init|=
block|{
name|sndopen
block|,
name|sndclose
block|,
name|sndread
block|,
name|sndwrite
block|,
name|sndioctl
block|,
name|nxstop
block|,
name|nxreset
block|,
name|nxdevtotty
block|,
name|sndpoll
block|,
name|sndmmap
block|,
name|nxstrategy
block|,
literal|"snd"
block|,
name|NULL
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * descriptors for active devices.  *  */
end_comment

begin_decl_stmt
name|snddev_info
name|pcm_info
index|[
name|NPCM_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|snddev_info
name|midi_info
index|[
name|NPCM_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|snddev_info
name|synth_info
index|[
name|NPCM_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|nsnd
init|=
name|NPCM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of sound devices */
end_comment

begin_comment
comment|/*  * the probe routine can only return an int to the upper layer. Hence,  * it leaves the pointer to the last successfully  * probed device descriptor in snddev_last_probed  */
end_comment

begin_decl_stmt
name|snddev_info
modifier|*
name|snddev_last_probed
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|snddev_info
modifier|*
name|generic_snd_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|snddev_info
modifier|*
modifier|*
name|p
index|[]
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * here are the lists of known cards. Similar cards (e.g. all  * sb clones, all mss clones, ... are in the same array.  * All lists of devices of the same type (eg. all pcm, all midi...)  * are in the same array.  * Each probe for a device type gets the pointer to the main array  * and then scans the sublists.  *  * XXX should use DATA_SET to create a linker set for sb_devs and other  * such structures.  */
end_comment

begin_decl_stmt
specifier|extern
name|snddev_info
name|sb_op_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|snddev_info
name|mss_op_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|snddev_info
modifier|*
name|sb_devs
index|[]
init|=
block|{
comment|/* all SB clones	 */
operator|&
name|sb_op_desc
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|snddev_info
modifier|*
name|mss_devs
index|[]
init|=
block|{
comment|/* all WSS clones	*/
operator|&
name|mss_op_desc
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|snddev_info
modifier|*
modifier|*
name|pcm_devslist
index|[]
init|=
block|{
comment|/* all pcm devices	*/
name|mss_devs
block|,
name|sb_devs
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pcmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|pcm_info
index|[
name|dev
operator|->
name|id_unit
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|pcm_info
index|[
name|dev
operator|->
name|id_unit
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|generic_snd_probe
argument_list|(
name|dev
argument_list|,
name|pcm_devslist
argument_list|,
literal|"pcm"
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|snddev_info
modifier|*
modifier|*
name|midi_devslist
index|[]
init|=
block|{
comment|/* all midi devices	*/
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|midiprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|midi_info
index|[
name|dev
operator|->
name|id_unit
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|midi_info
index|[
name|dev
operator|->
name|id_unit
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
return|return
name|generic_snd_probe
argument_list|(
name|dev
argument_list|,
name|midi_devslist
argument_list|,
literal|"midi"
argument_list|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|synthprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|synth_info
index|[
name|dev
operator|->
name|id_unit
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|synth_info
index|[
name|dev
operator|->
name|id_unit
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * this is the generic attach routine  */
end_comment

begin_function
name|int
name|pcmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|snddev_info
modifier|*
name|d
init|=
name|NULL
decl_stmt|;
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
name|int
name|stat
init|=
literal|0
decl_stmt|;
name|dev_t
name|isadev
decl_stmt|;
if|if
condition|(
operator|(
name|dev
operator|->
name|id_unit
operator|>=
name|NPCM_MAX
operator|)
operator|||
comment|/* too many devs	*/
operator|(
name|snddev_last_probed
operator|==
name|NULL
operator|)
operator|||
comment|/* last probe failed	*/
operator|(
name|snddev_last_probed
operator|->
name|attach
operator|==
name|NULL
operator|)
condition|)
comment|/* no attach routine	*/
return|return
literal|0
return|;
comment|/* fail */
comment|/*      * default initialization: copy generic parameters for the routine,      * initialize from the isa_device structure, and allocate memory.      * If everything succeeds, then call the attach routine for      * further initialization.      */
name|pcm_info
index|[
name|dev
operator|->
name|id_unit
index|]
operator|=
operator|*
name|snddev_last_probed
expr_stmt|;
name|d
operator|=
operator|&
name|pcm_info
index|[
name|dev
operator|->
name|id_unit
index|]
expr_stmt|;
name|d
operator|->
name|io_base
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
name|d
operator|->
name|irq
operator|=
name|ffs
argument_list|(
name|dev
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|dma1
operator|=
name|dev
operator|->
name|id_drq
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_flags
operator|!=
operator|-
literal|1
operator|&&
name|dev
operator|->
name|id_flags
operator|&
name|DV_F_DUAL_DMA
condition|)
comment|/* enable dma2 */
name|d
operator|->
name|dma2
operator|=
name|dev
operator|->
name|id_flags
operator|&
name|DV_F_DRQ_MASK
expr_stmt|;
else|else
name|d
operator|->
name|dma2
operator|=
name|d
operator|->
name|dma1
expr_stmt|;
comment|/* XXX should also set bd_id from flags ? */
name|d
operator|->
name|status_ptr
operator|=
literal|0
expr_stmt|;
comment|/*      * Allocates memory and initializes the dma structs properly. We      * use independent buffers for each channel.  For the time being,      * this is done independently of the dma setting. In future      * revisions, if we see that we have a single dma, we might decide      * to use a single buffer to save memory.      */
name|alloc_dbuf
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
argument_list|,
name|d
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|alloc_dbuf
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
argument_list|,
name|d
operator|->
name|bufsize
argument_list|)
expr_stmt|;
name|isa_dma_acquire
argument_list|(
name|d
operator|->
name|dma1
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dma2
operator|!=
name|d
operator|->
name|dma1
condition|)
name|isa_dma_acquire
argument_list|(
name|d
operator|->
name|dma2
argument_list|)
expr_stmt|;
comment|/*      * initialize standard parameters for the device. This can be      * overridden by device-specific configurations but better do      * here the generic things.      */
name|d
operator|->
name|play_speed
operator|=
name|d
operator|->
name|rec_speed
operator|=
literal|8000
expr_stmt|;
name|d
operator|->
name|play_blocksize
operator|=
name|d
operator|->
name|rec_blocksize
operator|=
literal|2048
expr_stmt|;
name|d
operator|->
name|play_fmt
operator|=
name|d
operator|->
name|rec_fmt
operator|=
name|AFMT_MU_LAW
expr_stmt|;
name|isadev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|isadev
argument_list|,
operator|&
name|snd_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*      * should try and find a suitable value for id_id, otherwise      * the interrupt is not registered and dispatched properly.      * This is important for PnP devices, where "dev" is built on      * the fly and many field are not initialized.      */
if|if
condition|(
name|dev
operator|->
name|id_driver
operator|==
name|NULL
condition|)
block|{
name|dev
operator|->
name|id_driver
operator|=
operator|&
name|pcmdriver
expr_stmt|;
name|dvp
operator|=
name|find_isadev
argument_list|(
name|isa_devtab_tty
argument_list|,
operator|&
name|pcmdriver
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
condition|)
name|dev
operator|->
name|id_id
operator|=
name|dvp
operator|->
name|id_id
expr_stmt|;
block|}
name|d
operator|->
name|magic
operator|=
name|MAGIC
argument_list|(
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
comment|/* debugging... */
comment|/*      * and finally, call the device attach routine      */
name|stat
operator|=
name|snddev_last_probed
operator|->
name|attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|snddev_last_probed
operator|=
name|NULL
expr_stmt|;
return|return
name|stat
return|;
block|}
end_function

begin_function
name|int
name|midiattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|synthattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|isa_driver
name|pcmdriver
init|=
block|{
name|pcmprobe
block|,
name|pcmattach
block|,
literal|"pcm"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|mididriver
init|=
block|{
name|midiprobe
block|,
name|midiattach
block|,
literal|"midi"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|synthdriver
init|=
block|{
name|synthprobe
block|,
name|synthattach
block|,
literal|"synth"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pcmintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"__/\\/ pcmintr -- unit %d\n"
argument_list|,
name|unit
argument_list|)
argument_list|)
expr_stmt|;
name|pcm_info
index|[
name|unit
index|]
operator|.
name|interrupts
operator|++
expr_stmt|;
if|if
condition|(
name|pcm_info
index|[
name|unit
index|]
operator|.
name|isr
condition|)
name|pcm_info
index|[
name|unit
index|]
operator|.
name|isr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|midi_info
index|[
name|unit
index|]
operator|.
name|isr
condition|)
name|midi_info
index|[
name|unit
index|]
operator|.
name|isr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|synth_info
index|[
name|unit
index|]
operator|.
name|isr
condition|)
name|synth_info
index|[
name|unit
index|]
operator|.
name|isr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|snddev_info
modifier|*
name|generic_snd_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|,
name|snddev_info
modifier|*
modifier|*
name|p
index|[]
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|snddev_info
modifier|*
modifier|*
name|q
decl_stmt|;
name|struct
name|isa_device
name|saved_dev
decl_stmt|;
name|snddev_last_probed
operator|=
name|NULL
expr_stmt|;
name|saved_dev
operator|=
operator|*
name|dev
expr_stmt|;
comment|/* the probe routine might alter parameters */
comment|/*      * XXX todo: should try to match flags with device type.      */
for|for
control|(
init|;
name|p
index|[
literal|0
index|]
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
for|for
control|(
name|q
operator|=
operator|*
name|p
init|;
name|q
index|[
literal|0
index|]
condition|;
name|q
operator|++
control|)
if|if
condition|(
name|q
index|[
literal|0
index|]
operator|->
name|probe
operator|&&
name|q
index|[
literal|0
index|]
operator|->
name|probe
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|snddev_last_probed
operator|=
name|q
index|[
literal|0
index|]
operator|)
return|;
else|else
operator|*
name|dev
operator|=
name|saved_dev
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * a small utility function which, given a device number, returns  * a pointer to the associated snddev_info struct, and sets the unit  * number.  */
end_comment

begin_function
specifier|static
name|snddev_info
modifier|*
name|get_snddev_info
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
modifier|*
name|unit
parameter_list|)
block|{
name|int
name|u
decl_stmt|;
name|snddev_info
modifier|*
name|d
init|=
name|NULL
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|u
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|unit
condition|)
operator|*
name|unit
operator|=
name|u
expr_stmt|;
if|if
condition|(
name|u
operator|>
name|NPCM_MAX
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|dev
operator|&
literal|0x0f
condition|)
block|{
case|case
name|SND_DEV_CTL
case|:
comment|/* /dev/mixer handled by pcm */
case|case
name|SND_DEV_STATUS
case|:
comment|/* /dev/sndstat handled by pcm */
case|case
name|SND_DEV_SNDPROC
case|:
comment|/* /dev/sndproc handled by pcm */
case|case
name|SND_DEV_DSP
case|:
case|case
name|SND_DEV_DSP16
case|:
case|case
name|SND_DEV_AUDIO
case|:
name|d
operator|=
operator|&
name|pcm_info
index|[
name|u
index|]
expr_stmt|;
break|break ;
case|case
name|SND_DEV_SEQ
case|:
case|case
name|SND_DEV_SEQ2
case|:
name|d
operator|=
operator|&
name|synth_info
index|[
name|u
index|]
expr_stmt|;
break|break ;
case|case
name|SND_DEV_MIDIN
case|:
name|d
operator|=
operator|&
name|midi_info
index|[
name|u
index|]
expr_stmt|;
break|break ;
default|default:
return|return
name|NULL
return|;
block|}
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/*  * here are the switches for the main functions. The switches do  * all necessary checks on the device number to make sure  * that the device is configured. They also provide some default  * functionalities so that device-specific drivers have to deal  * only with special cases.  */
end_comment

begin_function
specifier|static
name|int
name|sndopen
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|dev
decl_stmt|,
name|unit
decl_stmt|;
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_snddev_info
argument_list|(
name|dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"open snd%d subdev %d flags 0x%08x mode 0x%08x\n"
argument_list|,
name|unit
argument_list|,
name|dev
operator|&
literal|0xf
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"open: unit %d dev %d not configured, perhaps you want unit %d ?\n"
argument_list|,
name|unit
argument_list|,
name|dev
operator|&
literal|0xf
argument_list|,
name|unit
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
switch|switch
condition|(
name|dev
operator|&
literal|0x0f
condition|)
block|{
case|case
name|SND_DEV_CTL
case|:
comment|/* mixer ... */
return|return
literal|0
return|;
comment|/* always succeed */
case|case
name|SND_DEV_STATUS
case|:
comment|/* implemented right here */
name|init_status
argument_list|(
operator|&
name|pcm_info
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|d
operator|->
name|status_ptr
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
default|default:
if|if
condition|(
name|d
operator|->
name|open
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"open: bad unit %d, perhaps you want unit %d ?\n"
argument_list|,
name|unit
argument_list|,
name|unit
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
else|else
return|return
name|d
operator|->
name|open
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
return|;
block|}
return|return
name|ENXIO
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sndclose
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|dev
decl_stmt|,
name|unit
decl_stmt|;
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_snddev_info
argument_list|(
name|dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"close snd%d subdev %d\n"
argument_list|,
name|unit
argument_list|,
name|dev
operator|&
literal|0xf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"close: unit %d dev %d not configured\n"
argument_list|,
name|unit
argument_list|,
name|dev
operator|&
literal|0xf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
switch|switch
condition|(
name|dev
operator|&
literal|0x0f
condition|)
block|{
comment|/* only those for which close makes sense */
case|case
name|SND_DEV_AUDIO
case|:
case|case
name|SND_DEV_DSP
case|:
case|case
name|SND_DEV_DSP16
case|:
case|case
name|SND_DEV_SEQ
case|:
case|case
name|SND_DEV_SEQ2
case|:
case|case
name|SND_DEV_MIDIN
case|:
if|if
condition|(
name|d
operator|->
name|close
condition|)
return|return
name|d
operator|->
name|close
argument_list|(
name|i_dev
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sndread
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|dev
decl_stmt|,
name|unit
decl_stmt|;
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_snddev_info
argument_list|(
name|dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"read snd%d subdev %d flag 0x%08x\n"
argument_list|,
name|unit
argument_list|,
name|dev
operator|&
literal|0xf
argument_list|,
name|flag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"read: unit %d not configured\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|(
name|dev
operator|&
literal|0x0f
operator|)
operator|==
name|SND_DEV_STATUS
condition|)
block|{
name|int
name|l
decl_stmt|,
name|c
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|;
name|l
operator|=
name|buf
operator|->
name|uio_resid
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|c
operator|=
name|status_len
operator|-
name|d
operator|->
name|status_ptr
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
comment|/* should not happen! */
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|l
condition|)
name|l
operator|=
name|c
expr_stmt|;
name|p
operator|=
name|status_buf
operator|+
name|d
operator|->
name|status_ptr
expr_stmt|;
name|d
operator|->
name|status_ptr
operator|+=
name|l
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ret
operator|=
name|uiomove
argument_list|(
name|p
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|printf
argument_list|(
literal|"pcm-stat: bad copyout\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|d
operator|->
name|read
condition|)
comment|/* device-specific read */
return|return
name|d
operator|->
name|read
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|,
name|flag
argument_list|)
return|;
comment|/*      * the generic read routine. device-specific stuff should only      * be in the dma-handling procedures.      */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_READING
condition|)
block|{
comment|/* another reader is in, deny request */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"read denied, another reader is in\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
if|if
condition|(
name|d
operator|->
name|dma1
operator|==
name|d
operator|->
name|dma2
condition|)
block|{
comment|/* half duplex */
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WRITING
condition|)
block|{
comment|/* another writer is in, deny request */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"read denied, half duplex and a writer is in\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
while|while
condition|(
name|d
operator|->
name|dbuf_out
operator|.
name|dl
condition|)
block|{
comment|/* 	     * we have a pending dma operation, post a read request 	     * and wait for the write to complete. 	     */
name|d
operator|->
name|flags
operator||=
name|SND_F_READING
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sndread: sleeping waiting for write to end\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"sndrdw"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERESTART
operator|||
name|ret
operator|==
name|EINTR
condition|)
block|{
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_READING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINTR
return|;
block|}
block|}
block|}
name|d
operator|->
name|flags
operator||=
name|SND_F_READING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|dsp_read_body
argument_list|(
name|d
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sndwrite
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|dev
decl_stmt|,
name|unit
decl_stmt|;
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_snddev_info
argument_list|(
name|dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"write snd%d subdev %d flag 0x%08x\n"
argument_list|,
name|unit
argument_list|,
name|dev
operator|&
literal|0xf
argument_list|,
name|flag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"write: unit %d not configured\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
switch|switch
condition|(
name|dev
operator|&
literal|0x0f
condition|)
block|{
comment|/* only writeable devices */
case|case
name|SND_DEV_MIDIN
case|:
comment|/* XXX is this writable ? */
case|case
name|SND_DEV_SEQ
case|:
case|case
name|SND_DEV_SEQ2
case|:
case|case
name|SND_DEV_DSP
case|:
case|case
name|SND_DEV_DSP16
case|:
case|case
name|SND_DEV_AUDIO
case|:
break|break ;
default|default:
return|return
name|EPERM
return|;
comment|/* for non-writeable devices ; */
block|}
if|if
condition|(
name|d
operator|->
name|write
condition|)
return|return
name|d
operator|->
name|write
argument_list|(
name|i_dev
argument_list|,
name|buf
argument_list|,
name|flag
argument_list|)
return|;
comment|/*      * Otherwise, use the generic write routine. device-specific      * stuff should only be in the dma-handling procedures.      */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WRITING
condition|)
block|{
comment|/* another writer is in, deny request */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"write denied, another writer is in\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
if|if
condition|(
name|d
operator|->
name|dma1
operator|==
name|d
operator|->
name|dma2
condition|)
block|{
comment|/* half duplex */
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_READING
condition|)
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"write denied, half duplex and a reader is in\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* another reader is in, deny request */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
while|while
condition|(
name|d
operator|->
name|dbuf_in
operator|.
name|dl
condition|)
block|{
comment|/* 	     * we have a pending read dma. Post a write request 	     * and wait for the read to complete (in fact I could 	     * abort the read dma... 	     */
name|d
operator|->
name|flags
operator||=
name|SND_F_WRITING
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sndwrite: sleeping waiting for read to end\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"sndwr"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERESTART
operator|||
name|ret
operator|==
name|EINTR
condition|)
block|{
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_WRITING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EINTR
return|;
block|}
block|}
block|}
name|d
operator|->
name|flags
operator||=
name|SND_F_WRITING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|dsp_write_body
argument_list|(
name|d
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * generic sound ioctl. Functions of the default driver can be  * overridden by the device-specific ioctl call.  * If a device-specific call returns ENOSYS (Function not implemented),  * the default driver is called. Otherwise, the returned value  * is passed up.  *  * The default handler, for many parameters, sets the value in the  * descriptor, sets SND_F_INIT, and calls the callback function with  * reason INIT. If successful, the callback returns 1 and the caller  * can update the parameter.  */
end_comment

begin_function
specifier|static
name|int
name|sndioctl
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|ret
init|=
name|ENOSYS
decl_stmt|,
name|dev
decl_stmt|,
name|unit
decl_stmt|;
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_snddev_info
argument_list|(
name|dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ioctl: unit %d not configured\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|d
operator|->
name|ioctl
condition|)
name|ret
operator|=
name|d
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|mode
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ENOSYS
condition|)
return|return
name|ret
return|;
comment|/*      * pass control to the default ioctl handler. Set ret to 0 now.      */
name|ret
operator|=
literal|0
expr_stmt|;
comment|/*      * The linux ioctl interface for the sound driver has a thousand      * different calls, and it is unpractical to put the names in      * the switch().  So we have some tests before for common routines,      * such as the ones related to the mixer.  But we really ought      * to redesign the interface!      *      * Reading from the mixer just requires to look at the cached      * copy in d->mix_levels[dev], so this routine should cover      * practically all needs for mixer reading.      */
if|if
condition|(
operator|(
name|cmd
operator|&
name|MIXER_READ
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
name|MIXER_READ
argument_list|(
literal|0
argument_list|)
operator|&&
operator|(
name|cmd
operator|&
literal|0xff
operator|)
operator|<
literal|32
condition|)
block|{
name|int
name|dev
init|=
name|cmd
operator|&
literal|0x1f
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|mix_devs
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
condition|)
block|{
comment|/* supported */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|mix_levels
index|[
name|dev
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|EINVAL
return|;
block|}
comment|/*      * all routines are called with int. blocked. Make sure that      * ints are re-enabled when calling slow or blocking functions!      */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/*      * we start with the new ioctl interface.      */
case|case
name|AIONWRITE
case|:
comment|/* how many bytes can write ? */
if|if
condition|(
name|d
operator|->
name|dbuf_out
operator|.
name|dl
condition|)
name|dsp_wr_dmaupdate
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|dbuf_out
operator|.
name|fl
expr_stmt|;
break|break;
case|case
name|AIOSSIZE
case|:
comment|/* set the current blocksize */
block|{
name|struct
name|snd_size
modifier|*
name|p
init|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|play_size
operator|<=
literal|1
operator|&&
name|p
operator|->
name|rec_size
operator|<=
literal|1
condition|)
block|{
comment|/* means no blocks */
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_HAS_SIZE
expr_stmt|;
block|}
else|else
block|{
name|RANGE
argument_list|(
name|p
operator|->
name|play_size
argument_list|,
literal|40
argument_list|,
name|d
operator|->
name|dbuf_out
operator|.
name|bufsize
operator|/
literal|4
argument_list|)
expr_stmt|;
name|d
operator|->
name|play_blocksize
operator|=
name|p
operator|->
name|play_size
operator|&
operator|~
literal|3
expr_stmt|;
name|RANGE
argument_list|(
name|p
operator|->
name|rec_size
argument_list|,
literal|40
argument_list|,
name|d
operator|->
name|dbuf_in
operator|.
name|bufsize
operator|/
literal|4
argument_list|)
expr_stmt|;
name|d
operator|->
name|rec_blocksize
operator|=
name|p
operator|->
name|rec_size
operator|&
operator|~
literal|3
expr_stmt|;
name|d
operator|->
name|flags
operator||=
name|SND_F_HAS_SIZE
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ask_init
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|AIOGSIZE
case|:
comment|/* get the current blocksize */
block|{
name|struct
name|snd_size
modifier|*
name|p
init|=
operator|(
expr|struct
name|snd_size
operator|*
operator|)
name|arg
decl_stmt|;
name|p
operator|->
name|play_size
operator|=
name|d
operator|->
name|play_blocksize
expr_stmt|;
name|p
operator|->
name|rec_size
operator|=
name|d
operator|->
name|rec_blocksize
expr_stmt|;
block|}
break|break ;
case|case
name|AIOSFMT
case|:
block|{
name|snd_chan_param
modifier|*
name|p
init|=
operator|(
name|snd_chan_param
operator|*
operator|)
name|arg
decl_stmt|;
name|d
operator|->
name|play_speed
operator|=
name|p
operator|->
name|play_rate
expr_stmt|;
name|d
operator|->
name|rec_speed
operator|=
name|p
operator|->
name|play_rate
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|p
operator|->
name|play_format
operator|&
name|SND_F_STEREO
condition|)
name|d
operator|->
name|flags
operator||=
name|SND_F_STEREO
expr_stmt|;
else|else
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_STEREO
expr_stmt|;
name|d
operator|->
name|play_fmt
operator|=
name|p
operator|->
name|play_format
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
name|d
operator|->
name|rec_fmt
operator|=
name|p
operator|->
name|rec_format
operator|&
operator|~
name|AFMT_STEREO
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ask_init
argument_list|(
name|d
argument_list|)
condition|)
break|break ;
comment|/* could not reinit */
comment|/* FALLTHROUGH */
case|case
name|AIOGFMT
case|:
block|{
name|snd_chan_param
modifier|*
name|p
init|=
operator|(
name|snd_chan_param
operator|*
operator|)
name|arg
decl_stmt|;
name|p
operator|->
name|play_rate
operator|=
name|d
operator|->
name|play_speed
expr_stmt|;
name|p
operator|->
name|rec_rate
operator|=
name|d
operator|->
name|rec_speed
expr_stmt|;
name|p
operator|->
name|play_format
operator|=
name|d
operator|->
name|play_fmt
expr_stmt|;
name|p
operator|->
name|rec_format
operator|=
name|d
operator|->
name|rec_fmt
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
condition|)
block|{
name|p
operator|->
name|play_format
operator||=
name|AFMT_STEREO
expr_stmt|;
name|p
operator|->
name|rec_format
operator||=
name|AFMT_STEREO
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AIOGCAP
case|:
comment|/* get capabilities */
comment|/* this should really be implemented by the driver */
block|{
name|snd_capabilities
modifier|*
name|p
init|=
operator|(
name|snd_capabilities
operator|*
operator|)
name|arg
decl_stmt|;
name|p
operator|->
name|rate_min
operator|=
literal|5000
expr_stmt|;
name|p
operator|->
name|rate_max
operator|=
literal|48000
expr_stmt|;
comment|/* default */
name|p
operator|->
name|bufsize
operator|=
name|d
operator|->
name|bufsize
expr_stmt|;
name|p
operator|->
name|formats
operator|=
name|d
operator|->
name|audio_fmt
expr_stmt|;
comment|/* default */
name|p
operator|->
name|mixers
operator|=
literal|1
expr_stmt|;
comment|/* default: one mixer */
name|p
operator|->
name|inputs
operator|=
name|d
operator|->
name|mix_devs
expr_stmt|;
name|p
operator|->
name|left
operator|=
name|p
operator|->
name|right
operator|=
literal|255
expr_stmt|;
block|}
break|break ;
case|case
name|AIOSTOP
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
name|AIOSYNC_PLAY
condition|)
comment|/* play */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|dsp_wrabort
argument_list|(
name|d
argument_list|,
literal|1
comment|/* restart */
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
name|AIOSYNC_CAPTURE
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|dsp_rdabort
argument_list|(
name|d
argument_list|,
literal|1
comment|/* restart */
argument_list|)
expr_stmt|;
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"AIOSTOP: bad channel 0x%x\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|0
expr_stmt|;
block|}
break|break ;
case|case
name|AIOSYNC
case|:
name|printf
argument_list|(
literal|"AIOSYNC chan 0x%03lx pos %ld unimplemented\n"
argument_list|,
operator|(
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
operator|)
operator|->
name|chan
argument_list|,
operator|(
operator|(
name|snd_sync_parm
operator|*
operator|)
name|arg
operator|)
operator|->
name|pos
argument_list|)
expr_stmt|;
break|break;
comment|/*      * here follow the standard ioctls (filio.h etc.)      */
case|case
name|FIONREAD
case|:
comment|/* get # bytes to read */
if|if
condition|(
name|d
operator|->
name|dbuf_in
operator|.
name|dl
condition|)
name|dsp_rd_dmaupdate
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|dbuf_in
operator|.
name|rl
expr_stmt|;
break|break;
case|case
name|FIOASYNC
case|:
comment|/*set/clear async i/o */
name|printf
argument_list|(
literal|"FIOASYNC\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_NONBLOCK
case|:
case|case
name|FIONBIO
case|:
comment|/* set/clear non-blocking i/o */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
literal|0
condition|)
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_NBIO
expr_stmt|;
else|else
name|d
operator|->
name|flags
operator||=
name|SND_F_NBIO
expr_stmt|;
break|break ;
comment|/*      * Finally, here is the linux-compatible ioctl interface      */
case|case
name|SNDCTL_DSP_GETBLKSIZE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|play_blocksize
expr_stmt|;
break|break ;
case|case
name|SNDCTL_DSP_SETBLKSIZE
case|:
block|{
name|int
name|t
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|t
operator|<=
literal|1
condition|)
block|{
comment|/* means no blocks */
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_HAS_SIZE
expr_stmt|;
block|}
else|else
block|{
name|RANGE
argument_list|(
name|t
argument_list|,
literal|40
argument_list|,
name|d
operator|->
name|dbuf_out
operator|.
name|bufsize
operator|/
literal|4
argument_list|)
expr_stmt|;
name|d
operator|->
name|play_blocksize
operator|=
name|d
operator|->
name|rec_blocksize
operator|=
name|t
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* align to multiple of 4 */
name|d
operator|->
name|flags
operator||=
name|SND_F_HAS_SIZE
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ask_init
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break ;
case|case
name|SNDCTL_DSP_RESET
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp reset\n"
argument_list|)
argument_list|)
expr_stmt|;
name|dsp_wrabort
argument_list|(
name|d
argument_list|,
literal|1
comment|/* restart */
argument_list|)
expr_stmt|;
name|dsp_rdabort
argument_list|(
name|d
argument_list|,
literal|1
comment|/* restart */
argument_list|)
expr_stmt|;
break|break ;
case|case
name|SNDCTL_DSP_SYNC
case|:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp sync\n"
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|snd_sync
argument_list|(
name|d
argument_list|,
literal|1
argument_list|,
name|d
operator|->
name|dbuf_out
operator|.
name|bufsize
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/* DMA does not start with<4 bytes */
break|break ;
case|case
name|SNDCTL_DSP_SPEED
case|:
name|d
operator|->
name|play_speed
operator|=
name|d
operator|->
name|rec_speed
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask_init
argument_list|(
name|d
argument_list|)
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|play_speed
expr_stmt|;
break|break ;
case|case
name|SNDCTL_DSP_STEREO
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
literal|0
condition|)
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_STEREO
expr_stmt|;
comment|/* mono */
elseif|else
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
literal|1
condition|)
name|d
operator|->
name|flags
operator||=
name|SND_F_STEREO
expr_stmt|;
comment|/* stereo */
else|else
block|{
name|printf
argument_list|(
literal|"dsp stereo: %d is invalid, assuming 1\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|d
operator|->
name|flags
operator||=
name|SND_F_STEREO
expr_stmt|;
comment|/* stereo */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask_init
argument_list|(
name|d
argument_list|)
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break ;
case|case
name|SOUND_PCM_WRITE_CHANNELS
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
literal|1
condition|)
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_STEREO
expr_stmt|;
comment|/* mono */
elseif|else
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|==
literal|2
condition|)
name|d
operator|->
name|flags
operator||=
name|SND_F_STEREO
expr_stmt|;
comment|/* stereo */
else|else
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break ;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask_init
argument_list|(
name|d
argument_list|)
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
break|break ;
case|case
name|SOUND_PCM_READ_RATE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|play_speed
expr_stmt|;
break|break ;
case|case
name|SOUND_PCM_READ_CHANNELS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
break|break ;
case|case
name|SNDCTL_DSP_GETFMTS
case|:
comment|/* returns a mask of supported fmts */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
operator|(
name|int
operator|)
name|d
operator|->
name|audio_fmt
expr_stmt|;
break|break ;
case|case
name|SNDCTL_DSP_SETFMT
case|:
comment|/* sets _one_ format */
name|d
operator|->
name|play_fmt
operator|=
name|d
operator|->
name|rec_fmt
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ask_init
argument_list|(
name|d
argument_list|)
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|play_fmt
expr_stmt|;
break|break ;
case|case
name|SNDCTL_DSP_SUBDIVIDE
case|:
comment|/* XXX watch out, this is RW! */
name|printf
argument_list|(
literal|"SNDCTL_DSP_SUBDIVIDE yet unimplemented\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SNDCTL_DSP_SETFRAGMENT
case|:
comment|/* XXX watch out, this is RW! */
name|printf
argument_list|(
literal|"SNDCTL_DSP_SETFRAGMENT 0x%08x\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|{
name|int
name|bytes
decl_stmt|,
name|count
decl_stmt|;
name|bytes
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|&
literal|0xffff
expr_stmt|;
name|count
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|7
condition|)
name|bytes
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|15
condition|)
name|bytes
operator|=
literal|15
expr_stmt|;
name|d
operator|->
name|play_blocksize
operator|=
name|d
operator|->
name|rec_blocksize
operator|=
name|min
argument_list|(
literal|1
operator|<<
name|bytes
argument_list|,
name|d
operator|->
name|dbuf_in
operator|.
name|bufsize
argument_list|)
expr_stmt|;
name|count
operator|=
name|d
operator|->
name|dbuf_in
operator|.
name|bufsize
operator|/
name|d
operator|->
name|play_blocksize
expr_stmt|;
name|bytes
operator|=
name|ffs
argument_list|(
name|d
operator|->
name|play_blocksize
argument_list|)
operator|-
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	     * don't change arg, since it's fake anyways and some 	     * programs might fail if we do. 	     */
block|*(int *)arg = (count<< 16) | bytes ;
endif|#
directive|endif
block|}
break|break ;
case|case
name|SNDCTL_DSP_GETISPACE
case|:
comment|/* return space available in the input queue */
operator|(
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
operator|)
operator|->
name|bytes
operator|=
name|d
operator|->
name|dbuf_in
operator|.
name|fl
expr_stmt|;
operator|(
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
operator|)
operator|->
name|fragments
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
operator|)
operator|->
name|fragstotal
operator|=
name|d
operator|->
name|dbuf_in
operator|.
name|bufsize
operator|/
name|d
operator|->
name|rec_blocksize
expr_stmt|;
operator|(
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
operator|)
operator|->
name|fragsize
operator|=
name|d
operator|->
name|rec_blocksize
expr_stmt|;
break|break ;
case|case
name|SNDCTL_DSP_GETOSPACE
case|:
comment|/* return space available in the output queue */
operator|(
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
operator|)
operator|->
name|bytes
operator|=
name|d
operator|->
name|dbuf_out
operator|.
name|fl
expr_stmt|;
operator|(
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
operator|)
operator|->
name|fragments
operator|=
literal|1
expr_stmt|;
operator|(
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
operator|)
operator|->
name|fragstotal
operator|=
name|d
operator|->
name|dbuf_out
operator|.
name|bufsize
operator|/
name|d
operator|->
name|play_blocksize
expr_stmt|;
operator|(
operator|(
name|audio_buf_info
operator|*
operator|)
name|arg
operator|)
operator|->
name|fragsize
operator|=
name|d
operator|->
name|play_blocksize
expr_stmt|;
break|break ;
case|case
name|SNDCTL_DSP_GETCAPS
case|:
name|printf
argument_list|(
literal|"dsp getcaps\n"
argument_list|)
expr_stmt|;
break|break ;
case|case
name|SOUND_PCM_READ_BITS
case|:
if|if
condition|(
name|d
operator|->
name|play_fmt
operator|==
name|AFMT_S16_LE
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|16
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|8
expr_stmt|;
break|break ;
comment|/*      * mixer calls      */
case|case
name|SOUND_MIXER_READ_DEVMASK
case|:
case|case
name|SOUND_MIXER_READ_STEREODEVS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|mix_devs
expr_stmt|;
break|break ;
case|case
name|SOUND_MIXER_READ_RECMASK
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|mix_rec_devs
expr_stmt|;
break|break ;
case|case
name|SOUND_MIXER_READ_RECSRC
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|d
operator|->
name|mix_recsrc
expr_stmt|;
break|break;
case|case
name|SOUND_MIXER_READ_CAPS
case|:
comment|/* 	 * XXX - This needs to be fixed when the sound driver actually 	 * supports multiple inputs. 	 */
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|SOUND_CAP_EXCL_INPUT
expr_stmt|;
break|break;
default|default:
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"default ioctl snd%d subdev %d fn 0x%08x fail\n"
argument_list|,
name|unit
argument_list|,
name|dev
operator|&
literal|0xf
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break ;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * function to poll what is currently available.  Used to be select.  */
end_comment

begin_function
name|int
name|sndpoll
parameter_list|(
name|dev_t
name|i_dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|dev
decl_stmt|,
name|unit
decl_stmt|,
name|c
init|=
literal|1
comment|/* default: success */
decl_stmt|;
name|snddev_info
modifier|*
name|d
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|dev
operator|=
name|minor
argument_list|(
name|i_dev
argument_list|)
expr_stmt|;
name|d
operator|=
name|get_snddev_info
argument_list|(
name|dev
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sndpoll dev 0x%04x events 0x%08x\n"
argument_list|,
name|i_dev
argument_list|,
name|events
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"poll: unit %d not configured\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLOUT
operator||
name|POLLRDNORM
operator||
name|POLLWRNORM
operator|)
operator|)
operator||
name|POLLHUP
operator|)
return|;
block|}
if|if
condition|(
name|d
operator|->
name|poll
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLOUT
operator||
name|POLLRDNORM
operator||
name|POLLWRNORM
operator|)
operator|)
operator||
name|POLLHUP
operator|)
return|;
elseif|else
if|if
condition|(
name|d
operator|->
name|poll
operator|!=
name|sndpoll
condition|)
return|return
name|d
operator|->
name|poll
argument_list|(
name|i_dev
argument_list|,
name|events
argument_list|,
name|p
argument_list|)
return|;
else|else
block|{
comment|/* handle it here with the generic code */
name|int
name|lim
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
comment|/* 	 * if the user selected a block size, then we want to use the 	 * device as a block device, and select will return ready when 	 * we have a full block. 	 * In all other cases, select will return when 1 byte is ready. 	 */
name|lim
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_HAS_SIZE
condition|)
name|lim
operator|=
name|d
operator|->
name|play_blocksize
expr_stmt|;
comment|/* XXX fix the test here for half duplex devices */
if|if
condition|(
literal|1
comment|/* write is compatible with current mode */
condition|)
block|{
name|flags
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dbuf_out
operator|.
name|dl
condition|)
name|dsp_wr_dmaupdate
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|d
operator|->
name|dbuf_out
operator|.
name|fl
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|lim
condition|)
comment|/* no space available */
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
operator|(
name|d
operator|->
name|wsel
operator|)
argument_list|)
expr_stmt|;
else|else
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_HAS_SIZE
condition|)
name|lim
operator|=
name|d
operator|->
name|rec_blocksize
expr_stmt|;
comment|/* XXX fix the test here */
if|if
condition|(
literal|1
comment|/* read is compatible with current mode */
condition|)
block|{
name|flags
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|dbuf_in
operator|.
name|dl
operator|==
literal|0
condition|)
comment|/* dma idle, restart it */
name|dsp_rdintr
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|dsp_rd_dmaupdate
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|d
operator|->
name|dbuf_in
operator|.
name|rl
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|lim
condition|)
comment|/* no data available */
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
operator|(
name|d
operator|->
name|rsel
operator|)
argument_list|)
expr_stmt|;
else|else
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sndpoll on read: %d>= %d flags 0x%08x\n"
argument_list|,
name|c
argument_list|,
name|lim
argument_list|,
name|d
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|c
operator|<
name|lim
condition|?
literal|0
else|:
literal|1
return|;
block|}
return|return
name|revents
return|;
block|}
return|return
name|ENXIO
return|;
comment|/* notreached */
block|}
end_function

begin_comment
comment|/*  * The mmap interface allows access to the play and read buffer,  * plus the device descriptor.  * The various blocks are accessible at the following offsets:  *  * 0x00000000 ( 0   ) : write buffer ;  * 0x01000000 (16 MB) : read buffer ;  * 0x02000000 (32 MB) : device descriptor (dangerous!)  *  * WARNING: the mmap routines assume memory areas are aligned. This  * is true (probably) for the dma buffers, but likely false for the  * device descriptor. As a consequence, we do not know where it is  * located in the requested area.  */
end_comment

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_function
specifier|static
name|int
name|sndmmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|snddev_info
modifier|*
name|d
init|=
name|get_snddev_info
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sndmmap d 0x%p dev 0x%04x ofs 0x%08x nprot 0x%08x\n"
argument_list|,
name|d
argument_list|,
name|dev
argument_list|,
name|offset
argument_list|,
name|nprot
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
operator|||
name|nprot
operator|&
name|PROT_EXEC
condition|)
return|return
operator|-
literal|1
return|;
comment|/* forbidden */
if|if
condition|(
name|offset
operator|>=
name|d
operator|->
name|dbuf_out
operator|.
name|bufsize
operator|&&
operator|(
name|nprot
operator|&
name|PROT_WRITE
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* can only write to the first block */
if|if
condition|(
name|offset
operator|<
name|d
operator|->
name|dbuf_out
operator|.
name|bufsize
condition|)
return|return
name|i386_btop
argument_list|(
name|vtophys
argument_list|(
name|d
operator|->
name|dbuf_out
operator|.
name|buf
operator|+
name|offset
argument_list|)
argument_list|)
return|;
name|offset
operator|-=
literal|1
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|offset
operator|<
name|d
operator|->
name|dbuf_in
operator|.
name|bufsize
operator|)
condition|)
return|return
name|i386_btop
argument_list|(
name|vtophys
argument_list|(
name|d
operator|->
name|dbuf_in
operator|.
name|buf
operator|+
name|offset
argument_list|)
argument_list|)
return|;
name|offset
operator|-=
literal|1
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|offset
operator|<
literal|0x2000
operator|)
condition|)
block|{
return|return
name|i386_btop
argument_list|(
name|vtophys
argument_list|(
operator|(
operator|(
name|int
operator|)
name|d
operator|&
operator|~
literal|0xfff
operator|)
operator|+
name|offset
argument_list|)
argument_list|)
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * ask_init sets the init flag in the device descriptor, and  * possibly calls the appropriate callback routine, returning 1  * if the callback was successful. This enables ioctls handler for  * rw parameters to read back the updated value.  * Since the init callback can be slow, ask_init() should be called  * with interrupts enabled.  */
end_comment

begin_function
name|int
name|ask_init
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|u_long
name|s
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|callback
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_PENDING_IO
operator|||
name|d
operator|->
name|dbuf_out
operator|.
name|dl
operator|||
name|d
operator|->
name|dbuf_in
operator|.
name|dl
condition|)
block|{
comment|/* cannot do it now, record the request and return */
name|d
operator|->
name|flags
operator||=
name|SND_F_INIT
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_INIT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * these are the functions for the soundstat device. We copy parameters  * from the device info structure to static variables, and from there  * back to the structure when done.  */
end_comment

begin_function
specifier|static
name|void
name|init_status
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
comment|/*      * Write the status information to the status_buf and update      * status_len. There is a limit of SNDSTAT_BUF_SIZE bytes for the data.      * put_status handles this and returns 0 in case of failure. Since      * it never oveflows the buffer, we do not care to check.      */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|status_len
operator|!=
literal|0
condition|)
comment|/* only do init once */
return|return ;
name|sprintf
argument_list|(
name|status_buf
argument_list|,
literal|"FreeBSD Audio Driver (971023) "
name|__DATE__
literal|" "
name|__TIME__
literal|"\n"
literal|"Installed devices:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPCM_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pcm_info
index|[
name|i
index|]
operator|.
name|open
condition|)
name|sprintf
argument_list|(
name|status_buf
operator|+
name|strlen
argument_list|(
name|status_buf
argument_list|)
argument_list|,
literal|"pcm%d:<%s> at 0x%x irq %d dma %d:%d\n"
argument_list|,
name|i
argument_list|,
name|pcm_info
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|pcm_info
index|[
name|i
index|]
operator|.
name|io_base
argument_list|,
name|pcm_info
index|[
name|i
index|]
operator|.
name|irq
argument_list|,
name|pcm_info
index|[
name|i
index|]
operator|.
name|dma1
argument_list|,
name|pcm_info
index|[
name|i
index|]
operator|.
name|dma2
argument_list|)
expr_stmt|;
if|if
condition|(
name|midi_info
index|[
name|i
index|]
operator|.
name|open
condition|)
name|sprintf
argument_list|(
name|status_buf
operator|+
name|strlen
argument_list|(
name|status_buf
argument_list|)
argument_list|,
literal|"midi%d:<%s> at 0x%x irq %d dma %d:%d\n"
argument_list|,
name|i
argument_list|,
name|midi_info
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|midi_info
index|[
name|i
index|]
operator|.
name|io_base
argument_list|,
name|midi_info
index|[
name|i
index|]
operator|.
name|irq
argument_list|,
name|midi_info
index|[
name|i
index|]
operator|.
name|dma1
argument_list|,
name|midi_info
index|[
name|i
index|]
operator|.
name|dma2
argument_list|)
expr_stmt|;
if|if
condition|(
name|synth_info
index|[
name|i
index|]
operator|.
name|open
condition|)
name|sprintf
argument_list|(
name|status_buf
operator|+
name|strlen
argument_list|(
name|status_buf
argument_list|)
argument_list|,
literal|"synth%d:<%s> at 0x%x irq %d dma %d:%d\n"
argument_list|,
name|i
argument_list|,
name|synth_info
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|synth_info
index|[
name|i
index|]
operator|.
name|io_base
argument_list|,
name|synth_info
index|[
name|i
index|]
operator|.
name|irq
argument_list|,
name|synth_info
index|[
name|i
index|]
operator|.
name|dma1
argument_list|,
name|synth_info
index|[
name|i
index|]
operator|.
name|dma2
argument_list|)
expr_stmt|;
block|}
name|status_len
operator|=
name|strlen
argument_list|(
name|status_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * finally, some "libraries"  */
end_comment

begin_comment
comment|/*  * isa_dmastatus1() is a wrapper for isa_dmastatus(), which  * might return -1 or -2 in some cases (errors). Since for the  * user code it is more comfortable not to check for these cases,  * negative values are mapped back to 0 (which is reasonable).  */
end_comment

begin_function
name|int
name|isa_dmastatus1
parameter_list|(
name|int
name|channel
parameter_list|)
block|{
name|int
name|r
init|=
name|isa_dmastatus
argument_list|(
name|channel
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|r
operator|=
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * snd_conflict scans already-attached boards to see if  * the current address is conflicting with one of the already  * assigned ones. Returns 1 if a conflict is detected.  */
end_comment

begin_function
name|int
name|snd_conflict
parameter_list|(
name|int
name|io_base
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPCM_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|io_base
operator|==
name|pcm_info
index|[
name|i
index|]
operator|.
name|io_base
operator|)
operator|||
operator|(
name|io_base
operator|==
name|pcm_info
index|[
name|i
index|]
operator|.
name|alt_base
operator|)
operator|||
operator|(
name|io_base
operator|==
name|pcm_info
index|[
name|i
index|]
operator|.
name|conf_base
operator|)
operator|||
operator|(
name|io_base
operator|==
name|pcm_info
index|[
name|i
index|]
operator|.
name|mix_base
operator|)
operator|||
operator|(
name|io_base
operator|==
name|pcm_info
index|[
name|i
index|]
operator|.
name|midi_base
operator|)
operator|||
operator|(
name|io_base
operator|==
name|pcm_info
index|[
name|i
index|]
operator|.
name|synth_base
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"device at 0x%x already attached as unit %d\n"
argument_list|,
name|io_base
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|snd_set_blocksize
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|int
name|tmp
decl_stmt|;
comment|/*      * compute the sample size, and possibly      * set the blocksize so as to guarantee approx 1/4s      * between callbacks.      */
name|tmp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
condition|)
name|tmp
operator|+=
name|tmp
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|play_fmt
operator|&
operator|(
name|AFMT_S16_LE
operator||
name|AFMT_U16_LE
operator|)
condition|)
name|tmp
operator|+=
name|tmp
expr_stmt|;
name|d
operator|->
name|dbuf_out
operator|.
name|sample_size
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|*
name|d
operator|->
name|play_speed
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_HAS_SIZE
operator|)
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|play_blocksize
operator|=
operator|(
name|tmp
operator|/
literal|4
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* 0.25s, aligned to 4 */
name|RANGE
argument_list|(
name|d
operator|->
name|play_blocksize
argument_list|,
literal|1024
argument_list|,
operator|(
name|d
operator|->
name|bufsize
operator|/
literal|4
operator|)
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_STEREO
condition|)
name|tmp
operator|+=
name|tmp
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|rec_fmt
operator|&
operator|(
name|AFMT_S16_LE
operator||
name|AFMT_U16_LE
operator|)
condition|)
name|tmp
operator|+=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|*
name|d
operator|->
name|rec_speed
expr_stmt|;
name|d
operator|->
name|dbuf_in
operator|.
name|sample_size
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_HAS_SIZE
operator|)
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|rec_blocksize
operator|=
operator|(
name|tmp
operator|/
literal|4
operator|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* 0.25s, aligned to 4 */
name|RANGE
argument_list|(
name|d
operator|->
name|rec_blocksize
argument_list|,
literal|1024
argument_list|,
operator|(
name|d
operator|->
name|bufsize
operator|/
literal|4
operator|)
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The various mixers use a variety of bitmasks etc. The Voxware  * driver had a very nice technique to describe a mixer and interface  * to it. A table defines, for each channel, which register, bits,  * offset, polarity to use. This procedure creates the new value  * using the table and the old value.  */
end_comment

begin_function
name|void
name|change_bits
parameter_list|(
name|mixer_tab
modifier|*
name|t
parameter_list|,
name|u_char
modifier|*
name|regval
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|newval
parameter_list|)
block|{
name|u_char
name|mask
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"ch_bits dev %d ch %d val %d old 0x%02x "
literal|"r %d p %d bit %d off %d\n"
argument_list|,
name|dev
argument_list|,
name|chn
argument_list|,
name|newval
argument_list|,
operator|*
name|regval
argument_list|,
operator|(
operator|*
name|t
operator|)
index|[
name|dev
index|]
index|[
name|chn
index|]
operator|.
name|regno
argument_list|,
operator|(
operator|*
name|t
operator|)
index|[
name|dev
index|]
index|[
name|chn
index|]
operator|.
name|polarity
argument_list|,
operator|(
operator|*
name|t
operator|)
index|[
name|dev
index|]
index|[
name|chn
index|]
operator|.
name|nbits
argument_list|,
operator|(
operator|*
name|t
operator|)
index|[
name|dev
index|]
index|[
name|chn
index|]
operator|.
name|bitoffs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|t
operator|)
index|[
name|dev
index|]
index|[
name|chn
index|]
operator|.
name|polarity
operator|==
literal|1
condition|)
comment|/* reverse */
name|newval
operator|=
literal|100
operator|-
name|newval
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
operator|(
operator|*
name|t
operator|)
index|[
name|dev
index|]
index|[
name|chn
index|]
operator|.
name|nbits
operator|)
operator|-
literal|1
expr_stmt|;
name|newval
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|newval
operator|*
name|mask
operator|)
operator|+
literal|50
argument_list|)
operator|/
literal|100
expr_stmt|;
comment|/* Scale it */
name|shift
operator|=
operator|(
operator|*
name|t
operator|)
index|[
name|dev
index|]
index|[
name|chn
index|]
operator|.
name|bitoffs
comment|/*- (*t)[dev][LEFT_CHN].nbits + 1*/
expr_stmt|;
operator|*
name|regval
operator|&=
operator|~
operator|(
name|mask
operator|<<
name|shift
operator|)
expr_stmt|;
comment|/* Filter out the previous value */
operator|*
name|regval
operator||=
operator|(
name|newval
operator|&
name|mask
operator|)
operator|<<
name|shift
expr_stmt|;
comment|/* Set the new value */
block|}
end_function

begin_comment
comment|/*  * code for translating between U8 and ULAW. Needed to support  * /dev/audio on the SoundBlaster. Actually, we would also need  * ulaw -> 16 bits (for the soundblaster as well, when used in  * full-duplex)  */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_function
name|void
name|translate_bytes
parameter_list|(
name|u_char
modifier|*
name|table
parameter_list|,
name|u_char
modifier|*
name|buff
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|u_long
name|i
decl_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
operator|++
name|i
control|)
name|buff
index|[
name|i
index|]
operator|=
name|table
index|[
name|buff
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* inline */
end_comment

begin_function
name|void
name|translate_bytes
parameter_list|(
specifier|const
name|void
modifier|*
name|table
parameter_list|,
name|void
modifier|*
name|buff
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
asm|__asm__ (  "   cld\n" 		   "1: lodsb\n" 		   "   xlatb\n" 		   "   stosb\n" 		   "   loop 1b\n": 	    : "b" ((long) table), "c" (n), "D" ((long) buff), "S" ((long) buff) 	    : "bx", "cx", "di", "si", "ax");
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCM> 0 */
end_comment

end_unit

