begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Sound interface for Speak Freely for Unix  *   * Designed and implemented in July of 1990 by John Walker  *   * FreeBSD / voxware version  */
end_comment

begin_define
define|#
directive|define
name|BUFL
value|8000
end_define

begin_include
include|#
directive|include
file|"speakfree.h"
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* #include<math.h> */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LINUX
end_ifdef

begin_include
include|#
directive|include
file|<linux/soundcard.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/soundcard.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|AUDIO_MIN_GAIN
value|0
end_define

begin_define
define|#
directive|define
name|AUDIO_MAX_GAIN
value|255
end_define

begin_decl_stmt
specifier|static
name|int
name|abuf_size
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SoundFile
value|"/dev/audio"
end_define

begin_define
define|#
directive|define
name|AUDIO_CTLDEV
value|"/dev/mixer"
end_define

begin_define
define|#
directive|define
name|MAX_GAIN
value|100
end_define

begin_struct
struct|struct
name|sound_buf
block|{
name|struct
name|sound_buf
modifier|*
name|snext
decl_stmt|;
comment|/* Next sound buffer */
name|int
name|sblen
decl_stmt|;
comment|/* Length of this sound buffer */
name|unsigned
name|char
name|sbtext
index|[
literal|2
index|]
decl_stmt|;
comment|/* Actual sampled sound */
block|}
struct|;
end_struct

begin_comment
comment|/* Local variables  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|audiof
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Audio device file descriptor */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Audio_fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Audio control port */
end_comment

begin_decl_stmt
name|struct
name|sound_buf
modifier|*
name|sbchain
init|=
name|NULL
decl_stmt|,
comment|/* Sound buffer chain links */
modifier|*
name|sbtail
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sbtotal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total sample bytes in memory */
end_comment

begin_decl_stmt
specifier|static
name|int
name|playing
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Replay in progress ? */
end_comment

begin_comment
comment|/* static int playqsize;  */
end_comment

begin_comment
comment|/* Output queue size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|playlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Length left to play */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|playbuf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current play pointer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|squelch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Squelch value */
end_comment

begin_comment
comment|/* Convert local gain into device parameters */
end_comment

begin_function
specifier|static
name|unsigned
name|scale_gain
parameter_list|(
name|unsigned
name|g
parameter_list|)
block|{
return|return
operator|(
name|AUDIO_MIN_GAIN
operator|+
call|(
name|unsigned
call|)
argument_list|(
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
call|(
name|double
call|)
argument_list|(
name|AUDIO_MAX_GAIN
operator|-
name|AUDIO_MIN_GAIN
argument_list|)
operator|)
operator|*
operator|(
operator|(
name|double
operator|)
name|g
operator|/
operator|(
name|double
operator|)
name|MAX_GAIN
operator|)
operator|)
operator|+
literal|0.5
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HALF_DUPLEX
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|oldvol
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * SOUNDINIT  --  Open the sound peripheral and initialise for access. Return  * TRUE if successful, FALSE otherwise.  */
end_comment

begin_function
name|int
name|soundinit
parameter_list|(
name|int
name|iomode
parameter_list|)
block|{
name|int
name|attempts
init|=
literal|3
decl_stmt|;
name|assert
argument_list|(
name|audiof
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|attempts
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|audiof
operator|=
name|open
argument_list|(
name|SoundFile
argument_list|,
name|iomode
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|Audio_fd
operator|=
name|open
argument_list|(
name|AUDIO_CTLDEV
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|AUDIO_CTLDEV
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* fcntl(audiof, F_SETFL, O_NDELAY); */
ifndef|#
directive|ifndef
name|AUDIO_BLOCKING
if|if
condition|(
name|ioctl
argument_list|(
name|audiof
argument_list|,
name|SNDCTL_DSP_NONBLOCK
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"SNDCTL_DSP_NONBLOCK"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|audiof
argument_list|,
name|SNDCTL_DSP_GETBLKSIZE
argument_list|,
operator|&
name|abuf_size
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"SNDCTL_DSP_GETBLKSIZE"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HALF_DUPLEX
if|if
condition|(
name|iomode
operator|==
name|O_RDONLY
condition|)
block|{
if|if
condition|(
name|oldvol
operator|==
operator|-
literal|1
condition|)
name|oldvol
operator|=
name|soundgetvol
argument_list|()
expr_stmt|;
name|soundplayvol
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iomode
operator|==
name|O_WRONLY
operator|&&
name|oldvol
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|soundgetvol
argument_list|()
operator|==
literal|0
condition|)
name|soundplayvol
argument_list|(
name|oldvol
argument_list|)
expr_stmt|;
name|oldvol
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
break|break;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Audio open: retrying EINTR attempt %d\n"
argument_list|,
name|attempts
argument_list|)
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* SOUNDTERM  --  Close the sound device. chan=1 for play, 2:capture */
end_comment

begin_function
name|void
name|soundterm
parameter_list|(
name|int
name|chan
parameter_list|)
block|{
if|if
condition|(
name|audiof
operator|>=
literal|0
condition|)
block|{
name|int
name|arg
decl_stmt|;
ifdef|#
directive|ifdef
name|AIOSTOP
comment|/* FreeBSD */
if|if
condition|(
name|chan
operator|==
literal|2
condition|)
block|{
name|arg
operator|=
name|AIOSYNC_CAPTURE
expr_stmt|;
name|ioctl
argument_list|(
name|audiof
argument_list|,
name|AIOSTOP
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SNDCTL_DSP_SYNC
if|if
condition|(
name|chan
operator|==
literal|1
condition|)
name|ioctl
argument_list|(
name|audiof
argument_list|,
name|SNDCTL_DSP_SYNC
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HALF_DUPLEX
if|if
condition|(
name|oldvol
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|soundgetvol
argument_list|()
operator|==
literal|0
condition|)
name|soundplayvol
argument_list|(
name|oldvol
argument_list|)
expr_stmt|;
name|oldvol
operator|=
operator|-
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|close
argument_list|(
name|audiof
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"closing audio device"
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
argument_list|(
name|Audio_fd
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"closing audio control device"
argument_list|)
expr_stmt|;
name|audiof
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* SOUNDPLAY  --  Begin playing a sound.  */
end_comment

begin_function
name|void
name|soundplay
parameter_list|(
name|int
name|len
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|ios
decl_stmt|;
name|assert
argument_list|(
name|audiof
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|ios
operator|=
name|write
argument_list|(
name|audiof
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ios
operator|==
operator|-
literal|1
condition|)
name|sf_usleep
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ios
operator|<
name|len
condition|)
block|{
name|buf
operator|+=
name|ios
expr_stmt|;
name|len
operator|-=
name|ios
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* SOUNDPLAYVOL  --  Set playback volume from 0 (silence) to 100 (full on). */
end_comment

begin_function
name|void
name|soundplayvol
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|int
name|arg
decl_stmt|;
name|arg
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|value
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|Audio_fd
argument_list|,
name|SOUND_MIXER_WRITE_PCM
argument_list|,
operator|&
name|arg
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"SOUND_MIXER_WRITE_PCM"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HALF_DUPLEX
end_ifdef

begin_comment
comment|/* SOUNDGETVOL -- Get current playback volume. */
end_comment

begin_function
name|int
name|soundgetvol
parameter_list|()
block|{
name|int
name|arg
decl_stmt|,
name|v1
decl_stmt|,
name|v2
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|Audio_fd
argument_list|,
name|SOUND_MIXER_READ_PCM
argument_list|,
operator|&
name|arg
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"SOUND_MIXER_READ_PCM"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|v1
operator|=
name|arg
operator|&
literal|0xFF
expr_stmt|;
name|v2
operator|=
operator|(
name|arg
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
return|return
operator|(
name|v1
operator|>
name|v2
operator|)
condition|?
name|v1
else|:
name|v2
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOUNDRECGAIN  --  Set recording gain from 0 (minimum) to 100 (maximum).  */
end_comment

begin_function
name|void
name|soundrecgain
parameter_list|(
name|int
name|value
parameter_list|)
block|{
name|int
name|arg
decl_stmt|;
name|arg
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|value
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|Audio_fd
argument_list|,
name|SOUND_MIXER_WRITE_RECLEV
argument_list|,
operator|&
name|arg
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"SOUND_MIXER_WRITE_RECLEV"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SOUNDDEST  --  Set destination for generated sound.  If "where" is 0,  * sound goes to the built-in speaker; if 1, to the audio output jack.  */
end_comment

begin_function
name|void
name|sounddest
parameter_list|(
name|int
name|where
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* SOUNDGRAB  --  Return audio information in the record queue.  */
end_comment

begin_function
name|int
name|soundgrab
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|long
name|read_size
decl_stmt|;
name|int
name|c
decl_stmt|;
name|read_size
operator|=
name|len
expr_stmt|;
ifndef|#
directive|ifndef
name|AUDIO_BLOCKING
if|if
condition|(
name|read_size
operator|>
name|abuf_size
condition|)
block|{
name|read_size
operator|=
name|abuf_size
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|TRUE
condition|)
block|{
name|c
operator|=
name|read
argument_list|(
name|audiof
argument_list|,
name|buf
argument_list|,
name|read_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EAGAIN
condition|)
block|{
name|c
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"soundgrab"
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* SOUNDFLUSH	--  Flush any queued sound.  */
end_comment

begin_function
name|void
name|soundflush
parameter_list|()
block|{
name|char
name|sb
index|[
name|BUFL
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
ifndef|#
directive|ifndef
name|AUDIO_BLOCKING
while|while
condition|(
name|TRUE
condition|)
block|{
name|c
operator|=
name|read
argument_list|(
name|audiof
argument_list|,
name|sb
argument_list|,
name|BUFL
operator|<
name|abuf_size
condition|?
name|BUFL
else|:
name|abuf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"soundflush"
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
literal|0
condition|)
break|break;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

