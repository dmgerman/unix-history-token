begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    SCCS: @(#) auvoxware.c 11.4 95/04/14  */
end_comment

begin_comment
comment|/*-------------------------------------------------------------------------  Copyright (C) 1995 The Santa Cruz Operation, Inc. All Rights Reserved.  Permission to use, copy, modify and distribute this software for any purpose is hereby granted without fee, provided that the  above copyright notice and this notice appear in all copies and that both the copyright notice and this notice appear in supporting documentation.  SCO makes no representations about the suitability of this software for any purpose.  It is provided "AS IS" without express or implied warranty.  SCO DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,  INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL SCO BE LIABLE FOR ANY SPECIAL, INDIRECT,  PUNITIVE, CONSEQUENTIAL OR INCIDENTAL DAMAGES OR ANY DAMAGES  WHATSOEVER RESULTING FROM LOSS OF USE, LOSS OF DATA OR LOSS OF PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER  TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  PERFORMANCE OF THIS SOFTWARE.  -------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*    AUVoxConfig additions (sysseh@devetir.qld.gov.au)    96-01-15 	Put the following  keywords in - 		minrate		-	Minimum sampling rate 		maxrate		-	Maximum sampling rate 		fragsize	-	The fragment size 		minfrags	-	Minimum number of frags in queue 		maxfrags	-	Maximum fragments in queue 		wordsize	-	8 or 16 bit samples 		device		-	What device file to use 		numchans	-	Mono (1) or stereo (2) 		debug		-	Output messages during operation 		verbose		-	Be chatty about config 		inputsection	-	Next lot of specs are for input 		outputsection	-	Next specs are for output 		end		-	End an input or output section */
end_comment

begin_comment
comment|/*    SCO Modification History:    S005, 24-Apr-95, shawnm@sco.com 	base # of driver buffer fragments on data rate    S004, 12-Apr-95, shawnm@sco.com 	finish integration of ausco.c, fix setitimer calls    S003, 28-Mar-95, shawnm@sco.com, sysseh@devetir.qld.gov.au 	incorporate patch for stereo/mono mixing from Stephen Hocking    S002, 21-Mar-95, shawnm@sco.com 	incorporate signal handling and audio block/unblock from ausco.c    S001, 21-Mar-95, shawnm@sco.com, sysseh@devetir.qld.gov.au 	SYSSEH incorporate parts of patch from Stephen Hocking */
end_comment

begin_comment
comment|/*  * Copyright 1993 Network Computing Devices, Inc. Copyright (C) Siemens  * Nixdorf Informationssysteme AG 1993  *   * Permission to use, copy, modify, distribute, and sell this software and its  * documentation for any purpose is hereby granted without fee, provided that  * the above copyright notice appear in all copies and that both that  * copyright notice and this permission notice appear in supporting  * documentation, and that the name Network Computing Devices, Inc.  or  * Siemens Nixdorf Informationssysteme AG not be used in advertising or  * publicity pertaining to distribution of this software without specific,  * written prior permission.  *   * THIS SOFTWARE IS PROVIDED `AS-IS'.  NETWORK COMPUTING DEVICES, INC. AND  * SIEMENS NIXDORF INFORMATIONSSYSTEME AG DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE, INCLUDING WITHOUT LIMITATION ALL IMPLIED  * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR  * NONINFRINGEMENT.  IN NO EVENT SHALL NETWORK COMPUTING DEVICES, INC. NOR  * SIEMENS NIXDORF INFORMATIONSSYSTEME AG BE LIABLE FOR ANY DAMAGES  * WHATSOEVER, INCLUDING SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES,  * INCLUDING LOSS OF USE, DATA, OR PROFITS, EVEN IF ADVISED OF THE  * POSSIBILITY THEREOF, AND REGARDLESS OF WHETHER IN AN ACTION IN CONTRACT,  * TORT OR NEGLIGENCE, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  *   * $NCDId: @(#)auvoxware.c,v 1.10 1996/04/24 17:04:19 greg Exp $  *   * Copyright (C) Siemens Nixdorf Informationssysteme AG 1993 All rights reserved  */
end_comment

begin_comment
comment|/*  * Originally from the merge of auvoxware by Amancio Hasty (hasty@netcom.com)  *& auvoxsvr4 by Stephen Hocking (sysseh@devetir.qld.gov.au).  * 16bit fixes and Linux patches supplied by Christian  * Schlichtherle (s_schli@ira.uka.de).  *  * BUGS:  * - When the soundcard can do only 8 bit recording, "aurecord" records  *   twice as long as it should. Is this our fault?  *  * TODO:  * - Adapt the buffer sizes to the current sampling rate,  *   so that we can record/play high quality audio samples without  *   swallows/pauses.  *   Note that setting the buffer size to a fixed maximum will not work,  *   because it causes playing at slow sample rate to pause. :-(  *   I already tried to do this, but it seems that the rest of the server  *   code doesn't recognize the changed buffer sizes. Any help in doing  *   this is welcome!  *   [chris]  * - Support a second input channel for stereo sampling,  *   so that microphone sampling is done on the mono channel  *   while line sampling is done on the stereo channel.  *   [chris]  *  * CHANGELOG:  * - 94/7/2:  *   Completely rewrote this file. Features:  *   + Makes use of two sound cards if available.  *     So you can concurrently record and play samples.  *   + Tested to work with all combinations of 8/16 bit, mono/stereo  *     sound card sampling modes.  *   + Uses a stereo input channel if hardware supports this.  *   + Can play stereo samples on mono sound cards (but who cares?).  *   + Always uses the highest possible audio quality, i.e. 8/16 bit and  *     mono/stereo parameters are fixed while only the sampling rate is  *     variable. This reduces swallows and pauses to the (currently)  *     unavoidable minimum while consuming a little bit more cpu time.  *   + Format conversion stuff is pushed back to the rest of the server code.  *     Only mono/stereo conversion is done here.  *   + Debugging output uses indentation.  *   [chris]  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_decl_stmt
name|FILE
modifier|*
name|yyin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|searchpath
init|=
name|CONFSEARCHPATH
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUGDSPOUT
argument_list|)
operator|||
name|defined
argument_list|(
name|DEBUGDSPIN
argument_list|)
end_if

begin_decl_stmt
name|int
name|dspin
decl_stmt|,
name|dspout
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PRMSG
parameter_list|(
name|x
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|)
define|\
value|if (doDebug) { \     fprintf(stderr, "auvoxware.c:  %*s", debug_msg_indentation, ""); \     fprintf(stderr, (x), (a), (b)); \     fflush(stderr); \   }
end_define

begin_define
define|#
directive|define
name|IDENTMSG
value|(debug_msg_indentation += 2)
end_define

begin_define
define|#
directive|define
name|UNIDENTMSG
value|(debug_msg_indentation -= 2)
end_define

begin_decl_stmt
specifier|static
name|int
name|doDebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|beVerbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_msg_indentation
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"dixstruct.h"
end_include

begin_comment
comment|/* for RESTYPE */
end_comment

begin_include
include|#
directive|include
file|"os.h"
end_include

begin_comment
comment|/* for xalloc/xfree and NULL */
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<machine/soundcard.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcaudioio.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/soundcard.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<audio/audio.h>
end_include

begin_include
include|#
directive|include
file|<audio/Aproto.h>
end_include

begin_include
include|#
directive|include
file|"au.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|sco
end_ifdef

begin_decl_stmt
specifier|static
name|AuBool
name|scoAudioBlocked
init|=
name|AuFalse
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sco */
end_comment

begin_decl_stmt
specifier|static
name|AuBool
name|processFlowEnabled
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SERVER_CLIENT
value|0
end_define

begin_define
define|#
directive|define
name|MIN_MINIBUF_SAMPLES
value|256
end_define

begin_define
define|#
directive|define
name|MAX_MINIBUF_SAMPLES
value|1024
end_define

begin_comment
comment|/* Must be a power of 2 */
end_comment

begin_define
define|#
directive|define
name|auDefaultInputGain
value|AuFixedPointFromSum(50, 0)
end_define

begin_define
define|#
directive|define
name|auDefaultOutputGain
value|AuFixedPointFromSum(50, 0)
end_define

begin_define
define|#
directive|define
name|PhysicalOneTrackBufferSize
define|\
value|PAD4(auMinibufSamples * auNativeBytesPerSample * 1)
end_define

begin_define
define|#
directive|define
name|PhysicalTwoTrackBufferSize
define|\
value|PAD4(auMinibufSamples * auNativeBytesPerSample * 2)
end_define

begin_comment
comment|/* VOXware sound driver mixer control variables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|Letsplay
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|level
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mixerfd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The mixer device */
end_comment

begin_decl_stmt
specifier|static
name|int
name|devmask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmask for supported mixer devices */
end_comment

begin_decl_stmt
specifier|static
name|int
name|recsrc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Currently selected recording sources */
end_comment

begin_decl_stmt
specifier|static
name|int
name|recmask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Supported recording sources */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stereodevs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Channels supporting stereo */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|labels
index|[
name|SOUND_MIXER_NRDEVICES
index|]
init|=
name|SOUND_DEVICE_LABELS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of VOXware driver mixer control variables */
end_comment

begin_decl_stmt
name|int
name|ParseError
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Did we fail to parse conf. file? */
end_comment

begin_decl_stmt
name|SndStat
modifier|*
name|confStat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SndStat
name|sndStatIn
init|=
block|{
operator|-
literal|1
block|,
literal|16
block|,
literal|2
block|,
literal|0
block|,
literal|4000
block|,
literal|44100
block|,
literal|256
block|,
literal|3
block|,
literal|32
block|,
literal|"/dev/dsp"
block|,
literal|0
block|}
decl_stmt|,
name|sndStatOut
init|=
block|{
operator|-
literal|1
block|,
literal|16
block|,
literal|2
block|,
literal|0
block|,
literal|4000
block|,
literal|44100
block|,
literal|256
block|,
literal|3
block|,
literal|32
block|,
literal|"/dev/dsp"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|AuUint8
modifier|*
name|auOutputMono
decl_stmt|,
modifier|*
name|auOutputStereo
decl_stmt|,
modifier|*
name|auInput
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ComponentPtr
name|monoInputDevice
decl_stmt|,
name|stereoInputDevice
decl_stmt|,
name|monoOutputDevice
decl_stmt|,
name|stereoOutputDevice
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|AuInt32
name|auMinibufSamples
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|auPhysicalOutputChangableMask
value|AuCompDeviceGainMask
end_define

begin_define
define|#
directive|define
name|auPhysicalOutputValueMask
define|\
value|(AuCompCommonAllMasks \    | AuCompDeviceMinSampleRateMask \    | AuCompDeviceMaxSampleRateMask \    | AuCompDeviceGainMask \    | AuCompDeviceLocationMask \    | AuCompDeviceChildrenMask)
end_define

begin_define
define|#
directive|define
name|auPhysicalInputChangableMask
define|\
value|(AuCompDeviceGainMask | AuCompDeviceLineModeMask)
end_define

begin_define
define|#
directive|define
name|auPhysicalInputValueMask
define|\
value|(AuCompCommonAllMasks \    | AuCompDeviceMinSampleRateMask \    | AuCompDeviceMaxSampleRateMask \    | AuCompDeviceLocationMask \    | AuCompDeviceGainMask \    | AuCompDeviceChildrenMask)
end_define

begin_function_decl
specifier|static
name|void
name|setPhysicalOutputGain
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setPhysicalInputGainAndLineMode
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|setDebugOn
parameter_list|()
block|{
name|doDebug
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setVerboseOn
parameter_list|()
block|{
name|beVerbose
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|sco
end_ifdef

begin_function
name|AuBlock
name|AuBlockAudio
parameter_list|()
block|{
name|scoAudioBlocked
operator|=
name|AuTrue
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|AuUnBlockAudio
parameter_list|(
name|AuBlock
name|id
parameter_list|)
block|{
name|scoAudioBlocked
operator|=
name|AuFalse
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sco */
end_comment

begin_function
specifier|static
name|int
name|createServerComponents
parameter_list|(
name|auServerDeviceListSize
parameter_list|,
name|auServerBucketListSize
parameter_list|,
name|auServerRadioListSize
parameter_list|,
name|auServerMinRate
parameter_list|,
name|auServerMaxRate
parameter_list|)
name|AuUint32
modifier|*
name|auServerDeviceListSize
decl_stmt|,
decl|*
name|auServerBucketListSize
decl_stmt|,
modifier|*
name|auServerRadioListSize
decl_stmt|,
modifier|*
name|auServerMinRate
decl_stmt|,
modifier|*
name|auServerMaxRate
decl_stmt|;
end_function

begin_block
block|{
name|AuDeviceID
name|stereo
decl_stmt|,
name|mono
decl_stmt|;
name|ComponentPtr
name|d
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|AuUint8
name|formatIn
decl_stmt|,
name|formatOut
decl_stmt|;
name|AuUint32
name|bytesPerSampleIn
decl_stmt|,
name|bytesPerSampleOut
decl_stmt|;
specifier|static
name|AuBool
name|initialized
init|=
name|AuFalse
decl_stmt|;
specifier|extern
name|RESTYPE
name|auComponentType
decl_stmt|;
specifier|extern
name|ComponentPtr
modifier|*
name|auServerDevices
decl_stmt|,
comment|/* array of devices */
modifier|*
name|auServerBuckets
decl_stmt|,
comment|/* array of server owned buckets */
modifier|*
name|auServerRadios
decl_stmt|,
comment|/* array of server owned radios */
name|auDevices
decl_stmt|,
comment|/* list of all devices */
name|auBuckets
decl_stmt|,
comment|/* list of all buckets */
name|auRadios
decl_stmt|;
comment|/* list of all radios */
specifier|extern
name|AuUint32
name|auNumServerDevices
decl_stmt|,
comment|/* number of devices */
name|auNumActions
decl_stmt|,
comment|/* number of defined actions */
name|auNumServerBuckets
decl_stmt|,
comment|/* number of server owned buckets */
name|auNumServerRadios
decl_stmt|;
comment|/* number of server owned radios */
name|PRMSG
argument_list|(
literal|"createServerComponents(...);\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IDENTMSG
expr_stmt|;
operator|*
name|auServerMinRate
operator|=
name|aumax
argument_list|(
name|sndStatIn
operator|.
name|minSampleRate
argument_list|,
name|sndStatOut
operator|.
name|minSampleRate
argument_list|)
expr_stmt|;
operator|*
name|auServerMaxRate
operator|=
name|aumax
argument_list|(
name|sndStatIn
operator|.
name|maxSampleRate
argument_list|,
name|sndStatOut
operator|.
name|maxSampleRate
argument_list|)
expr_stmt|;
name|auNumServerDevices
operator|=
operator|*
name|auServerDeviceListSize
operator|=
operator|*
name|auServerBucketListSize
operator|=
operator|*
name|auServerRadioListSize
operator|=
literal|0
expr_stmt|;
name|formatIn
operator|=
operator|(
name|sndStatIn
operator|.
name|wordSize
operator|==
literal|16
operator|)
condition|?
name|AuFormatLinearSigned16LSB
else|:
name|AuFormatLinearUnsigned8
expr_stmt|;
name|formatOut
operator|=
operator|(
name|sndStatOut
operator|.
name|wordSize
operator|==
literal|16
operator|)
condition|?
name|AuFormatLinearSigned16LSB
else|:
name|AuFormatLinearUnsigned8
expr_stmt|;
name|bytesPerSampleIn
operator|=
name|sndStatIn
operator|.
name|wordSize
operator|/
literal|8
expr_stmt|;
name|bytesPerSampleOut
operator|=
name|sndStatOut
operator|.
name|wordSize
operator|/
literal|8
expr_stmt|;
name|AU_ALLOC_DEVICE
argument_list|(
name|d
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|id
operator|=
name|FakeClientID
argument_list|(
name|SERVER_CLIENT
argument_list|)
expr_stmt|;
name|d
operator|->
name|changableMask
operator|=
name|auPhysicalOutputChangableMask
expr_stmt|;
name|d
operator|->
name|valueMask
operator|=
name|auPhysicalOutputValueMask
expr_stmt|;
name|d
operator|->
name|kind
operator|=
name|AuComponentKindPhysicalOutput
expr_stmt|;
name|d
operator|->
name|use
operator|=
name|AuComponentUseExportMask
expr_stmt|;
name|d
operator|->
name|access
operator|=
name|AuAccessExportMask
operator||
name|AuAccessListMask
expr_stmt|;
name|d
operator|->
name|format
operator|=
name|formatOut
expr_stmt|;
name|d
operator|->
name|numTracks
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|description
operator|.
name|type
operator|=
name|AuStringLatin1
expr_stmt|;
name|d
operator|->
name|description
operator|.
name|string
operator|=
literal|"Mono Channel Output"
expr_stmt|;
name|d
operator|->
name|description
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|d
operator|->
name|description
operator|.
name|string
argument_list|)
expr_stmt|;
name|d
operator|->
name|minSampleRate
operator|=
name|sndStatOut
operator|.
name|minSampleRate
expr_stmt|;
name|d
operator|->
name|maxSampleRate
operator|=
name|sndStatOut
operator|.
name|maxSampleRate
expr_stmt|;
name|d
operator|->
name|location
operator|=
name|AuDeviceLocationCenterMask
operator||
name|AuDeviceLocationInternalMask
expr_stmt|;
name|d
operator|->
name|numChildren
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|minibuf
operator|=
name|auOutputMono
expr_stmt|;
name|d
operator|->
name|minibufSize
operator|=
name|d
operator|->
name|numTracks
operator|*
name|bytesPerSampleOut
operator|*
name|auMinibufSamples
expr_stmt|;
name|d
operator|->
name|physicalDeviceMask
operator|=
name|PhysicalOutputMono
expr_stmt|;
name|AU_ADD_DEVICE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|monoOutputDevice
operator|=
name|d
expr_stmt|;
name|AU_ALLOC_DEVICE
argument_list|(
name|d
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|id
operator|=
name|FakeClientID
argument_list|(
name|SERVER_CLIENT
argument_list|)
expr_stmt|;
name|d
operator|->
name|changableMask
operator|=
name|auPhysicalOutputChangableMask
expr_stmt|;
name|d
operator|->
name|valueMask
operator|=
name|auPhysicalOutputValueMask
expr_stmt|;
name|d
operator|->
name|kind
operator|=
name|AuComponentKindPhysicalOutput
expr_stmt|;
name|d
operator|->
name|use
operator|=
name|AuComponentUseExportMask
expr_stmt|;
name|d
operator|->
name|access
operator|=
name|AuAccessExportMask
operator||
name|AuAccessListMask
expr_stmt|;
name|d
operator|->
name|format
operator|=
name|formatOut
expr_stmt|;
name|d
operator|->
name|numTracks
operator|=
literal|2
expr_stmt|;
name|d
operator|->
name|description
operator|.
name|type
operator|=
name|AuStringLatin1
expr_stmt|;
name|d
operator|->
name|description
operator|.
name|string
operator|=
literal|"Stereo Channel Output"
expr_stmt|;
name|d
operator|->
name|description
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|d
operator|->
name|description
operator|.
name|string
argument_list|)
expr_stmt|;
name|d
operator|->
name|minSampleRate
operator|=
name|sndStatOut
operator|.
name|minSampleRate
expr_stmt|;
name|d
operator|->
name|maxSampleRate
operator|=
name|sndStatOut
operator|.
name|maxSampleRate
expr_stmt|;
name|d
operator|->
name|location
operator|=
name|AuDeviceLocationCenterMask
operator||
name|AuDeviceLocationInternalMask
expr_stmt|;
name|d
operator|->
name|numChildren
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|children
operator|=
operator|(
name|AuID
operator|*
operator|)
operator|(
operator|(
name|AuUint8
operator|*
operator|)
name|d
operator|+
name|PAD4
argument_list|(
sizeof|sizeof
argument_list|(
name|ComponentRec
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|d
operator|->
name|childSwap
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|d
operator|->
name|children
operator|+
name|d
operator|->
name|numChildren
operator|)
expr_stmt|;
name|d
operator|->
name|children
index|[
literal|0
index|]
operator|=
name|monoOutputDevice
operator|->
name|id
expr_stmt|;
name|d
operator|->
name|minibuf
operator|=
name|auOutputStereo
expr_stmt|;
name|d
operator|->
name|minibufSize
operator|=
name|d
operator|->
name|numTracks
operator|*
name|bytesPerSampleOut
operator|*
name|auMinibufSamples
expr_stmt|;
name|d
operator|->
name|physicalDeviceMask
operator|=
name|PhysicalOutputStereo
expr_stmt|;
name|AU_ADD_DEVICE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|stereoOutputDevice
operator|=
name|d
expr_stmt|;
name|AU_ALLOC_DEVICE
argument_list|(
name|d
argument_list|,
operator|(
name|sndStatIn
operator|.
name|isStereo
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|id
operator|=
name|FakeClientID
argument_list|(
name|SERVER_CLIENT
argument_list|)
expr_stmt|;
name|d
operator|->
name|changableMask
operator|=
name|auPhysicalInputChangableMask
expr_stmt|;
name|d
operator|->
name|valueMask
operator|=
name|auPhysicalInputValueMask
expr_stmt|;
name|d
operator|->
name|kind
operator|=
name|AuComponentKindPhysicalInput
expr_stmt|;
name|d
operator|->
name|use
operator|=
name|AuComponentUseImportMask
expr_stmt|;
name|d
operator|->
name|access
operator|=
name|AuAccessImportMask
operator||
name|AuAccessListMask
expr_stmt|;
name|d
operator|->
name|format
operator|=
name|formatIn
expr_stmt|;
name|d
operator|->
name|numTracks
operator|=
name|sndStatIn
operator|.
name|isStereo
operator|+
literal|1
expr_stmt|;
name|d
operator|->
name|description
operator|.
name|type
operator|=
name|AuStringLatin1
expr_stmt|;
name|d
operator|->
name|description
operator|.
name|string
operator|=
operator|(
name|sndStatIn
operator|.
name|isStereo
operator|)
condition|?
literal|"Stereo Channel Input"
else|:
literal|"Mono Channel Input"
expr_stmt|;
name|d
operator|->
name|description
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|d
operator|->
name|description
operator|.
name|string
argument_list|)
expr_stmt|;
name|d
operator|->
name|minSampleRate
operator|=
name|sndStatOut
operator|.
name|minSampleRate
expr_stmt|;
name|d
operator|->
name|maxSampleRate
operator|=
name|sndStatOut
operator|.
name|maxSampleRate
expr_stmt|;
name|d
operator|->
name|location
operator|=
name|AuDeviceLocationRightMask
operator||
name|AuDeviceLocationLeftMask
operator||
name|AuDeviceLocationExternalMask
expr_stmt|;
name|d
operator|->
name|numChildren
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|gain
operator|=
name|auDefaultInputGain
expr_stmt|;
name|d
operator|->
name|minibuf
operator|=
name|auInput
expr_stmt|;
name|d
operator|->
name|minibufSize
operator|=
name|d
operator|->
name|numTracks
operator|*
name|bytesPerSampleIn
operator|*
name|auMinibufSamples
expr_stmt|;
name|d
operator|->
name|physicalDeviceMask
operator|=
operator|(
name|sndStatIn
operator|.
name|isStereo
operator|)
condition|?
name|PhysicalInputStereo
else|:
name|PhysicalInputMono
expr_stmt|;
name|AU_ADD_DEVICE
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|monoInputDevice
operator|=
name|d
expr_stmt|;
comment|/* Should have two input devices - FIXME */
name|stereoInputDevice
operator|=
name|d
expr_stmt|;
comment|/* set the array of server devices */
if|if
condition|(
operator|!
operator|(
name|auServerDevices
operator|=
operator|(
name|ComponentPtr
operator|*
operator|)
name|aualloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ComponentPtr
argument_list|)
operator|*
name|auNumServerDevices
argument_list|)
operator|)
condition|)
block|{
name|UNIDENTMSG
expr_stmt|;
return|return
name|AuBadAlloc
return|;
block|}
name|p
operator|=
name|auServerDevices
expr_stmt|;
name|d
operator|=
name|auDevices
expr_stmt|;
while|while
condition|(
name|d
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|d
expr_stmt|;
name|d
operator|=
name|d
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|initialized
condition|)
block|{
name|initialized
operator|=
name|AuTrue
expr_stmt|;
name|setPhysicalOutputGain
argument_list|(
name|auDefaultOutputGain
argument_list|)
expr_stmt|;
name|setPhysicalInputGainAndLineMode
argument_list|(
name|auDefaultInputGain
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|UNIDENTMSG
expr_stmt|;
return|return
name|AuSuccess
return|;
block|}
end_block

begin_function
specifier|static
name|AuInt32
name|setTimer
parameter_list|(
name|rate
parameter_list|)
name|AuInt32
name|rate
decl_stmt|;
block|{
name|AuInt16
name|timer_ms
decl_stmt|;
name|AuInt32
name|foo
decl_stmt|;
name|struct
name|itimerval
name|ntval
decl_stmt|,
name|otval
decl_stmt|;
name|PRMSG
argument_list|(
literal|"setTimer(rate = %d);\n"
argument_list|,
name|rate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IDENTMSG
expr_stmt|;
comment|/* change timer according to new sample rate */
if|if
condition|(
name|rate
operator|==
literal|0
condition|)
block|{
comment|/* Disable timer case */
name|ntval
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|ntval
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|ntval
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
name|ntval
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timer_ms
operator|=
literal|0x7fff
expr_stmt|;
block|}
else|else
block|{
name|timer_ms
operator|=
operator|(
name|auMinibufSamples
operator|*
literal|500
operator|)
operator|/
name|rate
expr_stmt|;
name|ntval
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|ntval
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
name|timer_ms
operator|*
literal|1000
expr_stmt|;
name|ntval
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|ntval
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
name|timer_ms
operator|*
literal|1000
operator|/
literal|2
expr_stmt|;
block|}
name|foo
operator|=
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|ntval
argument_list|,
operator|&
name|otval
argument_list|)
expr_stmt|;
name|UNIDENTMSG
expr_stmt|;
return|return
name|timer_ms
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|sco
end_ifdef

begin_function
specifier|static
name|void
name|oneMoreTick
parameter_list|()
block|{
name|struct
name|itimerval
name|ntval
decl_stmt|,
name|otval
decl_stmt|;
name|int
name|foo
decl_stmt|;
name|ntval
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|ntval
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|ntval
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|ntval
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|10
expr_stmt|;
name|foo
operator|=
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|ntval
argument_list|,
operator|&
name|otval
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sco */
end_comment

begin_function
specifier|static
name|void
name|setFragmentSize
parameter_list|(
name|sndStatPtr
parameter_list|)
name|SndStat
modifier|*
name|sndStatPtr
decl_stmt|;
block|{
name|int
name|fragarg
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|datarate
decl_stmt|,
name|numfrags
decl_stmt|;
name|datarate
operator|=
name|sndStatPtr
operator|->
name|curSampleRate
expr_stmt|;
if|if
condition|(
name|sndStatPtr
operator|->
name|isStereo
condition|)
name|datarate
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|sndStatPtr
operator|->
name|wordSize
operator|==
literal|16
condition|)
name|datarate
operator|*=
literal|2
expr_stmt|;
name|datarate
operator|/=
literal|2
expr_stmt|;
comment|/* half second */
name|numfrags
operator|=
name|datarate
operator|/
name|MAX_MINIBUF_SAMPLES
expr_stmt|;
if|if
condition|(
name|numfrags
operator|<
name|sndStatPtr
operator|->
name|minFrags
condition|)
name|numfrags
operator|=
name|sndStatPtr
operator|->
name|minFrags
expr_stmt|;
elseif|else
if|if
condition|(
name|numfrags
operator|>
name|sndStatPtr
operator|->
name|maxFrags
condition|)
name|numfrags
operator|=
name|sndStatPtr
operator|->
name|maxFrags
expr_stmt|;
name|j
operator|=
name|MAX_MINIBUF_SAMPLES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|j
condition|;
name|i
operator|++
control|)
comment|/* figure out what power of 2 MAX_MINIBUF_SAMPLES is */
name|j
operator|=
name|j
operator|>>
literal|1
expr_stmt|;
name|fragarg
operator|=
operator|(
name|numfrags
operator|<<
literal|16
operator|)
operator||
name|i
expr_stmt|;
comment|/* numfrags of size MAX_MINIBUF_SAMPLES */
name|ioctl
argument_list|(
name|sndStatPtr
operator|->
name|fd
argument_list|,
name|SNDCTL_DSP_SETFRAGMENT
argument_list|,
operator|&
name|fragarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|AuUint32
name|setSampleRate
parameter_list|(
name|rate
parameter_list|)
name|AuUint32
name|rate
decl_stmt|;
block|{
name|int
name|numSamplesIn
decl_stmt|,
name|numSamplesOut
decl_stmt|;
name|AuBlock
name|l
decl_stmt|;
name|PRMSG
argument_list|(
literal|"setSampleRate(rate = %d);\n"
argument_list|,
name|rate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IDENTMSG
expr_stmt|;
name|l
operator|=
name|AuBlockAudio
argument_list|()
expr_stmt|;
if|if
condition|(
name|sndStatOut
operator|.
name|curSampleRate
operator|!=
name|rate
condition|)
block|{
name|sndStatOut
operator|.
name|curSampleRate
operator|=
name|rate
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SNDCTL_DSP_SETFRAGMENT
argument_list|)
name|setFragmentSize
argument_list|(
operator|&
name|sndStatOut
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ioctl
argument_list|(
name|sndStatOut
operator|.
name|fd
argument_list|,
name|SNDCTL_DSP_SYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|sndStatOut
operator|.
name|fd
argument_list|,
name|SNDCTL_DSP_SPEED
argument_list|,
operator|&
operator|(
name|sndStatOut
operator|.
name|curSampleRate
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sndStatIn
operator|.
name|fd
operator|==
name|sndStatOut
operator|.
name|fd
condition|)
name|sndStatIn
operator|=
name|sndStatOut
expr_stmt|;
elseif|else
if|if
condition|(
name|sndStatIn
operator|.
name|curSampleRate
operator|!=
name|rate
condition|)
block|{
name|sndStatIn
operator|.
name|curSampleRate
operator|=
name|rate
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SNDCTL_DSP_SETFRAGMENT
argument_list|)
name|setFragmentSize
argument_list|(
operator|&
name|sndStatIn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ioctl
argument_list|(
name|sndStatIn
operator|.
name|fd
argument_list|,
name|SNDCTL_DSP_SYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|sndStatIn
operator|.
name|fd
argument_list|,
name|SNDCTL_DSP_SPEED
argument_list|,
operator|&
operator|(
name|sndStatIn
operator|.
name|curSampleRate
operator|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|AUDIO_DRAIN
argument_list|)
if|if
condition|(
name|sndStatOut
operator|.
name|isPCSpeaker
condition|)
name|ioctl
argument_list|(
name|sndStatOut
operator|.
name|fd
argument_list|,
name|AUDIO_DRAIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|AuUnBlockAudio
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|setTimer
argument_list|(
name|rate
argument_list|)
expr_stmt|;
name|UNIDENTMSG
expr_stmt|;
return|return
name|sndStatOut
operator|.
name|curSampleRate
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|serverReset
parameter_list|()
block|{
name|PRMSG
argument_list|(
literal|"serverReset();\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IDENTMSG
expr_stmt|;
name|setTimer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|sco
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sco */
name|PRMSG
argument_list|(
literal|"Audio Synchronisation..."
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AUDIO_DRAIN
argument_list|)
if|if
condition|(
name|sndStatOut
operator|.
name|isPCSpeaker
condition|)
name|ioctl
argument_list|(
name|sndStatOut
operator|.
name|fd
argument_list|,
name|AUDIO_DRAIN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
endif|#
directive|endif
name|ioctl
argument_list|(
name|sndStatIn
operator|.
name|fd
argument_list|,
name|SNDCTL_DSP_SYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndStatOut
operator|.
name|fd
operator|!=
name|sndStatIn
operator|.
name|fd
condition|)
name|ioctl
argument_list|(
name|sndStatOut
operator|.
name|fd
argument_list|,
name|SNDCTL_DSP_SYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|AUDIO_DRAIN
argument_list|)
block|}
endif|#
directive|endif
if|if
condition|(
name|doDebug
condition|)
block|{
name|fputs
argument_list|(
literal|" done.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|UNIDENTMSG
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|sco
name|intervalProc
parameter_list|(
name|int
name|i
parameter_list|)
else|#
directive|else
function|intervalProc
parameter_list|()
endif|#
directive|endif
comment|/* sco */
block|{
specifier|extern
name|void
name|AuProcessData
parameter_list|()
function_decl|;
ifndef|#
directive|ifndef
name|sco
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|processFlowEnabled
condition|)
block|{
name|AuProcessData
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|intervalProc
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|scoAudioBlocked
operator|&&
name|processFlowEnabled
condition|)
name|AuProcessData
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* sco */
block|}
end_function

begin_comment
comment|/**   * Gains are mapped thusly:   *   *   Software   s	0 - 100   *   Hardware   h	0 - 100 **/
end_comment

begin_function
specifier|static
name|void
name|setPhysicalOutputGain
parameter_list|(
name|gain
parameter_list|)
name|AuFixedPoint
name|gain
decl_stmt|;
block|{
name|AuInt32
name|g
init|=
name|AuFixedPointIntegralAddend
argument_list|(
name|gain
argument_list|)
decl_stmt|;
name|AuInt32
name|i
decl_stmt|,
name|gusvolume
decl_stmt|;
if|if
condition|(
name|g
operator|>
literal|100
condition|)
name|g
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|g
operator|<
literal|0
condition|)
name|g
operator|=
literal|0
expr_stmt|;
name|Letsplay
operator|=
name|g
expr_stmt|;
name|gusvolume
operator|=
name|g
operator||
operator|(
name|g
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|mixerfd
operator|!=
operator|-
literal|1
condition|)
name|i
operator|=
name|ioctl
argument_list|(
name|mixerfd
argument_list|,
name|MIXER_WRITE
argument_list|(
name|SOUND_MIXER_PCM
argument_list|)
argument_list|,
operator|&
name|gusvolume
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|AuFixedPoint
name|getPhysicalOutputGain
parameter_list|()
block|{
name|AuInt16
name|outputGain
decl_stmt|;
name|outputGain
operator|=
name|Letsplay
expr_stmt|;
return|return
name|AuFixedPointFromSum
argument_list|(
name|outputGain
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setPhysicalInputGainAndLineMode
parameter_list|(
name|gain
parameter_list|,
name|lineMode
parameter_list|)
name|AuFixedPoint
name|gain
decl_stmt|;
name|AuUint8
name|lineMode
decl_stmt|;
block|{
name|AuInt16
name|g
init|=
name|AuFixedPointIntegralAddend
argument_list|(
name|gain
argument_list|)
decl_stmt|;
name|AuInt16
name|inputAttenuation
decl_stmt|;
name|AuInt16
name|zero
init|=
literal|0
decl_stmt|;
name|AuInt32
name|params
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|g
operator|<
literal|100
condition|)
name|inputAttenuation
operator|=
name|g
expr_stmt|;
else|else
name|inputAttenuation
operator|=
literal|100
expr_stmt|;
name|inputAttenuation
operator|=
name|inputAttenuation
operator|<<
literal|8
operator||
name|inputAttenuation
expr_stmt|;
if|if
condition|(
name|lineMode
operator|==
name|AuDeviceLineModeHigh
condition|)
block|{
name|ioctl
argument_list|(
name|mixerfd
argument_list|,
name|MIXER_WRITE
argument_list|(
name|SOUND_MIXER_MIC
argument_list|)
argument_list|,
operator|&
name|inputAttenuation
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|mixerfd
argument_list|,
name|MIXER_WRITE
argument_list|(
name|SOUND_MIXER_LINE
argument_list|)
argument_list|,
operator|&
name|zero
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lineMode
operator|==
name|AuDeviceLineModeLow
condition|)
block|{
name|ioctl
argument_list|(
name|mixerfd
argument_list|,
name|MIXER_WRITE
argument_list|(
name|SOUND_MIXER_LINE
argument_list|)
argument_list|,
operator|&
name|inputAttenuation
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|mixerfd
argument_list|,
name|MIXER_WRITE
argument_list|(
name|SOUND_MIXER_MIC
argument_list|)
argument_list|,
operator|&
name|zero
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|enableProcessFlow
parameter_list|()
block|{
name|AuUint8
modifier|*
name|p
decl_stmt|;
name|PRMSG
argument_list|(
literal|"enableProcessFlow();\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sco
if|if
condition|(
operator|!
name|processFlowEnabled
condition|)
block|{
endif|#
directive|endif
comment|/* sco */
name|processFlowEnabled
operator|=
name|AuTrue
expr_stmt|;
ifndef|#
directive|ifndef
name|sco
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|intervalProc
argument_list|)
expr_stmt|;
else|#
directive|else
name|setTimer
argument_list|(
name|sndStatOut
operator|.
name|curSampleRate
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sco */
ifdef|#
directive|ifdef
name|sco
block|}
endif|#
directive|endif
comment|/* sco */
block|}
end_function

begin_function
specifier|static
name|void
name|disableProcessFlow
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|sco
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sco */
name|PRMSG
argument_list|(
literal|"disableProcessFlow();\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|sco
if|if
condition|(
name|processFlowEnabled
condition|)
block|{
endif|#
directive|endif
comment|/* sco */
name|ioctl
argument_list|(
name|sndStatOut
operator|.
name|fd
argument_list|,
name|SNDCTL_DSP_SYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|sco
name|ioctl
argument_list|(
name|sndStatOut
operator|.
name|fd
argument_list|,
name|SNDCTL_DSP_SPEED
argument_list|,
operator|&
name|sndStatOut
operator|.
name|curSampleRate
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sco */
if|if
condition|(
name|sndStatOut
operator|.
name|fd
operator|!=
name|sndStatIn
operator|.
name|fd
condition|)
block|{
name|ioctl
argument_list|(
name|sndStatIn
operator|.
name|fd
argument_list|,
name|SNDCTL_DSP_SYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|sco
name|ioctl
argument_list|(
name|sndStatIn
operator|.
name|fd
argument_list|,
name|SNDCTL_DSP_SPEED
argument_list|,
operator|&
name|sndStatIn
operator|.
name|curSampleRate
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sco */
block|}
ifdef|#
directive|ifdef
name|sco
name|oneMoreTick
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|processFlowEnabled
operator|=
name|AuFalse
expr_stmt|;
ifdef|#
directive|ifdef
name|sco
block|}
endif|#
directive|endif
comment|/* sco */
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_function
specifier|inline
endif|#
directive|endif
specifier|static
name|void
name|monoToStereoLinearSigned16LSB
parameter_list|(
name|numSamples
parameter_list|)
name|AuUint32
name|numSamples
decl_stmt|;
block|{
name|AuInt16
modifier|*
name|s
init|=
operator|(
name|AuInt16
operator|*
operator|)
name|monoOutputDevice
operator|->
name|minibuf
decl_stmt|;
name|AuInt16
modifier|*
name|d
init|=
operator|(
name|AuInt16
operator|*
operator|)
name|stereoOutputDevice
operator|->
name|minibuf
decl_stmt|;
while|while
condition|(
name|numSamples
operator|--
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_function
specifier|inline
endif|#
directive|endif
specifier|static
name|void
name|monoToStereoLinearUnsigned8
parameter_list|(
name|numSamples
parameter_list|)
name|AuUint32
name|numSamples
decl_stmt|;
block|{
name|AuUint8
modifier|*
name|s
init|=
operator|(
name|AuUint8
operator|*
operator|)
name|monoOutputDevice
operator|->
name|minibuf
decl_stmt|;
name|AuUint8
modifier|*
name|d
init|=
operator|(
name|AuUint8
operator|*
operator|)
name|stereoOutputDevice
operator|->
name|minibuf
decl_stmt|;
while|while
condition|(
name|numSamples
operator|--
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|writePhysicalOutputsMono
parameter_list|()
block|{
name|AuBlock
name|l
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|bufSize
decl_stmt|;
if|if
condition|(
name|sndStatOut
operator|.
name|isStereo
condition|)
block|{
switch|switch
condition|(
name|monoOutputDevice
operator|->
name|format
condition|)
block|{
case|case
name|AuFormatLinearSigned16LSB
case|:
name|monoToStereoLinearSigned16LSB
argument_list|(
name|monoOutputDevice
operator|->
name|minibufSamples
argument_list|)
expr_stmt|;
break|break;
case|case
name|AuFormatLinearUnsigned8
case|:
name|monoToStereoLinearUnsigned8
argument_list|(
name|monoOutputDevice
operator|->
name|minibufSamples
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* check createServerComponents(...)! */
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|stereoOutputDevice
operator|->
name|minibuf
expr_stmt|;
name|bufSize
operator|=
name|stereoOutputDevice
operator|->
name|bytesPerSample
operator|*
name|monoOutputDevice
operator|->
name|minibufSamples
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|monoOutputDevice
operator|->
name|minibuf
expr_stmt|;
name|bufSize
operator|=
name|monoOutputDevice
operator|->
name|bytesPerSample
operator|*
name|monoOutputDevice
operator|->
name|minibufSamples
expr_stmt|;
block|}
name|l
operator|=
name|AuBlockAudio
argument_list|()
expr_stmt|;
block|{
name|int
name|b
decl_stmt|,
name|w
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
for|for
control|(
name|b
operator|=
name|bufSize
init|;
name|b
operator|>
literal|0
condition|;
name|b
operator|-=
name|w
control|)
block|{
name|w
operator|=
name|write
argument_list|(
name|sndStatOut
operator|.
name|fd
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|p
operator|+=
name|w
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUGDSPOUT
block|{
name|char
name|tempbuf
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tempbuf
argument_list|,
literal|"\nwriteMono buf: %d size: %d\n"
argument_list|,
name|buf
argument_list|,
name|bufSize
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|dspout
argument_list|,
name|tempbuf
argument_list|,
name|strlen
argument_list|(
name|tempbuf
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|dspout
argument_list|,
name|buf
argument_list|,
name|bufSize
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUGDSPOUT */
name|AuUnBlockAudio
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_function
specifier|inline
endif|#
directive|endif
specifier|static
name|void
name|stereoToMonoLinearSigned16LSB
parameter_list|(
name|numSamples
parameter_list|)
name|AuUint32
name|numSamples
decl_stmt|;
block|{
name|AuInt16
modifier|*
name|s
init|=
operator|(
name|AuInt16
operator|*
operator|)
name|stereoOutputDevice
operator|->
name|minibuf
decl_stmt|;
name|AuInt16
modifier|*
name|d
init|=
operator|(
name|AuInt16
operator|*
operator|)
name|monoOutputDevice
operator|->
name|minibuf
decl_stmt|;
while|while
condition|(
name|numSamples
operator|--
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|(
name|s
index|[
literal|0
index|]
operator|+
name|s
index|[
literal|1
index|]
operator|)
operator|/
literal|2
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|linux
argument_list|)
end_if

begin_function
specifier|inline
endif|#
directive|endif
specifier|static
name|void
name|stereoToMonoLinearUnsigned8
parameter_list|(
name|numSamples
parameter_list|)
name|AuUint32
name|numSamples
decl_stmt|;
block|{
name|AuUint8
modifier|*
name|s
init|=
operator|(
name|AuUint8
operator|*
operator|)
name|stereoOutputDevice
operator|->
name|minibuf
decl_stmt|;
name|AuUint8
modifier|*
name|d
init|=
operator|(
name|AuUint8
operator|*
operator|)
name|monoOutputDevice
operator|->
name|minibuf
decl_stmt|;
while|while
condition|(
name|numSamples
operator|--
condition|)
block|{
operator|*
name|d
operator|++
operator|=
operator|(
name|s
index|[
literal|0
index|]
operator|+
name|s
index|[
literal|1
index|]
operator|)
operator|/
literal|2
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|writePhysicalOutputsStereo
parameter_list|()
block|{
name|AuBlock
name|l
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|bufSize
decl_stmt|;
if|if
condition|(
name|sndStatOut
operator|.
name|isStereo
condition|)
block|{
name|buf
operator|=
name|stereoOutputDevice
operator|->
name|minibuf
expr_stmt|;
name|bufSize
operator|=
name|stereoOutputDevice
operator|->
name|bytesPerSample
operator|*
name|stereoOutputDevice
operator|->
name|minibufSamples
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|stereoOutputDevice
operator|->
name|format
condition|)
block|{
case|case
name|AuFormatLinearSigned16LSB
case|:
name|stereoToMonoLinearSigned16LSB
argument_list|(
name|stereoOutputDevice
operator|->
name|minibufSamples
argument_list|)
expr_stmt|;
break|break;
case|case
name|AuFormatLinearUnsigned8
case|:
name|stereoToMonoLinearUnsigned8
argument_list|(
name|stereoOutputDevice
operator|->
name|minibufSamples
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* check createServerComponents(...)! */
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|monoOutputDevice
operator|->
name|minibuf
expr_stmt|;
name|bufSize
operator|=
name|monoOutputDevice
operator|->
name|bytesPerSample
operator|*
name|stereoOutputDevice
operator|->
name|minibufSamples
expr_stmt|;
block|}
name|l
operator|=
name|AuBlockAudio
argument_list|()
expr_stmt|;
block|{
name|int
name|b
decl_stmt|,
name|w
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
for|for
control|(
name|b
operator|=
name|bufSize
init|;
name|b
operator|>
literal|0
condition|;
name|b
operator|-=
name|w
control|)
block|{
name|w
operator|=
name|write
argument_list|(
name|sndStatOut
operator|.
name|fd
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|p
operator|+=
name|w
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUGDSPOUT
block|{
name|char
name|tempbuf
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tempbuf
argument_list|,
literal|"\nwriteStereo buf: %d size: %d\n"
argument_list|,
name|buf
argument_list|,
name|bufSize
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|dspout
argument_list|,
name|tempbuf
argument_list|,
name|strlen
argument_list|(
name|tempbuf
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|dspout
argument_list|,
name|buf
argument_list|,
name|bufSize
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUGDSPOUT */
name|AuUnBlockAudio
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|writePhysicalOutputsBoth
parameter_list|()
block|{
name|AuInt16
modifier|*
name|m
init|=
operator|(
name|AuInt16
operator|*
operator|)
name|monoOutputDevice
operator|->
name|minibuf
decl_stmt|;
name|AuInt16
modifier|*
name|p
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|AuUint8
modifier|*
name|m8
init|=
operator|(
name|AuUint8
operator|*
operator|)
name|monoOutputDevice
operator|->
name|minibuf
decl_stmt|;
name|AuUint8
modifier|*
name|p8
decl_stmt|,
modifier|*
name|s8
decl_stmt|;
name|AuUint32
name|max
init|=
name|aumax
argument_list|(
name|monoOutputDevice
operator|->
name|minibufSamples
argument_list|,
name|stereoOutputDevice
operator|->
name|minibufSamples
argument_list|)
decl_stmt|;
name|AuUint32
name|i
decl_stmt|;
switch|switch
condition|(
name|stereoOutputDevice
operator|->
name|format
condition|)
block|{
case|case
name|AuFormatLinearSigned16LSB
case|:
name|p
operator|=
name|s
operator|=
operator|(
name|AuInt16
operator|*
operator|)
name|stereoOutputDevice
operator|->
name|minibuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
operator|*
name|m
operator|+
operator|*
name|s
operator|++
operator|)
operator|/
literal|2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|*
name|m
operator|++
operator|+
operator|*
name|s
operator|++
operator|)
operator|/
literal|2
expr_stmt|;
block|}
break|break;
case|case
name|AuFormatLinearUnsigned8
case|:
name|p8
operator|=
name|s8
operator|=
operator|(
name|AuUint8
operator|*
operator|)
name|stereoOutputDevice
operator|->
name|minibuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p8
operator|++
operator|=
operator|(
operator|*
name|m8
operator|+
operator|*
name|s8
operator|++
operator|)
operator|/
literal|2
expr_stmt|;
operator|*
name|p8
operator|++
operator|=
operator|(
operator|*
name|m8
operator|++
operator|+
operator|*
name|s8
operator|++
operator|)
operator|/
literal|2
expr_stmt|;
block|}
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|stereoOutputDevice
operator|->
name|minibufSamples
operator|=
name|max
expr_stmt|;
name|writePhysicalOutputsStereo
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|readPhysicalInputs
parameter_list|()
block|{
name|AuBlock
name|l
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|stereoInputDevice
operator|->
name|minibuf
decl_stmt|;
name|int
name|b
decl_stmt|,
name|r
decl_stmt|;
comment|/* Should make use of two input devices - FIXME */
name|l
operator|=
name|AuBlockAudio
argument_list|()
expr_stmt|;
for|for
control|(
name|b
operator|=
name|stereoInputDevice
operator|->
name|bytesPerSample
operator|*
name|auMinibufSamples
init|;
name|b
operator|>
literal|0
condition|;
name|b
operator|-=
name|r
control|)
block|{
name|r
operator|=
name|read
argument_list|(
name|sndStatIn
operator|.
name|fd
argument_list|,
name|p
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|p
operator|+=
name|r
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGDSPIN
block|{
name|char
name|tempbuf
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|tempbuf
argument_list|,
literal|"\nreadInputs buf: %d size: %d\n"
argument_list|,
name|stereoInputDevice
operator|->
name|minibuf
argument_list|,
name|stereoInputDevice
operator|->
name|bytesPerSample
operator|*
name|auMinibufSamples
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|dspin
argument_list|,
name|tempbuf
argument_list|,
name|strlen
argument_list|(
name|tempbuf
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|dspin
argument_list|,
name|stereoInputDevice
operator|->
name|minibuf
argument_list|,
name|stereoInputDevice
operator|->
name|bytesPerSample
operator|*
name|auMinibufSamples
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUGDSPIN */
name|AuUnBlockAudio
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|noop
parameter_list|()
block|{ }
end_function

begin_decl_stmt
specifier|static
name|void
name|setWritePhysicalOutputFunction
argument_list|(
name|flow
argument_list|,
name|funct
argument_list|)
name|CompiledFlowPtr
name|flow
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
modifier|*
name|funct
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|AuUint32
name|mask
init|=
name|flow
operator|->
name|physicalDeviceMask
decl_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|PhysicalOutputMono
operator||
name|PhysicalOutputStereo
operator|)
operator|)
operator|==
operator|(
name|PhysicalOutputMono
operator||
name|PhysicalOutputStereo
operator|)
condition|)
operator|*
name|funct
operator|=
name|writePhysicalOutputsBoth
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|PhysicalOutputMono
condition|)
operator|*
name|funct
operator|=
name|writePhysicalOutputsMono
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|&
name|PhysicalOutputStereo
condition|)
operator|*
name|funct
operator|=
name|writePhysicalOutputsStereo
expr_stmt|;
else|else
operator|*
name|funct
operator|=
name|noop
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Setup soundcard at maximum audio quality.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|NO_16_BIT_SAMPLING
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|setupSoundcard
parameter_list|(
name|sndStatPtr
parameter_list|)
name|SndStat
modifier|*
name|sndStatPtr
decl_stmt|;
block|{
name|int
name|samplesize
decl_stmt|;
name|PRMSG
argument_list|(
literal|"setupSoundcard(...);\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IDENTMSG
expr_stmt|;
if|if
condition|(
name|beVerbose
condition|)
if|if
condition|(
name|sndStatPtr
operator|==
operator|&
name|sndStatOut
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"++ Setting up Output device\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"++ Setting up Input device\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndStatPtr
operator|->
name|isPCSpeaker
condition|)
block|{
if|if
condition|(
name|beVerbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"+++ Device is a PC speaker\n"
argument_list|)
expr_stmt|;
name|sndStatPtr
operator|->
name|curSampleRate
operator|=
name|sndStatPtr
operator|->
name|maxSampleRate
operator|=
name|sndStatPtr
operator|->
name|minSampleRate
operator|=
literal|8000
expr_stmt|;
name|sndStatPtr
operator|->
name|isStereo
operator|=
literal|0
expr_stmt|;
name|sndStatPtr
operator|->
name|wordSize
operator|=
literal|8
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|beVerbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"+++ requesting wordsize of %d, "
argument_list|,
name|sndStatPtr
operator|->
name|wordSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sndStatPtr
operator|->
name|fd
argument_list|,
name|SNDCTL_DSP_SAMPLESIZE
argument_list|,
operator|&
name|sndStatPtr
operator|->
name|wordSize
argument_list|)
operator|||
name|sndStatPtr
operator|->
name|wordSize
operator|!=
literal|16
condition|)
block|{
name|sndStatPtr
operator|->
name|wordSize
operator|=
literal|8
expr_stmt|;
name|ioctl
argument_list|(
name|sndStatPtr
operator|->
name|fd
argument_list|,
name|SNDCTL_DSP_SAMPLESIZE
argument_list|,
operator|&
name|sndStatPtr
operator|->
name|wordSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|beVerbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"got %d\n"
argument_list|,
name|sndStatPtr
operator|->
name|wordSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|beVerbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"+++ requesting %d channel(s), "
argument_list|,
name|sndStatPtr
operator|->
name|isStereo
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|sndStatPtr
operator|->
name|fd
argument_list|,
name|SNDCTL_DSP_STEREO
argument_list|,
operator|&
name|sndStatPtr
operator|->
name|isStereo
argument_list|)
operator|==
operator|-
literal|1
operator|||
operator|!
name|sndStatPtr
operator|->
name|isStereo
condition|)
block|{
name|sndStatPtr
operator|->
name|isStereo
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
name|sndStatPtr
operator|->
name|fd
argument_list|,
name|SNDCTL_DSP_STEREO
argument_list|,
operator|&
name|sndStatPtr
operator|->
name|isStereo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|beVerbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"got %d channel(s)\n"
argument_list|,
name|sndStatPtr
operator|->
name|isStereo
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|beVerbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"+++ Requesting minimum sample rate of %d, "
argument_list|,
name|sndStatPtr
operator|->
name|minSampleRate
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|sndStatPtr
operator|->
name|fd
argument_list|,
name|SNDCTL_DSP_SPEED
argument_list|,
operator|&
name|sndStatPtr
operator|->
name|minSampleRate
argument_list|)
expr_stmt|;
if|if
condition|(
name|beVerbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"got %d\n"
argument_list|,
name|sndStatPtr
operator|->
name|minSampleRate
argument_list|)
expr_stmt|;
if|if
condition|(
name|beVerbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"+++ Requesting maximum sample rate of %d, "
argument_list|,
name|sndStatPtr
operator|->
name|maxSampleRate
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|sndStatPtr
operator|->
name|fd
argument_list|,
name|SNDCTL_DSP_SPEED
argument_list|,
operator|&
name|sndStatPtr
operator|->
name|maxSampleRate
argument_list|)
expr_stmt|;
if|if
condition|(
name|beVerbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"got %d\n"
argument_list|,
name|sndStatPtr
operator|->
name|maxSampleRate
argument_list|)
expr_stmt|;
name|sndStatPtr
operator|->
name|curSampleRate
operator|=
name|sndStatPtr
operator|->
name|maxSampleRate
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SNDCTL_DSP_SETFRAGMENT
argument_list|)
name|setFragmentSize
argument_list|(
name|sndStatPtr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UNIDENTMSG
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|sco
end_ifdef

begin_function
specifier|static
name|AuBool
name|scoInterrupts
parameter_list|()
block|{
name|struct
name|sigaction
name|act
decl_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|intervalProc
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|,
name|SIGALRM
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|act
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ErrorF
argument_list|(
literal|"sigaction SIGALRM"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sco */
end_comment

begin_comment
comment|/* *  Find the config file  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|openConfigFile
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|FILE
modifier|*
name|config
decl_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"AUVoxConfig"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|config
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|config
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|AuBool
name|AuInitPhysicalDevices
parameter_list|()
block|{
specifier|static
name|AuBool
name|AL_initialized
init|=
name|AuFalse
decl_stmt|;
specifier|static
name|AuUint8
modifier|*
name|physicalBuffers
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|AuUint32
name|physicalBuffersSize
decl_stmt|;
specifier|extern
name|AuUint8
modifier|*
name|auPhysicalOutputBuffers
decl_stmt|;
specifier|extern
name|AuUint32
name|auPhysicalOutputBuffersSize
decl_stmt|;
specifier|extern
name|void
name|AuProcessData
parameter_list|()
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|AUDIO_GETINFO
argument_list|)
name|audio_info_t
name|spkrinf
decl_stmt|;
endif|#
directive|endif
name|PRMSG
argument_list|(
literal|"AuInitPhysicalDevices();\n"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IDENTMSG
expr_stmt|;
comment|/*    * create the input and output ports    */
if|if
condition|(
operator|!
name|AL_initialized
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|AuInt32
name|i
decl_stmt|;
name|AL_initialized
operator|=
name|AuTrue
expr_stmt|;
if|if
condition|(
operator|(
name|yyin
operator|=
name|openConfigFile
argument_list|(
name|CONFSEARCHPATH
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|yyparse
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|sndStatOut
operator|.
name|device
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|UNIDENTMSG
expr_stmt|;
return|return
name|AuFalse
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|AUDIO_GETINFO
argument_list|)
if|if
condition|(
name|sndStatOut
operator|.
name|isPCSpeaker
condition|)
block|{
name|ioctl
argument_list|(
name|fd
argument_list|,
name|AUDIO_GETINFO
argument_list|,
operator|&
name|spkrinf
argument_list|)
expr_stmt|;
name|spkrinf
operator|.
name|play
operator|.
name|encoding
operator|=
name|AUDIO_ENCODING_RAW
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|AUDIO_SETINFO
argument_list|,
operator|&
name|spkrinf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUGDSPOUT
name|dspout
operator|=
name|open
argument_list|(
literal|"/tmp/dspout"
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|00666
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUGDSPIN
name|dspin
operator|=
name|open
argument_list|(
literal|"/tmp/dspin"
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|00666
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sndStatOut
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|sndStatIn
operator|.
name|device
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
name|sndStatIn
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
else|else
name|sndStatIn
operator|.
name|fd
operator|=
name|sndStatOut
operator|.
name|fd
expr_stmt|;
name|setupSoundcard
argument_list|(
operator|&
name|sndStatOut
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndStatOut
operator|.
name|fd
operator|!=
name|sndStatIn
operator|.
name|fd
condition|)
name|setupSoundcard
argument_list|(
operator|&
name|sndStatIn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sndStatOut
operator|.
name|isPCSpeaker
condition|)
block|{
if|if
condition|(
operator|(
name|mixerfd
operator|=
name|open
argument_list|(
literal|"/dev/mixer"
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|UNIDENTMSG
expr_stmt|;
return|return
name|AuFalse
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|mixerfd
argument_list|,
name|SOUND_MIXER_READ_DEVMASK
argument_list|,
operator|&
name|devmask
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|close
argument_list|(
name|mixerfd
argument_list|)
expr_stmt|;
name|mixerfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|mixerfd
argument_list|,
name|SOUND_MIXER_READ_RECMASK
argument_list|,
operator|&
name|recmask
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|AuFalse
return|;
block|}
block|{
comment|/* Enable all used recording sources ( mic& line ) and            * control which is active via level setting later. There            * should be a better way to do this!            */
name|int
name|mask
init|=
name|SOUND_MASK_MIC
operator||
name|SOUND_MASK_LINE
decl_stmt|;
comment|/* enable these */
name|mask
operator|&=
name|recmask
expr_stmt|;
comment|/* if supported */
if|if
condition|(
name|ioctl
argument_list|(
name|mixerfd
argument_list|,
name|SOUND_MIXER_WRITE_RECSRC
argument_list|,
operator|&
name|mask
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|AuFalse
return|;
block|}
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|mixerfd
argument_list|,
name|SOUND_MIXER_READ_RECSRC
argument_list|,
operator|&
name|recsrc
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|UNIDENTMSG
expr_stmt|;
return|return
name|AuFalse
return|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|mixerfd
argument_list|,
name|SOUND_MIXER_READ_STEREODEVS
argument_list|,
operator|&
name|stereodevs
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|UNIDENTMSG
expr_stmt|;
return|return
name|AuFalse
return|;
block|}
comment|/* get all sound levels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|&
name|devmask
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|mixerfd
argument_list|,
name|MIXER_READ
argument_list|(
name|i
argument_list|)
argument_list|,
operator|&
name|level
index|[
name|i
index|]
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|UNIDENTMSG
expr_stmt|;
return|return
name|AuFalse
return|;
block|}
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|physicalBuffers
condition|)
name|aufree
argument_list|(
name|physicalBuffers
argument_list|)
expr_stmt|;
name|auMinibufSamples
operator|=
name|MAX_MINIBUF_SAMPLES
expr_stmt|;
comment|/* the output buffers need to be twice as large for output range checking */
name|physicalBuffersSize
operator|=
name|PhysicalTwoTrackBufferSize
operator|+
comment|/* mono/stereo input */
name|PhysicalOneTrackBufferSize
operator|*
literal|2
operator|+
comment|/* mono output */
name|PhysicalTwoTrackBufferSize
operator|*
literal|2
expr_stmt|;
comment|/* stereo output */
if|if
condition|(
operator|!
operator|(
name|physicalBuffers
operator|=
operator|(
name|AuUint8
operator|*
operator|)
name|aualloc
argument_list|(
name|physicalBuffersSize
argument_list|)
operator|)
condition|)
block|{
name|UNIDENTMSG
expr_stmt|;
return|return
name|AuFalse
return|;
block|}
name|auInput
operator|=
name|physicalBuffers
expr_stmt|;
name|auOutputMono
operator|=
name|auInput
operator|+
name|PhysicalTwoTrackBufferSize
expr_stmt|;
name|auOutputStereo
operator|=
name|auOutputMono
operator|+
literal|2
operator|*
name|PhysicalOneTrackBufferSize
expr_stmt|;
name|auPhysicalOutputBuffers
operator|=
name|auOutputMono
expr_stmt|;
name|auPhysicalOutputBuffersSize
operator|=
name|physicalBuffersSize
operator|-
name|PhysicalTwoTrackBufferSize
expr_stmt|;
comment|/*    * Call AuProcessData() in signal handler often enough to drain the    * input devices and keep the output devices full at the current    * sample rate.    */
name|processFlowEnabled
operator|=
name|AuFalse
expr_stmt|;
ifdef|#
directive|ifdef
name|sco
if|if
condition|(
operator|!
name|scoInterrupts
argument_list|()
condition|)
block|{
return|return
name|AuFalse
return|;
block|}
else|#
directive|else
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|intervalProc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sco */
name|setTimer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|AuRegisterCallback
argument_list|(
name|AuCreateServerComponentsCB
argument_list|,
name|createServerComponents
argument_list|)
expr_stmt|;
name|AuRegisterCallback
argument_list|(
name|AuSetPhysicalOutputGainCB
argument_list|,
name|setPhysicalOutputGain
argument_list|)
expr_stmt|;
name|AuRegisterCallback
argument_list|(
name|AuGetPhysicalOutputGainCB
argument_list|,
name|getPhysicalOutputGain
argument_list|)
expr_stmt|;
name|AuRegisterCallback
argument_list|(
name|AuSetPhysicalInputGainAndLineModeCB
argument_list|,
name|setPhysicalInputGainAndLineMode
argument_list|)
expr_stmt|;
name|AuRegisterCallback
argument_list|(
name|AuEnableProcessFlowCB
argument_list|,
name|enableProcessFlow
argument_list|)
expr_stmt|;
name|AuRegisterCallback
argument_list|(
name|AuDisableProcessFlowCB
argument_list|,
name|disableProcessFlow
argument_list|)
expr_stmt|;
name|AuRegisterCallback
argument_list|(
name|AuReadPhysicalInputsCB
argument_list|,
name|readPhysicalInputs
argument_list|)
expr_stmt|;
name|AuRegisterCallback
argument_list|(
name|AuSetWritePhysicalOutputFunctionCB
argument_list|,
name|setWritePhysicalOutputFunction
argument_list|)
expr_stmt|;
name|AuRegisterCallback
argument_list|(
name|AuSetSampleRateCB
argument_list|,
name|setSampleRate
argument_list|)
expr_stmt|;
comment|/* bogus resource so we can have a cleanup function at server reset */
name|AddResource
argument_list|(
name|FakeClientID
argument_list|(
name|SERVER_CLIENT
argument_list|)
argument_list|,
name|CreateNewResourceType
argument_list|(
name|serverReset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNIDENTMSG
expr_stmt|;
return|return
name|AuTrue
return|;
block|}
end_function

end_unit

