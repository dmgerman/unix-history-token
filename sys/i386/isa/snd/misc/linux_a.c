begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * TiMidity -- Experimental MIDI to WAVE converter Copyright (C) 1995 Tuukka  * Toivonen<toivonen@clinet.fi>  *   * This program is free software; you can redistribute it and/or modify it under  * the terms of the GNU General Public License as published by the Free  * Software Foundation; either version 2 of the License, or (at your option)  * any later version.  *   * This program is distributed in the hope that it will be useful, but WITHOUT  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for  * more details.  *   * You should have received a copy of the GNU General Public License along with  * this program; if not, write to the Free Software Foundation, Inc., 675  * Mass Ave, Cambridge, MA 02139, USA.  *   * linux_audio.c  *   * Functions to play sound on the VoxWare audio driver (Linux or FreeBSD)  *   */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_comment
comment|/* new with 1.2.0? Didn't need this under 				 * 1.1.64 */
end_comment

begin_include
include|#
directive|include
file|<linux/soundcard.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<machine/soundcard.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"output.h"
end_include

begin_include
include|#
directive|include
file|"controls.h"
end_include

begin_function_decl
specifier|static
name|int
name|open_output
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 0=success, 1=warning, -1=fatal 					 * error */
end_comment

begin_function_decl
specifier|static
name|void
name|close_output
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_data
parameter_list|(
name|int32
modifier|*
name|buf
parameter_list|,
name|int32
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flush_output
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|purge_output
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* export the playback mode */
end_comment

begin_define
define|#
directive|define
name|dpm
value|linux_play_mode
end_define

begin_decl_stmt
name|PlayMode
name|dpm
init|=
block|{
name|DEFAULT_RATE
block|,
name|PE_16BIT
operator||
name|PE_SIGNED
block|,
operator|-
literal|1
block|,
block|{
literal|0
block|}
block|,
comment|/* default: get all the buffer fragments you 				 * can */
literal|"Linux dsp device"
block|,
literal|'d'
block|,
literal|"/dev/dsp"
block|,
name|open_output
block|,
name|close_output
block|,
name|output_data
block|,
name|flush_output
block|,
name|purge_output
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************************************************************/
end_comment

begin_comment
comment|/*  * We currently only honor the PE_MONO bit, the sample rate, and the number  * of buffer fragments. We try 16-bit signed data first, and then 8-bit  * unsigned if it fails. If you have a sound device that can't handle either,  * let me know.  */
end_comment

begin_function
specifier|static
name|int
name|open_output
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|tmp
decl_stmt|,
name|i
decl_stmt|,
name|warnings
init|=
literal|0
decl_stmt|;
comment|/* Open the audio device */
name|fd
operator|=
name|open
argument_list|(
name|dpm
operator|.
name|name
argument_list|,
name|O_RDWR
comment|/* | O_NDELAY */
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|ctl
operator|->
name|cmsg
argument_list|(
name|CMSG_ERROR
argument_list|,
name|VERB_NORMAL
argument_list|,
literal|"%s: %s"
argument_list|,
name|dpm
operator|.
name|name
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* They can't mean these */
name|dpm
operator|.
name|encoding
operator|&=
operator|~
operator|(
name|PE_ULAW
operator||
name|PE_BYTESWAP
operator|)
expr_stmt|;
comment|/*      * Set sample width to whichever the user wants. If it fails, try the      * other one.      */
name|i
operator|=
name|tmp
operator|=
operator|(
name|dpm
operator|.
name|encoding
operator|&
name|PE_16BIT
operator|)
condition|?
literal|16
else|:
literal|8
expr_stmt|;
if|if
condition|(
name|dpm
operator|.
name|encoding
operator|&
name|PE_16BIT
condition|)
block|{
name|int
name|fmt
init|=
name|AFMT_S16_LE
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_SETFMT
argument_list|,
operator|&
name|fmt
argument_list|)
operator|<
literal|0
operator|||
name|fmt
operator|!=
name|AFMT_S16_LE
condition|)
block|{
name|fmt
operator|=
name|AFMT_U8
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_SETFMT
argument_list|,
operator|&
name|fmt
argument_list|)
operator|<
literal|0
operator|||
name|fmt
operator|!=
name|AFMT_U8
condition|)
block|{
name|ctl
operator|->
name|cmsg
argument_list|(
name|CMSG_ERROR
argument_list|,
name|VERB_NORMAL
argument_list|,
literal|"%s doesn't support 16- or 8-bit sample width"
argument_list|,
name|dpm
operator|.
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ctl
operator|->
name|cmsg
argument_list|(
name|CMSG_WARNING
argument_list|,
name|VERB_VERBOSE
argument_list|,
literal|"Sample width adjusted to %d bits"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|dpm
operator|.
name|encoding
operator|^=
name|PE_16BIT
expr_stmt|;
name|warnings
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dpm
operator|.
name|encoding
operator|&
name|PE_16BIT
condition|)
name|dpm
operator|.
name|encoding
operator||=
name|PE_SIGNED
expr_stmt|;
else|else
name|dpm
operator|.
name|encoding
operator|&=
operator|~
name|PE_SIGNED
expr_stmt|;
comment|/*      * Try stereo or mono, whichever the user wants. If it fails, try the      * other.      */
name|i
operator|=
name|tmp
operator|=
operator|(
name|dpm
operator|.
name|encoding
operator|&
name|PE_MONO
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_STEREO
argument_list|,
operator|&
name|tmp
argument_list|)
operator|<
literal|0
operator|)
operator|||
name|tmp
operator|!=
name|i
condition|)
block|{
name|i
operator|=
name|tmp
operator|=
operator|(
name|dpm
operator|.
name|encoding
operator|&
name|PE_MONO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_STEREO
argument_list|,
operator|&
name|tmp
argument_list|)
operator|<
literal|0
operator|)
operator|||
name|tmp
operator|!=
name|i
condition|)
block|{
name|ctl
operator|->
name|cmsg
argument_list|(
name|CMSG_ERROR
argument_list|,
name|VERB_NORMAL
argument_list|,
literal|"%s doesn't support mono or stereo samples"
argument_list|,
name|dpm
operator|.
name|name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
name|dpm
operator|.
name|encoding
operator||=
name|PE_MONO
expr_stmt|;
else|else
name|dpm
operator|.
name|encoding
operator|&=
operator|~
name|PE_MONO
expr_stmt|;
name|ctl
operator|->
name|cmsg
argument_list|(
name|CMSG_WARNING
argument_list|,
name|VERB_VERBOSE
argument_list|,
literal|"Sound adjusted to %sphonic"
argument_list|,
operator|(
name|tmp
operator|==
literal|0
operator|)
condition|?
literal|"mono"
else|:
literal|"stereo"
argument_list|)
expr_stmt|;
name|warnings
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Set the sample rate */
name|tmp
operator|=
name|dpm
operator|.
name|rate
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_SPEED
argument_list|,
operator|&
name|tmp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ctl
operator|->
name|cmsg
argument_list|(
name|CMSG_ERROR
argument_list|,
name|VERB_NORMAL
argument_list|,
literal|"%s doesn't support a %d Hz sample rate"
argument_list|,
name|dpm
operator|.
name|name
argument_list|,
name|dpm
operator|.
name|rate
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|tmp
operator|!=
name|dpm
operator|.
name|rate
condition|)
block|{
name|dpm
operator|.
name|rate
operator|=
name|tmp
expr_stmt|;
name|ctl
operator|->
name|cmsg
argument_list|(
name|CMSG_WARNING
argument_list|,
name|VERB_VERBOSE
argument_list|,
literal|"Output rate adjusted to %d Hz"
argument_list|,
name|dpm
operator|.
name|rate
argument_list|)
expr_stmt|;
name|warnings
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Older VoxWare drivers don't have buffer fragment capabilities */
ifdef|#
directive|ifdef
name|SNDCTL_DSP_SETFRAGMENT
comment|/* Set buffer fragments (in extra_param[0]) */
name|tmp
operator|=
literal|2
operator|+
name|AUDIO_BUFFER_BITS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dpm
operator|.
name|encoding
operator|&
name|PE_MONO
operator|)
condition|)
name|tmp
operator|++
expr_stmt|;
if|if
condition|(
name|dpm
operator|.
name|encoding
operator|&
name|PE_16BIT
condition|)
name|tmp
operator|++
expr_stmt|;
name|tmp
operator||=
operator|(
name|dpm
operator|.
name|extra_param
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
expr_stmt|;
name|i
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_SETFRAGMENT
argument_list|,
operator|&
name|tmp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ctl
operator|->
name|cmsg
argument_list|(
name|CMSG_WARNING
argument_list|,
name|VERB_NORMAL
argument_list|,
literal|"%s doesn't support %d-byte buffer fragments"
argument_list|,
name|dpm
operator|.
name|name
argument_list|,
operator|(
literal|1
operator|<<
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * It should still work in some fashion. We should use a secondary 	 * buffer anyway -- 64k isn't enough. 	 */
name|warnings
operator|=
literal|1
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|dpm
operator|.
name|extra_param
index|[
literal|0
index|]
condition|)
block|{
name|ctl
operator|->
name|cmsg
argument_list|(
name|CMSG_WARNING
argument_list|,
name|VERB_NORMAL
argument_list|,
literal|"%s doesn't support buffer fragments"
argument_list|,
name|dpm
operator|.
name|name
argument_list|)
expr_stmt|;
name|warnings
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|dpm
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
return|return
name|warnings
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_data
parameter_list|(
name|int32
modifier|*
name|buf
parameter_list|,
name|int32
name|count
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|res
decl_stmt|,
name|l
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dpm
operator|.
name|encoding
operator|&
name|PE_MONO
operator|)
condition|)
name|count
operator|*=
literal|2
expr_stmt|;
comment|/* Stereo samples */
if|if
condition|(
name|dpm
operator|.
name|encoding
operator|&
name|PE_16BIT
condition|)
block|{
comment|/* Convert data to signed 16-bit PCM */
name|s32tos16
argument_list|(
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|res
operator|=
name|count
operator|*
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Convert to 8-bit unsigned and write out. */
name|s32tou8
argument_list|(
name|buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|res
operator|=
name|count
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|buf
init|;
name|res
operator|>
literal|0
condition|;
name|res
operator|-=
name|l
control|)
block|{
name|l
operator|=
name|write
argument_list|(
name|dpm
operator|.
name|fd
argument_list|,
name|p
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<
literal|0
condition|)
return|return ;
name|p
operator|+=
name|l
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|close_output
parameter_list|(
name|void
parameter_list|)
block|{
name|close
argument_list|(
name|dpm
operator|.
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flush_output
parameter_list|(
name|void
parameter_list|)
block|{
name|ioctl
argument_list|(
name|dpm
operator|.
name|fd
argument_list|,
name|SNDCTL_DSP_SYNC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|purge_output
parameter_list|(
name|void
parameter_list|)
block|{
name|ioctl
argument_list|(
name|dpm
operator|.
name|fd
argument_list|,
name|SNDCTL_DSP_RESET
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

