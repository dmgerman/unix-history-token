begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * snd/dmabuf.c  *   * New DMA routines -- Luigi Rizzo, 19 jul 97  * This file implements the new DMA routines for the sound driver.  *  * Copyright by Luigi Rizzo - 1997  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/snd/sound.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/snd/ulaw.h>
end_include

begin_define
define|#
directive|define
name|MIN_CHUNK_SIZE
value|256
end_define

begin_comment
comment|/* for uiomove etc. */
end_comment

begin_define
define|#
directive|define
name|DMA_ALIGN_BITS
value|2
end_define

begin_comment
comment|/* i.e. 4 bytes */
end_comment

begin_define
define|#
directive|define
name|DMA_ALIGN_THRESHOLD
value|(1<< DMA_ALIGN_BITS)
end_define

begin_define
define|#
directive|define
name|DMA_ALIGN_MASK
value|(~ (DMA_ALIGN_THRESHOLD - 1))
end_define

begin_function_decl
specifier|static
name|void
name|dsp_wr_dmadone
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dsp_rd_dmadone
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  *  SOUND OUTPUT  We use a circular buffer to store samples directed to the DAC. The buffer is split into three variable-size regions, each identified by an offset in the buffer (dp,rp,fp) and a lenght (dl,rl,fl).        0          dp,dl        rp,rl         fp,fl    bufsize       |__________|_____>______|_____________|________| 	  FREE        DMA          READY      FREE        READY region: contains data written from the process and ready       to be sent to the DAC;    FREE region: is the empty region of the buffer, where a process       can write new data.    DMA region: contains data being sent to the DAC by the DMA engine.       the actual boundary between the FREE and READY regions is in       fact within the DMA region (indicated by the> symbol above),       and advances as the DMA engine makes progress.  Both the "READY" and "FREE" regions can wrap around the end of the buffer. The "DMA" region can only wrap if AUTO DMA is used, otherwise it cannot cross the end of the buffer.  Since dl can be updated on the fly, dl0 marks the value used when the operation was started. When using AUTO DMA, bufsize-(count in the ISA DMA register) directly reflects the position of dp.  At initialization, DMA and READY are empty, and FREE takes all the available space:      dp = rp = fp = 0 ;	--  beginning of buffer     dl0 = dl = 0 ;	-- meaning no dma activity     rl = 0 ;		-- meaning no data ready     fl = bufsize ;  The DMA region is also empty whenever there is no DMA activity, for whatever reason (e.g. no ready data, or output is paused). The code works as follows: the user write routine dsp_write_body() fills up the READY region with new data (reclaiming space from the FREE region) and starts the write DMA engine if inactive (activity is indicated by d->flags& SND_F_WR_DMA ). The size of each DMA transfer is chosen according to a series of rules which will be discussed later. When a DMA transfer is complete, an interrupt causes dsp_wrintr() to be called which empties the DMA region, extends the FREE region and possibly starts the next transfer.  In some cases, the code tries to track the current status of DMA operations by calling isa_dmastatus() and advancing the boundary between FREE and DMA regions accordingly.  The size of a DMA transfer is selected according to the following rules:    1. when not using AUTO DMA, do not wrap around the end of the      buffer, and do not let fp move too close to the end of the      buffer;    2. do not use more than half of the buffer size.      This serves to allow room for a next write operation concurrent      with the dma transfer, and to reduce the time which is necessary      to wait before a pending dma will end (optionally, the max      size could be further limited to a fixed amount of play time,      depending on number of channels, sample size and sample speed);    3. use the current blocksize (either specified by the user, or      corresponding roughly to 0.25s of data);    *   */
end_comment

begin_comment
comment|/*  * dsp_wr_dmadone moves the write DMA region into the FREE region.  * It is assumed to be called at spltty() and with a write dma  * previously started.  */
end_comment

begin_function
specifier|static
name|void
name|dsp_wr_dmadone
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
decl_stmt|;
name|isa_dmadone
argument_list|(
name|B_WRITE
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|dp
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|d
operator|->
name|dma1
argument_list|)
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|b
operator|->
name|dl
expr_stmt|;
comment|/* make dl bytes free */
comment|/*      * XXX here it would be more efficient to record if there      * actually is a sleeping process, but this should still work.      */
name|wakeup
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* wakeup possible sleepers */
if|if
condition|(
name|d
operator|->
name|wsel
operator|.
name|si_pid
operator|&&
operator|(
operator|!
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_HAS_SIZE
operator|)
operator|||
name|b
operator|->
name|fl
operator|>=
name|d
operator|->
name|play_blocksize
operator|)
condition|)
name|selwakeup
argument_list|(
operator|&
name|d
operator|->
name|wsel
argument_list|)
expr_stmt|;
name|b
operator|->
name|dp
operator|=
name|b
operator|->
name|rp
expr_stmt|;
name|b
operator|->
name|dl0
operator|=
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The following function tracks the status of a (write) dma transfer,  * and moves the boundary between the FREE and the DMA regions.  * It works under the following assumptions:  *   - the DMA engine is running;  *   - the routine is called with interrupts blocked.  * BEWARE: when using AUTO DMA, dl can go negative! We assume that it  * does not wrap!  */
end_comment

begin_function
name|void
name|dsp_wr_dmaupdate
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|b
operator|->
name|dl
operator|-
name|isa_dmastatus1
argument_list|(
name|d
operator|->
name|dma1
argument_list|)
expr_stmt|;
name|tmp
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* align... */
if|if
condition|(
name|tmp
operator|>
literal|0
condition|)
block|{
comment|/* we have some new data */
name|b
operator|->
name|dp
operator|+=
name|tmp
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dp
operator|>=
name|b
operator|->
name|bufsize
condition|)
name|b
operator|->
name|dp
operator|-=
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|dl
operator|-=
name|tmp
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Write interrupt routine. Can be called from other places, but  * with interrupts disabled.  */
end_comment

begin_function
name|void
name|dsp_wrintr
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
decl_stmt|;
name|int
name|cb_reason
init|=
name|SND_CB_WR
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp_wrintr: start on dl %d, rl %d, fl %d\n"
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WR_DMA
condition|)
block|{
comment|/* dma was active */
name|b
operator|->
name|int_count
operator|++
expr_stmt|;
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_WR_DMA
expr_stmt|;
name|cb_reason
operator|=
name|SND_CB_WR
operator||
name|SND_CB_RESTART
expr_stmt|;
name|dsp_wr_dmadone
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|cb_reason
operator|=
name|SND_CB_WR
operator||
name|SND_CB_START
expr_stmt|;
comment|/*      * start another dma operation only if have ready data in the      * buffer, there is no pending abort, have a full-duplex device      * (dma1 != dma2) or have half duplex device and there is no      * pending op on the other side.      *      * Force transfer to be aligned to a boundary of 4, which is      * needed when doing stereo and 16-bit. We could make this      * adaptive, but why bother for now...      */
if|if
condition|(
name|b
operator|->
name|rl
operator|>=
name|DMA_ALIGN_THRESHOLD
operator|&&
operator|!
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_ABORTING
operator|)
operator|&&
operator|(
operator|(
name|d
operator|->
name|dma1
operator|!=
name|d
operator|->
name|dma2
operator|)
operator|||
operator|!
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_READING
operator|)
operator|)
condition|)
block|{
name|b
operator|->
name|dl
operator|=
name|min
argument_list|(
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|rp
argument_list|)
expr_stmt|;
comment|/* do not wrap */
name|b
operator|->
name|dl
operator|=
name|min
argument_list|(
name|b
operator|->
name|dl
argument_list|,
name|d
operator|->
name|play_blocksize
argument_list|)
expr_stmt|;
comment|/* avoid too large transfer */
name|b
operator|->
name|dl
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* realign things */
name|b
operator|->
name|rl
operator|-=
name|b
operator|->
name|dl
expr_stmt|;
name|b
operator|->
name|rp
operator|+=
name|b
operator|->
name|dl
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|rp
operator|==
name|b
operator|->
name|bufsize
condition|)
name|b
operator|->
name|rp
operator|=
literal|0
expr_stmt|;
comment|/*          * now try to avoid too small dma transfers in the near future.          * This can happen if I let rp start too close to the end of          * the buffer. If this happens, and have enough data, try to          * split the available block in two approx. equal parts. 	 * XXX this code can go when we use auto dma.          */
if|if
condition|(
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|rp
operator|<
name|MIN_CHUNK_SIZE
operator|&&
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|dp
operator|>
literal|2
operator|*
name|MIN_CHUNK_SIZE
condition|)
block|{
name|b
operator|->
name|dl
operator|=
operator|(
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|dp
operator|)
operator|/
literal|2
expr_stmt|;
name|b
operator|->
name|dl
operator|&=
operator|~
literal|3
expr_stmt|;
comment|/* align to a boundary of 4 */
name|b
operator|->
name|rl
operator|+=
operator|(
name|b
operator|->
name|rp
operator|-
operator|(
name|b
operator|->
name|dp
operator|+
name|b
operator|->
name|dl
operator|)
operator|)
expr_stmt|;
name|b
operator|->
name|rp
operator|=
name|b
operator|->
name|dp
operator|+
name|b
operator|->
name|dl
expr_stmt|;
comment|/* no need to check for wraps */
block|}
comment|/* 	 * how important is the order of operations ? 	 */
if|if
condition|(
name|b
operator|->
name|dl
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ouch... want to start for 0 bytes!\n"
argument_list|)
expr_stmt|;
goto|goto
name|ferma
goto|;
block|}
name|b
operator|->
name|dl0
operator|=
name|b
operator|->
name|dl
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|d
operator|->
name|callback
condition|)
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|cb_reason
argument_list|)
expr_stmt|;
comment|/* start/restart dma */
name|isa_dmastart
argument_list|(
name|B_WRITE
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|dp
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|d
operator|->
name|dma1
argument_list|)
expr_stmt|;
name|d
operator|->
name|flags
operator||=
name|SND_F_WR_DMA
expr_stmt|;
block|}
else|else
block|{
name|ferma
label|:
if|if
condition|(
name|d
operator|->
name|callback
operator|&&
operator|(
name|cb_reason
operator|&
name|SND_CB_REASON_MASK
operator|)
operator|==
name|SND_CB_RESTART
condition|)
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_WR
operator||
name|SND_CB_STOP
argument_list|)
expr_stmt|;
comment|/* stop dma */
comment|/* 	 * if switching to read, should start the read dma... 	 */
if|if
condition|(
name|d
operator|->
name|dma1
operator|==
name|d
operator|->
name|dma2
operator|&&
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_READING
operator|)
condition|)
name|dsp_rdintr
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"cannot start wr-dma flags 0x%08x dma_dl %d rl %d\n"
argument_list|,
name|d
operator|->
name|flags
argument_list|,
name|isa_dmastatus1
argument_list|(
name|d
operator|->
name|dma1
argument_list|)
argument_list|,
name|b
operator|->
name|rl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * user write routine  *  * advance the boundary between READY and FREE, fill the space with  * uiomove(), and possibly start DMA. Do the above until the transfer  * is complete.  *   * To minimize latency in case a pending DMA transfer is about to end,  * we do the transfer in pieces of increasing sizes, extending the  * READY area at every checkpoint. In the (necessary) assumption that  * memory bandwidth is larger than the rate at which the dma consumes  * data, we reduce the latency to something proportional to the length  * of the first piece, while keeping the overhead low and being able  * to feed the DMA with large blocks.  */
end_comment

begin_function
name|int
name|dsp_write_body
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|timeout
init|=
literal|1
decl_stmt|,
name|n
decl_stmt|,
name|l
decl_stmt|,
name|bsz
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|long
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
decl_stmt|;
comment|/* assume d->flags |= SND_F_WRITING ; has been done before */
comment|/*      * bsz is the max size for the next transfer. If the dma was      * idle, we want it as large as possible. Otherwise, start with      * a small block to avoid underruns if we are close to the end of      * the previous operation.      */
name|bsz
operator|=
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WR_DMA
operator|)
condition|?
name|MIN_CHUNK_SIZE
else|:
name|b
operator|->
name|bufsize
expr_stmt|;
while|while
condition|(
name|n
operator|=
name|buf
operator|->
name|uio_resid
condition|)
block|{
name|l
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|bsz
argument_list|)
expr_stmt|;
comment|/* at most n bytes ... */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* no interrupts here ... */
comment|/* 	 * if i) the dma engine is running, ii) we do not have enough space 	 * in the FREE region, and iii) the current DMA transfer might let 	 * us complete the _whole_ transfer without sleeping, or we are doing 	 * non-blocking I/O, then try to extend the FREE region. 	 * Otherwise do not bother, we will need to sleep anyways, and 	 * make the timeout longer. 	 */
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WR_DMA
operator|&&
name|b
operator|->
name|fl
operator|<
name|l
operator|&&
operator|(
name|b
operator|->
name|fl
operator|+
name|b
operator|->
name|dl
operator|>=
name|n
operator|||
name|d
operator|->
name|flags
operator|&
name|SND_F_NBIO
operator|)
condition|)
name|dsp_wr_dmaupdate
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* should really change timeout... */
else|else
name|timeout
operator|=
name|hz
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|l
argument_list|,
name|b
operator|->
name|fl
argument_list|)
expr_stmt|;
comment|/* no more than avail. space */
name|l
operator|=
name|min
argument_list|(
name|l
argument_list|,
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|fp
argument_list|)
expr_stmt|;
comment|/* do not wrap ... */
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp_write_body: prepare %d bytes out of %d\n"
argument_list|,
name|l
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * at this point, we assume that if l==0 the dma engine 	 * must (or will, in cause it is paused) be running. 	 */
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
comment|/* no space, must sleep */
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_NBIO
condition|)
block|{
comment|/* unless of course we are doing non-blocking i/o */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp_write_body: l=0, (fl %d) sleeping\n"
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"dspwr"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
condition|)
name|d
operator|->
name|flags
operator||=
name|SND_F_ABORTING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERESTART
operator|||
name|ret
operator|==
name|EINTR
condition|)
break|break ;
name|timeout
operator|=
name|min
argument_list|(
literal|2
operator|*
name|timeout
argument_list|,
name|hz
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|1
expr_stmt|;
comment|/* we got some data... */
comment|/* 	 * copy data to the buffer, and possibly do format 	 * conversions (here, from ULAW to U8). 	 * NOTE: I can use fp here since it is not modified by the 	 * interrupt routines. 	 */
name|ret
operator|=
name|uiomove
argument_list|(
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|fp
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
comment|/* an error occurred ... */
name|printf
argument_list|(
literal|"uiomove error %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
break|break ;
block|}
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_XLAT8
condition|)
name|translate_bytes
argument_list|(
name|ulaw_dsp
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|fp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* no interrupts here ... */
name|b
operator|->
name|rl
operator|+=
name|l
expr_stmt|;
comment|/* this more ready bytes */
name|b
operator|->
name|fl
operator|-=
name|l
expr_stmt|;
comment|/* this less free bytes */
name|b
operator|->
name|fp
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|fp
operator|>=
name|b
operator|->
name|bufsize
condition|)
comment|/* handle wraps */
name|b
operator|->
name|fp
operator|-=
name|b
operator|->
name|bufsize
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WR_DMA
operator|)
condition|)
block|{
comment|/* dma was idle, restart it */
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
operator|(
name|SND_F_INIT
operator||
name|SND_F_WR_DMA
operator||
name|SND_F_RD_DMA
operator|)
operator|)
operator|==
name|SND_F_INIT
condition|)
block|{
comment|/* want to init but no pending DMA activity */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_INIT
argument_list|)
expr_stmt|;
comment|/* this is slow! */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
block|}
name|dsp_wrintr
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bsz
operator|=
name|min
argument_list|(
name|b
operator|->
name|bufsize
argument_list|,
name|bsz
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* no interrupts here ... */
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_WRITING
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_ABORTING
condition|)
block|{
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_ABORTING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dsp_wrabort
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * SOUND INPUT  *  The input part is similar to the output one. The only difference is in the ordering of regions, which is the following:        0          rp,rl        dp,dl         fp,fl    bufsize       |__________|____________|______>______|________| 	  FREE       READY          DMA       FREE      and the fact that input data are in the READY region.  At initialization, as for the write routine, DMA and READY are empty, and FREE takes all the space:      dp = rp = fp = 0 ;	-- beginning of buffer     dl0 = dl = 0 ;	-- meaning no dma activity     rl = 0 ;		-- meaning no data ready     fl = bufsize ;  Operation is as follows: upon user read (dsp_read_body()) a DMA read is started if not already active (marked by d->flags& SND_F_RD_DMA), then as soon as data are available in the READY region they are transferred to the user buffer, thus advancing the boundary between FREE and READY. Upon interrupts, caused by a completion of a DMA transfer, the READY region is extended and possibly a new transfer is started.  When necessary, isa_dmastatus() is called to advance the boundary between READY and DMA to the real position.  The rules to choose the size of the new DMA area are similar to the other case, i.e:    1. if not using AUTO mode, do not wrap around the end of the      buffer, and do not let fp move too close to the end of the      buffer;    2. do not use more than half the buffer size; this serves to      leave room for the next dma operation.    3. use the default blocksize, either user-specified, or      corresponding to 0.25s of data;   *  */
end_comment

begin_comment
comment|/*  * dsp_rd_dmadone moves bytes in the input buffer from DMA region to  * READY region. We assume it is called at spltty() and  with dl>0   */
end_comment

begin_function
specifier|static
name|void
name|dsp_rd_dmadone
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
decl_stmt|;
name|isa_dmadone
argument_list|(
name|B_READ
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|dp
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|d
operator|->
name|dma2
argument_list|)
expr_stmt|;
name|b
operator|->
name|rl
operator|+=
name|b
operator|->
name|dl
expr_stmt|;
comment|/* make dl bytes available */
name|wakeup
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* wakeup possibly sleeping processes */
if|if
condition|(
name|d
operator|->
name|rsel
operator|.
name|si_pid
operator|&&
operator|(
operator|!
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_HAS_SIZE
operator|)
operator|||
name|b
operator|->
name|rl
operator|>=
name|d
operator|->
name|rec_blocksize
operator|)
condition|)
name|selwakeup
argument_list|(
operator|&
name|d
operator|->
name|rsel
argument_list|)
expr_stmt|;
name|b
operator|->
name|dp
operator|=
name|b
operator|->
name|fp
expr_stmt|;
name|b
operator|->
name|dl0
operator|=
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The following function tracks the status of a (read) dma transfer,  * and moves the boundary between the READY and the DMA regions.  * It works under the following assumptions:  *   - the DMA engine is running;  *   - the function is called with interrupts blocked.  */
end_comment

begin_function
name|void
name|dsp_rd_dmaupdate
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
name|b
operator|->
name|dl
operator|-
name|isa_dmastatus1
argument_list|(
name|d
operator|->
name|dma2
argument_list|)
expr_stmt|;
name|tmp
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* align... */
if|if
condition|(
name|tmp
operator|>
literal|0
condition|)
block|{
comment|/* we have some data */
name|b
operator|->
name|dp
operator|+=
name|tmp
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dp
operator|>=
name|b
operator|->
name|bufsize
condition|)
name|b
operator|->
name|dp
operator|-=
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|dl
operator|-=
name|tmp
expr_stmt|;
name|b
operator|->
name|rl
operator|+=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * read interrupt routine. Must be called with interrupts blocked.  */
end_comment

begin_function
name|void
name|dsp_rdintr
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
decl_stmt|;
name|int
name|cb_reason
init|=
name|SND_CB_RD
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp_rdintr: start dl = %d fp %d blocksize %d\n"
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|b
operator|->
name|fp
argument_list|,
name|d
operator|->
name|rec_blocksize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_RD_DMA
condition|)
block|{
comment|/* dma was active */
name|b
operator|->
name|int_count
operator|++
expr_stmt|;
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_RD_DMA
expr_stmt|;
name|cb_reason
operator|=
name|SND_CB_RD
operator||
name|SND_CB_RESTART
expr_stmt|;
name|dsp_rd_dmadone
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
else|else
name|cb_reason
operator|=
name|SND_CB_RD
operator||
name|SND_CB_START
expr_stmt|;
comment|/*      * Same checks as in the write case (mutatis mutandis) to decide      * whether or not to restart a dma transfer.      */
if|if
condition|(
name|b
operator|->
name|fl
operator|>=
name|DMA_ALIGN_THRESHOLD
operator|&&
operator|(
operator|(
name|d
operator|->
name|flags
operator|&
operator|(
name|SND_F_ABORTING
operator||
name|SND_F_CLOSING
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|d
operator|->
name|dma1
operator|!=
name|d
operator|->
name|dma2
operator|)
operator|||
operator|(
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WRITING
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|b
operator|->
name|dl
operator|=
name|min
argument_list|(
name|b
operator|->
name|fl
argument_list|,
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|fp
argument_list|)
expr_stmt|;
comment|/* do not wrap */
name|b
operator|->
name|dl
operator|=
name|min
argument_list|(
name|b
operator|->
name|dl
argument_list|,
name|d
operator|->
name|rec_blocksize
argument_list|)
expr_stmt|;
name|b
operator|->
name|dl
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* realign sizes */
name|b
operator|->
name|fl
operator|-=
name|b
operator|->
name|dl
expr_stmt|;
name|b
operator|->
name|fp
operator|+=
name|b
operator|->
name|dl
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|fp
operator|==
name|b
operator|->
name|bufsize
condition|)
name|b
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
comment|/*          * now try to avoid too small dma transfers in the near future.          * This can happen if I let fp start too close to the end of          * the buffer. If this happens, and have enough data, try to          * split the available block in two approx. equal parts.          */
if|if
condition|(
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|fp
operator|<
name|MIN_CHUNK_SIZE
operator|&&
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|dp
operator|>
literal|2
operator|*
name|MIN_CHUNK_SIZE
condition|)
block|{
name|b
operator|->
name|dl
operator|=
operator|(
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|dp
operator|)
operator|/
literal|2
expr_stmt|;
name|b
operator|->
name|dl
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* align to multiples of 3 */
name|b
operator|->
name|fl
operator|+=
operator|(
name|b
operator|->
name|fp
operator|-
operator|(
name|b
operator|->
name|dp
operator|+
name|b
operator|->
name|dl
operator|)
operator|)
expr_stmt|;
name|b
operator|->
name|fp
operator|=
name|b
operator|->
name|dp
operator|+
name|b
operator|->
name|dl
expr_stmt|;
comment|/* no need to check that fp wraps */
block|}
if|if
condition|(
name|b
operator|->
name|dl
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ouch! want to read 0 bytes\n"
argument_list|)
expr_stmt|;
goto|goto
name|ferma
goto|;
block|}
name|b
operator|->
name|dl0
operator|=
name|b
operator|->
name|dl
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|d
operator|->
name|callback
condition|)
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|cb_reason
argument_list|)
expr_stmt|;
comment|/* restart_dma(); */
name|isa_dmastart
argument_list|(
name|B_READ
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|dp
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|d
operator|->
name|dma2
argument_list|)
expr_stmt|;
name|d
operator|->
name|flags
operator||=
name|SND_F_RD_DMA
expr_stmt|;
block|}
else|else
block|{
name|ferma
label|:
if|if
condition|(
name|d
operator|->
name|callback
operator|&&
operator|(
name|cb_reason
operator|&
name|SND_CB_REASON_MASK
operator|)
operator|==
name|SND_CB_RESTART
condition|)
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_RD
operator||
name|SND_CB_STOP
argument_list|)
expr_stmt|;
comment|/* 	 * if switching to write, start write dma engine 	 */
if|if
condition|(
name|d
operator|->
name|dma1
operator|==
name|d
operator|->
name|dma2
operator|&&
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WRITING
operator|)
condition|)
name|dsp_wrintr
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"cannot start rd-dma flags 0x%08x dma_dl %d fl %d\n"
argument_list|,
name|d
operator|->
name|flags
argument_list|,
name|isa_dmastatus1
argument_list|(
name|d
operator|->
name|dma2
argument_list|)
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * body of user-read routine  *  * Start DMA if not active; wait for READY not empty.  * Transfer data from READY region using uiomove(), advance boundary  * between FREE and READY. Repeat until transfer is complete.  *  * To avoid excessive latency in freeing up space for the DMA  * engine, transfers are done in blocks of increasing size, so that  * the latency is proportional to the size of the smallest block, but  * we have a low overhead and are able to feed the dma engine with  * large blocks.  *  * When we enter this routine, we assume that d->flags |= SND_F_READING  * was done before.  *  * NOTE: in the current version, read will not return more than  * blocksize bytes at once (unless more are already available), to  * avoid that requests using very large buffers block for too long.  */
end_comment

begin_function
name|int
name|dsp_read_body
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|limit
decl_stmt|,
name|l
decl_stmt|,
name|n
decl_stmt|,
name|bsz
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|long
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
decl_stmt|;
name|int
name|timeout
init|=
literal|1
decl_stmt|;
comment|/* counter of how many ticks we sleep */
comment|/*      * "limit" serves to return after at most one blocksize of data      * (unless more are already available).  Otherwise, things like      * cat /dev/audio would use a 64K buffer and would start returning      * data after a _very_ long time...      * Note -- some applications depend on reads not returning short      * blocks. But I believe these apps are broken, since interrupted      * system calls might return short reads anyways, and the      * application should better check that.      */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|>
name|d
operator|->
name|rec_blocksize
condition|)
name|limit
operator|=
name|buf
operator|->
name|uio_resid
operator|-
name|d
operator|->
name|rec_blocksize
expr_stmt|;
else|else
name|limit
operator|=
literal|0
expr_stmt|;
name|bsz
operator|=
name|MIN_CHUNK_SIZE
expr_stmt|;
comment|/* the current transfer (doubles at each step) */
while|while
condition|(
operator|(
name|n
operator|=
name|buf
operator|->
name|uio_resid
operator|)
operator|>
name|limit
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp_read_body: start waiting for %d bytes\n"
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * here compute how many bytes to transfer, enforcing various 	 * limitations: 	 */
name|l
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|bsz
argument_list|)
expr_stmt|;
comment|/* 1': at most bsz bytes ...        */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* no interrupts here !             */
comment|/* 	 * if i) the dma engine is running, ii) we do not have enough 	 * ready bytes, and iii) the current DMA transfer could give 	 * us what we need, or we are doing non-blocking IO, then try 	 * to extend the READY region. 	 * Otherwise do not bother, we will need to sleep anyways, 	 * and make the timeout longer. 	 */
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_RD_DMA
operator|&&
name|b
operator|->
name|rl
operator|<
name|l
operator|&&
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_NBIO
operator|||
name|b
operator|->
name|rl
operator|+
name|b
operator|->
name|dl
operator|>=
name|n
operator|-
name|limit
operator|)
condition|)
name|dsp_rd_dmaupdate
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|timeout
operator|=
name|hz
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|l
argument_list|,
name|b
operator|->
name|rl
argument_list|)
expr_stmt|;
comment|/* 2': no more than avail. data     */
name|l
operator|=
name|min
argument_list|(
name|l
argument_list|,
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|rp
argument_list|)
expr_stmt|;
comment|/* 3': do not wrap buffer. */
comment|/* the above limitation can be removed if we use auto DMA 	    * on the ISA controller. But then we have to make a check 	    * when doing the uiomove... 	    */
if|if
condition|(
operator|!
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_RD_DMA
operator|)
condition|)
block|{
comment|/* dma was idle, start it  */
comment|/* 	     * There are two reasons the dma can be idle: either this 	     * is the first read, or the buffer has become full. In 	     * the latter case, the dma cannot be restarted until 	     * we have removed some data, which will be true at the 	     * second round. 	     * 	     * Call dsp_rdintr to start the dma. It would be nice to 	     * have a "need" field in the snd_dbuf, so that we do 	     * not start a long operation unnecessarily. However, 	     * the restart code will ask for at most d->blocksize 	     * bytes, and since we are sure we are the only reader, 	     * and the routine is not interrupted, we patch and 	     * restore d->blocksize around the call. A bit dirty, 	     * but it works, and saves some overhead :) 	     */
name|int
name|old_bs
init|=
name|d
operator|->
name|rec_blocksize
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|flags
operator|&
operator|(
name|SND_F_INIT
operator||
name|SND_F_WR_DMA
operator||
name|SND_F_RD_DMA
operator|)
operator|)
operator|==
name|SND_F_INIT
condition|)
block|{
comment|/* want to init but no pending DMA activity */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_INIT
argument_list|)
expr_stmt|;
comment|/* this is slow! */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|<
name|MIN_CHUNK_SIZE
condition|)
name|d
operator|->
name|rec_blocksize
operator|=
name|MIN_CHUNK_SIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|<
name|d
operator|->
name|rec_blocksize
condition|)
name|d
operator|->
name|rec_blocksize
operator|=
name|l
expr_stmt|;
name|dsp_rdintr
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|rec_blocksize
operator|=
name|old_bs
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
comment|/* 	     * If, after all these efforts, we still have no data ready, 	     * then we must sleep (unless of course we have doing 	     * non-blocking i/o. But use exponential delays, starting 	     * at 1 tick and doubling each time. 	     */
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_NBIO
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp_read_body: sleeping %d waiting for %d bytes\n"
argument_list|,
name|timeout
argument_list|,
name|buf
operator|->
name|uio_resid
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"dsprd"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
condition|)
name|d
operator|->
name|flags
operator||=
name|SND_F_ABORTING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* necessary before the goto again... */
if|if
condition|(
name|ret
operator|==
name|ERESTART
operator|||
name|ret
operator|==
name|EINTR
condition|)
break|break ;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"woke up, ret %d, rl %d\n"
argument_list|,
name|ret
argument_list|,
name|b
operator|->
name|rl
argument_list|)
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|min
argument_list|(
name|timeout
operator|*
literal|2
argument_list|,
name|hz
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|1
expr_stmt|;
comment|/* we got some data, so reset exp. wait */
comment|/* 	 * if we are using /dev/audio and the device does not 	 * support it natively, we should do a format conversion. 	 * (in this case from uLAW to natural format). 	 * This can be messy in that it can require an intermediate 	 * buffer, and also screw up the byte count. 	 */
comment|/* 	 * NOTE: I _can_ use rp here because it is not modified by the 	 * interrupt routines. 	 */
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_XLAT8
condition|)
name|translate_bytes
argument_list|(
name|dsp_ulaw
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|rp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|ret
operator|=
name|uiomove
argument_list|(
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|rp
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
comment|/* an error occurred ... */
break|break ;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* no interrupts here ... */
name|b
operator|->
name|fl
operator|+=
name|l
expr_stmt|;
comment|/* this more free bytes */
name|b
operator|->
name|rl
operator|-=
name|l
expr_stmt|;
comment|/* this less ready bytes */
name|b
operator|->
name|rp
operator|+=
name|l
expr_stmt|;
comment|/* advance ready pointer */
if|if
condition|(
name|b
operator|->
name|rp
operator|==
name|b
operator|->
name|bufsize
condition|)
comment|/* handle wraps */
name|b
operator|->
name|rp
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bsz
operator|=
name|min
argument_list|(
name|b
operator|->
name|bufsize
argument_list|,
name|bsz
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* no interrupts here ... */
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_READING
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_ABORTING
condition|)
block|{
name|d
operator|->
name|flags
operator||=
operator|~
name|SND_F_ABORTING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dsp_rdabort
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * short routine to initialize a dma buffer descriptor (usually  * located in the XXX_desc structure). The first parameter is  * the buffer size, the second one specifies the dma channel in use  * At the moment we do not support more than 64K, since for some  * cards I need to switch between dma1 and dma2. The channel is  * unused.  */
end_comment

begin_function
name|void
name|alloc_dbuf
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
if|if
condition|(
name|size
operator|>
literal|0x10000
condition|)
name|panic
argument_list|(
literal|"max supported size is 64k"
argument_list|)
expr_stmt|;
name|b
operator|->
name|buf
operator|=
name|contigmalloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0ul
argument_list|,
literal|0xfffffful
argument_list|,
literal|1ul
argument_list|,
literal|0x10000ul
argument_list|)
expr_stmt|;
comment|/* should check that it does not fail... */
name|b
operator|->
name|dp
operator|=
name|b
operator|->
name|rp
operator|=
name|b
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|dl0
operator|=
name|b
operator|->
name|dl
operator|=
name|b
operator|->
name|rl
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|bufsize
operator|=
name|b
operator|->
name|fl
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reset_dbuf
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|)
block|{
name|b
operator|->
name|dp
operator|=
name|b
operator|->
name|rp
operator|=
name|b
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|dl0
operator|=
name|b
operator|->
name|dl
operator|=
name|b
operator|->
name|rl
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|fl
operator|=
name|b
operator|->
name|bufsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * snd_sync waits until the space in the given channel goes above  * a threshold. chan = 1 : play, 2: capture. The threshold is  * checked against fl or rl respectively.  * Assume that the condition can become true, do not check here...  */
end_comment

begin_function
name|int
name|snd_sync
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|int
name|chan
parameter_list|,
name|int
name|threshold
parameter_list|)
block|{
name|u_long
name|s
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
decl_stmt|;
name|b
operator|=
operator|(
name|chan
operator|==
literal|1
operator|)
condition|?
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
else|:
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|chan
operator|==
literal|1
condition|)
name|dsp_wr_dmaupdate
argument_list|(
name|d
argument_list|)
expr_stmt|;
else|else
name|dsp_rd_dmaupdate
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chan
operator|==
literal|1
operator|&&
name|b
operator|->
name|fl
operator|<=
name|threshold
operator|)
operator|||
operator|(
name|chan
operator|==
literal|2
operator|&&
name|b
operator|->
name|rl
operator|<=
name|threshold
operator|)
condition|)
block|{
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"sndsyn"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERESTART
operator|||
name|ret
operator|==
name|EINTR
condition|)
block|{
name|printf
argument_list|(
literal|"tsleep returns %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * dsp_wrabort(d) and dsp_rdabort(d) are non-blocking functions  * which abort a pending DMA transfer and flush the buffers.  */
end_comment

begin_function
name|int
name|dsp_wrabort
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|long
name|s
decl_stmt|;
name|int
name|missing
init|=
literal|0
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WR_DMA
condition|)
block|{
name|d
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SND_F_WR_DMA
operator||
name|SND_F_WRITING
operator|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|callback
condition|)
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_WR
operator||
name|SND_CB_ABORT
argument_list|)
expr_stmt|;
name|missing
operator|=
name|isa_dmastop
argument_list|(
name|d
operator|->
name|dma1
argument_list|)
expr_stmt|;
comment|/* this many missing bytes... */
name|b
operator|->
name|rl
operator|+=
name|missing
expr_stmt|;
comment|/* which are part of the ready area */
name|b
operator|->
name|rp
operator|-=
name|missing
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|rp
operator|<
literal|0
condition|)
name|b
operator|->
name|rp
operator|+=
name|b
operator|->
name|bufsize
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp_wrabort: stopped after %d bytes out of %d\n"
argument_list|,
name|b
operator|->
name|dl
operator|-
name|missing
argument_list|,
name|b
operator|->
name|dl
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|dl
operator|-=
name|missing
expr_stmt|;
name|dsp_wr_dmadone
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|missing
operator|=
name|b
operator|->
name|rl
expr_stmt|;
block|}
name|reset_dbuf
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|missing
return|;
block|}
end_function

begin_function
name|int
name|dsp_rdabort
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|long
name|s
decl_stmt|;
name|int
name|missing
init|=
literal|0
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_RD_DMA
condition|)
block|{
name|d
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SND_F_RD_DMA
operator||
name|SND_F_READING
operator|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|callback
condition|)
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_RD
operator||
name|SND_CB_ABORT
argument_list|)
expr_stmt|;
name|missing
operator|=
name|isa_dmastop
argument_list|(
name|d
operator|->
name|dma2
argument_list|)
expr_stmt|;
comment|/* this many missing bytes... */
name|b
operator|->
name|fl
operator|+=
name|missing
expr_stmt|;
comment|/* which are part of the free area */
name|b
operator|->
name|fp
operator|-=
name|missing
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|fp
operator|<
literal|0
condition|)
name|b
operator|->
name|fp
operator|+=
name|b
operator|->
name|bufsize
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp_rdabort: stopped after %d bytes out of %d\n"
argument_list|,
name|b
operator|->
name|dl
operator|-
name|missing
argument_list|,
name|b
operator|->
name|dl
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|dl
operator|-=
name|missing
expr_stmt|;
name|dsp_rd_dmadone
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|missing
operator|=
name|b
operator|->
name|rl
expr_stmt|;
block|}
name|reset_dbuf
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|missing
return|;
block|}
end_function

begin_comment
comment|/*  * this routine tries to flush the dma transfer. It is called  * on a close. The caller must set SND_F_CLOSING, and insure that  * interrupts are enabled. We immediately abort any read DMA  * operation, and then wait for the play buffer to drain.  */
end_comment

begin_function
name|int
name|snd_flush
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|res
decl_stmt|,
name|res1
decl_stmt|;
name|int
name|count
init|=
literal|10
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"snd_flush d->flags 0x%08x\n"
argument_list|,
name|d
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|dsp_rdabort
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WR_DMA
condition|)
block|{
comment|/* close write */
while|while
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WR_DMA
condition|)
block|{
comment|/* 	     * still pending output data. 	     */
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"dmafl1"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERESTART
operator|||
name|ret
operator|==
name|EINTR
condition|)
block|{
name|printf
argument_list|(
literal|"tsleep returns %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ret
operator|&&
operator|--
name|count
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"timeout flushing dma1, cnt 0x%x flags 0x%08x\n"
argument_list|,
name|isa_dmastatus1
argument_list|(
name|d
operator|->
name|dma1
argument_list|)
argument_list|,
name|d
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_CLOSING
expr_stmt|;
block|}
name|reset_dbuf
argument_list|(
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * end of new code for dma buffer handling  */
end_comment

end_unit

