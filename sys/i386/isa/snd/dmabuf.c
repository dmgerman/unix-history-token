begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * snd/dmabuf.c  *   * This file implements the new DMA routines for the sound driver.  * AUTO DMA MODE (ISA DMA SIDE).  *  * Copyright by Luigi Rizzo - 1997  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer  *    in the documentation and/or other materials provided with the  *    distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/snd/sound.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/snd/ulaw.h>
end_include

begin_define
define|#
directive|define
name|MIN_CHUNK_SIZE
value|256
end_define

begin_comment
comment|/* for uiomove etc. */
end_comment

begin_define
define|#
directive|define
name|DMA_ALIGN_THRESHOLD
value|4
end_define

begin_define
define|#
directive|define
name|DMA_ALIGN_MASK
value|(~ (DMA_ALIGN_THRESHOLD - 1))
end_define

begin_function_decl
specifier|static
name|void
name|dsp_wr_dmadone
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dsp_rd_dmadone
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * SOUND OUTPUT  We use a circular buffer to store samples directed to the DAC. The buffer is split into two variable-size regions, each identified by an offset in the buffer (rp,fp) and a length (rl,fl):        0          rp,rl        fp,fl    bufsize       |__________>____________>________| 	  FREE   d   READY    w FREE        READY: data written from the process and ready to be sent to the DAC;   FREE: free part of the buffer.  Both regions can wrap around the end of the buffer.  At initialization, READY is empty, FREE takes all the available space, and dma is idle.  dl contains the length of the current DMA transfer, dl=0 means that the dma is idle.  The two boundaries (rp,fp) in the buffers are advanced by DMA [d] and write() [w] operations. The first portion of the READY region is used for DMA transfers. The transfer is started at rp and with chunks of length dl. During DMA operations, dsp_wr_dmaupdate() updates rp, rl and fl tracking the ISA DMA engine as the transfer makes progress. When a new block is written, fp advances and rl,fl are updated accordingly.  The code works as follows: the user write routine dsp_write_body() fills up the READY region with new data (reclaiming space from the FREE region) and starts the write DMA engine if inactive.  When a DMA transfer is complete, an interrupt causes dsp_wrintr() to be called which extends the FREE region and possibly starts the next transfer.  In some cases, the code tries to track the current status of DMA operations by calling dsp_wr_dmaupdate() which changes rp, rl and fl.  The sistem tries to make all DMA transfers use the same size, play_blocksize or rec_blocksize. The size is either selected by the user, or computed by the system to correspond to about .25s of audio. The blocksize must be within a range which is currently:  	min(5ms, 40 bytes) ... 1/2 buffer size.  When there aren't enough data (write) or space (read), a transfer is started with a reduced size.  To reduce problems in case of overruns, the routine which fills up the buffer should initialize (e.g. by repeating the last value) a reasonably long area after the last block so that no noise is produced on overruns.    *   */
end_comment

begin_comment
comment|/*  * dsp_wr_dmadone() updates pointers and wakes up any process sleeping  * or waiting on a select().  * Must be called at spltty().  */
end_comment

begin_function
specifier|static
name|void
name|dsp_wr_dmadone
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
decl_stmt|;
name|dsp_wr_dmaupdate
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/*      * XXX here it would be more efficient to record if there      * actually is a sleeping process, but this should still work.      */
name|wakeup
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* wakeup possible sleepers */
if|if
condition|(
name|b
operator|->
name|sel
operator|.
name|si_pid
operator|&&
operator|(
operator|!
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_HAS_SIZE
operator|)
operator|||
name|b
operator|->
name|fl
operator|>=
name|d
operator|->
name|play_blocksize
operator|)
condition|)
name|selwakeup
argument_list|(
operator|&
name|b
operator|->
name|sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * dsp_wr_dmaupdate() tracks the status of a (write) dma transfer,  * updating pointers. It must be called at spltty() and the ISA DMA must  * have been started.  *  * NOTE: when we are using auto dma in the device, rl might become  *  negative.  */
end_comment

begin_function
name|void
name|dsp_wr_dmaupdate
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|)
block|{
name|int
name|tmp
decl_stmt|,
name|delta
decl_stmt|;
name|tmp
operator|=
name|b
operator|->
name|bufsize
operator|-
name|isa_dmastatus1
argument_list|(
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
name|tmp
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* align... */
name|delta
operator|=
name|tmp
operator|-
name|b
operator|->
name|rp
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
comment|/* wrapped */
name|delta
operator|+=
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|rp
operator|=
name|tmp
expr_stmt|;
name|b
operator|->
name|rl
operator|-=
name|delta
expr_stmt|;
name|b
operator|->
name|fl
operator|+=
name|delta
expr_stmt|;
name|b
operator|->
name|total
operator|+=
name|delta
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write interrupt routine. Can be called from other places (e.g.  * to start a paused transfer), but with interrupts disabled.  */
end_comment

begin_function
name|void
name|dsp_wrintr
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
comment|/* dma was active */
name|b
operator|->
name|int_count
operator|++
expr_stmt|;
name|dsp_wr_dmadone
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|DEB
argument_list|(
argument|if (b->rl<
literal|0
argument|) 	printf(
literal|"dsp_wrintr: dl %d, rp:rl %d:%d, fp:fl %d:%d\n"
argument|, 	    b->dl, b->rp, b->rl, b->fp, b->fl)
argument_list|)
empty_stmt|;
comment|/*      * start another dma operation only if have ready data in the buffer,      * there is no pending abort, have a full-duplex device      * or have half duplex device      * and there is no * pending op on the other side.      *      * Force transfers to be aligned to a boundary of 4, which is      * needed when doing stereo and 16-bit. We could make this      * adaptive, but why bother for now...      */
if|if
condition|(
name|b
operator|->
name|rl
operator|>=
name|DMA_ALIGN_THRESHOLD
operator|&&
operator|!
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_ABORTING
operator|)
operator|&&
operator|(
name|FULL_DUPLEX
argument_list|(
name|d
argument_list|)
operator|||
operator|!
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_READING
operator|)
operator|)
condition|)
block|{
name|int
name|l
init|=
name|min
argument_list|(
name|b
operator|->
name|rl
argument_list|,
name|d
operator|->
name|play_blocksize
argument_list|)
decl_stmt|;
comment|/* avoid too large transfer */
name|l
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* realign things */
if|if
condition|(
name|l
operator|!=
name|b
operator|->
name|dl
condition|)
block|{
comment|/* for any reason, size has changed. Stop and restart */
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"wrintr: bsz change from %d to %d, rp %d rl %d\n"
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|l
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b
operator|->
name|rl
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|dl
operator|=
name|l
expr_stmt|;
comment|/* record previous transfer size */
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_WR
operator||
name|SND_CB_STOP
argument_list|)
expr_stmt|;
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_WR
operator||
name|SND_CB_START
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* cannot start a new dma transfer */
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"cannot start wr-dma flags 0x%08x rp %d rl %d\n"
argument_list|,
name|d
operator|->
name|flags
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b
operator|->
name|rl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
operator|>
literal|0
condition|)
block|{
comment|/* was active */
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_WR
operator||
name|SND_CB_STOP
argument_list|)
expr_stmt|;
comment|/* stop dma */
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WRITING
condition|)
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"Race! got wrint while reloading...\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|reset_dbuf
argument_list|(
name|b
argument_list|,
name|SND_CHAN_WR
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * if switching to read, should start the read dma... 	 */
if|if
condition|(
operator|!
name|FULL_DUPLEX
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_READING
operator|)
condition|)
name|dsp_rdintr
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * user write routine  *  * advance the boundary between READY and FREE, fill the space with  * uiomove(), and possibly start DMA. Do the above until the transfer  * is complete.  *   * To minimize latency in case a pending DMA transfer is about to end,  * we do the transfer in pieces of increasing sizes, extending the  * READY area at every checkpoint. In the (necessary) assumption that  * memory bandwidth is larger than the rate at which the dma consumes  * data, we reduce the latency to something proportional to the length  * of the first piece, while keeping the overhead low and being able  * to feed the DMA with large blocks.  *  * assume d->flags |= SND_F_WRITING ; has been done before  */
end_comment

begin_function
name|int
name|dsp_write_body
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|l
decl_stmt|,
name|bsz
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|long
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
decl_stmt|;
comment|/*      * bsz is the max size for the next transfer. If the dma was idle      * (dl == 0), we want it as large as possible. Otherwise, start with      * a small block to avoid underruns if we are close to the end of      * the previous operation.      */
name|bsz
operator|=
name|b
operator|->
name|dl
condition|?
name|MIN_CHUNK_SIZE
else|:
name|b
operator|->
name|bufsize
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|buf
operator|->
name|uio_resid
operator|)
condition|)
block|{
name|l
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|bsz
argument_list|)
expr_stmt|;
comment|/* at most n bytes ... */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* no interrupts here ... */
name|dsp_wr_dmaupdate
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|l
argument_list|,
name|b
operator|->
name|fl
argument_list|)
expr_stmt|;
comment|/* no more than avail. space */
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp_write_body: prepare %d bytes out of %d\n"
argument_list|,
name|l
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * at this point, we assume that if l==0 the dma engine 	 * must be running. 	 */
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
comment|/* no space, must sleep */
name|int
name|timeout
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_NBIO
condition|)
block|{
comment|/* unless of course we are doing non-blocking i/o */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp_write_body: l=0, (fl %d) sleeping\n"
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|fl
operator|<
name|n
condition|)
name|timeout
operator|=
name|hz
expr_stmt|;
else|else
name|timeout
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"dspwr"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
condition|)
name|d
operator|->
name|flags
operator||=
name|SND_F_ABORTING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
condition|)
break|break ;
continue|continue;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * copy data to the buffer, and possibly do format 	 * conversions (here, from ULAW to U8). 	 * NOTE: I can use fp here since it is not modified by the 	 * interrupt routines. 	 */
if|if
condition|(
name|b
operator|->
name|fp
operator|+
name|l
operator|>
name|b
operator|->
name|bufsize
condition|)
block|{
name|int
name|l1
init|=
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|fp
decl_stmt|;
name|uiomove
argument_list|(
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|fp
argument_list|,
name|l1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|uiomove
argument_list|(
name|b
operator|->
name|buf
argument_list|,
name|l
operator|-
name|l1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_XLAT8
condition|)
block|{
name|translate_bytes
argument_list|(
name|ulaw_dsp
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|fp
argument_list|,
name|l1
argument_list|)
expr_stmt|;
name|translate_bytes
argument_list|(
name|ulaw_dsp
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|l
operator|-
name|l1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|uiomove
argument_list|(
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|fp
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_XLAT8
condition|)
name|translate_bytes
argument_list|(
name|ulaw_dsp
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|fp
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* no interrupts here ... */
name|b
operator|->
name|rl
operator|+=
name|l
expr_stmt|;
comment|/* this more ready bytes */
name|b
operator|->
name|fl
operator|-=
name|l
expr_stmt|;
comment|/* this less free bytes */
name|b
operator|->
name|fp
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|fp
operator|>=
name|b
operator|->
name|bufsize
condition|)
comment|/* handle wraps */
name|b
operator|->
name|fp
operator|-=
name|b
operator|->
name|bufsize
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
operator|==
literal|0
condition|)
comment|/* dma was idle, restart it */
name|dsp_wrintr
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|==
literal|0
operator|&&
operator|(
name|b
operator|->
name|fp
operator|&
operator|(
name|b
operator|->
name|sample_size
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	     * If data is correctly aligned, pad the region with 	     * replicas of the last sample. l0 goes from current to 	     * the buffer end, l1 is the portion which wraps around. 	     */
name|int
name|l0
decl_stmt|,
name|l1
decl_stmt|,
name|i
decl_stmt|;
name|l1
operator|=
name|min
argument_list|(
comment|/* b->dl */
name|d
operator|->
name|play_blocksize
argument_list|,
name|b
operator|->
name|fl
argument_list|)
expr_stmt|;
name|l0
operator|=
name|min
argument_list|(
name|l1
argument_list|,
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|fp
argument_list|)
expr_stmt|;
name|l1
operator|=
name|l1
operator|-
name|l0
expr_stmt|;
name|i
operator|=
name|b
operator|->
name|fp
operator|-
name|b
operator|->
name|sample_size
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|+=
name|b
operator|->
name|bufsize
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|sample_size
operator|==
literal|1
condition|)
block|{
name|u_char
modifier|*
name|p
init|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|b
operator|->
name|buf
operator|+
name|i
operator|)
decl_stmt|,
name|sample
init|=
operator|*
name|p
decl_stmt|;
for|for
control|(
init|;
name|l0
condition|;
name|l0
operator|--
control|)
operator|*
name|p
operator|++
operator|=
name|sample
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|b
operator|->
name|buf
operator|)
init|;
name|l1
condition|;
name|l1
operator|--
control|)
operator|*
name|p
operator|++
operator|=
name|sample
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|sample_size
operator|==
literal|2
condition|)
block|{
name|u_short
modifier|*
name|p
init|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|b
operator|->
name|buf
operator|+
name|i
operator|)
decl_stmt|,
name|sample
init|=
operator|*
name|p
decl_stmt|;
name|l1
operator|/=
literal|2
expr_stmt|;
name|l0
operator|/=
literal|2
expr_stmt|;
for|for
control|(
init|;
name|l0
condition|;
name|l0
operator|--
control|)
operator|*
name|p
operator|++
operator|=
name|sample
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|b
operator|->
name|buf
operator|)
init|;
name|l1
condition|;
name|l1
operator|--
control|)
operator|*
name|p
operator|++
operator|=
name|sample
expr_stmt|;
block|}
else|else
block|{
comment|/* must be 4 ... */
name|u_long
modifier|*
name|p
init|=
operator|(
name|u_long
operator|*
operator|)
operator|(
name|b
operator|->
name|buf
operator|+
name|i
operator|)
decl_stmt|,
name|sample
init|=
operator|*
name|p
decl_stmt|;
name|l1
operator|/=
literal|4
expr_stmt|;
name|l0
operator|/=
literal|4
expr_stmt|;
for|for
control|(
init|;
name|l0
condition|;
name|l0
operator|--
control|)
operator|*
name|p
operator|++
operator|=
name|sample
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|u_long
operator|*
operator|)
operator|(
name|b
operator|->
name|buf
operator|)
init|;
name|l1
condition|;
name|l1
operator|--
control|)
operator|*
name|p
operator|++
operator|=
name|sample
expr_stmt|;
block|}
block|}
name|bsz
operator|=
name|min
argument_list|(
name|b
operator|->
name|bufsize
argument_list|,
name|bsz
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* no interrupts here ... */
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_WRITING
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_ABORTING
condition|)
block|{
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_ABORTING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dsp_wrabort
argument_list|(
name|d
argument_list|,
literal|1
comment|/* restart */
argument_list|)
expr_stmt|;
comment|/* XXX return EINTR ? */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * SOUND INPUT  *  The input part is similar to the output one, with a circular buffer split in two regions, and boundaries advancing because of read() calls [r] or dma operation [d].  At initialization, as for the write routine, READY is empty, and FREE takes all the space.        0          rp,rl        fp,fl    bufsize       |__________>____________>________| 	  FREE   r   READY    d  FREE      Operation is as follows: upon user read (dsp_read_body()) a DMA read is started if not already active (marked by b->dl> 0), then as soon as data are available in the READY region they are transferred to the user buffer, thus advancing the boundary between FREE and READY. Upon interrupts, caused by a completion of a DMA transfer, the READY region is extended and possibly a new transfer is started.  When necessary, dsp_rd_dmaupdate() is called to advance fp (and update rl,fl accordingly). Upon user reads, rp is advanced and rl,fl are updated accordingly.  The rules to choose the size of the new DMA area are similar to the other case, with a preferred constant transfer size equal to rec_blocksize, and fallback to smaller sizes if no space is available.   *  */
end_comment

begin_comment
comment|/*  * dsp_rd_dmadone moves bytes in the input buffer from DMA region to  * READY region. We assume it is called at spltty() and  with dl>0   */
end_comment

begin_function
specifier|static
name|void
name|dsp_rd_dmadone
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
decl_stmt|;
name|dsp_rd_dmaupdate
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* wakeup possibly sleeping processes */
if|if
condition|(
name|b
operator|->
name|sel
operator|.
name|si_pid
operator|&&
operator|(
operator|!
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_HAS_SIZE
operator|)
operator|||
name|b
operator|->
name|rl
operator|>=
name|d
operator|->
name|rec_blocksize
operator|)
condition|)
name|selwakeup
argument_list|(
operator|&
name|b
operator|->
name|sel
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The following function tracks the status of a (read) dma transfer,  * and moves the boundary between the READY and the DMA regions.  * It works under the following assumptions:  *   - the DMA engine is running;  *   - the function is called with interrupts blocked.  */
end_comment

begin_function
name|void
name|dsp_rd_dmaupdate
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|)
block|{
name|int
name|delta
decl_stmt|,
name|tmp
decl_stmt|;
name|tmp
operator|=
name|b
operator|->
name|bufsize
operator|-
name|isa_dmastatus1
argument_list|(
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
name|tmp
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* align... */
name|delta
operator|=
name|tmp
operator|-
name|b
operator|->
name|fp
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
comment|/* wrapped */
name|delta
operator|+=
name|b
operator|->
name|bufsize
expr_stmt|;
name|b
operator|->
name|fp
operator|=
name|tmp
expr_stmt|;
name|b
operator|->
name|fl
operator|-=
name|delta
expr_stmt|;
name|b
operator|->
name|rl
operator|+=
name|delta
expr_stmt|;
name|b
operator|->
name|total
operator|+=
name|delta
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * read interrupt routine. Must be called with interrupts blocked.  */
end_comment

begin_function
name|void
name|dsp_rdintr
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
comment|/* dma was active */
name|b
operator|->
name|int_count
operator|++
expr_stmt|;
name|dsp_rd_dmadone
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp_rdintr: start dl %d, rp:rl %d:%d, fp:fl %d:%d\n"
argument_list|,
name|b
operator|->
name|dl
argument_list|,
name|b
operator|->
name|rp
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|fp
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Restart if have enough free space to absorb overruns;      */
if|if
condition|(
name|b
operator|->
name|fl
operator|>
literal|0x200
operator|&&
operator|(
name|d
operator|->
name|flags
operator|&
operator|(
name|SND_F_ABORTING
operator||
name|SND_F_CLOSING
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|FULL_DUPLEX
argument_list|(
name|d
argument_list|)
operator|||
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WRITING
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|l
init|=
name|min
argument_list|(
name|b
operator|->
name|fl
operator|-
literal|0x100
argument_list|,
name|d
operator|->
name|rec_blocksize
argument_list|)
decl_stmt|;
name|l
operator|&=
name|DMA_ALIGN_MASK
expr_stmt|;
comment|/* realign sizes */
if|if
condition|(
name|l
operator|!=
name|b
operator|->
name|dl
condition|)
block|{
comment|/* for any reason, size has changed. Stop and restart */
name|b
operator|->
name|dl
operator|=
name|l
expr_stmt|;
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_RD
operator||
name|SND_CB_STOP
argument_list|)
expr_stmt|;
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_RD
operator||
name|SND_CB_START
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|b
operator|->
name|dl
operator|>
literal|0
condition|)
block|{
comment|/* was active */
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_RD
operator||
name|SND_CB_STOP
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * if switching to write, start write dma engine 	 */
if|if
condition|(
operator|!
name|FULL_DUPLEX
argument_list|(
name|d
argument_list|)
operator|&&
operator|(
name|d
operator|->
name|flags
operator|&
name|SND_F_WRITING
operator|)
condition|)
name|dsp_wrintr
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"cannot start rd-dma rl %d fl %d\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * body of user-read routine  *  * Start DMA if not active; wait for READY not empty.  * Transfer data from READY region using uiomove(), advance boundary  * between FREE and READY. Repeat until transfer is complete.  *  * To avoid excessive latency in freeing up space for the DMA  * engine, transfers are done in blocks of increasing size, so that  * the latency is proportional to the size of the smallest block, but  * we have a low overhead and are able to feed the dma engine with  * large blocks.  *  * When we enter this routine, we assume that d->flags |= SND_F_READING  * was done before.  *  * NOTE: in the current version, read will not return more than  * blocksize bytes at once (unless more are already available), to  * avoid that requests using very large buffers block for too long.  */
end_comment

begin_function
name|int
name|dsp_read_body
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|struct
name|uio
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|limit
decl_stmt|,
name|l
decl_stmt|,
name|n
decl_stmt|,
name|bsz
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|long
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
decl_stmt|;
comment|/*      * "limit" serves to return after at most one blocksize of data      * (unless more are already available).  Otherwise, things like      * cat /dev/audio would use a 64K buffer and would start returning      * data after a _very_ long time...      * Note -- some applications depend on reads not returning short      * blocks. But I believe these apps are broken, since interrupted      * system calls might return short reads anyways, and the      * application should better check that.      */
if|if
condition|(
name|buf
operator|->
name|uio_resid
operator|>
name|d
operator|->
name|rec_blocksize
condition|)
name|limit
operator|=
name|buf
operator|->
name|uio_resid
operator|-
name|d
operator|->
name|rec_blocksize
expr_stmt|;
else|else
name|limit
operator|=
literal|0
expr_stmt|;
name|bsz
operator|=
name|MIN_CHUNK_SIZE
expr_stmt|;
comment|/* the current transfer (doubles at each step) */
while|while
condition|(
operator|(
name|n
operator|=
name|buf
operator|->
name|uio_resid
operator|)
operator|>
name|limit
condition|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp_read_body: start waiting for %d bytes\n"
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|bsz
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* no interrupts here !             */
name|dsp_rd_dmaupdate
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|l
operator|=
name|min
argument_list|(
name|l
argument_list|,
name|b
operator|->
name|rl
argument_list|)
expr_stmt|;
comment|/* no more than avail. data     */
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|int
name|timeout
decl_stmt|;
comment|/* 	     * If there is no data ready, then we must sleep (unless 	     * of course we have doing non-blocking i/o). But also 	     * consider restarting the DMA engine. 	     */
if|if
condition|(
name|b
operator|->
name|dl
operator|==
literal|0
condition|)
block|{
comment|/* dma was idle, start it  */
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_INIT
operator|&&
name|d
operator|->
name|dbuf_out
operator|.
name|dl
operator|==
literal|0
condition|)
block|{
comment|/* want to init and there is no pending DMA activity */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_INIT
argument_list|)
expr_stmt|;
comment|/* this is slow! */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
block|}
name|dsp_rdintr
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_NBIO
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|-
name|limit
operator|>
name|b
operator|->
name|dl
condition|)
name|timeout
operator|=
name|hz
expr_stmt|;
comment|/* we need to wait for an int. */
else|else
name|timeout
operator|=
literal|1
expr_stmt|;
comment|/* maybe data will be ready earlier */
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"dsprd"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
condition|)
name|d
operator|->
name|flags
operator||=
name|SND_F_ABORTING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
condition|)
break|break ;
continue|continue;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Do any necessary format conversion, and copy to user space. 	 * NOTE: I _can_ use rp here because it is not modified by the 	 * interrupt routines. 	 */
if|if
condition|(
name|b
operator|->
name|rp
operator|+
name|l
operator|>
name|b
operator|->
name|bufsize
condition|)
block|{
comment|/* handle wraparounds */
name|int
name|l1
init|=
name|b
operator|->
name|bufsize
operator|-
name|b
operator|->
name|rp
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_XLAT8
condition|)
block|{
name|translate_bytes
argument_list|(
name|dsp_ulaw
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|rp
argument_list|,
name|l1
argument_list|)
expr_stmt|;
name|translate_bytes
argument_list|(
name|dsp_ulaw
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|l
operator|-
name|l1
argument_list|)
expr_stmt|;
block|}
name|uiomove
argument_list|(
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|rp
argument_list|,
name|l1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|uiomove
argument_list|(
name|b
operator|->
name|buf
argument_list|,
name|l
operator|-
name|l1
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_XLAT8
condition|)
name|translate_bytes
argument_list|(
name|dsp_ulaw
argument_list|,
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|rp
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|uiomove
argument_list|(
name|b
operator|->
name|buf
operator|+
name|b
operator|->
name|rp
argument_list|,
name|l
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* no interrupts here ... */
name|b
operator|->
name|fl
operator|+=
name|l
expr_stmt|;
comment|/* this more free bytes */
name|b
operator|->
name|rl
operator|-=
name|l
expr_stmt|;
comment|/* this less ready bytes */
name|b
operator|->
name|rp
operator|+=
name|l
expr_stmt|;
comment|/* advance ready pointer */
if|if
condition|(
name|b
operator|->
name|rp
operator|>=
name|b
operator|->
name|bufsize
condition|)
comment|/* handle wraps */
name|b
operator|->
name|rp
operator|-=
name|b
operator|->
name|bufsize
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bsz
operator|=
name|min
argument_list|(
name|b
operator|->
name|bufsize
argument_list|,
name|bsz
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* no interrupts here ... */
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_READING
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|flags
operator|&
name|SND_F_ABORTING
condition|)
block|{
name|d
operator|->
name|flags
operator||=
operator|~
name|SND_F_ABORTING
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dsp_rdabort
argument_list|(
name|d
argument_list|,
literal|1
comment|/* restart */
argument_list|)
expr_stmt|;
comment|/* XXX return EINTR ? */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * short routine to initialize a dma buffer descriptor (usually  * located in the XXX_desc structure). The first parameter is  * the buffer size, the second one specifies that a 16-bit dma channel  * is used (hence the buffer must be properly aligned).  */
end_comment

begin_function
name|void
name|alloc_dbuf
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|>
literal|0x10000
condition|)
name|panic
argument_list|(
literal|"max supported size is 64k"
argument_list|)
expr_stmt|;
name|b
operator|->
name|buf
operator|=
name|contigmalloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0ul
argument_list|,
literal|0xfffffful
argument_list|,
literal|1ul
argument_list|,
literal|0x10000ul
argument_list|)
expr_stmt|;
comment|/* should check that malloc does not fail... */
name|b
operator|->
name|rp
operator|=
name|b
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|dl
operator|=
name|b
operator|->
name|rl
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|bufsize
operator|=
name|b
operator|->
name|fl
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this resets a buffer and starts the isa dma on that channel.  * Must be called when the dma on the card is disabled (e.g. after init).  */
end_comment

begin_function
name|void
name|reset_dbuf
parameter_list|(
name|snd_dbuf
modifier|*
name|b
parameter_list|,
name|int
name|chan
parameter_list|)
block|{
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"reset dbuf for chan %d\n"
argument_list|,
name|b
operator|->
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|rp
operator|=
name|b
operator|->
name|fp
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|dl
operator|=
name|b
operator|->
name|rl
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|fl
operator|=
name|b
operator|->
name|bufsize
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|SND_CHAN_NONE
condition|)
return|return ;
if|if
condition|(
name|chan
operator|==
name|SND_CHAN_WR
condition|)
name|chan
operator|=
name|B_WRITE
operator||
name|B_RAW
expr_stmt|;
else|else
name|chan
operator|=
name|B_READ
operator||
name|B_RAW
expr_stmt|;
name|isa_dmastart
argument_list|(
name|chan
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * snd_sync waits until the space in the given channel goes above  * a threshold. chan = 1 : play, 2: capture. The threshold is  * checked against fl or rl respectively.  * Assume that the condition can become true, do not check here...  */
end_comment

begin_function
name|int
name|snd_sync
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|int
name|chan
parameter_list|,
name|int
name|threshold
parameter_list|)
block|{
name|u_long
name|s
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
decl_stmt|;
name|b
operator|=
operator|(
name|chan
operator|==
literal|1
operator|)
condition|?
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
else|:
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|chan
operator|==
literal|1
condition|)
name|dsp_wr_dmaupdate
argument_list|(
name|b
argument_list|)
expr_stmt|;
else|else
name|dsp_rd_dmaupdate
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chan
operator|==
literal|1
operator|&&
name|b
operator|->
name|fl
operator|<=
name|threshold
operator|)
operator|||
operator|(
name|chan
operator|==
literal|2
operator|&&
name|b
operator|->
name|rl
operator|<=
name|threshold
operator|)
condition|)
block|{
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"sndsyn"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ERESTART
operator|||
name|ret
operator|==
name|EINTR
condition|)
block|{
name|printf
argument_list|(
literal|"tsleep returns %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * dsp_wrabort(d) and dsp_rdabort(d) are non-blocking functions  * which abort a pending DMA transfer and flush the buffers.  * They return the number of bytes that has not been transferred.  * The second parameter is used to restart the engine if needed.  */
end_comment

begin_function
name|int
name|dsp_wrabort
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|int
name|restart
parameter_list|)
block|{
name|long
name|s
decl_stmt|;
name|int
name|missing
init|=
literal|0
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_WRITING
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|callback
condition|)
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_WR
operator||
name|SND_CB_ABORT
argument_list|)
expr_stmt|;
name|isa_dmastop
argument_list|(
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
name|dsp_wr_dmadone
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"dsp_wrabort: stopped, %d bytes left\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|missing
operator|=
name|b
operator|->
name|rl
expr_stmt|;
name|isa_dmadone
argument_list|(
name|B_WRITE
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
comment|/*free chan */
name|reset_dbuf
argument_list|(
name|b
argument_list|,
name|restart
condition|?
name|SND_CHAN_WR
else|:
name|SND_CHAN_NONE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|missing
return|;
block|}
end_function

begin_function
name|int
name|dsp_rdabort
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|,
name|int
name|restart
parameter_list|)
block|{
name|long
name|s
decl_stmt|;
name|int
name|missing
init|=
literal|0
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_in
operator|)
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|dl
condition|)
block|{
name|b
operator|->
name|dl
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_READING
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|callback
condition|)
name|d
operator|->
name|callback
argument_list|(
name|d
argument_list|,
name|SND_CB_RD
operator||
name|SND_CB_ABORT
argument_list|)
expr_stmt|;
name|isa_dmastop
argument_list|(
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
name|dsp_rd_dmadone
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
name|missing
operator|=
name|b
operator|->
name|rl
expr_stmt|;
name|isa_dmadone
argument_list|(
name|B_READ
argument_list|,
name|b
operator|->
name|buf
argument_list|,
name|b
operator|->
name|bufsize
argument_list|,
name|b
operator|->
name|chan
argument_list|)
expr_stmt|;
name|reset_dbuf
argument_list|(
name|b
argument_list|,
name|restart
condition|?
name|SND_CHAN_RD
else|:
name|SND_CHAN_NONE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|missing
return|;
block|}
end_function

begin_comment
comment|/*  * this routine tries to flush the dma transfer. It is called  * on a close. The caller must set SND_F_CLOSING, and insure that  * interrupts are enabled. We immediately abort any read DMA  * operation, and then wait for the play buffer to drain.  */
end_comment

begin_function
name|int
name|snd_flush
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|count
init|=
literal|10
decl_stmt|;
name|u_long
name|s
decl_stmt|;
name|snd_dbuf
modifier|*
name|b
init|=
operator|&
operator|(
name|d
operator|->
name|dbuf_out
operator|)
decl_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"snd_flush d->flags 0x%08x\n"
argument_list|,
name|d
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|dsp_rdabort
argument_list|(
name|d
argument_list|,
literal|0
comment|/* no restart */
argument_list|)
expr_stmt|;
comment|/* close write */
while|while
condition|(
name|b
operator|->
name|dl
condition|)
block|{
comment|/* 	 * still pending output data. 	 */
name|ret
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|b
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"dmafl1"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|dsp_wr_dmaupdate
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"snd_sync: now rl : fl  %d : %d\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|b
operator|->
name|fl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|EINTR
condition|)
block|{
name|printf
argument_list|(
literal|"tsleep returns %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ret
operator|&&
operator|--
name|count
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"timeout flushing dbuf_out.chan, cnt 0x%x flags 0x%08lx\n"
argument_list|,
name|b
operator|->
name|rl
argument_list|,
name|d
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* should not be necessary... */
name|d
operator|->
name|flags
operator|&=
operator|~
name|SND_F_CLOSING
expr_stmt|;
name|dsp_wrabort
argument_list|(
name|d
argument_list|,
literal|0
comment|/* no restart */
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * end of new code for dma buffer handling  */
end_comment

end_unit

