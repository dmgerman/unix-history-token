begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/clones.c  *   * init code for enabling clone cards to work in sb/mss emulation.  *  * Note -- this code is currently unused!  *  * Copyright by Luigi Rizzo - 1997  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met: 1. Redistributions of source code must retain the above  * copyright notice, this list of conditions and the following  * disclaimer. 2.  Redistributions in binary form must reproduce the  * above copyright notice, this list of conditions and the following  * disclaimer in the documentation and/or other materials provided  * with the distribution.  *    * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS''  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR  * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF  * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * This file has been written using information from various sources  * in the Voxware 3.5 distribution.  */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/snd/sound.h>
end_include

begin_if
if|#
directive|if
name|NPCM
operator|>
literal|0
end_if

begin_comment
comment|/*  * Known clones card include:  *  * Trix (emulating MSS)  * MAD16 (emulating MSS)  * OPTi930 -- same as the OPTi931, but no PnP ?  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|JAZZ16
end_ifdef

begin_comment
comment|/*  * Initialization of a Media Vision ProSonic 16 Soundcard. The function  * initializes a ProSonic 16 like PROS.EXE does for DOS. It sets the base  * address, the DMA-channels, interrupts and enables the joystickport.  *   * Also used by Jazz 16 (same card, different name)  *   * written 1994 by Rainer Vranken E-Mail:  * rvranken@polaris.informatik.uni-essen.de  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SM_WAVE
end_ifdef

begin_comment
comment|/*  * Logitech Soundman Wave detection and initialization by Hannu Savolainen.  *   * There is a microcontroller (8031) in the SM Wave card for MIDI emulation.  * it's located at address MPU_BASE+4.  MPU_BASE+7 is a SM Wave specific  * control register for MC reset, SCSI, OPL4 and DSP (future expansion)  * address decoding. Otherwise the SM Wave is just a ordinary MV Jazz16 based  * soundcard.  */
end_comment

begin_function
specifier|static
name|void
name|smw_putmem
parameter_list|(
name|int
name|base
parameter_list|,
name|int
name|addr
parameter_list|,
name|u_char
name|val
parameter_list|)
block|{
name|u_long
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
literal|1
argument_list|,
name|addr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Low address bits */
name|outb
argument_list|(
name|base
operator|+
literal|2
argument_list|,
name|addr
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* High address bits */
name|outb
argument_list|(
name|base
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* Data */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_char
name|smw_getmem
parameter_list|(
name|int
name|base
parameter_list|,
name|int
name|addr
parameter_list|)
block|{
name|u_long
name|s
decl_stmt|;
name|u_char
name|val
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
literal|1
argument_list|,
name|addr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Low address bits */
name|outb
argument_list|(
name|base
operator|+
literal|2
argument_list|,
name|addr
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* High address bits */
name|val
operator|=
name|inb
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* Data */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMW_MIDI0001_INCLUDED
end_ifdef

begin_include
include|#
directive|include
file|</sys/i386/isa/snd/smw-midi0001.h>
end_include

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|u_char
modifier|*
name|smw_ucode
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|smw_ucodeLen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SWM_MIDI0001_INCLUDED */
end_comment

begin_function
specifier|static
name|int
name|initialize_smw
parameter_list|(
name|int
name|mpu_base
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|mp_base
init|=
name|mpu_base
operator|+
literal|4
decl_stmt|;
comment|/* Microcontroller base */
name|u_char
name|control
decl_stmt|;
comment|/*      * Reset the microcontroller so that the RAM can be accessed      */
name|control
operator|=
name|inb
argument_list|(
name|mpu_base
operator|+
literal|7
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|mpu_base
operator|+
literal|7
argument_list|,
name|control
operator||
literal|3
argument_list|)
expr_stmt|;
comment|/* Set last two bits to 1 (?) */
name|outb
argument_list|(
name|mpu_base
operator|+
literal|7
argument_list|,
operator|(
name|control
operator|&
literal|0xfe
operator|)
operator||
literal|2
argument_list|)
expr_stmt|;
comment|/* xxxxxxx0 resets the mc */
name|DELAY
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
comment|/* Wait at least 1ms */
name|outb
argument_list|(
name|mpu_base
operator|+
literal|7
argument_list|,
name|control
operator|&
literal|0xfc
argument_list|)
expr_stmt|;
comment|/* xxxxxx00 enables RAM */
comment|/*      * Detect microcontroller by probing the 8k RAM area      */
name|smw_putmem
argument_list|(
name|mp_base
argument_list|,
literal|0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|smw_putmem
argument_list|(
name|mp_base
argument_list|,
literal|1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|smw_getmem
argument_list|(
name|mp_base
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0x00
operator|||
name|smw_getmem
argument_list|(
name|mp_base
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"\nSM Wave: No microcontroller RAM detected (%02x, %02x)\n"
argument_list|,
name|smw_getmem
argument_list|(
name|mp_base
argument_list|,
literal|0
argument_list|)
argument_list|,
name|smw_getmem
argument_list|(
name|mp_base
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* No RAM */
block|}
comment|/*      * There is RAM so assume it's really a SM Wave      */
if|if
condition|(
name|smw_ucodeLen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|smw_ucodeLen
operator|!=
literal|8192
condition|)
block|{
name|printf
argument_list|(
literal|"\nSM Wave: Invalid microcode (MIDI0001.BIN) length\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Download microcode 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8192
condition|;
name|i
operator|++
control|)
name|smw_putmem
argument_list|(
name|mp_base
argument_list|,
name|i
argument_list|,
name|smw_ucode
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Verify microcode 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8192
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|smw_getmem
argument_list|(
name|mp_base
argument_list|,
name|i
argument_list|)
operator|!=
name|smw_ucode
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"SM Wave: Microcode verification failed\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|control
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SMW_SCSI_IRQ
comment|/*      * Set the SCSI interrupt (IRQ2/9, IRQ3 or IRQ10). The SCSI interrupt      * is disabled by default.      *       * Btw the Zilog 5380 SCSI controller is located at MPU base + 0x10.      */
block|{
specifier|static
name|u_char
name|scsi_irq_bits
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|control
operator||=
name|scsi_irq_bits
index|[
name|SMW_SCSI_IRQ
index|]
operator|<<
literal|6
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SMW_OPL4_ENABLE
comment|/*      * Make the OPL4 chip visible on the PC bus at 0x380.      *       * There is no need to enable this feature since VoxWare doesn't support      * OPL4 yet. Also there is no RAM in SM Wave so enabling OPL4 is      * pretty useless.      */
name|control
operator||=
literal|0x10
expr_stmt|;
comment|/* Uses IRQ12 if bit 0x20 == 0 */
comment|/* control |= 0x20;      Uncomment this if you want to use IRQ7 */
endif|#
directive|endif
name|outb
argument_list|(
name|mpu_base
operator|+
literal|7
argument_list|,
name|control
operator||
literal|0x03
argument_list|)
expr_stmt|;
comment|/* xxxxxx11 restarts */
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * this is only called during the probe. Variables are found in  * sb_probed.  */
end_comment

begin_decl_stmt
specifier|static
name|sbdev_info
name|sb_probed
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|initialize_ProSonic16
parameter_list|(
name|snddev_info
modifier|*
name|d
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
specifier|static
name|u_char
name|int_translat
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|2
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|6
block|}
decl_stmt|,
name|dma_translat
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|4
block|}
decl_stmt|;
name|struct
name|address_info
modifier|*
name|mpu_config
decl_stmt|;
name|int
name|mpu_base
decl_stmt|,
name|mpu_irq
decl_stmt|;
if|if
condition|(
operator|(
name|mpu_config
operator|=
name|NULL
operator|)
condition|)
block|{
name|mpu_base
operator|=
name|mpu_config
operator|->
name|io_base
expr_stmt|;
name|mpu_irq
operator|=
name|mpu_config
operator|->
name|irq
expr_stmt|;
block|}
else|else
block|{
name|mpu_base
operator|=
name|mpu_irq
operator|=
literal|0
expr_stmt|;
block|}
name|outb
argument_list|(
literal|0x201
argument_list|,
literal|0xAF
argument_list|)
expr_stmt|;
comment|/* ProSonic/Jazz16 wakeup */
name|DELAY
argument_list|(
literal|15000
argument_list|)
expr_stmt|;
comment|/* wait at least 10 milliseconds */
name|outb
argument_list|(
literal|0x201
argument_list|,
literal|0x50
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x201
argument_list|,
operator|(
name|sb_probed
operator|.
name|io_base
operator|&
literal|0x70
operator|)
operator||
operator|(
operator|(
name|mpu_base
operator|&
literal|0x30
operator|)
operator|>>
literal|4
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb_reset_dsp
argument_list|(
name|sb_probed
operator|.
name|io_base
argument_list|)
condition|)
block|{
comment|/* OK. We have at least a SB */
comment|/* Check the version number of ProSonic (I guess) */
if|if
condition|(
operator|!
name|sb_cmd
argument_list|(
name|sb_probed
operator|.
name|io_base
argument_list|,
literal|0xFA
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|sb_get_byte
argument_list|(
name|sb_probed
operator|.
name|io_base
argument_list|)
operator|!=
literal|0x12
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|sb_cmd
argument_list|(
name|sb_probed
operator|.
name|io_base
argument_list|,
literal|0xFB
argument_list|)
operator|&&
comment|/* set DMA and irq */
name|sb_cmd
argument_list|(
name|sb_probed
operator|.
name|io_base
argument_list|,
operator|(
name|dma_translat
index|[
name|JAZZ_DMA16
index|]
operator|<<
literal|4
operator|)
operator||
name|dma_translat
index|[
name|sb_probed
operator|.
name|dbuf_out
operator|.
name|chan
index|]
argument_list|)
operator|&&
name|sb_cmd
argument_list|(
name|sb_probed
operator|.
name|io_base
argument_list|,
operator|(
name|int_translat
index|[
name|mpu_irq
index|]
operator|<<
literal|4
operator|)
operator||
name|int_translat
index|[
name|sb_probed
operator|.
name|irq
index|]
argument_list|)
condition|)
block|{
name|d
operator|->
name|bf_flags
operator||=
name|BD_F_JAZZ16
expr_stmt|;
if|if
condition|(
name|mpu_base
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Jazz16: No MPU401 devices configured "
literal|"- MIDI port not initialized\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SM_WAVE
if|if
condition|(
name|mpu_base
operator|!=
literal|0
condition|)
if|if
condition|(
name|initialize_smw
argument_list|(
name|mpu_base
argument_list|)
condition|)
name|d
operator|->
name|bf_flags
operator||=
name|BD_F_JAZZ16_2
expr_stmt|;
endif|#
directive|endif
comment|/* sb_dsp_disable_midi(); */
block|}
return|return
literal|1
return|;
comment|/* There was at least a SB */
block|}
return|return
literal|0
return|;
comment|/* No SB or ProSonic16 detected */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ifdef JAZZ16  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCM */
end_comment

end_unit

