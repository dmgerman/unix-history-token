begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1993	Allen K. Briggs, Chris P. Caputo,  *			Michael L. Finch, Bradley A. Grantham, and  *			Lawrence A. Kesteloot  * Copyright (C) 1994	Poul-Henning Kamp  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the Alice Group.  * 4. The names of the Alice Group or any of its members may not be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE ALICE GROUP ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE ALICE GROUP BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Id: pas.c,v 1.8.2.1 1994/07/11 00:02:32 cgd Exp $  *  */
end_comment

begin_comment
comment|/* Modified for use with the pc532 by Phil Nelson, Feb 94.  * Modified for use with MediaVision ProAudioSpectrum type adapters  * under FreeBSD by Poul-Henning Kamp,  */
end_comment

begin_include
include|#
directive|include
file|"pas.h"
end_include

begin_if
if|#
directive|if
name|NPAS
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"cdio.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"dkbad.h"
end_include

begin_include
include|#
directive|include
file|"disklabel.h"
end_include

begin_include
include|#
directive|include
file|"icu.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|"ic/ncr_5380.h"
end_include

begin_comment
comment|/* What we need to debug the driver */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PAS_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|int
name|pas_show_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|HERE
parameter_list|()
value|printf("<%d>",__LINE__)
end_define

begin_define
define|#
directive|define
name|ARGH
parameter_list|()
value|printf("[%d]",__LINE__)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PAS_DEBUG */
end_comment

begin_define
define|#
directive|define
name|HERE
parameter_list|()
end_define

begin_comment
comment|/**/
end_comment

begin_define
define|#
directive|define
name|ARGH
parameter_list|()
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PAS_DEBUG */
end_comment

begin_define
define|#
directive|define
name|SCSI_PHASE_DATA_OUT
value|0x0
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_DATA_IN
value|0x1
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_CMD
value|0x2
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_STATUS
value|0x3
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_UNSPEC1
value|0x4
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_UNSPEC2
value|0x5
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_MESSAGE_OUT
value|0x6
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_MESSAGE_IN
value|0x7
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE
parameter_list|(
name|x
parameter_list|)
value|((x)&0x7)
end_define

begin_define
define|#
directive|define
name|SCSI_RET_SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|SCSI_RET_RETRY
value|1
end_define

begin_define
define|#
directive|define
name|SCSI_RET_DEVICE_DOWN
value|2
end_define

begin_define
define|#
directive|define
name|SCSI_RET_COMMAND_FAIL
value|3
end_define

begin_comment
comment|/* Our per device (card) structure */
end_comment

begin_struct
specifier|static
struct|struct
name|pas_softc
block|{
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
name|int
name|mv_unit
decl_stmt|;
name|u_short
name|iobase
decl_stmt|;
define|#
directive|define
name|sci_data
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->iobase+0x0)
define|#
directive|define
name|sci_icmd
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->iobase+0x1)
define|#
directive|define
name|sci_mode
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->iobase+0x2)
define|#
directive|define
name|sci_tcmd
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->iobase+0x3)
define|#
directive|define
name|sci_bus_csr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->iobase+0x2000)
define|#
directive|define
name|sci_csr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->iobase+0x2001)
define|#
directive|define
name|sci_idata
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->iobase+0x2002)
define|#
directive|define
name|sci_iack
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->iobase+0x2003)
define|#
directive|define
name|sci_pdmadata
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->iobase+0x4000)
define|#
directive|define
name|sci_pdmastat
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->iobase+0x4001)
block|}
name|s_pas
index|[
name|NPAS
index|]
struct|;
end_struct

begin_comment
comment|/* Our access to the 5380 chip */
end_comment

begin_define
define|#
directive|define
name|P_PAS
value|struct pas_softc *
end_define

begin_define
define|#
directive|define
name|R_PAS
parameter_list|(
name|ptr
parameter_list|,
name|foo
parameter_list|)
value|inb(foo(ptr))
end_define

begin_define
define|#
directive|define
name|W_PAS
parameter_list|(
name|ptr
parameter_list|,
name|foo
parameter_list|,
name|val
parameter_list|)
value|outb(foo(ptr),val)
end_define

begin_define
define|#
directive|define
name|M_PAS
parameter_list|(
name|ptr
parameter_list|,
name|foo
parameter_list|,
name|opr
parameter_list|,
name|arg
parameter_list|)
value|outb(foo(ptr),R_PAS(ptr,foo) opr arg)
end_define

begin_define
define|#
directive|define
name|PSEUDO_DMA
value|0
end_define

begin_if
if|#
directive|if
name|PSEUDO_DMA
end_if

begin_comment
comment|/* static int		sci_pdma_out(P_PAS, int, int, u_char *); */
end_comment

begin_define
define|#
directive|define
name|sci_pdma_out
value|sci_data_out
end_define

begin_function_decl
specifier|static
name|int
name|sci_pdma_in
parameter_list|(
name|P_PAS
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PSEUDO_DMA */
end_comment

begin_define
define|#
directive|define
name|sci_pdma_out
value|sci_data_out
end_define

begin_define
define|#
directive|define
name|sci_pdma_in
value|sci_data_in
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PSEUDO_DMA */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pas_foo
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SCI_CLR_INTR
parameter_list|(
name|ptr
parameter_list|)
value|{pas_foo += R_PAS(ptr,sci_iack);}
end_define

begin_define
define|#
directive|define
name|SCI_PHASE_DISC
value|0
end_define

begin_comment
comment|/* sort of ... */
end_comment

begin_define
define|#
directive|define
name|SCI_ACK
parameter_list|(
name|ptr
parameter_list|,
name|phase
parameter_list|)
value|{W_PAS(ptr,sci_tcmd,phase);}
end_define

begin_define
define|#
directive|define
name|SCSI_TIMEOUT_VAL
value|10000000
end_define

begin_define
define|#
directive|define
name|WAIT_FOR_NOT_REQ
parameter_list|(
name|ptr
parameter_list|)
value|{	\     int scsi_timeout = SCSI_TIMEOUT_VAL; \     while ( (R_PAS(ptr,sci_bus_csr)& SCI_BUS_REQ)&& \ 	    (R_PAS(ptr,sci_bus_csr)& SCI_BUS_REQ)&& \ 	    (R_PAS(ptr,sci_bus_csr)& SCI_BUS_REQ)&& \ 	     (--scsi_timeout) ); \     if (!scsi_timeout) { \ 	printf("scsi timeout--WAIT_FOR_NOT_REQ-- pas.c:%d.\n", __LINE__); \ 	goto scsi_timeout_error; \     } \ }
end_define

begin_define
define|#
directive|define
name|WAIT_FOR_REQ
parameter_list|(
name|ptr
parameter_list|)
value|{	\     int scsi_timeout = SCSI_TIMEOUT_VAL; \     while ( ((R_PAS(ptr,sci_bus_csr)& SCI_BUS_REQ) == 0)&& \ 	    ((R_PAS(ptr,sci_bus_csr)& SCI_BUS_REQ) == 0)&& \ 	    ((R_PAS(ptr,sci_bus_csr)& SCI_BUS_REQ) == 0)&& \ 	     (--scsi_timeout) ); \     if (!scsi_timeout) { \ 	printf("scsi timeout--WAIT_FOR_REQ-- pas.c:%d.\n", __LINE__); \ 	goto scsi_timeout_error; \     } \ }
end_define

begin_define
define|#
directive|define
name|WAIT_FOR_BSY
parameter_list|(
name|ptr
parameter_list|)
value|{	\     int scsi_timeout = SCSI_TIMEOUT_VAL; \     while ( ((R_PAS(ptr,sci_bus_csr)& SCI_BUS_BSY) == 0)&& \ 	    ((R_PAS(ptr,sci_bus_csr)& SCI_BUS_BSY) == 0)&& \ 	    ((R_PAS(ptr,sci_bus_csr)& SCI_BUS_BSY) == 0)&& \ 	     (--scsi_timeout) ); \     if (!scsi_timeout) { \ 	printf("scsi timeout--WAIT_FOR_BSY-- pas.c:%d.\n", __LINE__); \ 	goto scsi_timeout_error; \     } \ }
end_define

begin_function_decl
specifier|static
name|u_int32
name|pas_adapter_info
parameter_list|(
name|int
name|adapter_number
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pas_minphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32
name|pas_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pas_reset_target
parameter_list|(
name|int
name|adapter
parameter_list|,
name|int
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pas_poll
parameter_list|(
name|int
name|adapter
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pas_send_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsi_req
parameter_list|(
name|P_PAS
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsi_group0
parameter_list|(
name|int
name|adapter
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|lun
parameter_list|,
name|int
name|opcode
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|,
name|caddr_t
name|databuf
parameter_list|,
name|int
name|datalen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sci_data_out
parameter_list|(
name|P_PAS
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sci_data_in
parameter_list|(
name|P_PAS
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|pasprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|pasattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|pasdriver
init|=
block|{
name|pasprobe
block|,
name|pasattach
block|,
literal|"pas"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|pas_adapter
init|=
block|{
name|pas_scsi_cmd
block|,
comment|/* scsi_cmd()		*/
name|pas_minphys
block|,
comment|/* scsi_minphys()	*/
literal|0
block|,
comment|/* open_target_lu()	*/
literal|0
block|,
comment|/* close_target_lu()	*/
name|pas_adapter_info
block|,
comment|/* adapter_info()	*/
literal|"pas"
block|,
comment|/* name			*/
block|{
literal|0
block|,
literal|0
block|}
comment|/* spare[2]		*/
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|pas_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler.	    */
name|NULL
block|,
comment|/* have a queue, served by this (?) */
name|NULL
block|,
comment|/* have no async handler.	    */
name|NULL
block|,
comment|/* Use default "done" routine.	    */
literal|"pas"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mv_type
index|[]
init|=
block|{
literal|"?"
literal|"PAS"
block|,
literal|"PAS+"
block|,
literal|"CDPC"
block|,
literal|"PAS16C"
block|,
literal|"PAS16D"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pasprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|port
init|=
name|dev
operator|->
name|id_iobase
decl_stmt|;
name|int
name|base
init|=
name|port
operator|-
literal|0x1c00
decl_stmt|;
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Tell the PAS16 we want to talk to, where to listen */
name|outb
argument_list|(
literal|0x9a01
argument_list|,
literal|0xbc
operator|+
name|unit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x9a01
argument_list|,
name|base
operator|>>
literal|2
argument_list|)
expr_stmt|;
comment|/* Various magic */
name|outb
argument_list|(
name|base
operator|+
literal|0x4000
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
literal|0x4001
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
literal|0xbc00
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Killer one */
name|i
operator|=
name|inb
argument_list|(
name|base
operator|+
literal|0x803
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0xff
condition|)
return|return
literal|0
return|;
comment|/* killer two */
name|outb
argument_list|(
name|base
operator|+
literal|0x803
argument_list|,
name|i
operator|^
literal|0xe0
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
name|base
operator|+
literal|0x803
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
literal|0x803
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|j
condition|)
return|return
literal|0
return|;
comment|/* killer three */
if|if
condition|(
operator|(
literal|0x03
operator|&
name|inb
argument_list|(
name|base
operator|+
literal|0xec03
argument_list|)
operator|)
operator|!=
literal|0x03
condition|)
return|return
literal|0
return|;
comment|/* killer four */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|port
argument_list|)
operator|!=
literal|0xff
operator|||
name|inb
argument_list|(
name|port
operator|+
literal|0x2000
argument_list|)
operator|!=
literal|0xff
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32
name|pas_adapter_info
parameter_list|(
name|int
name|adapter_number
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|pasattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|pas_softc
modifier|*
name|ppas
decl_stmt|;
name|i
operator|=
name|inb
argument_list|(
name|dev
operator|->
name|id_iobase
operator|-
literal|0x1c00
operator|+
literal|0xFC00
argument_list|)
operator|>>
literal|5
expr_stmt|;
if|if
condition|(
name|i
operator|>=
operator|(
sizeof|sizeof
name|mv_type
operator|/
sizeof|sizeof
expr|*
name|mv_type
operator|)
condition|)
name|j
operator|=
literal|0
expr_stmt|;
else|else
name|j
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"pas%d: Type = %d<%s>\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|i
argument_list|,
name|mv_type
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|ppas
operator|=
name|s_pas
operator|+
name|dev
operator|->
name|id_unit
expr_stmt|;
name|ppas
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
name|ppas
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
literal|7
expr_stmt|;
name|ppas
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|pas_adapter
expr_stmt|;
name|ppas
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|pas_dev
expr_stmt|;
name|ppas
operator|->
name|iobase
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|STILL_NO_INTR
comment|/* As of yet we havn't bothered with interrupts, so don't bother */
name|j
operator|=
name|inb
argument_list|(
name|dev
operator|->
name|id_iobase
operator|-
literal|0x1c00
operator|+
literal|0xf002
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dev
operator|->
name|id_irq
condition|)
block|{
case|case
name|IRQ2
case|:
name|i
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|IRQ3
case|:
name|i
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|IRQ4
case|:
name|i
operator|=
literal|3
expr_stmt|;
break|break;
case|case
name|IRQ5
case|:
name|i
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|IRQ6
case|:
name|i
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|IRQ7
case|:
name|i
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|IRQ10
case|:
name|i
operator|=
literal|7
expr_stmt|;
break|break;
case|case
name|IRQ11
case|:
name|i
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|IRQ12
case|:
name|i
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|IRQ14
case|:
name|i
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|IRQ15
case|:
name|i
operator|=
literal|11
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Intr %d unknown\n"
argument_list|,
name|dev
operator|->
name|id_irq
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"brag!"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"0xf002 irq%d code=%x, before %x,"
argument_list|,
name|dev
operator|->
name|id_irq
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|j
operator|&=
literal|0x0f
expr_stmt|;
name|j
operator||=
operator|(
name|i
operator|<<
literal|4
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|" after= %x \n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|dev
operator|->
name|id_iobase
operator|-
literal|0x1c00
operator|+
literal|0xf002
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|dev
operator|->
name|id_iobase
operator|-
literal|0x1c00
operator|+
literal|0x8003
argument_list|,
literal|0x4d
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STILL_NO_INTR */
name|scsi_attachdevs
argument_list|(
operator|&
operator|(
name|ppas
operator|->
name|sc_link
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pas_minphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
define|#
directive|define
name|MIN_PHYS
value|65536
comment|/*BARF!!!!*/
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|MIN_PHYS
condition|)
block|{
name|printf
argument_list|(
literal|"Uh-oh...  pas_minphys setting bp->b_bcount = %x.\n"
argument_list|,
name|MIN_PHYS
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|MIN_PHYS
expr_stmt|;
block|}
undef|#
directive|undef
name|MIN_PHYS
block|}
end_function

begin_function
specifier|static
name|int32
name|pas_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|int
name|flags
decl_stmt|,
name|s
decl_stmt|,
name|r
decl_stmt|;
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
name|flags
operator||=
operator|(
name|SCSI_NOSLEEP
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"Already done?"
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Not in use?"
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|printf
argument_list|(
literal|"flags& SCSIRESET.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|pas_reset_target
argument_list|(
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
else|else
block|{
name|pas_reset_target
argument_list|(
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|pas_poll
argument_list|(
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|,
name|xs
operator|->
name|timeout
argument_list|)
condition|)
block|{
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
block|}
comment|/*      * OK.  Now that that's over with, let's pack up that      * SCSI puppy and send it off.  If we can, we'll just      * queue and go; otherwise, we'll wait for the command      * to finish.     if ( ! ( flags& SCSI_NOSLEEP ) ) { 	s = splbio(); 	pas_send_cmd(xs); 	splx(s); 	return(SUCCESSFULLY_QUEUED);     }      */
name|r
operator|=
name|pas_send_cmd
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_NOMASK
condition|)
block|{
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
name|SUCCESSFULLY_QUEUED
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PAS_DEBUG
end_ifdef

begin_function
specifier|static
name|int
name|pas_show_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|u_char
modifier|*
name|b
init|=
operator|(
name|u_char
operator|*
operator|)
name|xs
operator|->
name|cmd
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_RESET
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pas(%d:%d:%d) "
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d@%x, %d@%x<"
argument_list|,
name|xs
operator|->
name|cmdlen
argument_list|,
name|xs
operator|->
name|cmd
argument_list|,
name|xs
operator|->
name|datalen
argument_list|,
name|xs
operator|->
name|data
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|xs
operator|->
name|cmdlen
condition|)
block|{
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
name|b
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|">\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"pas(%d:%d:%d)-RESET-\n"
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PAS_DEBUG */
end_comment

begin_comment
comment|/*  * Actual chip control.  */
end_comment

begin_function
specifier|extern
name|void
name|pasintr
parameter_list|(
name|int
name|adapter
parameter_list|)
block|{
name|struct
name|pas_softc
modifier|*
name|ppas
init|=
name|s_pas
operator|+
name|adapter
decl_stmt|;
name|printf
argument_list|(
literal|"pasintr\n"
argument_list|)
expr_stmt|;
name|SCI_CLR_INTR
argument_list|(
name|ppas
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ppas
argument_list|,
name|sci_mode
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|PHK
end_if

begin_function
specifier|extern
name|int
name|scsi_irq_intr
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*  if (R_PAS(ptr,sci_csr) != SCI_CSR_PHASE_MATCH) 	printf("scsi_irq_intr called (not just phase match -- " 	    "csr = 0x%x, bus_csr = 0x%x).\n", 	    R_PAS(ptr,sci_csr), R_PAS(ptr,sci_bus_csr));     pas_intr(0); */
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|pas_reset_target
parameter_list|(
name|int
name|adapter
parameter_list|,
name|int
name|target
parameter_list|)
block|{
name|struct
name|pas_softc
modifier|*
name|ppas
init|=
name|s_pas
operator|+
name|adapter
decl_stmt|;
name|W_PAS
argument_list|(
name|ppas
argument_list|,
name|sci_icmd
argument_list|,
name|SCI_ICMD_TEST
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ppas
argument_list|,
name|sci_icmd
argument_list|,
name|SCI_ICMD_TEST
operator||
name|SCI_ICMD_RST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ppas
argument_list|,
name|sci_icmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ppas
argument_list|,
name|sci_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ppas
argument_list|,
name|sci_tcmd
argument_list|,
name|SCI_PHASE_DISC
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ppas
argument_list|,
name|sci_sel_enb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCI_CLR_INTR
argument_list|(
name|ppas
argument_list|)
expr_stmt|;
name|SCI_CLR_INTR
argument_list|(
name|ppas
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pas_poll
parameter_list|(
name|int
name|adapter
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pas_send_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|P_PAS
name|ptr
init|=
name|s_pas
operator|+
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
decl_stmt|;
name|int
name|s
decl_stmt|,
name|sent
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|sense
decl_stmt|;
ifdef|#
directive|ifdef
name|PAS_DEBUG
name|pas_show_scsi_cmd
argument_list|(
name|xs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PAS_DEBUG */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|sense
operator|=
name|scsi_req
argument_list|(
name|ptr
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|xs
operator|->
name|cmd
argument_list|,
name|xs
operator|->
name|cmdlen
argument_list|,
name|xs
operator|->
name|data
argument_list|,
name|xs
operator|->
name|datalen
argument_list|,
operator|&
name|sent
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PAS_DEBUG
name|HERE
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"sent=%d,ret=%d,sense=%x "
argument_list|,
name|sent
argument_list|,
name|ret
argument_list|,
name|sense
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PAS_DEBUG */
switch|switch
condition|(
name|sense
condition|)
block|{
case|case
literal|0x00
case|:
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
name|sent
expr_stmt|;
ifdef|#
directive|ifdef
name|PAS_DEBUG
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PAS_DEBUG */
return|return
operator|(
name|COMPLETE
operator|)
return|;
case|case
literal|0x02
case|:
comment|/* Check condition */
ifdef|#
directive|ifdef
name|PAS_DEBUG
name|printf
argument_list|(
literal|"check cond. targ= %d.\n"
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|spinwait
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|scsi_group0
argument_list|(
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
literal|0x3
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
return|return
name|HAD_ERROR
return|;
case|case
literal|0x08
case|:
comment|/* Busy */
name|ARGH
argument_list|()
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
return|return
name|HAD_ERROR
return|;
default|default:
name|ARGH
argument_list|()
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
name|HAD_ERROR
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|select_target
parameter_list|(
name|P_PAS
name|ptr
parameter_list|,
name|u_char
name|myid
parameter_list|,
name|u_char
name|tid
parameter_list|,
name|int
name|with_atn
parameter_list|)
block|{
specifier|register
name|u_char
name|bid
decl_stmt|,
name|icmd
decl_stmt|;
name|int
name|ret
init|=
name|SCSI_RET_RETRY
decl_stmt|;
if|if
condition|(
operator|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_bus_csr
argument_list|)
operator|&
operator|(
name|SCI_BUS_BSY
operator||
name|SCI_BUS_SEL
operator|)
operator|)
operator|&&
operator|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_bus_csr
argument_list|)
operator|&
operator|(
name|SCI_BUS_BSY
operator||
name|SCI_BUS_SEL
operator|)
operator|)
operator|&&
operator|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_bus_csr
argument_list|)
operator|&
operator|(
name|SCI_BUS_BSY
operator||
name|SCI_BUS_SEL
operator|)
operator|)
condition|)
return|return
name|ret
return|;
comment|/* for our purposes.. */
name|myid
operator|=
literal|1
operator|<<
name|myid
expr_stmt|;
name|tid
operator|=
literal|1
operator|<<
name|tid
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_sel_enb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we don't want any interrupts. */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_tcmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get into a harmless state */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* get into a harmless state */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_odata
argument_list|,
name|myid
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_mode
argument_list|,
name|SCI_MODE_ARB
argument_list|)
expr_stmt|;
comment|/* AIP might not set if BSY went true after we checked */
for|for
control|(
name|bid
operator|=
literal|0
init|;
name|bid
operator|<
literal|20
condition|;
name|bid
operator|++
control|)
comment|/* 20usec circa */
if|if
condition|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|)
operator|&
name|SCI_ICMD_AIP
condition|)
break|break;
if|if
condition|(
operator|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|)
operator|&
name|SCI_ICMD_AIP
operator|)
operator|==
literal|0
condition|)
block|{
name|ARGH
argument_list|()
expr_stmt|;
goto|goto
name|lost
goto|;
block|}
name|spinwait
argument_list|(
literal|2
comment|/* was 2 */
argument_list|)
expr_stmt|;
comment|/* 2.2us arb delay */
if|if
condition|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|)
operator|&
name|SCI_ICMD_LST
condition|)
block|{
name|printf
argument_list|(
literal|"lost 1\n"
argument_list|)
expr_stmt|;
goto|goto
name|lost
goto|;
block|}
name|M_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_mode
argument_list|,
operator|&
argument_list|,
operator|~
name|SCI_MODE_PAR_CHK
argument_list|)
expr_stmt|;
name|bid
operator|=
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bid
operator|&
operator|~
name|myid
operator|)
operator|>
name|myid
condition|)
block|{
name|printf
argument_list|(
literal|"lost 2\n"
argument_list|)
expr_stmt|;
goto|goto
name|lost
goto|;
block|}
if|if
condition|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|)
operator|&
name|SCI_ICMD_LST
condition|)
block|{
name|printf
argument_list|(
literal|"lost 3\n"
argument_list|)
expr_stmt|;
goto|goto
name|lost
goto|;
block|}
comment|/* Won arbitration, enter selection phase now */
name|icmd
operator|=
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|)
operator|&
operator|~
operator|(
name|SCI_ICMD_DIFF
operator||
name|SCI_ICMD_TEST
operator|)
expr_stmt|;
name|icmd
operator||=
operator|(
name|with_atn
condition|?
operator|(
name|SCI_ICMD_SEL
operator||
name|SCI_ICMD_ATN
operator|)
else|:
name|SCI_ICMD_SEL
operator|)
expr_stmt|;
name|icmd
operator||=
name|SCI_ICMD_BSY
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|)
operator|&
name|SCI_ICMD_LST
condition|)
block|{
name|printf
argument_list|(
literal|"nosel\n"
argument_list|)
expr_stmt|;
goto|goto
name|nosel
goto|;
block|}
comment|/* XXX a target that violates specs might still drive the bus XXX */
comment|/* XXX should put our id out, and after the delay check nothi XXX */
comment|/* XXX ng else is out there.				      XXX */
name|DELAY
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_tcmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_odata
argument_list|,
name|myid
operator||
name|tid
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_sel_enb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|M_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_mode
argument_list|,
operator|&
argument_list|,
operator|~
name|SCI_MODE_ARB
argument_list|)
expr_stmt|;
comment|/* 2 deskew delays, too */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|icmd
operator||=
name|SCI_ICMD_DATA
expr_stmt|;
name|icmd
operator|&=
operator|~
operator|(
name|SCI_ICMD_BSY
operator|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
comment|/* bus settle delay, 400ns */
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* too much (was 2) ? */
comment|/*  M_PAS(ptr,sci_mode, |, SCI_MODE_PAR_CHK); */
block|{
specifier|register
name|int
name|timeo
init|=
literal|2500
decl_stmt|;
comment|/* 250 msecs in 100 usecs chunks */
while|while
condition|(
operator|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_bus_csr
argument_list|)
operator|&
name|SCI_BUS_BSY
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|timeo
operator|>
literal|0
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ARGH
argument_list|()
expr_stmt|;
goto|goto
name|nodev
goto|;
block|}
block|}
block|}
name|icmd
operator|&=
operator|~
operator|(
name|SCI_ICMD_DATA
operator||
name|SCI_ICMD_SEL
operator|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
comment|/*	ptr->sci_sel_enb = myid;*/
comment|/* looks like we should NOT have it */
return|return
name|SCSI_RET_SUCCESS
return|;
name|nodev
label|:
name|ret
operator|=
name|SCSI_RET_DEVICE_DOWN
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_sel_enb
argument_list|,
name|myid
argument_list|)
expr_stmt|;
name|nosel
label|:
name|icmd
operator|&=
operator|~
operator|(
name|SCI_ICMD_DATA
operator||
name|SCI_ICMD_SEL
operator||
name|SCI_ICMD_ATN
operator|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
name|lost
label|:
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sci_data_out
parameter_list|(
name|P_PAS
name|ptr
parameter_list|,
name|int
name|phase
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
name|icmd
decl_stmt|;
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PAS_DEBUG
name|printf
argument_list|(
literal|"out%d@%x "
argument_list|,
name|count
argument_list|,
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PAS_DEBUG */
comment|/* ..checks.. */
name|icmd
operator|=
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|)
operator|&
operator|~
operator|(
name|SCI_ICMD_DIFF
operator||
name|SCI_ICMD_TEST
operator|)
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|SCI_CUR_PHASE
argument_list|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_bus_csr
argument_list|)
argument_list|)
operator|!=
name|phase
condition|)
return|return
name|cnt
return|;
name|WAIT_FOR_REQ
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|icmd
operator||=
name|SCI_ICMD_DATA
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_odata
argument_list|,
operator|*
name|data
operator|++
argument_list|)
expr_stmt|;
name|icmd
operator||=
name|SCI_ICMD_ACK
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
name|icmd
operator|&=
operator|~
operator|(
name|SCI_ICMD_DATA
operator||
name|SCI_ICMD_ACK
operator|)
expr_stmt|;
name|WAIT_FOR_NOT_REQ
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
if|if
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
name|scsi_timeout_error
label|:
return|return
name|cnt
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sci_data_in
parameter_list|(
name|P_PAS
name|ptr
parameter_list|,
name|int
name|phase
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
name|icmd
decl_stmt|;
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PAS_DEBUG
name|printf
argument_list|(
literal|"in%d@%x "
argument_list|,
name|count
argument_list|,
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PAS_DEBUG */
comment|/* ..checks.. */
name|icmd
operator|=
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|)
operator|&
operator|~
operator|(
name|SCI_ICMD_DIFF
operator||
name|SCI_ICMD_TEST
operator|)
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|SCI_CUR_PHASE
argument_list|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_bus_csr
argument_list|)
argument_list|)
operator|!=
name|phase
condition|)
return|return
name|cnt
return|;
name|WAIT_FOR_REQ
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|data
operator|++
operator|=
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_data
argument_list|)
expr_stmt|;
name|icmd
operator||=
name|SCI_ICMD_ACK
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
name|icmd
operator|&=
operator|~
name|SCI_ICMD_ACK
expr_stmt|;
name|WAIT_FOR_NOT_REQ
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
if|if
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
name|scsi_timeout_error
label|:
return|return
name|cnt
return|;
block|}
end_function

begin_if
if|#
directive|if
name|PSEUDO_DMA
end_if

begin_function
specifier|static
name|int
name|sci_pdma_in
parameter_list|(
name|P_PAS
name|ptr
parameter_list|,
name|int
name|phase
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
name|icmd
decl_stmt|;
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PAS_DEBUG
name|printf
argument_list|(
literal|"in%d@%x "
argument_list|,
name|count
argument_list|,
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PAS_DEBUG */
name|WAIT_FOR_BSY
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|M_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_mode
argument_list|,
operator||
argument_list|,
name|SCI_MODE_DMA
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_dma_send
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|M_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|,
operator||
argument_list|,
name|SCI_ICMD_DATA
argument_list|)
expr_stmt|;
comment|/*     while(R_PAS(ptr,sci_pdmastat)& 0x80) ; */
for|for
control|(
init|;
name|cnt
operator|<
name|count
condition|;
name|cnt
operator|++
control|)
operator|*
name|data
operator|++
operator|=
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_pdmadata
argument_list|)
expr_stmt|;
name|scsi_timeout_error
label|:
name|M_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_mode
argument_list|,
operator|&
argument_list|,
operator|~
name|SCI_MODE_DMA
argument_list|)
expr_stmt|;
name|M_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|,
operator|&
argument_list|,
operator|~
name|SCI_ICMD_DATA
argument_list|)
expr_stmt|;
return|return
name|cnt
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PSEUDO_DMA */
end_comment

begin_function
specifier|static
name|int
name|cmd_xfer
parameter_list|(
name|P_PAS
name|ptr
parameter_list|,
name|int
name|maxlen
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|u_char
modifier|*
name|status
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|xfer
init|=
literal|0
decl_stmt|,
name|phase
decl_stmt|;
ifdef|#
directive|ifdef
name|PAS_DEBUG
name|printf
argument_list|(
literal|"cmd_xfer called for 0x%x.\n"
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PAS_DEBUG */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|WAIT_FOR_REQ
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|phase
operator|=
name|SCI_CUR_PHASE
argument_list|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_bus_csr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
name|SCSI_PHASE_CMD
case|:
name|SCI_ACK
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_CMD
argument_list|)
expr_stmt|;
name|xfer
operator|+=
name|sci_data_out
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_CMD
argument_list|,
name|maxlen
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|xfer
return|;
case|case
name|SCSI_PHASE_DATA_IN
case|:
name|printf
argument_list|(
literal|"Data in phase in cmd_xfer?\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SCSI_PHASE_DATA_OUT
case|:
name|printf
argument_list|(
literal|"Data out phase in cmd_xfer?\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SCSI_PHASE_STATUS
case|:
name|SCI_ACK
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_STATUS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"status in cmd_xfer.\n"
argument_list|)
expr_stmt|;
name|sci_data_in
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_STATUS
argument_list|,
literal|1
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PHASE_MESSAGE_IN
case|:
name|SCI_ACK
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_MESSAGE_IN
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"msgin in cmd_xfer.\n"
argument_list|)
expr_stmt|;
name|sci_data_in
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_MESSAGE_IN
argument_list|,
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PHASE_MESSAGE_OUT
case|:
name|SCI_ACK
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_MESSAGE_OUT
argument_list|)
expr_stmt|;
name|sci_data_out
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_MESSAGE_OUT
argument_list|,
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unexpected phase 0x%x in cmd_xfer()\n"
argument_list|,
name|phase
argument_list|)
expr_stmt|;
name|scsi_timeout_error
label|:
return|return
name|xfer
return|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|data_xfer
parameter_list|(
name|P_PAS
name|ptr
parameter_list|,
name|int
name|maxlen
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|u_char
modifier|*
name|status
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|retlen
init|=
literal|0
decl_stmt|,
name|xfer
decl_stmt|,
name|phase
decl_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_icmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|WAIT_FOR_REQ
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|phase
operator|=
name|SCI_CUR_PHASE
argument_list|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|sci_bus_csr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
name|SCSI_PHASE_CMD
case|:
name|printf
argument_list|(
literal|"Command phase in data_xfer().\n"
argument_list|)
expr_stmt|;
return|return
name|retlen
return|;
case|case
name|SCSI_PHASE_DATA_IN
case|:
name|SCI_ACK
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_DATA_IN
argument_list|)
expr_stmt|;
name|xfer
operator|=
name|sci_pdma_in
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_DATA_IN
argument_list|,
name|maxlen
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|retlen
operator|+=
name|xfer
expr_stmt|;
name|maxlen
operator|-=
name|xfer
expr_stmt|;
break|break;
case|case
name|SCSI_PHASE_DATA_OUT
case|:
name|SCI_ACK
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_DATA_OUT
argument_list|)
expr_stmt|;
name|xfer
operator|=
name|sci_pdma_out
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_DATA_OUT
argument_list|,
name|maxlen
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|retlen
operator|+=
name|xfer
expr_stmt|;
name|maxlen
operator|-=
name|xfer
expr_stmt|;
break|break;
case|case
name|SCSI_PHASE_STATUS
case|:
name|SCI_ACK
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_STATUS
argument_list|)
expr_stmt|;
name|sci_data_in
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_STATUS
argument_list|,
literal|1
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PHASE_MESSAGE_IN
case|:
name|SCI_ACK
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_MESSAGE_IN
argument_list|)
expr_stmt|;
name|sci_data_in
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_MESSAGE_IN
argument_list|,
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|msg
operator|==
literal|0
condition|)
block|{
return|return
name|retlen
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"message 0x%x in data_xfer.\n"
argument_list|,
operator|*
name|msg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCSI_PHASE_MESSAGE_OUT
case|:
name|SCI_ACK
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_MESSAGE_OUT
argument_list|)
expr_stmt|;
name|sci_data_out
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_MESSAGE_OUT
argument_list|,
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unexpected phase 0x%x in data_xfer().\n"
argument_list|,
name|phase
argument_list|)
expr_stmt|;
name|scsi_timeout_error
label|:
return|return
name|retlen
return|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|scsi_req
parameter_list|(
name|P_PAS
name|ptr
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_char
modifier|*
name|cmd
parameter_list|,
name|int
name|cmdlen
parameter_list|,
name|u_char
modifier|*
name|databuf
parameter_list|,
name|int
name|datalen
parameter_list|,
name|int
modifier|*
name|sent
parameter_list|,
name|int
modifier|*
name|ret
parameter_list|)
block|{
comment|/* Returns 0 on success, -1 on internal error, or the status byte */
name|int
name|cmd_bytes_sent
decl_stmt|,
name|r
decl_stmt|;
name|u_char
name|stat
decl_stmt|,
name|msg
decl_stmt|,
name|c
decl_stmt|;
operator|*
name|sent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|select_target
argument_list|(
name|ptr
argument_list|,
literal|7
argument_list|,
name|target
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|SCSI_RET_SUCCESS
condition|)
block|{
operator|*
name|ret
operator|=
name|r
expr_stmt|;
name|SCI_CLR_INTR
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|SCSI_RET_RETRY
case|:
name|ARGH
argument_list|()
expr_stmt|;
return|return
literal|0x08
return|;
default|default:
name|printf
argument_list|(
literal|"select_target(target %d, lun %d) failed(%d).\n"
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|r
argument_list|)
expr_stmt|;
case|case
name|SCSI_RET_DEVICE_DOWN
case|:
return|return
operator|-
literal|1
return|;
block|}
block|}
name|c
operator|=
literal|0x80
operator||
name|lun
expr_stmt|;
if|if
condition|(
operator|(
name|cmd_bytes_sent
operator|=
name|cmd_xfer
argument_list|(
name|ptr
argument_list|,
name|cmdlen
argument_list|,
name|cmd
argument_list|,
operator|&
name|stat
argument_list|,
operator|&
name|c
argument_list|)
operator|)
operator|!=
name|cmdlen
condition|)
block|{
name|ARGH
argument_list|()
expr_stmt|;
name|SCI_CLR_INTR
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|SCSI_RET_COMMAND_FAIL
expr_stmt|;
name|printf
argument_list|(
literal|"Data underrun sending CCB (%d bytes of %d, sent).\n"
argument_list|,
name|cmd_bytes_sent
argument_list|,
name|cmdlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|sent
operator|=
name|data_xfer
argument_list|(
name|ptr
argument_list|,
name|datalen
argument_list|,
name|databuf
argument_list|,
operator|&
name|stat
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PAS_DEBUG
name|printf
argument_list|(
literal|"scsi_req,stat=0x%x "
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PAS_DEBUG */
return|return
name|stat
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|scsi_group0
parameter_list|(
name|int
name|adapter
parameter_list|,
name|int
name|id
parameter_list|,
name|int
name|lun
parameter_list|,
name|int
name|opcode
parameter_list|,
name|int
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|,
name|caddr_t
name|databuf
parameter_list|,
name|int
name|datalen
parameter_list|)
block|{
name|P_PAS
name|ptr
init|=
name|s_pas
operator|+
name|adapter
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
literal|6
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sent
decl_stmt|,
name|ret
decl_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|opcode
expr_stmt|;
comment|/* Operation code */
name|cmd
index|[
literal|1
index|]
operator|=
operator|(
name|lun
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0x1F
operator|)
expr_stmt|;
comment|/* Lun& MSB of addr */
name|cmd
index|[
literal|2
index|]
operator|=
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
comment|/* addr	*/
name|cmd
index|[
literal|3
index|]
operator|=
name|addr
operator|&
literal|0xFF
expr_stmt|;
comment|/* LSB of addr */
name|cmd
index|[
literal|4
index|]
operator|=
name|len
expr_stmt|;
comment|/* Allocation length */
name|cmd
index|[
literal|5
index|]
operator|=
name|flags
expr_stmt|;
comment|/* Link/Flag */
name|i
operator|=
name|scsi_req
argument_list|(
name|ptr
argument_list|,
name|id
argument_list|,
name|lun
argument_list|,
name|cmd
argument_list|,
literal|6
argument_list|,
name|databuf
argument_list|,
name|datalen
argument_list|,
operator|&
name|sent
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* pseudo-dma action */
end_comment

begin_if
if|#
directive|if
literal|0
operator|&&
name|PSEUDO_DMA
end_if

begin_define
unit|static int pas_debug=1;
define|#
directive|define
name|W1
value|*byte_data = *data++
end_define

begin_define
define|#
directive|define
name|W4
value|*long_data = *((long*)data)++
end_define

begin_undef
unit|int sci_pdma_out(ptr, phase, count, data) 	P_PAS ptr; 	int					phase; 	int					count; 	u_char					*data; { 	register volatile long		*long_data = sci_4byte_addr; 	register volatile u_char	*byte_data = sci_1byte_addr; 	register int			len = count, i;  pas_debug=1;  	if (count< 128) 		return sci_data_out(ptr, phase, count, data);  	WAIT_FOR_BSY(ptr); 	M_PAS(ptr,sci_mode, |, SCI_MODE_DMA); 	M_PAS(ptr,sci_icmd, |, SCI_ICMD_DATA); 	W_PAS(ptr,sci_dma_send,0);  	while ( len>= 64 ) { 		READY(1); W1; READY(1); W1; READY(1); W1; READY(1); W1; 		READY(1); 		W4;W4;W4; W4;W4;W4;W4; W4;W4;W4;W4; W4;W4;W4;W4; 		len -= 64; 	} 	while (len) { 		READY(1); 		W1; 		len--; 	} 	i = TIMEOUT; 	while ( ((R_PAS(ptr,sci_csr)& (SCI_CSR_DREQ|SCI_CSR_PHASE_MATCH)) 		== SCI_CSR_PHASE_MATCH)&& --i); 	if (!i) 		printf("pas.c:%d: timeout waiting for SCI_CSR_DREQ.\n", __LINE__); 	*byte_data = 0; scsi_timeout_error: 	M_PAS(ptr,sci_mode,&, ~SCI_MODE_DMA); 	return count-len; }
undef|#
directive|undef
name|W1
end_undef

begin_undef
undef|#
directive|undef
name|W4
end_undef

begin_define
define|#
directive|define
name|R4
value|*((long *)data)++ = *long_data
end_define

begin_define
define|#
directive|define
name|R1
value|*data++ = *byte_data
end_define

begin_comment
unit|int sci_pdma_in(ptr, phase, count, data) 	P_PAS ptr; 	int					phase; 	int					count; 	u_char					*data; { 	register volatile long		*long_data = sci_4byte_addr; 	register volatile u_char	*byte_data = sci_1byte_addr; 	register int			len = count, i;  pas_debug=2; 	if (count< 128) 		return sci_data_in(ptr, phase, count, data);
comment|/*	printf("Called sci_pdma_in(0x%x, 0x%x, %d, 0x%x.\n", ptr, phase, count, data); */
end_comment

begin_comment
unit|WAIT_FOR_BSY(ptr); 	M_PAS(ptr,sci_mode, |, SCI_MODE_DMA); 	M_PAS(ptr,sci_icmd, |, SCI_ICMD_DATA); 	W_PAS(ptr,sci_irecv, 0);  	while (len>= 1024) { 		READY(0); 		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;  		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;
comment|/* 128 */
end_comment

begin_comment
unit|READY(0); 		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;  		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;
comment|/* 256 */
end_comment

begin_comment
unit|READY(0); 		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;  		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;
comment|/* 384 */
end_comment

begin_comment
unit|READY(0); 		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;  		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;
comment|/* 512 */
end_comment

begin_comment
unit|READY(0); 		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;  		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;
comment|/* 640 */
end_comment

begin_comment
unit|READY(0); 		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;  		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;
comment|/* 768 */
end_comment

begin_comment
unit|READY(0); 		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;  		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;
comment|/* 896 */
end_comment

begin_comment
unit|READY(0); 		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;  		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;
comment|/*1024 */
end_comment

begin_comment
unit|len -= 1024; 	} 	while (len>= 128) { 		READY(0); 		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;  		R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4; R4;R4;R4;R4;
comment|/* 128 */
end_comment

begin_undef
unit|len -= 128; 	} 	while (len) { 		READY(0); 		R1; 		len--; 	} scsi_timeout_error: 	M_PAS(ptr,sci_mode,&, ~SCI_MODE_DMA); 	return count - len; }
undef|#
directive|undef
name|R4
end_undef

begin_undef
undef|#
directive|undef
name|R1
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPAS */
end_comment

end_unit

