begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1994	Poul-Henning Kamp  *  * All rights reserved.  *  * This file contains some material which are covered by the message after   * this message.  *  * The rest of this file is covered by the following clause:  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@login.dkuug.dk> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $Id: pas.c,v 1.3 1994/09/13 06:44:39 phk Exp $  *  * This is a driver for the one particular kind of the "ProAudioSpectrum"  * card from MediaVision.  To find out if your card is supported, you can  * either try out the driver, or you can look for a chip a little less than  * 1" square in one end of the card, with writing on it that say ...5380...  *  * Up to four of these cards can be in the same computer.  If you have   * multiple cards, you need to set the "card-id" jumpers correspondingly.  *  * The driver uses no interrupts, so don't expect record-breaking performance.  *  * Poul-Henning Kamp<phk@freefall.cdrom.com>  */
end_comment

begin_comment
comment|/*  * Copyright (C) 1993	Allen K. Briggs, Chris P. Caputo,  *			Michael L. Finch, Bradley A. Grantham, and  *			Lawrence A. Kesteloot  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the Alice Group.  * 4. The names of the Alice Group or any of its members may not be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE ALICE GROUP ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE ALICE GROUP BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Was: Id: pas.c,v 1.8.2.1 1994/07/11 00:02:32 cgd Exp  *  * Modified for use with the pc532 by Phil Nelson, Feb 94.  */
end_comment

begin_include
include|#
directive|include
file|"pas.h"
end_include

begin_if
if|#
directive|if
name|NPAS
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|"ic/ncr_5380.h"
end_include

begin_comment
comment|/*  * Define this macro to disable the PSEUDO-DMA transfers.  */
end_comment

begin_undef
undef|#
directive|undef
name|NO_PAS16_PSEUDO_DMA
end_undef

begin_comment
comment|/*  * This parameter determines how many byte we "insb" between each check for  * a change of phase.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PAS16_PSEUDO_DMA_SIZE
end_ifndef

begin_define
define|#
directive|define
name|PAS16_PSEUDO_DMA_SIZE
value|512
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * How many times we attempt to select a device.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ATTEMPT_SELECTION
end_ifndef

begin_define
define|#
directive|define
name|ATTEMPT_SELECTION
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATTEMPT_SELECTION */
end_comment

begin_comment
comment|/*  * How many microseconds between each attempt.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SELECTION_DELAY
end_ifndef

begin_define
define|#
directive|define
name|SELECTION_DELAY
value|10000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SELECTION_DELAY */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PAS16_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|PAS16_TIMEOUT
value|1000000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PAS16_TIMEOUT */
end_comment

begin_comment
comment|/* What we need to debug the driver */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PAS_DEBUG
end_ifdef

begin_if
if|#
directive|if
name|PAS_DEBUG
operator|==
literal|0
end_if

begin_undef
undef|#
directive|undef
name|PAS_DEBUG
end_undef

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|pas_show_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|PAS_DEBUG_REQUEST_SENSE
end_ifndef

begin_define
define|#
directive|define
name|PAS_DEBUG_REQUEST_SENSE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PAS_DEBUG */
end_comment

begin_define
define|#
directive|define
name|SCSI_PHASE_DATA_OUT
value|0x0
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_DATA_IN
value|0x1
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_CMD
value|0x2
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_STATUS
value|0x3
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_UNSPEC1
value|0x4
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_UNSPEC2
value|0x5
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_MESSAGE_OUT
value|0x6
end_define

begin_define
define|#
directive|define
name|SCSI_PHASE_MESSAGE_IN
value|0x7
end_define

begin_define
define|#
directive|define
name|SCSI_CUR_PHASE
parameter_list|(
name|x
parameter_list|)
value|((x>>2)&0x7)
end_define

begin_define
define|#
directive|define
name|SCSI_RET_SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|SCSI_RET_RETRY
value|1
end_define

begin_define
define|#
directive|define
name|SCSI_RET_DEVICE_DOWN
value|2
end_define

begin_define
define|#
directive|define
name|SCSI_RET_COMMAND_FAIL
value|3
end_define

begin_comment
comment|/* Our per device (card) structure */
end_comment

begin_struct
specifier|static
struct|struct
name|pas_softc
block|{
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
name|int
name|mv_unit
decl_stmt|;
name|u_short
name|iobase
decl_stmt|;
define|#
directive|define
name|xor_0000
value|iobase
name|u_short
name|xor_0001
decl_stmt|;
name|u_short
name|xor_0002
decl_stmt|;
name|u_short
name|xor_0003
decl_stmt|;
name|u_short
name|xor_2000
decl_stmt|;
name|u_short
name|xor_2001
decl_stmt|;
name|u_short
name|xor_2002
decl_stmt|;
name|u_short
name|xor_2003
decl_stmt|;
name|u_short
name|xor_4000
decl_stmt|;
name|u_short
name|xor_4001
decl_stmt|;
name|u_short
name|xor_4003
decl_stmt|;
block|}
name|s_pas
index|[
name|NPAS
index|]
struct|;
end_struct

begin_comment
comment|/*  * Register Access-macros use these  */
end_comment

begin_define
define|#
directive|define
name|r_csdr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_0000)
end_define

begin_define
define|#
directive|define
name|w_odr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_0000)
end_define

begin_define
define|#
directive|define
name|r_icr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_0001)
end_define

begin_define
define|#
directive|define
name|w_icr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_0001)
end_define

begin_define
define|#
directive|define
name|rw_mr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_0002)
end_define

begin_define
define|#
directive|define
name|r_tcr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_0003)
end_define

begin_define
define|#
directive|define
name|w_tcr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_0003)
end_define

begin_define
define|#
directive|define
name|r_cscr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_2000)
end_define

begin_define
define|#
directive|define
name|w_ser
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_2000)
end_define

begin_define
define|#
directive|define
name|r_bsr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_2001)
end_define

begin_define
define|#
directive|define
name|w_sdsr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_2001)
end_define

begin_define
define|#
directive|define
name|r_idr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_2002)
end_define

begin_define
define|#
directive|define
name|w_sdtr
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_2002)
end_define

begin_define
define|#
directive|define
name|r_rpir
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_2003)
end_define

begin_define
define|#
directive|define
name|w_sdir
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_2003)
end_define

begin_define
define|#
directive|define
name|pas_data
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_4000)
end_define

begin_define
define|#
directive|define
name|pas_stat
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_4001)
end_define

begin_define
define|#
directive|define
name|R_PAS_STAT_DREQ
value|0x80
end_define

begin_define
define|#
directive|define
name|pas_irq
parameter_list|(
name|ptr
parameter_list|)
value|(ptr->xor_4003)
end_define

begin_comment
comment|/*  * The actual macros used to access the chip  */
end_comment

begin_define
define|#
directive|define
name|P_PAS
value|struct pas_softc *
end_define

begin_define
define|#
directive|define
name|R_PAS
parameter_list|(
name|ptr
parameter_list|,
name|foo
parameter_list|)
value|inb(foo(ptr))
end_define

begin_define
define|#
directive|define
name|W_PAS
parameter_list|(
name|ptr
parameter_list|,
name|foo
parameter_list|,
name|val
parameter_list|)
value|outb(foo(ptr),val)
end_define

begin_define
define|#
directive|define
name|M_PAS
parameter_list|(
name|ptr
parameter_list|,
name|foo
parameter_list|,
name|opr
parameter_list|,
name|arg
parameter_list|)
value|outb(foo(ptr),R_PAS(ptr,foo) opr arg)
end_define

begin_define
define|#
directive|define
name|WAIT_FOR_NOT_REQ
parameter_list|(
name|ptr
parameter_list|)
value|{	\     int scsi_timeout = PAS16_TIMEOUT; \     while ( (R_PAS(ptr,r_cscr)& R_CSCR_REQ)&& \ 	    (R_PAS(ptr,r_cscr)& R_CSCR_REQ)&& \ 	    (R_PAS(ptr,r_cscr)& R_CSCR_REQ)&& \ 	     (--scsi_timeout) ); \     if (!scsi_timeout) { \ 	printf("scsi timeout--WAIT_FOR_NOT_REQ-- pas.c:%d.\n", __LINE__); \ 	goto scsi_timeout_error; \     } \ }
end_define

begin_define
define|#
directive|define
name|WAIT_FOR_REQ
parameter_list|(
name|ptr
parameter_list|)
value|{	\     int scsi_timeout = PAS16_TIMEOUT; \     while ( ((R_PAS(ptr,r_cscr)& R_CSCR_REQ) == 0)&& \ 	    ((R_PAS(ptr,r_cscr)& R_CSCR_REQ) == 0)&& \ 	    ((R_PAS(ptr,r_cscr)& R_CSCR_REQ) == 0)&& \ 	     (--scsi_timeout) ); \     if (!scsi_timeout) { \ 	printf("scsi timeout--WAIT_FOR_REQ-- pas.c:%d.\n", __LINE__); \ 	goto scsi_timeout_error; \     } \ }
end_define

begin_function_decl
specifier|static
name|u_int32
name|pas_adapter_info
parameter_list|(
name|int
name|adapter_number
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pas_minphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32
name|pas_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pas_reset
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pas_send_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scsi_req
parameter_list|(
name|P_PAS
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sci_data_out
parameter_list|(
name|P_PAS
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sci_data_in
parameter_list|(
name|P_PAS
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|select_target
parameter_list|(
name|P_PAS
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|pasprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|pasattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|pasdriver
init|=
block|{
name|pasprobe
block|,
name|pasattach
block|,
literal|"pas"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|pas_adapter
init|=
block|{
name|pas_scsi_cmd
block|,
comment|/* scsi_cmd()		*/
name|pas_minphys
block|,
comment|/* scsi_minphys()	*/
literal|0
block|,
comment|/* open_target_lu()	*/
literal|0
block|,
comment|/* close_target_lu()	*/
name|pas_adapter_info
block|,
comment|/* adapter_info()	*/
literal|"pas"
block|,
comment|/* name			*/
block|{
literal|0
block|,
literal|0
block|}
comment|/* spare[2]		*/
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|pas_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler.	    */
name|NULL
block|,
comment|/* have a queue, served by this (?) */
name|NULL
block|,
comment|/* have no async handler.	    */
name|NULL
block|,
comment|/* Use default "done" routine.	    */
literal|"pas"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mv_type
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"PAS+"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"PAS16D"
block|,
literal|0
block|,
literal|"CDPC"
block|,
literal|"PAS16"
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pasprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|port
init|=
name|dev
operator|->
name|id_iobase
decl_stmt|;
name|int
name|base
init|=
name|port
operator|-
literal|0x1c00
decl_stmt|;
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|base
operator|&
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"pas%d cannot operate on address %x."
argument_list|,
name|unit
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Address must be a multiple of four.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Tell the PAS16 we want to talk to, where to listen */
name|outb
argument_list|(
literal|0x9a01
argument_list|,
literal|0xbc
operator|+
name|unit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x9a01
argument_list|,
name|base
operator|>>
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PAS_DEBUG
name|printf
argument_list|(
literal|"%x: 0x803=%x 0xec03=%x 0xff88=%x\n"
argument_list|,
name|base
argument_list|,
name|inb
argument_list|(
name|base
operator|^
literal|0x803
argument_list|)
argument_list|,
name|inb
argument_list|(
name|base
operator|^
literal|0xec03
argument_list|)
argument_list|,
name|inb
argument_list|(
name|base
operator|^
literal|0xfc00
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Killer one */
name|i
operator|=
name|inb
argument_list|(
name|base
operator|^
literal|0x803
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0xff
condition|)
return|return
literal|0
return|;
comment|/* killer two */
if|if
condition|(
operator|(
literal|0x03
operator|&
name|inb
argument_list|(
name|base
operator|^
literal|0xec03
argument_list|)
operator|)
operator|!=
literal|0x03
condition|)
return|return
literal|0
return|;
comment|/* killer three */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|port
argument_list|)
operator|!=
literal|0xff
operator|||
name|inb
argument_list|(
name|port
operator|^
literal|0x2000
argument_list|)
operator|!=
literal|0xff
condition|)
goto|goto
name|ok
goto|;
block|}
return|return
literal|0
return|;
name|ok
label|:
comment|/* killer four */
name|i
operator|=
name|inb
argument_list|(
name|base
operator|^
literal|0x803
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|^
literal|0x803
argument_list|,
name|i
operator|^
literal|0xe0
argument_list|)
expr_stmt|;
name|j
operator|=
name|inb
argument_list|(
name|base
operator|^
literal|0x803
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|^
literal|0x803
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|j
condition|)
return|return
literal|0
return|;
return|return
literal|4
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32
name|pas_adapter_info
parameter_list|(
name|int
name|adapter_number
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|pasattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|base
init|=
name|dev
operator|->
name|id_iobase
operator|-
literal|0x1c00
decl_stmt|;
name|struct
name|pas_softc
modifier|*
name|ppas
decl_stmt|;
name|i
operator|=
name|inb
argument_list|(
name|base
operator|^
literal|0xEC03
argument_list|)
operator|&
literal|0x0f
expr_stmt|;
name|printf
argument_list|(
literal|"pas%d: Type = %d<%s>\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|i
argument_list|,
name|mv_type
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ppas
operator|=
name|s_pas
operator|+
name|dev
operator|->
name|id_unit
expr_stmt|;
name|ppas
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
name|ppas
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
literal|7
expr_stmt|;
name|ppas
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|pas_adapter
expr_stmt|;
name|ppas
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|pas_dev
expr_stmt|;
name|ppas
operator|->
name|iobase
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
name|ppas
operator|->
name|xor_0001
operator|=
name|ppas
operator|->
name|iobase
operator|^
literal|0x0001
expr_stmt|;
name|ppas
operator|->
name|xor_0002
operator|=
name|ppas
operator|->
name|iobase
operator|^
literal|0x0002
expr_stmt|;
name|ppas
operator|->
name|xor_0003
operator|=
name|ppas
operator|->
name|iobase
operator|^
literal|0x0003
expr_stmt|;
name|ppas
operator|->
name|xor_2000
operator|=
name|ppas
operator|->
name|iobase
operator|^
literal|0x2000
expr_stmt|;
name|ppas
operator|->
name|xor_2001
operator|=
name|ppas
operator|->
name|iobase
operator|^
literal|0x2001
expr_stmt|;
name|ppas
operator|->
name|xor_2002
operator|=
name|ppas
operator|->
name|iobase
operator|^
literal|0x2002
expr_stmt|;
name|ppas
operator|->
name|xor_2003
operator|=
name|ppas
operator|->
name|iobase
operator|^
literal|0x2003
expr_stmt|;
name|ppas
operator|->
name|xor_4000
operator|=
name|ppas
operator|->
name|iobase
operator|^
literal|0x4000
expr_stmt|;
name|ppas
operator|->
name|xor_4001
operator|=
name|ppas
operator|->
name|iobase
operator|^
literal|0x4001
expr_stmt|;
name|ppas
operator|->
name|xor_4003
operator|=
name|ppas
operator|->
name|iobase
operator|^
literal|0x4003
expr_stmt|;
comment|/* Various magic */
name|outb
argument_list|(
name|base
operator|^
literal|0x4000
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|^
literal|0x4001
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|^
literal|0xbc00
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|^
literal|0x8003
argument_list|,
literal|0x4d
argument_list|)
expr_stmt|;
name|scsi_attachdevs
argument_list|(
operator|&
operator|(
name|ppas
operator|->
name|sc_link
operator|)
argument_list|)
expr_stmt|;
name|pas_reset
argument_list|(
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pas_minphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
define|#
directive|define
name|MIN_PHYS
value|65536
comment|/*BARF!!!!*/
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|MIN_PHYS
condition|)
block|{
name|printf
argument_list|(
literal|"Uh-oh...  pas_minphys setting bp->b_bcount = %x.\n"
argument_list|,
name|MIN_PHYS
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|MIN_PHYS
expr_stmt|;
block|}
undef|#
directive|undef
name|MIN_PHYS
block|}
end_function

begin_function
specifier|static
name|int32
name|pas_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|int
name|flags
decl_stmt|,
name|s
decl_stmt|,
name|r
decl_stmt|;
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
name|flags
operator||=
operator|(
name|SCSI_NOSLEEP
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"Already done?"
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Not in use?"
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|printf
argument_list|(
literal|"flags& SCSIRESET.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|pas_reset
argument_list|(
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
else|else
block|{
name|pas_reset
argument_list|(
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
block|}
name|r
operator|=
name|pas_send_cmd
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_NOMASK
condition|)
block|{
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
name|SUCCESSFULLY_QUEUED
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PAS_DEBUG
end_ifdef

begin_function
specifier|static
name|int
name|pas_show_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|u_char
modifier|*
name|b
init|=
operator|(
name|u_char
operator|*
operator|)
name|xs
operator|->
name|cmd
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_RESET
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pas(%d:%d:%d) "
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d@%x, %d@%x<"
argument_list|,
name|xs
operator|->
name|cmdlen
argument_list|,
operator|(
name|u_long
operator|)
name|xs
operator|->
name|cmd
argument_list|,
name|xs
operator|->
name|datalen
argument_list|,
operator|(
name|u_long
operator|)
name|xs
operator|->
name|data
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|xs
operator|->
name|cmdlen
condition|)
block|{
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
name|b
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|">\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"pas(%d:%d:%d)-RESET-\n"
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PAS_DEBUG */
end_comment

begin_function
specifier|static
name|int
name|pas_reset
parameter_list|(
name|int
name|adapter
parameter_list|)
block|{
name|struct
name|pas_softc
modifier|*
name|ppas
init|=
name|s_pas
operator|+
name|adapter
decl_stmt|;
comment|/*      * Reset Hold Time is 25 uSec      */
name|W_PAS
argument_list|(
name|ppas
argument_list|,
name|w_icr
argument_list|,
name|W_ICR_ASSERT_RST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|25
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ppas
argument_list|,
name|w_icr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ppas
argument_list|,
name|rw_mr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ppas
argument_list|,
name|w_ser
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pas_send_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|P_PAS
name|ptr
init|=
name|s_pas
operator|+
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
decl_stmt|;
name|int
name|s
decl_stmt|,
name|sent
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|sense
decl_stmt|;
name|u_char
name|cmd
index|[
literal|6
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|PAS_DEBUG
name|pas_show_scsi_cmd
argument_list|(
name|xs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PAS_DEBUG */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|sense
operator|=
name|scsi_req
argument_list|(
name|ptr
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|xs
operator|->
name|cmd
argument_list|,
name|xs
operator|->
name|cmdlen
argument_list|,
name|xs
operator|->
name|data
argument_list|,
name|xs
operator|->
name|datalen
argument_list|,
operator|&
name|sent
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sense
condition|)
block|{
case|case
literal|0x00
case|:
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
name|sent
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
case|case
literal|0x02
case|:
comment|/* Check condition */
ifdef|#
directive|ifdef
name|PAS_DEBUG_REQUEST_SENSE
name|printf
argument_list|(
literal|"pas%d, target%d: sent=%d,ret=%d,sense=%x check. cond.\n"
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|sent
argument_list|,
name|ret
argument_list|,
name|sense
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Cmd:<%x"
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|(
name|xs
operator|->
name|cmd
operator|)
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|sent
operator|=
literal|1
init|;
name|sent
operator|<
sizeof|sizeof
name|xs
operator|->
name|cmdlen
condition|;
name|sent
operator|++
control|)
block|{
name|printf
argument_list|(
literal|",%x"
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|(
name|xs
operator|->
name|cmd
operator|)
operator|)
index|[
name|sent
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|">\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PAS_DEBUG_REQUEST_SENSE */
name|cmd
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
name|cmd
index|[
literal|1
index|]
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|<<
literal|5
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|cmd
index|[
literal|4
index|]
operator|=
sizeof|sizeof
name|xs
operator|->
name|sense
expr_stmt|;
name|cmd
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|scsi_req
argument_list|(
name|ptr
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
name|cmd
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
argument_list|,
sizeof|sizeof
name|xs
operator|->
name|sense
argument_list|,
operator|&
name|sent
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PAS_DEBUG_REQUEST_SENSE
name|printf
argument_list|(
literal|"Sense result: (sent=%d, ret=%d)\n"
argument_list|,
name|sent
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<%x"
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|xs
operator|->
name|sense
operator|)
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|sent
operator|=
literal|1
init|;
name|sent
operator|<
sizeof|sizeof
name|xs
operator|->
name|sense
condition|;
name|sent
operator|++
control|)
block|{
name|printf
argument_list|(
literal|",%x"
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|xs
operator|->
name|sense
operator|)
operator|)
index|[
name|sent
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|">\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PAS_DEBUG_REQUEST_SENSE */
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
return|return
name|HAD_ERROR
return|;
case|case
literal|0x08
case|:
comment|/* Busy */
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
return|return
name|HAD_ERROR
return|;
default|default:
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
name|HAD_ERROR
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Perform arbitration and selection.  Figure 5-1, more or less.  */
end_comment

begin_function
specifier|static
name|int
name|select_target
parameter_list|(
name|P_PAS
name|ptr
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|int
name|myid
init|=
name|ptr
operator|->
name|sc_link
operator|.
name|adapter_targ
decl_stmt|;
name|int
name|ret
init|=
name|SCSI_RET_RETRY
decl_stmt|;
name|int
name|tries
init|=
name|ATTEMPT_SELECTION
decl_stmt|;
name|int
name|delay
init|=
name|SELECTION_DELAY
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*       * Convert the ID's to bit-maps.      */
name|myid
operator|=
literal|1
operator|<<
name|myid
expr_stmt|;
name|tid
operator|=
literal|1
operator|<<
name|tid
expr_stmt|;
comment|/*      * Not documented, but clearly needed for now.      * XXX is this missing somewhere else, and this is just a hack ?      */
name|loop
label|:
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_tcr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Write ID Bit to Output Register.      */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_odr
argument_list|,
name|myid
argument_list|)
expr_stmt|;
comment|/*      * Set "ARBITRATE" Bit.      */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|rw_mr
argument_list|,
name|RW_MR_ARBITRATE
argument_list|)
expr_stmt|;
comment|/*      * Check "Arbitration in progress" Bit.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
comment|/* 20usec circa */
if|if
condition|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_icr
argument_list|)
operator|&
name|R_ICR_ARBITRATION_IN_PROGRESS
condition|)
goto|goto
name|aip
goto|;
goto|goto
name|lost
goto|;
name|aip
label|:
comment|/*      * Wait 2.2 usec Arbitration Delay.      */
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/*      * Check "Lost Arbitration" Bit.      */
if|if
condition|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_icr
argument_list|)
operator|&
name|R_ICR_LOST_ARBITRATION
condition|)
goto|goto
name|lost
goto|;
comment|/*      * Higher priority ID present ?      */
if|if
condition|(
operator|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_csdr
argument_list|)
operator|&
operator|~
name|myid
operator|)
operator|>
name|myid
condition|)
goto|goto
name|lost
goto|;
comment|/*      * Check "Lost Arbitration" Bit.      */
if|if
condition|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_icr
argument_list|)
operator|&
name|R_ICR_LOST_ARBITRATION
condition|)
goto|goto
name|lost
goto|;
comment|/*      * Set "Assert SEL/".      */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
name|W_ICR_ASSERT_SEL
argument_list|)
expr_stmt|;
comment|/*      * Check "Lost Arbitration" Bit.      */
if|if
condition|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_icr
argument_list|)
operator|&
name|R_ICR_LOST_ARBITRATION
condition|)
block|{
goto|goto
name|nosel
goto|;
block|}
comment|/*      * Wait 1.2 usec minimum. (Bus Clear + Settle)      */
name|DELAY
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/*      * Write Target and Initiator's ID bits to output Register.      */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_odr
argument_list|,
name|myid
operator||
name|tid
argument_list|)
expr_stmt|;
comment|/*      * Set "Assert BSY/" + "Assert Data Bus".      */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
name|W_ICR_ASSERT_SEL
operator||
name|W_ICR_ASSERT_BSY
operator||
name|W_ICR_ASSERT_DATA_BUS
argument_list|)
expr_stmt|;
comment|/*      * Reset "ARBITRATE" Bit.      */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|rw_mr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Reset "Select Enable" Register.      */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_ser
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * Reset "Assert BSY/".      */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
name|W_ICR_ASSERT_SEL
operator||
name|W_ICR_ASSERT_DATA_BUS
argument_list|)
expr_stmt|;
comment|/*      * "BSY/" Asserted within 250 msec ?      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|250000
condition|;
name|i
operator|+=
literal|100
control|)
block|{
if|if
condition|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_cscr
argument_list|)
operator|&
name|R_CSCR_BSY
condition|)
goto|goto
name|resp
goto|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
goto|goto
name|nodev
goto|;
name|resp
label|:
comment|/*      * Reset "Assert SEL/" + "Assert Data Bus".      */
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|SCSI_RET_SUCCESS
return|;
name|nodev
label|:
name|ret
operator|=
name|SCSI_RET_DEVICE_DOWN
expr_stmt|;
name|nosel
label|:
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lost
label|:
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|rw_mr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|tries
condition|)
block|{
name|DELAY
argument_list|(
name|delay
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Figure 5-2.  */
end_comment

begin_decl_stmt
name|int
name|PHK
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sci_data_out
parameter_list|(
name|P_PAS
name|ptr
parameter_list|,
name|int
name|phase
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|unsigned
name|char
name|icmd
decl_stmt|;
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|,
name|zonk
decl_stmt|;
if|if
condition|(
name|SCSI_CUR_PHASE
argument_list|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_cscr
argument_list|)
argument_list|)
operator|!=
name|phase
condition|)
return|return
name|cnt
return|;
name|icmd
operator|=
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_icr
argument_list|)
operator|&
name|RW_ICR_MASK
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_PAS16_PSEUDO_DMA
comment|/*      * The PAS16 has special provisions for doing pseudo-dma.      */
comment|/*       * Don't use pseudo-dma unless we need much data.  This way we avoid all      * the variable length stuff entirely.      *      * XXX something screws up for big transfers :-(      */
if|if
condition|(
name|count
operator|>=
literal|128
operator|&&
name|count
operator|<=
literal|8192
condition|)
block|{
name|M_PAS
argument_list|(
name|ptr
argument_list|,
name|rw_mr
argument_list|,
operator||
argument_list|,
name|RW_MR_DMA_MODE
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
name|icmd
operator||
name|W_ICR_ASSERT_DATA_BUS
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_sdsr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>=
name|PAS16_PSEUDO_DMA_SIZE
condition|)
block|{
name|zonk
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|pas_stat
argument_list|)
operator|&
name|R_PAS_STAT_DREQ
operator|)
condition|)
if|if
condition|(
operator|++
name|zonk
operator|>
literal|1000
operator|||
name|SCSI_CUR_PHASE
argument_list|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_cscr
argument_list|)
argument_list|)
operator|!=
name|phase
condition|)
return|return
name|cnt
return|;
name|outsb
argument_list|(
name|pas_data
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|data
argument_list|,
name|PAS16_PSEUDO_DMA_SIZE
argument_list|)
expr_stmt|;
name|data
operator|+=
name|PAS16_PSEUDO_DMA_SIZE
expr_stmt|;
name|cnt
operator|+=
name|PAS16_PSEUDO_DMA_SIZE
expr_stmt|;
name|count
operator|-=
name|PAS16_PSEUDO_DMA_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|count
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|pas_stat
argument_list|)
operator|&
name|R_PAS_STAT_DREQ
operator|)
condition|)
if|if
condition|(
name|SCSI_CUR_PHASE
argument_list|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_cscr
argument_list|)
argument_list|)
operator|!=
name|phase
condition|)
return|return
name|cnt
return|;
name|outsb
argument_list|(
name|pas_data
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|data
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|cnt
operator|+=
name|count
expr_stmt|;
name|data
operator|+=
name|count
expr_stmt|;
block|}
name|M_PAS
argument_list|(
name|ptr
argument_list|,
name|rw_mr
argument_list|,
operator|&
argument_list|,
operator|~
name|RW_MR_DMA_MODE
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
return|return
name|cnt
return|;
block|}
endif|#
directive|endif
comment|/* NO_PAS16_PSEUDO_DMA */
name|loop
label|:
if|if
condition|(
name|SCSI_CUR_PHASE
argument_list|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_cscr
argument_list|)
argument_list|)
operator|!=
name|phase
condition|)
return|return
name|cnt
return|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_odr
argument_list|,
operator|*
name|data
argument_list|)
expr_stmt|;
name|WAIT_FOR_REQ
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|icmd
operator||=
name|W_ICR_ASSERT_DATA_BUS
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
name|icmd
operator||=
name|W_ICR_ASSERT_ACK
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
name|icmd
operator|&=
operator|~
operator|(
name|W_ICR_ASSERT_DATA_BUS
operator||
name|W_ICR_ASSERT_ACK
operator|)
expr_stmt|;
name|WAIT_FOR_NOT_REQ
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
name|data
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
name|scsi_timeout_error
label|:
return|return
name|cnt
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sci_data_in
parameter_list|(
name|P_PAS
name|ptr
parameter_list|,
name|int
name|phase
parameter_list|,
name|int
name|count
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|unsigned
name|char
name|icmd
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|SCSI_CUR_PHASE
argument_list|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_cscr
argument_list|)
argument_list|)
operator|!=
name|phase
condition|)
return|return
name|cnt
return|;
ifndef|#
directive|ifndef
name|NO_PAS16_PSEUDO_DMA
comment|/*      * The PAS16 has special provisions for doing pseudo-dma.      */
comment|/*       * Don't use pseudo-dma unless we need much data.  This way we avoid all      * the variable length stuff entirely.      */
if|if
condition|(
name|count
operator|>=
literal|128
condition|)
block|{
name|M_PAS
argument_list|(
name|ptr
argument_list|,
name|rw_mr
argument_list|,
operator||
argument_list|,
name|RW_MR_DMA_MODE
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_sdir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|>
name|PAS16_PSEUDO_DMA_SIZE
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|pas_stat
argument_list|)
operator|&
name|R_PAS_STAT_DREQ
operator|)
condition|)
empty_stmt|;
name|insb
argument_list|(
name|pas_data
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|data
argument_list|,
name|PAS16_PSEUDO_DMA_SIZE
argument_list|)
expr_stmt|;
name|data
operator|+=
name|PAS16_PSEUDO_DMA_SIZE
expr_stmt|;
name|cnt
operator|+=
name|PAS16_PSEUDO_DMA_SIZE
expr_stmt|;
name|count
operator|-=
name|PAS16_PSEUDO_DMA_SIZE
expr_stmt|;
if|if
condition|(
name|SCSI_CUR_PHASE
argument_list|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_cscr
argument_list|)
argument_list|)
operator|!=
name|phase
condition|)
return|return
name|cnt
return|;
block|}
while|while
condition|(
operator|!
operator|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|pas_stat
argument_list|)
operator|&
name|R_PAS_STAT_DREQ
operator|)
condition|)
empty_stmt|;
name|insb
argument_list|(
name|pas_data
argument_list|(
name|ptr
argument_list|)
argument_list|,
name|data
argument_list|,
name|count
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cnt
operator|+=
name|count
operator|-
literal|1
expr_stmt|;
name|data
operator|+=
name|count
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|pas_stat
argument_list|)
operator|&
name|R_PAS_STAT_DREQ
operator|)
condition|)
empty_stmt|;
while|while
condition|(
operator|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_cscr
argument_list|)
operator|&
name|R_CSCR_REQ
operator|)
condition|)
empty_stmt|;
operator|*
name|data
operator|=
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_idr
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|M_PAS
argument_list|(
name|ptr
argument_list|,
name|rw_mr
argument_list|,
operator|&
argument_list|,
operator|~
name|RW_MR_DMA_MODE
argument_list|)
expr_stmt|;
return|return
name|cnt
return|;
block|}
endif|#
directive|endif
comment|/* NO_PAS16_PSEUDO_DMA */
name|icmd
operator|=
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_icr
argument_list|)
operator|&
name|RW_ICR_MASK
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|SCSI_CUR_PHASE
argument_list|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_cscr
argument_list|)
argument_list|)
operator|!=
name|phase
condition|)
return|return
name|cnt
return|;
name|WAIT_FOR_REQ
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
operator|*
name|data
operator|++
operator|=
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_csdr
argument_list|)
expr_stmt|;
name|icmd
operator||=
name|W_ICR_ASSERT_ACK
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
name|icmd
operator|&=
operator|~
name|W_ICR_ASSERT_ACK
expr_stmt|;
name|WAIT_FOR_NOT_REQ
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
name|icmd
argument_list|)
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
if|if
condition|(
operator|--
name|count
operator|>
literal|0
condition|)
goto|goto
name|loop
goto|;
name|scsi_timeout_error
label|:
return|return
name|cnt
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmd_xfer
parameter_list|(
name|P_PAS
name|ptr
parameter_list|,
name|int
name|maxlen
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|u_char
modifier|*
name|status
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|xfer
init|=
literal|0
decl_stmt|,
name|phase
decl_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|WAIT_FOR_REQ
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|phase
operator|=
name|SCSI_CUR_PHASE
argument_list|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_cscr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
name|SCSI_PHASE_CMD
case|:
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_tcr
argument_list|,
name|SCSI_PHASE_CMD
argument_list|)
expr_stmt|;
name|xfer
operator|+=
name|sci_data_out
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_CMD
argument_list|,
name|maxlen
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|xfer
return|;
case|case
name|SCSI_PHASE_DATA_IN
case|:
name|printf
argument_list|(
literal|"Data in phase in cmd_xfer?\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SCSI_PHASE_DATA_OUT
case|:
name|printf
argument_list|(
literal|"Data out phase in cmd_xfer?\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SCSI_PHASE_STATUS
case|:
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_tcr
argument_list|,
name|SCSI_PHASE_STATUS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"status in cmd_xfer.\n"
argument_list|)
expr_stmt|;
name|sci_data_in
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_STATUS
argument_list|,
literal|1
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PHASE_MESSAGE_IN
case|:
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_tcr
argument_list|,
name|SCSI_PHASE_MESSAGE_IN
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"msgin in cmd_xfer.\n"
argument_list|)
expr_stmt|;
name|sci_data_in
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_MESSAGE_IN
argument_list|,
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PHASE_MESSAGE_OUT
case|:
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_tcr
argument_list|,
name|SCSI_PHASE_MESSAGE_OUT
argument_list|)
expr_stmt|;
name|sci_data_out
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_MESSAGE_OUT
argument_list|,
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unexpected phase 0x%x in cmd_xfer()\n"
argument_list|,
name|phase
argument_list|)
expr_stmt|;
name|scsi_timeout_error
label|:
return|return
name|xfer
return|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|data_xfer
parameter_list|(
name|P_PAS
name|ptr
parameter_list|,
name|int
name|maxlen
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|u_char
modifier|*
name|status
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|retlen
init|=
literal|0
decl_stmt|,
name|xfer
decl_stmt|,
name|phase
decl_stmt|;
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_icr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|status
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|WAIT_FOR_REQ
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|phase
operator|=
name|SCSI_CUR_PHASE
argument_list|(
name|R_PAS
argument_list|(
name|ptr
argument_list|,
name|r_cscr
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
name|SCSI_PHASE_CMD
case|:
name|printf
argument_list|(
literal|"Command phase in data_xfer().\n"
argument_list|)
expr_stmt|;
return|return
name|retlen
return|;
case|case
name|SCSI_PHASE_DATA_IN
case|:
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_tcr
argument_list|,
name|SCSI_PHASE_DATA_IN
argument_list|)
expr_stmt|;
name|xfer
operator|=
name|sci_data_in
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_DATA_IN
argument_list|,
name|maxlen
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|retlen
operator|+=
name|xfer
expr_stmt|;
name|maxlen
operator|-=
name|xfer
expr_stmt|;
break|break;
case|case
name|SCSI_PHASE_DATA_OUT
case|:
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_tcr
argument_list|,
name|SCSI_PHASE_DATA_OUT
argument_list|)
expr_stmt|;
name|xfer
operator|=
name|sci_data_out
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_DATA_OUT
argument_list|,
name|maxlen
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|retlen
operator|+=
name|xfer
expr_stmt|;
name|maxlen
operator|-=
name|xfer
expr_stmt|;
break|break;
case|case
name|SCSI_PHASE_STATUS
case|:
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_tcr
argument_list|,
name|SCSI_PHASE_STATUS
argument_list|)
expr_stmt|;
name|sci_data_in
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_STATUS
argument_list|,
literal|1
argument_list|,
name|status
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_PHASE_MESSAGE_IN
case|:
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_tcr
argument_list|,
name|SCSI_PHASE_MESSAGE_IN
argument_list|)
expr_stmt|;
name|sci_data_in
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_MESSAGE_IN
argument_list|,
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|msg
operator|==
literal|0
condition|)
block|{
return|return
name|retlen
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"message 0x%x in data_xfer.\n"
argument_list|,
operator|*
name|msg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCSI_PHASE_MESSAGE_OUT
case|:
name|W_PAS
argument_list|(
name|ptr
argument_list|,
name|w_tcr
argument_list|,
name|SCSI_PHASE_MESSAGE_OUT
argument_list|)
expr_stmt|;
name|sci_data_out
argument_list|(
name|ptr
argument_list|,
name|SCSI_PHASE_MESSAGE_OUT
argument_list|,
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unexpected phase 0x%x in data_xfer().\n"
argument_list|,
name|phase
argument_list|)
expr_stmt|;
name|scsi_timeout_error
label|:
return|return
name|retlen
return|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|scsi_req
parameter_list|(
name|P_PAS
name|ptr
parameter_list|,
name|int
name|target
parameter_list|,
name|int
name|lun
parameter_list|,
name|u_char
modifier|*
name|cmd
parameter_list|,
name|int
name|cmdlen
parameter_list|,
name|u_char
modifier|*
name|databuf
parameter_list|,
name|int
name|datalen
parameter_list|,
name|int
modifier|*
name|sent
parameter_list|,
name|int
modifier|*
name|ret
parameter_list|)
block|{
comment|/* Returns 0 on success, -1 on internal error, or the status byte */
name|int
name|cmd_bytes_sent
decl_stmt|,
name|r
decl_stmt|;
name|u_char
name|stat
decl_stmt|,
name|msg
decl_stmt|,
name|c
decl_stmt|;
operator|*
name|sent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|select_target
argument_list|(
name|ptr
argument_list|,
name|target
argument_list|)
operator|)
operator|!=
name|SCSI_RET_SUCCESS
condition|)
block|{
operator|*
name|ret
operator|=
name|r
expr_stmt|;
switch|switch
condition|(
name|r
condition|)
block|{
case|case
name|SCSI_RET_RETRY
case|:
return|return
literal|0x08
return|;
default|default:
name|printf
argument_list|(
literal|"select_target(target %d, lun %d) failed(%d).\n"
argument_list|,
name|target
argument_list|,
name|lun
argument_list|,
name|r
argument_list|)
expr_stmt|;
case|case
name|SCSI_RET_DEVICE_DOWN
case|:
return|return
operator|-
literal|1
return|;
block|}
block|}
name|c
operator|=
literal|0x80
operator||
name|lun
expr_stmt|;
if|if
condition|(
operator|(
name|cmd_bytes_sent
operator|=
name|cmd_xfer
argument_list|(
name|ptr
argument_list|,
name|cmdlen
argument_list|,
name|cmd
argument_list|,
operator|&
name|stat
argument_list|,
operator|&
name|c
argument_list|)
operator|)
operator|!=
name|cmdlen
condition|)
block|{
operator|*
name|ret
operator|=
name|SCSI_RET_COMMAND_FAIL
expr_stmt|;
name|printf
argument_list|(
literal|"Data underrun sending CCB (%d bytes of %d, sent).\n"
argument_list|,
name|cmd_bytes_sent
argument_list|,
name|cmdlen
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|sent
operator|=
name|data_xfer
argument_list|(
name|ptr
argument_list|,
name|datalen
argument_list|,
name|databuf
argument_list|,
operator|&
name|stat
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
literal|0
expr_stmt|;
return|return
name|stat
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPAS */
end_comment

end_unit

