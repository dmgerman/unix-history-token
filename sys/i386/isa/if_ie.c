begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, University of Vermont and State  *  Agricultural College.  * Copyright (c) 1992, 1993, Garrett A. Wollman.  *  * Portions:  * Copyright (c) 1990, 1991, William F. Jolitz  * Copyright (c) 1990, The Regents of the University of California  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	Vermont and State Agricultural College and Garrett A. Wollman,  *	by William F. Jolitz, by the University of California,  *	Berkeley, by Larwence Berkeley Laboratory, and its contributors.  * 4. Neither the names of the Universities nor the names of the authors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR AUTHORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id$  */
end_comment

begin_comment
comment|/*  * Intel 82586 Ethernet chip  * Register, bit, and structure definitions.  *  * Written by GAW with reference to the Clarkson Packet Driver code for this  * chip written by Russ Nelson and others.  *  * BPF support code stolen directly from hpdev/if_le.c, supplied with  * tcpdump.  */
end_comment

begin_comment
comment|/*  * The i82586 is a very versatile chip, found in many implementations.  * Programming this chip is mostly the same, but certain details differ  * from card to card.  This driver is written so that different cards   * can be automatically detected at run-time.  Currently, only the  * AT&T EN100/StarLAN 10 series are supported.  */
end_comment

begin_comment
comment|/* Mode of operation:  We run the 82586 in a standard Ethernet mode.  We keep NFRAMES received frame descriptors around for the receiver to use, and NBUFFS associated receive buffer descriptors, both in a circular list.  Whenever a frame is received, we rotate both lists as necessary.  (The 586 treats both lists as a simple queue.)  We also keep a transmit command around so that packets can be sent off quickly.  We configure the adapter in AL-LOC = 1 mode, which means that the Ethernet/802.3 MAC header is placed at the beginning of the receive buffer rather than being split off into various fields in the RFD.  This also means that we must include this header in the transmit buffer as well.  By convention, all transmit commands, and only transmit commands, shall have the I (IE_CMD_INTR) bit set in the command.  This way, when an interrupt arrives at ieintr(), it is immediately possible to tell what precisely caused it.  ANY OTHER command-sending routines should run at splimp(), and should post an acknowledgement to every interrupt they generate.  The 82586 has a 24-bit address space internally, and the adaptor's memory is located at the top of this region.  However, the value we are given in configuration is normally the *bottom* of the adaptor RAM.  So, we must go through a few gyrations to come up with a kernel virtual address which represents the actual beginning of the 586 address space.  First, we autosize the RAM by running through several possible sizes and trying to initialize the adapter under the assumption that the selected size is correct.  Then, knowing the correct RAM size, we set up our pointers in ie_softc[unit].  `iomem' represents the computed base of the 586 address space.  `iomembot' represents the actual configured base of adapter RAM.  Finally, `iosize' represents the calculated size of 586 RAM.  Then, when laying out commands, we use the interval [iomembot, iomembot + iosize); to make 24-pointers, we subtract iomem, and to make 16-pointers, we subtract iomem and and with 0xffff.  */
end_comment

begin_include
include|#
directive|include
file|"ie.h"
end_include

begin_if
if|#
directive|if
name|NIE
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"net/if.h"
end_include

begin_include
include|#
directive|include
file|"net/if_types.h"
end_include

begin_include
include|#
directive|include
file|"net/if_dl.h"
end_include

begin_include
include|#
directive|include
file|"net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"net/route.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|"netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip.h"
end_include

begin_include
include|#
directive|include
file|"netinet/if_ether.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|"netns/ns.h"
end_include

begin_include
include|#
directive|include
file|"netns/ns_if.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"i386/isa/isa.h"
end_include

begin_comment
comment|/*#include "machine/cpufunc.h"*/
end_comment

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/ic/i82586.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/if_iereg.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/icu.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"net/bpf.h"
end_include

begin_include
include|#
directive|include
file|"net/bpfdesc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
name|NBPFILTER
operator|>
literal|0
operator|)
operator|||
name|defined
argument_list|(
name|MULTICAST
argument_list|)
end_if

begin_define
define|#
directive|define
name|FILTER
end_define

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|last_not_for_us
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|IED_RINT
value|1
end_define

begin_define
define|#
directive|define
name|IED_TINT
value|2
end_define

begin_define
define|#
directive|define
name|IED_RNR
value|4
end_define

begin_define
define|#
directive|define
name|IED_CNA
value|8
end_define

begin_define
define|#
directive|define
name|IED_READFRAME
value|16
end_define

begin_decl_stmt
name|int
name|ie_debug
init|=
name|IED_RNR
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ETHERMINLEN
end_ifndef

begin_define
define|#
directive|define
name|ETHERMINLEN
value|60
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IE_BUF_LEN
value|1512
end_define

begin_comment
comment|/* length of transmit buffer */
end_comment

begin_comment
comment|/* Forward declaration */
end_comment

begin_struct_decl
struct_decl|struct
name|ie_softc
struct_decl|;
end_struct_decl

begin_function_decl
name|int
name|ieprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ieattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ieinit
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ieioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|command
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iestart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sl_reset_586
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sl_chan_attn
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|iereset
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ie_readframe
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|,
name|int
name|bufno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ie_drop_packet_buffer
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sl_read_ether
parameter_list|(
name|int
name|unit
parameter_list|,
name|unsigned
name|char
name|addr
index|[
literal|6
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|find_ie_mem_size
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|command_and_wait
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|command
parameter_list|,
name|void
specifier|volatile
modifier|*
name|pcmd
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ierint
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ietint
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iernr
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_receiver
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ieget
parameter_list|(
name|int
parameter_list|,
name|struct
name|ie_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|ether_header
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|caddr_t
name|setup_rfa
parameter_list|(
name|caddr_t
name|ptr
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mc_setup
parameter_list|(
name|int
parameter_list|,
name|caddr_t
parameter_list|,
specifier|volatile
name|struct
name|ie_sys_ctl_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MULTICAST
end_ifdef

begin_function_decl
specifier|static
name|void
name|ie_mc_reset
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
name|void
name|print_rbd
parameter_list|(
specifier|volatile
name|struct
name|ie_recv_buf_desc
modifier|*
name|rbd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|in_ierint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|in_ietint
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This tells the autoconf code how to set us up.  */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|iedriver
init|=
block|{
name|ieprobe
block|,
name|ieattach
block|,
literal|"ie"
block|, }
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|ie_hardware
block|{
name|IE_STARLAN10
block|,
name|IE_EN100
block|,
name|IE_SLFIBER
block|,
name|IE_UNKNOWN
block|}
enum|;
end_enum

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ie_hardware_names
index|[]
init|=
block|{
literal|"StarLAN 10"
block|,
literal|"EN100"
block|,
literal|"StarLAN Fiber"
block|,
literal|"Unknown"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  sizeof(iscp) == 1+1+2+4 == 8 sizeof(scb) == 2+2+2+2+2+2+2+2 == 16 NFRAMES * sizeof(rfd) == NFRAMES*(2+2+2+2+6+6+2+2) == NFRAMES*24 == 384 sizeof(xmit_cmd) == 2+2+2+2+6+2 == 18 sizeof(transmit buffer) == 1512 sizeof(transmit buffer desc) == 8 ----- 1946  NBUFFS * sizeof(rbd) == NBUFFS*(2+2+4+2+2) == NBUFFS*12 NBUFFS * IE_RBUF_SIZE == NBUFFS*256  NBUFFS should be (16384 - 1946) / (256 + 12) == 14438 / 268 == 53  With NBUFFS == 48, this leaves us 1574 bytes for another command or more buffers.  Another transmit command would be 18+8+1512 == 1538 ---just barely fits!  Obviously all these would have to be reduced for smaller memory sizes. With a larger memory, it would be possible to roughly double the number of both transmit and receive buffers. */
end_comment

begin_define
define|#
directive|define
name|NFRAMES
value|16
end_define

begin_comment
comment|/* number of frames to allow for receive */
end_comment

begin_define
define|#
directive|define
name|NBUFFS
value|48
end_define

begin_comment
comment|/* number of buffers to allocate */
end_comment

begin_define
define|#
directive|define
name|IE_RBUF_SIZE
value|256
end_define

begin_comment
comment|/* size of each buffer, MUST BE POWER OF TWO */
end_comment

begin_comment
comment|/*  * Ethernet status, per interface.  */
end_comment

begin_struct
struct|struct
name|ie_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
name|void
function_decl|(
modifier|*
name|ie_reset_586
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|ie_chan_attn
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|enum
name|ie_hardware
name|hard_type
decl_stmt|;
name|int
name|hard_vers
decl_stmt|;
name|u_short
name|port
decl_stmt|;
name|caddr_t
name|iomem
decl_stmt|;
name|caddr_t
name|iomembot
decl_stmt|;
name|unsigned
name|iosize
decl_stmt|;
name|int
name|want_mcsetup
decl_stmt|;
name|int
name|promisc
decl_stmt|;
specifier|volatile
name|struct
name|ie_int_sys_conf_ptr
modifier|*
name|iscp
decl_stmt|;
specifier|volatile
name|struct
name|ie_sys_ctl_block
modifier|*
name|scb
decl_stmt|;
specifier|volatile
name|struct
name|ie_recv_frame_desc
modifier|*
name|rframes
index|[
name|NFRAMES
index|]
decl_stmt|;
specifier|volatile
name|struct
name|ie_recv_buf_desc
modifier|*
name|rbuffs
index|[
name|NBUFFS
index|]
decl_stmt|;
specifier|volatile
name|char
modifier|*
name|cbuffs
index|[
name|NBUFFS
index|]
decl_stmt|;
name|int
name|rfhead
decl_stmt|,
name|rftail
decl_stmt|,
name|rbhead
decl_stmt|,
name|rbtail
decl_stmt|;
specifier|volatile
name|struct
name|ie_xmit_cmd
modifier|*
name|xmit_cmds
index|[
literal|2
index|]
decl_stmt|;
specifier|volatile
name|struct
name|ie_xmit_buf
modifier|*
name|xmit_buffs
index|[
literal|2
index|]
decl_stmt|;
name|int
name|xmit_count
decl_stmt|;
name|u_char
modifier|*
name|xmit_cbuffs
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|ie_en_addr
name|mcast_addrs
index|[
name|MAXMCAST
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|mcast_count
decl_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|caddr_t
name|ie_bpf
decl_stmt|;
endif|#
directive|endif
block|}
name|ie_softc
index|[
name|NIE
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|MK_24
parameter_list|(
name|base
parameter_list|,
name|ptr
parameter_list|)
value|((caddr_t)((u_long)ptr - (u_long)base))
end_define

begin_define
define|#
directive|define
name|MK_16
parameter_list|(
name|base
parameter_list|,
name|ptr
parameter_list|)
value|((u_short)(u_long)MK_24(base, ptr))
end_define

begin_define
define|#
directive|define
name|PORT
value|ie_softc[unit].port
end_define

begin_define
define|#
directive|define
name|MEM
value|ie_softc[unit].iomem
end_define

begin_function
name|int
name|ieprobe
parameter_list|(
name|dvp
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iomembot
operator|=
name|dvp
operator|->
name|id_maddr
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iomem
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|inb
argument_list|(
name|PORT
operator|+
name|IEATT_REVISION
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SL_BOARD
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
name|SL10_BOARD
case|:
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_type
operator|=
name|IE_STARLAN10
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_reset_586
operator|=
name|sl_reset_586
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|=
name|sl_chan_attn
expr_stmt|;
break|break;
case|case
name|EN100_BOARD
case|:
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_type
operator|=
name|IE_EN100
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_reset_586
operator|=
name|sl_reset_586
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|=
name|sl_chan_attn
expr_stmt|;
break|break;
case|case
name|SLFIBER_BOARD
case|:
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_type
operator|=
name|IE_SLFIBER
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_reset_586
operator|=
name|sl_reset_586
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|=
name|sl_chan_attn
expr_stmt|;
break|break;
comment|/*      * Anything else is not recognized or cannot be used.      */
default|default:
return|return
literal|0
return|;
block|}
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_vers
operator|=
name|SL_REV
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/*    * Divine memory size on-board the card.  Ususally 16k.    */
name|find_ie_mem_size
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iosize
condition|)
block|{
return|return
literal|0
return|;
block|}
name|dvp
operator|->
name|id_msize
operator|=
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iosize
expr_stmt|;
switch|switch
condition|(
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_type
condition|)
block|{
case|case
name|IE_EN100
case|:
case|case
name|IE_STARLAN10
case|:
case|case
name|IE_SLFIBER
case|:
name|sl_read_ether
argument_list|(
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ie%d: unknown AT&T board type code %d\n"
argument_list|,
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Taken almost exactly from Bill's if_is.c, then modified beyond recognition.  */
end_comment

begin_function
name|int
name|ieattach
parameter_list|(
name|dvp
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|struct
name|ie_softc
modifier|*
name|ie
init|=
operator|&
name|ie_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
name|iedriver
operator|.
name|name
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|printf
argument_list|(
literal|"<%s R%d> ethernet address %s"
argument_list|,
name|ie_hardware_names
index|[
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_type
index|]
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|hard_vers
operator|+
literal|1
argument_list|,
name|ether_sprintf
argument_list|(
name|ie
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_NOTRAILERS
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTICAST
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_MULTICAST
expr_stmt|;
endif|#
directive|endif
comment|/* MULTICAST */
name|ifp
operator|->
name|if_init
operator|=
name|ieinit
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|iestart
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ieioctl
expr_stmt|;
name|ifp
operator|->
name|if_reset
operator|=
name|iereset
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|ifp
operator|->
name|if_addrlen
operator|=
literal|6
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
literal|14
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|bpfattach
argument_list|(
operator|&
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
name|ifp
operator|->
name|if_addrlist
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
while|while
condition|(
name|ifa
operator|&&
name|ifa
operator|->
name|ifa_addr
operator|&&
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
expr_stmt|;
if|if
condition|(
operator|!
name|ifa
operator|||
operator|!
name|ifa
operator|->
name|ifa_addr
condition|)
return|return;
comment|/* Provide our ether address to the higher layers */
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
literal|6
expr_stmt|;
name|sdl
operator|->
name|sdl_slen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|ie
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * What to do upon receipt of an interrupt.  */
end_comment

begin_function
name|int
name|ieintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|ie_softc
modifier|*
name|ie
init|=
operator|&
name|ie_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|u_short
name|status
decl_stmt|;
name|status
operator|=
name|ie
operator|->
name|scb
operator|->
name|ie_status
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|status
operator|&
operator|(
name|IE_ST_RECV
operator||
name|IE_ST_RNR
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|in_ierint
operator|++
expr_stmt|;
if|if
condition|(
name|ie_debug
operator|&
name|IED_RINT
condition|)
name|printf
argument_list|(
literal|"ie%d: rint\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ierint
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|in_ierint
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|IE_ST_DONE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|in_ietint
operator|++
expr_stmt|;
if|if
condition|(
name|ie_debug
operator|&
name|IED_TINT
condition|)
name|printf
argument_list|(
literal|"ie%d: tint\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ietint
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|in_ietint
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|status
operator|&
name|IE_ST_RNR
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ie_debug
operator|&
name|IED_RNR
condition|)
name|printf
argument_list|(
literal|"ie%d: rnr\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iernr
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|status
operator|&
name|IE_ST_ALLDONE
operator|)
operator|&&
operator|(
name|ie_debug
operator|&
name|IED_CNA
operator|)
condition|)
name|printf
argument_list|(
literal|"ie%d: cna\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Don't ack interrupts which we didn't receive */
name|ie_ack
argument_list|(
name|ie
operator|->
name|scb
argument_list|,
name|IE_ST_WHENCE
operator|&
name|status
argument_list|,
name|unit
argument_list|,
name|ie
operator|->
name|ie_chan_attn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|=
name|ie
operator|->
name|scb
operator|->
name|ie_status
operator|)
operator|&
name|IE_ST_WHENCE
condition|)
goto|goto
name|loop
goto|;
return|return
name|unit
return|;
block|}
end_function

begin_comment
comment|/*  * Process a received-frame interrupt.  */
end_comment

begin_function
specifier|static
name|int
name|ierint
parameter_list|(
name|unit
parameter_list|,
name|ie
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|ie_softc
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|status
decl_stmt|;
specifier|static
name|int
name|timesthru
init|=
literal|1024
decl_stmt|;
name|i
operator|=
name|ie
operator|->
name|rfhead
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|status
operator|=
name|ie
operator|->
name|rframes
index|[
name|i
index|]
operator|->
name|ie_fd_status
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|IE_FD_COMPLETE
operator|)
operator|&&
operator|(
name|status
operator|&
name|IE_FD_OK
operator|)
condition|)
block|{
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|timesthru
condition|)
block|{
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|+=
name|ie
operator|->
name|scb
operator|->
name|ie_err_crc
operator|+
name|ie
operator|->
name|scb
operator|->
name|ie_err_align
operator|+
name|ie
operator|->
name|scb
operator|->
name|ie_err_resource
operator|+
name|ie
operator|->
name|scb
operator|->
name|ie_err_overrun
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_err_crc
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_err_align
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_err_resource
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_err_overrun
operator|=
literal|0
expr_stmt|;
name|timesthru
operator|=
literal|1024
expr_stmt|;
block|}
name|ie_readframe
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|status
operator|&
name|IE_FD_RNR
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ie
operator|->
name|scb
operator|->
name|ie_status
operator|&
name|IE_RU_READY
operator|)
condition|)
block|{
name|ie
operator|->
name|rframes
index|[
literal|0
index|]
operator|->
name|ie_fd_next
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie
operator|->
name|rbuffs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|NFRAMES
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Process a command-complete interrupt.  These are only generated by  * the transmission of frames.  This routine is deceptively simple, since  * most of the real work is done by iestart().  */
end_comment

begin_function
specifier|static
name|int
name|ietint
parameter_list|(
name|unit
parameter_list|,
name|ie
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|ie_softc
modifier|*
name|ie
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|xmit_count
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|ie
operator|->
name|xmit_cmds
index|[
name|i
index|]
operator|->
name|ie_xmit_status
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|IE_XS_LATECOLL
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: late collision\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|IE_XS_NOCARRIER
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: no carrier\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|IE_XS_LOSTCTS
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: lost CTS\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|IE_XS_UNDERRUN
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: DMA underrun\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|IE_XS_EXCMAX
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: too many collisions\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|+=
literal|16
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|+=
name|status
operator|&
name|IE_XS_MAXCOLL
expr_stmt|;
block|}
block|}
name|ie
operator|->
name|xmit_count
operator|=
literal|0
expr_stmt|;
comment|/*    * If multicast addresses were added or deleted while we were transmitting,    * ie_mc_reset() set the want_mcsetup flag indicating that we should do it.    */
if|if
condition|(
name|ie
operator|->
name|want_mcsetup
condition|)
block|{
name|mc_setup
argument_list|(
name|unit
argument_list|,
operator|(
name|caddr_t
operator|)
name|ie
operator|->
name|xmit_cbuffs
index|[
literal|0
index|]
argument_list|,
name|ie
operator|->
name|scb
argument_list|)
expr_stmt|;
name|ie
operator|->
name|want_mcsetup
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Wish I knew why this seems to be necessary... */
name|ie
operator|->
name|xmit_cmds
index|[
literal|0
index|]
operator|->
name|ie_xmit_status
operator||=
name|IE_STAT_COMPL
expr_stmt|;
name|iestart
argument_list|(
operator|&
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* shouldn't be necessary */
block|}
end_function

begin_comment
comment|/*  * Process a receiver-not-ready interrupt.  I believe that we get these  * when there aren't enough buffers to go around.  For now (FIXME), we  * just restart the receiver, and hope everything's ok.  */
end_comment

begin_function
specifier|static
name|int
name|iernr
parameter_list|(
name|unit
parameter_list|,
name|ie
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|ie_softc
modifier|*
name|ie
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|doesnt_work
name|setup_rfa
argument_list|(
operator|(
name|caddr_t
operator|)
name|ie
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* This doesn't work either, but it doesn't hang either. */
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_DISABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* just in case */
name|setup_rfa
argument_list|(
operator|(
name|caddr_t
operator|)
name|ie
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|ie
operator|->
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* was ENABLE */
endif|#
directive|endif
name|ie_ack
argument_list|(
name|ie
operator|->
name|scb
argument_list|,
name|IE_ST_WHENCE
argument_list|,
name|unit
argument_list|,
name|ie
operator|->
name|ie_chan_attn
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FILTER
end_ifdef

begin_comment
comment|/*  * Compare two Ether/802 addresses for equality, inlined and  * unrolled for speed.  I'd love to have an inline assembler  * version of this...  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ether_equal
parameter_list|(
name|u_char
modifier|*
name|one
parameter_list|,
name|u_char
modifier|*
name|two
parameter_list|)
block|{
if|if
condition|(
name|one
index|[
literal|0
index|]
operator|!=
name|two
index|[
literal|0
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|one
index|[
literal|1
index|]
operator|!=
name|two
index|[
literal|1
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|one
index|[
literal|2
index|]
operator|!=
name|two
index|[
literal|2
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|one
index|[
literal|3
index|]
operator|!=
name|two
index|[
literal|3
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|one
index|[
literal|4
index|]
operator|!=
name|two
index|[
literal|4
index|]
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|one
index|[
literal|5
index|]
operator|!=
name|two
index|[
literal|5
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Check for a valid address.  to_bpf is filled in with one of the following:  *   0 -> BPF doesn't get this packet  *   1 -> BPF does get this packet  *   2 -> BPF does get this packet, but we don't  * Return value is true if the packet is for us, and false otherwise.  *  * This routine is a mess, but it's also critical that it be as fast  * as possible.  It could be made cleaner if we can assume that the  * only client which will fiddle with IFF_PROMISC is BPF.  This is  * probably a good assumption, but we do not make it here.  (Yet.)  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|check_eh
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|,
name|struct
name|ether_header
modifier|*
name|eh
parameter_list|,
name|int
modifier|*
name|to_bpf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|ie
operator|->
name|promisc
condition|)
block|{
case|case
name|IFF_ALLMULTI
case|:
comment|/*      * Receiving all multicasts, but no unicasts except those destined for us.      */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
operator|*
name|to_bpf
operator|=
operator|(
name|ie
operator|->
name|ie_bpf
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* BPF gets this packet if anybody cares */
endif|#
directive|endif
if|if
condition|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ether_equal
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ie
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
case|case
name|IFF_PROMISC
case|:
comment|/*      * Receiving all packets.  These need to be passed on to BPF.      */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
operator|*
name|to_bpf
operator|=
operator|(
name|ie
operator|->
name|ie_bpf
operator|!=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* If for us, accept and hand up to BPF */
if|if
condition|(
name|ether_equal
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ie
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
condition|)
return|return
literal|1
return|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
operator|*
name|to_bpf
condition|)
operator|*
name|to_bpf
operator|=
literal|2
expr_stmt|;
comment|/* we don't need to see it */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MULTICAST
comment|/*      * Not a multicast, so BPF wants to see it but we don't.      */
if|if
condition|(
operator|!
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
condition|)
return|return
literal|1
return|;
comment|/*      * If it's one of our multicast groups, accept it and pass it      * up.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ie
operator|->
name|mcast_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ether_equal
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ie
operator|->
name|mcast_addrs
index|[
name|i
index|]
argument_list|)
condition|)
block|{
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
operator|*
name|to_bpf
condition|)
operator|*
name|to_bpf
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
block|}
endif|#
directive|endif
comment|/* MULTICAST */
return|return
literal|1
return|;
case|case
name|IFF_ALLMULTI
operator||
name|IFF_PROMISC
case|:
comment|/*      * Acting as a multicast router, and BPF running at the same time.      * Whew!  (Hope this is a fast machine...)      */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
operator|*
name|to_bpf
operator|=
operator|(
name|ie
operator|->
name|ie_bpf
operator|!=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* We want to see multicasts. */
if|if
condition|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
condition|)
return|return
literal|1
return|;
comment|/* We want to see our own packets */
if|if
condition|(
name|ether_equal
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ie
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Anything else goes to BPF but nothing else. */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
operator|*
name|to_bpf
condition|)
operator|*
name|to_bpf
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
default|default:
comment|/*      * Only accept unicast packets destined for us, or multicasts      * for groups that we belong to.  For now, we assume that the      * '586 will only return packets that we asked it for.  This      * isn't strictly true (it uses hashing for the multicast filter),      * but it will do in this case, and we want to get out of here      * as quickly as possible.      */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
operator|*
name|to_bpf
operator|=
operator|(
name|ie
operator|->
name|ie_bpf
operator|!=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FILTER */
end_comment

begin_comment
comment|/*  * We want to isolate the bits that have meaning...  This assumes that  * IE_RBUF_SIZE is an even power of two.  If somehow the act_len exceeds  * the size of the buffer, then we are screwed anyway.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ie_buflen
parameter_list|(
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|,
name|int
name|head
parameter_list|)
block|{
return|return
operator|(
name|ie
operator|->
name|rbuffs
index|[
name|head
index|]
operator|->
name|ie_rbd_actual
operator|&
operator|(
name|IE_RBUF_SIZE
operator||
operator|(
name|IE_RBUF_SIZE
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ie_packet_len
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|head
init|=
name|ie
operator|->
name|rbhead
decl_stmt|;
name|int
name|acc
init|=
literal|0
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|!
operator|(
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_actual
operator|&
name|IE_RBD_USED
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|print_rbd
argument_list|(
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ie%d: receive descriptors out of sync at %d\n"
argument_list|,
name|unit
argument_list|,
name|ie
operator|->
name|rbhead
argument_list|)
expr_stmt|;
name|iereset
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|i
operator|=
name|ie
operator|->
name|rbuffs
index|[
name|head
index|]
operator|->
name|ie_rbd_actual
operator|&
name|IE_RBD_LAST
expr_stmt|;
name|acc
operator|+=
name|ie_buflen
argument_list|(
name|ie
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
operator|(
name|head
operator|+
literal|1
operator|)
operator|%
name|NBUFFS
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|i
condition|)
do|;
return|return
name|acc
return|;
block|}
end_function

begin_comment
comment|/*  * Read data off the interface, and turn it into an mbuf chain.  *  * This code is DRAMATICALLY different from the previous version; this  * version tries to allocate the entire mbuf chain up front, given the  * length of the data available.  This enables us to allocate mbuf  * clusters in many situations where before we would have had a long  * chain of partially-full mbufs.  This should help to speed up the  * operation considerably.  (Provided that it works, of course.)  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|ieget
parameter_list|(
name|unit
parameter_list|,
name|ie
parameter_list|,
name|mp
parameter_list|,
name|ehp
parameter_list|,
name|to_bpf
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|ie_softc
modifier|*
name|ie
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|ehp
decl_stmt|;
name|int
modifier|*
name|to_bpf
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mymp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|resid
decl_stmt|;
name|int
name|thismboff
decl_stmt|;
name|int
name|head
decl_stmt|;
name|totlen
operator|=
name|ie_packet_len
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|totlen
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|i
operator|=
name|ie
operator|->
name|rbhead
expr_stmt|;
comment|/*    * Snarf the Ethernet header.    */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ie
operator|->
name|cbuffs
index|[
name|i
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
name|ehp
argument_list|,
sizeof|sizeof
expr|*
name|ehp
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual warning here */
comment|/*    * As quickly as possible, check if this packet is for us.    * If not, don't waste a single cycle copying the rest of the    * packet in.    * This is only a consideration when FILTER is defined; i.e., when    * we are either running BPF or doing multicasting.    */
ifdef|#
directive|ifdef
name|FILTER
if|if
condition|(
operator|!
name|check_eh
argument_list|(
name|ie
argument_list|,
name|ehp
argument_list|,
name|to_bpf
argument_list|)
condition|)
block|{
name|ie_drop_packet_buffer
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|--
expr_stmt|;
comment|/* just this case, it's not an error */
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
name|totlen
operator|-=
operator|(
name|offset
operator|=
sizeof|sizeof
expr|*
name|ehp
operator|)
expr_stmt|;
name|MGETHDR
argument_list|(
operator|*
name|mp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|mp
condition|)
block|{
name|ie_drop_packet_buffer
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|resid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|mymp
operator|=
operator|&
name|top
expr_stmt|;
comment|/*    * This loop goes through and allocates mbufs for all the data we will    * be copying in.  It does not actually do the copying yet.    */
do|do
block|{
comment|/* while(resid> 0) */
comment|/*      * Try to allocate an mbuf to hold the data that we have.  If we       * already allocated one, just get another one and stick it on the      * end (eventually).  If we don't already have one, try to allocate      * an mbuf cluster big enough to hold the whole packet, if we think it's      * reasonable, or a single mbuf which may or may not be big enough.      * Got that?      */
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|ie_drop_packet_buffer
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|resid
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|resid
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|resid
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|!
name|top
operator|&&
name|resid
operator|+
name|max_linkhdr
operator|<=
name|m
operator|->
name|m_len
condition|)
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|resid
expr_stmt|;
block|}
block|}
name|resid
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
operator|*
name|mymp
operator|=
name|m
expr_stmt|;
name|mymp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
do|while
condition|(
name|resid
operator|>
literal|0
condition|)
do|;
name|resid
operator|=
name|totlen
expr_stmt|;
name|m
operator|=
name|top
expr_stmt|;
name|thismboff
operator|=
literal|0
expr_stmt|;
name|head
operator|=
name|ie
operator|->
name|rbhead
expr_stmt|;
comment|/*    * Now we take the mbuf chain (hopefully only one mbuf most of the    * time) and stuff the data into it.  There are no possible failures    * at or after this point.    */
while|while
condition|(
name|resid
operator|>
literal|0
condition|)
block|{
comment|/* while there's stuff left */
name|int
name|thislen
init|=
name|ie_buflen
argument_list|(
name|ie
argument_list|,
name|head
argument_list|)
operator|-
name|offset
decl_stmt|;
comment|/*      * If too much data for the current mbuf, then fill the current one      * up, go to the next one, and try again.      */
if|if
condition|(
name|thislen
operator|>
name|m
operator|->
name|m_len
operator|-
name|thismboff
condition|)
block|{
name|int
name|newlen
init|=
name|m
operator|->
name|m_len
operator|-
name|thismboff
decl_stmt|;
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|ie
operator|->
name|cbuffs
index|[
name|head
index|]
operator|+
name|offset
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|thismboff
argument_list|,
operator|(
name|unsigned
operator|)
name|newlen
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual warning */
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|thismboff
operator|=
literal|0
expr_stmt|;
comment|/* new mbuf, so no offset */
name|offset
operator|+=
name|newlen
expr_stmt|;
comment|/* we are now this far into the packet */
name|resid
operator|-=
name|newlen
expr_stmt|;
comment|/* so there is this much left to get */
continue|continue;
block|}
comment|/*      * If there is more than enough space in the mbuf to hold the      * contents of this buffer, copy everything in, advance pointers,      * and so on.      */
if|if
condition|(
name|thislen
operator|<
name|m
operator|->
name|m_len
operator|-
name|thismboff
condition|)
block|{
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|ie
operator|->
name|cbuffs
index|[
name|head
index|]
operator|+
name|offset
argument_list|)
argument_list|,
comment|/* ignore warning */
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|thismboff
argument_list|,
operator|(
name|unsigned
operator|)
name|thislen
argument_list|)
expr_stmt|;
name|thismboff
operator|+=
name|thislen
expr_stmt|;
comment|/* we are this far into the mbuf */
name|resid
operator|-=
name|thislen
expr_stmt|;
comment|/* and this much is left */
goto|goto
name|nextbuf
goto|;
block|}
comment|/*      * Otherwise, there is exactly enough space to put this buffer's      * contents into the current mbuf.  Do the combination of the above      * actions.      */
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|ie
operator|->
name|cbuffs
index|[
name|head
index|]
operator|+
name|offset
argument_list|)
argument_list|,
comment|/* ignore warning */
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|thismboff
argument_list|,
operator|(
name|unsigned
operator|)
name|thislen
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|thismboff
operator|=
literal|0
expr_stmt|;
comment|/* new mbuf, start at the beginning */
name|resid
operator|-=
name|thislen
expr_stmt|;
comment|/* and we are this far through */
comment|/*      * Advance all the pointers.  We can get here from either of the      * last two cases, but never the first.      */
name|nextbuf
label|:
name|offset
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|rbuffs
index|[
name|head
index|]
operator|->
name|ie_rbd_actual
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|rbuffs
index|[
name|head
index|]
operator|->
name|ie_rbd_length
operator||=
name|IE_RBD_LAST
expr_stmt|;
name|ie
operator|->
name|rbhead
operator|=
name|head
operator|=
operator|(
name|head
operator|+
literal|1
operator|)
operator|%
name|NBUFFS
expr_stmt|;
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbtail
index|]
operator|->
name|ie_rbd_length
operator|&=
operator|~
name|IE_RBD_LAST
expr_stmt|;
name|ie
operator|->
name|rbtail
operator|=
operator|(
name|ie
operator|->
name|rbtail
operator|+
literal|1
operator|)
operator|%
name|NBUFFS
expr_stmt|;
block|}
comment|/*    * Unless something changed strangely while we were doing the copy,    * we have now copied everything in from the shared memory.    * This means that we are done.    */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read frame NUM from unit UNIT (pre-cached as IE).  *  * This routine reads the RFD at NUM, and copies in the buffers from  * the list of RBD, then rotates the RBD and RFD lists so that the receiver  * doesn't start complaining.  Trailers are DROPPED---there's no point  * in wasting time on confusing code to deal with them.  Hopefully,  * this machine will never ARP for trailers anyway.  */
end_comment

begin_function
specifier|static
name|void
name|ie_readframe
parameter_list|(
name|unit
parameter_list|,
name|ie
parameter_list|,
name|num
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|ie_softc
modifier|*
name|ie
decl_stmt|;
name|int
name|num
decl_stmt|;
comment|/* frame number to read */
block|{
name|struct
name|ie_recv_frame_desc
name|rfd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
literal|0
decl_stmt|;
name|struct
name|ether_header
name|eh
decl_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|int
name|bpf_gets_it
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|bcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|ie
operator|->
name|rframes
index|[
name|num
index|]
argument_list|)
argument_list|,
operator|&
name|rfd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ie_recv_frame_desc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Immediately advance the RFD list, since we we have copied ours now. */
name|ie
operator|->
name|rframes
index|[
name|num
index|]
operator|->
name|ie_fd_status
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|rframes
index|[
name|num
index|]
operator|->
name|ie_fd_last
operator||=
name|IE_FD_LAST
expr_stmt|;
name|ie
operator|->
name|rframes
index|[
name|ie
operator|->
name|rftail
index|]
operator|->
name|ie_fd_last
operator|&=
operator|~
name|IE_FD_LAST
expr_stmt|;
name|ie
operator|->
name|rftail
operator|=
operator|(
name|ie
operator|->
name|rftail
operator|+
literal|1
operator|)
operator|%
name|NFRAMES
expr_stmt|;
name|ie
operator|->
name|rfhead
operator|=
operator|(
name|ie
operator|->
name|rfhead
operator|+
literal|1
operator|)
operator|%
name|NFRAMES
expr_stmt|;
if|if
condition|(
name|rfd
operator|.
name|ie_fd_status
operator|&
name|IE_FD_OK
condition|)
block|{
if|if
condition|(
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|ieget
argument_list|(
argument|unit
argument_list|,
argument|ie
argument_list|,
argument|&m
argument_list|,
argument|&eh
argument_list|,
argument|&bpf_gets_it
argument_list|)
else|#
directive|else
name|ieget
argument_list|(
name|unit
argument_list|,
name|ie
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|eh
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
comment|/* this counts as an error */
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ie_debug
operator|&
name|IED_READFRAME
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: frame from ether %s type %x\n"
argument_list|,
name|unit
argument_list|,
name|ether_sprintf
argument_list|(
name|eh
operator|.
name|ether_shost
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|eh
operator|.
name|ether_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|eh
operator|.
name|ether_type
argument_list|)
operator|>
name|ETHERTYPE_TRAIL
operator|&&
name|ntohs
argument_list|(
name|eh
operator|.
name|ether_type
argument_list|)
operator|<
operator|(
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
operator|)
condition|)
name|printf
argument_list|(
literal|"received trailer!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|m
condition|)
return|return;
ifdef|#
directive|ifdef
name|FILTER
if|if
condition|(
name|last_not_for_us
condition|)
block|{
name|m_freem
argument_list|(
name|last_not_for_us
argument_list|)
expr_stmt|;
name|last_not_for_us
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/*    * Check for a BPF filter; if so, hand it up.    * Note that we have to stick an extra mbuf up front, because    * bpf_mtap expects to have the ether header at the front.    * It doesn't matter that this results in an ill-formatted mbuf chain,    * since BPF just looks at the data.  (It doesn't try to free the mbuf,    * tho' it will make a copy for tcpdump.)    */
if|if
condition|(
name|bpf_gets_it
condition|)
block|{
name|struct
name|mbuf
name|m0
decl_stmt|;
name|m0
operator|.
name|m_len
operator|=
sizeof|sizeof
name|eh
expr_stmt|;
name|m0
operator|.
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|eh
expr_stmt|;
name|m0
operator|.
name|m_next
operator|=
name|m
expr_stmt|;
comment|/* Pass it up */
name|bpf_mtap
argument_list|(
name|ie
operator|->
name|ie_bpf
argument_list|,
operator|&
name|m0
argument_list|)
expr_stmt|;
block|}
comment|/*    * A signal passed up from the filtering code indicating that the    * packet is intended for BPF but not for the protocol machinery.    * We can save a few cycles by not handing it off to them.    */
if|if
condition|(
name|bpf_gets_it
operator|==
literal|2
condition|)
block|{
name|last_not_for_us
operator|=
name|m
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* NBPFILTER> 0 */
comment|/*    * In here there used to be code to check destination addresses upon    * receipt of a packet.  We have deleted that code, and replaced it    * with code to check the address much earlier in the cycle, before    * copying the data in; this saves us valuable cycles when operating    * as a multicast router or when using BPF.    */
endif|#
directive|endif
comment|/* FILTER */
name|eh
operator|.
name|ether_type
operator|=
name|ntohs
argument_list|(
name|eh
operator|.
name|ether_type
argument_list|)
expr_stmt|;
comment|/*    * Finally pass this packet up to higher layers.    */
name|ether_input
argument_list|(
operator|&
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
operator|&
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ie_drop_packet_buffer
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
do|do
block|{
comment|/*      * This means we are somehow out of sync.  So, we reset the      * adapter.      */
if|if
condition|(
operator|!
operator|(
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_actual
operator|&
name|IE_RBD_USED
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|print_rbd
argument_list|(
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ie%d: receive descriptors out of sync at %d\n"
argument_list|,
name|unit
argument_list|,
name|ie
operator|->
name|rbhead
argument_list|)
expr_stmt|;
name|iereset
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_actual
operator|&
name|IE_RBD_LAST
expr_stmt|;
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_length
operator||=
name|IE_RBD_LAST
expr_stmt|;
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbhead
index|]
operator|->
name|ie_rbd_actual
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|rbhead
operator|=
operator|(
name|ie
operator|->
name|rbhead
operator|+
literal|1
operator|)
operator|%
name|NBUFFS
expr_stmt|;
name|ie
operator|->
name|rbuffs
index|[
name|ie
operator|->
name|rbtail
index|]
operator|->
name|ie_rbd_length
operator|&=
operator|~
name|IE_RBD_LAST
expr_stmt|;
name|ie
operator|->
name|rbtail
operator|=
operator|(
name|ie
operator|->
name|rbtail
operator|+
literal|1
operator|)
operator|%
name|NBUFFS
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|i
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Start transmission on an interface.  */
end_comment

begin_function
name|int
name|iestart
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ie_softc
modifier|*
name|ie
init|=
operator|&
name|ie_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buffer
decl_stmt|;
name|u_short
name|len
decl_stmt|;
comment|/* This is not really volatile, in this routine, but it makes gcc happy. */
specifier|volatile
name|u_short
modifier|*
name|bptr
init|=
operator|&
name|ie
operator|->
name|scb
operator|->
name|ie_command_list
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
return|return
literal|0
return|;
do|do
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
break|break;
name|buffer
operator|=
name|ie
operator|->
name|xmit_cbuffs
index|[
name|ie
operator|->
name|xmit_count
index|]
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m
operator|&&
name|len
operator|<
name|IE_BUF_LEN
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|len
operator|=
name|MAX
argument_list|(
name|len
argument_list|,
name|ETHERMINLEN
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/*      * See if bpf is listening on this interface, let it see the packet      * before we commit it to the wire.      */
if|if
condition|(
name|ie
operator|->
name|ie_bpf
condition|)
name|bpf_tap
argument_list|(
name|ie
operator|->
name|ie_bpf
argument_list|,
name|ie
operator|->
name|xmit_cbuffs
index|[
name|ie
operator|->
name|xmit_count
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ie
operator|->
name|xmit_buffs
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_flags
operator|=
name|IE_XMIT_LAST
operator||
name|len
expr_stmt|;
name|ie
operator|->
name|xmit_buffs
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_next
operator|=
literal|0xffff
expr_stmt|;
name|ie
operator|->
name|xmit_buffs
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_buf
operator|=
name|MK_24
argument_list|(
name|ie
operator|->
name|iomem
argument_list|,
name|ie
operator|->
name|xmit_cbuffs
index|[
name|ie
operator|->
name|xmit_count
index|]
argument_list|)
expr_stmt|;
name|ie
operator|->
name|xmit_cmds
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_XMIT
expr_stmt|;
name|ie
operator|->
name|xmit_cmds
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_status
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|xmit_cmds
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|ie_xmit_desc
operator|=
name|MK_16
argument_list|(
name|ie
operator|->
name|iomem
argument_list|,
name|ie
operator|->
name|xmit_buffs
index|[
name|ie
operator|->
name|xmit_count
index|]
argument_list|)
expr_stmt|;
operator|*
name|bptr
operator|=
name|MK_16
argument_list|(
name|ie
operator|->
name|iomem
argument_list|,
name|ie
operator|->
name|xmit_cmds
index|[
name|ie
operator|->
name|xmit_count
index|]
argument_list|)
expr_stmt|;
name|bptr
operator|=
operator|&
name|ie
operator|->
name|xmit_cmds
index|[
name|ie
operator|->
name|xmit_count
index|]
operator|->
name|com
operator|.
name|ie_cmd_link
expr_stmt|;
name|ie
operator|->
name|xmit_count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ie
operator|->
name|xmit_count
operator|<
literal|2
condition|)
do|;
comment|/*    * If we queued up anything for transmission, send it.    */
if|if
condition|(
name|ie
operator|->
name|xmit_count
condition|)
block|{
name|ie
operator|->
name|xmit_cmds
index|[
name|ie
operator|->
name|xmit_count
operator|-
literal|1
index|]
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator||=
name|IE_CMD_LAST
operator||
name|IE_CMD_INTR
expr_stmt|;
comment|/*      * By passing the command pointer as a null, we tell      * command_and_wait() to pretend that this isn't an action      * command.  I wish I understood what was happening here.      */
name|command_and_wait
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|,
name|IE_CU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if there's an 82586 out there.  */
end_comment

begin_function
name|int
name|check_ie_present
parameter_list|(
name|unit
parameter_list|,
name|where
parameter_list|,
name|size
parameter_list|)
name|int
name|unit
decl_stmt|;
name|caddr_t
name|where
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
specifier|volatile
name|struct
name|ie_sys_conf_ptr
modifier|*
name|scp
decl_stmt|;
specifier|volatile
name|struct
name|ie_int_sys_conf_ptr
modifier|*
name|iscp
decl_stmt|;
specifier|volatile
name|struct
name|ie_sys_ctl_block
modifier|*
name|scb
decl_stmt|;
name|u_long
name|realbase
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|realbase
operator|=
operator|(
name|u_long
operator|)
name|where
operator|+
name|size
operator|-
operator|(
literal|1
operator|<<
literal|24
operator|)
expr_stmt|;
name|scp
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_sys_conf_ptr
operator|*
operator|)
operator|(
name|realbase
operator|+
name|IE_SCP_ADDR
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|scp
argument_list|,
sizeof|sizeof
expr|*
name|scp
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
comment|/*    * First we put the ISCP at the bottom of memory; this tests to make    * sure that our idea of the size of memory is the same as the controller's.    * This is NOT where the ISCP will be in normal operation.    */
name|iscp
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_int_sys_conf_ptr
operator|*
operator|)
name|where
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iscp
argument_list|,
sizeof|sizeof
expr|*
name|iscp
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|scb
operator|=
operator|(
specifier|volatile
expr|struct
name|ie_sys_ctl_block
operator|*
operator|)
name|where
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|scb
argument_list|,
sizeof|sizeof
expr|*
name|scb
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|scp
operator|->
name|ie_bus_use
operator|=
literal|0
expr_stmt|;
comment|/* 16-bit */
name|scp
operator|->
name|ie_iscp_ptr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
specifier|volatile
name|caddr_t
operator|)
name|iscp
operator|-
comment|/* ignore cast-qual */
operator|(
specifier|volatile
name|caddr_t
operator|)
name|realbase
argument_list|)
expr_stmt|;
name|iscp
operator|->
name|ie_busy
operator|=
literal|1
expr_stmt|;
name|iscp
operator|->
name|ie_scb_offset
operator|=
name|MK_16
argument_list|(
name|realbase
argument_list|,
name|scb
argument_list|)
operator|+
literal|256
expr_stmt|;
operator|(
operator|*
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_reset_586
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
operator|(
operator|*
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* wait a while... */
if|if
condition|(
name|iscp
operator|->
name|ie_busy
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*    * Now relocate the ISCP to its real home, and reset the controller    * again.    */
name|iscp
operator|=
operator|(
name|void
operator|*
operator|)
name|Align
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|realbase
operator|+
name|IE_SCP_ADDR
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ie_int_sys_conf_ptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iscp
argument_list|,
sizeof|sizeof
expr|*
name|iscp
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|scp
operator|->
name|ie_iscp_ptr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|caddr_t
operator|)
name|iscp
operator|-
operator|(
name|caddr_t
operator|)
name|realbase
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|iscp
operator|->
name|ie_busy
operator|=
literal|1
expr_stmt|;
name|iscp
operator|->
name|ie_scb_offset
operator|=
name|MK_16
argument_list|(
name|realbase
argument_list|,
name|scb
argument_list|)
expr_stmt|;
operator|(
operator|*
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_reset_586
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
operator|(
operator|*
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|iscp
operator|->
name|ie_busy
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iosize
operator|=
name|size
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iomem
operator|=
operator|(
name|caddr_t
operator|)
name|realbase
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iscp
operator|=
name|iscp
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
operator|=
name|scb
expr_stmt|;
comment|/*    * Acknowledge any interrupts we may have caused...    */
name|ie_ack
argument_list|(
name|scb
argument_list|,
name|IE_ST_WHENCE
argument_list|,
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Divine the memory size of ie board UNIT.  * Better hope there's nothing important hiding just below the ie card...  */
end_comment

begin_function
specifier|static
name|void
name|find_ie_mem_size
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|unsigned
name|size
decl_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iosize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|size
operator|=
literal|65536
init|;
name|size
operator|>=
literal|16384
condition|;
name|size
operator|-=
literal|16384
control|)
block|{
if|if
condition|(
name|check_ie_present
argument_list|(
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iomembot
argument_list|,
name|size
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
return|return;
block|}
end_function

begin_function
name|void
name|sl_reset_586
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|outb
argument_list|(
name|PORT
operator|+
name|IEATT_RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sl_chan_attn
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|outb
argument_list|(
name|PORT
operator|+
name|IEATT_ATTN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sl_read_ether
parameter_list|(
name|unit
parameter_list|,
name|addr
parameter_list|)
name|int
name|unit
decl_stmt|;
name|unsigned
name|char
name|addr
index|[
literal|6
index|]
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|addr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|PORT
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iereset
parameter_list|(
name|unit
parameter_list|,
name|dummy
parameter_list|)
name|int
name|unit
decl_stmt|,
name|dummy
decl_stmt|;
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NIE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|printf
argument_list|(
literal|"ie%d: reset\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|ieioctl
argument_list|(
operator|&
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_if
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*    * Stop i82586 dead in its tracks.    */
if|if
condition|(
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_ABORT
operator||
name|IE_CU_ABORT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ie%d: abort commands timed out\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_DISABLE
operator||
name|IE_CU_STOP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ie%d: disable commands timed out\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|!
name|check_ie_present
argument_list|(
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iomembot
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|iosize
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ie disappeared!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|ieioctl
argument_list|(
operator|&
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_if
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This is called if we time out.  */
end_comment

begin_function
specifier|static
name|int
name|chan_attn_timeout
parameter_list|(
name|rock
parameter_list|)
name|caddr_t
name|rock
decl_stmt|;
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|rock
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Send a command to the controller and wait for it to either  * complete or be accepted, depending on the command.  If the  * command pointer is null, then pretend that the command is  * not an action command.  If the command pointer is not null,  * and the command is an action command, wait for  * ((volatile struct ie_cmd_common *)pcmd)->ie_cmd_status& MASK  * to become true.  */
end_comment

begin_function
specifier|static
name|int
name|command_and_wait
parameter_list|(
name|unit
parameter_list|,
name|cmd
parameter_list|,
name|pcmd
parameter_list|,
name|mask
parameter_list|)
name|int
name|unit
decl_stmt|;
name|int
name|cmd
decl_stmt|;
specifier|volatile
name|void
modifier|*
name|pcmd
decl_stmt|;
name|int
name|mask
decl_stmt|;
block|{
specifier|volatile
name|struct
name|ie_cmd_common
modifier|*
name|cc
init|=
name|pcmd
decl_stmt|;
specifier|volatile
name|int
name|timedout
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|hz
decl_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
operator|->
name|ie_command
operator|=
operator|(
name|u_short
operator|)
name|cmd
expr_stmt|;
if|if
condition|(
name|IE_ACTION_COMMAND
argument_list|(
name|cmd
argument_list|)
operator|&&
name|pcmd
condition|)
block|{
operator|(
operator|*
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
comment|/*      * According to the packet driver, the minimum timeout should be      * .369 seconds, which we round up to .37.      */
name|timeout
argument_list|(
name|chan_attn_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|timedout
argument_list|,
literal|37
operator|*
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
comment|/*      * Now spin-lock waiting for status.  This is not a very nice      * thing to do, but I haven't figured out how, or indeed if, we      * can put the process waiting for action to sleep.  (We may      * be getting called through some other timeout running in the      * kernel.)      */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|cc
operator|->
name|ie_cmd_status
operator|&
name|mask
operator|)
operator|||
name|timedout
condition|)
break|break;
block|}
name|untimeout
argument_list|(
name|chan_attn_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|timedout
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
return|return
name|timedout
return|;
block|}
else|else
block|{
comment|/*      * Otherwise, just wait for the command to be accepted.      */
operator|(
operator|*
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
operator|)
operator|(
name|unit
operator|)
expr_stmt|;
while|while
condition|(
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
operator|->
name|ie_command
condition|)
empty_stmt|;
comment|/* spin lock */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Run the time-domain reflectometer...  */
end_comment

begin_function
specifier|static
name|void
name|run_tdr
parameter_list|(
name|unit
parameter_list|,
name|cmd
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|ie_tdr_cmd
modifier|*
name|cmd
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_TDR
operator||
name|IE_CMD_LAST
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_link
operator|=
literal|0xffff
expr_stmt|;
name|cmd
operator|->
name|ie_tdr_time
operator|=
literal|0
expr_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
operator|->
name|ie_command_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ie_tdr_time
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_CU_START
argument_list|,
name|cmd
argument_list|,
name|IE_STAT_COMPL
argument_list|)
condition|)
name|result
operator|=
literal|0x2000
expr_stmt|;
else|else
name|result
operator|=
name|cmd
operator|->
name|ie_tdr_time
expr_stmt|;
name|ie_ack
argument_list|(
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
argument_list|,
name|IE_ST_WHENCE
argument_list|,
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&
name|IE_TDR_SUCCESS
condition|)
return|return;
if|if
condition|(
name|result
operator|&
name|IE_TDR_XCVR
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: transceiver problem\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|&
name|IE_TDR_OPEN
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: TDR detected an open %d clocks away\n"
argument_list|,
name|unit
argument_list|,
name|result
operator|&
name|IE_TDR_TIME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|&
name|IE_TDR_SHORT
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: TDR detected a short %d clocks away\n"
argument_list|,
name|unit
argument_list|,
name|result
operator|&
name|IE_TDR_TIME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ie%d: TDR returned unknown status %x\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|start_receiver
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_START
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ie_ack
argument_list|(
name|ie_softc
index|[
name|unit
index|]
operator|.
name|scb
argument_list|,
name|IE_ST_WHENCE
argument_list|,
name|unit
argument_list|,
name|ie_softc
index|[
name|unit
index|]
operator|.
name|ie_chan_attn
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Here is a helper routine for iernr() and ieinit().  This sets up  * the RFA.  */
end_comment

begin_function
specifier|static
name|caddr_t
name|setup_rfa
parameter_list|(
name|caddr_t
name|ptr
parameter_list|,
name|struct
name|ie_softc
modifier|*
name|ie
parameter_list|)
block|{
specifier|volatile
name|struct
name|ie_recv_frame_desc
modifier|*
name|rfd
init|=
operator|(
name|void
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|volatile
name|struct
name|ie_recv_buf_desc
modifier|*
name|rbd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|unit
init|=
name|ie
operator|-
operator|&
name|ie_softc
index|[
literal|0
index|]
decl_stmt|;
comment|/* First lay them out */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFRAMES
condition|;
name|i
operator|++
control|)
block|{
name|ie
operator|->
name|rframes
index|[
name|i
index|]
operator|=
name|rfd
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rfd
argument_list|,
sizeof|sizeof
expr|*
name|rfd
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|rfd
operator|++
expr_stmt|;
block|}
name|ptr
operator|=
operator|(
name|caddr_t
operator|)
name|Align
argument_list|(
operator|(
name|caddr_t
operator|)
name|rfd
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
comment|/* Now link them together */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NFRAMES
condition|;
name|i
operator|++
control|)
block|{
name|ie
operator|->
name|rframes
index|[
name|i
index|]
operator|->
name|ie_fd_next
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie
operator|->
name|rframes
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|NFRAMES
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, set the EOL bit on the last one. */
name|ie
operator|->
name|rframes
index|[
name|NFRAMES
operator|-
literal|1
index|]
operator|->
name|ie_fd_last
operator||=
name|IE_FD_LAST
expr_stmt|;
comment|/*    * Now lay out some buffers for the incoming frames.  Note that    * we set aside a bit of slop in each buffer, to make sure that    * we have enough space to hold a single frame in every buffer.    */
name|rbd
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUFFS
condition|;
name|i
operator|++
control|)
block|{
name|ie
operator|->
name|rbuffs
index|[
name|i
index|]
operator|=
name|rbd
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rbd
argument_list|,
sizeof|sizeof
expr|*
name|rbd
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|ptr
operator|=
operator|(
name|caddr_t
operator|)
name|Align
argument_list|(
name|ptr
operator|+
sizeof|sizeof
expr|*
name|rbd
argument_list|)
expr_stmt|;
name|rbd
operator|->
name|ie_rbd_length
operator|=
name|IE_RBUF_SIZE
expr_stmt|;
name|rbd
operator|->
name|ie_rbd_buffer
operator|=
name|MK_24
argument_list|(
name|MEM
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ie
operator|->
name|cbuffs
index|[
name|i
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|IE_RBUF_SIZE
expr_stmt|;
name|rbd
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
block|}
comment|/* Now link them together */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBUFFS
condition|;
name|i
operator|++
control|)
block|{
name|ie
operator|->
name|rbuffs
index|[
name|i
index|]
operator|->
name|ie_rbd_next
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie
operator|->
name|rbuffs
index|[
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|NBUFFS
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Tag EOF on the last one */
name|ie
operator|->
name|rbuffs
index|[
name|NBUFFS
operator|-
literal|1
index|]
operator|->
name|ie_rbd_length
operator||=
name|IE_RBD_LAST
expr_stmt|;
comment|/* We use the head and tail pointers on receive to keep track of    * the order in which RFDs and RBDs are used. */
name|ie
operator|->
name|rfhead
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|rftail
operator|=
name|NFRAMES
operator|-
literal|1
expr_stmt|;
name|ie
operator|->
name|rbhead
operator|=
literal|0
expr_stmt|;
name|ie
operator|->
name|rbtail
operator|=
name|NBUFFS
operator|-
literal|1
expr_stmt|;
name|ie
operator|->
name|scb
operator|->
name|ie_recv_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie
operator|->
name|rframes
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ie
operator|->
name|rframes
index|[
literal|0
index|]
operator|->
name|ie_fd_buf_desc
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|ie
operator|->
name|rbuffs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|Align
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/*  * Run the multicast setup command.  * Call at splimp().  */
end_comment

begin_function
specifier|static
name|int
name|mc_setup
parameter_list|(
name|int
name|unit
parameter_list|,
name|caddr_t
name|ptr
parameter_list|,
specifier|volatile
name|struct
name|ie_sys_ctl_block
modifier|*
name|scb
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|ie
init|=
operator|&
name|ie_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|volatile
name|struct
name|ie_mcast_cmd
modifier|*
name|cmd
init|=
operator|(
name|void
operator|*
operator|)
name|ptr
decl_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_MCAST
operator||
name|IE_CMD_LAST
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_link
operator|=
literal|0xffff
expr_stmt|;
comment|/* ignore cast-qual */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ie
operator|->
name|mcast_addrs
argument_list|,
operator|(
name|caddr_t
operator|)
name|cmd
operator|->
name|ie_mcast_addrs
argument_list|,
name|ie
operator|->
name|mcast_count
operator|*
sizeof|sizeof
expr|*
name|ie
operator|->
name|mcast_addrs
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|ie_mcast_bytes
operator|=
name|ie
operator|->
name|mcast_count
operator|*
literal|6
expr_stmt|;
comment|/* grrr... */
name|scb
operator|->
name|ie_command_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_CU_START
argument_list|,
name|cmd
argument_list|,
name|IE_STAT_COMPL
argument_list|)
operator|||
operator|!
operator|(
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|&
name|IE_STAT_OK
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: multicast address setup command failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * This routine takes the environment generated by check_ie_present()  * and adds to it all the other structures we need to operate the adapter.  * This includes executing the CONFIGURE, IA-SETUP, and MC-SETUP commands,  * starting the receiver unit, and clearing interrupts.  *  * THIS ROUTINE MUST BE CALLED AT splimp() OR HIGHER.  */
end_comment

begin_function
name|int
name|ieinit
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ie_softc
modifier|*
name|ie
init|=
operator|&
name|ie_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|volatile
name|struct
name|ie_sys_ctl_block
modifier|*
name|scb
init|=
name|ie
operator|->
name|scb
decl_stmt|;
name|caddr_t
name|ptr
decl_stmt|;
name|ptr
operator|=
operator|(
name|caddr_t
operator|)
name|Align
argument_list|(
operator|(
name|caddr_t
operator|)
name|scb
operator|+
sizeof|sizeof
expr|*
name|scb
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
comment|/*    * Send the configure command first.    */
block|{
specifier|volatile
name|struct
name|ie_config_cmd
modifier|*
name|cmd
init|=
operator|(
name|void
operator|*
operator|)
name|ptr
decl_stmt|;
name|ie_setup_config
argument_list|(
name|cmd
argument_list|,
name|ie
operator|->
name|promisc
argument_list|,
name|ie
operator|->
name|hard_type
operator|==
name|IE_STARLAN10
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_CONFIG
operator||
name|IE_CMD_LAST
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_link
operator|=
literal|0xffff
expr_stmt|;
name|scb
operator|->
name|ie_command_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_CU_START
argument_list|,
name|cmd
argument_list|,
name|IE_STAT_COMPL
argument_list|)
operator|||
operator|!
operator|(
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|&
name|IE_STAT_OK
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: configure command failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/*    * Now send the Individual Address Setup command.    */
block|{
specifier|volatile
name|struct
name|ie_iasetup_cmd
modifier|*
name|cmd
init|=
operator|(
name|void
operator|*
operator|)
name|ptr
decl_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_cmd
operator|=
name|IE_CMD_IASETUP
operator||
name|IE_CMD_LAST
expr_stmt|;
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_link
operator|=
literal|0xffff
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ie_softc
index|[
name|unit
index|]
operator|.
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cmd
operator|->
name|ie_address
argument_list|,
sizeof|sizeof
name|cmd
operator|->
name|ie_address
argument_list|)
expr_stmt|;
comment|/* ignore cast-qual */
name|scb
operator|->
name|ie_command_list
operator|=
name|MK_16
argument_list|(
name|MEM
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_CU_START
argument_list|,
name|cmd
argument_list|,
name|IE_STAT_COMPL
argument_list|)
operator|||
operator|!
operator|(
name|cmd
operator|->
name|com
operator|.
name|ie_cmd_status
operator|&
name|IE_STAT_OK
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ie%d: individual address setup command failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/*    * Now run the time-domain reflectometer.    */
name|run_tdr
argument_list|(
name|unit
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ptr
argument_list|)
expr_stmt|;
comment|/*    * Acknowledge any interrupts we have generated thus far.    */
name|ie_ack
argument_list|(
name|ie
operator|->
name|scb
argument_list|,
name|IE_ST_WHENCE
argument_list|,
name|unit
argument_list|,
name|ie
operator|->
name|ie_chan_attn
argument_list|)
expr_stmt|;
comment|/*    * Set up the RFA.    */
name|ptr
operator|=
name|setup_rfa
argument_list|(
name|ptr
argument_list|,
name|ie
argument_list|)
expr_stmt|;
comment|/*    * Finally, the transmit command and buffer are the last little bit of work.    */
name|ie
operator|->
name|xmit_cmds
index|[
literal|0
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
expr|*
name|ie
operator|->
name|xmit_cmds
index|[
literal|0
index|]
expr_stmt|;
name|ptr
operator|=
name|Align
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ie
operator|->
name|xmit_buffs
index|[
literal|0
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
expr|*
name|ie
operator|->
name|xmit_buffs
index|[
literal|0
index|]
expr_stmt|;
name|ptr
operator|=
name|Align
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* Second transmit command */
name|ie
operator|->
name|xmit_cmds
index|[
literal|1
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
expr|*
name|ie
operator|->
name|xmit_cmds
index|[
literal|1
index|]
expr_stmt|;
name|ptr
operator|=
name|Align
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ie
operator|->
name|xmit_buffs
index|[
literal|1
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
expr|*
name|ie
operator|->
name|xmit_buffs
index|[
literal|1
index|]
expr_stmt|;
name|ptr
operator|=
name|Align
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
comment|/* Both transmit buffers */
name|ie
operator|->
name|xmit_cbuffs
index|[
literal|0
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|IE_BUF_LEN
expr_stmt|;
name|ptr
operator|=
name|Align
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ie
operator|->
name|xmit_cbuffs
index|[
literal|1
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|ptr
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ie
operator|->
name|xmit_cmds
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
expr|*
name|ie
operator|->
name|xmit_cmds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* ignore */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ie
operator|->
name|xmit_buffs
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
expr|*
name|ie
operator|->
name|xmit_buffs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* cast-qual */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ie
operator|->
name|xmit_cmds
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
expr|*
name|ie
operator|->
name|xmit_cmds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* warnings */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ie
operator|->
name|xmit_buffs
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
expr|*
name|ie
operator|->
name|xmit_buffs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* here */
comment|/*    * This must be coordinated with iestart() and ietint().    */
name|ie
operator|->
name|xmit_cmds
index|[
literal|0
index|]
operator|->
name|ie_xmit_status
operator|=
name|IE_STAT_COMPL
expr_stmt|;
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
comment|/* tell higher levels that we are here */
name|start_receiver
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ie_stop
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|command_and_wait
argument_list|(
name|unit
argument_list|,
name|IE_RU_DISABLE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ieioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|command
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ie_softc
modifier|*
name|ie
init|=
operator|&
name|ie_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|ieinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|NS
comment|/* This magic copied from if_is.c; I don't use XNS, so I have no        * way of telling if this actually works or not.        */
case|case
name|AF_NS
case|:
block|{
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
block|{
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|ie
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|ie
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
name|ie
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
expr_stmt|;
block|}
name|ieinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* NS */
default|default:
name|ieinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/*      * Note that this device doesn't have an "all multicast" mode, so we      * must turn on promiscuous mode and do the filtering manually.      */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ie_stop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|ie_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|promisc
operator|=
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
expr_stmt|;
name|ieinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ie_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|promisc
operator|^
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
operator|)
condition|)
block|{
name|ie_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|promisc
operator|=
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
expr_stmt|;
name|ieinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|MULTICAST
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
comment|/*      * Update multicast listeners      */
name|error
operator|=
operator|(
operator|(
name|command
operator|==
name|SIOCADDMULTI
operator|)
condition|?
name|ether_addmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|ie
operator|->
name|arpcom
argument_list|)
else|:
name|ether_delmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|ie
operator|->
name|arpcom
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
comment|/* reset multicast filtering */
name|ie_mc_reset
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* MULTICAST */
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MULTICAST
end_ifdef

begin_function
specifier|static
name|void
name|ie_mc_reset
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ie_softc
modifier|*
name|ie
init|=
operator|&
name|ie_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ether_multi
modifier|*
name|enm
decl_stmt|;
name|struct
name|ether_multistep
name|step
decl_stmt|;
comment|/*    * Step through the list of addresses.    */
name|ie
operator|->
name|mcast_count
operator|=
literal|0
expr_stmt|;
name|ETHER_FIRST_MULTI
argument_list|(
name|step
argument_list|,
operator|&
name|ie
operator|->
name|arpcom
argument_list|,
name|enm
argument_list|)
expr_stmt|;
while|while
condition|(
name|enm
condition|)
block|{
if|if
condition|(
name|ie
operator|->
name|mcast_count
operator|>=
name|MAXMCAST
operator|||
name|bcmp
argument_list|(
name|enm
operator|->
name|enm_addrlo
argument_list|,
name|enm
operator|->
name|enm_addrhi
argument_list|,
literal|6
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
name|ieioctl
argument_list|(
operator|&
name|ie
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|setflag
goto|;
block|}
name|bcopy
argument_list|(
name|enm
operator|->
name|enm_addrlo
argument_list|,
operator|&
operator|(
name|ie
operator|->
name|mcast_addrs
index|[
name|ie
operator|->
name|mcast_count
index|]
operator|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|ie
operator|->
name|mcast_count
operator|++
expr_stmt|;
name|ETHER_NEXT_MULTI
argument_list|(
name|step
argument_list|,
name|enm
argument_list|)
expr_stmt|;
block|}
name|setflag
label|:
name|ie
operator|->
name|want_mcsetup
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|print_rbd
parameter_list|(
specifier|volatile
name|struct
name|ie_recv_buf_desc
modifier|*
name|rbd
parameter_list|)
block|{
name|printf
argument_list|(
literal|"RBD at %08lx:\n"
literal|"actual %04x, next %04x, buffer %08x\n"
literal|"length %04x, mbz %04x\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|rbd
argument_list|,
name|rbd
operator|->
name|ie_rbd_actual
argument_list|,
name|rbd
operator|->
name|ie_rbd_next
argument_list|,
name|rbd
operator|->
name|ie_rbd_buffer
argument_list|,
name|rbd
operator|->
name|ie_rbd_length
argument_list|,
name|rbd
operator|->
name|mbz
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NIE> 0 */
end_comment

end_unit

