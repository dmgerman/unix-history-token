begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Nicolas Souchu, Marc Bouget  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: pcf.c,v 1.7 1999/05/02 21:51:17 peter Exp $  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/iicbus/iiconf.h>
end_include

begin_include
include|#
directive|include
file|"iicbus_if.h"
end_include

begin_define
define|#
directive|define
name|TIMEOUT
value|9999
end_define

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/* Status bits of S1 register (read only) */
end_comment

begin_define
define|#
directive|define
name|nBB
value|0x01
end_define

begin_comment
comment|/* busy when low set/reset by STOP/START*/
end_comment

begin_define
define|#
directive|define
name|LAB
value|0x02
end_define

begin_comment
comment|/* lost arbitration bit in multi-master mode */
end_comment

begin_define
define|#
directive|define
name|AAS
value|0x04
end_define

begin_comment
comment|/* addressed as slave */
end_comment

begin_define
define|#
directive|define
name|LRB
value|0x08
end_define

begin_comment
comment|/* last received byte when not AAS */
end_comment

begin_define
define|#
directive|define
name|AD0
value|0x08
end_define

begin_comment
comment|/* general call received when AAS */
end_comment

begin_define
define|#
directive|define
name|BER
value|0x10
end_define

begin_comment
comment|/* bus error, misplaced START or STOP */
end_comment

begin_define
define|#
directive|define
name|STS
value|0x20
end_define

begin_comment
comment|/* STOP detected in slave receiver mode */
end_comment

begin_define
define|#
directive|define
name|PIN
value|0x80
end_define

begin_comment
comment|/* pending interrupt not (r/w) */
end_comment

begin_comment
comment|/* Control bits of S1 register (write only) */
end_comment

begin_define
define|#
directive|define
name|ACK
value|0x01
end_define

begin_define
define|#
directive|define
name|STO
value|0x02
end_define

begin_define
define|#
directive|define
name|STA
value|0x04
end_define

begin_define
define|#
directive|define
name|ENI
value|0x08
end_define

begin_define
define|#
directive|define
name|ES2
value|0x10
end_define

begin_define
define|#
directive|define
name|ES1
value|0x20
end_define

begin_define
define|#
directive|define
name|ES0
value|0x40
end_define

begin_define
define|#
directive|define
name|BUFSIZE
value|2048
end_define

begin_define
define|#
directive|define
name|SLAVE_TRANSMITTER
value|0x1
end_define

begin_define
define|#
directive|define
name|SLAVE_RECEIVER
value|0x2
end_define

begin_define
define|#
directive|define
name|PCF_DEFAULT_ADDR
value|0xaa
end_define

begin_struct
struct|struct
name|pcf_softc
block|{
name|int
name|pcf_base
decl_stmt|;
comment|/* isa port */
name|u_char
name|pcf_addr
decl_stmt|;
comment|/* interface I2C address */
name|int
name|pcf_slave_mode
decl_stmt|;
comment|/* receiver or transmitter */
name|int
name|pcf_started
decl_stmt|;
comment|/* 1 if start condition sent */
name|device_t
name|iicbus
decl_stmt|;
comment|/* the corresponding iicbus */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pcf_isa_softc
block|{
name|int
name|pcf_unit
decl_stmt|;
comment|/* unit of the isa device */
name|int
name|pcf_base
decl_stmt|;
comment|/* isa port */
name|int
name|pcf_irq
decl_stmt|;
comment|/* isa irq or null if polled */
name|unsigned
name|int
name|pcf_flags
decl_stmt|;
comment|/* boot flags */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAXPCF
value|2
end_define

begin_decl_stmt
specifier|static
name|struct
name|pcf_isa_softc
modifier|*
name|pcfdata
index|[
name|MAXPCF
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|npcf
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|pcfprobe_isa
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcfattach_isa
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|pcfdriver
init|=
block|{
name|pcfprobe_isa
block|,
name|pcfattach_isa
block|,
literal|"pcf"
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|pcf_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcf_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcf_print_child
parameter_list|(
name|device_t
parameter_list|,
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcf_repeated_start
parameter_list|(
name|device_t
parameter_list|,
name|u_char
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcf_start
parameter_list|(
name|device_t
parameter_list|,
name|u_char
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcf_stop
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcf_write
parameter_list|(
name|device_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcf_read
parameter_list|(
name|device_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ointhand2_t
name|pcfintr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|pcf_rst_card
parameter_list|(
name|device_t
parameter_list|,
name|u_char
parameter_list|,
name|u_char
parameter_list|,
name|u_char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|pcf_methods
index|[]
init|=
block|{
comment|/* device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|pcf_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|pcf_attach
argument_list|)
block|,
comment|/* bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|pcf_print_child
argument_list|)
block|,
comment|/* iicbus interface */
name|DEVMETHOD
argument_list|(
name|iicbus_callback
argument_list|,
name|iicbus_null_callback
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|iicbus_repeated_start
argument_list|,
name|pcf_repeated_start
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|iicbus_start
argument_list|,
name|pcf_start
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|iicbus_stop
argument_list|,
name|pcf_stop
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|iicbus_write
argument_list|,
name|pcf_write
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|iicbus_read
argument_list|,
name|pcf_read
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|iicbus_reset
argument_list|,
name|pcf_rst_card
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|pcf_driver
init|=
block|{
literal|"pcf"
block|,
name|pcf_methods
block|,
name|DRIVER_TYPE_MISC
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcf_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|pcf_devclass
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEVTOSOFTC
parameter_list|(
name|dev
parameter_list|)
value|((struct pcf_softc *)device_get_softc(dev))
end_define

begin_function
specifier|static
name|int
name|pcfprobe_isa
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|device_t
name|pcfdev
decl_stmt|;
name|struct
name|pcf_isa_softc
modifier|*
name|pcf
decl_stmt|;
if|if
condition|(
name|npcf
operator|>=
name|MAXPCF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|pcf
operator|=
operator|(
expr|struct
name|pcf_isa_softc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pcf_isa_softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pcf
operator|->
name|pcf_base
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
comment|/* XXX should be ivars */
name|pcf
operator|->
name|pcf_unit
operator|=
name|dvp
operator|->
name|id_unit
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dvp
operator|->
name|id_flags
operator|&
name|IIC_POLLED
operator|)
condition|)
name|pcf
operator|->
name|pcf_irq
operator|=
operator|(
name|dvp
operator|->
name|id_irq
operator|)
expr_stmt|;
name|pcfdata
index|[
name|npcf
operator|++
index|]
operator|=
name|pcf
expr_stmt|;
comment|/* XXX add the pcf device to the root_bus until isa bus exists */
name|pcfdev
operator|=
name|device_add_child
argument_list|(
name|root_bus
argument_list|,
literal|"pcf"
argument_list|,
name|pcf
operator|->
name|pcf_unit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pcfdev
condition|)
goto|goto
name|error
goto|;
return|return
operator|(
literal|1
operator|)
return|;
name|error
label|:
name|free
argument_list|(
name|pcf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcfattach_isa
parameter_list|(
name|struct
name|isa_device
modifier|*
name|isdp
parameter_list|)
block|{
name|isdp
operator|->
name|id_ointr
operator|=
name|pcfintr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* ok */
block|}
end_function

begin_function
specifier|static
name|int
name|pcf_probe
parameter_list|(
name|device_t
name|pcfdev
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|pcf
init|=
operator|(
expr|struct
name|pcf_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|pcfdev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
name|device_get_unit
argument_list|(
name|pcfdev
argument_list|)
decl_stmt|;
comment|/* retrieve base address from isa initialization 	 * 	 * XXX should use ivars with isabus 	 */
name|pcf
operator|->
name|pcf_base
operator|=
name|pcfdata
index|[
name|unit
index|]
operator|->
name|pcf_base
expr_stmt|;
comment|/* reset the chip */
name|pcf_rst_card
argument_list|(
name|pcfdev
argument_list|,
name|IIC_FASTEST
argument_list|,
name|PCF_DEFAULT_ADDR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX try do detect chipset */
name|device_set_desc
argument_list|(
name|pcfdev
argument_list|,
literal|"PCF8584 I2C bus controller"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcf_attach
parameter_list|(
name|device_t
name|pcfdev
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|pcf
init|=
operator|(
expr|struct
name|pcf_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|pcfdev
argument_list|)
decl_stmt|;
name|pcf
operator|->
name|iicbus
operator|=
name|iicbus_alloc_bus
argument_list|(
name|pcfdev
argument_list|)
expr_stmt|;
comment|/* probe and attach the iicbus */
name|device_probe_and_attach
argument_list|(
name|pcf
operator|->
name|iicbus
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcf_print_child
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|pcf
init|=
operator|(
expr|struct
name|pcf_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|bus
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|" on %s%d addr 0x%x"
argument_list|,
name|device_get_name
argument_list|(
name|bus
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|bus
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|pcf
operator|->
name|pcf_addr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * PCF8584 datasheet : when operate at 8 MHz or more, a minimun time of  * 6 clocks cycles must be left between two consecutives access  */
end_comment

begin_define
define|#
directive|define
name|pcf_nops
parameter_list|()
value|DELAY(10)
end_define

begin_define
define|#
directive|define
name|dummy_read
parameter_list|(
name|pcf
parameter_list|)
value|PCF_GET_S0(pcf)
end_define

begin_define
define|#
directive|define
name|dummy_write
parameter_list|(
name|pcf
parameter_list|)
value|PCF_SET_S0(pcf, 0)
end_define

begin_comment
comment|/*  * Specific register access to PCF8584  */
end_comment

begin_function
specifier|static
name|void
name|PCF_SET_S0
parameter_list|(
name|struct
name|pcf_softc
modifier|*
name|pcf
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|outb
argument_list|(
name|pcf
operator|->
name|pcf_base
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|pcf_nops
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|PCF_SET_S1
parameter_list|(
name|struct
name|pcf_softc
modifier|*
name|pcf
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|outb
argument_list|(
name|pcf
operator|->
name|pcf_base
operator|+
literal|1
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|pcf_nops
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
name|PCF_GET_S0
parameter_list|(
name|struct
name|pcf_softc
modifier|*
name|pcf
parameter_list|)
block|{
name|char
name|data
decl_stmt|;
name|data
operator|=
name|inb
argument_list|(
name|pcf
operator|->
name|pcf_base
argument_list|)
expr_stmt|;
name|pcf_nops
argument_list|()
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
name|PCF_GET_S1
parameter_list|(
name|struct
name|pcf_softc
modifier|*
name|pcf
parameter_list|)
block|{
name|char
name|data
decl_stmt|;
name|data
operator|=
name|inb
argument_list|(
name|pcf
operator|->
name|pcf_base
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pcf_nops
argument_list|()
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Polling mode for master operations wait for a new  * byte incomming or outgoing  */
end_comment

begin_function
specifier|static
name|int
name|pcf_wait_byte
parameter_list|(
name|struct
name|pcf_softc
modifier|*
name|pcf
parameter_list|)
block|{
name|int
name|counter
init|=
name|TIMEOUT
decl_stmt|;
while|while
condition|(
name|counter
operator|--
condition|)
block|{
if|if
condition|(
operator|(
name|PCF_GET_S1
argument_list|(
name|pcf
argument_list|)
operator|&
name|PIN
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|IIC_ETIMEOUT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcf_stop
parameter_list|(
name|device_t
name|pcfdev
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|pcf
init|=
name|DEVTOSOFTC
argument_list|(
name|pcfdev
argument_list|)
decl_stmt|;
comment|/* 	 * Send STOP condition iff the START condition was previously sent. 	 * STOP is sent only once even if a iicbus_stop() is called after 	 * an iicbus_read()... see pcf_read(): the pcf needs to send the stop 	 * before the last char is read. 	 */
if|if
condition|(
name|pcf
operator|->
name|pcf_started
condition|)
block|{
comment|/* set stop condition and enable IT */
name|PCF_SET_S1
argument_list|(
name|pcf
argument_list|,
name|PIN
operator||
name|ES0
operator||
name|ENI
operator||
name|STO
operator||
name|ACK
argument_list|)
expr_stmt|;
name|pcf
operator|->
name|pcf_started
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcf_noack
parameter_list|(
name|struct
name|pcf_softc
modifier|*
name|pcf
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|noack
decl_stmt|;
name|int
name|k
init|=
name|timeout
operator|/
literal|10
decl_stmt|;
do|do
block|{
name|noack
operator|=
name|PCF_GET_S1
argument_list|(
name|pcf
argument_list|)
operator|&
name|LRB
expr_stmt|;
if|if
condition|(
operator|!
name|noack
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX wait 10 us */
block|}
do|while
condition|(
name|k
operator|--
condition|)
do|;
return|return
operator|(
name|noack
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcf_repeated_start
parameter_list|(
name|device_t
name|pcfdev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|pcf
init|=
name|DEVTOSOFTC
argument_list|(
name|pcfdev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* repeated start */
name|PCF_SET_S1
argument_list|(
name|pcf
argument_list|,
name|ES0
operator||
name|STA
operator||
name|STO
operator||
name|ACK
argument_list|)
expr_stmt|;
comment|/* set slave address to PCF. Last bit (LSB) must be set correctly 	 * according to transfer direction */
name|PCF_SET_S0
argument_list|(
name|pcf
argument_list|,
name|slave
argument_list|)
expr_stmt|;
comment|/* wait for address sent, polling */
if|if
condition|(
operator|(
name|error
operator|=
name|pcf_wait_byte
argument_list|(
name|pcf
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* check for ack */
if|if
condition|(
name|pcf_noack
argument_list|(
name|pcf
argument_list|,
name|timeout
argument_list|)
condition|)
block|{
name|error
operator|=
name|IIC_ENOACK
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|pcf_stop
argument_list|(
name|pcfdev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcf_start
parameter_list|(
name|device_t
name|pcfdev
parameter_list|,
name|u_char
name|slave
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|pcf
init|=
name|DEVTOSOFTC
argument_list|(
name|pcfdev
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|PCF_GET_S1
argument_list|(
name|pcf
argument_list|)
operator|&
name|nBB
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|IIC_EBUSBSY
operator|)
return|;
comment|/* set slave address to PCF. Last bit (LSB) must be set correctly 	 * according to transfer direction */
name|PCF_SET_S0
argument_list|(
name|pcf
argument_list|,
name|slave
argument_list|)
expr_stmt|;
comment|/* START only */
name|PCF_SET_S1
argument_list|(
name|pcf
argument_list|,
name|PIN
operator||
name|ES0
operator||
name|STA
operator||
name|ACK
argument_list|)
expr_stmt|;
name|pcf
operator|->
name|pcf_started
operator|=
literal|1
expr_stmt|;
comment|/* wait for address sent, polling */
if|if
condition|(
operator|(
name|error
operator|=
name|pcf_wait_byte
argument_list|(
name|pcf
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* check for ACK */
if|if
condition|(
name|pcf_noack
argument_list|(
name|pcf
argument_list|,
name|timeout
argument_list|)
condition|)
block|{
name|error
operator|=
name|IIC_ENOACK
expr_stmt|;
goto|goto
name|error
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|pcf_stop
argument_list|(
name|pcfdev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcfintr
parameter_list|(
name|unit
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|pcf
init|=
operator|(
expr|struct
name|pcf_softc
operator|*
operator|)
name|devclass_get_softc
argument_list|(
name|pcf_devclass
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|char
name|data
decl_stmt|,
name|status
decl_stmt|,
name|addr
decl_stmt|;
name|char
name|error
init|=
literal|0
decl_stmt|;
name|status
operator|=
name|PCF_GET_S1
argument_list|(
name|pcf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|PIN
condition|)
block|{
name|printf
argument_list|(
literal|"pcf%d: spurious interrupt, status=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|status
operator|&
literal|0xff
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|status
operator|&
name|LAB
condition|)
name|printf
argument_list|(
literal|"pcf%d: bus arbitration lost!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|BER
condition|)
block|{
name|error
operator|=
name|IIC_EBUSERR
expr_stmt|;
name|iicbus_intr
argument_list|(
name|pcf
operator|->
name|iicbus
argument_list|,
name|INTR_ERROR
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
do|do
block|{
name|status
operator|=
name|PCF_GET_S1
argument_list|(
name|pcf
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcf
operator|->
name|pcf_slave_mode
condition|)
block|{
case|case
name|SLAVE_TRANSMITTER
case|:
if|if
condition|(
name|status
operator|&
name|LRB
condition|)
block|{
comment|/* ack interrupt line */
name|dummy_write
argument_list|(
name|pcf
argument_list|)
expr_stmt|;
comment|/* no ack, don't send anymore */
name|pcf
operator|->
name|pcf_slave_mode
operator|=
name|SLAVE_RECEIVER
expr_stmt|;
name|iicbus_intr
argument_list|(
name|pcf
operator|->
name|iicbus
argument_list|,
name|INTR_NOACK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* get data from upper code */
name|iicbus_intr
argument_list|(
name|pcf
operator|->
name|iicbus
argument_list|,
name|INTR_TRANSMIT
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
name|PCF_SET_S0
argument_list|(
name|pcf
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLAVE_RECEIVER
case|:
if|if
condition|(
name|status
operator|&
name|AAS
condition|)
block|{
name|addr
operator|=
name|PCF_GET_S0
argument_list|(
name|pcf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|AD0
condition|)
name|iicbus_intr
argument_list|(
name|pcf
operator|->
name|iicbus
argument_list|,
name|INTR_GENERAL
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
else|else
name|iicbus_intr
argument_list|(
name|pcf
operator|->
name|iicbus
argument_list|,
name|INTR_START
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|&
name|LSB
condition|)
block|{
name|pcf
operator|->
name|pcf_slave_mode
operator|=
name|SLAVE_TRANSMITTER
expr_stmt|;
comment|/* get the first char from upper code */
name|iicbus_intr
argument_list|(
name|pcf
operator|->
name|iicbus
argument_list|,
name|INTR_TRANSMIT
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
comment|/* send first data byte */
name|PCF_SET_S0
argument_list|(
name|pcf
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* stop condition received? */
if|if
condition|(
name|status
operator|&
name|STS
condition|)
block|{
comment|/* ack interrupt line */
name|dummy_read
argument_list|(
name|pcf
argument_list|)
expr_stmt|;
comment|/* emulate intr stop condition */
name|iicbus_intr
argument_list|(
name|pcf
operator|->
name|iicbus
argument_list|,
name|INTR_STOP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* get data, ack interrupt line */
name|data
operator|=
name|PCF_GET_S0
argument_list|(
name|pcf
argument_list|)
expr_stmt|;
comment|/* deliver the character */
name|iicbus_intr
argument_list|(
name|pcf
operator|->
name|iicbus
argument_list|,
name|INTR_RECEIVE
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown slave mode (%d)!"
argument_list|,
name|__FUNCTION__
argument_list|,
name|pcf
operator|->
name|pcf_slave_mode
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|PCF_GET_S1
argument_list|(
name|pcf
argument_list|)
operator|&
name|PIN
operator|)
operator|==
literal|0
condition|)
do|;
return|return;
name|error
label|:
comment|/* unknown event on bus...reset PCF */
name|PCF_SET_S1
argument_list|(
name|pcf
argument_list|,
name|PIN
operator||
name|ES0
operator||
name|ENI
operator||
name|ACK
argument_list|)
expr_stmt|;
name|pcf
operator|->
name|pcf_slave_mode
operator|=
name|SLAVE_RECEIVER
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|pcf_rst_card
parameter_list|(
name|device_t
name|pcfdev
parameter_list|,
name|u_char
name|speed
parameter_list|,
name|u_char
name|addr
parameter_list|,
name|u_char
modifier|*
name|oldaddr
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|pcf
init|=
name|DEVTOSOFTC
argument_list|(
name|pcfdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldaddr
condition|)
operator|*
name|oldaddr
operator|=
name|pcf
operator|->
name|pcf_addr
expr_stmt|;
comment|/* retrieve own address from bus level */
if|if
condition|(
operator|!
name|addr
condition|)
name|pcf
operator|->
name|pcf_addr
operator|=
name|PCF_DEFAULT_ADDR
expr_stmt|;
else|else
name|pcf
operator|->
name|pcf_addr
operator|=
name|addr
expr_stmt|;
name|PCF_SET_S1
argument_list|(
name|pcf
argument_list|,
name|PIN
argument_list|)
expr_stmt|;
comment|/* initialize S1 */
comment|/* own address S'O<>0 */
name|PCF_SET_S0
argument_list|(
name|pcf
argument_list|,
name|pcf
operator|->
name|pcf_addr
operator|>>
literal|1
argument_list|)
expr_stmt|;
comment|/* select clock register */
name|PCF_SET_S1
argument_list|(
name|pcf
argument_list|,
name|PIN
operator||
name|ES1
argument_list|)
expr_stmt|;
comment|/* select bus speed : 18=90kb, 19=45kb, 1A=11kb, 1B=1.5kb */
switch|switch
condition|(
name|speed
condition|)
block|{
case|case
name|IIC_SLOW
case|:
name|PCF_SET_S0
argument_list|(
name|pcf
argument_list|,
literal|0x1b
argument_list|)
expr_stmt|;
break|break;
case|case
name|IIC_FAST
case|:
name|PCF_SET_S0
argument_list|(
name|pcf
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
break|break;
case|case
name|IIC_UNKNOWN
case|:
case|case
name|IIC_FASTEST
case|:
default|default:
name|PCF_SET_S0
argument_list|(
name|pcf
argument_list|,
literal|0x18
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* set bus on, ack=yes, INT=yes */
name|PCF_SET_S1
argument_list|(
name|pcf
argument_list|,
name|PIN
operator||
name|ES0
operator||
name|ENI
operator||
name|ACK
argument_list|)
expr_stmt|;
name|pcf
operator|->
name|pcf_slave_mode
operator|=
name|SLAVE_RECEIVER
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcf_write
parameter_list|(
name|device_t
name|pcfdev
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|sent
parameter_list|,
name|int
name|timeout
comment|/* us */
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|pcf
init|=
name|DEVTOSOFTC
argument_list|(
name|pcfdev
argument_list|)
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|printf
argument_list|(
literal|"pcf%d:>> writing %d bytes\n"
argument_list|,
name|device_get_unit
argument_list|(
name|pcfdev
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bytes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|PCF_SET_S0
argument_list|(
name|pcf
argument_list|,
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
comment|/* wait for the byte to be send */
if|if
condition|(
operator|(
name|error
operator|=
name|pcf_wait_byte
argument_list|(
name|pcf
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* check if ack received */
if|if
condition|(
name|pcf_noack
argument_list|(
name|pcf
argument_list|,
name|timeout
argument_list|)
condition|)
block|{
name|error
operator|=
name|IIC_ENOACK
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|len
operator|--
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
name|error
label|:
operator|*
name|sent
operator|=
name|bytes
expr_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|printf
argument_list|(
literal|"pcf%d:>> %d bytes written (%d)\n"
argument_list|,
name|device_get_unit
argument_list|(
name|pcfdev
argument_list|)
argument_list|,
name|bytes
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcf_read
parameter_list|(
name|device_t
name|pcfdev
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|read
parameter_list|,
name|int
name|last
parameter_list|,
name|int
name|delay
comment|/* us */
parameter_list|)
block|{
name|struct
name|pcf_softc
modifier|*
name|pcf
init|=
name|DEVTOSOFTC
argument_list|(
name|pcfdev
argument_list|)
decl_stmt|;
name|int
name|bytes
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|printf
argument_list|(
literal|"pcf%d:<< reading %d bytes\n"
argument_list|,
name|device_get_unit
argument_list|(
name|pcfdev
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* trig the bus to get the first data byte in S0 */
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|last
condition|)
comment|/* just one byte to read */
name|PCF_SET_S1
argument_list|(
name|pcf
argument_list|,
name|ES0
argument_list|)
expr_stmt|;
comment|/* no ack */
name|dummy_read
argument_list|(
name|pcf
argument_list|)
expr_stmt|;
block|}
name|bytes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
comment|/* XXX delay needed here */
comment|/* wait for trigged byte */
if|if
condition|(
operator|(
name|error
operator|=
name|pcf_wait_byte
argument_list|(
name|pcf
argument_list|)
operator|)
condition|)
block|{
name|pcf_stop
argument_list|(
name|pcfdev
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
name|last
condition|)
comment|/* ok, last data byte already in S0, no I2C activity 			 * on next PCF_GET_S0() */
name|pcf_stop
argument_list|(
name|pcfdev
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
literal|2
operator|&&
name|last
condition|)
comment|/* next trigged byte with no ack */
name|PCF_SET_S1
argument_list|(
name|pcf
argument_list|,
name|ES0
argument_list|)
expr_stmt|;
comment|/* receive byte, trig next byte */
operator|*
name|buf
operator|++
operator|=
name|PCF_GET_S0
argument_list|(
name|pcf
argument_list|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|error
label|:
operator|*
name|read
operator|=
name|bytes
expr_stmt|;
ifdef|#
directive|ifdef
name|PCFDEBUG
name|printf
argument_list|(
literal|"pcf%d:<< %d bytes read (%d)\n"
argument_list|,
name|device_get_unit
argument_list|(
name|pcfdev
argument_list|)
argument_list|,
name|bytes
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pcf
argument_list|,
name|root
argument_list|,
name|pcf_driver
argument_list|,
name|pcf_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

