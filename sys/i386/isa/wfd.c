begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997,1998  Junichi Satoh<junichi@astec.co.jp>  *   All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer as  *    the first lines of this file unmodified.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY Junichi Satoh ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL Junichi Satoh BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *      $Id: wfd.c,v 1.2 1998/01/16 22:43:33 pst Exp $  */
end_comment

begin_comment
comment|/*  * ATAPI Floppy, LS-120 driver  */
end_comment

begin_include
include|#
directive|include
file|"wdc.h"
end_include

begin_include
include|#
directive|include
file|"wfd.h"
end_include

begin_include
include|#
directive|include
file|"opt_atapi.h"
end_include

begin_if
if|#
directive|if
name|NWFD
operator|>
literal|0
operator|&&
name|NWDC
operator|>
literal|0
operator|&&
name|defined
argument_list|(
name|ATAPI
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskslice.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdio.h>
end_include

begin_include
include|#
directive|include
file|<machine/ioctl_fd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<i386/isa/atapi.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/fdc.h>
end_include

begin_decl_stmt
specifier|static
name|d_open_t
name|wfdbopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|wfdbclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|wfdioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|wfdstrategy
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|87
end_define

begin_define
define|#
directive|define
name|BDEV_MAJOR
value|24
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|wfd_cdevsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bdevsw
name|wfd_bdevsw
init|=
block|{
name|wfdbopen
block|,
name|wfdbclose
block|,
name|wfdstrategy
block|,
name|wfdioctl
block|,
name|nodump
block|,
name|nopsize
block|,
literal|0
block|,
literal|"wfd"
block|,
operator|&
name|wfd_cdevsw
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ATAPI_STATIC
end_ifndef

begin_function_decl
specifier|static
endif|#
directive|endif
name|int
name|wfdattach
parameter_list|(
name|struct
name|atapi
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|atapi_params
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NUNIT
value|(NWDC*2)
end_define

begin_comment
comment|/* Max. number of devices */
end_comment

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|d
parameter_list|)
value|((minor(d)>> 3)& 3)
end_define

begin_comment
comment|/* Unit part of minor device number */
end_comment

begin_define
define|#
directive|define
name|F_BOPEN
value|0x0001
end_define

begin_comment
comment|/* The block device is opened */
end_comment

begin_define
define|#
directive|define
name|F_MEDIA_CHANGED
value|0x0002
end_define

begin_comment
comment|/* The media have changed since open */
end_comment

begin_define
define|#
directive|define
name|F_DEBUG
value|0x0004
end_define

begin_comment
comment|/* Print debug info */
end_comment

begin_comment
comment|/*  * LS-120 Capabilities and Mechanical Status Page  */
end_comment

begin_struct
struct|struct
name|cappage
block|{
comment|/* Mode data header */
name|u_short
name|data_length
decl_stmt|;
name|u_char
name|medium_type
decl_stmt|;
define|#
directive|define
name|MDT_UNKNOWN
value|0x00
define|#
directive|define
name|MDT_NO_DISC
value|0x70
define|#
directive|define
name|MDT_DOOR_OPEN
value|0x71
define|#
directive|define
name|MDT_FMT_ERROR
value|0x72
define|#
directive|define
name|MDT_2DD_UN
value|0x10
define|#
directive|define
name|MDT_2DD
value|0x11
define|#
directive|define
name|MDT_2HD_UN
value|0x20
define|#
directive|define
name|MDT_2HD_12_98
value|0x22
define|#
directive|define
name|MDT_2HD_12
value|0x23
define|#
directive|define
name|MDT_2HD_144
value|0x24
define|#
directive|define
name|MDT_LS120
value|0x31
name|unsigned
name|reserved0
range|:
literal|7
decl_stmt|;
name|unsigned
name|wp
range|:
literal|1
decl_stmt|;
comment|/* Write protect */
name|u_char
name|reserved1
index|[
literal|4
index|]
decl_stmt|;
comment|/* Capabilities page */
name|unsigned
name|page_code
range|:
literal|6
decl_stmt|;
comment|/* Page code - Should be 0x5 */
define|#
directive|define
name|CAP_PAGE
value|0x05
name|unsigned
name|reserved1_6
range|:
literal|1
decl_stmt|;
comment|/* Reserved */
name|unsigned
name|ps
range|:
literal|1
decl_stmt|;
comment|/* The device is capable of savi ng the page */
name|u_char
name|page_length
decl_stmt|;
comment|/* Page Length - Should be 0x1e */
name|u_short
name|transfer_rate
decl_stmt|;
comment|/* In kilobits per second */
name|u_char
name|heads
decl_stmt|,
name|sectors
decl_stmt|;
comment|/* Number of heads, Number of sectors per track */
name|u_short
name|sector_size
decl_stmt|;
comment|/* Byes per sector */
name|u_short
name|cyls
decl_stmt|;
comment|/* Number of cylinders */
name|u_char
name|reserved10
index|[
literal|10
index|]
decl_stmt|;
name|u_char
name|motor_delay
decl_stmt|;
comment|/* Motor off delay */
name|u_char
name|reserved21
index|[
literal|7
index|]
decl_stmt|;
name|u_short
name|rpm
decl_stmt|;
comment|/* Rotations per minute */
name|u_char
name|reserved30
index|[
literal|2
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* misuse a flag to identify format operation */
end_comment

begin_define
define|#
directive|define
name|B_FORMAT
value|B_XXX
end_define

begin_struct
struct|struct
name|wfd
block|{
name|struct
name|atapi
modifier|*
name|ata
decl_stmt|;
comment|/* Controller structure */
name|int
name|unit
decl_stmt|;
comment|/* IDE bus drive unit */
name|int
name|lun
decl_stmt|;
comment|/* Logical device unit */
name|int
name|flags
decl_stmt|;
comment|/* Device state flags */
name|int
name|refcnt
decl_stmt|;
comment|/* The number of raw opens */
name|int
name|maxblks
decl_stmt|;
comment|/* transfer size limit */
name|struct
name|buf_queue_head
name|buf_queue
decl_stmt|;
comment|/* Queue of i/o requests */
name|struct
name|atapi_params
modifier|*
name|param
decl_stmt|;
comment|/* Drive parameters table */
name|struct
name|cappage
name|cap
decl_stmt|;
comment|/* Capabilities page info */
name|char
name|description
index|[
literal|80
index|]
decl_stmt|;
comment|/* Device description */
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|cdevs
decl_stmt|;
name|void
modifier|*
name|bdevs
decl_stmt|;
endif|#
directive|endif
name|struct
name|diskslices
modifier|*
name|dk_slices
decl_stmt|;
comment|/* virtual drives */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|wfd
modifier|*
name|wfdtab
index|[
name|NUNIT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Drive info by unit number */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wfdnlun
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of configured drives */
end_comment

begin_function_decl
specifier|static
name|void
name|wfd_start
parameter_list|(
name|struct
name|wfd
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wfd_done
parameter_list|(
name|struct
name|wfd
modifier|*
name|t
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|resid
parameter_list|,
name|struct
name|atapires
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wfd_error
parameter_list|(
name|struct
name|wfd
modifier|*
name|t
parameter_list|,
name|struct
name|atapires
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wfd_request_wait
parameter_list|(
name|struct
name|wfd
modifier|*
name|t
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|u_char
name|a1
parameter_list|,
name|u_char
name|a2
parameter_list|,
name|u_char
name|a3
parameter_list|,
name|u_char
name|a4
parameter_list|,
name|u_char
name|a5
parameter_list|,
name|u_char
name|a6
parameter_list|,
name|u_char
name|a7
parameter_list|,
name|u_char
name|a8
parameter_list|,
name|u_char
name|a9
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wfd_describe
parameter_list|(
name|struct
name|wfd
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wfd_eject
parameter_list|(
name|struct
name|wfd
modifier|*
name|t
parameter_list|,
name|int
name|closeit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wfdstrategy1
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Dump the array in hexadecimal format for debugging purposes.  */
end_comment

begin_function
specifier|static
name|void
name|wfd_dump
parameter_list|(
name|int
name|lun
parameter_list|,
name|char
modifier|*
name|label
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_char
modifier|*
name|p
init|=
name|data
decl_stmt|;
name|printf
argument_list|(
literal|"wfd%d: %s %x"
argument_list|,
name|lun
argument_list|,
name|label
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|len
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"-%x"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ATAPI_STATIC
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
name|int
name|wfdattach
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|int
name|unit
parameter_list|,
name|struct
name|atapi_params
modifier|*
name|ap
parameter_list|,
name|int
name|debug
parameter_list|)
block|{
name|struct
name|wfd
modifier|*
name|t
decl_stmt|;
name|struct
name|atapires
name|result
decl_stmt|;
name|int
name|lun
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|int
name|mynor
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wfdnlun
operator|>=
name|NUNIT
condition|)
block|{
name|printf
argument_list|(
literal|"wfd: too many units\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|atapi_request_immediate
condition|)
block|{
name|printf
argument_list|(
literal|"wfd: configuration error, ATAPI core code not present!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wfd: check `options ATAPI_STATIC' in your kernel config file!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|t
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wfd
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
condition|)
block|{
name|printf
argument_list|(
literal|"wfd: out of memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|wfdtab
index|[
name|wfdnlun
index|]
operator|=
name|t
expr_stmt|;
name|bzero
argument_list|(
name|t
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wfd
argument_list|)
argument_list|)
expr_stmt|;
name|bufq_init
argument_list|(
operator|&
name|t
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
name|t
operator|->
name|ata
operator|=
name|ata
expr_stmt|;
name|t
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|lun
operator|=
name|t
operator|->
name|lun
operator|=
name|wfdnlun
operator|++
expr_stmt|;
name|t
operator|->
name|param
operator|=
name|ap
expr_stmt|;
name|t
operator|->
name|flags
operator|=
name|F_MEDIA_CHANGED
expr_stmt|;
name|t
operator|->
name|refcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
name|t
operator|->
name|flags
operator||=
name|F_DEBUG
expr_stmt|;
comment|/* Print params. */
name|wfd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"info"
argument_list|,
name|ap
argument_list|,
sizeof|sizeof
expr|*
name|ap
argument_list|)
expr_stmt|;
block|}
comment|/* Get drive capabilities. */
comment|/* Do it twice to avoid the stale media changed state. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|atapi_request_immediate
argument_list|(
name|ata
argument_list|,
name|unit
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|CAP_PAGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|cap
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|.
name|code
operator|==
name|RES_ERR
operator|&&
operator|(
name|result
operator|.
name|error
operator|&
name|AER_SKEY
operator|)
operator|==
name|AER_SK_UNIT_ATTENTION
condition|)
name|result
operator|=
name|atapi_request_immediate
argument_list|(
name|ata
argument_list|,
name|unit
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|CAP_PAGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|cap
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some drives have shorter capabilities page. */
if|if
condition|(
name|result
operator|.
name|code
operator|==
name|RES_UNDERRUN
condition|)
name|result
operator|.
name|code
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|code
operator|==
literal|0
condition|)
block|{
name|wfd_describe
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|wfd_dump
argument_list|(
name|t
operator|->
name|lun
argument_list|,
literal|"cap"
argument_list|,
operator|&
name|t
operator|->
name|cap
argument_list|,
sizeof|sizeof
name|t
operator|->
name|cap
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
comment|/* 	 * The IOMEGA ZIP 100, at firmware 21.* and 23.* at least 	 * is known to lock up if transfers> 64 blocks are 	 * requested. 	 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ap
operator|->
name|model
argument_list|,
literal|"IOMEGA  ZIP 100       ATAPI"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"wfd%d: buggy Zip drive, 64-block transfer limit set\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|t
operator|->
name|maxblks
operator|=
literal|64
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|maxblks
operator|=
literal|0
expr_stmt|;
comment|/* no limit */
block|}
ifdef|#
directive|ifdef
name|DEVFS
name|mynor
operator|=
name|dkmakeminor
argument_list|(
name|unit
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|t
operator|->
name|bdevs
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|wfd_bdevsw
argument_list|,
name|mynor
argument_list|,
name|DV_BLK
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"wfd%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|t
operator|->
name|cdevs
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|wfd_cdevsw
argument_list|,
name|mynor
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"rwfd%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEVFS */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|wfd_describe
parameter_list|(
name|struct
name|wfd
modifier|*
name|t
parameter_list|)
block|{
name|int
name|no_print
init|=
literal|0
decl_stmt|;
name|t
operator|->
name|cap
operator|.
name|cyls
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|cap
operator|.
name|cyls
argument_list|)
expr_stmt|;
name|t
operator|->
name|cap
operator|.
name|sector_size
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|cap
operator|.
name|sector_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wfd%d: "
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|t
operator|->
name|cap
operator|.
name|medium_type
condition|)
block|{
case|case
name|MDT_UNKNOWN
case|:
name|printf
argument_list|(
literal|"medium type unknown (no disk)"
argument_list|)
expr_stmt|;
name|no_print
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MDT_2DD_UN
case|:
name|printf
argument_list|(
literal|"2DD(capacity unknown) floppy disk loaded"
argument_list|)
expr_stmt|;
name|no_print
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MDT_2DD
case|:
name|printf
argument_list|(
literal|"720KB floppy disk loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_2HD_UN
case|:
name|printf
argument_list|(
literal|"2HD(capacity unknown) floppy disk loaded"
argument_list|)
expr_stmt|;
name|no_print
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MDT_2HD_12_98
case|:
name|printf
argument_list|(
literal|"1.25MB(PC-9801 format) floppy disk loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_2HD_12
case|:
name|printf
argument_list|(
literal|"1.2MB floppy disk loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_2HD_144
case|:
name|printf
argument_list|(
literal|"1.44MB floppy disk loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_LS120
case|:
name|printf
argument_list|(
literal|"120MB floppy disk loaded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MDT_NO_DISC
case|:
name|printf
argument_list|(
literal|"no disc inside"
argument_list|)
expr_stmt|;
name|no_print
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MDT_DOOR_OPEN
case|:
name|printf
argument_list|(
literal|"door open"
argument_list|)
expr_stmt|;
name|no_print
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MDT_FMT_ERROR
case|:
name|printf
argument_list|(
literal|"medium format error"
argument_list|)
expr_stmt|;
name|no_print
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"medium type=0x%x"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|medium_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|cap
operator|.
name|wp
condition|)
name|printf
argument_list|(
literal|", write protected"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_print
condition|)
block|{
name|printf
argument_list|(
literal|"wfd%d: "
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%lu cyls"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|cyls
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %lu heads, %lu S/T"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|heads
argument_list|,
name|t
operator|->
name|cap
operator|.
name|sectors
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %lu B/S"
argument_list|,
name|t
operator|->
name|cap
operator|.
name|sector_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|wfdbopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|lun
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|wfd
modifier|*
name|t
decl_stmt|;
name|struct
name|atapires
name|result
decl_stmt|;
name|int
name|errcode
init|=
literal|0
decl_stmt|;
name|struct
name|disklabel
name|label
decl_stmt|;
comment|/* Check that the device number is legal 	 * and the ATAPI driver is loaded. */
if|if
condition|(
name|lun
operator|>=
name|wfdnlun
operator|||
operator|!
name|atapi_request_immediate
condition|)
block|{
name|printf
argument_list|(
literal|"ENXIO lun=%d, wfdnlun=%d, im=%d\n"
argument_list|,
name|lun
argument_list|,
name|wfdnlun
argument_list|,
name|atapi_request_immediate
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|t
operator|=
name|wfdtab
index|[
name|lun
index|]
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|F_MEDIA_CHANGED
expr_stmt|;
comment|/* Lock the media. */
name|wfd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Sense the media type */
name|result
operator|=
name|atapi_request_wait
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|ATAPI_MODE_SENSE
argument_list|,
literal|0
argument_list|,
name|CAP_PAGE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
operator|>>
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|t
operator|->
name|cap
argument_list|,
sizeof|sizeof
argument_list|(
name|t
operator|->
name|cap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|code
condition|)
name|printf
argument_list|(
literal|"wfd%d: Sense the media type is failed.\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
else|else
block|{
name|t
operator|->
name|cap
operator|.
name|cyls
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|cap
operator|.
name|cyls
argument_list|)
expr_stmt|;
name|t
operator|->
name|cap
operator|.
name|sector_size
operator|=
name|ntohs
argument_list|(
name|t
operator|->
name|cap
operator|.
name|sector_size
argument_list|)
expr_stmt|;
block|}
comment|/* Build label for whole disk. */
name|bzero
argument_list|(
operator|&
name|label
argument_list|,
sizeof|sizeof
name|label
argument_list|)
expr_stmt|;
name|label
operator|.
name|d_secsize
operator|=
name|t
operator|->
name|cap
operator|.
name|sector_size
expr_stmt|;
name|label
operator|.
name|d_nsectors
operator|=
name|t
operator|->
name|cap
operator|.
name|sectors
expr_stmt|;
name|label
operator|.
name|d_ntracks
operator|=
name|t
operator|->
name|cap
operator|.
name|heads
expr_stmt|;
name|label
operator|.
name|d_ncylinders
operator|=
name|t
operator|->
name|cap
operator|.
name|cyls
expr_stmt|;
name|label
operator|.
name|d_secpercyl
operator|=
name|t
operator|->
name|cap
operator|.
name|heads
operator|*
name|t
operator|->
name|cap
operator|.
name|sectors
expr_stmt|;
name|label
operator|.
name|d_rpm
operator|=
literal|720
expr_stmt|;
name|label
operator|.
name|d_secperunit
operator|=
name|label
operator|.
name|d_secpercyl
operator|*
name|t
operator|->
name|cap
operator|.
name|cyls
expr_stmt|;
comment|/* Initialize slice tables. */
name|errcode
operator|=
name|dsopen
argument_list|(
literal|"wfd"
argument_list|,
name|dev
argument_list|,
name|fmt
argument_list|,
operator|&
name|t
operator|->
name|dk_slices
argument_list|,
operator|&
name|label
argument_list|,
name|wfdstrategy1
argument_list|,
operator|(
name|ds_setgeom_t
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|wfd_bdevsw
argument_list|,
operator|&
name|wfd_cdevsw
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
return|return
name|errcode
return|;
name|t
operator|->
name|flags
operator||=
name|F_BOPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close the device.  Only called if we are the LAST  * occurence of an open device.  */
end_comment

begin_function
name|int
name|wfdbclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|lun
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|wfd
modifier|*
name|t
init|=
name|wfdtab
index|[
name|lun
index|]
decl_stmt|;
name|dsclose
argument_list|(
name|dev
argument_list|,
name|fmt
argument_list|,
name|t
operator|->
name|dk_slices
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsisopen
argument_list|(
name|t
operator|->
name|dk_slices
argument_list|)
condition|)
block|{
comment|/* If we were the last open of the entire device, release it. */
if|if
condition|(
operator|!
name|t
operator|->
name|refcnt
condition|)
name|wfd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|F_BOPEN
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wfdstrategy1
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
comment|/* 	 * XXX - do something to make wdstrategy() but not this block while 	 * we're doing dsinit() and dsioctl(). 	 */
name|wfdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Actually translate the requested transfer into one the physical driver can  * understand. The transfer is described by a buf and will include only one  * physical transfer.  */
end_comment

begin_function
name|void
name|wfdstrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|lun
init|=
name|UNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|struct
name|wfd
modifier|*
name|t
init|=
name|wfdtab
index|[
name|lun
index|]
decl_stmt|;
name|int
name|x
decl_stmt|;
comment|/* If it's a null transfer, return immediatly. */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Process transfer request. */
name|bp
operator|->
name|b_pblkno
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
comment|/* 	 * Do bounds checking, adjust transfer, and set b_pblkno.          */
if|if
condition|(
name|dscheck
argument_list|(
name|bp
argument_list|,
name|t
operator|->
name|dk_slices
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|b_blkno
operator|=
name|bp
operator|->
name|b_pblkno
expr_stmt|;
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* Place it in the queue of disk activities for this disk. */
name|bufqdisksort
argument_list|(
operator|&
name|t
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* Tell the device to get going on the transfer if it's 	 * not doing anything, otherwise just wait for completion. */
name|wfd_start
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look to see if there is a buf waiting for the device  * and that the device is not already busy. If both are true,  * It dequeues the buf and creates an ATAPI command to perform the  * transfer in the buf.  * The bufs are queued by the strategy routine (wfdstrategy).  * Must be called at the correct (splbio) level.  */
end_comment

begin_function
specifier|static
name|void
name|wfd_start
parameter_list|(
name|struct
name|wfd
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|bufq_first
argument_list|(
operator|&
name|t
operator|->
name|buf_queue
argument_list|)
decl_stmt|;
name|u_long
name|blkno
decl_stmt|,
name|nblk
decl_stmt|;
name|u_char
name|op_code
decl_stmt|;
name|long
name|count
decl_stmt|;
name|int
name|pxcount
decl_stmt|,
name|pxnblk
decl_stmt|;
name|u_char
modifier|*
name|pxdest
decl_stmt|;
comment|/* See if there is a buf to do and we are not already doing one. */
if|if
condition|(
operator|!
name|bp
condition|)
return|return;
comment|/* Unqueue the request. */
name|bufq_remove
argument_list|(
operator|&
name|t
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* We have a buf, now we should make a command 	 * First, translate the block to absolute and put it in terms of the 	 * logical blocksize of the device. 	 * What if something asks for 512 bytes not on a 2k boundary? */
name|blkno
operator|=
name|bp
operator|->
name|b_blkno
operator|/
operator|(
name|t
operator|->
name|cap
operator|.
name|sector_size
operator|/
literal|512
operator|)
expr_stmt|;
name|nblk
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
operator|(
name|t
operator|->
name|cap
operator|.
name|sector_size
operator|-
literal|1
operator|)
operator|)
operator|/
name|t
operator|->
name|cap
operator|.
name|sector_size
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|maxblks
operator|==
literal|0
operator|)
operator|||
operator|(
name|nblk
operator|<=
name|t
operator|->
name|maxblks
operator|)
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|op_code
operator|=
name|ATAPI_READ_BIG
expr_stmt|;
name|count
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
else|else
block|{
name|op_code
operator|=
name|ATAPI_WRITE_BIG
expr_stmt|;
name|count
operator|=
operator|-
name|bp
operator|->
name|b_bcount
expr_stmt|;
block|}
comment|/* only one transfer */
operator|(
name|int
operator|)
name|bp
operator|->
name|b_driver1
operator|=
literal|0
expr_stmt|;
operator|(
name|int
operator|)
name|bp
operator|->
name|b_driver2
operator|=
literal|0
expr_stmt|;
name|atapi_request_callback
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|op_code
argument_list|,
literal|0
argument_list|,
name|blkno
operator|>>
literal|24
argument_list|,
name|blkno
operator|>>
literal|16
argument_list|,
name|blkno
operator|>>
literal|8
argument_list|,
name|blkno
argument_list|,
literal|0
argument_list|,
name|nblk
operator|>>
literal|8
argument_list|,
name|nblk
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|count
argument_list|,
operator|(
name|void
operator|*
operator|)
name|wfd_done
argument_list|,
name|t
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We can't handle this request in a single 		 * read/write operation.  Instead, queue a set of 		 * transfers, and record the number of transfers 		 * and the running residual in the b_driver 		 * fields of the bp. 		 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
block|{
name|op_code
operator|=
name|ATAPI_READ_BIG
expr_stmt|;
block|}
else|else
block|{
name|op_code
operator|=
name|ATAPI_WRITE_BIG
expr_stmt|;
block|}
comment|/* calculate number of transfers */
operator|(
name|int
operator|)
name|bp
operator|->
name|b_driver1
operator|=
operator|(
name|nblk
operator|-
literal|1
operator|)
operator|/
name|t
operator|->
name|maxblks
expr_stmt|;
operator|(
name|int
operator|)
name|bp
operator|->
name|b_driver2
operator|=
literal|0
expr_stmt|;
name|pxdest
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|pxcount
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
comment|/* construct partial transfer requests */
while|while
condition|(
name|nblk
operator|>
literal|0
condition|)
block|{
name|pxnblk
operator|=
name|min
argument_list|(
name|nblk
argument_list|,
name|t
operator|->
name|maxblks
argument_list|)
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|pxcount
argument_list|,
name|t
operator|->
name|maxblks
operator|*
name|t
operator|->
name|cap
operator|.
name|sector_size
argument_list|)
expr_stmt|;
name|atapi_request_callback
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|op_code
argument_list|,
literal|0
argument_list|,
name|blkno
operator|>>
literal|24
argument_list|,
name|blkno
operator|>>
literal|16
argument_list|,
name|blkno
operator|>>
literal|8
argument_list|,
name|blkno
argument_list|,
literal|0
argument_list|,
name|pxnblk
operator|>>
literal|8
argument_list|,
name|pxnblk
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pxdest
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|count
else|:
operator|-
name|count
argument_list|,
operator|(
name|void
operator|*
operator|)
name|wfd_done
argument_list|,
name|t
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|nblk
operator|-=
name|pxnblk
expr_stmt|;
name|pxcount
operator|-=
name|count
expr_stmt|;
name|pxdest
operator|+=
name|count
expr_stmt|;
name|blkno
operator|+=
name|pxnblk
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wfd_done
parameter_list|(
name|struct
name|wfd
modifier|*
name|t
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|resid
parameter_list|,
name|struct
name|atapires
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|.
name|code
condition|)
block|{
name|wfd_error
argument_list|(
name|t
argument_list|,
name|result
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
else|else
operator|(
name|int
operator|)
name|bp
operator|->
name|b_driver2
operator|+=
name|resid
expr_stmt|;
comment|/* 	 * We can't call biodone until all outstanding 	 * transfer fragments are handled.  If one hits 	 * an error, we will be returning an error, but 	 * only when all are complete. 	 */
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|bp
operator|->
name|b_driver1
operator|)
operator|--
operator|<=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
operator|(
name|int
operator|)
name|bp
operator|->
name|b_driver2
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|wfd_start
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wfd_error
parameter_list|(
name|struct
name|wfd
modifier|*
name|t
parameter_list|,
name|struct
name|atapires
name|result
parameter_list|)
block|{
if|if
condition|(
name|result
operator|.
name|code
operator|!=
name|RES_ERR
condition|)
return|return;
switch|switch
condition|(
name|result
operator|.
name|error
operator|&
name|AER_SKEY
condition|)
block|{
case|case
name|AER_SK_NOT_READY
case|:
if|if
condition|(
name|result
operator|.
name|error
operator|&
operator|~
name|AER_SKEY
condition|)
block|{
comment|/* Not Ready */
name|printf
argument_list|(
literal|"wfd%d: not ready\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Tray open. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
operator|)
condition|)
name|printf
argument_list|(
literal|"wfd%d: tray open\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|F_MEDIA_CHANGED
expr_stmt|;
return|return;
case|case
name|AER_SK_UNIT_ATTENTION
case|:
comment|/* Media changed. */
if|if
condition|(
operator|!
operator|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
operator|)
condition|)
name|printf
argument_list|(
literal|"wfd%d: media changed\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
name|t
operator|->
name|flags
operator||=
name|F_MEDIA_CHANGED
expr_stmt|;
return|return;
case|case
name|AER_SK_ILLEGAL_REQUEST
case|:
comment|/* Unknown command or invalid command arguments. */
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_DEBUG
condition|)
name|printf
argument_list|(
literal|"wfd%d: invalid command\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"wfd%d: i/o error, status=%b, error=%b\n"
argument_list|,
name|t
operator|->
name|lun
argument_list|,
name|result
operator|.
name|status
argument_list|,
name|ARS_BITS
argument_list|,
name|result
operator|.
name|error
argument_list|,
name|AER_BITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wfd_request_wait
parameter_list|(
name|struct
name|wfd
modifier|*
name|t
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|u_char
name|a1
parameter_list|,
name|u_char
name|a2
parameter_list|,
name|u_char
name|a3
parameter_list|,
name|u_char
name|a4
parameter_list|,
name|u_char
name|a5
parameter_list|,
name|u_char
name|a6
parameter_list|,
name|u_char
name|a7
parameter_list|,
name|u_char
name|a8
parameter_list|,
name|u_char
name|a9
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|atapires
name|result
decl_stmt|;
name|result
operator|=
name|atapi_request_wait
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|cmd
argument_list|,
name|a1
argument_list|,
name|a2
argument_list|,
name|a3
argument_list|,
name|a4
argument_list|,
name|a5
argument_list|,
name|a6
argument_list|,
name|a7
argument_list|,
name|a8
argument_list|,
name|a9
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|code
condition|)
block|{
name|wfd_error
argument_list|(
name|t
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform special action on behalf of the user.  * Knows about the internals of this device  */
end_comment

begin_function
name|int
name|wfdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|lun
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|wfd
modifier|*
name|t
init|=
name|wfdtab
index|[
name|lun
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
decl_stmt|;
name|char
name|buffer
index|[
name|DEV_BSIZE
index|]
decl_stmt|;
name|error
operator|=
name|dsioctl
argument_list|(
literal|"wfd"
argument_list|,
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
operator|&
name|t
operator|->
name|dk_slices
argument_list|,
name|wfdstrategy1
argument_list|,
operator|(
name|ds_setgeom_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|t
operator|->
name|flags
operator|&
name|F_MEDIA_CHANGED
condition|)
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CDIOCSETDEBUG
case|:
case|case
name|CDIOCCLRDEBUG
case|:
case|case
name|CDIOCRESET
case|:
comment|/* These ops are media change transparent. */
break|break;
default|default:
comment|/* Lock the media. */
name|wfd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CDIOCSETDEBUG
case|:
if|if
condition|(
name|p
operator|->
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|t
operator|->
name|flags
operator||=
name|F_DEBUG
expr_stmt|;
name|atapi_debug
argument_list|(
name|t
operator|->
name|ata
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CDIOCCLRDEBUG
case|:
if|if
condition|(
name|p
operator|->
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|t
operator|->
name|flags
operator|&=
operator|~
name|F_DEBUG
expr_stmt|;
name|atapi_debug
argument_list|(
name|t
operator|->
name|ata
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|CDIOCRESET
case|:
if|if
condition|(
name|p
operator|->
name|p_cred
operator|->
name|pc_ucred
operator|->
name|cr_uid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
name|wfd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_TEST_UNIT_READY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCEJECT
case|:
comment|/* Don't allow eject if the device is opened 		 * by somebody (not us) in block mode. */
if|if
condition|(
operator|(
name|t
operator|->
name|flags
operator|&
name|F_BOPEN
operator|)
operator|&&
name|t
operator|->
name|refcnt
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
return|return
name|wfd_eject
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|CDIOCCLOSE
case|:
if|if
condition|(
operator|(
name|t
operator|->
name|flags
operator|&
name|F_BOPEN
operator|)
operator|&&
name|t
operator|->
name|refcnt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
name|wfd_eject
argument_list|(
name|t
argument_list|,
literal|1
argument_list|)
return|;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wfd_eject
parameter_list|(
name|struct
name|wfd
modifier|*
name|t
parameter_list|,
name|int
name|closeit
parameter_list|)
block|{
name|struct
name|atapires
name|result
decl_stmt|;
comment|/* Try to stop the disc. */
name|result
operator|=
name|atapi_request_wait
argument_list|(
name|t
operator|->
name|ata
argument_list|,
name|t
operator|->
name|unit
argument_list|,
name|ATAPI_START_STOP
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|code
operator|==
name|RES_ERR
operator|&&
operator|(
operator|(
name|result
operator|.
name|error
operator|&
name|AER_SKEY
operator|)
operator|==
name|AER_SK_NOT_READY
operator|||
operator|(
name|result
operator|.
name|error
operator|&
name|AER_SKEY
operator|)
operator|==
name|AER_SK_UNIT_ATTENTION
operator|)
condition|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|closeit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * The disc was unloaded. 		 * Load it (close tray). 		 * Read the table of contents. 		 */
name|err
operator|=
name|wfd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_START_STOP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Lock the media. */
name|wfd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|.
name|code
condition|)
block|{
name|wfd_error
argument_list|(
name|t
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|closeit
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Give it some time to stop spinning. */
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PRIBIO
argument_list|,
literal|"wfdej1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lbolt
argument_list|,
name|PRIBIO
argument_list|,
literal|"wfdej2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unlock. */
name|wfd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_PREVENT_ALLOW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Eject. */
name|t
operator|->
name|flags
operator||=
name|F_MEDIA_CHANGED
expr_stmt|;
return|return
name|wfd_request_wait
argument_list|(
name|t
argument_list|,
name|ATAPI_START_STOP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|WFD_MODULE
end_ifdef

begin_comment
comment|/*  * Loadable ATAPI Floppy driver stubs.  */
end_comment

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/lkm.h>
end_include

begin_comment
comment|/*  * Construct lkm_dev structures (see lkm.h).  * Our bdevsw/cdevsw slot numbers are 19/69.  */
end_comment

begin_expr_stmt
name|MOD_DEV
argument_list|(
name|wfd
argument_list|,
name|LM_DT_BLOCK
argument_list|,
name|BDEV_MAJOR
argument_list|,
operator|&
name|wfd_bdevsw
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MOD_DEV
argument_list|(
name|rwfd
argument_list|,
name|LM_DT_CHAR
argument_list|,
name|CDEV_MAJOR
argument_list|,
operator|&
name|wfd_cdevsw
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Function called when loading the driver.  */
end_comment

begin_function
name|int
name|wfd_load
parameter_list|(
name|struct
name|lkm_table
modifier|*
name|lkmtp
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|struct
name|atapi
modifier|*
name|ata
decl_stmt|;
name|int
name|n
decl_stmt|,
name|u
decl_stmt|;
if|if
condition|(
operator|!
name|atapi_start
condition|)
comment|/* No ATAPI driver available. */
return|return
name|EPROTONOSUPPORT
return|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ata
operator|=
name|atapi_tab
init|;
name|ata
operator|<
name|atapi_tab
operator|+
literal|2
condition|;
operator|++
name|ata
control|)
if|if
condition|(
name|ata
operator|->
name|port
condition|)
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
literal|2
condition|;
operator|++
name|u
control|)
comment|/* Probing controller ata->ctrlr, unit u. */
if|if
condition|(
name|ata
operator|->
name|params
index|[
name|u
index|]
operator|&&
operator|!
name|ata
operator|->
name|attached
index|[
name|u
index|]
operator|&&
name|wfdattach
argument_list|(
name|ata
argument_list|,
name|u
argument_list|,
name|ata
operator|->
name|params
index|[
name|u
index|]
argument_list|,
name|ata
operator|->
name|debug
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Drive found. */
name|ata
operator|->
name|attached
index|[
name|u
index|]
operator|=
literal|1
expr_stmt|;
operator|++
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|n
condition|)
comment|/* No IDE Floppies found. */
return|return
name|ENXIO
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Function called when unloading the driver.  */
end_comment

begin_function
name|int
name|wfd_unload
parameter_list|(
name|struct
name|lkm_table
modifier|*
name|lkmtp
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|struct
name|wfd
modifier|*
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|wfdtab
init|;
name|t
operator|<
name|wfdtab
operator|+
name|wfdnlun
condition|;
operator|++
name|t
control|)
if|if
condition|(
operator|(
operator|(
operator|*
name|t
operator|)
operator|->
name|flags
operator|&
name|F_BOPEN
operator|)
operator|||
operator|(
operator|*
name|t
operator|)
operator|->
name|refcnt
condition|)
comment|/* The device is opened, cannot unload the driver. */
return|return
name|EBUSY
return|;
for|for
control|(
name|t
operator|=
name|wfdtab
init|;
name|t
operator|<
name|wfdtab
operator|+
name|wfdnlun
condition|;
operator|++
name|t
control|)
block|{
operator|(
operator|*
name|t
operator|)
operator|->
name|ata
operator|->
name|attached
index|[
operator|(
operator|*
name|t
operator|)
operator|->
name|unit
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
operator|*
name|t
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
name|wfdnlun
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|wfdtab
argument_list|,
sizeof|sizeof
argument_list|(
name|wfdtab
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Dispatcher function for the module (load/unload/stat).  */
end_comment

begin_function
name|int
name|wfd_mod
parameter_list|(
name|struct
name|lkm_table
modifier|*
name|lkmtp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|ver
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ver
operator|!=
name|LKM_VERSION
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|cmd
operator|==
name|LKM_E_LOAD
condition|)
name|err
operator|=
name|wfd_load
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|==
name|LKM_E_UNLOAD
condition|)
name|err
operator|=
name|wfd_unload
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* XXX Poking around in the LKM internals like this is bad. 	 */
comment|/* Register the cdevsw entry. */
name|lkmtp
operator|->
name|private
operator|.
name|lkm_dev
operator|=
operator|&
name|MOD_PRIVATE
argument_list|(
name|rwfd
argument_list|)
expr_stmt|;
name|err
operator|=
name|lkmdispatch
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* Register the bdevsw entry. */
name|lkmtp
operator|->
name|private
operator|.
name|lkm_dev
operator|=
operator|&
name|MOD_PRIVATE
argument_list|(
name|wfd
argument_list|)
expr_stmt|;
return|return
name|lkmdispatch
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* WFD_MODULE */
end_comment

begin_expr_stmt
specifier|static
name|wfd_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|wfd_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
if|if
condition|(
operator|!
name|wfd_devsw_installed
condition|)
block|{
name|bdevsw_add_generic
argument_list|(
name|BDEV_MAJOR
argument_list|,
name|CDEV_MAJOR
argument_list|,
operator|&
name|wfd_bdevsw
argument_list|)
expr_stmt|;
name|wfd_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|wfddev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|wfd_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NWFD&& NWDC&& ATAPI */
end_comment

end_unit

