begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Device-independent level for ATAPI drivers.  *  * Copyright (C) 1995 Cronyx Ltd.  * Author Serge Vakulenko,<vak@cronyx.ru>  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations permission to use  * or modify this software as long as this message is kept with the software,  * all derivative works or modified versions.  *  * Version 1.3, Mon Aug 28 21:44:01 MSD 1995  */
end_comment

begin_comment
comment|/*  * The ATAPI level is implemented as a machine-dependent layer  * between the device driver and the IDE controller.  * All the machine- and controller dependency is isolated inside  * the ATAPI level, while all the device dependency is located  * in the device subdriver.  *  * It seems that an ATAPI bus will became popular for medium-speed  * storage devices such as CD-ROMs, magneto-optical disks, tape streamers etc.  *  * To ease the development of new ATAPI drivers, the subdriver  * interface was designed to be as simple as possible.  *  * Three routines are available for the subdriver to access the device:  *  *      struct atapires atapi_request_wait (ata, unit, cmd, a1, a2, a3, a4, a5,  *              a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, addr, count);  *      struct atapi *ata;  -- atapi controller descriptor  *      int unit;           -- device unit number on the IDE bus  *      u_char cmd;         -- ATAPI command code  *      u_char a1..a15;     -- ATAPI command arguments  *      char *addr;         -- address of the data buffer for i/o  *      int count;          -- data length,>0 for read ops,<0 for write ops  *  * The atapi_request_wait() function puts the op in the queue of ATAPI  * commands for the IDE controller, starts the controller, the waits for  * operation to be completed (using tsleep).  * The function should be called from the user phase only (open(), close(),  * ioctl() etc).  * Ata and unit args are the values which the subdriver gets from the ATAPI  * level via attach() call.  * Buffer pointed to by *addr should be placed in core memory, static  * or dynamic, but not in stack.  * The function returns the error code structure, which consists of:  * - atapi driver code value  * - controller status port value  * - controller error port value  *  *      struct atapires atapi_request_immediate (ata, unit, cmd, a1, a2, a3,  *              a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15,  *              addr, count);  *  * The atapi_request_immediate() function is similar to atapi_request_wait(),  * but it does not use interrupts for performing the request.  * It should be used during an attach phase to get parameters from the device.  *  *      void atapi_request_callback (ata, unit, cmd, a1, a2, a3, a4, a5,  *              a6, a7, a8, a9, a10, a11, a12, a13, a14, a15,  *              addr, count, done, x, y);  *      struct atapi *ata;  -- atapi controller descriptor  *      int unit;           -- device unit number on the IDE bus  *      u_char cmd;         -- ATAPI command code  *      u_char a1..a15;     -- ATAPI command arguments  *      char *addr;         -- address of the data buffer for i/o  *      int count;          -- data length,>0 for read ops,<0 for write ops  *      void (*done)();     -- function to call when op finished  *      void *x, *y;        -- arguments for done() function  *  * The atapi_request_callback() function puts the op in the queue of ATAPI  * commands for the IDE controller, starts the controller, then returns.  * When the operation finishes, then the callback function done()  * will be called on the interrupt level.  * The function is designed to be callable from the interrupt phase.  * The done() functions is called with the following arguments:  *      (void) (*done) (x, y, count, errcode)  *      void *x, *y;             -- arguments from the atapi_request_callback()  *      int count;               -- the data residual count  *      struct atapires errcode; -- error code structure, see above  *  * The new driver could be added in three steps:  * 1. Add entries for the new driver to bdevsw and cdevsw tables in conf.c.  *    You will need to make at least three routines: open(), close(),  *    strategy() and possibly ioctl().  * 2. Make attach() routine, which should allocate all the needed data  *    structures and print the device description string (see wcdattach()).  * 3. Add an appropriate case to the switch in atapi_attach() routine,  *    call attach() routine of the new driver here.  Add the appropriate  *    #include line at the top of attach.c.  * That's all!  *  * Use #define DEBUG in atapi.c to enable tracing of all i/o operations  * on the IDE bus.  */
end_comment

begin_undef
undef|#
directive|undef
name|DEBUG
end_undef

begin_include
include|#
directive|include
file|"wdc.h"
end_include

begin_include
include|#
directive|include
file|"wcd.h"
end_include

begin_comment
comment|/* #include "wmt.h" -- add your driver here */
end_comment

begin_comment
comment|/* #include "wmd.h" -- add your driver here */
end_comment

begin_if
if|#
directive|if
name|NWDC
operator|>
literal|0
operator|&&
name|defined
argument_list|(
name|ATAPI
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<i386/include/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<i386/include/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/atapi.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|print
parameter_list|(
name|s
parameter_list|)
value|printf s
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|print
parameter_list|(
name|s
parameter_list|)
value|{
comment|/*void*/
value|}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXCMD
value|(8*NWDC)
end_define

begin_comment
comment|/*  * ATAPI packet command phase.  */
end_comment

begin_define
define|#
directive|define
name|PHASE_CMDOUT
value|(ARS_DRQ | ARI_CMD)
end_define

begin_define
define|#
directive|define
name|PHASE_DATAIN
value|(ARS_DRQ | ARI_IN)
end_define

begin_define
define|#
directive|define
name|PHASE_DATAOUT
value|ARS_DRQ
end_define

begin_define
define|#
directive|define
name|PHASE_COMPLETED
value|(ARI_IN | ARI_CMD)
end_define

begin_struct
struct|struct
name|atapicmd
block|{
comment|/* ATAPI command block */
name|struct
name|atapicmd
modifier|*
name|next
decl_stmt|;
comment|/* next command in queue */
name|int
name|busy
decl_stmt|;
comment|/* busy flag */
name|u_char
name|cmd
index|[
literal|16
index|]
decl_stmt|;
comment|/* command and args */
name|int
name|unit
decl_stmt|;
comment|/* drive unit number */
name|int
name|count
decl_stmt|;
comment|/* byte count,>0 - read,<0 - write */
name|char
modifier|*
name|addr
decl_stmt|;
comment|/* data to transfer */
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|()
function_decl|;
comment|/* call when done */
name|void
modifier|*
name|cbarg1
decl_stmt|;
comment|/* callback arg 1 */
name|void
modifier|*
name|cbarg2
decl_stmt|;
comment|/* callback arg 1 */
name|struct
name|atapires
name|result
decl_stmt|;
comment|/* resulting error code */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|atapi
block|{
comment|/* ATAPI controller data */
name|u_short
name|port
decl_stmt|;
comment|/* i/o port base */
name|u_char
name|ctrlr
decl_stmt|;
comment|/* physical controller number */
name|u_char
name|debug
range|:
literal|1
decl_stmt|;
comment|/* trace enable flag */
name|u_char
name|cmd16
range|:
literal|1
decl_stmt|;
comment|/* 16-byte command flag */
name|u_char
name|intrcmd
range|:
literal|1
decl_stmt|;
comment|/* interrupt before cmd flag */
name|u_char
name|slow
range|:
literal|1
decl_stmt|;
comment|/* slow reaction device */
name|struct
name|atapicmd
modifier|*
name|queue
decl_stmt|;
comment|/* queue of commands to perform */
name|struct
name|atapicmd
modifier|*
name|tail
decl_stmt|;
comment|/* tail of queue */
name|struct
name|atapicmd
modifier|*
name|free
decl_stmt|;
comment|/* queue of free command blocks */
name|struct
name|atapicmd
name|cmdrq
index|[
name|MAXCMD
index|]
decl_stmt|;
comment|/* pool of command requests */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|atapi
name|atapitab
index|[
name|NWDC
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|atapi_params
modifier|*
name|atapi_probe
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atapi_wait
parameter_list|(
name|int
name|port
parameter_list|,
name|u_char
name|bits_wanted
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|atapi_send_cmd
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atapi_io
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atapi_start_cmd
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atapi_wait_cmd
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|wdstart
parameter_list|(
name|int
name|ctrlr
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|atapi_attach
parameter_list|(
name|int
name|ctlr
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|port
parameter_list|,
name|struct
name|kern_devconf
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|atapi
modifier|*
name|ata
init|=
name|atapitab
operator|+
name|ctlr
decl_stmt|;
name|struct
name|atapi_params
modifier|*
name|ap
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|model
argument_list|)
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|atapicmd
modifier|*
name|ac
decl_stmt|;
name|print
argument_list|(
operator|(
literal|"atapi%d.%d at 0x%x: attach called\n"
operator|,
name|ctlr
operator|,
name|unit
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
name|ap
operator|=
name|atapi_probe
argument_list|(
name|port
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
return|return;
name|bcopy
argument_list|(
name|ap
operator|->
name|model
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"wdc%d: unit %d (atapi):<%s>"
argument_list|,
name|ctlr
argument_list|,
name|unit
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* device is removable */
if|if
condition|(
name|ap
operator|->
name|removable
condition|)
name|printf
argument_list|(
literal|", removable"
argument_list|)
expr_stmt|;
comment|/* packet command size */
switch|switch
condition|(
name|ap
operator|->
name|cmdsz
condition|)
block|{
case|case
name|AT_PSIZE_12
case|:
break|break;
case|case
name|AT_PSIZE_16
case|:
name|printf
argument_list|(
literal|", cmd16"
argument_list|)
expr_stmt|;
name|ata
operator|->
name|cmd16
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|", cmd%d"
argument_list|,
name|ap
operator|->
name|cmdsz
argument_list|)
expr_stmt|;
block|}
comment|/* DRQ type */
switch|switch
condition|(
name|ap
operator|->
name|drqtype
condition|)
block|{
case|case
name|AT_DRQT_MPROC
case|:
name|ata
operator|->
name|slow
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AT_DRQT_INTR
case|:
name|printf
argument_list|(
literal|", intr"
argument_list|)
expr_stmt|;
name|ata
operator|->
name|intrcmd
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AT_DRQT_ACCEL
case|:
name|printf
argument_list|(
literal|", accel"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|", drq%d"
argument_list|,
name|ap
operator|->
name|cmdsz
argument_list|)
expr_stmt|;
block|}
comment|/* overlap operation supported */
if|if
condition|(
name|ap
operator|->
name|ovlapflag
condition|)
name|printf
argument_list|(
literal|", ovlap"
argument_list|)
expr_stmt|;
comment|/* interleaved DMA supported */
if|if
condition|(
name|ap
operator|->
name|idmaflag
condition|)
name|printf
argument_list|(
literal|", idma"
argument_list|)
expr_stmt|;
comment|/* DMA supported */
elseif|else
if|if
condition|(
name|ap
operator|->
name|dmaflag
condition|)
name|printf
argument_list|(
literal|", dma"
argument_list|)
expr_stmt|;
comment|/* IORDY can be disabled */
if|if
condition|(
name|ap
operator|->
name|iordydis
condition|)
name|printf
argument_list|(
literal|", iordis"
argument_list|)
expr_stmt|;
comment|/* IORDY supported */
elseif|else
if|if
condition|(
name|ap
operator|->
name|iordyflag
condition|)
name|printf
argument_list|(
literal|", iordy"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ata
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|ata
operator|->
name|ctrlr
operator|=
name|ctlr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|ata
operator|->
name|debug
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|ata
operator|->
name|debug
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize free queue. */
name|ata
operator|->
name|cmdrq
index|[
name|MAXCMD
operator|-
literal|1
index|]
operator|.
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ac
operator|=
name|ata
operator|->
name|cmdrq
operator|+
name|MAXCMD
operator|-
literal|2
init|;
name|ac
operator|>=
name|ata
operator|->
name|cmdrq
condition|;
operator|--
name|ac
control|)
name|ac
operator|->
name|next
operator|=
name|ac
operator|+
literal|1
expr_stmt|;
name|ata
operator|->
name|free
operator|=
name|ata
operator|->
name|cmdrq
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|proto
operator|!=
name|AT_PROTO_ATAPI
condition|)
block|{
name|printf
argument_list|(
literal|"wdc%d: unit %d: unknown ATAPI protocol=%d\n"
argument_list|,
name|ctlr
argument_list|,
name|unit
argument_list|,
name|ap
operator|->
name|proto
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ap
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|ap
operator|->
name|devtype
condition|)
block|{
default|default:
comment|/* unknown ATAPI device */
name|printf
argument_list|(
literal|"wdc%d: unit %d: unknown ATAPI device type=%d\n"
argument_list|,
name|ctlr
argument_list|,
name|unit
argument_list|,
name|ap
operator|->
name|devtype
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_TYPE_DIRECT
case|:
comment|/* direct-access (magnetic disk) */
if|#
directive|if
name|NWHD
operator|>
literal|0
comment|/* Add your driver here */
else|#
directive|else
name|printf
argument_list|(
literal|"wdc%d: ATAPI hard disks not supported\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wdc%d: Could be old ATAPI CDROM, trying...\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AT_TYPE_CDROM
case|:
comment|/* CD-ROM device */
if|#
directive|if
name|NWCD
operator|>
literal|0
block|{
name|int
name|wcdattach
argument_list|(
expr|struct
name|atapi
operator|*
argument_list|,
name|int
argument_list|,
expr|struct
name|atapi_params
operator|*
argument_list|,
name|int
argument_list|,
expr|struct
name|kern_devconf
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|wcdattach
argument_list|(
name|ata
argument_list|,
name|unit
argument_list|,
name|ap
argument_list|,
name|ata
operator|->
name|debug
argument_list|,
name|parent
argument_list|)
operator|<
literal|0
condition|)
break|break;
block|}
comment|/* Device attached successfully. */
return|return;
else|#
directive|else
name|printf
argument_list|(
literal|"wdc%d: ATAPI CD-ROMs not configured\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AT_TYPE_TAPE
case|:
comment|/* streaming tape (QIC-121 model) */
if|#
directive|if
name|NWMT
operator|>
literal|0
comment|/* Add your driver here */
else|#
directive|else
name|printf
argument_list|(
literal|"wdc%d: ATAPI streaming tapes not supported\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AT_TYPE_OPTICAL
case|:
comment|/* optical disk */
if|#
directive|if
name|NWMD
operator|>
literal|0
comment|/* Add your driver here */
else|#
directive|else
name|printf
argument_list|(
literal|"wdc%d: ATAPI optical disks not supported\n"
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
comment|/* Attach failed. */
name|free
argument_list|(
name|ap
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Issue IDENTIFY command to ATAPI drive to ask it what it is.  */
end_comment

begin_function
specifier|static
name|struct
name|atapi_params
modifier|*
name|atapi_probe
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|atapi_params
modifier|*
name|ap
decl_stmt|;
name|char
name|tb
index|[
name|DEV_BSIZE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Wait for controller not busy. */
if|if
condition|(
name|atapi_wait
argument_list|(
name|port
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"atapi.%d at 0x%x: controller busy, status=%b\n"
operator|,
name|unit
operator|,
name|port
operator|,
name|inb
argument_list|(
name|port
operator|+
name|AR_STATUS
argument_list|)
operator|,
name|ARS_BITS
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Issue ATAPI IDENTIFY command. */
name|outb
argument_list|(
name|port
operator|+
name|AR_DRIVE
argument_list|,
name|unit
condition|?
name|ARD_DRIVE1
else|:
name|ARD_DRIVE0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|AR_COMMAND
argument_list|,
name|ATAPIC_IDENTIFY
argument_list|)
expr_stmt|;
comment|/* Check that device is present. */
if|if
condition|(
name|inb
argument_list|(
name|port
operator|+
name|AR_STATUS
argument_list|)
operator|==
literal|0xff
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"atapi.%d at 0x%x: no device\n"
operator|,
name|unit
operator|,
name|port
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|1
condition|)
comment|/* Select unit 0. */
name|outb
argument_list|(
name|port
operator|+
name|AR_DRIVE
argument_list|,
name|ARD_DRIVE0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Wait for data ready. */
if|if
condition|(
name|atapi_wait
argument_list|(
name|port
argument_list|,
name|ARS_DRQ
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|print
argument_list|(
operator|(
literal|"atapi.%d at 0x%x: identify not ready, status=%b\n"
operator|,
name|unit
operator|,
name|port
operator|,
name|inb
argument_list|(
name|port
operator|+
name|AR_STATUS
argument_list|)
operator|,
name|ARS_BITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
literal|1
condition|)
comment|/* Select unit 0. */
name|outb
argument_list|(
name|port
operator|+
name|AR_DRIVE
argument_list|,
name|ARD_DRIVE0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Obtain parameters. */
name|insw
argument_list|(
name|port
operator|+
name|AR_DATA
argument_list|,
name|tb
argument_list|,
sizeof|sizeof
argument_list|(
name|tb
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|ap
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ap
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ap
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bcopy
argument_list|(
name|tb
argument_list|,
name|ap
argument_list|,
sizeof|sizeof
expr|*
name|ap
argument_list|)
expr_stmt|;
comment|/* 	 * Shuffle string byte order. 	 * Mitsumi and NEC drives don't need this. 	 */
if|if
condition|(
operator|!
operator|(
operator|(
name|ap
operator|->
name|model
index|[
literal|0
index|]
operator|==
literal|'N'
operator|&&
name|ap
operator|->
name|model
index|[
literal|1
index|]
operator|==
literal|'E'
operator|)
operator|||
operator|(
name|ap
operator|->
name|model
index|[
literal|0
index|]
operator|==
literal|'F'
operator|&&
name|ap
operator|->
name|model
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
operator|)
condition|)
block|{
name|u_short
modifier|*
name|p
init|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|ap
operator|->
name|model
operator|+
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|model
argument_list|)
operator|)
decl_stmt|;
while|while
condition|(
operator|--
name|p
operator|>=
operator|(
name|u_short
operator|*
operator|)
name|ap
operator|->
name|model
condition|)
operator|*
name|p
operator|=
name|ntohs
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up the model by converting nulls to spaces, and 	 * then removing the trailing spaces. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|model
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|ap
operator|->
name|model
index|[
name|i
index|]
condition|)
name|ap
operator|->
name|model
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|ap
operator|->
name|model
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
operator|&&
name|ap
operator|->
name|model
index|[
name|i
index|]
operator|==
literal|' '
condition|;
name|i
operator|--
control|)
name|ap
operator|->
name|model
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait uninterruptibly until controller is not busy and certain  * status bits are set.  * The wait is usually short unless it is for the controller to process  * an entire critical command.  * Return 1 for (possibly stale) controller errors, -1 for timeout errors,  * or 0 for no errors.  */
end_comment

begin_function
specifier|static
name|int
name|atapi_wait
parameter_list|(
name|int
name|port
parameter_list|,
name|u_char
name|bits_wanted
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
name|u_char
name|s
decl_stmt|;
comment|/* Wait 5 sec for BUSY deassert. */
for|for
control|(
name|cnt
operator|=
literal|500000
init|;
name|cnt
operator|>
literal|0
condition|;
operator|--
name|cnt
control|)
block|{
name|s
operator|=
name|inb
argument_list|(
name|port
operator|+
name|AR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|&
name|ARS_BSY
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|bits_wanted
condition|)
return|return
operator|(
name|s
operator|&
name|ARS_CHECK
operator|)
return|;
comment|/* Wait 50 msec for bits wanted. */
for|for
control|(
name|cnt
operator|=
literal|5000
init|;
name|cnt
operator|>
literal|0
condition|;
operator|--
name|cnt
control|)
block|{
name|s
operator|=
name|inb
argument_list|(
name|port
operator|+
name|AR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|&
name|bits_wanted
operator|)
operator|==
name|bits_wanted
condition|)
return|return
operator|(
name|s
operator|&
name|ARS_CHECK
operator|)
return|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|atapi_debug
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|ata
operator|->
name|debug
operator|=
name|on
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|atapicmd
modifier|*
name|atapi_alloc
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|)
block|{
name|struct
name|atapicmd
modifier|*
name|ac
decl_stmt|;
while|while
condition|(
operator|!
name|ata
operator|->
name|free
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|ata
argument_list|,
name|PRIBIO
argument_list|,
literal|"atacmd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ac
operator|=
name|ata
operator|->
name|free
expr_stmt|;
name|ata
operator|->
name|free
operator|=
name|ac
operator|->
name|next
expr_stmt|;
name|ac
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ac
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atapi_free
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ata
operator|->
name|free
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ata
argument_list|)
expr_stmt|;
name|ac
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|next
operator|=
name|ata
operator|->
name|free
expr_stmt|;
name|ata
operator|->
name|free
operator|=
name|ac
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add new command request to the end of the queue.  */
end_comment

begin_function
specifier|static
name|void
name|atapi_enqueue
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
block|{
name|ac
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|tail
condition|)
name|ata
operator|->
name|tail
operator|->
name|next
operator|=
name|ac
expr_stmt|;
else|else
name|ata
operator|->
name|queue
operator|=
name|ac
expr_stmt|;
name|ata
operator|->
name|tail
operator|=
name|ac
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atapi_done
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|)
block|{
name|struct
name|atapicmd
modifier|*
name|ac
init|=
name|ata
operator|->
name|queue
decl_stmt|;
if|if
condition|(
operator|!
name|ac
condition|)
return|return;
comment|/* cannot happen */
name|ata
operator|->
name|queue
operator|=
name|ac
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|ata
operator|->
name|queue
condition|)
name|ata
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ac
operator|->
name|callback
condition|)
block|{
call|(
modifier|*
name|ac
operator|->
name|callback
call|)
argument_list|(
name|ac
operator|->
name|cbarg1
argument_list|,
name|ac
operator|->
name|cbarg2
argument_list|,
name|ac
operator|->
name|count
argument_list|,
name|ac
operator|->
name|result
argument_list|)
expr_stmt|;
name|atapi_free
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
block|}
else|else
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|ac
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start new packet op.  Called from wdstart().  * Return 1 if op started, and we are waiting for interrupt.  * Return 0 when idle.  */
end_comment

begin_function
name|int
name|atapi_start
parameter_list|(
name|int
name|ctrlr
parameter_list|)
block|{
name|struct
name|atapi
modifier|*
name|ata
init|=
name|atapitab
operator|+
name|ctrlr
decl_stmt|;
name|struct
name|atapicmd
modifier|*
name|ac
decl_stmt|;
name|again
label|:
name|ac
operator|=
name|ata
operator|->
name|queue
expr_stmt|;
if|if
condition|(
operator|!
name|ac
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Start packet command. */
if|if
condition|(
name|atapi_start_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
operator|<
literal|0
condition|)
block|{
name|atapi_done
argument_list|(
name|ata
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|ata
operator|->
name|intrcmd
condition|)
comment|/* Wait for interrupt before sending packet command */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Wait for DRQ. */
if|if
condition|(
name|atapi_wait_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
operator|<
literal|0
condition|)
block|{
name|atapi_done
argument_list|(
name|ata
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* Send packet command. */
name|atapi_send_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start new packet op. Returns -1 on errors.  */
end_comment

begin_function
name|int
name|atapi_start_cmd
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
block|{
name|ac
operator|->
name|result
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_DRIVE
argument_list|,
name|ac
operator|->
name|unit
condition|?
name|ARD_DRIVE1
else|:
name|ARD_DRIVE0
argument_list|)
expr_stmt|;
if|if
condition|(
name|atapi_wait
argument_list|(
name|ata
operator|->
name|port
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: controller not ready for cmd\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_NOTRDY
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Set up the controller registers. */
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_FEATURES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_IREASON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_TAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_CNTLO
argument_list|,
name|ac
operator|->
name|count
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_CNTHI
argument_list|,
name|ac
operator|->
name|count
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_COMMAND
argument_list|,
name|ATAPIC_PACKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|debug
condition|)
name|printf
argument_list|(
literal|"atapi%d.%d: start\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for DRQ before sending packet cmd. Returns -1 on errors.  */
end_comment

begin_function
name|int
name|atapi_wait_cmd
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
block|{
comment|/* Wait for DRQ from 50 usec to 3 msec for slow devices */
name|int
name|cnt
init|=
name|ata
operator|->
name|intrcmd
condition|?
literal|10000
else|:
name|ata
operator|->
name|slow
condition|?
literal|3000
else|:
literal|50
decl_stmt|;
for|for
control|(
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|-=
literal|10
control|)
block|{
name|ac
operator|->
name|result
operator|.
name|status
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|->
name|result
operator|.
name|status
operator|&
name|ARS_DRQ
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ac
operator|->
name|result
operator|.
name|status
operator|&
name|ARS_DRQ
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: no cmd drq\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_NODRQ
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|error
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send packet cmd.  */
end_comment

begin_function
name|void
name|atapi_send_cmd
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
block|{
name|outsw
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_DATA
argument_list|,
name|ac
operator|->
name|cmd
argument_list|,
name|ata
operator|->
name|cmd16
condition|?
literal|8
else|:
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|debug
condition|)
name|printf
argument_list|(
literal|"atapi%d.%d: send cmd %x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interrupt routine for the controller.  Called from wdintr().  * Finish the started op, wakeup wait-type commands,  * run callbacks for callback-type commands, then return.  * Do not start new op here, it will be done by wdstart,  * which is called just after us.  * Return 1 if op continues, and we are waiting for new interrupt.  * Return 0 when idle.  */
end_comment

begin_function
name|int
name|atapi_intr
parameter_list|(
name|int
name|ctrlr
parameter_list|)
block|{
name|struct
name|atapi
modifier|*
name|ata
init|=
name|atapitab
operator|+
name|ctrlr
decl_stmt|;
name|struct
name|atapicmd
modifier|*
name|ac
init|=
name|ata
operator|->
name|queue
decl_stmt|;
if|if
condition|(
operator|!
name|ac
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d: stray interrupt\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|atapi_io
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|atapi_done
argument_list|(
name|ata
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process the i/o phase, transferring the command/data to/from the device.  * Return 1 if op continues, and we are waiting for new interrupt.  * Return 0 when idle.  */
end_comment

begin_function
name|int
name|atapi_io
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|struct
name|atapicmd
modifier|*
name|ac
parameter_list|)
block|{
name|u_char
name|ireason
decl_stmt|;
name|u_short
name|len
decl_stmt|;
if|if
condition|(
name|atapi_wait
argument_list|(
name|ata
operator|->
name|port
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ac
operator|->
name|result
operator|.
name|status
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_STATUS
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|error
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_ERROR
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_NOTRDY
expr_stmt|;
name|printf
argument_list|(
literal|"atapi%d.%d: controller not ready, status=%b, error=%b\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ac
operator|->
name|result
operator|.
name|status
argument_list|,
name|ARS_BITS
argument_list|,
name|ac
operator|->
name|result
operator|.
name|error
argument_list|,
name|AER_BITS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ac
operator|->
name|result
operator|.
name|status
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_STATUS
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|error
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_ERROR
argument_list|)
expr_stmt|;
name|len
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_CNTLO
argument_list|)
expr_stmt|;
name|len
operator||=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_CNTHI
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|ireason
operator|=
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_IREASON
argument_list|)
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|debug
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: intr ireason=0x%x, len=%d, status=%b, error=%b\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ireason
argument_list|,
name|len
argument_list|,
name|ac
operator|->
name|result
operator|.
name|status
argument_list|,
name|ARS_BITS
argument_list|,
name|ac
operator|->
name|result
operator|.
name|error
argument_list|,
name|AER_BITS
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|ireason
operator|&
operator|(
name|ARI_CMD
operator||
name|ARI_IN
operator|)
operator|)
operator||
operator|(
name|ac
operator|->
name|result
operator|.
name|status
operator|&
name|ARS_DRQ
operator|)
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"atapi%d.%d: unknown phase\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_ERR
expr_stmt|;
break|break;
case|case
name|PHASE_CMDOUT
case|:
comment|/* Send packet command. */
if|if
condition|(
operator|!
operator|(
name|ac
operator|->
name|result
operator|.
name|status
operator|&
name|ARS_DRQ
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: no cmd drq\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_NODRQ
expr_stmt|;
break|break;
block|}
name|atapi_send_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PHASE_DATAOUT
case|:
comment|/* Write data */
if|if
condition|(
name|ac
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: invalid data direction\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_INVDIR
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|-
name|ac
operator|->
name|count
operator|<
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: send data underrun, %d bytes left\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
operator|-
name|ac
operator|->
name|count
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_UNDERRUN
expr_stmt|;
break|break;
block|}
name|outsw
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_DATA
argument_list|,
name|ac
operator|->
name|addr
argument_list|,
name|len
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|ac
operator|->
name|addr
operator|+=
name|len
expr_stmt|;
name|ac
operator|->
name|count
operator|+=
name|len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PHASE_DATAIN
case|:
comment|/* Read data */
if|if
condition|(
name|ac
operator|->
name|count
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: invalid data direction\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_INVDIR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ac
operator|->
name|count
operator|<
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: recv data overrun, %d bytes left\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ac
operator|->
name|count
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_OVERRUN
expr_stmt|;
break|break;
block|}
name|insw
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_DATA
argument_list|,
name|ac
operator|->
name|addr
argument_list|,
name|len
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|ac
operator|->
name|addr
operator|+=
name|len
expr_stmt|;
name|ac
operator|->
name|count
operator|-=
name|len
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|PHASE_COMPLETED
case|:
if|if
condition|(
name|ac
operator|->
name|result
operator|.
name|status
operator|&
operator|(
name|ARS_CHECK
operator||
name|ARS_DF
operator|)
condition|)
block|{
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_ERR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ac
operator|->
name|count
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: send data overrun, %d bytes left\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
operator|-
name|ac
operator|->
name|count
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_OVERRUN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ac
operator|->
name|count
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"atapi%d.%d: recv data underrun, %d bytes left\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ac
operator|->
name|count
argument_list|)
expr_stmt|;
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_UNDERRUN
expr_stmt|;
break|break;
block|}
name|ac
operator|->
name|result
operator|.
name|code
operator|=
name|RES_OK
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue new packet request, then call wdstart().  * Called on splbio().  */
end_comment

begin_function
name|void
name|atapi_request_callback
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|int
name|unit
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|u_char
name|a1
parameter_list|,
name|u_char
name|a2
parameter_list|,
name|u_char
name|a3
parameter_list|,
name|u_char
name|a4
parameter_list|,
name|u_char
name|a5
parameter_list|,
name|u_char
name|a6
parameter_list|,
name|u_char
name|a7
parameter_list|,
name|u_char
name|a8
parameter_list|,
name|u_char
name|a9
parameter_list|,
name|u_char
name|a10
parameter_list|,
name|u_char
name|a11
parameter_list|,
name|u_char
name|a12
parameter_list|,
name|u_char
name|a13
parameter_list|,
name|u_char
name|a14
parameter_list|,
name|u_char
name|a15
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|,
name|void
function_decl|(
modifier|*
name|done
function_decl|)
parameter_list|()
parameter_list|,
name|void
modifier|*
name|x
parameter_list|,
name|void
modifier|*
name|y
parameter_list|)
block|{
name|struct
name|atapicmd
modifier|*
name|ac
decl_stmt|;
name|ac
operator|=
name|atapi_alloc
argument_list|(
name|ata
argument_list|)
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
operator|=
name|a1
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
operator|=
name|a2
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
operator|=
name|a3
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
operator|=
name|a4
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
operator|=
name|a5
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
operator|=
name|a6
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
operator|=
name|a7
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
operator|=
name|a8
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
operator|=
name|a9
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
operator|=
name|a10
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
operator|=
name|a11
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
operator|=
name|a12
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
operator|=
name|a13
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
operator|=
name|a14
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
operator|=
name|a15
expr_stmt|;
name|ac
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|ac
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|ac
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|ac
operator|->
name|callback
operator|=
name|done
expr_stmt|;
name|ac
operator|->
name|cbarg1
operator|=
name|x
expr_stmt|;
name|ac
operator|->
name|cbarg2
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|debug
condition|)
name|printf
argument_list|(
literal|"atapi%d.%d: req cb %x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x len=%d\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|atapi_enqueue
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
name|wdstart
argument_list|(
name|ata
operator|->
name|ctrlr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Queue new packet request, then call wdstart().  * Wait until the request is finished.  * Called on spl0().  * Return atapi error.  * Buffer pointed to by *addr should be placed in core memory, not in stack!  */
end_comment

begin_function
name|struct
name|atapires
name|atapi_request_wait
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|int
name|unit
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|u_char
name|a1
parameter_list|,
name|u_char
name|a2
parameter_list|,
name|u_char
name|a3
parameter_list|,
name|u_char
name|a4
parameter_list|,
name|u_char
name|a5
parameter_list|,
name|u_char
name|a6
parameter_list|,
name|u_char
name|a7
parameter_list|,
name|u_char
name|a8
parameter_list|,
name|u_char
name|a9
parameter_list|,
name|u_char
name|a10
parameter_list|,
name|u_char
name|a11
parameter_list|,
name|u_char
name|a12
parameter_list|,
name|u_char
name|a13
parameter_list|,
name|u_char
name|a14
parameter_list|,
name|u_char
name|a15
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|atapicmd
modifier|*
name|ac
decl_stmt|;
name|int
name|x
init|=
name|splbio
argument_list|()
decl_stmt|;
name|struct
name|atapires
name|result
decl_stmt|;
name|ac
operator|=
name|atapi_alloc
argument_list|(
name|ata
argument_list|)
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
operator|=
name|a1
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
operator|=
name|a2
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
operator|=
name|a3
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
operator|=
name|a4
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
operator|=
name|a5
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
operator|=
name|a6
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
operator|=
name|a7
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
operator|=
name|a8
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
operator|=
name|a9
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
operator|=
name|a10
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
operator|=
name|a11
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
operator|=
name|a12
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
operator|=
name|a13
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
operator|=
name|a14
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
operator|=
name|a15
expr_stmt|;
name|ac
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|ac
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|ac
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|ac
operator|->
name|callback
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|cbarg1
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|cbarg2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|debug
condition|)
name|printf
argument_list|(
literal|"atapi%d.%d: req w %x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x len=%d\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|atapi_enqueue
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
name|wdstart
argument_list|(
name|ata
operator|->
name|ctrlr
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|ac
argument_list|,
name|PRIBIO
argument_list|,
literal|"atareq"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|ac
operator|->
name|result
expr_stmt|;
name|atapi_free
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a packet command on the device.  * Should be called on splbio().  * Return atapi error.  */
end_comment

begin_function
name|struct
name|atapires
name|atapi_request_immediate
parameter_list|(
name|struct
name|atapi
modifier|*
name|ata
parameter_list|,
name|int
name|unit
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|u_char
name|a1
parameter_list|,
name|u_char
name|a2
parameter_list|,
name|u_char
name|a3
parameter_list|,
name|u_char
name|a4
parameter_list|,
name|u_char
name|a5
parameter_list|,
name|u_char
name|a6
parameter_list|,
name|u_char
name|a7
parameter_list|,
name|u_char
name|a8
parameter_list|,
name|u_char
name|a9
parameter_list|,
name|u_char
name|a10
parameter_list|,
name|u_char
name|a11
parameter_list|,
name|u_char
name|a12
parameter_list|,
name|u_char
name|a13
parameter_list|,
name|u_char
name|a14
parameter_list|,
name|u_char
name|a15
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|atapicmd
name|cmdbuf
decl_stmt|,
modifier|*
name|ac
init|=
operator|&
name|cmdbuf
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
operator|=
name|a1
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
operator|=
name|a2
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
operator|=
name|a3
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
operator|=
name|a4
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
operator|=
name|a5
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
operator|=
name|a6
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
operator|=
name|a7
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
operator|=
name|a8
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
operator|=
name|a9
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
operator|=
name|a10
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
operator|=
name|a11
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
operator|=
name|a12
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
operator|=
name|a13
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
operator|=
name|a14
expr_stmt|;
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
operator|=
name|a15
expr_stmt|;
name|ac
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|ac
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|ac
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|ac
operator|->
name|callback
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|cbarg1
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|cbarg2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ata
operator|->
name|debug
condition|)
name|printf
argument_list|(
literal|"atapi%d.%d: req im %x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x-%x len=%d\n"
argument_list|,
name|ata
operator|->
name|ctrlr
argument_list|,
name|ac
operator|->
name|unit
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|1
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|2
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|3
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|4
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|5
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|6
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|7
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|8
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|9
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|10
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|11
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|12
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|13
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|14
index|]
argument_list|,
name|ac
operator|->
name|cmd
index|[
literal|15
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* Start packet command, wait for DRQ. */
if|if
condition|(
name|atapi_start_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
operator|>=
literal|0
operator|&&
name|atapi_wait_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Send packet command. */
name|atapi_send_cmd
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
expr_stmt|;
comment|/* Do all needed i/o. */
while|while
condition|(
name|atapi_io
argument_list|(
name|ata
argument_list|,
name|ac
argument_list|)
condition|)
comment|/* Wait for DRQ deassert. */
for|for
control|(
name|cnt
operator|=
literal|2000
init|;
name|cnt
operator|>
literal|0
condition|;
operator|--
name|cnt
control|)
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|ata
operator|->
name|port
operator|+
name|AR_STATUS
argument_list|)
operator|&
name|ARS_DRQ
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|ac
operator|->
name|result
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NWDC&& ATAPI */
end_comment

end_unit

