begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
specifier|static
name|int
name|wdtest
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)wx.c	7.2 (Berkeley) 5/9/91  *	$Id: wx.c,v 1.3 1993/11/03 18:04:15 nate Exp $  */
end_comment

begin_comment
comment|/* TODO:peel out buffer at low ipl, speed improvement */
end_comment

begin_include
include|#
directive|include
file|"wx.h"
end_include

begin_if
if|#
directive|if
name|NWX
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"dkbad.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"disklabel.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/icu.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/wxreg.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_define
define|#
directive|define
name|_NWD
value|(NWX - 1)
end_define

begin_comment
comment|/* One is for the controller XXX 31 Jul 92*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|WDCTIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|WDCTIMEOUT
value|10000000
end_define

begin_comment
comment|/* arbitrary timeout for drive ready waits */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RETRIES
value|5
end_define

begin_comment
comment|/* number of retries before giving up */
end_comment

begin_define
define|#
directive|define
name|RECOVERYTIME
value|500000
end_define

begin_comment
comment|/* usec for controller to recover after err */
end_comment

begin_define
define|#
directive|define
name|MAXTRANSFER
value|32
end_define

begin_comment
comment|/* max size of transfer in page clusters */
end_comment

begin_define
define|#
directive|define
name|wdnoreloc
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x80)
end_define

begin_comment
comment|/* ignore partition table */
end_comment

begin_define
define|#
directive|define
name|wddospart
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x40)
end_define

begin_comment
comment|/* use dos partitions */
end_comment

begin_define
define|#
directive|define
name|wdunit
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev)& 0x38)>> 3)
end_define

begin_define
define|#
directive|define
name|wdpart
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)& 0x7)
end_define

begin_define
define|#
directive|define
name|makewddev
parameter_list|(
name|maj
parameter_list|,
name|unit
parameter_list|,
name|part
parameter_list|)
value|(makedev(maj,((unit<<3)+part)))
end_define

begin_define
define|#
directive|define
name|WDRAW
value|3
end_define

begin_comment
comment|/* 'd' partition isn't a partition! */
end_comment

begin_define
define|#
directive|define
name|b_cylin
value|b_resid
end_define

begin_comment
comment|/* cylinder number for doing IO to */
end_comment

begin_comment
comment|/* shares an entry in the buf struct */
end_comment

begin_comment
comment|/*  * Drive states.  Used to initialize drive.  */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|0
end_define

begin_comment
comment|/* disk is closed. */
end_comment

begin_define
define|#
directive|define
name|WANTOPEN
value|1
end_define

begin_comment
comment|/* open requested, not started */
end_comment

begin_define
define|#
directive|define
name|RECAL
value|2
end_define

begin_comment
comment|/* doing restore */
end_comment

begin_define
define|#
directive|define
name|OPEN
value|3
end_define

begin_comment
comment|/* done with open */
end_comment

begin_comment
comment|/*  * The structure of a disk drive.  */
end_comment

begin_struct
struct|struct
name|disk
block|{
name|long
name|dk_bc
decl_stmt|;
comment|/* byte count left */
name|short
name|dk_skip
decl_stmt|;
comment|/* blocks already transferred */
name|char
name|dk_unit
decl_stmt|;
comment|/* physical unit number */
name|char
name|dk_state
decl_stmt|;
comment|/* control state */
name|u_char
name|dk_status
decl_stmt|;
comment|/* copy of status reg. */
name|u_char
name|dk_error
decl_stmt|;
comment|/* copy of error reg. */
name|short
name|dk_port
decl_stmt|;
comment|/* i/o port base */
name|u_long
name|dk_copenpart
decl_stmt|;
comment|/* character units open on this drive */
name|u_long
name|dk_bopenpart
decl_stmt|;
comment|/* block units open on this drive */
name|u_long
name|dk_openpart
decl_stmt|;
comment|/* all units open on this drive */
name|short
name|dk_wlabel
decl_stmt|;
comment|/* label writable? */
name|short
name|dk_flags
decl_stmt|;
comment|/* drive characteistics found */
define|#
directive|define
name|DKFL_DOSPART
value|0x00001
comment|/* has DOS partition table */
define|#
directive|define
name|DKFL_SINGLE
value|0x00004
comment|/* sector at a time mode */
define|#
directive|define
name|DKFL_ERROR
value|0x00008
comment|/* processing a disk error */
define|#
directive|define
name|DKFL_BSDLABEL
value|0x00010
comment|/* has a BSD disk label */
define|#
directive|define
name|DKFL_BADSECT
value|0x00020
comment|/* has a bad144 badsector table */
define|#
directive|define
name|DKFL_WRITEPROT
value|0x00040
comment|/* manual unit write protect */
define|#
directive|define
name|DKFL_LABELLING
value|0x00080
comment|/* readdisklabel() in progress */
name|struct
name|wdparams
name|dk_params
decl_stmt|;
comment|/* ESDI/IDE drive/controller parameters */
name|struct
name|disklabel
name|dk_dd
decl_stmt|;
comment|/* device configuration data */
name|struct
name|dos_partition
name|dk_dospartitions
index|[
name|NDOSPART
index|]
decl_stmt|;
comment|/* DOS view of disk */
name|struct
name|dkbad
name|dk_bad
decl_stmt|;
comment|/* bad sector table */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|disk
modifier|*
name|wddrives
index|[
name|_NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of units */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|buf
name|wdtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|buf
name|wdutab
index|[
name|_NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of queue per drive */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|buf
name|rwdbuf
index|[
name|_NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffers for raw IO */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|long
name|wdxfer
index|[
name|_NWD
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of transfers */
end_comment

begin_function_decl
specifier|static
name|int
name|wdprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wdustart
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wdstart
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdcontrol
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdcommand
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|u_int
name|cylinder
parameter_list|,
name|u_int
name|head
parameter_list|,
name|u_int
name|sector
parameter_list|,
name|u_int
name|count
parameter_list|,
name|u_int
name|command
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdsetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdwsetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdgetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wderror
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdreset
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wdsleep
parameter_list|(
name|char
modifier|*
name|wmesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdunwedge
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wdwait
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|u_char
name|bits_wanted
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|wxdriver
init|=
block|{
name|wdprobe
block|,
name|wdattach
block|,
literal|"wd"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Probe for controller.  */
end_comment

begin_function
specifier|static
name|int
name|wdprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|int
name|u
decl_stmt|;
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|wdc
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|_NWD
condition|)
comment|/* 31 Jul 92*/
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|disk
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|disk
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|du
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 31 Jul 92*/
name|du
operator|->
name|dk_unit
operator|=
name|unit
expr_stmt|;
block|}
name|wdc
operator|=
name|du
operator|->
name|dk_port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
comment|/* 	 * Skip probing and resetting the controller if it has already 	 * been successfully done. 	 * XXX - should finish probing for drives (using wdgetctlr) or 	 * only probe for controllers. 	 */
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|_NWD
condition|;
name|u
operator|++
control|)
if|if
condition|(
name|u
operator|!=
name|unit
operator|&&
name|wddrives
index|[
name|u
index|]
operator|!=
name|NULL
operator|&&
name|wddrives
index|[
name|u
index|]
operator|->
name|dk_port
operator|==
name|wdc
condition|)
return|return
operator|(
name|IO_WDCSIZE
operator|)
return|;
comment|/* check if we have registers that work */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
literal|0xa5
argument_list|)
expr_stmt|;
comment|/* wd_cyl_lo is read/write */
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|)
operator|!=
literal|0xa5
condition|)
goto|goto
name|nodevice
goto|;
if|if
condition|(
name|wdreset
argument_list|(
name|du
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|DELAY
argument_list|(
name|RECOVERYTIME
argument_list|)
operator|,
name|wdreset
argument_list|(
name|du
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|nodevice
goto|;
comment|/* execute a controller only command */
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_DIAGNOSE
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nodevice
goto|;
return|return
operator|(
name|IO_WDCSIZE
operator|)
return|;
name|nodevice
label|:
name|free
argument_list|(
name|du
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|wddrives
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach each drive if possible.  */
end_comment

begin_function
specifier|static
name|int
name|wdattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|_NWD
condition|;
name|unit
operator|++
control|)
block|{
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
if|if
condition|(
operator|(
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|disk
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|disk
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|du
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_unit
operator|=
name|unit
expr_stmt|;
name|du
operator|->
name|dk_port
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
block|}
comment|/* print out description of drive, suppressing multiple blanks*/
if|if
condition|(
name|wdgetctlr
argument_list|(
name|du
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|,
name|blank
decl_stmt|;
name|printf
argument_list|(
literal|"wd%d: unit %d type "
argument_list|,
name|unit
argument_list|,
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|blank
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|char
name|c
init|=
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|blank
operator|&&
name|c
operator|==
literal|' '
condition|)
continue|continue;
if|if
condition|(
name|blank
operator|&&
name|c
operator|!=
literal|' '
condition|)
block|{
name|printf
argument_list|(
literal|" %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|blank
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
name|blank
operator|=
literal|1
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|du
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|wddrives
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read/write routine for a buffer.  Finds the proper unit, range checks  * arguments, and schedules the transfer.  Does not wait for the transfer  * to complete.  Multi-page transfers are supported.  All I/O requests must  * be a multiple of a sector in length.  */
end_comment

begin_function
name|void
name|wdstrategy
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
comment|/* Disk unit to do the IO.	*/
name|int
name|unit
init|=
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* valid unit, controller, and request?  */
if|if
condition|(
name|unit
operator|>=
name|_NWD
operator|||
name|bp
operator|->
name|b_blkno
operator|<
literal|0
operator|||
operator|(
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* "soft" write protect check */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_WRITEPROT
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* have partitions and want to use them? */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_BSDLABEL
operator|)
operator|!=
literal|0
operator|&&
name|wdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|!=
name|WDRAW
condition|)
block|{
comment|/* 		 * do bounds checking, adjust transfer. if error, process. 		 * if end of partition, just return 		 */
if|if
condition|(
name|bounds_check_with_label
argument_list|(
name|bp
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
name|du
operator|->
name|dk_wlabel
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* otherwise, process transfer request */
block|}
comment|/* queue transfer on drive, activate drive and controller if idle */
name|dp
operator|=
operator|&
name|wdutab
index|[
name|unit
index|]
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|b_active
operator|==
literal|0
condition|)
name|wdustart
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* start drive */
comment|/* Pick up changes made by readdisklabel(). */
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_LABELLING
operator|&&
name|du
operator|->
name|dk_state
operator|>
name|RECAL
condition|)
block|{
name|wdsleep
argument_list|(
literal|"wdlab"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
block|}
if|if
condition|(
name|wdtab
operator|.
name|b_active
operator|==
literal|0
condition|)
name|wdstart
argument_list|()
expr_stmt|;
comment|/* start controller */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
name|done
label|:
comment|/* toss transfer, we're done early */
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to queue a command to the controller.  The unit's  * request is linked into the active list for the controller.  * If the controller is idle, the transfer is started.  */
end_comment

begin_function
specifier|static
name|void
name|wdustart
parameter_list|(
specifier|register
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
init|=
operator|&
name|wdutab
index|[
name|du
operator|->
name|dk_unit
index|]
decl_stmt|;
comment|/* unit already active? */
if|if
condition|(
name|dp
operator|->
name|b_active
condition|)
return|return;
comment|/* anything to start? */
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return;
comment|/* link onto controller queue */
name|dp
operator|->
name|b_forw
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|wdtab
operator|.
name|b_actf
operator|==
name|NULL
condition|)
name|wdtab
operator|.
name|b_actf
operator|=
name|dp
expr_stmt|;
else|else
name|wdtab
operator|.
name|b_actl
operator|->
name|b_forw
operator|=
name|dp
expr_stmt|;
name|wdtab
operator|.
name|b_actl
operator|=
name|dp
expr_stmt|;
comment|/* mark the drive unit as busy */
name|dp
operator|->
name|b_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Controller startup routine.  This does the calculation, and starts  * a single-sector read or write operation.  Called to start a transfer,  * or from the interrupt routine to continue a multi-sector transfer.  * RESTRICTIONS:  * 1.	The transfer length must be an exact multiple of the sector size.  */
end_comment

begin_function
specifier|static
name|void
name|wdstart
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
comment|/* disk unit for IO */
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|bt_bad
modifier|*
name|bt_ptr
decl_stmt|;
name|long
name|blknum
decl_stmt|,
name|cylin
decl_stmt|,
name|head
decl_stmt|,
name|sector
decl_stmt|;
name|long
name|secpertrk
decl_stmt|,
name|secpercyl
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|wdc
decl_stmt|;
name|loop
label|:
comment|/* is there a drive for the controller to do a transfer with? */
name|dp
operator|=
name|wdtab
operator|.
name|b_actf
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
return|return;
comment|/* is there a transfer to this drive ? if so, link it on 	   the controller's queue */
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|wdtab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* obtain controller and drive information */
name|unit
operator|=
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
comment|/* if not really a transfer, do control operations specially */
if|if
condition|(
name|du
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
block|{
if|if
condition|(
name|du
operator|->
name|dk_state
operator|!=
name|WANTOPEN
condition|)
name|printf
argument_list|(
literal|"wd%d: wdstart: weird dk_state %d\n"
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|du
operator|->
name|dk_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdcontrol
argument_list|(
name|bp
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"wd%d: wdstart: wdcontrol returned nonzero, state = %d\n"
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|du
operator|->
name|dk_state
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* calculate transfer details */
name|blknum
operator|=
name|bp
operator|->
name|b_blkno
operator|+
name|du
operator|->
name|dk_skip
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"wd%d: wdstart: %s %d@%d; map "
argument_list|,
name|unit
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
literal|"read"
else|:
literal|"write"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %d)%x"
argument_list|,
name|du
operator|->
name|dk_skip
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_altsts
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|=
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
condition|)
name|du
operator|->
name|dk_bc
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|lp
operator|=
operator|&
name|du
operator|->
name|dk_dd
expr_stmt|;
name|secpertrk
operator|=
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|secpercyl
operator|=
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_BSDLABEL
operator|)
operator|!=
literal|0
operator|&&
name|wdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|!=
name|WDRAW
condition|)
name|blknum
operator|+=
name|lp
operator|->
name|d_partitions
index|[
name|wdpart
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|p_offset
expr_stmt|;
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
comment|/*  	 * See if the current block is in the bad block list. 	 * (If we have one, and not formatting.) 	 */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_SINGLE
operator||
name|DKFL_BADSECT
operator|)
operator|)
comment|/* 19 Aug 92*/
operator|==
operator|(
name|DKFL_SINGLE
operator||
name|DKFL_BADSECT
operator|)
condition|)
for|for
control|(
name|bt_ptr
operator|=
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
init|;
name|bt_ptr
operator|->
name|bt_cyl
operator|!=
literal|0xffff
condition|;
name|bt_ptr
operator|++
control|)
block|{
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|>
name|cylin
condition|)
comment|/* Sorted list, and we passed our cylinder. quit. */
break|break;
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|==
name|cylin
operator|&&
name|bt_ptr
operator|->
name|bt_trksec
operator|==
operator|(
name|head
operator|<<
literal|8
operator|)
operator|+
name|sector
condition|)
block|{
comment|/* 			 * Found bad block.  Calculate new block addr. 			 * This starts at the end of the disk (skip the 			 * last track which is used for the bad block list), 			 * and works backwards to the front of the disk. 			 */
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"--- badblock code -> Old = %d; "
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * XXX the offset of the bad sector table ought 			 * to be stored in the in-core copy of the table. 			 */
define|#
directive|define
name|BAD144_PART
value|2
comment|/* XXX scattered magic numbers */
define|#
directive|define
name|BSD_PART
value|0
comment|/* XXX should be 2 but bad144.c uses 0 */
if|if
condition|(
name|lp
operator|->
name|d_partitions
index|[
name|BSD_PART
index|]
operator|.
name|p_offset
operator|!=
literal|0
condition|)
name|blknum
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|BAD144_PART
index|]
operator|.
name|p_offset
operator|+
name|lp
operator|->
name|d_partitions
index|[
name|BAD144_PART
index|]
operator|.
name|p_size
expr_stmt|;
else|else
name|blknum
operator|=
name|lp
operator|->
name|d_secperunit
expr_stmt|;
name|blknum
operator|-=
name|lp
operator|->
name|d_nsectors
operator|+
operator|(
name|bt_ptr
operator|-
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
operator|)
operator|+
literal|1
expr_stmt|;
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"new = %d\n"
argument_list|,
name|blknum
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
name|wdtab
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
comment|/* mark controller active */
comment|/* if starting a multisector transfer, or doing single transfers */
if|if
condition|(
name|du
operator|->
name|dk_skip
operator|==
literal|0
operator|||
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
operator|)
condition|)
block|{
name|int
name|command
decl_stmt|;
name|u_int
name|count
decl_stmt|;
if|if
condition|(
name|wdtab
operator|.
name|b_errcnt
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
name|du
operator|->
name|dk_bc
operator|+=
name|DEV_BSIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|B_FORMAT
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FORMAT
condition|)
block|{
name|command
operator|=
name|WDCC_FORMAT
expr_stmt|;
name|count
operator|=
name|lp
operator|->
name|d_nsectors
expr_stmt|;
name|sector
operator|=
name|lp
operator|->
name|d_gap3
operator|-
literal|1
expr_stmt|;
comment|/* + 1 later */
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
condition|)
name|count
operator|=
literal|1
expr_stmt|;
else|else
name|count
operator|=
name|howmany
argument_list|(
name|du
operator|->
name|dk_bc
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
name|command
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|WDCC_READ
else|:
name|WDCC_WRITE
expr_stmt|;
block|}
comment|/* 		 * XXX this loop may never terminate.  The code to handle 		 * counting down of retries and eventually failing the i/o is 		 * in wdintr() and we can't get there from here. 		 */
if|if
condition|(
name|wdtest
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|--
name|wdtest
operator|==
literal|0
condition|)
block|{
name|wdtest
operator|=
literal|100
expr_stmt|;
name|printf
argument_list|(
literal|"dummy wdunwedge\n"
argument_list|)
expr_stmt|;
name|wdunwedge
argument_list|(
name|du
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
name|cylin
argument_list|,
name|head
argument_list|,
name|sector
argument_list|,
name|count
argument_list|,
name|command
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdstart: timeout waiting to send command"
argument_list|)
expr_stmt|;
name|wdunwedge
argument_list|(
name|du
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"sector %d cylin %d head %d addr %x sts %x\n"
argument_list|,
name|sector
argument_list|,
name|cylin
argument_list|,
name|head
argument_list|,
name|addr
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_altsts
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* if this is a read operation, just go away until it's done.	*/
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
return|return;
comment|/* ready to send data?	*/
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdstart: timeout waiting for DRQ"
argument_list|)
expr_stmt|;
comment|/* 		 * XXX what do we do now?  If we've just issued the command, 		 * then we can treat this failure the same as a command 		 * failure.  But if we are continuing a multi-sector write, 		 * the command was issued ages ago, so we can't simply 		 * restart it. 		 * 		 * XXX we waste a lot of time unnecessarily translating 		 * block numbers to cylin/head/sector for continued i/o's. 		 */
block|}
comment|/* then send it! */
name|outsw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
name|addr
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
argument_list|,
name|DEV_BSIZE
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_bc
operator|-=
name|DEV_BSIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Interrupt routine for the controller.  Acknowledge the interrupt, check for  * errors on the current operation, mark it done if necessary, and start  * the next request.  Also check for a partially done transfer, and  * continue with the next chunk if so.  */
end_comment

begin_function
name|void
name|wdintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|wdc
decl_stmt|;
if|if
condition|(
operator|!
name|wdtab
operator|.
name|b_active
condition|)
block|{
name|printf
argument_list|(
literal|"wd%d: extra interrupt\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|dp
operator|=
name|wdtab
operator|.
name|b_actf
expr_stmt|;
name|bp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
name|du
operator|=
name|wddrives
index|[
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdintr: timeout waiting for status"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_status
operator||=
name|WDCS_ERR
expr_stmt|;
comment|/* XXX */
block|}
comment|/* is it not a transfer, but a control operation? */
if|if
condition|(
name|du
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
block|{
name|wdtab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|wdcontrol
argument_list|(
name|bp
argument_list|)
condition|)
name|wdstart
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* have we an error? */
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
operator|(
name|WDCS_ERR
operator||
name|WDCS_ECCCOR
operator|)
condition|)
block|{
name|oops
label|:
ifdef|#
directive|ifdef
name|WDDEBUG
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdintr"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_SINGLE
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_ERROR
expr_stmt|;
goto|goto
name|outt
goto|;
block|}
ifdef|#
directive|ifdef
name|B_FORMAT
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FORMAT
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
comment|/* 17 Sep 92*/
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
endif|#
directive|endif
comment|/* error or error correction? */
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
name|WDCS_ERR
condition|)
block|{
if|if
condition|(
operator|++
name|wdtab
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
block|{
name|wdtab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"hard error"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
comment|/* 17 Sep 92*/
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* flag the error */
block|}
block|}
else|else
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"soft ecc"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this was a successful read operation, fetch the data. 	 */
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_READ
operator||
name|B_ERROR
operator|)
operator|)
operator|==
name|B_READ
operator|)
operator|&&
name|wdtab
operator|.
name|b_active
condition|)
block|{
name|int
name|chk
decl_stmt|,
name|dummy
decl_stmt|;
name|chk
operator|=
name|min
argument_list|(
name|DEV_BSIZE
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
name|du
operator|->
name|dk_bc
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ready to receive data? */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_status
operator|&
operator|(
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
operator|)
operator|)
operator|!=
operator|(
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
operator|)
condition|)
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdintr: read intr arrived early"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdintr: read error detected late"
argument_list|)
expr_stmt|;
goto|goto
name|oops
goto|;
block|}
comment|/* suck in data */
name|insw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|du
operator|->
name|dk_skip
operator|*
name|DEV_BSIZE
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_bc
operator|-=
name|chk
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
expr_stmt|;
comment|/* for obselete fractional sector reads */
while|while
condition|(
name|chk
operator|++
operator|<
literal|256
condition|)
name|insw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
operator|&
name|dummy
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|wdxfer
index|[
name|du
operator|->
name|dk_unit
index|]
operator|++
expr_stmt|;
name|outt
label|:
if|if
condition|(
name|wdtab
operator|.
name|b_active
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_skip
operator|++
expr_stmt|;
comment|/* Add to successful sectors. */
if|if
condition|(
name|wdtab
operator|.
name|b_errcnt
condition|)
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"soft error"
argument_list|)
expr_stmt|;
name|wdtab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
comment|/* see if more to transfer */
if|if
condition|(
name|du
operator|->
name|dk_bc
operator|>
literal|0
operator|&&
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|wdtab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|wdstart
argument_list|()
expr_stmt|;
return|return;
comment|/* next chunk is started */
block|}
elseif|else
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
operator|(
name|DKFL_SINGLE
operator||
name|DKFL_ERROR
operator|)
operator|)
operator|==
name|DKFL_ERROR
condition|)
block|{
name|du
operator|->
name|dk_skip
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_ERROR
expr_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_SINGLE
expr_stmt|;
name|wdtab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|wdstart
argument_list|()
expr_stmt|;
return|return;
comment|/* redo xfer sector by sector */
block|}
block|}
ifdef|#
directive|ifdef
name|B_FORMAT
name|done
label|:
empty_stmt|;
endif|#
directive|endif
comment|/* done with this transfer, with or without error */
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_SINGLE
expr_stmt|;
name|wdtab
operator|.
name|b_actf
operator|=
name|dp
operator|->
name|b_forw
expr_stmt|;
name|wdtab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_skip
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_active
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
name|dp
operator|->
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* controller idle */
name|wdtab
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
comment|/* anything more on drive queue? */
if|if
condition|(
name|dp
operator|->
name|b_actf
condition|)
name|wdustart
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* anything more for controller to do? */
if|if
condition|(
name|wdtab
operator|.
name|b_actf
condition|)
name|wdstart
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a drive.  */
end_comment

begin_function
name|int
name|wdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|unit
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|part
init|=
name|wdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|mask
init|=
literal|1
operator|<<
name|part
decl_stmt|;
name|struct
name|partition
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|struct
name|disklabel
name|save_label
decl_stmt|;
name|unit
operator|=
name|wdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|_NWD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|du
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
while|while
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_LABELLING
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|du
operator|->
name|dk_flags
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|,
literal|"wdopen"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_BSDLABEL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * wdtab.b_active != 0 implies wdutab[unit].b_actf == NULL (?) 		 * so the following guards most things (until the next i/o). 		 * It doesn't guard against a new i/o starting and being 		 * affected by the label being changed.  Sigh. 		 */
name|wdsleep
argument_list|(
literal|"wdopn1"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_LABELLING
operator||
name|DKFL_WRITEPROT
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
name|wdutab
index|[
name|unit
index|]
operator|.
name|b_actf
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Read label using WDRAW partition. 		 * 		 * If the drive has an MBR, then the current geometry (from 		 * wdgetctlr()) is used to read it; then the BIOS/DOS 		 * geometry is inferred and used to read the label off the 		 * 'c' partition.  Otherwise the label is read using the 		 * current geometry.  The label gives the final geometry. 		 * If bad sector handling is enabled, then this geometry 		 * is used to read the bad sector table.  The geometry 		 * changes occur inside readdisklabel() and are propagated 		 * to the driver by resetting the state machine. 		 */
name|save_label
operator|=
name|du
operator|->
name|dk_dd
expr_stmt|;
define|#
directive|define
name|WDSTRATEGY
value|((int (*)(struct buf *)) wdstrategy)
comment|/* XXX */
name|msg
operator|=
name|readdisklabel
argument_list|(
name|makewddev
argument_list|(
name|major
argument_list|(
name|dev
argument_list|)
argument_list|,
name|unit
argument_list|,
name|WDRAW
argument_list|)
argument_list|,
name|WDSTRATEGY
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
name|du
operator|->
name|dk_dospartitions
argument_list|,
operator|&
name|du
operator|->
name|dk_bad
argument_list|,
operator|(
expr|struct
name|buf
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_LABELLING
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|du
operator|->
name|dk_dd
operator|=
name|save_label
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wd%d: cannot find label (%s)\n"
argument_list|,
name|unit
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|!=
name|WDRAW
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX needs translation */
block|}
else|else
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_BSDLABEL
expr_stmt|;
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_WRITEPROT
expr_stmt|;
if|if
condition|(
name|du
operator|->
name|dk_dd
operator|.
name|d_flags
operator|&
name|D_BADSECT
condition|)
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_BADSECT
expr_stmt|;
block|}
comment|/* Pick up changes made by readdisklabel(). */
name|wdsleep
argument_list|(
literal|"wdopn2"
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
block|}
comment|/*          * Warn if a partion is opened          * that overlaps another partition which is open          * unless one is the "raw" partition (whole disk).          */
if|if
condition|(
operator|(
name|du
operator|->
name|dk_openpart
operator|&
name|mask
operator|)
operator|==
literal|0
comment|/*&& part != RAWPART*/
operator|&&
name|part
operator|!=
name|WDRAW
condition|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|pp
operator|=
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
expr_stmt|;
name|start
operator|=
name|pp
operator|->
name|p_offset
expr_stmt|;
name|end
operator|=
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
init|;
name|pp
operator|<
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|du
operator|->
name|dk_dd
operator|.
name|d_npartitions
index|]
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_offset
operator|+
name|pp
operator|->
name|p_size
operator|<=
name|start
operator|||
name|pp
operator|->
name|p_offset
operator|>=
name|end
condition|)
continue|continue;
if|if
condition|(
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|==
name|WDRAW
condition|)
continue|continue;
if|if
condition|(
name|du
operator|->
name|dk_openpart
operator|&
operator|(
literal|1
operator|<<
operator|(
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|)
operator|)
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"wd%d%c: overlaps open partition (%c)\n"
argument_list|,
name|unit
argument_list|,
name|part
operator|+
literal|'a'
argument_list|,
name|pp
operator|-
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|part
operator|>=
name|du
operator|->
name|dk_dd
operator|.
name|d_npartitions
operator|&&
name|part
operator|!=
name|WDRAW
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* insure only one open at a time */
name|du
operator|->
name|dk_openpart
operator||=
name|mask
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|du
operator|->
name|dk_copenpart
operator||=
name|mask
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|du
operator|->
name|dk_bopenpart
operator||=
name|mask
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement operations other than read/write.  * Called from wdstart or wdintr during opens and formats.  * Uses finite-state-machine to track progress of operation in progress.  * Returns 0 if operation still in progress, 1 if completed.  */
end_comment

begin_function
specifier|static
name|int
name|wdcontrol
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|du
operator|=
name|wddrives
index|[
name|wdunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
expr_stmt|;
switch|switch
condition|(
name|du
operator|->
name|dk_state
condition|)
block|{
case|case
name|WANTOPEN
case|:
name|tryagainrecal
label|:
name|wdtab
operator|.
name|b_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdcontrol: wdcommand failed"
argument_list|)
expr_stmt|;
goto|goto
name|maybe_retry
goto|;
block|}
name|du
operator|->
name|dk_state
operator|=
name|RECAL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RECAL
case|:
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
name|WDCS_ERR
operator|||
name|wdsetctlr
argument_list|(
name|du
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
name|bp
argument_list|,
name|du
argument_list|,
literal|"wdcontrol: recal failed"
argument_list|)
expr_stmt|;
name|maybe_retry
label|:
if|if
condition|(
name|du
operator|->
name|dk_status
operator|&
name|WDCS_ERR
condition|)
name|wdunwedge
argument_list|(
name|du
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|wdtab
operator|.
name|b_errcnt
operator|<
name|RETRIES
condition|)
block|{
name|du
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
goto|goto
name|tryagainrecal
goto|;
block|}
name|bp
operator|->
name|b_error
operator|=
name|ENXIO
expr_stmt|;
comment|/* XXX needs translation */
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|wdtab
operator|.
name|b_errcnt
operator|=
literal|0
expr_stmt|;
name|du
operator|->
name|dk_state
operator|=
name|OPEN
expr_stmt|;
comment|/* 		 * The rest of the initialization can be done 		 * by normal means. 		 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"wdcontrol"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait uninterruptibly until controller is not busy, then send it a command.  * The wait usually terminates immediately because we waited for the previous  * command to terminate.  */
end_comment

begin_function
specifier|static
name|int
name|wdcommand
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|u_int
name|cylinder
parameter_list|,
name|u_int
name|head
parameter_list|,
name|u_int
name|sector
parameter_list|,
name|u_int
name|count
parameter_list|,
name|u_int
name|command
parameter_list|)
block|{
name|u_int
name|wdc
decl_stmt|;
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_precomp
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_precompcyl
operator|/
literal|4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
name|cylinder
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|,
name|cylinder
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|du
operator|->
name|dk_unit
operator|<<
literal|4
operator|)
operator||
name|head
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX give drive time to see change */
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|,
name|sector
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_command
argument_list|,
name|command
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * issue IDC to drive to tell it just what geometry it is to be.  */
end_comment

begin_function
specifier|static
name|int
name|wdsetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"wd%d: wdsetctlr C %lu H %lu S %lu\n"
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
argument_list|,
name|WDCC_IDC
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wdsetctlr failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait until driver is inactive, then set up controller.  */
end_comment

begin_function
specifier|static
name|int
name|wdwsetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|int
name|stat
decl_stmt|;
name|int
name|x
decl_stmt|;
name|wdsleep
argument_list|(
literal|"wdwset"
argument_list|)
expr_stmt|;
name|x
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|stat
operator|=
name|wdsetctlr
argument_list|(
name|du
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * issue READP to drive to ask it what it is.  */
end_comment

begin_function
specifier|static
name|int
name|wdgetctlr
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|tb
index|[
name|DEV_BSIZE
index|]
decl_stmt|;
name|struct
name|wdparams
modifier|*
name|wp
decl_stmt|;
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_READP
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
operator||
name|WDCS_DRQ
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|MFM
comment|/* Old drives don't support WDCC_READP.  Try a seek to 0. */
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
operator|!=
literal|0
operator|||
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
comment|/* IDE */
comment|/* 		 * Some IDE drives return trash if there is not a unit 1 		 * out there, need to make sure that it is READY and not BUSY 		 * before you assume it is there ! 		 */
name|outb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|du
operator|->
name|dk_unit
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_status
argument_list|)
operator|&
operator|(
name|WDCS_READY
operator||
name|WDCS_BUSY
operator|)
operator|)
operator|!=
name|WDCS_READY
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* MFM */
comment|/* Fake minimal drive geometry for reading the MBR or label. */
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|=
literal|17
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
literal|1
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|=
literal|1
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|=
literal|17
expr_stmt|;
comment|/* 		 * Fake some more of the label for printing by disklabel(1) 		 * in case there is no real label. 		 */
name|du
operator|->
name|dk_dd
operator|.
name|d_type
operator|=
name|DTYPE_ST506
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_subtype
operator||=
name|DSTYPE_GEOMETRY
expr_stmt|;
name|strncpy
argument_list|(
name|du
operator|->
name|dk_dd
operator|.
name|d_typename
argument_list|,
literal|"Fake geometry"
argument_list|,
sizeof|sizeof
name|du
operator|->
name|dk_dd
operator|.
name|d_typename
argument_list|)
expr_stmt|;
comment|/* Fake the model name for printing by wdattach(). */
name|strncpy
argument_list|(
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|,
literal|"Unknown Type"
argument_list|,
sizeof|sizeof
name|du
operator|->
name|dk_params
operator|.
name|wdp_model
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* obtain parameters */
name|wp
operator|=
operator|&
name|du
operator|->
name|dk_params
expr_stmt|;
name|insw
argument_list|(
name|du
operator|->
name|dk_port
operator|+
name|wd_data
argument_list|,
name|tb
argument_list|,
sizeof|sizeof
argument_list|(
name|tb
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tb
argument_list|,
name|wp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wdparams
argument_list|)
argument_list|)
expr_stmt|;
comment|/* shuffle string byte order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|wp
operator|->
name|wdp_model
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|u_short
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|u_short
operator|*
operator|)
operator|(
name|wp
operator|->
name|wdp_model
operator|+
name|i
operator|)
expr_stmt|;
operator|*
name|p
operator|=
name|ntohs
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WDDEBUG
name|printf
argument_list|(
literal|"\nwdgetctlr wd%d: gc %x cyl %d trk %d sec %d type %d sz %d model %s\n"
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|wp
operator|->
name|wdp_config
argument_list|,
name|wp
operator|->
name|wdp_fixedcyl
operator|+
name|wp
operator|->
name|wdp_removcyl
argument_list|,
name|wp
operator|->
name|wdp_heads
argument_list|,
name|wp
operator|->
name|wdp_sectors
argument_list|,
name|wp
operator|->
name|wdp_cntype
argument_list|,
name|wp
operator|->
name|wdp_cnsbsz
argument_list|,
name|wp
operator|->
name|wdp_model
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* update disklabel given drive information */
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
operator|=
name|DEV_BSIZE
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ncylinders
operator|=
name|wp
operator|->
name|wdp_fixedcyl
operator|+
name|wp
operator|->
name|wdp_removcyl
comment|/*+- 1*/
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|=
name|wp
operator|->
name|wdp_heads
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|=
name|wp
operator|->
name|wdp_sectors
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_ntracks
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
comment|/* dubious ... */
name|bcopy
argument_list|(
literal|"ESDI/IDE"
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_typename
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|wp
operator|->
name|wdp_model
operator|+
literal|20
argument_list|,
name|du
operator|->
name|dk_dd
operator|.
name|d_packname
argument_list|,
literal|14
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* better ... */
name|du
operator|->
name|dk_dd
operator|.
name|d_type
operator|=
name|DTYPE_ESDI
expr_stmt|;
name|du
operator|->
name|dk_dd
operator|.
name|d_subtype
operator||=
name|DSTYPE_GEOMETRY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|wdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|)
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|part
init|=
name|wdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|mask
init|=
literal|1
operator|<<
name|part
decl_stmt|;
name|du
operator|=
name|wddrives
index|[
name|wdunit
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
comment|/* insure only one open at a time */
name|du
operator|->
name|dk_openpart
operator|&=
operator|~
name|mask
expr_stmt|;
switch|switch
condition|(
name|fmt
condition|)
block|{
case|case
name|S_IFCHR
case|:
name|du
operator|->
name|dk_copenpart
operator|&=
operator|~
name|mask
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|du
operator|->
name|dk_bopenpart
operator|&=
operator|~
name|mask
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|unit
init|=
name|wdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
endif|#
directive|endif
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCSBAD
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|du
operator|->
name|dk_bad
operator|=
operator|*
operator|(
expr|struct
name|dkbad
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
operator|=
name|du
operator|->
name|dk_dd
expr_stmt|;
break|break;
case|case
name|DIOCGPART
case|:
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|disklab
operator|=
operator|&
name|du
operator|->
name|dk_dd
expr_stmt|;
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|part
operator|=
operator|&
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|wdpart
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
break|break;
case|case
name|DIOCSDINFO
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|error
operator|=
name|setdisklabel
argument_list|(
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
argument_list|,
comment|/*(du->dk_flags& DKFL_BSDLABEL) ? du->dk_openpart : */
literal|0
argument_list|,
name|du
operator|->
name|dk_dospartitions
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_BSDLABEL
expr_stmt|;
name|wdwsetctlr
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* XXX - check */
block|}
break|break;
case|case
name|DIOCWLABEL
case|:
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_WRITEPROT
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
name|du
operator|->
name|dk_wlabel
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|DIOCWDINFO
case|:
name|du
operator|->
name|dk_flags
operator|&=
operator|~
name|DKFL_WRITEPROT
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|setdisklabel
argument_list|(
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
argument_list|,
comment|/*(du->dk_flags& DKFL_BSDLABEL) ? du->dk_openpart :*/
literal|0
argument_list|,
name|du
operator|->
name|dk_dospartitions
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|wlab
decl_stmt|;
name|du
operator|->
name|dk_flags
operator||=
name|DKFL_BSDLABEL
expr_stmt|;
name|wdwsetctlr
argument_list|(
name|du
argument_list|)
expr_stmt|;
comment|/* XXX - check */
comment|/* simulate opening partition 0 so write succeeds */
name|du
operator|->
name|dk_openpart
operator||=
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
comment|/* XXX */
name|wlab
operator|=
name|du
operator|->
name|dk_wlabel
expr_stmt|;
name|du
operator|->
name|dk_wlabel
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|writedisklabel
argument_list|(
name|dev
argument_list|,
name|WDSTRATEGY
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|,
name|du
operator|->
name|dk_dospartitions
argument_list|)
expr_stmt|;
name|du
operator|->
name|dk_openpart
operator|=
name|du
operator|->
name|dk_copenpart
operator||
name|du
operator|->
name|dk_bopenpart
expr_stmt|;
name|du
operator|->
name|dk_wlabel
operator|=
name|wlab
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|notyet
case|case
name|DIOCGDINFOP
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|*
operator|)
name|addr
operator|=
operator|&
operator|(
name|du
operator|->
name|dk_dd
operator|)
expr_stmt|;
break|break;
case|case
name|DIOCWFORMAT
case|:
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EBADF
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|format_op
modifier|*
name|fop
decl_stmt|;
name|fop
operator|=
operator|(
expr|struct
name|format_op
operator|*
operator|)
name|addr
expr_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
name|fop
operator|->
name|df_buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|fop
operator|->
name|df_count
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|fop
operator|->
name|df_startblk
operator|*
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
name|error
operator|=
name|physio
argument_list|(
name|wdformat
argument_list|,
operator|&
name|rwdbuf
index|[
name|unit
index|]
argument_list|,
literal|0
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|minphys
argument_list|,
operator|&
name|auio
argument_list|)
expr_stmt|;
name|fop
operator|->
name|df_count
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
name|fop
operator|->
name|df_reg
index|[
literal|0
index|]
operator|=
name|du
operator|->
name|dk_status
expr_stmt|;
name|fop
operator|->
name|df_reg
index|[
literal|1
index|]
operator|=
name|du
operator|->
name|dk_error
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|B_FORMAT
end_ifdef

begin_function
name|int
name|wdformat
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_FORMAT
expr_stmt|;
return|return
operator|(
name|wdstrategy
argument_list|(
name|bp
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|wdsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|wdunit
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|part
init|=
name|wdpart
argument_list|(
name|dev
argument_list|)
decl_stmt|,
name|val
decl_stmt|;
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|_NWD
condition|)
comment|/* 31 Jul 92*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|du
operator|==
literal|0
operator|||
name|du
operator|->
name|dk_state
operator|==
name|CLOSED
condition|)
name|val
operator|=
name|wdopen
argument_list|(
name|makewddev
argument_list|(
name|major
argument_list|(
name|dev
argument_list|)
argument_list|,
name|unit
argument_list|,
name|WDRAW
argument_list|)
argument_list|,
name|FREAD
argument_list|,
name|S_IFBLK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|du
operator|==
literal|0
operator|||
name|val
operator|!=
literal|0
operator|||
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_WRITEPROT
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
operator|(
name|int
operator|)
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|vmmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* poor name! */
end_comment

begin_function
name|int
name|wddump
parameter_list|(
name|dev_t
name|dev
parameter_list|)
comment|/* dump core after a system crash */
block|{
specifier|register
name|struct
name|disk
modifier|*
name|du
decl_stmt|;
comment|/* disk unit to do the IO */
ifdef|#
directive|ifdef
name|notyet
specifier|register
name|struct
name|bt_bad
modifier|*
name|bt_ptr
decl_stmt|;
endif|#
directive|endif
name|long
name|num
decl_stmt|;
comment|/* number of sectors to write */
name|int
name|unit
decl_stmt|,
name|part
decl_stmt|,
name|wdc
decl_stmt|;
name|long
name|blkoff
decl_stmt|,
name|blknum
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|long
name|blkcnt
decl_stmt|;
endif|#
directive|endif
name|long
name|cylin
decl_stmt|,
name|head
decl_stmt|,
name|sector
decl_stmt|;
name|long
name|secpertrk
decl_stmt|,
name|secpercyl
decl_stmt|,
name|nblocks
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
specifier|extern
name|int
name|Maxmem
decl_stmt|;
specifier|static
name|wddoingadump
operator|=
literal|0
expr_stmt|;
specifier|extern
name|caddr_t
name|CADDR1
decl_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* starting address */
comment|/* toss any characters present prior to dump */
while|while
condition|(
name|sgetc
argument_list|(
literal|1
argument_list|)
condition|)
empty_stmt|;
comment|/* size of memory to dump */
name|num
operator|=
name|Maxmem
expr_stmt|;
name|unit
operator|=
name|wdunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* eventually support floppies? */
name|part
operator|=
name|wdpart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* file system */
comment|/* check for acceptable drive number */
if|if
condition|(
name|unit
operator|>=
name|_NWD
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 31 Jul 92*/
name|du
operator|=
name|wddrives
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|du
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* was it ever initialized ? */
if|if
condition|(
name|du
operator|->
name|dk_state
operator|<
name|OPEN
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|du
operator|->
name|dk_flags
operator|&
name|DKFL_WRITEPROT
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
comment|/* Convert to disk sectors */
name|num
operator|=
operator|(
name|u_long
operator|)
name|num
operator|*
name|NBPG
operator|/
name|du
operator|->
name|dk_dd
operator|.
name|d_secsize
expr_stmt|;
comment|/* check if controller active */
comment|/*if (wdtab.b_active) return(EFAULT); */
if|if
condition|(
name|wddoingadump
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|secpertrk
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
expr_stmt|;
name|secpercyl
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_secpercyl
expr_stmt|;
name|nblocks
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
expr_stmt|;
name|blkoff
operator|=
name|du
operator|->
name|dk_dd
operator|.
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
expr_stmt|;
comment|/*pg("xunit %x, nblocks %d, dumplo %d num %d\n", part,nblocks,dumplo,num);*/
comment|/* check transfer bounds against partition size */
if|if
condition|(
operator|(
name|dumplo
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|dumplo
operator|+
name|num
operator|)
operator|>
name|nblocks
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|#
directive|if
literal|0
block|wdtab.b_active = 1;
comment|/* mark controller active for if we 					   panic during the dump */
endif|#
directive|endif
name|wddoingadump
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|100000
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_BUSY
operator|)
operator|&&
operator|(
name|i
operator|--
operator|>
literal|0
operator|)
condition|)
empty_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_BUSY
condition|)
empty_stmt|;
comment|/* some compaq controllers require this ... */
name|wdsetctlr
argument_list|(
name|du
argument_list|)
expr_stmt|;
name|blknum
operator|=
name|dumplo
operator|+
name|blkoff
expr_stmt|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|blkcnt
operator|>
name|MAXTRANSFER
condition|)
name|blkcnt
operator|=
name|MAXTRANSFER
expr_stmt|;
if|if
condition|(
operator|(
name|blknum
operator|+
name|blkcnt
operator|-
literal|1
operator|)
operator|/
name|secpercyl
operator|!=
name|blknum
operator|/
name|secpercyl
condition|)
name|blkcnt
operator|=
name|secpercyl
operator|-
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
expr_stmt|;
comment|/* keep transfer within current cylinder */
endif|#
directive|endif
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
name|CADDR1
argument_list|,
name|trunc_page
argument_list|(
name|addr
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* compute disk address */
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/*  		 * See if the current block is in the bad block list. 		 * (If we have one.) 		 */
for|for
control|(
name|bt_ptr
operator|=
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
init|;
name|bt_ptr
operator|->
name|bt_cyl
operator|!=
operator|-
literal|1
condition|;
name|bt_ptr
operator|++
control|)
block|{
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|>
name|cylin
condition|)
comment|/* Sorted list, and we passed our cylinder. 					quit. */
break|break;
if|if
condition|(
name|bt_ptr
operator|->
name|bt_cyl
operator|==
name|cylin
operator|&&
name|bt_ptr
operator|->
name|bt_trksec
operator|==
operator|(
name|head
operator|<<
literal|8
operator|)
operator|+
name|sector
condition|)
block|{
comment|/* 			 * Found bad block.  Calculate new block addr. 			 * This starts at the end of the disk (skip the 			 * last track which is used for the bad block list), 			 * and works backwards to the front of the disk. 			 */
comment|/* XXX as usual */
if|if
condition|(
name|lp
operator|->
name|d_partitions
index|[
name|BSD_PART
index|]
operator|.
name|p_offset
operator|!=
literal|0
condition|)
name|blknum
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|BAD144_PART
index|]
operator|.
name|p_offset
operator|+
name|lp
operator|->
name|d_partitions
index|[
name|BAD144_PART
index|]
operator|.
name|p_size
expr_stmt|;
else|else
name|blknum
operator|=
name|lp
operator|->
name|d_secperunit
expr_stmt|;
name|blknum
operator|-=
name|du
operator|->
name|dk_dd
operator|.
name|d_nsectors
operator|+
operator|(
name|bt_ptr
operator|-
name|du
operator|->
name|dk_bad
operator|.
name|bt_bad
operator|)
operator|+
literal|1
expr_stmt|;
name|cylin
operator|=
name|blknum
operator|/
name|secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|blknum
operator|%
name|secpercyl
operator|)
operator|/
name|secpertrk
expr_stmt|;
name|sector
operator|=
name|blknum
operator|%
name|secpertrk
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
name|sector
operator|++
expr_stmt|;
comment|/* origin 1 */
comment|/* select drive.     */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|,
name|WDSD_IBM
operator||
operator|(
name|unit
operator|<<
literal|4
operator|)
operator||
operator|(
name|head
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_READY
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* transfer some blocks */
name|outb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_seccnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|,
name|cylin
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|,
name|cylin
operator|>>
literal|8
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* lets just talk about this first...*/
name|pg
argument_list|(
literal|"sdh 0%o sector %d cyl %d addr 0x%x"
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_sdh
argument_list|)
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_sector
argument_list|)
argument_list|,
name|inb
argument_list|(
name|wdc
operator|+
name|wd_cyl_hi
argument_list|)
operator|*
literal|256
operator|+
name|inb
argument_list|(
name|wdc
operator|+
name|wd_cyl_lo
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|wdc
operator|+
name|wd_command
argument_list|,
name|WDCC_WRITE
argument_list|)
expr_stmt|;
comment|/* Ready to send data?	*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_DRQ
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_ERR
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|outsw
argument_list|(
name|wdc
operator|+
name|wd_data
argument_list|,
name|CADDR1
operator|+
operator|(
operator|(
name|int
operator|)
name|addr
operator|&
operator|(
name|NBPG
operator|-
literal|1
operator|)
operator|)
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_ERR
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Check data request (should be done).         */
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_DRQ
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* wait for completion */
for|for
control|(
name|i
operator|=
name|WDCTIMEOUT
init|;
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_BUSY
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* error check the xfer */
if|if
condition|(
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
operator|&
name|WDCS_ERR
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|addr
operator|%
operator|(
literal|1024
operator|*
literal|1024
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%ld "
argument_list|,
name|num
operator|/
literal|2048
argument_list|)
expr_stmt|;
comment|/* update block count */
name|num
operator|--
expr_stmt|;
name|blknum
operator|++
expr_stmt|;
operator|(
name|int
operator|)
name|addr
operator|+=
literal|512
expr_stmt|;
comment|/* operator aborting dump? */
if|if
condition|(
name|sgetc
argument_list|(
literal|1
argument_list|)
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wderror
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|char
modifier|*
name|mesg
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"wd%d: %s:"
argument_list|,
name|du
operator|->
name|dk_unit
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
else|else
name|diskerr
argument_list|(
name|bp
argument_list|,
literal|"wd"
argument_list|,
name|mesg
argument_list|,
name|LOG_PRINTF
argument_list|,
name|du
operator|->
name|dk_skip
argument_list|,
operator|&
name|du
operator|->
name|dk_dd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" status %b error %b\n"
argument_list|,
name|du
operator|->
name|dk_status
argument_list|,
name|WDCS_BITS
argument_list|,
name|du
operator|->
name|dk_error
argument_list|,
name|WDERR_BITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the controller.  */
end_comment

begin_function
specifier|static
name|int
name|wdreset
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|int
name|wdc
decl_stmt|;
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
operator|(
name|void
operator|)
name|wdwait
argument_list|(
name|du
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_IDS
operator||
name|WDCTL_RST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_IDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|du
operator|->
name|dk_error
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
operator|)
operator|!=
literal|0x01
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|outb
argument_list|(
name|wdc
operator|+
name|wd_ctlr
argument_list|,
name|WDCTL_4BIT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sleep until driver is inactive.  * This is used only for avoiding rare race conditions, so it is unimportant  * that the sleep may be far too short or too long.  */
end_comment

begin_function
specifier|static
name|void
name|wdsleep
parameter_list|(
name|char
modifier|*
name|wmesg
parameter_list|)
block|{
while|while
condition|(
name|wdtab
operator|.
name|b_active
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|wdtab
operator|.
name|b_active
argument_list|,
name|PZERO
operator|-
literal|1
argument_list|,
name|wmesg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the controller after it has become wedged.  This is different from  * wdreset() so that wdreset() can be used in the probe and so that this  * can restore the geometry .  */
end_comment

begin_function
specifier|static
name|int
name|wdunwedge
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|du1
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* Schedule other drives for recalibration. */
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|_NWD
condition|;
name|unit
operator|++
control|)
if|if
condition|(
operator|(
name|du1
operator|=
name|wddrives
index|[
name|unit
index|]
operator|)
operator|!=
name|NULL
operator|&&
name|du1
operator|!=
name|du
operator|&&
name|du1
operator|->
name|dk_state
operator|>
name|WANTOPEN
condition|)
name|du1
operator|->
name|dk_state
operator|=
name|WANTOPEN
expr_stmt|;
name|DELAY
argument_list|(
name|RECOVERYTIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|wdreset
argument_list|(
name|du
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * XXX - recalibrate current drive now because some callers 		 * aren't prepared to have its state change. 		 */
if|if
condition|(
name|wdcommand
argument_list|(
name|du
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|WDCC_RESTORE
operator||
name|WD_STEP
argument_list|)
operator|==
literal|0
operator|&&
name|wdwait
argument_list|(
name|du
argument_list|,
name|WDCS_READY
operator||
name|WDCS_SEEKCMPLT
argument_list|)
operator|==
literal|0
operator|&&
name|wdsetctlr
argument_list|(
name|du
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|wderror
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
argument_list|,
name|du
argument_list|,
literal|"wdunwedge failed"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wait uninterruptibly until controller is not busy and either certain  * status bits are set or an error has occurred.  * The wait is usually short unless it is for the controller to process  * an entire critical command.  * Return 1 for (possibly stale) controller errors, -1 for timeout errors,  * or 0 for no errors.  * Return controller status in du->dk_status and, if there was a controller  * error, return the error code in du->dk_error.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|min_retries
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|wdwait
parameter_list|(
name|struct
name|disk
modifier|*
name|du
parameter_list|,
name|u_char
name|bits_wanted
parameter_list|)
block|{
name|int
name|retries
decl_stmt|;
name|int
name|wdc
decl_stmt|;
name|u_char
name|status
decl_stmt|;
define|#
directive|define
name|POLLING
value|1000
define|#
directive|define
name|TIMEOUT
value|1000
comment|/* WDCC_DIAGNOSE can take> 300 msec */
name|wdc
operator|=
name|du
operator|->
name|dk_port
expr_stmt|;
name|retries
operator|=
name|POLLING
operator|+
name|TIMEOUT
expr_stmt|;
do|do
block|{
if|if
condition|(
name|min_retries
operator|>
name|retries
operator|||
name|min_retries
operator|==
literal|0
condition|)
name|min_retries
operator|=
name|retries
expr_stmt|;
name|du
operator|->
name|dk_status
operator|=
name|status
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|WDCS_BUSY
operator|)
condition|)
block|{
if|if
condition|(
name|status
operator|&
name|WDCS_ERR
condition|)
block|{
name|du
operator|->
name|dk_error
operator|=
name|inb
argument_list|(
name|wdc
operator|+
name|wd_error
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|bits_wanted
operator|)
operator|==
name|bits_wanted
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|retries
operator|<
name|TIMEOUT
condition|)
comment|/* 			 * Switch to a polling rate of about 1 KHz so that 			 * the timeout is almost machine-independent.  The 			 * controller is taking a long time to respond, so 			 * an extra msec won't matter. 			 */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|retries
operator|!=
literal|0
condition|)
do|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NWD> 0 */
end_comment

end_unit

