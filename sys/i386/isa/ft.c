begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Copyright (c) 1993, 1994 Steve Gerakines  *  *  This is freely redistributable software.  You may do anything you  *  wish with it, so long as the above notice stays intact.  *  *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS  *  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  *  DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,  *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  *  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  *  STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  *  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  *  POSSIBILITY OF SUCH DAMAGE.  *  *  ft.c - QIC-40/80 floppy tape driver  *  $Id: ft.c,v 1.31 1997/02/22 09:36:12 peter Exp $  *  *  01/19/95 ++sg  *  Cleaned up recalibrate/seek code at attach time for FreeBSD 2.x.  *  *  06/07/94 v0.9 ++sg  *  Tape stuck on segment problem should be gone.  Re-wrote buffering  *  scheme.  Added support for drives that do not automatically perform  *  seek load point.  Can handle more wakeup types now and should correctly  *  report most manufacturer names.  Fixed places where unit 0 was being  *  sent to the fdc instead of the actual unit number.  Added ioctl support  *  for an in-core badmap.  *  *  01/26/94 v0.3b - Jim Babb  *  Got rid of the hard coded device selection.  Moved (some of) the  *  static variables into a structure for support of multiple devices.  *  ( still has a way to go for 2 controllers - but closer )  *  Changed the interface with fd.c so we no longer 'steal' it's  *  driver routine vectors.  *  *  10/30/93 v0.3  *  Fixed a couple more bugs.  Reading was sometimes looping when an  *  an error such as address-mark-missing was encountered.  Both  *  reading and writing was having more backup-and-retries than was  *  necessary.  Added support to get hardware info.  Updated for use  *  with FreeBSD.  *  *  09/15/93 v0.2 pl01  *  Fixed a bunch of bugs:  extra isa_dmadone() in async_write() (shouldn't  *  matter), fixed double buffering in async_req(), changed tape_end() in  *  set_fdcmode() to reduce unexpected interrupts, changed end of track  *  processing in async_req(), protected more of ftreq_rw() with an  *  splbio().  Changed some of the ftreq_*() functions so that they wait  *  for inactivity and then go, instead of aborting immediately.  *  *  08/07/93 v0.2 release  *  Shifted from ftstrat to ioctl support for I/O.  Streaming is now much  *  more reliable.  Added internal support for error correction, QIC-40,  *  and variable length tapes.  Random access of segments greatly  *  improved.  Formatting and verification support is close but still  *  incomplete.  *  *  06/03/93 v0.1 Alpha release  *  Hopefully the last re-write.  Many bugs fixed, many remain.  */
end_comment

begin_include
include|#
directive|include
file|"ft.h"
end_include

begin_if
if|#
directive|if
name|NFT
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"fd.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_comment
comment|/* temp. for dkunit() in fdc.h */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ftape.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<pc98/pc98/fdreg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<i386/isa/fdreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/rtc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/fdc.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ftreg.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|ftintr
name|__P
argument_list|(
operator|(
name|ftu_t
name|ftu
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enable or disable debugging messages. */
end_comment

begin_define
define|#
directive|define
name|FTDBGALL
value|0
end_define

begin_comment
comment|/* 1 if you want everything */
end_comment

begin_comment
comment|/*#define DPRT(a) printf a		*/
end_comment

begin_define
define|#
directive|define
name|DPRT
parameter_list|(
name|a
parameter_list|)
end_define

begin_comment
comment|/* Constants private to the driver */
end_comment

begin_define
define|#
directive|define
name|FTPRI
value|(PRIBIO)
end_define

begin_comment
comment|/* sleep priority */
end_comment

begin_define
define|#
directive|define
name|FTNBUFF
value|9
end_define

begin_comment
comment|/* 8 for buffering, 1 for header */
end_comment

begin_comment
comment|/* The following items are needed from the fd driver. */
end_comment

begin_function_decl
specifier|extern
name|int
name|in_fdc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* read fdc registers */
end_comment

begin_function_decl
specifier|extern
name|int
name|out_fdc
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* write fdc registers */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system clock rate */
end_comment

begin_comment
comment|/* Flags in isadev struct */
end_comment

begin_define
define|#
directive|define
name|FT_PROBE
value|0x1
end_define

begin_comment
comment|/* allow for "dangerous" tape probes */
end_comment

begin_comment
comment|/* Type of tape attached */
end_comment

begin_comment
comment|/* use numbers that don't interfere with the possible floppy types */
end_comment

begin_define
define|#
directive|define
name|NO_TYPE
value|0
end_define

begin_comment
comment|/* (same as NO_TYPE in fd.c) */
end_comment

begin_comment
comment|/* F_TAPE_TYPE must match value in fd.c */
end_comment

begin_define
define|#
directive|define
name|F_TAPE_TYPE
value|0x020
end_define

begin_comment
comment|/* bit for ft->types to indicate tape */
end_comment

begin_define
define|#
directive|define
name|FT_NONE
value|(F_TAPE_TYPE | 0)
end_define

begin_comment
comment|/* no method required */
end_comment

begin_define
define|#
directive|define
name|FT_MOUNTAIN
value|(F_TAPE_TYPE | 1)
end_define

begin_comment
comment|/* mountain */
end_comment

begin_define
define|#
directive|define
name|FT_COLORADO
value|(F_TAPE_TYPE | 2)
end_define

begin_comment
comment|/* colorado */
end_comment

begin_define
define|#
directive|define
name|FT_INSIGHT
value|(F_TAPE_TYPE | 3)
end_define

begin_comment
comment|/* insight */
end_comment

begin_comment
comment|/* Mode FDC is currently in: tape or disk */
end_comment

begin_enum
enum|enum
block|{
name|FDC_TAPE_MODE
block|,
name|FDC_DISK_MODE
block|}
enum|;
end_enum

begin_comment
comment|/* Command we are awaiting completion of */
end_comment

begin_enum
enum|enum
block|{
name|FTCMD_NONE
block|,
name|FTCMD_RESET
block|,
name|FTCMD_RECAL
block|,
name|FTCMD_SEEK
block|,
name|FTCMD_READID
block|}
enum|;
end_enum

begin_comment
comment|/* Tape interrupt status of current request */
end_comment

begin_enum
enum|enum
block|{
name|FTSTS_NONE
block|,
name|FTSTS_SNOOZE
block|,
name|FTSTS_INTERRUPT
block|,
name|FTSTS_TIMEOUT
block|}
enum|;
end_enum

begin_comment
comment|/* Tape I/O status */
end_comment

begin_enum
enum|enum
block|{
name|FTIO_READY
block|,
comment|/* No I/O activity */
name|FTIO_READING
block|,
comment|/* Currently reading blocks */
name|FTIO_RDAHEAD
block|,
comment|/* Currently reading ahead */
name|FTIO_WRITING
comment|/* Buffers are being written */
block|}
enum|;
end_enum

begin_comment
comment|/* Current tape mode */
end_comment

begin_enum
enum|enum
block|{
name|FTM_PRIMARY
block|,
comment|/* Primary mode */
name|FTM_VERIFY
block|,
comment|/* Verify mode */
name|FTM_FORMAT
block|,
comment|/* Format mode */
name|FTM_DIAG1
block|,
comment|/* Diagnostic mode 1 */
name|FTM_DIAG2
comment|/* Diagnostic mode 2 */
block|}
enum|;
end_enum

begin_comment
comment|/* Tape geometries table */
end_comment

begin_decl_stmt
specifier|static
name|QIC_Geom
name|ftgtbl
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|"Unformatted"
block|,
literal|"Unknown"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* XXX */
block|{
literal|1
block|,
literal|1
block|,
literal|"QIC-40"
block|,
literal|"205/550"
block|,
literal|20
block|,
literal|68
block|,
literal|2176
block|,
literal|128
block|,
literal|21760
block|}
block|,
block|{
literal|1
block|,
literal|2
block|,
literal|"QIC-40"
block|,
literal|"307.5/550"
block|,
literal|20
block|,
literal|102
block|,
literal|3264
block|,
literal|128
block|,
literal|32640
block|}
block|,
block|{
literal|1
block|,
literal|3
block|,
literal|"QIC-40"
block|,
literal|"295/900"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ??? */
block|{
literal|1
block|,
literal|4
block|,
literal|"QIC-40"
block|,
literal|"1100/550"
block|,
literal|20
block|,
literal|365
block|,
literal|11680
block|,
literal|128
block|,
literal|32512
block|}
block|,
block|{
literal|1
block|,
literal|5
block|,
literal|"QIC-40"
block|,
literal|"1100/900"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ??? */
block|{
literal|2
block|,
literal|1
block|,
literal|"QIC-80"
block|,
literal|"205/550"
block|,
literal|28
block|,
literal|100
block|,
literal|3200
block|,
literal|128
block|,
literal|19200
block|}
block|,
block|{
literal|2
block|,
literal|2
block|,
literal|"QIC-80"
block|,
literal|"307.5/550"
block|,
literal|28
block|,
literal|150
block|,
literal|4800
block|,
literal|128
block|,
literal|19200
block|}
block|,
block|{
literal|2
block|,
literal|3
block|,
literal|"QIC-80"
block|,
literal|"295/900"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ??? */
block|{
literal|2
block|,
literal|4
block|,
literal|"QIC-80"
block|,
literal|"1100/550"
block|,
literal|28
block|,
literal|537
block|,
literal|17184
block|,
literal|128
block|,
literal|32512
block|}
block|,
block|{
literal|2
block|,
literal|5
block|,
literal|"QIC-80"
block|,
literal|"1100/900"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ??? */
block|{
literal|3
block|,
literal|1
block|,
literal|"QIC-500"
block|,
literal|"205/550"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ??? */
block|{
literal|3
block|,
literal|2
block|,
literal|"QIC-500"
block|,
literal|"307.5/550"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ??? */
block|{
literal|3
block|,
literal|3
block|,
literal|"QIC-500"
block|,
literal|"295/900"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ??? */
block|{
literal|3
block|,
literal|4
block|,
literal|"QIC-500"
block|,
literal|"1100/550"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ??? */
block|{
literal|3
block|,
literal|5
block|,
literal|"QIC-500"
block|,
literal|"1100/900"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* ??? */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NGEOM
value|(sizeof(ftgtbl) / sizeof(QIC_Geom))
end_define

begin_decl_stmt
specifier|static
name|QIC_Geom
modifier|*
name|ftg
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current tape's geometry */
end_comment

begin_comment
comment|/*  *  things relating to asynchronous commands  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awr_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state of async write */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ard_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state of async read */
end_comment

begin_decl_stmt
specifier|static
name|int
name|arq_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state of async request */
end_comment

begin_decl_stmt
specifier|static
name|int
name|async_retries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* retries, one per invocation */
end_comment

begin_decl_stmt
specifier|static
name|int
name|async_func
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function to perform */
end_comment

begin_decl_stmt
specifier|static
name|int
name|async_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state current function is at */
end_comment

begin_decl_stmt
specifier|static
name|int
name|async_arg0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* up to 3 arguments for async cmds */
end_comment

begin_decl_stmt
specifier|static
name|int
name|async_arg1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**/
end_comment

begin_decl_stmt
specifier|static
name|int
name|async_arg2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**/
end_comment

begin_decl_stmt
specifier|static
name|int
name|async_ret
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return value */
end_comment

begin_struct
specifier|static
struct|struct
name|_astk
block|{
name|int
name|over_func
decl_stmt|;
name|int
name|over_state
decl_stmt|;
name|int
name|over_retries
decl_stmt|;
name|int
name|over_arg0
decl_stmt|;
name|int
name|over_arg1
decl_stmt|;
name|int
name|over_arg2
decl_stmt|;
block|}
name|astk
index|[
literal|10
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|_astk
modifier|*
name|astk_ptr
init|=
operator|&
name|astk
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to stack position */
end_comment

begin_comment
comment|/* List of valid async (interrupt driven) tape support functions. */
end_comment

begin_enum
enum|enum
block|{
name|ACMD_NONE
block|,
comment|/* no command */
name|ACMD_SEEK
block|,
comment|/* command seek */
name|ACMD_STATUS
block|,
comment|/* report status */
name|ACMD_STATE
block|,
comment|/* wait for state bits to be true */
name|ACMD_SEEKSTS
block|,
comment|/* perform command and wait for status */
name|ACMD_READID
block|,
comment|/* read id */
name|ACMD_RUNBLK
comment|/* ready tape for I/O on the given block */
block|}
enum|;
end_enum

begin_comment
comment|/* Call another asyncronous command from within async_cmd(). */
end_comment

begin_define
define|#
directive|define
name|CALL_ACMD
parameter_list|(
name|r
parameter_list|,
name|f
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|astk_ptr->over_retries = async_retries; \ 			astk_ptr->over_func = async_func; \ 			astk_ptr->over_state = (r); \ 			astk_ptr->over_arg0 = async_arg0; \ 			astk_ptr->over_arg1 = async_arg1; \ 			astk_ptr->over_arg2 = async_arg2; \ 			async_func = (f); async_state = 0; async_retries = 0; \ 			async_arg0=(a); async_arg1=(b); async_arg2=(c); \ 			astk_ptr++; \ 			goto restate
end_define

begin_comment
comment|/* Perform an asyncronous command from outside async_cmd(). */
end_comment

begin_define
define|#
directive|define
name|ACMD_FUNC
parameter_list|(
name|r
parameter_list|,
name|f
parameter_list|,
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|over_async = (r); astk_ptr =&astk[0]; \ 			async_func = (f); async_state = 0; async_retries = 0; \ 			async_arg0=(a); async_arg1=(b); async_arg2=(c); \ 			async_cmd(ftu); \ 			return
end_define

begin_comment
comment|/* Various wait channels */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wc_buff_avail
init|=
literal|"bavail"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wc_buff_done
init|=
literal|"bdone"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wc_iosts_change
init|=
literal|"iochg"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wc_long_delay
init|=
literal|"ldelay"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wc_intr_wait
init|=
literal|"intrw"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ftsleep
parameter_list|(
name|wc
parameter_list|,
name|to
parameter_list|)
value|tsleep((caddr_t)(wc),FTPRI,(wc),(to))
end_define

begin_comment
comment|/***********************************************************************\ * Per controller structure.						* \***********************************************************************/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|fdc_data
name|fdc_data
index|[
name|NFDC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************************************************************\ * Per tape drive structure.						* \***********************************************************************/
end_comment

begin_struct
specifier|static
struct|struct
name|ft_data
block|{
name|struct
name|fdc_data
modifier|*
name|fdc
decl_stmt|;
comment|/* pointer to controller structure */
name|int
name|ftsu
decl_stmt|;
comment|/* this units number on this controller */
name|int
name|type
decl_stmt|;
comment|/* Drive type (Mountain, Colorado) */
comment|/*	QIC_Geom *ftg;	*/
comment|/* pointer to Current tape's geometry */
name|int
name|flags
decl_stmt|;
name|int
name|cmd_wait
decl_stmt|;
comment|/* Command we are awaiting completion of */
name|int
name|sts_wait
decl_stmt|;
comment|/* Tape interrupt status of current request */
name|int
name|io_sts
decl_stmt|;
comment|/* Tape I/O status */
name|int
name|mode
decl_stmt|;
name|int
name|pcn
decl_stmt|;
comment|/* present cylinder number */
name|int
name|attaching
decl_stmt|;
comment|/* true when ft is attaching */
name|unsigned
name|char
modifier|*
name|xptr
decl_stmt|;
comment|/* pointer to buffer blk to xfer  */
name|int
name|xcnt
decl_stmt|;
comment|/* transfer count                 */
name|int
name|xblk
decl_stmt|;
comment|/* block number to transfer       */
name|int
name|xseg
decl_stmt|;
comment|/* segment being transferred	  */
name|SegReq
modifier|*
name|segh
decl_stmt|;
comment|/* Current I/O request		  */
name|SegReq
modifier|*
name|segt
decl_stmt|;
comment|/* Tail of queued I/O requests	  */
name|SegReq
modifier|*
name|doneh
decl_stmt|;
comment|/* Completed I/O request queue    */
name|SegReq
modifier|*
name|donet
decl_stmt|;
comment|/* Completed I/O request tail	  */
name|SegReq
modifier|*
name|segfree
decl_stmt|;
comment|/* Free segments		  */
name|SegReq
modifier|*
name|hdr
decl_stmt|;
comment|/* Current tape header		  */
name|int
name|nsegq
decl_stmt|;
comment|/* Segments on request queue	  */
name|int
name|ndoneq
decl_stmt|;
comment|/* Segments on completed queue	  */
name|int
name|nfreelist
decl_stmt|;
comment|/* Segments on free list	  */
comment|/* the next 3 should be defines in 'flags' */
name|int
name|active
decl_stmt|;
comment|/* TRUE if transfer is active	  */
name|int
name|rdonly
decl_stmt|;
comment|/* TRUE if tape is read-only	  */
name|int
name|newcart
decl_stmt|;
comment|/* TRUE if new cartridge detected */
name|int
name|laststs
decl_stmt|;
comment|/* last reported status code      */
name|int
name|lastcfg
decl_stmt|;
comment|/* last reported QIC config	  */
name|int
name|lasterr
decl_stmt|;
comment|/* last QIC error code 		  */
name|int
name|lastpos
decl_stmt|;
comment|/* last known segment number	  */
name|int
name|moving
decl_stmt|;
comment|/* TRUE if tape is moving	  */
name|int
name|rid
index|[
literal|7
index|]
decl_stmt|;
comment|/* read_id return values	  */
block|}
modifier|*
name|ft_data
index|[
name|NFT
index|]
struct|;
end_struct

begin_comment
comment|/***********************************************************************\ * Throughout this file the following conventions will be used:		* * ft is a pointer to the ft_data struct for the drive in question	* * fdc is a pointer to the fdc_data struct for the controller		* * ftu is the tape drive unit number					* * fdcu is the floppy controller unit number				* * ftsu is the tape drive unit number on that controller. (sub-unit)	* \***********************************************************************/
end_comment

begin_define
define|#
directive|define
name|id_physid
value|id_scsiid
end_define

begin_comment
comment|/* this biotab field doubles as a field */
end_comment

begin_comment
comment|/* for the physical unit number on the controller */
end_comment

begin_function_decl
name|int
name|ftopen
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ftclose
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ftioctl
parameter_list|(
name|dev_t
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ftattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|,
name|struct
name|isa_device
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|ft_timeout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|async_cmd
parameter_list|(
name|ftu_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|async_req
parameter_list|(
name|ftu_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|async_read
parameter_list|(
name|ftu_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|async_write
parameter_list|(
name|ftu_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tape_start
parameter_list|(
name|ftu_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tape_end
parameter_list|(
name|ftu_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tape_inactive
parameter_list|(
name|ftu_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tape_cmd
parameter_list|(
name|ftu_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tape_status
parameter_list|(
name|ftu_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|qic_status
parameter_list|(
name|ftu_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ftreq_rewind
parameter_list|(
name|ftu_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ftreq_hwinfo
parameter_list|(
name|ftu_t
parameter_list|,
name|QIC_HWInfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *  Allocate a segment I/O buffer from the free list.  */
end_comment

begin_function
specifier|static
name|SegReq
modifier|*
name|segio_alloc
parameter_list|(
name|ft_p
name|ft
parameter_list|)
block|{
name|SegReq
modifier|*
name|r
decl_stmt|;
comment|/* Grab first item from free list */
if|if
condition|(
operator|(
name|r
operator|=
name|ft
operator|->
name|segfree
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ft
operator|->
name|segfree
operator|=
name|ft
operator|->
name|segfree
operator|->
name|next
expr_stmt|;
name|ft
operator|->
name|nfreelist
operator|--
expr_stmt|;
block|}
name|DPRT
argument_list|(
operator|(
literal|"segio_alloc: nfree=%d ndone=%d nreq=%d\n"
operator|,
name|ft
operator|->
name|nfreelist
operator|,
name|ft
operator|->
name|ndoneq
operator|,
name|ft
operator|->
name|nsegq
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Queue a segment I/O request.  */
end_comment

begin_function
specifier|static
name|void
name|segio_queue
parameter_list|(
name|ft_p
name|ft
parameter_list|,
name|SegReq
modifier|*
name|sp
parameter_list|)
block|{
comment|/* Put request on in process queue. */
if|if
condition|(
name|ft
operator|->
name|segt
operator|==
name|NULL
condition|)
name|ft
operator|->
name|segh
operator|=
name|sp
expr_stmt|;
else|else
name|ft
operator|->
name|segt
operator|->
name|next
operator|=
name|sp
expr_stmt|;
name|sp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ft
operator|->
name|segt
operator|=
name|sp
expr_stmt|;
name|ft
operator|->
name|nsegq
operator|++
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"segio_queue: nfree=%d ndone=%d nreq=%d\n"
operator|,
name|ft
operator|->
name|nfreelist
operator|,
name|ft
operator|->
name|ndoneq
operator|,
name|ft
operator|->
name|nsegq
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Segment I/O completed, place on correct queue.  */
end_comment

begin_function
specifier|static
name|void
name|segio_done
parameter_list|(
name|ft_p
name|ft
parameter_list|,
name|SegReq
modifier|*
name|sp
parameter_list|)
block|{
comment|/* First remove from current I/O queue */
name|ft
operator|->
name|segh
operator|=
name|sp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|segh
operator|==
name|NULL
condition|)
name|ft
operator|->
name|segt
operator|=
name|NULL
expr_stmt|;
name|ft
operator|->
name|nsegq
operator|--
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|reqtype
operator|==
name|FTIO_WRITING
condition|)
block|{
comment|/* Place on free list */
name|sp
operator|->
name|next
operator|=
name|ft
operator|->
name|segfree
expr_stmt|;
name|ft
operator|->
name|segfree
operator|=
name|sp
expr_stmt|;
name|ft
operator|->
name|nfreelist
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|wc_buff_avail
argument_list|)
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"segio_done: (w) nfree=%d ndone=%d nreq=%d\n"
operator|,
name|ft
operator|->
name|nfreelist
operator|,
name|ft
operator|->
name|ndoneq
operator|,
name|ft
operator|->
name|nsegq
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Put on completed I/O queue */
if|if
condition|(
name|ft
operator|->
name|donet
operator|==
name|NULL
condition|)
name|ft
operator|->
name|doneh
operator|=
name|sp
expr_stmt|;
else|else
name|ft
operator|->
name|donet
operator|->
name|next
operator|=
name|sp
expr_stmt|;
name|sp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|ft
operator|->
name|donet
operator|=
name|sp
expr_stmt|;
name|ft
operator|->
name|ndoneq
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|wc_buff_done
argument_list|)
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"segio_done: (r) nfree=%d ndone=%d nreq=%d\n"
operator|,
name|ft
operator|->
name|nfreelist
operator|,
name|ft
operator|->
name|ndoneq
operator|,
name|ft
operator|->
name|nsegq
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  Take I/O request from finished queue to free queue.  */
end_comment

begin_function
specifier|static
name|void
name|segio_free
parameter_list|(
name|ft_p
name|ft
parameter_list|,
name|SegReq
modifier|*
name|sp
parameter_list|)
block|{
comment|/* First remove from done queue */
name|ft
operator|->
name|doneh
operator|=
name|sp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|doneh
operator|==
name|NULL
condition|)
name|ft
operator|->
name|donet
operator|=
name|NULL
expr_stmt|;
name|ft
operator|->
name|ndoneq
operator|--
expr_stmt|;
comment|/* Place on free list */
name|sp
operator|->
name|next
operator|=
name|ft
operator|->
name|segfree
expr_stmt|;
name|ft
operator|->
name|segfree
operator|=
name|sp
expr_stmt|;
name|ft
operator|->
name|nfreelist
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|wc_buff_avail
argument_list|)
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"segio_free: nfree=%d ndone=%d nreq=%d\n"
operator|,
name|ft
operator|->
name|nfreelist
operator|,
name|ft
operator|->
name|ndoneq
operator|,
name|ft
operator|->
name|nsegq
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Probe/attach floppy tapes.  */
end_comment

begin_function
name|int
name|ftattach
parameter_list|(
name|isadev
parameter_list|,
name|fdup
parameter_list|,
name|unithasfd
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isadev
decl_stmt|,
decl|*
name|fdup
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|unithasfd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fdcu_t
name|fdcu
init|=
name|isadev
operator|->
name|id_unit
decl_stmt|;
comment|/* fdc active unit */
name|fdc_p
name|fdc
init|=
name|fdc_data
operator|+
name|fdcu
decl_stmt|;
comment|/* pointer to controller structure */
name|ftu_t
name|ftu
init|=
name|fdup
operator|->
name|id_unit
decl_stmt|;
name|ft_p
name|ft
decl_stmt|;
name|ftsu_t
name|ftsu
init|=
name|fdup
operator|->
name|id_physid
decl_stmt|;
name|QIC_HWInfo
name|hw
decl_stmt|;
name|char
modifier|*
name|manu
decl_stmt|;
if|if
condition|(
name|ftu
operator|>=
name|NFT
condition|)
return|return
literal|0
return|;
name|ft
operator|=
name|ft_data
index|[
name|ftu
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|ft
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ft
argument_list|,
sizeof|sizeof
expr|*
name|ft
argument_list|)
expr_stmt|;
comment|/* Probe for tape */
name|ft
operator|->
name|attaching
operator|=
literal|1
expr_stmt|;
name|ft
operator|->
name|type
operator|=
name|NO_TYPE
expr_stmt|;
name|ft
operator|->
name|fdc
operator|=
name|fdc
expr_stmt|;
name|ft
operator|->
name|ftsu
operator|=
name|ftsu
expr_stmt|;
comment|/*    *  FT_NONE - no method, just do it    */
name|tape_start
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape_status
argument_list|(
name|ftu
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|ft
operator|->
name|type
operator|=
name|FT_NONE
expr_stmt|;
name|ftreq_hwinfo
argument_list|(
name|ftu
argument_list|,
operator|&
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*    *  FT_COLORADO - colorado style    */
name|tape_start
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_COL_ENABLE1
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_COL_ENABLE2
operator|+
name|ftu
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape_status
argument_list|(
name|ftu
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|ft
operator|->
name|type
operator|=
name|FT_COLORADO
expr_stmt|;
name|ftreq_hwinfo
argument_list|(
name|ftu
argument_list|,
operator|&
name|hw
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_COL_DISABLE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*    *  FT_MOUNTAIN - mountain style    */
name|tape_start
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_MTN_ENABLE1
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_MTN_ENABLE2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape_status
argument_list|(
name|ftu
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|ft
operator|->
name|type
operator|=
name|FT_MOUNTAIN
expr_stmt|;
name|ftreq_hwinfo
argument_list|(
name|ftu
argument_list|,
operator|&
name|hw
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_MTN_DISABLE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|isadev
operator|->
name|id_flags
operator|&
name|FT_PROBE
condition|)
block|{
comment|/*      * Insight probe is dangerous, since it requires the motor being      * enabled and therefore risks attached floppy disk drives to jam.      * Probe only if explicitly requested by a flag 0x1 from config      */
comment|/*      *  FT_INSIGHT - insight style      *      *  Since insight requires turning the drive motor on, we will not      *  perform this probe if a floppy drive was already found with the      *  the given unit and controller.      */
if|if
condition|(
name|unithasfd
condition|)
goto|goto
name|out
goto|;
name|tape_start
argument_list|(
name|ftu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape_status
argument_list|(
name|ftu
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|ft
operator|->
name|type
operator|=
name|FT_INSIGHT
expr_stmt|;
name|ftreq_hwinfo
argument_list|(
name|ftu
argument_list|,
operator|&
name|hw
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|tape_end
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|type
operator|!=
name|NO_TYPE
condition|)
block|{
name|fdc
operator|->
name|flags
operator||=
name|FDC_HASFTAPE
expr_stmt|;
switch|switch
condition|(
name|hw
operator|.
name|hw_make
condition|)
block|{
case|case
literal|0x0000
case|:
if|if
condition|(
name|ft
operator|->
name|type
operator|==
name|FT_COLORADO
condition|)
block|{
name|manu
operator|=
literal|"Colorado"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ft
operator|->
name|type
operator|==
name|FT_INSIGHT
condition|)
block|{
name|manu
operator|=
literal|"Insight"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ft
operator|->
name|type
operator|==
name|FT_MOUNTAIN
operator|&&
name|hw
operator|.
name|hw_model
operator|==
literal|0x05
condition|)
block|{
name|manu
operator|=
literal|"Archive"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ft
operator|->
name|type
operator|==
name|FT_MOUNTAIN
condition|)
block|{
name|manu
operator|=
literal|"Mountain"
expr_stmt|;
block|}
else|else
block|{
name|manu
operator|=
literal|"Unknown"
expr_stmt|;
block|}
break|break;
case|case
literal|0x0001
case|:
name|manu
operator|=
literal|"Colorado"
expr_stmt|;
break|break;
case|case
literal|0x0005
case|:
if|if
condition|(
name|hw
operator|.
name|hw_model
operator|>=
literal|0x09
condition|)
block|{
name|manu
operator|=
literal|"Conner"
expr_stmt|;
block|}
else|else
block|{
name|manu
operator|=
literal|"Archive"
expr_stmt|;
block|}
break|break;
case|case
literal|0x0006
case|:
name|manu
operator|=
literal|"Mountain"
expr_stmt|;
break|break;
case|case
literal|0x0007
case|:
name|manu
operator|=
literal|"Wangtek"
expr_stmt|;
break|break;
case|case
literal|0x0222
case|:
name|manu
operator|=
literal|"IOMega"
expr_stmt|;
break|break;
default|default:
name|manu
operator|=
literal|"Unknown"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"ft%d: %s tape\n"
argument_list|,
name|fdup
operator|->
name|id_unit
argument_list|,
name|manu
argument_list|)
expr_stmt|;
block|}
name|ft
operator|->
name|attaching
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ft
operator|->
name|type
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  Perform common commands asynchronously.  */
end_comment

begin_function
specifier|static
name|void
name|async_cmd
parameter_list|(
name|ftu_t
name|ftu
parameter_list|)
block|{
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|fdcu_t
name|fdcu
init|=
name|ft
operator|->
name|fdc
operator|->
name|fdcu
decl_stmt|;
name|int
name|cmd
decl_stmt|,
name|i
decl_stmt|,
name|st0
decl_stmt|,
name|st3
decl_stmt|,
name|pcn
decl_stmt|;
specifier|static
name|int
name|bitn
decl_stmt|,
name|retval
decl_stmt|,
name|retpos
decl_stmt|,
name|nbits
decl_stmt|,
name|newcn
decl_stmt|;
specifier|static
name|int
name|wanttrk
decl_stmt|,
name|wantblk
decl_stmt|,
name|wantdir
decl_stmt|;
specifier|static
name|int
name|curtrk
decl_stmt|,
name|curblk
decl_stmt|,
name|curdir
decl_stmt|,
name|curdiff
decl_stmt|;
specifier|static
name|int
name|errcnt
init|=
literal|0
decl_stmt|;
name|restate
label|:
if|#
directive|if
name|FTDBGALL
name|DPRT
argument_list|(
operator|(
literal|"async_cmd state: func: %d  state: %d\n"
operator|,
name|async_func
operator|,
name|async_state
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|async_func
condition|)
block|{
case|case
name|ACMD_SEEK
case|:
comment|/* 	 *  Arguments: 	 *     0 - command to perform 	 */
switch|switch
condition|(
name|async_state
condition|)
block|{
case|case
literal|0
case|:
name|cmd
operator|=
name|async_arg0
expr_stmt|;
if|#
directive|if
name|FTDBGALL
name|DPRT
argument_list|(
operator|(
literal|"===>async_seek cmd = %d\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|newcn
operator|=
operator|(
name|cmd
operator|<=
name|ft
operator|->
name|pcn
operator|)
condition|?
name|ft
operator|->
name|pcn
operator|-
name|cmd
else|:
name|ft
operator|->
name|pcn
operator|+
name|cmd
expr_stmt|;
name|async_state
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SEEK
argument_list|)
operator|<
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|&&
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|ftu
argument_list|)
operator|<
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|i
operator|&&
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|newcn
argument_list|)
operator|<
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
if|if
condition|(
operator|++
name|async_retries
operator|>=
literal|10
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: async_cmd command seek failed!!\n"
operator|,
name|ftu
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
name|DPRT
argument_list|(
operator|(
literal|"ft%d: async_cmd command seek retry...\n"
operator|,
name|ftu
operator|)
argument_list|)
expr_stmt|;
name|async_state
operator|=
literal|0
expr_stmt|;
goto|goto
name|restate
goto|;
block|}
break|break;
case|case
literal|1
case|:
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SENSEI
argument_list|)
expr_stmt|;
name|st0
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|pcn
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
if|if
condition|(
name|st0
operator|<
literal|0
operator|||
name|pcn
operator|<
literal|0
operator|||
name|newcn
operator|!=
name|pcn
condition|)
block|{
if|if
condition|(
operator|++
name|async_retries
operator|>=
literal|10
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: async_cmd seek retries exceeded\n"
operator|,
name|ftu
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
name|DPRT
argument_list|(
operator|(
literal|"ft%d: async_cmd command bad st0=$%02x pcn=$%02x\n"
operator|,
name|ftu
operator|,
name|st0
operator|,
name|pcn
operator|)
argument_list|)
expr_stmt|;
name|async_state
operator|=
literal|0
expr_stmt|;
name|timeout
argument_list|(
name|ft_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ftu
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|st0
operator|&
literal|0x20
condition|)
block|{
comment|/* seek done */
name|ft
operator|->
name|pcn
operator|=
name|pcn
expr_stmt|;
block|}
if|#
directive|if
name|FTDBGALL
else|else
name|DPRT
argument_list|(
operator|(
literal|"ft%d: async_seek error st0 = $%02x pcn = %d\n"
operator|,
name|ftu
operator|,
name|st0
operator|,
name|pcn
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|async_arg1
condition|)
goto|goto
name|complete
goto|;
name|async_state
operator|=
literal|2
expr_stmt|;
name|timeout
argument_list|(
name|ft_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ftu
argument_list|,
name|hz
operator|/
literal|50
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
goto|goto
name|complete
goto|;
comment|/* NOTREACHED */
block|}
break|break;
case|case
name|ACMD_STATUS
case|:
comment|/* 	 *  Arguments: 	 *     0 - command to issue report from 	 *     1 - number of bits 	 *  modifies: bitn, retval, st3 	 */
switch|switch
condition|(
name|async_state
condition|)
block|{
case|case
literal|0
case|:
name|bitn
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
name|cmd
operator|=
name|async_arg0
expr_stmt|;
name|nbits
operator|=
name|async_arg1
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"async_status got cmd = %d nbits = %d\n"
operator|,
name|cmd
operator|,
name|nbits
operator|)
argument_list|)
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|5
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_NEXTBIT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|1
case|:
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SENSED
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|ftu
argument_list|)
expr_stmt|;
name|st3
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
if|if
condition|(
name|st3
operator|<
literal|0
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: async_status timed out on bit %d r=$%02x\n"
operator|,
name|ftu
operator|,
name|bitn
operator|,
name|retval
operator|)
argument_list|)
expr_stmt|;
name|async_ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
if|if
condition|(
operator|(
name|st3
operator|&
literal|0x10
operator|)
operator|!=
literal|0
condition|)
name|retval
operator||=
operator|(
literal|1
operator|<<
name|bitn
operator|)
expr_stmt|;
name|bitn
operator|++
expr_stmt|;
if|if
condition|(
name|bitn
operator|>=
operator|(
name|nbits
operator|+
literal|2
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|retval
operator|&
literal|1
operator|)
operator|&&
operator|(
name|retval
operator|&
operator|(
literal|1
operator|<<
operator|(
name|nbits
operator|+
literal|1
operator|)
operator|)
operator|)
condition|)
block|{
name|async_ret
operator|=
operator|(
name|retval
operator|&
operator|~
operator|(
literal|1
operator|<<
operator|(
name|nbits
operator|+
literal|1
operator|)
operator|)
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|async_arg0
operator|==
name|QC_STATUS
operator|&&
name|async_arg2
operator|==
literal|0
operator|&&
operator|(
name|async_ret
operator|&
operator|(
name|QS_ERROR
operator||
name|QS_NEWCART
operator|)
operator|)
condition|)
block|{
name|async_state
operator|=
literal|2
expr_stmt|;
goto|goto
name|restate
goto|;
block|}
name|DPRT
argument_list|(
operator|(
literal|"async status got $%04x ($%04x)\n"
operator|,
name|async_ret
operator|,
name|retval
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: async_status failed: retval=$%04x nbits=%d\n"
operator|,
name|ftu
operator|,
name|retval
operator|,
name|nbits
operator|)
argument_list|)
expr_stmt|;
name|async_ret
operator|=
operator|-
literal|2
expr_stmt|;
block|}
goto|goto
name|complete
goto|;
block|}
name|CALL_ACMD
argument_list|(
literal|1
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_NEXTBIT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|2
case|:
if|if
condition|(
name|async_ret
operator|&
name|QS_NEWCART
condition|)
name|ft
operator|->
name|newcart
operator|=
literal|1
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|3
argument_list|,
name|ACMD_STATUS
argument_list|,
name|QC_ERRCODE
argument_list|,
literal|16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|ft
operator|->
name|lasterr
operator|=
name|async_ret
expr_stmt|;
if|if
condition|(
operator|(
name|ft
operator|->
name|lasterr
operator|&
name|QS_NEWCART
operator|)
operator|==
literal|0
operator|&&
name|ft
operator|->
name|lasterr
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: QIC error %d occurred on cmd %d\n"
operator|,
name|ftu
operator|,
name|ft
operator|->
name|lasterr
operator|&
literal|0xff
operator|,
name|ft
operator|->
name|lasterr
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
name|async_arg0
expr_stmt|;
name|nbits
operator|=
name|async_arg1
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|4
argument_list|,
name|ACMD_STATUS
argument_list|,
name|QC_STATUS
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
goto|goto
name|complete
goto|;
case|case
literal|5
case|:
name|CALL_ACMD
argument_list|(
literal|6
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_NEXTBIT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|6
case|:
name|CALL_ACMD
argument_list|(
literal|7
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_NEXTBIT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|7
case|:
name|CALL_ACMD
argument_list|(
literal|8
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_NEXTBIT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|8
case|:
name|cmd
operator|=
name|async_arg0
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|1
argument_list|,
name|ACMD_SEEK
argument_list|,
name|cmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACMD_STATE
case|:
comment|/* 	 *  Arguments: 	 *     0 - status bits to check 	 */
switch|switch
condition|(
name|async_state
condition|)
block|{
case|case
literal|0
case|:
name|CALL_ACMD
argument_list|(
literal|1
argument_list|,
name|ACMD_STATUS
argument_list|,
name|QC_STATUS
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
if|if
condition|(
operator|(
name|async_ret
operator|&
name|async_arg0
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|complete
goto|;
name|async_state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|++
name|async_retries
operator|==
literal|360
condition|)
block|{
comment|/* 90 secs. */
name|DPRT
argument_list|(
operator|(
literal|"ft%d: acmd_state exceeded retry count\n"
operator|,
name|ftu
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
name|timeout
argument_list|(
name|ft_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ftu
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ACMD_SEEKSTS
case|:
comment|/* 	 *  Arguments: 	 *     0 - command to perform 	 *     1 - status bits to check 	 *     2 - (optional) seconds to wait until completion 	 */
switch|switch
condition|(
name|async_state
condition|)
block|{
case|case
literal|0
case|:
name|cmd
operator|=
name|async_arg0
expr_stmt|;
name|async_retries
operator|=
operator|(
name|async_arg2
operator|)
condition|?
operator|(
name|async_arg2
operator|*
literal|4
operator|)
else|:
literal|10
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|1
argument_list|,
name|ACMD_SEEK
argument_list|,
name|cmd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|CALL_ACMD
argument_list|(
literal|2
argument_list|,
name|ACMD_STATUS
argument_list|,
name|QC_STATUS
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
if|if
condition|(
operator|(
name|async_ret
operator|&
name|async_arg1
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|complete
goto|;
if|if
condition|(
operator|--
name|async_retries
operator|==
literal|0
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: acmd_seeksts retries exceeded\n"
operator|,
name|ftu
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
name|async_state
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|ft_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ftu
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|ACMD_READID
case|:
comment|/* 	 *  Arguments: (none) 	 */
switch|switch
condition|(
name|async_state
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|!
name|ft
operator|->
name|moving
condition|)
block|{
name|CALL_ACMD
argument_list|(
literal|4
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|QC_STOP
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|async_state
operator|=
literal|1
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0x4a
argument_list|)
expr_stmt|;
comment|/* READ_ID */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|ftu
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|ft
operator|->
name|rid
index|[
name|i
index|]
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|async_ret
operator|=
operator|(
name|ft
operator|->
name|rid
index|[
literal|3
index|]
operator|*
name|ftg
operator|->
name|g_fdtrk
operator|)
operator|+
operator|(
name|ft
operator|->
name|rid
index|[
literal|4
index|]
operator|*
name|ftg
operator|->
name|g_fdside
operator|)
operator|+
name|ft
operator|->
name|rid
index|[
literal|5
index|]
operator|-
literal|1
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"readid st0:%02x st1:%02x st2:%02x c:%d h:%d s:%d pos:%d\n"
operator|,
name|ft
operator|->
name|rid
index|[
literal|0
index|]
operator|,
name|ft
operator|->
name|rid
index|[
literal|1
index|]
operator|,
name|ft
operator|->
name|rid
index|[
literal|2
index|]
operator|,
name|ft
operator|->
name|rid
index|[
literal|3
index|]
operator|,
name|ft
operator|->
name|rid
index|[
literal|4
index|]
operator|,
name|ft
operator|->
name|rid
index|[
literal|5
index|]
operator|,
name|async_ret
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ft
operator|->
name|rid
index|[
literal|0
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0
operator|||
name|async_ret
operator|<
literal|0
condition|)
block|{
comment|/* 			 *  Method for retry: 			 *    errcnt == 1 regular retry 			 *		2 microstep head 1 			 * 		3 microstep head 2 			 *		4 microstep head back to 0 			 *		5 fail 			 */
if|if
condition|(
operator|++
name|errcnt
operator|>=
literal|5
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: acmd_readid errcnt exceeded\n"
operator|,
name|fdcu
operator|)
argument_list|)
expr_stmt|;
name|async_ret
operator|=
operator|-
literal|2
expr_stmt|;
name|errcnt
operator|=
literal|0
expr_stmt|;
goto|goto
name|complete
goto|;
block|}
if|if
condition|(
name|errcnt
operator|==
literal|1
condition|)
block|{
name|ft
operator|->
name|moving
operator|=
literal|0
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|4
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|QC_STOP
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ft
operator|->
name|moving
operator|=
literal|0
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|4
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|QC_STPAUSE
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|DPRT
argument_list|(
operator|(
literal|"readid retry %d...\n"
operator|,
name|errcnt
operator|)
argument_list|)
expr_stmt|;
name|async_state
operator|=
literal|0
expr_stmt|;
goto|goto
name|restate
goto|;
block|}
if|if
condition|(
operator|(
name|async_ret
operator|%
name|ftg
operator|->
name|g_blktrk
operator|)
operator|==
operator|(
name|ftg
operator|->
name|g_blktrk
operator|-
literal|1
operator|)
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"acmd_readid detected last block on track\n"
operator|)
argument_list|)
expr_stmt|;
name|retpos
operator|=
name|async_ret
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|2
argument_list|,
name|ACMD_STATE
argument_list|,
name|QS_BOT
operator||
name|QS_EOT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|ft
operator|->
name|lastpos
operator|=
name|async_ret
expr_stmt|;
name|errcnt
operator|=
literal|0
expr_stmt|;
goto|goto
name|complete
goto|;
comment|/* NOTREACHED */
case|case
literal|2
case|:
name|CALL_ACMD
argument_list|(
literal|3
argument_list|,
name|ACMD_STATE
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|ft
operator|->
name|moving
operator|=
literal|0
expr_stmt|;
name|async_ret
operator|=
name|retpos
operator|+
literal|1
expr_stmt|;
goto|goto
name|complete
goto|;
case|case
literal|4
case|:
name|CALL_ACMD
argument_list|(
literal|5
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_FORWARD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
name|ft
operator|->
name|moving
operator|=
literal|1
expr_stmt|;
name|async_state
operator|=
literal|0
expr_stmt|;
name|timeout
argument_list|(
name|ft_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ftu
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
block|}
break|break;
case|case
name|ACMD_RUNBLK
case|:
comment|/* 	 *  Arguments: 	 *     0 - block number I/O will be performed on 	 * 	 *  modifies: curpos 	 */
switch|switch
condition|(
name|async_state
condition|)
block|{
case|case
literal|0
case|:
name|wanttrk
operator|=
name|async_arg0
operator|/
name|ftg
operator|->
name|g_blktrk
expr_stmt|;
name|wantblk
operator|=
name|async_arg0
operator|%
name|ftg
operator|->
name|g_blktrk
expr_stmt|;
name|wantdir
operator|=
name|wanttrk
operator|&
literal|1
expr_stmt|;
name|ft
operator|->
name|moving
operator|=
literal|0
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|1
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|QC_STOP
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|curtrk
operator|=
name|wanttrk
expr_stmt|;
name|curdir
operator|=
name|curtrk
operator|&
literal|1
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"Changing to track %d\n"
operator|,
name|wanttrk
operator|)
argument_list|)
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|2
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_SEEKTRACK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|cmd
operator|=
name|wanttrk
operator|+
literal|2
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|3
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|cmd
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
name|CALL_ACMD
argument_list|(
literal|4
argument_list|,
name|ACMD_STATUS
argument_list|,
name|QC_STATUS
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|4
case|:
name|ft
operator|->
name|laststs
operator|=
name|async_ret
expr_stmt|;
if|if
condition|(
name|wantblk
operator|==
literal|0
condition|)
block|{
name|curblk
operator|=
literal|0
expr_stmt|;
name|cmd
operator|=
operator|(
name|wantdir
operator|)
condition|?
name|QC_SEEKEND
else|:
name|QC_SEEKSTART
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|6
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|cmd
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ft
operator|->
name|laststs
operator|&
name|QS_BOT
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"Tape is at BOT\n"
operator|)
argument_list|)
expr_stmt|;
name|curblk
operator|=
operator|(
name|wantdir
operator|)
condition|?
literal|4800
else|:
literal|0
expr_stmt|;
name|async_state
operator|=
literal|6
expr_stmt|;
goto|goto
name|restate
goto|;
block|}
if|if
condition|(
name|ft
operator|->
name|laststs
operator|&
name|QS_EOT
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"Tape is at EOT\n"
operator|)
argument_list|)
expr_stmt|;
name|curblk
operator|=
operator|(
name|wantdir
operator|)
condition|?
literal|0
else|:
literal|4800
expr_stmt|;
name|async_state
operator|=
literal|6
expr_stmt|;
goto|goto
name|restate
goto|;
block|}
name|CALL_ACMD
argument_list|(
literal|5
argument_list|,
name|ACMD_READID
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
if|if
condition|(
name|async_ret
operator|<
literal|0
condition|)
block|{
name|ft
operator|->
name|moving
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|lastpos
operator|=
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|async_ret
operator|==
operator|-
literal|2
condition|)
block|{
name|CALL_ACMD
argument_list|(
literal|9
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|QC_STOP
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CALL_ACMD
argument_list|(
literal|1
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|QC_STOP
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|curtrk
operator|=
operator|(
name|async_ret
operator|+
literal|1
operator|)
operator|/
name|ftg
operator|->
name|g_blktrk
expr_stmt|;
name|curblk
operator|=
operator|(
name|async_ret
operator|+
literal|1
operator|)
operator|%
name|ftg
operator|->
name|g_blktrk
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"gotid: curtrk=%d wanttrk=%d curblk=%d wantblk=%d\n"
operator|,
name|curtrk
operator|,
name|wanttrk
operator|,
name|curblk
operator|,
name|wantblk
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curtrk
operator|!=
name|wanttrk
condition|)
block|{
comment|/* oops! */
name|DPRT
argument_list|(
operator|(
literal|"oops!! wrong track!\n"
operator|)
argument_list|)
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|1
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|QC_STOP
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|async_state
operator|=
literal|6
expr_stmt|;
goto|goto
name|restate
goto|;
case|case
literal|6
case|:
name|DPRT
argument_list|(
operator|(
literal|"curtrk = %d nextblk = %d\n"
operator|,
name|curtrk
operator|,
name|curblk
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curblk
operator|==
name|wantblk
condition|)
block|{
name|ft
operator|->
name|lastpos
operator|=
name|curblk
operator|-
literal|1
expr_stmt|;
name|async_ret
operator|=
name|ft
operator|->
name|lastpos
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|moving
condition|)
goto|goto
name|complete
goto|;
name|CALL_ACMD
argument_list|(
literal|7
argument_list|,
name|ACMD_STATE
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curblk
operator|>
name|wantblk
condition|)
block|{
comment|/* passed it */
name|ft
operator|->
name|moving
operator|=
literal|0
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|10
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|QC_STOP
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|wantblk
operator|-
name|curblk
operator|)
operator|<=
literal|256
condition|)
block|{
comment|/* approaching it */
name|CALL_ACMD
argument_list|(
literal|5
argument_list|,
name|ACMD_READID
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* way up ahead */
name|ft
operator|->
name|moving
operator|=
literal|0
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|14
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|QC_STOP
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|ft
operator|->
name|moving
operator|=
literal|1
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|8
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_FORWARD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|async_state
operator|=
literal|9
expr_stmt|;
name|timeout
argument_list|(
name|ft_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ftu
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
case|case
literal|9
case|:
goto|goto
name|complete
goto|;
case|case
literal|10
case|:
name|curdiff
operator|=
operator|(
operator|(
name|curblk
operator|-
name|wantblk
operator|)
operator|/
name|QCV_BLKSEG
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|curdiff
operator|>=
name|ftg
operator|->
name|g_segtrk
condition|)
name|curdiff
operator|=
name|ftg
operator|->
name|g_segtrk
operator|-
literal|1
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"pos %d past %d, reverse %d\n"
operator|,
name|curblk
operator|,
name|wantblk
operator|,
name|curdiff
operator|)
argument_list|)
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|11
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_SEEKREV
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|11
case|:
name|DPRT
argument_list|(
operator|(
literal|"reverse 1 done\n"
operator|)
argument_list|)
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|12
argument_list|,
name|ACMD_SEEK
argument_list|,
operator|(
name|curdiff
operator|&
literal|0xf
operator|)
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|12
case|:
name|DPRT
argument_list|(
operator|(
literal|"reverse 2 done\n"
operator|)
argument_list|)
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|13
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
operator|(
operator|(
name|curdiff
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|+
literal|2
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
case|case
literal|13
case|:
name|CALL_ACMD
argument_list|(
literal|5
argument_list|,
name|ACMD_READID
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|14
case|:
name|curdiff
operator|=
operator|(
operator|(
name|wantblk
operator|-
name|curblk
operator|)
operator|/
name|QCV_BLKSEG
operator|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|curdiff
operator|<
literal|0
condition|)
name|curdiff
operator|=
literal|0
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"pos %d before %d, forward %d\n"
operator|,
name|curblk
operator|,
name|wantblk
operator|,
name|curdiff
operator|)
argument_list|)
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|15
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_SEEKFWD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|15
case|:
name|DPRT
argument_list|(
operator|(
literal|"forward 1 done\n"
operator|)
argument_list|)
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|16
argument_list|,
name|ACMD_SEEK
argument_list|,
operator|(
name|curdiff
operator|&
literal|0xf
operator|)
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
case|case
literal|16
case|:
name|DPRT
argument_list|(
operator|(
literal|"forward 2 done\n"
operator|)
argument_list|)
expr_stmt|;
name|CALL_ACMD
argument_list|(
literal|13
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
operator|(
operator|(
name|curdiff
operator|>>
literal|4
operator|)
operator|&
literal|0xf
operator|)
operator|+
literal|2
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return;
name|complete
label|:
if|if
condition|(
name|astk_ptr
operator|!=
operator|&
name|astk
index|[
literal|0
index|]
condition|)
block|{
name|astk_ptr
operator|--
expr_stmt|;
name|async_retries
operator|=
name|astk_ptr
operator|->
name|over_retries
expr_stmt|;
name|async_func
operator|=
name|astk_ptr
operator|->
name|over_func
expr_stmt|;
name|async_state
operator|=
name|astk_ptr
operator|->
name|over_state
expr_stmt|;
name|async_arg0
operator|=
name|astk_ptr
operator|->
name|over_arg0
expr_stmt|;
name|async_arg1
operator|=
name|astk_ptr
operator|->
name|over_arg1
expr_stmt|;
name|async_arg2
operator|=
name|astk_ptr
operator|->
name|over_arg2
expr_stmt|;
goto|goto
name|restate
goto|;
block|}
name|async_func
operator|=
name|ACMD_NONE
expr_stmt|;
name|async_state
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ft
operator|->
name|io_sts
condition|)
block|{
case|case
name|FTIO_READY
case|:
name|async_req
argument_list|(
name|ftu
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTIO_READING
case|:
case|case
name|FTIO_RDAHEAD
case|:
name|async_read
argument_list|(
name|ftu
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTIO_WRITING
case|:
name|async_write
argument_list|(
name|ftu
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRT
argument_list|(
operator|(
literal|"ft%d: bad async_cmd ending I/O state!\n"
operator|,
name|ftu
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  *  Entry point for the async request processor.  */
end_comment

begin_function
specifier|static
name|void
name|async_req
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|SegReq
modifier|*
name|sp
decl_stmt|;
specifier|static
name|int
name|over_async
decl_stmt|,
name|lastreq
decl_stmt|;
name|int
name|cmd
decl_stmt|;
if|if
condition|(
name|from
operator|==
literal|2
condition|)
name|arq_state
operator|=
name|over_async
expr_stmt|;
name|restate
label|:
switch|switch
condition|(
name|arq_state
condition|)
block|{
case|case
literal|0
case|:
comment|/* Process segment */
name|sp
operator|=
name|ft
operator|->
name|segh
expr_stmt|;
name|ft
operator|->
name|io_sts
operator|=
operator|(
name|sp
operator|==
name|NULL
operator|)
condition|?
name|FTIO_READY
else|:
name|sp
operator|->
name|reqtype
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|io_sts
operator|==
name|FTIO_WRITING
condition|)
name|async_write
argument_list|(
name|ftu
argument_list|,
name|from
argument_list|)
expr_stmt|;
else|else
name|async_read
argument_list|(
name|ftu
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|io_sts
operator|!=
name|FTIO_READY
condition|)
return|return;
comment|/* Pull buffer from current I/O queue */
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|lastreq
operator|=
name|sp
operator|->
name|reqtype
expr_stmt|;
name|segio_done
argument_list|(
name|ft
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* If I/O cancelled, clear finished queue. */
if|if
condition|(
name|sp
operator|->
name|reqcan
condition|)
block|{
while|while
condition|(
name|ft
operator|->
name|doneh
operator|!=
name|NULL
condition|)
name|segio_free
argument_list|(
name|ft
argument_list|,
name|ft
operator|->
name|doneh
argument_list|)
expr_stmt|;
name|lastreq
operator|=
name|FTIO_READY
expr_stmt|;
block|}
block|}
else|else
name|lastreq
operator|=
name|FTIO_READY
expr_stmt|;
comment|/* Detect end of track */
if|if
condition|(
operator|(
operator|(
name|ft
operator|->
name|xblk
operator|/
name|QCV_BLKSEG
operator|)
operator|%
name|ftg
operator|->
name|g_segtrk
operator|)
operator|==
literal|0
condition|)
block|{
name|ACMD_FUNC
argument_list|(
literal|2
argument_list|,
name|ACMD_STATE
argument_list|,
name|QS_BOT
operator||
name|QS_EOT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|arq_state
operator|=
literal|1
expr_stmt|;
goto|goto
name|restate
goto|;
case|case
literal|1
case|:
comment|/* Next request */
comment|/* If we have another request queued, start it running. */
if|if
condition|(
name|ft
operator|->
name|segh
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|ft
operator|->
name|segh
expr_stmt|;
name|sp
operator|->
name|reqcrc
operator|=
literal|0
expr_stmt|;
name|arq_state
operator|=
name|ard_state
operator|=
name|awr_state
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|xblk
operator|=
name|sp
operator|->
name|reqblk
expr_stmt|;
name|ft
operator|->
name|xseg
operator|=
name|sp
operator|->
name|reqseg
expr_stmt|;
name|ft
operator|->
name|xcnt
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|xptr
operator|=
name|sp
operator|->
name|buff
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"I/O reqblk = %d\n"
operator|,
name|ft
operator|->
name|xblk
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|restate
goto|;
block|}
comment|/* If the last request was reading, do read ahead. */
if|if
condition|(
operator|(
name|lastreq
operator|==
name|FTIO_READING
operator|||
name|lastreq
operator|==
name|FTIO_RDAHEAD
operator|)
operator|&&
operator|(
name|sp
operator|=
name|segio_alloc
argument_list|(
name|ft
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|->
name|reqtype
operator|=
name|FTIO_RDAHEAD
expr_stmt|;
name|sp
operator|->
name|reqblk
operator|=
name|ft
operator|->
name|xblk
expr_stmt|;
name|sp
operator|->
name|reqseg
operator|=
name|ft
operator|->
name|xseg
operator|+
literal|1
expr_stmt|;
name|sp
operator|->
name|reqcrc
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|reqcan
operator|=
literal|0
expr_stmt|;
name|segio_queue
argument_list|(
name|ft
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sp
operator|->
name|buff
argument_list|,
name|QCV_SEGSIZE
argument_list|)
expr_stmt|;
name|arq_state
operator|=
name|ard_state
operator|=
name|awr_state
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|xblk
operator|=
name|sp
operator|->
name|reqblk
expr_stmt|;
name|ft
operator|->
name|xseg
operator|=
name|sp
operator|->
name|reqseg
expr_stmt|;
name|ft
operator|->
name|xcnt
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|xptr
operator|=
name|sp
operator|->
name|buff
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"Processing readahead reqblk = %d\n"
operator|,
name|ft
operator|->
name|xblk
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|restate
goto|;
block|}
if|if
condition|(
name|ft
operator|->
name|moving
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"No more I/O.. Stopping.\n"
operator|)
argument_list|)
expr_stmt|;
name|ft
operator|->
name|moving
operator|=
literal|0
expr_stmt|;
name|ACMD_FUNC
argument_list|(
literal|7
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|QC_PAUSE
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|arq_state
operator|=
literal|7
expr_stmt|;
goto|goto
name|restate
goto|;
case|case
literal|2
case|:
comment|/* End of track */
name|ft
operator|->
name|moving
operator|=
literal|0
expr_stmt|;
name|ACMD_FUNC
argument_list|(
literal|3
argument_list|,
name|ACMD_STATE
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|DPRT
argument_list|(
operator|(
literal|"async_req seek head to track %d\n"
operator|,
name|ft
operator|->
name|xblk
operator|/
name|ftg
operator|->
name|g_blktrk
operator|)
argument_list|)
expr_stmt|;
name|ACMD_FUNC
argument_list|(
literal|4
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_SEEKTRACK
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|cmd
operator|=
operator|(
name|ft
operator|->
name|xblk
operator|/
name|ftg
operator|->
name|g_blktrk
operator|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|segh
operator|!=
name|NULL
condition|)
block|{
name|ACMD_FUNC
argument_list|(
literal|5
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|cmd
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ACMD_FUNC
argument_list|(
literal|7
argument_list|,
name|ACMD_SEEKSTS
argument_list|,
name|cmd
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|5
case|:
name|ft
operator|->
name|moving
operator|=
literal|1
expr_stmt|;
name|ACMD_FUNC
argument_list|(
literal|6
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_FORWARD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|arq_state
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|ft_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ftu
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
case|case
literal|7
case|:
comment|/* Time to rest. */
name|ft
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|lastpos
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* wakeup those who want an i/o chg */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|wc_iosts_change
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  *  Entry for async read.  */
end_comment

begin_function
specifier|static
name|void
name|async_read
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|fdcu_t
name|fdcu
init|=
name|ft
operator|->
name|fdc
operator|->
name|fdcu
decl_stmt|;
comment|/* fdc active unit */
name|int
name|i
decl_stmt|,
name|rddta
index|[
literal|7
index|]
decl_stmt|;
name|int
name|where
decl_stmt|;
specifier|static
name|int
name|over_async
decl_stmt|;
specifier|static
name|int
name|retries
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from
operator|==
literal|2
condition|)
name|ard_state
operator|=
name|over_async
expr_stmt|;
name|restate
label|:
if|#
directive|if
name|FTDBGALL
name|DPRT
argument_list|(
operator|(
literal|"async_read: state: %d  from = %d\n"
operator|,
name|ard_state
operator|,
name|from
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ard_state
condition|)
block|{
case|case
literal|0
case|:
comment|/* Start off */
comment|/* If tape is not at desired position, stop and locate */
if|if
condition|(
name|ft
operator|->
name|lastpos
operator|!=
operator|(
name|ft
operator|->
name|xblk
operator|-
literal|1
operator|)
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: position unknown: lastpos:%d ft->xblk:%d\n"
operator|,
name|ftu
operator|,
name|ft
operator|->
name|lastpos
operator|,
name|ft
operator|->
name|xblk
operator|)
argument_list|)
expr_stmt|;
name|ACMD_FUNC
argument_list|(
literal|1
argument_list|,
name|ACMD_RUNBLK
argument_list|,
name|ft
operator|->
name|xblk
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Tape is in position but stopped. */
if|if
condition|(
operator|!
name|ft
operator|->
name|moving
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"async_read ******STARTING TAPE\n"
operator|)
argument_list|)
expr_stmt|;
name|ACMD_FUNC
argument_list|(
literal|3
argument_list|,
name|ACMD_STATE
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ard_state
operator|=
literal|1
expr_stmt|;
goto|goto
name|restate
goto|;
case|case
literal|1
case|:
comment|/* Start DMA */
comment|/* Tape is now moving and in position-- start DMA now! */
name|isa_dmastart
argument_list|(
name|B_READ
argument_list|,
name|ft
operator|->
name|xptr
argument_list|,
name|QCV_BLKSIZE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0x66
argument_list|)
expr_stmt|;
comment|/* read */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|ftu
argument_list|)
expr_stmt|;
comment|/* unit */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
operator|(
name|ft
operator|->
name|xblk
operator|%
name|ftg
operator|->
name|g_fdside
operator|)
operator|/
name|ftg
operator|->
name|g_fdtrk
argument_list|)
expr_stmt|;
comment|/* cylinder */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|ft
operator|->
name|xblk
operator|/
name|ftg
operator|->
name|g_fdside
argument_list|)
expr_stmt|;
comment|/* head */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
operator|(
name|ft
operator|->
name|xblk
operator|%
name|ftg
operator|->
name|g_fdtrk
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* sector */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* 1K sectors */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
operator|(
name|ft
operator|->
name|xblk
operator|%
name|ftg
operator|->
name|g_fdtrk
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* count */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0x74
argument_list|)
expr_stmt|;
comment|/* gap length */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* transfer size */
name|ard_state
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* DMA completed */
comment|/* Transfer complete, get status */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|rddta
index|[
name|i
index|]
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|isa_dmadone
argument_list|(
name|B_READ
argument_list|,
name|ft
operator|->
name|xptr
argument_list|,
name|QCV_BLKSIZE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|FTDBGALL
comment|/* Compute where the controller thinks we are */
name|where
operator|=
operator|(
name|rddta
index|[
literal|3
index|]
operator|*
name|ftg
operator|->
name|g_fdtrk
operator|)
operator|+
operator|(
name|rddta
index|[
literal|4
index|]
operator|*
name|ftg
operator|->
name|g_fdside
operator|)
operator|+
name|rddta
index|[
literal|5
index|]
operator|-
literal|1
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"xfer done: st0:%02x st1:%02x st2:%02x c:%d h:%d s:%d pos:%d want:%d\n"
operator|,
name|rddta
index|[
literal|0
index|]
operator|,
name|rddta
index|[
literal|1
index|]
operator|,
name|rddta
index|[
literal|2
index|]
operator|,
name|rddta
index|[
literal|3
index|]
operator|,
name|rddta
index|[
literal|4
index|]
operator|,
name|rddta
index|[
literal|5
index|]
operator|,
name|where
operator|,
name|ft
operator|->
name|xblk
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check for errors */
if|if
condition|(
operator|(
name|rddta
index|[
literal|0
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x00
condition|)
block|{
if|#
directive|if
operator|!
name|FTDBGALL
name|where
operator|=
operator|(
name|rddta
index|[
literal|3
index|]
operator|*
name|ftg
operator|->
name|g_fdtrk
operator|)
operator|+
operator|(
name|rddta
index|[
literal|4
index|]
operator|*
name|ftg
operator|->
name|g_fdside
operator|)
operator|+
name|rddta
index|[
literal|5
index|]
operator|-
literal|1
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"xd: st0:%02x st1:%02x st2:%02x c:%d h:%d s:%d pos:%d want:%d\n"
operator|,
name|rddta
index|[
literal|0
index|]
operator|,
name|rddta
index|[
literal|1
index|]
operator|,
name|rddta
index|[
literal|2
index|]
operator|,
name|rddta
index|[
literal|3
index|]
operator|,
name|rddta
index|[
literal|4
index|]
operator|,
name|rddta
index|[
literal|5
index|]
operator|,
name|where
operator|,
name|ft
operator|->
name|xblk
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|rddta
index|[
literal|1
index|]
operator|&
literal|0x04
operator|)
operator|==
literal|0x04
operator|&&
name|retries
operator|<
literal|2
condition|)
block|{
comment|/* Probably wrong position */
name|DPRT
argument_list|(
operator|(
literal|"async_read: doing retry %d\n"
operator|,
name|retries
operator|)
argument_list|)
expr_stmt|;
name|ft
operator|->
name|lastpos
operator|=
name|ft
operator|->
name|xblk
expr_stmt|;
name|ard_state
operator|=
literal|0
expr_stmt|;
name|retries
operator|++
expr_stmt|;
goto|goto
name|restate
goto|;
block|}
else|else
block|{
comment|/* CRC/Address-mark/Data-mark, et. al. */
name|DPRT
argument_list|(
operator|(
literal|"ft%d: CRC error on block %d\n"
operator|,
name|fdcu
operator|,
name|ft
operator|->
name|xblk
operator|)
argument_list|)
expr_stmt|;
name|ft
operator|->
name|segh
operator|->
name|reqcrc
operator||=
operator|(
literal|1
operator|<<
name|ft
operator|->
name|xcnt
operator|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise, transfer completed okay. */
name|retries
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|lastpos
operator|=
name|ft
operator|->
name|xblk
expr_stmt|;
name|ft
operator|->
name|xblk
operator|++
expr_stmt|;
name|ft
operator|->
name|xcnt
operator|++
expr_stmt|;
name|ft
operator|->
name|xptr
operator|+=
name|QCV_BLKSIZE
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|xcnt
operator|<
name|QCV_BLKSEG
operator|&&
name|ft
operator|->
name|segh
operator|->
name|reqcan
operator|==
literal|0
condition|)
block|{
name|ard_state
operator|=
literal|0
expr_stmt|;
goto|goto
name|restate
goto|;
block|}
name|DPRT
argument_list|(
operator|(
literal|"Read done..  Cancel = %d\n"
operator|,
name|ft
operator|->
name|segh
operator|->
name|reqcan
operator|)
argument_list|)
expr_stmt|;
name|ft
operator|->
name|io_sts
operator|=
name|FTIO_READY
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ft
operator|->
name|moving
operator|=
literal|1
expr_stmt|;
name|ACMD_FUNC
argument_list|(
literal|4
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_FORWARD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ard_state
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|ft_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ftu
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
default|default:
name|DPRT
argument_list|(
operator|(
literal|"ft%d: bad async_read state %d!!\n"
operator|,
name|ftu
operator|,
name|ard_state
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  *  Entry for async write.  If from is 0, this came from the interrupt  *  routine, if it's 1 then it was a timeout, if it's 2, then an  *  async_cmd completed.  */
end_comment

begin_function
specifier|static
name|void
name|async_write
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|fdcu_t
name|fdcu
init|=
name|ft
operator|->
name|fdc
operator|->
name|fdcu
decl_stmt|;
comment|/* fdc active unit */
name|int
name|i
decl_stmt|,
name|rddta
index|[
literal|7
index|]
decl_stmt|;
name|int
name|where
decl_stmt|;
specifier|static
name|int
name|over_async
decl_stmt|;
specifier|static
name|int
name|retries
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from
operator|==
literal|2
condition|)
name|awr_state
operator|=
name|over_async
expr_stmt|;
name|restate
label|:
if|#
directive|if
name|FTDBGALL
name|DPRT
argument_list|(
operator|(
literal|"async_write: state: %d  from = %d\n"
operator|,
name|awr_state
operator|,
name|from
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|awr_state
condition|)
block|{
case|case
literal|0
case|:
comment|/* Start off */
comment|/* If tape is not at desired position, stop and locate */
if|if
condition|(
name|ft
operator|->
name|lastpos
operator|!=
operator|(
name|ft
operator|->
name|xblk
operator|-
literal|1
operator|)
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: position unknown: lastpos:%d ft->xblk:%d\n"
operator|,
name|ftu
operator|,
name|ft
operator|->
name|lastpos
operator|,
name|ft
operator|->
name|xblk
operator|)
argument_list|)
expr_stmt|;
name|ACMD_FUNC
argument_list|(
literal|1
argument_list|,
name|ACMD_RUNBLK
argument_list|,
name|ft
operator|->
name|xblk
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Tape is in position but stopped. */
if|if
condition|(
operator|!
name|ft
operator|->
name|moving
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"async_write ******STARTING TAPE\n"
operator|)
argument_list|)
expr_stmt|;
name|ACMD_FUNC
argument_list|(
literal|3
argument_list|,
name|ACMD_STATE
argument_list|,
name|QS_READY
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|awr_state
operator|=
literal|1
expr_stmt|;
goto|goto
name|restate
goto|;
case|case
literal|1
case|:
comment|/* Start DMA */
comment|/* Tape is now moving and in position-- start DMA now! */
name|isa_dmastart
argument_list|(
name|B_WRITE
argument_list|,
name|ft
operator|->
name|xptr
argument_list|,
name|QCV_BLKSIZE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0x45
argument_list|)
expr_stmt|;
comment|/* write */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|ftu
argument_list|)
expr_stmt|;
comment|/* unit */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
operator|(
name|ft
operator|->
name|xblk
operator|%
name|ftg
operator|->
name|g_fdside
operator|)
operator|/
name|ftg
operator|->
name|g_fdtrk
argument_list|)
expr_stmt|;
comment|/* cyl */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|ft
operator|->
name|xblk
operator|/
name|ftg
operator|->
name|g_fdside
argument_list|)
expr_stmt|;
comment|/* head */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
operator|(
name|ft
operator|->
name|xblk
operator|%
name|ftg
operator|->
name|g_fdtrk
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* sector */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* 1K sectors */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
operator|(
name|ft
operator|->
name|xblk
operator|%
name|ftg
operator|->
name|g_fdtrk
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* count */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0x74
argument_list|)
expr_stmt|;
comment|/* gap length */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* transfer size */
name|awr_state
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* DMA completed */
comment|/* Transfer complete, get status */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|rddta
index|[
name|i
index|]
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|isa_dmadone
argument_list|(
name|B_WRITE
argument_list|,
name|ft
operator|->
name|xptr
argument_list|,
name|QCV_BLKSIZE
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|FTDBGALL
comment|/* Compute where the controller thinks we are */
name|where
operator|=
operator|(
name|rddta
index|[
literal|3
index|]
operator|*
name|ftg
operator|->
name|g_fdtrk
operator|)
operator|+
operator|(
name|rddta
index|[
literal|4
index|]
operator|*
name|ftg
operator|->
name|g_fdside
operator|)
operator|+
name|rddta
index|[
literal|5
index|]
operator|-
literal|1
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"xfer done: st0:%02x st1:%02x st2:%02x c:%d h:%d s:%d pos:%d want:%d\n"
operator|,
name|rddta
index|[
literal|0
index|]
operator|,
name|rddta
index|[
literal|1
index|]
operator|,
name|rddta
index|[
literal|2
index|]
operator|,
name|rddta
index|[
literal|3
index|]
operator|,
name|rddta
index|[
literal|4
index|]
operator|,
name|rddta
index|[
literal|5
index|]
operator|,
name|where
operator|,
name|ft
operator|->
name|xblk
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check for errors */
if|if
condition|(
operator|(
name|rddta
index|[
literal|0
index|]
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x00
condition|)
block|{
if|#
directive|if
operator|!
name|FTDBGALL
name|where
operator|=
operator|(
name|rddta
index|[
literal|3
index|]
operator|*
name|ftg
operator|->
name|g_fdtrk
operator|)
operator|+
operator|(
name|rddta
index|[
literal|4
index|]
operator|*
name|ftg
operator|->
name|g_fdside
operator|)
operator|+
name|rddta
index|[
literal|5
index|]
operator|-
literal|1
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"xfer done: st0:%02x st1:%02x st2:%02x c:%d h:%d s:%d pos:%d want:%d\n"
operator|,
name|rddta
index|[
literal|0
index|]
operator|,
name|rddta
index|[
literal|1
index|]
operator|,
name|rddta
index|[
literal|2
index|]
operator|,
name|rddta
index|[
literal|3
index|]
operator|,
name|rddta
index|[
literal|4
index|]
operator|,
name|rddta
index|[
literal|5
index|]
operator|,
name|where
operator|,
name|ft
operator|->
name|xblk
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|retries
operator|<
literal|3
condition|)
block|{
comment|/* Something happened -- try again */
name|DPRT
argument_list|(
operator|(
literal|"async_write: doing retry %d\n"
operator|,
name|retries
operator|)
argument_list|)
expr_stmt|;
name|ft
operator|->
name|lastpos
operator|=
name|ft
operator|->
name|xblk
expr_stmt|;
name|awr_state
operator|=
literal|0
expr_stmt|;
name|retries
operator|++
expr_stmt|;
goto|goto
name|restate
goto|;
block|}
else|else
block|{
comment|/* 			 *  Retries failed.  Note the unrecoverable error. 			 *  Marking the block as bad is useless right now. 			 */
name|printf
argument_list|(
literal|"ft%d: unrecoverable write error on block %d\n"
argument_list|,
name|ftu
argument_list|,
name|ft
operator|->
name|xblk
argument_list|)
expr_stmt|;
name|ft
operator|->
name|segh
operator|->
name|reqcrc
operator||=
operator|(
literal|1
operator|<<
name|ft
operator|->
name|xcnt
operator|)
expr_stmt|;
block|}
block|}
comment|/* Otherwise, transfer completed okay. */
name|retries
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|lastpos
operator|=
name|ft
operator|->
name|xblk
expr_stmt|;
name|ft
operator|->
name|xblk
operator|++
expr_stmt|;
name|ft
operator|->
name|xcnt
operator|++
expr_stmt|;
name|ft
operator|->
name|xptr
operator|+=
name|QCV_BLKSIZE
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|xcnt
operator|<
name|QCV_BLKSEG
condition|)
block|{
name|awr_state
operator|=
literal|0
expr_stmt|;
comment|/* next block */
goto|goto
name|restate
goto|;
block|}
if|#
directive|if
name|FTDBGALL
name|DPRT
argument_list|(
operator|(
literal|"Write done.\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ft
operator|->
name|io_sts
operator|=
name|FTIO_READY
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ft
operator|->
name|moving
operator|=
literal|1
expr_stmt|;
name|ACMD_FUNC
argument_list|(
literal|4
argument_list|,
name|ACMD_SEEK
argument_list|,
name|QC_FORWARD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|awr_state
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|ft_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ftu
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
default|default:
name|DPRT
argument_list|(
operator|(
literal|"ft%d: bad async_write state %d!!\n"
operator|,
name|ftu
operator|,
name|awr_state
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  *  Interrupt handler for active tape.  Bounced off of fdintr().  */
end_comment

begin_function
name|int
name|ftintr
parameter_list|(
name|ftu_t
name|ftu
parameter_list|)
block|{
name|int
name|st0
decl_stmt|,
name|pcn
decl_stmt|,
name|i
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|fdcu_t
name|fdcu
init|=
name|ft
operator|->
name|fdc
operator|->
name|fdcu
decl_stmt|;
comment|/* fdc active unit */
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|st0
operator|=
literal|0
expr_stmt|;
name|pcn
operator|=
literal|0
expr_stmt|;
comment|/* I/O segment transfer completed */
if|if
condition|(
name|ft
operator|->
name|active
condition|)
block|{
if|if
condition|(
name|async_func
operator|!=
name|ACMD_NONE
condition|)
block|{
name|async_cmd
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|#
directive|if
name|FTDBGALL
name|DPRT
argument_list|(
operator|(
literal|"Got request interrupt\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|async_req
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Get interrupt status */
if|if
condition|(
name|ft
operator|->
name|cmd_wait
operator|!=
name|FTCMD_READID
condition|)
block|{
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SENSEI
argument_list|)
expr_stmt|;
name|st0
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|pcn
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ft
operator|->
name|cmd_wait
operator|==
name|FTCMD_NONE
operator|||
name|ft
operator|->
name|sts_wait
operator|!=
name|FTSTS_SNOOZE
condition|)
block|{
name|huh_what
label|:
name|printf
argument_list|(
literal|"ft%d: unexpected interrupt; st0 = $%02x pcn = %d\n"
argument_list|,
name|ftu
argument_list|,
name|st0
argument_list|,
name|pcn
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|ft
operator|->
name|cmd_wait
condition|)
block|{
case|case
name|FTCMD_RESET
case|:
name|ft
operator|->
name|sts_wait
operator|=
name|FTSTS_INTERRUPT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|wc_intr_wait
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTCMD_RECAL
case|:
case|case
name|FTCMD_SEEK
case|:
if|if
condition|(
name|st0
operator|&
literal|0x20
condition|)
block|{
comment|/* seek done */
name|ft
operator|->
name|sts_wait
operator|=
name|FTSTS_INTERRUPT
expr_stmt|;
name|ft
operator|->
name|pcn
operator|=
name|pcn
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|wc_intr_wait
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|FTDBGALL
else|else
name|DPRT
argument_list|(
operator|(
literal|"ft%d: seek error st0 = $%02x pcn = %d\n"
operator|,
name|ftu
operator|,
name|st0
operator|,
name|pcn
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|FTCMD_READID
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|ft
operator|->
name|rid
index|[
name|i
index|]
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
name|ft
operator|->
name|sts_wait
operator|=
name|FTSTS_INTERRUPT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|wc_intr_wait
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|huh_what
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Interrupt timeout routine.  */
end_comment

begin_function
specifier|static
name|void
name|ft_timeout
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|ftu_t
name|ftu
init|=
operator|(
name|ftu_t
operator|)
name|arg1
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|active
condition|)
block|{
if|if
condition|(
name|async_func
operator|!=
name|ACMD_NONE
condition|)
block|{
name|async_cmd
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|async_req
argument_list|(
name|ftu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ft
operator|->
name|sts_wait
operator|=
name|FTSTS_TIMEOUT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|wc_intr_wait
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Wait for a particular interrupt to occur.  ftintr() will wake us up  *  if it sees what we want.  Otherwise, time out and return error.  *  Should always disable ints before trigger is sent and calling here.  */
end_comment

begin_function
specifier|static
name|int
name|ftintr_wait
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|ticks
parameter_list|)
block|{
name|int
name|retries
decl_stmt|,
name|st0
decl_stmt|,
name|pcn
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|fdcu_t
name|fdcu
init|=
name|ft
operator|->
name|fdc
operator|->
name|fdcu
decl_stmt|;
comment|/* fdc active unit */
name|ft
operator|->
name|cmd_wait
operator|=
name|cmd
expr_stmt|;
name|ft
operator|->
name|sts_wait
operator|=
name|FTSTS_SNOOZE
expr_stmt|;
comment|/* At attach time, we can't rely on having interrupts serviced */
if|if
condition|(
name|ft
operator|->
name|attaching
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FTCMD_RESET
case|:
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ft
operator|->
name|sts_wait
operator|=
name|FTSTS_INTERRUPT
expr_stmt|;
goto|goto
name|intrdone
goto|;
case|case
name|FTCMD_RECAL
case|:
case|case
name|FTCMD_SEEK
case|:
for|for
control|(
name|retries
operator|=
literal|0
init|;
name|retries
operator|<
literal|10000
condition|;
name|retries
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SENSEI
argument_list|)
expr_stmt|;
name|st0
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st0
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
condition|)
continue|continue;
name|pcn
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
if|if
condition|(
name|st0
operator|&
literal|0x20
condition|)
block|{
name|ft
operator|->
name|sts_wait
operator|=
name|FTSTS_INTERRUPT
expr_stmt|;
name|ft
operator|->
name|pcn
operator|=
name|pcn
expr_stmt|;
goto|goto
name|intrdone
goto|;
block|}
block|}
break|break;
block|}
name|ft
operator|->
name|sts_wait
operator|=
name|FTSTS_TIMEOUT
expr_stmt|;
goto|goto
name|intrdone
goto|;
block|}
name|ftsleep
argument_list|(
name|wc_intr_wait
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|intrdone
label|:
if|if
condition|(
name|ft
operator|->
name|sts_wait
operator|==
name|FTSTS_TIMEOUT
condition|)
block|{
comment|/* timeout */
if|#
directive|if
name|FTDBGALL
if|if
condition|(
name|ft
operator|->
name|cmd_wait
operator|!=
name|FTCMD_RESET
condition|)
name|DPRT
argument_list|(
operator|(
literal|"ft%d: timeout on command %d\n"
operator|,
name|ftu
operator|,
name|ft
operator|->
name|cmd_wait
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ft
operator|->
name|cmd_wait
operator|=
name|FTCMD_NONE
expr_stmt|;
name|ft
operator|->
name|sts_wait
operator|=
name|FTSTS_NONE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* got interrupt */
if|if
condition|(
name|ft
operator|->
name|attaching
operator|==
literal|0
operator|&&
name|ticks
condition|)
name|untimeout
argument_list|(
name|ft_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ftu
argument_list|)
expr_stmt|;
name|ft
operator|->
name|cmd_wait
operator|=
name|FTCMD_NONE
expr_stmt|;
name|ft
operator|->
name|sts_wait
operator|=
name|FTSTS_NONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Recalibrate tape drive.  Parameter totape is true, if we should  *  recalibrate to tape drive settings.  */
end_comment

begin_function
specifier|static
name|int
name|tape_recal
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|totape
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|fdcu_t
name|fdcu
init|=
name|ft
operator|->
name|fdc
operator|->
name|fdcu
decl_stmt|;
comment|/* fdc active unit */
name|DPRT
argument_list|(
operator|(
literal|"tape_recal start\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
literal|0xbe
argument_list|,
name|FDP_FDDEXC
operator||
name|FDP_PORTEXC
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SPECIFY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
operator|(
name|totape
operator|)
condition|?
literal|0xEF
else|:
literal|0xCF
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
else|#
directive|else
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
operator|(
name|totape
operator|)
condition|?
literal|0xAD
else|:
literal|0xDF
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_RECAL
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|ftu
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftintr_wait
argument_list|(
name|ftu
argument_list|,
name|FTCMD_RECAL
argument_list|,
name|hz
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"ft%d: recalibrate timeout\n"
operator|,
name|ftu
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SPECIFY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
operator|(
name|totape
operator|)
condition|?
literal|0xEF
else|:
literal|0xCF
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
else|#
directive|else
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
operator|(
name|totape
operator|)
condition|?
literal|0xFD
else|:
literal|0xDF
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRT
argument_list|(
operator|(
literal|"tape_recal end\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Wait for a particular tape status to be met.  If all is TRUE, then  *  all states must be met, otherwise any state can be met.  */
end_comment

begin_function
specifier|static
name|int
name|tape_state
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|all
parameter_list|,
name|int
name|mask
parameter_list|,
name|int
name|seconds
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|tries
decl_stmt|,
name|maxtries
decl_stmt|;
name|maxtries
operator|=
operator|(
name|seconds
operator|)
condition|?
operator|(
literal|4
operator|*
name|seconds
operator|)
else|:
literal|1
expr_stmt|;
for|for
control|(
name|tries
operator|=
literal|0
init|;
name|tries
operator|<
name|maxtries
condition|;
name|tries
operator|++
control|)
block|{
name|r
operator|=
name|tape_status
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|all
operator|&&
operator|(
name|r
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
return|return
operator|(
name|r
operator|)
return|;
if|if
condition|(
operator|(
name|r
operator|&
name|mask
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|seconds
condition|)
name|ftsleep
argument_list|(
name|wc_long_delay
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
name|DPRT
argument_list|(
operator|(
literal|"ft%d: tape_state failed on mask=$%02x maxtries=%d\n"
operator|,
name|ftu
operator|,
name|mask
operator|,
name|maxtries
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Send a QIC command to tape drive, wait for completion.  */
end_comment

begin_function
specifier|static
name|int
name|tape_cmd
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|int
name|newcn
decl_stmt|;
name|int
name|retries
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|fdcu_t
name|fdcu
init|=
name|ft
operator|->
name|fdc
operator|->
name|fdcu
decl_stmt|;
comment|/* fdc active unit */
name|DPRT
argument_list|(
operator|(
literal|"===> tape_cmd: %d\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|newcn
operator|=
operator|(
name|cmd
operator|<=
name|ft
operator|->
name|pcn
operator|)
condition|?
name|ft
operator|->
name|pcn
operator|-
name|cmd
else|:
name|ft
operator|->
name|pcn
operator|+
name|cmd
expr_stmt|;
name|retry
label|:
comment|/* Perform seek */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SEEK
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|ftu
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|newcn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftintr_wait
argument_list|(
name|ftu
argument_list|,
name|FTCMD_SEEK
argument_list|,
name|hz
argument_list|)
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: tape_cmd seek timeout\n"
operator|,
name|ftu
operator|)
argument_list|)
expr_stmt|;
name|redo
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|retries
operator|<
literal|5
condition|)
goto|goto
name|retry
goto|;
name|DPRT
argument_list|(
operator|(
literal|"ft%d: tape_cmd seek failed!\n"
operator|,
name|ftu
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|pcn
operator|!=
name|newcn
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: bad seek in tape_cmd; pcn = %d  newcn = %d\n"
operator|,
name|ftu
operator|,
name|ft
operator|->
name|pcn
operator|,
name|newcn
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|redo
goto|;
block|}
name|DELAY
argument_list|(
literal|2500
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Return status of tape drive  */
end_comment

begin_function
specifier|static
name|int
name|tape_status
parameter_list|(
name|ftu_t
name|ftu
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|err
decl_stmt|,
name|tries
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|int
name|max
init|=
operator|(
name|ft
operator|->
name|attaching
operator|)
condition|?
literal|2
else|:
literal|3
decl_stmt|;
for|for
control|(
name|r
operator|=
operator|-
literal|1
operator|,
name|tries
operator|=
literal|0
init|;
name|r
operator|<
literal|0
operator|&&
name|tries
operator|<
name|max
condition|;
name|tries
operator|++
control|)
name|r
operator|=
name|qic_status
argument_list|(
name|ftu
argument_list|,
name|QC_STATUS
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|tries
operator|==
name|max
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|recheck
label|:
name|DPRT
argument_list|(
operator|(
literal|"tape_status got $%04x\n"
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
name|ft
operator|->
name|laststs
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|r
operator|&
operator|(
name|QS_ERROR
operator||
name|QS_NEWCART
operator|)
condition|)
block|{
name|err
operator|=
name|qic_status
argument_list|(
name|ftu
argument_list|,
name|QC_ERRCODE
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|ft
operator|->
name|lasterr
operator|=
name|err
expr_stmt|;
if|if
condition|(
name|r
operator|&
name|QS_NEWCART
condition|)
block|{
name|ft
operator|->
name|newcart
operator|=
literal|1
expr_stmt|;
comment|/* If tape not referenced, do a seek load point. */
if|if
condition|(
operator|(
name|r
operator|&
name|QS_FMTOK
operator|)
operator|==
literal|0
operator|&&
operator|!
name|ft
operator|->
name|attaching
condition|)
block|{
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_SEEKLP
argument_list|)
expr_stmt|;
do|do
block|{
name|ftsleep
argument_list|(
name|wc_long_delay
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|r
operator|=
name|qic_status
argument_list|(
name|ftu
argument_list|,
name|QC_STATUS
argument_list|,
literal|8
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|r
operator|&
operator|(
name|QS_READY
operator||
name|QS_CART
operator|)
operator|)
operator|==
name|QS_CART
condition|)
do|;
goto|goto
name|recheck
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|err
operator|&&
operator|!
name|ft
operator|->
name|attaching
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: QIC error %d occurred on cmd %d\n"
operator|,
name|ftu
operator|,
name|err
operator|&
literal|0xff
operator|,
name|err
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|qic_status
argument_list|(
name|ftu
argument_list|,
name|QC_STATUS
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ft
operator|->
name|laststs
operator|=
name|r
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"tape_status got error code $%04x new sts = $%02x\n"
operator|,
name|err
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
block|}
name|ft
operator|->
name|rdonly
operator|=
operator|(
name|r
operator|&
name|QS_RDONLY
operator|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Transfer control to tape drive.  */
end_comment

begin_function
specifier|static
name|void
name|tape_start
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|motor
parameter_list|)
block|{
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|fdc_p
name|fdc
init|=
name|ft
operator|->
name|fdc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|mbits
decl_stmt|;
ifndef|#
directive|ifndef
name|PC98
specifier|static
name|int
name|mbmotor
index|[]
init|=
block|{
name|FDO_MOEN0
block|,
name|FDO_MOEN1
block|,
name|FDO_MOEN2
block|,
name|FDO_MOEN3
block|}
decl_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"tape_start start\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* reset, dma disable */
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
name|FDO_RST
operator||
name|FDO_FRY
operator||
name|FDO_AIE
operator||
name|FDO_MTON
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|ftintr_wait
argument_list|(
name|ftu
argument_list|,
name|FTCMD_RESET
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* raise reset, enable DMA, motor on if needed */
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
name|FDO_DMAE
operator||
name|FDO_MTON
argument_list|)
expr_stmt|;
else|#
directive|else
name|mbits
operator|=
name|ftu
operator|&
literal|3
expr_stmt|;
if|if
condition|(
name|motor
operator|&&
name|ftu
operator|<
literal|4
condition|)
name|mbits
operator||=
name|mbmotor
index|[
name|ftu
index|]
expr_stmt|;
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
name|FDO_FRST
operator||
name|FDO_FDMAEN
operator||
name|mbits
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|ftintr_wait
argument_list|(
name|ftu
argument_list|,
name|FTCMD_RESET
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|tape_recal
argument_list|(
name|ftu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set transfer speed */
ifndef|#
directive|ifndef
name|PC98
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDCTL
argument_list|,
name|FDC_500KBPS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRT
argument_list|(
operator|(
literal|"tape_start end\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Transfer control back to floppy disks.  */
end_comment

begin_function
specifier|static
name|void
name|tape_end
parameter_list|(
name|ftu_t
name|ftu
parameter_list|)
block|{
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|fdc_p
name|fdc
init|=
name|ft
operator|->
name|fdc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"tape_end start\n"
operator|)
argument_list|)
expr_stmt|;
name|tape_recal
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* reset, dma disable */
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
name|FDO_RST
operator||
name|FDO_FRY
operator||
name|FDO_AIE
operator||
name|FDO_MTON
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|ftintr_wait
argument_list|(
name|ftu
argument_list|,
name|FTCMD_RESET
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
comment|/* raise reset, enable DMA */
ifdef|#
directive|ifdef
name|PC98
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
name|FDO_DMAE
operator||
name|FDO_MTON
argument_list|)
expr_stmt|;
else|#
directive|else
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDOUT
argument_list|,
name|FDO_FRST
operator||
name|FDO_FDMAEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|ftintr_wait
argument_list|(
name|ftu
argument_list|,
name|FTCMD_RESET
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* set transfer speed */
ifndef|#
directive|ifndef
name|PC98
name|outb
argument_list|(
name|fdc
operator|->
name|baseport
operator|+
name|FDCTL
argument_list|,
name|FDC_500KBPS
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fdc
operator|->
name|flags
operator|&=
operator|~
name|FDC_TAPE_BUSY
expr_stmt|;
name|DPRT
argument_list|(
operator|(
literal|"tape_end end\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Wait for the driver to go inactive, cancel readahead if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|tape_inactive
parameter_list|(
name|ftu_t
name|ftu
parameter_list|)
block|{
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
name|ft
operator|->
name|segh
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ft
operator|->
name|segh
operator|->
name|reqtype
operator|==
name|FTIO_RDAHEAD
condition|)
block|{
comment|/* cancel read-ahead */
name|ft
operator|->
name|segh
operator|->
name|reqcan
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ft
operator|->
name|segh
operator|->
name|reqtype
operator|==
name|FTIO_WRITING
operator|&&
operator|!
name|ft
operator|->
name|active
condition|)
block|{
comment|/* flush out any remaining writes */
name|DPRT
argument_list|(
operator|(
literal|"Flushing write I/O chain\n"
operator|)
argument_list|)
expr_stmt|;
name|arq_state
operator|=
name|ard_state
operator|=
name|awr_state
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|xblk
operator|=
name|ft
operator|->
name|segh
operator|->
name|reqblk
expr_stmt|;
name|ft
operator|->
name|xseg
operator|=
name|ft
operator|->
name|segh
operator|->
name|reqseg
expr_stmt|;
name|ft
operator|->
name|xcnt
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|xptr
operator|=
name|ft
operator|->
name|segh
operator|->
name|buff
expr_stmt|;
name|ft
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|ft_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ftu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
name|ft
operator|->
name|active
condition|)
name|ftsleep
argument_list|(
name|wc_iosts_change
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  Get the geometry of the tape currently in the drive.  */
end_comment

begin_function
specifier|static
name|int
name|ftgetgeom
parameter_list|(
name|ftu_t
name|ftu
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|i
decl_stmt|,
name|tries
decl_stmt|;
name|int
name|cfg
decl_stmt|,
name|qic80
decl_stmt|,
name|ext
decl_stmt|;
name|int
name|sts
decl_stmt|,
name|fmt
decl_stmt|,
name|len
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|r
operator|=
name|tape_status
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
comment|/* XXX fix me when format mode is finished */
if|if
condition|(
name|r
operator|<
literal|0
operator|||
operator|(
name|r
operator|&
name|QS_CART
operator|)
operator|==
literal|0
operator|||
operator|(
name|r
operator|&
name|QS_FMTOK
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ftgetgeom: no cart or not formatted 0x%04x\n"
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
name|ftg
operator|=
name|NULL
expr_stmt|;
name|ft
operator|->
name|newcart
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Report drive configuration */
for|for
control|(
name|cfg
operator|=
operator|-
literal|1
operator|,
name|tries
operator|=
literal|0
init|;
name|cfg
operator|<
literal|0
operator|&&
name|tries
operator|<
literal|3
condition|;
name|tries
operator|++
control|)
name|cfg
operator|=
name|qic_status
argument_list|(
name|ftu
argument_list|,
name|QC_CONFIG
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|tries
operator|==
literal|3
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ftgetgeom report config failed\n"
operator|)
argument_list|)
expr_stmt|;
name|ftg
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|DPRT
argument_list|(
operator|(
literal|"ftgetgeom report config got $%04x\n"
operator|,
name|cfg
operator|)
argument_list|)
expr_stmt|;
name|ft
operator|->
name|lastcfg
operator|=
name|cfg
expr_stmt|;
name|qic80
operator|=
name|cfg
operator|&
name|QCF_QIC80
expr_stmt|;
name|ext
operator|=
name|cfg
operator|&
name|QCF_EXTRA
expr_stmt|;
comment|/*  *  XXX - This doesn't seem to work on my Colorado Jumbo 250...  *  if it works on your drive, I'd sure like to hear about it.  */
if|#
directive|if
literal|0
comment|/* Report drive status */
block|for (sts = -1, tries = 0; sts< 0&& tries< 3; tries++) 	sts = qic_status(ftu, QC_TSTATUS, 8);   if (tries == 3) { 	DPRT(("ftgetgeom report tape status failed\n")); 	ftg = NULL; 	return(-1);   }   DPRT(("ftgetgeom report tape status got $%04x\n", sts));
else|#
directive|else
comment|/*    *  XXX - Forge a fake tape status based upon the returned    *  configuration, since the above command or code is broken    *  for my drive and probably other older drives.    */
name|sts
operator|=
literal|0
expr_stmt|;
name|sts
operator|=
operator|(
name|qic80
operator|)
condition|?
name|QTS_QIC80
else|:
name|QTS_QIC40
expr_stmt|;
name|sts
operator||=
operator|(
name|ext
operator|)
condition|?
name|QTS_LEN2
else|:
name|QTS_LEN1
expr_stmt|;
endif|#
directive|endif
name|fmt
operator|=
name|sts
operator|&
name|QTS_FMMASK
expr_stmt|;
name|len
operator|=
operator|(
name|sts
operator|&
name|QTS_LNMASK
operator|)
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|fmt
operator|>
name|QCV_NFMT
condition|)
block|{
name|ftg
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"ft%d: unsupported tape format\n"
argument_list|,
name|ftu
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|>
name|QCV_NLEN
condition|)
block|{
name|ftg
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"ft%d: unsupported tape length\n"
argument_list|,
name|ftu
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Look up geometry in the table */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NGEOM
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ftgtbl
index|[
name|i
index|]
operator|.
name|g_fmtno
operator|==
name|fmt
operator|&&
name|ftgtbl
index|[
name|i
index|]
operator|.
name|g_lenno
operator|==
name|len
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|NGEOM
condition|)
block|{
name|printf
argument_list|(
literal|"ft%d: unknown tape geometry\n"
argument_list|,
name|ftu
argument_list|)
expr_stmt|;
name|ftg
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ftg
operator|=
operator|&
name|ftgtbl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ftg
operator|->
name|g_trktape
condition|)
block|{
name|printf
argument_list|(
literal|"ft%d: unsupported format %s w/len %s\n"
argument_list|,
name|ftu
argument_list|,
name|ftg
operator|->
name|g_fmtdesc
argument_list|,
name|ftg
operator|->
name|g_lendesc
argument_list|)
expr_stmt|;
name|ftg
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|DPRT
argument_list|(
operator|(
literal|"Tape format is %s, length is %s\n"
operator|,
name|ftg
operator|->
name|g_fmtdesc
operator|,
name|ftg
operator|->
name|g_lendesc
operator|)
argument_list|)
expr_stmt|;
name|ft
operator|->
name|newcart
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Switch between tape/floppy.  This will send the tape enable/disable  *  codes for this drive's manufacturer.  */
end_comment

begin_function
specifier|static
name|int
name|set_fdcmode
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|newmode
parameter_list|)
block|{
name|ftu_t
name|ftu
init|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|fdc_p
name|fdc
init|=
name|ft
operator|->
name|fdc
decl_stmt|;
specifier|static
name|int
name|havebufs
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SegReq
modifier|*
name|sp
decl_stmt|,
modifier|*
name|rsp
decl_stmt|;
if|if
condition|(
name|newmode
operator|==
name|FDC_TAPE_MODE
condition|)
block|{
comment|/* Wake up the tape drive */
switch|switch
condition|(
name|ft
operator|->
name|type
condition|)
block|{
case|case
name|NO_TYPE
case|:
name|fdc
operator|->
name|flags
operator|&=
operator|~
name|FDC_TAPE_BUSY
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
case|case
name|FT_NONE
case|:
name|tape_start
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_COLORADO
case|:
name|tape_start
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_COL_ENABLE1
argument_list|)
condition|)
block|{
name|tape_end
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_COL_ENABLE2
operator|+
name|ftu
argument_list|)
condition|)
block|{
name|tape_end
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
break|break;
case|case
name|FT_MOUNTAIN
case|:
name|tape_start
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_MTN_ENABLE1
argument_list|)
condition|)
block|{
name|tape_end
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_MTN_ENABLE2
argument_list|)
condition|)
block|{
name|tape_end
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
break|break;
case|case
name|FT_INSIGHT
case|:
name|tape_start
argument_list|(
name|ftu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRT
argument_list|(
operator|(
literal|"ft%d: bad tape type\n"
operator|,
name|ftu
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|tape_status
argument_list|(
name|ftu
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ft
operator|->
name|type
operator|==
name|FT_COLORADO
condition|)
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_COL_DISABLE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ft
operator|->
name|type
operator|==
name|FT_MOUNTAIN
condition|)
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_MTN_DISABLE
argument_list|)
expr_stmt|;
name|tape_end
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Grab buffers from memory. */
if|if
condition|(
operator|!
name|havebufs
condition|)
block|{
name|ft
operator|->
name|segh
operator|=
name|ft
operator|->
name|segt
operator|=
name|NULL
expr_stmt|;
name|ft
operator|->
name|doneh
operator|=
name|ft
operator|->
name|donet
operator|=
name|NULL
expr_stmt|;
name|ft
operator|->
name|segfree
operator|=
name|NULL
expr_stmt|;
name|ft
operator|->
name|hdr
operator|=
name|NULL
expr_stmt|;
name|ft
operator|->
name|nsegq
operator|=
name|ft
operator|->
name|ndoneq
operator|=
name|ft
operator|->
name|nfreelist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FTNBUFF
condition|;
name|i
operator|++
control|)
block|{
name|sp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SegReq
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ft%d: not enough memory for buffers\n"
argument_list|,
name|ftu
argument_list|)
expr_stmt|;
for|for
control|(
name|sp
operator|=
name|ft
operator|->
name|segfree
init|;
name|sp
operator|!=
name|NULL
condition|;
name|sp
operator|=
name|sp
operator|->
name|next
control|)
name|free
argument_list|(
name|sp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|type
operator|==
name|FT_COLORADO
condition|)
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_COL_DISABLE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ft
operator|->
name|type
operator|==
name|FT_MOUNTAIN
condition|)
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_MTN_DISABLE
argument_list|)
expr_stmt|;
name|tape_end
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|sp
operator|->
name|reqtype
operator|=
name|FTIO_READY
expr_stmt|;
name|sp
operator|->
name|next
operator|=
name|ft
operator|->
name|segfree
expr_stmt|;
name|ft
operator|->
name|segfree
operator|=
name|sp
expr_stmt|;
name|ft
operator|->
name|nfreelist
operator|++
expr_stmt|;
block|}
comment|/* take one buffer for header */
name|ft
operator|->
name|hdr
operator|=
name|ft
operator|->
name|segfree
expr_stmt|;
name|ft
operator|->
name|segfree
operator|=
name|ft
operator|->
name|segfree
operator|->
name|next
expr_stmt|;
name|ft
operator|->
name|nfreelist
operator|--
expr_stmt|;
name|havebufs
operator|=
literal|1
expr_stmt|;
block|}
name|ft
operator|->
name|io_sts
operator|=
name|FTIO_READY
expr_stmt|;
comment|/* tape drive is ready */
name|ft
operator|->
name|active
operator|=
literal|0
expr_stmt|;
comment|/* interrupt driver not active */
name|ft
operator|->
name|moving
operator|=
literal|0
expr_stmt|;
comment|/* tape not moving */
name|ft
operator|->
name|rdonly
operator|=
literal|0
expr_stmt|;
comment|/* tape read only */
name|ft
operator|->
name|newcart
operator|=
literal|0
expr_stmt|;
comment|/* new cartridge flag */
name|ft
operator|->
name|lastpos
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* tape is rewound */
name|async_func
operator|=
name|ACMD_NONE
expr_stmt|;
comment|/* No async function */
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_RATE
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QCF_RT500
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* 500K bps */
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|ft
operator|->
name|mode
operator|=
name|FTM_PRIMARY
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_PRIMARY
argument_list|)
expr_stmt|;
comment|/* Make sure we're in primary mode */
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|ftg
operator|=
name|NULL
expr_stmt|;
comment|/* No geometry yet */
name|ftgetgeom
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
comment|/* Get tape geometry */
name|ftreq_rewind
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
comment|/* Make sure tape is rewound */
block|}
else|else
block|{
if|if
condition|(
name|ft
operator|->
name|type
operator|==
name|FT_COLORADO
condition|)
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_COL_DISABLE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ft
operator|->
name|type
operator|==
name|FT_MOUNTAIN
condition|)
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_MTN_DISABLE
argument_list|)
expr_stmt|;
name|tape_end
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
name|ft
operator|->
name|newcart
operator|=
literal|0
expr_stmt|;
comment|/* clear new cartridge */
if|if
condition|(
name|ft
operator|->
name|hdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ft
operator|->
name|hdr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|havebufs
condition|)
block|{
for|for
control|(
name|sp
operator|=
name|ft
operator|->
name|segfree
init|;
name|sp
operator|!=
name|NULL
condition|;
control|)
block|{
name|rsp
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|rsp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|ft
operator|->
name|segh
init|;
name|sp
operator|!=
name|NULL
condition|;
control|)
block|{
name|rsp
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|rsp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|sp
operator|=
name|ft
operator|->
name|doneh
init|;
name|sp
operator|!=
name|NULL
condition|;
control|)
block|{
name|rsp
operator|=
name|sp
expr_stmt|;
name|sp
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|rsp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
name|havebufs
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Perform a QIC status function.  */
end_comment

begin_function
specifier|static
name|int
name|qic_status
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|nbits
parameter_list|)
block|{
name|int
name|st3
decl_stmt|,
name|r
decl_stmt|,
name|i
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|fdcu_t
name|fdcu
init|=
name|ft
operator|->
name|fdc
operator|->
name|fdcu
decl_stmt|;
comment|/* fdc active unit */
if|if
condition|(
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: QIC status timeout\n"
operator|,
name|ftu
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Sense drive status */
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SENSED
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|ftu
argument_list|)
expr_stmt|;
name|st3
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|st3
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* track 0 */
name|DPRT
argument_list|(
operator|(
literal|"qic_status has dead drive...  st3 = $%02x\n"
operator|,
name|st3
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
name|r
operator|=
literal|0
init|;
name|i
operator|<=
name|nbits
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_NEXTBIT
argument_list|)
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: QIC status bit timed out on %d\n"
operator|,
name|ftu
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|NE7CMD_SENSED
argument_list|)
expr_stmt|;
name|out_fdc
argument_list|(
name|fdcu
argument_list|,
name|ftu
argument_list|)
expr_stmt|;
name|st3
operator|=
name|in_fdc
argument_list|(
name|fdcu
argument_list|)
expr_stmt|;
if|if
condition|(
name|st3
operator|<
literal|0
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: controller timed out on bit %d r=$%02x\n"
operator|,
name|ftu
operator|,
name|i
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|r
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nbits
condition|)
name|r
operator||=
operator|(
operator|(
name|st3
operator|&
literal|0x10
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
operator|<<
name|nbits
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|st3
operator|&
literal|0x10
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"ft%d: qic status stop bit missing at %d, st3=$%02x r=$%04x\n"
operator|,
name|ftu
operator|,
name|i
operator|,
name|st3
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|DPRT
argument_list|(
operator|(
literal|"qic_status returned $%02x\n"
operator|,
name|r
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Open tape drive for use.  Bounced off of Fdopen if tape minor is  *  detected.  */
end_comment

begin_function
name|int
name|ftopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
name|ftu_t
name|ftu
init|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|fdc_p
name|fdc
decl_stmt|;
comment|/* check bounds */
if|if
condition|(
name|ftu
operator|>=
name|NFT
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|ft_data
index|[
name|ftu
index|]
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|fdc
operator|=
name|ft_data
index|[
name|ftu
index|]
operator|->
name|fdc
expr_stmt|;
if|if
condition|(
operator|(
name|fdc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ft_data
index|[
name|ftu
index|]
operator|->
name|type
operator|==
name|NO_TYPE
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* check for controller already busy with tape */
if|if
condition|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_TAPE_BUSY
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* make sure we found a tape when probed */
if|if
condition|(
operator|!
operator|(
name|fdc
operator|->
name|flags
operator|&
name|FDC_HASFTAPE
operator|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|fdc
operator|->
name|fdu
operator|=
name|ftu
expr_stmt|;
name|fdc
operator|->
name|flags
operator||=
name|FDC_TAPE_BUSY
expr_stmt|;
return|return
operator|(
name|set_fdcmode
argument_list|(
name|dev
argument_list|,
name|FDC_TAPE_MODE
argument_list|)
operator|)
return|;
comment|/* try to switch to tape */
block|}
end_function

begin_comment
comment|/*  *  Close tape and return floppy controller to disk mode.  */
end_comment

begin_function
name|int
name|ftclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ftu_t
name|ftu
init|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
comment|/* Wait for any remaining I/O activity to complete. */
name|tape_inactive
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
name|ft
operator|->
name|mode
operator|=
name|FTM_PRIMARY
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_PRIMARY
argument_list|)
expr_stmt|;
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|ftreq_rewind
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
return|return
operator|(
name|set_fdcmode
argument_list|(
name|dev
argument_list|,
name|FDC_DISK_MODE
argument_list|)
operator|)
return|;
comment|/* Otherwise, close tape */
block|}
end_function

begin_comment
comment|/*  *  Read or write a segment.  */
end_comment

begin_function
specifier|static
name|int
name|ftreq_rw
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|cmd
parameter_list|,
name|QIC_Segment
modifier|*
name|sr
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|i
decl_stmt|;
name|SegReq
modifier|*
name|sp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|long
name|blk
decl_stmt|,
name|bad
decl_stmt|,
name|seg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ft
operator|->
name|active
operator|&&
name|ft
operator|->
name|segh
operator|==
name|NULL
condition|)
block|{
name|r
operator|=
name|tape_status
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
name|QS_CART
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* No cartridge */
if|if
condition|(
operator|(
name|r
operator|&
name|QS_FMTOK
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Not formatted */
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ftg
operator|==
name|NULL
operator|||
name|ft
operator|->
name|newcart
condition|)
block|{
name|tape_inactive
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftgetgeom
argument_list|(
name|ftu
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Write not allowed on a read-only tape. */
if|if
condition|(
name|cmd
operator|==
name|QIOWRITE
operator|&&
name|ft
operator|->
name|rdonly
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
comment|/* Quick check of request and buffer. */
if|if
condition|(
name|sr
operator|==
name|NULL
operator|||
name|sr
operator|->
name|sg_data
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Make sure requested track and segment is in range. */
if|if
condition|(
name|sr
operator|->
name|sg_trk
operator|>=
name|ftg
operator|->
name|g_trktape
operator|||
name|sr
operator|->
name|sg_seg
operator|>=
name|ftg
operator|->
name|g_segtrk
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|blk
operator|=
name|sr
operator|->
name|sg_trk
operator|*
name|ftg
operator|->
name|g_blktrk
operator|+
name|sr
operator|->
name|sg_seg
operator|*
name|QCV_BLKSEG
expr_stmt|;
name|seg
operator|=
name|sr
operator|->
name|sg_trk
operator|*
name|ftg
operator|->
name|g_segtrk
operator|+
name|sr
operator|->
name|sg_seg
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|QIOREAD
condition|)
block|{
comment|/* 	 *  See if the driver is reading ahead. 	 */
if|if
condition|(
name|ft
operator|->
name|doneh
operator|!=
name|NULL
operator|||
operator|(
name|ft
operator|->
name|segh
operator|!=
name|NULL
operator|&&
name|ft
operator|->
name|segh
operator|->
name|reqtype
operator|==
name|FTIO_RDAHEAD
operator|)
condition|)
block|{
comment|/* 		 *  Eat the completion queue and see if the request 		 *  is already there. 		 */
while|while
condition|(
name|ft
operator|->
name|doneh
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|blk
operator|==
name|ft
operator|->
name|doneh
operator|->
name|reqblk
condition|)
block|{
name|sp
operator|=
name|ft
operator|->
name|doneh
expr_stmt|;
name|sp
operator|->
name|reqtype
operator|=
name|FTIO_READING
expr_stmt|;
name|sp
operator|->
name|reqbad
operator|=
name|sr
operator|->
name|sg_badmap
expr_stmt|;
goto|goto
name|rddone
goto|;
block|}
name|segio_free
argument_list|(
name|ft
argument_list|,
name|ft
operator|->
name|doneh
argument_list|)
expr_stmt|;
block|}
comment|/* 		 *  Not on the completed queue, in progress maybe? 		 */
if|if
condition|(
name|ft
operator|->
name|segh
operator|!=
name|NULL
operator|&&
name|ft
operator|->
name|segh
operator|->
name|reqtype
operator|==
name|FTIO_RDAHEAD
operator|&&
name|blk
operator|==
name|ft
operator|->
name|segh
operator|->
name|reqblk
condition|)
block|{
name|sp
operator|=
name|ft
operator|->
name|segh
expr_stmt|;
name|sp
operator|->
name|reqtype
operator|=
name|FTIO_READING
expr_stmt|;
name|sp
operator|->
name|reqbad
operator|=
name|sr
operator|->
name|sg_badmap
expr_stmt|;
goto|goto
name|rdwait
goto|;
block|}
block|}
comment|/* Wait until we're ready. */
name|tape_inactive
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
comment|/* Set up a new read request. */
name|sp
operator|=
name|segio_alloc
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|sp
operator|->
name|reqcrc
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|reqbad
operator|=
name|sr
operator|->
name|sg_badmap
expr_stmt|;
name|sp
operator|->
name|reqblk
operator|=
name|blk
expr_stmt|;
name|sp
operator|->
name|reqseg
operator|=
name|seg
expr_stmt|;
name|sp
operator|->
name|reqcan
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|reqtype
operator|=
name|FTIO_READING
expr_stmt|;
name|segio_queue
argument_list|(
name|ft
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Start the read request off. */
name|DPRT
argument_list|(
operator|(
literal|"Starting read I/O chain\n"
operator|)
argument_list|)
expr_stmt|;
name|arq_state
operator|=
name|ard_state
operator|=
name|awr_state
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|xblk
operator|=
name|sp
operator|->
name|reqblk
expr_stmt|;
name|ft
operator|->
name|xseg
operator|=
name|sp
operator|->
name|reqseg
expr_stmt|;
name|ft
operator|->
name|xcnt
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|xptr
operator|=
name|sp
operator|->
name|buff
expr_stmt|;
name|ft
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|ft_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ftu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rdwait
label|:
name|ftsleep
argument_list|(
name|wc_buff_done
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rddone
label|:
name|bad
operator|=
name|sp
operator|->
name|reqbad
expr_stmt|;
name|sr
operator|->
name|sg_crcmap
operator|=
name|sp
operator|->
name|reqcrc
operator|&
operator|~
name|bad
expr_stmt|;
comment|/* Copy out segment and discard bad mapped blocks. */
name|cp
operator|=
name|sp
operator|->
name|buff
expr_stmt|;
name|cp2
operator|=
name|sr
operator|->
name|sg_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QCV_BLKSEG
condition|;
name|cp
operator|+=
name|QCV_BLKSIZE
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bad
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
continue|continue;
name|copyout
argument_list|(
name|cp
argument_list|,
name|cp2
argument_list|,
name|QCV_BLKSIZE
argument_list|)
expr_stmt|;
name|cp2
operator|+=
name|QCV_BLKSIZE
expr_stmt|;
block|}
name|segio_free
argument_list|(
name|ft
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ft
operator|->
name|segh
operator|!=
name|NULL
operator|&&
name|ft
operator|->
name|segh
operator|->
name|reqtype
operator|!=
name|FTIO_WRITING
condition|)
name|tape_inactive
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
comment|/* Allocate a buffer and start tape if we're running low. */
name|sp
operator|=
name|segio_alloc
argument_list|(
name|ft
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ft
operator|->
name|active
operator|&&
operator|(
name|sp
operator|==
name|NULL
operator|||
name|ft
operator|->
name|nfreelist
operator|<=
literal|1
operator|)
condition|)
block|{
name|DPRT
argument_list|(
operator|(
literal|"Starting write I/O chain\n"
operator|)
argument_list|)
expr_stmt|;
name|arq_state
operator|=
name|ard_state
operator|=
name|awr_state
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|xblk
operator|=
name|ft
operator|->
name|segh
operator|->
name|reqblk
expr_stmt|;
name|ft
operator|->
name|xseg
operator|=
name|ft
operator|->
name|segh
operator|->
name|reqseg
expr_stmt|;
name|ft
operator|->
name|xcnt
operator|=
literal|0
expr_stmt|;
name|ft
operator|->
name|xptr
operator|=
name|ft
operator|->
name|segh
operator|->
name|buff
expr_stmt|;
name|ft
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|ft_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ftu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Sleep until a buffer becomes available. */
while|while
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|ftsleep
argument_list|(
name|wc_buff_avail
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sp
operator|=
name|segio_alloc
argument_list|(
name|ft
argument_list|)
expr_stmt|;
block|}
comment|/* Copy in segment and expand bad blocks. */
name|bad
operator|=
name|sr
operator|->
name|sg_badmap
expr_stmt|;
name|cp
operator|=
name|sr
operator|->
name|sg_data
expr_stmt|;
name|cp2
operator|=
name|sp
operator|->
name|buff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QCV_BLKSEG
condition|;
name|cp2
operator|+=
name|QCV_BLKSIZE
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bad
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
continue|continue;
name|copyin
argument_list|(
name|cp
argument_list|,
name|cp2
argument_list|,
name|QCV_BLKSIZE
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|QCV_BLKSIZE
expr_stmt|;
block|}
name|sp
operator|->
name|reqblk
operator|=
name|blk
expr_stmt|;
name|sp
operator|->
name|reqseg
operator|=
name|seg
expr_stmt|;
name|sp
operator|->
name|reqcan
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|reqtype
operator|=
name|FTIO_WRITING
expr_stmt|;
name|segio_queue
argument_list|(
name|ft
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Rewind to beginning of tape  */
end_comment

begin_function
specifier|static
name|int
name|ftreq_rewind
parameter_list|(
name|ftu_t
name|ftu
parameter_list|)
block|{
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|tape_inactive
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_STOP
argument_list|)
expr_stmt|;
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_SEEKSTART
argument_list|)
expr_stmt|;
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_SEEKTRACK
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
name|ft
operator|->
name|lastpos
operator|=
operator|-
literal|1
expr_stmt|;
name|ft
operator|->
name|moving
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Move to logical beginning or end of track  */
end_comment

begin_function
specifier|static
name|int
name|ftreq_trkpos
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|req
parameter_list|)
block|{
name|int
name|curtrk
decl_stmt|,
name|r
decl_stmt|,
name|cmd
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|tape_inactive
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_STOP
argument_list|)
expr_stmt|;
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
name|r
operator|=
name|tape_status
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
name|QS_CART
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* No cartridge */
if|if
condition|(
operator|(
name|r
operator|&
name|QS_FMTOK
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Not formatted */
if|if
condition|(
name|ftg
operator|==
name|NULL
operator|||
name|ft
operator|->
name|newcart
condition|)
block|{
if|if
condition|(
name|ftgetgeom
argument_list|(
name|ftu
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|curtrk
operator|=
operator|(
name|ft
operator|->
name|lastpos
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|ft
operator|->
name|lastpos
operator|/
name|ftg
operator|->
name|g_blktrk
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|QIOBOT
condition|)
name|cmd
operator|=
operator|(
name|curtrk
operator|&
literal|1
operator|)
condition|?
name|QC_SEEKEND
else|:
name|QC_SEEKSTART
expr_stmt|;
else|else
name|cmd
operator|=
operator|(
name|curtrk
operator|&
literal|1
operator|)
condition|?
name|QC_SEEKSTART
else|:
name|QC_SEEKEND
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Seek tape head to a particular track.  */
end_comment

begin_function
specifier|static
name|int
name|ftreq_trkset
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
modifier|*
name|trk
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|tape_inactive
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_STOP
argument_list|)
expr_stmt|;
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
name|r
operator|=
name|tape_status
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|&
name|QS_CART
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* No cartridge */
if|if
condition|(
operator|(
name|r
operator|&
name|QS_FMTOK
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Not formatted */
if|if
condition|(
name|ftg
operator|==
name|NULL
operator|||
name|ft
operator|->
name|newcart
condition|)
block|{
if|if
condition|(
name|ftgetgeom
argument_list|(
name|ftu
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_SEEKTRACK
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
operator|*
name|trk
operator|+
literal|2
argument_list|)
expr_stmt|;
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Start tape moving forward.  */
end_comment

begin_function
specifier|static
name|int
name|ftreq_lfwd
parameter_list|(
name|ftu_t
name|ftu
parameter_list|)
block|{
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|tape_inactive
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_STOP
argument_list|)
expr_stmt|;
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_FORWARD
argument_list|)
expr_stmt|;
name|ft
operator|->
name|moving
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Stop the tape  */
end_comment

begin_function
specifier|static
name|int
name|ftreq_stop
parameter_list|(
name|ftu_t
name|ftu
parameter_list|)
block|{
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|tape_inactive
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_STOP
argument_list|)
expr_stmt|;
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|90
argument_list|)
expr_stmt|;
name|ft
operator|->
name|moving
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Set the particular mode the drive should be in.  */
end_comment

begin_function
specifier|static
name|int
name|ftreq_setmode
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|tape_inactive
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
name|r
operator|=
name|tape_status
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|QIOPRIMARY
case|:
name|ft
operator|->
name|mode
operator|=
name|FTM_PRIMARY
expr_stmt|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_PRIMARY
argument_list|)
expr_stmt|;
break|break;
case|case
name|QIOFORMAT
case|:
if|if
condition|(
name|r
operator|&
name|QS_RDONLY
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|r
operator|&
name|QS_BOT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_FORMAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|QIOVERIFY
case|:
if|if
condition|(
operator|(
name|r
operator|&
name|QS_FMTOK
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Not formatted */
name|tape_cmd
argument_list|(
name|ftu
argument_list|,
name|QC_VERIFY
argument_list|)
expr_stmt|;
break|break;
block|}
name|tape_state
argument_list|(
name|ftu
argument_list|,
literal|0
argument_list|,
name|QS_READY
argument_list|,
literal|60
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Return drive status bits  */
end_comment

begin_function
specifier|static
name|int
name|ftreq_status
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
modifier|*
name|sts
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
if|if
condition|(
name|ft
operator|->
name|active
condition|)
operator|*
name|sts
operator|=
name|ft
operator|->
name|laststs
operator|&
operator|~
name|QS_READY
expr_stmt|;
else|else
operator|*
name|sts
operator|=
name|tape_status
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Return drive configuration bits  */
end_comment

begin_function
specifier|static
name|int
name|ftreq_config
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
modifier|*
name|cfg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|tries
decl_stmt|;
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
if|if
condition|(
name|ft
operator|->
name|active
condition|)
name|r
operator|=
name|ft
operator|->
name|lastcfg
expr_stmt|;
else|else
block|{
for|for
control|(
name|r
operator|=
operator|-
literal|1
operator|,
name|tries
operator|=
literal|0
init|;
name|r
operator|<
literal|0
operator|&&
name|tries
operator|<
literal|3
condition|;
name|tries
operator|++
control|)
name|r
operator|=
name|qic_status
argument_list|(
name|ftu
argument_list|,
name|QC_CONFIG
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|tries
operator|==
literal|3
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
operator|*
name|cfg
operator|=
name|r
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Return current tape's geometry.  */
end_comment

begin_function
specifier|static
name|int
name|ftreq_geom
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|QIC_Geom
modifier|*
name|g
parameter_list|)
block|{
name|tape_inactive
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftg
operator|==
name|NULL
operator|&&
name|ftgetgeom
argument_list|(
name|ftu
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bcopy
argument_list|(
name|ftg
argument_list|,
name|g
argument_list|,
sizeof|sizeof
argument_list|(
name|QIC_Geom
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Return drive hardware information  */
end_comment

begin_function
specifier|static
name|int
name|ftreq_hwinfo
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|QIC_HWInfo
modifier|*
name|hwp
parameter_list|)
block|{
name|int
name|tries
decl_stmt|;
name|int
name|rom
decl_stmt|,
name|vend
decl_stmt|;
name|tape_inactive
argument_list|(
name|ftu
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hwp
argument_list|,
sizeof|sizeof
argument_list|(
name|QIC_HWInfo
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|rom
operator|=
operator|-
literal|1
operator|,
name|tries
operator|=
literal|0
init|;
name|rom
operator|<
literal|0
operator|&&
name|tries
operator|<
literal|3
condition|;
name|tries
operator|++
control|)
name|rom
operator|=
name|qic_status
argument_list|(
name|ftu
argument_list|,
name|QC_VERSION
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|rom
operator|>
literal|0
condition|)
block|{
name|hwp
operator|->
name|hw_rombeta
operator|=
operator|(
name|rom
operator|>>
literal|7
operator|)
operator|&
literal|0x01
expr_stmt|;
name|hwp
operator|->
name|hw_romid
operator|=
name|rom
operator|&
literal|0x7f
expr_stmt|;
block|}
for|for
control|(
name|vend
operator|=
operator|-
literal|1
operator|,
name|tries
operator|=
literal|0
init|;
name|vend
operator|<
literal|0
operator|&&
name|tries
operator|<
literal|3
condition|;
name|tries
operator|++
control|)
name|vend
operator|=
name|qic_status
argument_list|(
name|ftu
argument_list|,
name|QC_VENDORID
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|vend
operator|>
literal|0
condition|)
block|{
name|hwp
operator|->
name|hw_make
operator|=
operator|(
name|vend
operator|>>
literal|6
operator|)
operator|&
literal|0x3ff
expr_stmt|;
name|hwp
operator|->
name|hw_model
operator|=
name|vend
operator|&
literal|0x3f
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Receive or Send the in-core header segment.  */
end_comment

begin_function
specifier|static
name|int
name|ftreq_hdr
parameter_list|(
name|ftu_t
name|ftu
parameter_list|,
name|int
name|cmd
parameter_list|,
name|QIC_Segment
modifier|*
name|sp
parameter_list|)
block|{
name|ft_p
name|ft
init|=
name|ft_data
index|[
name|ftu
index|]
decl_stmt|;
name|QIC_Header
modifier|*
name|h
init|=
operator|(
name|QIC_Header
operator|*
operator|)
name|ft
operator|->
name|hdr
operator|->
name|buff
decl_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
operator|||
name|sp
operator|->
name|sg_data
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cmd
operator|==
name|QIOSENDHDR
condition|)
block|{
name|copyin
argument_list|(
name|sp
operator|->
name|sg_data
argument_list|,
name|ft
operator|->
name|hdr
operator|->
name|buff
argument_list|,
name|QCV_SEGSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|h
operator|->
name|qh_sig
operator|!=
name|QCV_HDRMAGIC
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|copyout
argument_list|(
name|ft
operator|->
name|hdr
operator|->
name|buff
argument_list|,
name|sp
operator|->
name|sg_data
argument_list|,
name|QCV_SEGSIZE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  I/O functions.  */
end_comment

begin_function
name|int
name|ftioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|ftu_t
name|ftu
init|=
name|FDUNIT
argument_list|(
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|QIOREAD
case|:
comment|/* Request reading a segment from tape.		*/
case|case
name|QIOWRITE
case|:
comment|/* Request writing a segment to tape.		*/
return|return
operator|(
name|ftreq_rw
argument_list|(
name|ftu
argument_list|,
name|cmd
argument_list|,
operator|(
name|QIC_Segment
operator|*
operator|)
name|data
argument_list|,
name|p
argument_list|)
operator|)
return|;
case|case
name|QIOREWIND
case|:
comment|/* Rewind tape.					*/
return|return
operator|(
name|ftreq_rewind
argument_list|(
name|ftu
argument_list|)
operator|)
return|;
case|case
name|QIOBOT
case|:
comment|/* Seek to logical beginning of track.		*/
case|case
name|QIOEOT
case|:
comment|/* Seek to logical end of track.		*/
return|return
operator|(
name|ftreq_trkpos
argument_list|(
name|ftu
argument_list|,
name|cmd
argument_list|)
operator|)
return|;
case|case
name|QIOTRACK
case|:
comment|/* Seek tape head to specified track.		*/
return|return
operator|(
name|ftreq_trkset
argument_list|(
name|ftu
argument_list|,
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
operator|)
return|;
case|case
name|QIOSEEKLP
case|:
comment|/* Seek load point.				*/
goto|goto
name|badreq
goto|;
case|case
name|QIOFORWARD
case|:
comment|/* Move tape in logical forward direction.	*/
return|return
operator|(
name|ftreq_lfwd
argument_list|(
name|ftu
argument_list|)
operator|)
return|;
case|case
name|QIOSTOP
case|:
comment|/* Causes tape to stop.				*/
return|return
operator|(
name|ftreq_stop
argument_list|(
name|ftu
argument_list|)
operator|)
return|;
case|case
name|QIOPRIMARY
case|:
comment|/* Enter primary mode.				*/
case|case
name|QIOFORMAT
case|:
comment|/* Enter format mode.				*/
case|case
name|QIOVERIFY
case|:
comment|/* Enter verify mode.				*/
return|return
operator|(
name|ftreq_setmode
argument_list|(
name|ftu
argument_list|,
name|cmd
argument_list|)
operator|)
return|;
case|case
name|QIOWRREF
case|:
comment|/* Write reference burst.			*/
goto|goto
name|badreq
goto|;
case|case
name|QIOSTATUS
case|:
comment|/* Get drive status.				*/
return|return
operator|(
name|ftreq_status
argument_list|(
name|ftu
argument_list|,
name|cmd
argument_list|,
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|p
argument_list|)
operator|)
return|;
case|case
name|QIOCONFIG
case|:
comment|/* Get tape configuration.			*/
return|return
operator|(
name|ftreq_config
argument_list|(
name|ftu
argument_list|,
name|cmd
argument_list|,
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
name|p
argument_list|)
operator|)
return|;
case|case
name|QIOGEOM
case|:
return|return
operator|(
name|ftreq_geom
argument_list|(
name|ftu
argument_list|,
operator|(
name|QIC_Geom
operator|*
operator|)
name|data
argument_list|)
operator|)
return|;
case|case
name|QIOHWINFO
case|:
return|return
operator|(
name|ftreq_hwinfo
argument_list|(
name|ftu
argument_list|,
operator|(
name|QIC_HWInfo
operator|*
operator|)
name|data
argument_list|)
operator|)
return|;
case|case
name|QIOSENDHDR
case|:
case|case
name|QIORECVHDR
case|:
return|return
operator|(
name|ftreq_hdr
argument_list|(
name|ftu
argument_list|,
name|cmd
argument_list|,
operator|(
name|QIC_Segment
operator|*
operator|)
name|data
argument_list|)
operator|)
return|;
block|}
name|badreq
label|:
name|DPRT
argument_list|(
operator|(
literal|"ft%d: unknown ioctl(%d) request\n"
operator|,
name|ftu
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

