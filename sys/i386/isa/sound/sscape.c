begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/sscape.c  *   * Low level driver for Ensoniq Soundscape  *   * Copyright by Hannu Savolainen 1994  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/sound/sound_config.h>
end_include

begin_if
if|#
directive|if
name|NSSCAPE
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<i386/isa/sound/coproc.h>
end_include

begin_define
define|#
directive|define
name|EXCLUDE_NATIVE_PCM
end_define

begin_comment
comment|/*  * I/O ports  */
end_comment

begin_define
define|#
directive|define
name|MIDI_DATA
value|0
end_define

begin_define
define|#
directive|define
name|MIDI_CTRL
value|1
end_define

begin_define
define|#
directive|define
name|HOST_CTRL
value|2
end_define

begin_define
define|#
directive|define
name|TX_READY
value|0x02
end_define

begin_define
define|#
directive|define
name|RX_READY
value|0x01
end_define

begin_define
define|#
directive|define
name|HOST_DATA
value|3
end_define

begin_define
define|#
directive|define
name|ODIE_ADDR
value|4
end_define

begin_define
define|#
directive|define
name|ODIE_DATA
value|5
end_define

begin_comment
comment|/*  * Indirect registers  */
end_comment

begin_define
define|#
directive|define
name|GA_INTSTAT_REG
value|0
end_define

begin_define
define|#
directive|define
name|GA_INTENA_REG
value|1
end_define

begin_define
define|#
directive|define
name|GA_DMAA_REG
value|2
end_define

begin_define
define|#
directive|define
name|GA_DMAB_REG
value|3
end_define

begin_define
define|#
directive|define
name|GA_INTCFG_REG
value|4
end_define

begin_define
define|#
directive|define
name|GA_DMACFG_REG
value|5
end_define

begin_define
define|#
directive|define
name|GA_CDCFG_REG
value|6
end_define

begin_define
define|#
directive|define
name|GA_SMCFGA_REG
value|7
end_define

begin_define
define|#
directive|define
name|GA_SMCFGB_REG
value|8
end_define

begin_define
define|#
directive|define
name|GA_HMCTL_REG
value|9
end_define

begin_comment
comment|/*  * DMA channel identifiers (A and B)  */
end_comment

begin_define
define|#
directive|define
name|SSCAPE_DMA_A
value|0
end_define

begin_define
define|#
directive|define
name|SSCAPE_DMA_B
value|1
end_define

begin_define
define|#
directive|define
name|PORT
parameter_list|(
name|name
parameter_list|)
value|(devc->base+name)
end_define

begin_comment
comment|/*  * Host commands recognized by the OBP microcode  */
end_comment

begin_define
define|#
directive|define
name|CMD_GEN_HOST_ACK
value|0x80
end_define

begin_define
define|#
directive|define
name|CMD_GEN_MPU_ACK
value|0x81
end_define

begin_define
define|#
directive|define
name|CMD_GET_BOARD_TYPE
value|0x82
end_define

begin_define
define|#
directive|define
name|CMD_SET_CONTROL
value|0x88
end_define

begin_define
define|#
directive|define
name|CMD_GET_CONTROL
value|0x89
end_define

begin_define
define|#
directive|define
name|CTL_MASTER_VOL
value|0
end_define

begin_define
define|#
directive|define
name|CTL_MIC_MODE
value|2
end_define

begin_define
define|#
directive|define
name|CTL_SYNTH_VOL
value|4
end_define

begin_define
define|#
directive|define
name|CTL_WAVE_VOL
value|7
end_define

begin_define
define|#
directive|define
name|CMD_SET_MT32
value|0x96
end_define

begin_define
define|#
directive|define
name|CMD_GET_MT32
value|0x97
end_define

begin_define
define|#
directive|define
name|CMD_SET_EXTMIDI
value|0x9b
end_define

begin_define
define|#
directive|define
name|CMD_GET_EXTMIDI
value|0x9c
end_define

begin_define
define|#
directive|define
name|CMD_ACK
value|0x80
end_define

begin_typedef
typedef|typedef
struct|struct
name|sscape_info
block|{
name|int
name|base
decl_stmt|,
name|irq
decl_stmt|,
name|dma
decl_stmt|;
name|int
name|ok
decl_stmt|;
comment|/* Properly detected */
name|int
name|failed
decl_stmt|;
name|int
name|dma_allocated
decl_stmt|;
name|int
name|my_audiodev
decl_stmt|;
name|int
name|opened
decl_stmt|;
name|sound_os_info
modifier|*
name|osp
decl_stmt|;
block|}
name|sscape_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|sscape_info
name|dev_info
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sscape_info
modifier|*
name|devc
init|=
operator|&
name|dev_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|sscape_sleeper
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|struct
name|snd_wait
name|sscape_sleep_flag
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some older cards have assigned interrupt bits differently than new ones */
end_comment

begin_decl_stmt
specifier|static
name|char
name|valid_interrupts_old
index|[]
init|=
block|{
literal|9
block|,
literal|7
block|,
literal|5
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|valid_interrupts_new
index|[]
init|=
block|{
literal|9
block|,
literal|5
block|,
literal|7
block|,
literal|10
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|valid_interrupts
init|=
name|valid_interrupts_new
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|REVEAL_SPEA
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|old_hardware
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|old_hardware
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|u_char
name|sscape_read
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|u_char
name|val
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|PORT
argument_list|(
name|ODIE_ADDR
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|PORT
argument_list|(
name|ODIE_DATA
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sscape_write
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|,
name|int
name|reg
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|PORT
argument_list|(
name|ODIE_ADDR
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PORT
argument_list|(
name|ODIE_DATA
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|host_open
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
argument_list|(
name|HOST_CTRL
argument_list|)
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Put the board to the host mode */
block|}
end_function

begin_function
specifier|static
name|void
name|host_close
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|)
block|{
name|outb
argument_list|(
name|PORT
argument_list|(
name|HOST_CTRL
argument_list|)
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Put the board to the MIDI mode */
block|}
end_function

begin_function
specifier|static
name|int
name|host_write
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|,
name|timeout_val
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* 	 * Send the command and data bytes 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|timeout_val
operator|=
literal|10000
init|;
name|timeout_val
operator|>
literal|0
condition|;
name|timeout_val
operator|--
control|)
if|if
condition|(
name|inb
argument_list|(
name|PORT
argument_list|(
name|HOST_CTRL
argument_list|)
argument_list|)
operator|&
name|TX_READY
condition|)
break|break;
if|if
condition|(
name|timeout_val
operator|<=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|outb
argument_list|(
name|PORT
argument_list|(
name|HOST_DATA
argument_list|)
argument_list|,
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|host_read
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|int
name|timeout_val
decl_stmt|;
name|u_char
name|data
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* 	 * Read a byte 	 */
for|for
control|(
name|timeout_val
operator|=
literal|10000
init|;
name|timeout_val
operator|>
literal|0
condition|;
name|timeout_val
operator|--
control|)
if|if
condition|(
name|inb
argument_list|(
name|PORT
argument_list|(
name|HOST_CTRL
argument_list|)
argument_list|)
operator|&
name|RX_READY
condition|)
break|break;
if|if
condition|(
name|timeout_val
operator|<=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|data
operator|=
name|inb
argument_list|(
name|PORT
argument_list|(
name|HOST_DATA
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|data
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|host_command1
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cmd
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
name|host_write
argument_list|(
name|devc
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|host_command2
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|parm1
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cmd
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|parm1
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
name|host_write
argument_list|(
name|devc
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|host_command3
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|parm1
parameter_list|,
name|int
name|parm2
parameter_list|)
block|{
name|u_char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|cmd
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|parm1
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
name|parm2
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
name|host_write
argument_list|(
name|devc
argument_list|,
name|buf
argument_list|,
literal|3
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mt32
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|host_open
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|host_command2
argument_list|(
name|devc
argument_list|,
name|CMD_SET_MT32
argument_list|,
name|value
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_read
argument_list|(
name|devc
argument_list|)
operator|!=
name|CMD_ACK
condition|)
block|{
name|printf
argument_list|(
literal|"SNDSCAPE: Setting MT32 mode failed\n"
argument_list|)
expr_stmt|;
block|}
name|host_close
argument_list|(
name|devc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_control
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|,
name|int
name|ctrl
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|host_open
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|host_command3
argument_list|(
name|devc
argument_list|,
name|CMD_SET_CONTROL
argument_list|,
name|ctrl
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_read
argument_list|(
name|devc
argument_list|)
operator|!=
name|CMD_ACK
condition|)
block|{
name|printf
argument_list|(
literal|"SNDSCAPE: Setting control (%d) failed\n"
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
block|}
name|host_close
argument_list|(
name|devc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_board_type
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|)
block|{
name|int
name|tmp
decl_stmt|;
name|host_open
argument_list|(
name|devc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host_command1
argument_list|(
name|devc
argument_list|,
name|CMD_GET_BOARD_TYPE
argument_list|)
condition|)
name|tmp
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|tmp
operator|=
name|host_read
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|host_close
argument_list|(
name|devc
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
name|void
name|sscapeintr
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|u_char
name|bits
decl_stmt|,
name|tmp
decl_stmt|;
name|bits
operator|=
name|sscape_read
argument_list|(
name|devc
argument_list|,
name|GA_INTSTAT_REG
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sscapeintr(0x%02x)\n"
argument_list|,
name|bits
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sscape_sleep_flag
operator|.
name|mode
operator|&
name|WK_SLEEP
operator|)
condition|)
block|{
name|sscape_sleep_flag
operator|.
name|mode
operator|=
name|WK_WAKEUP
expr_stmt|;
name|wakeup
argument_list|(
name|sscape_sleeper
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bits
operator|&
literal|0x02
condition|)
block|{
comment|/* Host interface interrupt */
name|printf
argument_list|(
literal|"SSCAPE: Host interrupt, data=%02x\n"
argument_list|,
name|host_read
argument_list|(
name|devc
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|CONFIG_MPU401
argument_list|)
operator|||
name|defined
argument_list|(
name|CONFIG_MPU_EMU
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|CONFIG_MIDI
argument_list|)
if|if
condition|(
name|bits
operator|&
literal|0x01
condition|)
block|{
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
name|mpuintr
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|++
operator|>
literal|10
condition|)
block|{
comment|/* Temporary debugging hack */
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|GA_INTENA_REG
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Disable all interr. */
block|}
block|}
endif|#
directive|endif
comment|/*      * Acknowledge interrupts (toggle the interrupt bits)      */
name|tmp
operator|=
name|sscape_read
argument_list|(
name|devc
argument_list|,
name|GA_INTENA_REG
argument_list|)
expr_stmt|;
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|GA_INTENA_REG
argument_list|,
operator|(
operator|~
name|bits
operator|&
literal|0x0e
operator|)
operator||
operator|(
name|tmp
operator|&
literal|0xf1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_dma
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|,
name|int
name|dma_chan
parameter_list|,
name|u_long
name|buf
parameter_list|,
name|int
name|blk_size
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|u_char
name|temp
decl_stmt|;
if|if
condition|(
name|dma_chan
operator|!=
name|SSCAPE_DMA_A
condition|)
block|{
name|printf
argument_list|(
literal|"SSCAPE: Tried to use DMA channel  != A. Why?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|DMAbuf_start_dma
argument_list|(
name|devc
operator|->
name|my_audiodev
argument_list|,
name|buf
argument_list|,
name|blk_size
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|temp
operator|=
name|devc
operator|->
name|dma
operator|<<
literal|4
expr_stmt|;
comment|/* Setup DMA channel select bits */
if|if
condition|(
name|devc
operator|->
name|dma
operator|<=
literal|3
condition|)
name|temp
operator||=
literal|0x80
expr_stmt|;
comment|/* 8 bit DMA channel */
name|temp
operator||=
literal|1
expr_stmt|;
comment|/* Trigger DMA */
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|GA_DMAA_REG
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|&=
literal|0xfe
expr_stmt|;
comment|/* Clear DMA trigger */
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|GA_DMAA_REG
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|verify_mpu
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|)
block|{
comment|/*      * The SoundScape board could be in three modes (MPU, 8250 and host).      * If the card is not in the MPU mode, enabling the MPU driver will      * cause infinite loop (the driver believes that there is always some      * received data in the buffer.      *       * Detect this by looking if there are more than 10 received MIDI bytes      * (0x00) in the buffer.      */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|devc
operator|->
name|base
operator|+
name|HOST_CTRL
argument_list|)
operator|&
literal|0x80
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|inb
argument_list|(
name|devc
operator|->
name|base
argument_list|)
operator|!=
literal|0x00
condition|)
return|return
literal|1
return|;
block|}
name|printf
argument_list|(
literal|"SoundScape: The device is not in the MPU-401 mode\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sscape_coproc_open
parameter_list|(
name|void
modifier|*
name|dev_info
parameter_list|,
name|int
name|sub_device
parameter_list|)
block|{
if|if
condition|(
name|sub_device
operator|==
name|COPR_MIDI
condition|)
block|{
name|set_mt32
argument_list|(
name|devc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verify_mpu
argument_list|(
name|devc
argument_list|)
condition|)
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
block|}
name|sscape_sleep_flag
operator|.
name|aborting
operator|=
literal|0
expr_stmt|;
name|sscape_sleep_flag
operator|.
name|mode
operator|=
name|WK_NONE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sscape_coproc_close
parameter_list|(
name|void
modifier|*
name|dev_info
parameter_list|,
name|int
name|sub_device
parameter_list|)
block|{
name|struct
name|sscape_info
modifier|*
name|devc
init|=
name|dev_info
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|dma_allocated
condition|)
block|{
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|GA_DMAA_REG
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* DMA channel disabled */
ifdef|#
directive|ifdef
name|CONFIG_NATIVE_PCM
endif|#
directive|endif
name|devc
operator|->
name|dma_allocated
operator|=
literal|0
expr_stmt|;
block|}
name|sscape_sleep_flag
operator|.
name|aborting
operator|=
literal|0
expr_stmt|;
name|sscape_sleep_flag
operator|.
name|mode
operator|=
name|WK_NONE
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sscape_coproc_reset
parameter_list|(
name|void
modifier|*
name|dev_info
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|sscape_download_boot
parameter_list|(
name|struct
name|sscape_info
modifier|*
name|devc
parameter_list|,
name|u_char
modifier|*
name|block
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|u_char
name|temp
decl_stmt|;
name|int
name|done
decl_stmt|,
name|timeout_val
decl_stmt|;
if|if
condition|(
name|flag
operator|&
name|CPF_FIRST
condition|)
block|{
comment|/* 	 * First block. Have to allocate DMA and to reset the board 	 * before continuing. 	 */
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|dma_allocated
operator|==
literal|0
condition|)
block|{
name|devc
operator|->
name|dma_allocated
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|GA_HMCTL_REG
argument_list|,
operator|(
name|temp
operator|=
name|sscape_read
argument_list|(
name|devc
argument_list|,
name|GA_HMCTL_REG
argument_list|)
operator|)
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
comment|/* Reset */
for|for
control|(
name|timeout_val
operator|=
literal|10000
init|;
name|timeout_val
operator|>
literal|0
condition|;
name|timeout_val
operator|--
control|)
name|sscape_read
argument_list|(
name|devc
argument_list|,
name|GA_HMCTL_REG
argument_list|)
expr_stmt|;
comment|/* Delay */
comment|/* Take board out of reset */
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|GA_HMCTL_REG
argument_list|,
operator|(
name|temp
operator|=
name|sscape_read
argument_list|(
name|devc
argument_list|,
name|GA_HMCTL_REG
argument_list|)
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
block|}
comment|/*      * Transfer one code block using DMA      */
name|bcopy
argument_list|(
name|block
argument_list|,
name|audio_devs
index|[
name|devc
operator|->
name|my_audiodev
index|]
operator|->
name|dmap_out
operator|->
name|raw_buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/******** INTERRUPTS DISABLED NOW ********/
name|do_dma
argument_list|(
name|devc
argument_list|,
name|SSCAPE_DMA_A
argument_list|,
name|audio_devs
index|[
name|devc
operator|->
name|my_audiodev
index|]
operator|->
name|dmap_out
operator|->
name|raw_buf_phys
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*      * Wait until transfer completes.      */
name|sscape_sleep_flag
operator|.
name|aborting
operator|=
literal|0
expr_stmt|;
name|sscape_sleep_flag
operator|.
name|mode
operator|=
name|WK_NONE
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|timeout_val
operator|=
literal|100
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|timeout_val
operator|--
operator|>
literal|0
condition|)
block|{
name|int
name|chn
decl_stmt|;
name|sscape_sleeper
operator|=
operator|&
name|chn
expr_stmt|;
name|DO_SLEEP
argument_list|(
name|chn
argument_list|,
name|sscape_sleep_flag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|flag
operator|&
name|CPF_LAST
condition|)
block|{
comment|/* 	 * Take the board out of reset 	 */
name|outb
argument_list|(
name|PORT
argument_list|(
name|HOST_CTRL
argument_list|)
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PORT
argument_list|(
name|MIDI_CTRL
argument_list|)
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|temp
operator|=
name|sscape_read
argument_list|(
name|devc
argument_list|,
name|GA_HMCTL_REG
argument_list|)
expr_stmt|;
name|temp
operator||=
literal|0x40
expr_stmt|;
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|GA_HMCTL_REG
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Kickstart the board */
comment|/* 	 * Wait until the ODB wakes up 	 */
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|timeout_val
operator|=
literal|5
operator|*
name|hz
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|timeout_val
operator|--
operator|>
literal|0
condition|)
block|{
name|int
name|chn
decl_stmt|;
name|sscape_sleeper
operator|=
operator|&
name|chn
expr_stmt|;
name|DO_SLEEP
argument_list|(
name|chn
argument_list|,
name|sscape_sleep_flag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|PORT
argument_list|(
name|HOST_DATA
argument_list|)
argument_list|)
operator|==
literal|0xff
condition|)
comment|/* OBP startup acknowledge */
name|done
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|printf
argument_list|(
literal|"SoundScape: The OBP didn't respond after code download\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|timeout_val
operator|=
literal|5
operator|*
name|hz
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|timeout_val
operator|--
operator|>
literal|0
condition|)
block|{
name|int
name|chn
decl_stmt|;
name|sscape_sleeper
operator|=
operator|&
name|chn
expr_stmt|;
name|DO_SLEEP
argument_list|(
name|chn
argument_list|,
name|sscape_sleep_flag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|PORT
argument_list|(
name|HOST_DATA
argument_list|)
argument_list|)
operator|==
literal|0xfe
condition|)
comment|/* Host startup acknowledge */
name|done
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|printf
argument_list|(
literal|"SoundScape: OBP Initialization failed.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"SoundScape board of type %d initialized OK\n"
argument_list|,
name|get_board_type
argument_list|(
name|devc
argument_list|)
argument_list|)
expr_stmt|;
name|set_control
argument_list|(
name|devc
argument_list|,
name|CTL_MASTER_VOL
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|set_control
argument_list|(
name|devc
argument_list|,
name|CTL_SYNTH_VOL
argument_list|,
literal|100
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SSCAPE_DEBUG3
comment|/* 	 * Temporary debugging aid. Print contents of the registers 	 * after downloading the code. 	 */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|13
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"I%d = %02x (new value)\n"
argument_list|,
name|i
argument_list|,
name|sscape_read
argument_list|(
name|devc
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|download_boot_block
parameter_list|(
name|void
modifier|*
name|dev_info
parameter_list|,
name|copr_buffer
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|buf
operator|->
name|len
operator|<=
literal|0
operator|||
name|buf
operator|->
name|len
operator|>
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|data
argument_list|)
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|sscape_download_boot
argument_list|(
name|devc
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|len
argument_list|,
name|buf
operator|->
name|flags
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"SSCAPE: Unable to load microcode block to the OBP.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sscape_coproc_ioctl
parameter_list|(
name|void
modifier|*
name|dev_info
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|ioctl_arg
name|arg
parameter_list|,
name|int
name|local
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_COPR_RESET
case|:
name|sscape_coproc_reset
argument_list|(
name|dev_info
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_COPR_LOAD
case|:
block|{
name|copr_buffer
modifier|*
name|buf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|buf
operator|=
operator|(
name|copr_buffer
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|copr_buffer
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|-
operator|(
name|ENOSPC
operator|)
return|;
name|bcopy
argument_list|(
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|download_boot_block
argument_list|(
name|dev_info
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
break|break;
default|default:
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|coproc_operations
name|sscape_coproc_operations
init|=
block|{
literal|"SoundScape M68K"
block|,
name|sscape_coproc_open
block|,
name|sscape_coproc_close
block|,
name|sscape_coproc_ioctl
block|,
name|sscape_coproc_reset
block|,
operator|&
name|dev_info
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EXCLUDE_NATIVE_PCM
argument_list|)
operator|&&
name|defined
argument_list|(
name|CONFIG_AUDIO
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|struct
name|audio_operations
name|sscape_audio_operations
init|=
block|{
literal|"Not functional"
block|,
literal|0
block|,
name|AFMT_U8
operator||
name|AFMT_S16_LE
block|,
name|NULL
block|,
name|sscape_audio_open
block|,
name|sscape_audio_close
block|,
name|sscape_audio_output_block
block|,
name|sscape_audio_start_input
block|,
name|sscape_audio_ioctl
block|,
name|sscape_audio_prepare_for_input
block|,
name|sscape_audio_prepare_for_output
block|,
name|sscape_audio_reset
block|,
name|sscape_audio_halt
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined(EXCLUDE_NATIVE_PCM)&& defined(CONFIG_AUDIO) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sscape_detected
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|attach_sscape
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|SSCAPE_REGS
comment|/*      * Config register values for Spea/V7 Media FX and Ensoniq S-2000.      * These values are card dependent. If you have another SoundScape      * based card, you have to find the correct values. Do the following:      * - Compile this driver with SSCAPE_DEBUG1 defined. - Shut down and      * power off your machine. - Boot with DOS so that the SSINIT.EXE      * program is run. - Warm boot to {Linux|SYSV|BSD} and write down the      * lines displayed when detecting the SoundScape. - Modify the      * following list to use the values printed during boot. Undefine the      * SSCAPE_DEBUG1      */
define|#
directive|define
name|SSCAPE_REGS
value|{ \
comment|/* I0 */
value|0x00, \ 		0xf0,
comment|/* Note! Ignored. Set always to 0xf0 */
value|\ 		0x20,
comment|/* Note! Ignored. Set always to 0x20 */
value|\ 		0x20,
comment|/* Note! Ignored. Set always to 0x20 */
value|\ 		0xf5,
comment|/* Ignored */
value|\ 		0x10, \ 		0x00, \ 		0x2e,
comment|/* I7 MEM config A. Likely to vary between models */
value|\ 		0x00,
comment|/* I8 MEM config B. Likely to vary between models */
value|\
comment|/* I9 */
value|0x40
comment|/* Ignored */
value|\ 	}
endif|#
directive|endif
name|u_long
name|flags
decl_stmt|;
specifier|static
name|u_char
name|regs
index|[
literal|10
index|]
init|=
name|SSCAPE_REGS
decl_stmt|;
name|int
name|i
decl_stmt|,
name|irq_bits
init|=
literal|0xff
decl_stmt|;
if|if
condition|(
name|sscape_detected
operator|!=
name|hw_config
operator|->
name|io_base
condition|)
return|return;
if|if
condition|(
name|old_hardware
condition|)
block|{
name|valid_interrupts
operator|=
name|valid_interrupts_old
expr_stmt|;
name|conf_printf
argument_list|(
literal|"Ensoniq Soundscape (old)"
argument_list|,
name|hw_config
argument_list|)
expr_stmt|;
block|}
else|else
name|conf_printf
argument_list|(
literal|"Ensoniq Soundscape"
argument_list|,
name|hw_config
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|valid_interrupts
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hw_config
operator|->
name|irq
operator|==
name|valid_interrupts
index|[
name|i
index|]
condition|)
block|{
name|irq_bits
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hw_config
operator|->
name|irq
operator|>
literal|15
operator|||
operator|(
name|regs
index|[
literal|4
index|]
operator|=
name|irq_bits
operator|==
literal|0xff
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid IRQ%d\n"
argument_list|,
name|hw_config
operator|->
name|irq
argument_list|)
expr_stmt|;
return|return;
block|}
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|1
case|:
comment|/* Host interrupt enable */
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|i
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
comment|/* All interrupts enabled */
break|break;
case|case
literal|2
case|:
comment|/* DMA A status/trigger register */
case|case
literal|3
case|:
comment|/* DMA B status/trigger register */
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|i
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* DMA channel disabled */
break|break;
case|case
literal|4
case|:
comment|/* Host interrupt config reg */
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|i
argument_list|,
literal|0xf0
operator||
operator|(
name|irq_bits
operator|<<
literal|2
operator|)
operator||
name|irq_bits
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* Don't destroy CD-ROM DMA config bits (0xc0) */
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|i
argument_list|,
operator|(
name|regs
index|[
name|i
index|]
operator|&
literal|0x3f
operator|)
operator||
operator|(
name|sscape_read
argument_list|(
name|devc
argument_list|,
name|i
argument_list|)
operator|&
literal|0xc0
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* CD-ROM config. Don't touch. */
break|break;
case|case
literal|9
case|:
comment|/* Master control reg. Don't modify CR-ROM 		 * bits. Disable SB emul */
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|i
argument_list|,
operator|(
name|sscape_read
argument_list|(
name|devc
argument_list|,
name|i
argument_list|)
operator|&
literal|0xf0
operator|)
operator||
literal|0x00
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|i
argument_list|,
name|regs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SSCAPE_DEBUG2
comment|/*      * Temporary debugging aid. Print contents of the registers after      * changing them.      */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|13
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"I%d = %02x (new value)\n"
argument_list|,
name|i
argument_list|,
name|sscape_read
argument_list|(
name|devc
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_MIDI
argument_list|)
operator|&&
name|defined
argument_list|(
name|CONFIG_MPU_EMU
argument_list|)
if|if
condition|(
name|probe_mpu401
argument_list|(
name|hw_config
argument_list|)
condition|)
name|hw_config
operator|->
name|always_detect
operator|=
literal|1
expr_stmt|;
block|{
name|int
name|prev_devs
decl_stmt|;
name|prev_devs
operator|=
name|num_midis
expr_stmt|;
name|attach_mpu401
argument_list|(
name|hw_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_midis
operator|==
operator|(
name|prev_devs
operator|+
literal|1
operator|)
condition|)
comment|/* The MPU driver 						 * installed itself */
name|midi_devs
index|[
name|prev_devs
index|]
operator|->
name|coproc
operator|=
operator|&
name|sscape_coproc_operations
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EXCLUDE_NATIVE_PCM
comment|/* Not supported yet */
ifdef|#
directive|ifdef
name|CONFIG_AUDIO
if|if
condition|(
name|num_audiodevs
operator|<
name|MAX_AUDIO_DEV
condition|)
block|{
name|int
name|my_dev
decl_stmt|;
name|audio_devs
index|[
name|my_dev
operator|=
name|num_audiodevs
operator|++
index|]
operator|=
operator|&
name|sscape_audio_operations
expr_stmt|;
name|audio_devs
index|[
name|my_dev
index|]
operator|->
name|dmachan1
operator|=
name|hw_config
operator|->
name|dma
expr_stmt|;
name|audio_devs
index|[
name|my_dev
index|]
operator|->
name|buffsize
operator|=
name|DSP_BUFFSIZE
expr_stmt|;
name|audio_devs
index|[
name|my_dev
index|]
operator|->
name|devc
operator|=
name|devc
expr_stmt|;
name|devc
operator|->
name|my_audiodev
operator|=
name|my_dev
expr_stmt|;
name|devc
operator|->
name|opened
operator|=
literal|0
expr_stmt|;
name|audio_devs
index|[
name|my_dev
index|]
operator|->
name|coproc
operator|=
operator|&
name|sscape_coproc_operations
expr_stmt|;
if|if
condition|(
name|snd_set_irq_handler
argument_list|(
name|hw_config
operator|->
name|irq
argument_list|,
name|sscapeintr
argument_list|,
name|devc
operator|->
name|osp
argument_list|)
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"Error: Can't allocate IRQ for SoundScape\n"
argument_list|)
expr_stmt|;
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|GA_INTENA_REG
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* Master IRQ enable */
block|}
else|else
name|printf
argument_list|(
literal|"SoundScape: More than enough audio devices detected\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|devc
operator|->
name|ok
operator|=
literal|1
expr_stmt|;
name|devc
operator|->
name|failed
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|probe_sscape
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|u_char
name|save
decl_stmt|;
name|devc
operator|->
name|failed
operator|=
literal|1
expr_stmt|;
name|devc
operator|->
name|base
operator|=
name|hw_config
operator|->
name|io_base
expr_stmt|;
name|devc
operator|->
name|irq
operator|=
name|hw_config
operator|->
name|irq
expr_stmt|;
name|devc
operator|->
name|dma
operator|=
name|hw_config
operator|->
name|dma
expr_stmt|;
name|devc
operator|->
name|osp
operator|=
name|hw_config
operator|->
name|osp
expr_stmt|;
if|if
condition|(
name|sscape_detected
operator|!=
literal|0
operator|&&
name|sscape_detected
operator|!=
name|hw_config
operator|->
name|io_base
condition|)
return|return
literal|0
return|;
comment|/*      * First check that the address register of "ODIE" is there and that      * it has exactly 4 writeable bits. First 4 bits      */
if|if
condition|(
operator|(
name|save
operator|=
name|inb
argument_list|(
name|PORT
argument_list|(
name|ODIE_ADDR
argument_list|)
argument_list|)
operator|)
operator|&
literal|0xf0
condition|)
return|return
literal|0
return|;
name|outb
argument_list|(
name|PORT
argument_list|(
name|ODIE_ADDR
argument_list|)
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|PORT
argument_list|(
name|ODIE_ADDR
argument_list|)
argument_list|)
operator|!=
literal|0x00
condition|)
return|return
literal|0
return|;
name|outb
argument_list|(
name|PORT
argument_list|(
name|ODIE_ADDR
argument_list|)
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|PORT
argument_list|(
name|ODIE_ADDR
argument_list|)
argument_list|)
operator|!=
literal|0x0f
condition|)
return|return
literal|0
return|;
name|outb
argument_list|(
name|PORT
argument_list|(
name|ODIE_ADDR
argument_list|)
argument_list|,
name|save
argument_list|)
expr_stmt|;
comment|/*      * Now verify that some indirect registers return zero on some bits.      * This may break the driver with some future revisions of "ODIE"      * but...      */
if|if
condition|(
name|sscape_read
argument_list|(
name|devc
argument_list|,
literal|0
argument_list|)
operator|&
literal|0x0c
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sscape_read
argument_list|(
name|devc
argument_list|,
literal|1
argument_list|)
operator|&
literal|0x0f
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sscape_read
argument_list|(
name|devc
argument_list|,
literal|5
argument_list|)
operator|&
literal|0x0f
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|SSCAPE_DEBUG1
comment|/*      * Temporary debugging aid. Print contents of the registers before      * changing them.      */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|13
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"I%d = %02x (old value)\n"
argument_list|,
name|i
argument_list|,
name|sscape_read
argument_list|(
name|devc
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|old_hardware
condition|)
block|{
comment|/* Check that it's really an old Spea/Reveal card. */
name|u_char
name|tmp
decl_stmt|;
name|int
name|cc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|tmp
operator|=
name|sscape_read
argument_list|(
name|devc
argument_list|,
name|GA_HMCTL_REG
argument_list|)
operator|)
operator|&
literal|0xc0
operator|)
condition|)
block|{
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|GA_HMCTL_REG
argument_list|,
name|tmp
operator||
literal|0x80
argument_list|)
expr_stmt|;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
literal|200000
condition|;
operator|++
name|cc
control|)
name|inb
argument_list|(
name|devc
operator|->
name|base
operator|+
name|ODIE_ADDR
argument_list|)
expr_stmt|;
block|}
else|else
name|old_hardware
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sscape.c: Can't allocate DMA channel\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sscape_detected
operator|=
name|hw_config
operator|->
name|io_base
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|probe_ss_mss
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|irq_bits
init|=
literal|0xff
decl_stmt|;
if|if
condition|(
name|devc
operator|->
name|failed
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|devc
operator|->
name|ok
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"SoundScape: Invalid initialization order.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|valid_interrupts
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hw_config
operator|->
name|irq
operator|==
name|valid_interrupts
index|[
name|i
index|]
condition|)
block|{
name|irq_bits
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hw_config
operator|->
name|irq
operator|>
literal|15
operator|||
name|irq_bits
operator|==
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"SoundScape: Invalid MSS IRQ%d\n"
argument_list|,
name|hw_config
operator|->
name|irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ad1848_detect
argument_list|(
name|hw_config
operator|->
name|io_base
argument_list|,
name|NULL
argument_list|,
name|hw_config
operator|->
name|osp
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|attach_ss_mss
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
comment|/*      * This routine configures the SoundScape card for use with the Win      * Sound System driver. The AD1848 codec interface uses the CD-ROM      * config registers of the "ODIE".      */
name|int
name|i
decl_stmt|,
name|irq_bits
init|=
literal|0xff
decl_stmt|;
ifndef|#
directive|ifndef
name|CONFIG_NATIVE_PCM
name|int
name|prev_devs
init|=
name|num_audiodevs
decl_stmt|;
endif|#
directive|endif
comment|/*      * Setup the DMA polarity.      */
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|GA_DMACFG_REG
argument_list|,
literal|0x50
argument_list|)
expr_stmt|;
comment|/*      * Take the gate-arry off of the DMA channel.      */
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|GA_DMAB_REG
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/*      * Init the AD1848 (CD-ROM) config reg.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|valid_interrupts
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hw_config
operator|->
name|irq
operator|==
name|valid_interrupts
index|[
name|i
index|]
condition|)
block|{
name|irq_bits
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|sscape_write
argument_list|(
name|devc
argument_list|,
name|GA_CDCFG_REG
argument_list|,
literal|0x89
operator||
operator|(
name|hw_config
operator|->
name|dma
operator|<<
literal|4
operator|)
operator||
operator|(
name|irq_bits
operator|<<
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw_config
operator|->
name|irq
operator|==
name|devc
operator|->
name|irq
condition|)
name|printf
argument_list|(
literal|"SoundScape: Warning! WSS mode can't share IRQ with MIDI\n"
argument_list|)
expr_stmt|;
name|ad1848_init
argument_list|(
literal|"SoundScape"
argument_list|,
name|hw_config
operator|->
name|io_base
argument_list|,
name|hw_config
operator|->
name|irq
argument_list|,
name|hw_config
operator|->
name|dma
argument_list|,
name|hw_config
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
name|devc
operator|->
name|osp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CONFIG_NATIVE_PCM
comment|/* Check if the AD1848 driver installed itself */
if|if
condition|(
name|num_audiodevs
operator|==
operator|(
name|prev_devs
operator|+
literal|1
operator|)
condition|)
name|audio_devs
index|[
name|prev_devs
index|]
operator|->
name|coproc
operator|=
operator|&
name|sscape_coproc_operations
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

