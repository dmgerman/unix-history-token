begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	gpatinfo.c: This program demonstrates the patch management  *		    interface of the GUS driver.  *  *	NOTE! The patch manager interface is highly device dependent,  *	      currently incompletely implemented prototype and  *	      will change before final implementation.  *   * $Id$  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<machine/ultrasound.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gmidi.h"
end_include

begin_define
define|#
directive|define
name|GUS_DEV
value|gus_dev
end_define

begin_define
define|#
directive|define
name|patch_access
parameter_list|(
name|cmd
parameter_list|,
name|rec
parameter_list|)
define|\
value|rec.command = cmd;\ 	rec.device = gus_dev;\ 	if (ioctl(seqfd, SNDCTL_PMGR_IFACE,&rec)==-1)\ 	{\ 		perror("/dev/sequencer(SNDCTL_PMGR_IFACE/" #cmd ")");\ 		exit(-1);\ 	}
end_define

begin_expr_stmt
name|SEQ_DEFINEBUF
argument_list|(
literal|2048
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|seqfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gus_dev
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The function seqbuf_dump() must always be provided  */
end_comment

begin_function
name|void
name|seqbuf_dump
parameter_list|()
block|{
if|if
condition|(
name|_seqbufptr
condition|)
if|if
condition|(
name|write
argument_list|(
name|seqfd
argument_list|,
name|_seqbuf
argument_list|,
name|_seqbufptr
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"write /dev/sequencer"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|_seqbufptr
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|synth_info
name|info
decl_stmt|;
name|struct
name|patch_info
modifier|*
name|patch
decl_stmt|;
name|struct
name|patmgr_info
name|mgr
decl_stmt|,
name|mgr2
decl_stmt|,
name|mgr3
decl_stmt|;
if|if
condition|(
operator|(
name|seqfd
operator|=
name|open
argument_list|(
literal|"/dev/sequencer"
argument_list|,
name|O_WRONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"/dev/sequencer"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|seqfd
argument_list|,
name|SNDCTL_SEQ_NRSYNTHS
argument_list|,
operator|&
name|n
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"/dev/sequencer"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  * First locate the GUS device  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|info
operator|.
name|device
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|seqfd
argument_list|,
name|SNDCTL_SYNTH_INFO
argument_list|,
operator|&
name|info
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"/dev/sequencer"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|synth_type
operator|==
name|SYNTH_TYPE_SAMPLE
operator|&&
name|info
operator|.
name|synth_subtype
operator|==
name|SAMPLE_TYPE_GUS
condition|)
name|gus_dev
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|gus_dev
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: Gravis Ultrasound not detected\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Gravis UltraSound device = %d\n"
argument_list|,
name|gus_dev
argument_list|)
expr_stmt|;
comment|/*   * Get type of the Patch Manager interface of the GUS device   */
name|patch_access
argument_list|(
name|PM_GET_DEVTYPE
argument_list|,
name|mgr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Patch manager type: %d\n"
argument_list|,
name|mgr
operator|.
name|parm1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mgr
operator|.
name|parm1
operator|!=
name|PMTYPE_WAVE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Hups, this program seems to be obsolete\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*    * The GUS driver supports up to 256 different midi program numbers but    * this limit can be changed before compiling the driver. The following    * call returns the value compiled to the driver.    */
name|patch_access
argument_list|(
name|PM_GET_PGMMAP
argument_list|,
name|mgr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Device supports %d midi programs.\n"
argument_list|,
name|mgr
operator|.
name|parm1
argument_list|)
expr_stmt|;
comment|/*    * Each program can be undefined or it may have one or more patches.    * A patch consists of header and the waveform data. If there is more    * than one patch in a program, the right one is selected by checking the    * note number when the program is played.    *    * The following call reads an array indexed by program number. Each    * element defines the number of patches defined for the corresponding    * program.    */
name|printf
argument_list|(
literal|"Loaded programs:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mgr
operator|.
name|parm1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mgr
operator|.
name|data
operator|.
name|data8
index|[
name|i
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"%03d: %2d patches\n"
argument_list|,
name|i
argument_list|,
name|mgr
operator|.
name|data
operator|.
name|data8
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/*   * Next get the magic keys of the patches associated with this program.   * This key can be used to access the patc data.   */
name|mgr2
operator|.
name|parm1
operator|=
name|i
expr_stmt|;
name|patch_access
argument_list|(
name|PM_GET_PGM_PATCHES
argument_list|,
name|mgr2
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|mgr2
operator|.
name|parm1
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"\tPatch %d: %3d "
argument_list|,
name|j
argument_list|,
name|mgr2
operator|.
name|data
operator|.
name|data32
index|[
name|j
index|]
argument_list|)
expr_stmt|;
comment|/*   * The last step is to read the patch header (without wave data).   * The header is returned in the mgr3.data. The field parm1 returns   * address of the wave data in tge GUS DRAM. Parm2 returns   * size of the struct patch_info in the kernel.   *   * There is also the PM_SET_PATCH call which allows modification of the   * header data. The only limitation is that the sample len cannot be   * increased.   */
name|mgr3
operator|.
name|parm1
operator|=
name|mgr2
operator|.
name|data
operator|.
name|data32
index|[
name|j
index|]
expr_stmt|;
name|patch_access
argument_list|(
name|PM_GET_PATCH
argument_list|,
name|mgr3
argument_list|)
expr_stmt|;
name|patch
operator|=
operator|(
expr|struct
name|patch_info
operator|*
operator|)
operator|&
name|mgr3
operator|.
name|data
expr_stmt|;
comment|/* Pointer to the patch hdr */
name|printf
argument_list|(
literal|"DRAM ptr = %7d, sample len =%6d bytes.\n"
argument_list|,
name|mgr3
operator|.
name|parm1
argument_list|,
name|patch
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|i
operator|=
name|gus_dev
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|seqfd
argument_list|,
name|SNDCTL_SYNTH_MEMAVL
argument_list|,
operator|&
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d bytes of DRAM available for wave data\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

