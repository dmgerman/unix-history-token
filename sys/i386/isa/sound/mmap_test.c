begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This is a simple program which demonstrates use of mmapped DMA buffer  * of the sound driver directly from application program.  *  * This sample program works (currently) only with Linux, FreeBSD and BSD/OS  * (FreeBSD and BSD/OS require OSS version 3.8-beta16 or later.  *  * Note! Don't use mmapped DMA buffers (direct audio) unless you have  * very good reasons to do it. Programs using this feature will not  * work with all soundcards. GUS (GF1) is one of them (GUS MAX works).  *  * This program requires version 3.5-beta7 or later of OSS  * (3.8-beta16 or later in FreeBSD and BSD/OS).  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<machine/soundcard.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_function
name|int
name|main
parameter_list|()
block|{
name|int
name|fd
decl_stmt|,
name|sz
decl_stmt|,
name|fsz
decl_stmt|,
name|tmp
decl_stmt|,
name|nfrag
decl_stmt|;
name|int
name|caps
decl_stmt|;
name|int
name|sd
decl_stmt|,
name|sl
init|=
literal|0
decl_stmt|,
name|sp
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|500000
index|]
decl_stmt|,
modifier|*
name|dp
init|=
name|data
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|struct
name|timeval
name|tim
decl_stmt|;
name|unsigned
name|char
modifier|*
name|op
decl_stmt|;
name|struct
name|audio_buf_info
name|info
decl_stmt|;
name|int
name|frag
init|=
literal|0xffff000c
decl_stmt|;
comment|/* Max # fragments of 2^13=8k bytes */
name|fd_set
name|writeset
decl_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/dsp"
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"/dev/dsp"
argument_list|)
expr_stmt|;
comment|/*  * Then setup sampling parameters. Just sampling rate in this case.  */
name|tmp
operator|=
literal|8000
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_SPEED
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/*  * Load some test data.  */
name|sl
operator|=
name|sp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|=
name|open
argument_list|(
literal|"smpl"
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|sl
operator|=
name|read
argument_list|(
name|sd
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d bytes read from file.\n"
argument_list|,
name|sl
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sd
argument_list|)
expr_stmt|;
block|}
else|else
name|warn
argument_list|(
literal|"smpl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_GETCAPS
argument_list|,
operator|&
name|caps
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|warn
argument_list|(
literal|"sorry but your sound driver is too old"
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"/dev/dsp"
argument_list|)
expr_stmt|;
block|}
comment|/*  * Check that the device has capability to do this. Currently just  * CS4231 based cards will work.  *  * The application should also check for DSP_CAP_MMAP bit but this  * version of driver doesn't have it yet.  */
comment|/*	ioctl(fd, SNDCTL_DSP_SETSYNCRO, 0); */
comment|/*  * You need version 3.5-beta7 or later of the sound driver before next  * two lines compile. There is no point to modify this program to  * compile with older driver versions since they don't have working  * mmap() support.  */
if|if
condition|(
operator|!
operator|(
name|caps
operator|&
name|DSP_CAP_TRIGGER
operator|)
operator|||
operator|!
operator|(
name|caps
operator|&
name|DSP_CAP_MMAP
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"sorry but your soundcard can't do this"
argument_list|)
expr_stmt|;
comment|/*  * Select the fragment size. This is propably important only when  * the program uses select(). Fragment size defines how often  * select call returns.  */
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_SETFRAGMENT
argument_list|,
operator|&
name|frag
argument_list|)
expr_stmt|;
comment|/*  * Compute total size of the buffer. It's important to use this value  * in mmap() call.  */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_GETOSPACE
argument_list|,
operator|&
name|info
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"GETOSPACE"
argument_list|)
expr_stmt|;
name|sz
operator|=
name|info
operator|.
name|fragstotal
operator|*
name|info
operator|.
name|fragsize
expr_stmt|;
name|fsz
operator|=
name|info
operator|.
name|fragsize
expr_stmt|;
comment|/*  * Call mmap().  *   * IMPORTANT NOTE!!!!!!!!!!!  *  * Full duplex audio devices have separate input and output buffers.   * It is not possible to map both of them at the same mmap() call. The buffer  * is selected based on the prot argument in the following way:  *  * - PROT_READ (alone) selects the input buffer.  * - PROT_WRITE (alone) selects the output buffer.  * - PROT_WRITE|PROT_READ together select the output buffer. This combination  *   is required in BSD to make the buffer accessible. With just PROT_WRITE  *   every attempt to access the returned buffer will result in segmentation/bus  *   error. PROT_READ|PROT_WRITE is also permitted in Linux with OSS version  *   3.8-beta16 and later (earlier versions don't accept it).  *  * Non duplex devices have just one buffer. When an application wants to do both  * input and output it's recommended that the device is closed and re-opened when  * switching between modes. PROT_READ|PROT_WRITE can be used to open the buffer  * for both input and output (with OSS 3.8-beta16 and later) but the result may be  * unpredictable.  */
if|if
condition|(
operator|(
name|buf
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|sz
argument_list|,
name|PROT_WRITE
operator||
name|PROT_READ
argument_list|,
name|MAP_FILE
operator||
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|(
name|caddr_t
operator|)
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"mmap (write)"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mmap (out) returned %08x\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|op
operator|=
name|buf
expr_stmt|;
comment|/*  * op contains now a pointer to the DMA buffer  */
comment|/*  * Then it's time to start the engine. The driver doesn't allow read() and/or  * write() when the buffer is mapped. So the only way to start operation is  * to togle device's enable bits. First set them off. Setting them on enables  * recording and/or playback.  */
name|tmp
operator|=
literal|0
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_SETTRIGGER
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/*  * It might be usefull to write some data to the buffer before starting.  */
name|tmp
operator|=
name|PCM_ENABLE_OUTPUT
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_SETTRIGGER
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/*  * The machine is up and running now. Use SNDCTL_DSP_GETOPTR to get the  * buffer status.  *  * NOTE! The driver empties each buffer fragmen after they have been  * played. This prevents looping sound if there are some performance problems  * in the application side. For similar reasons it recommended that the  * application uses some amout of play ahead. It can rewrite the unplayed  * data later if necessary.  */
name|nfrag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|count_info
name|count
decl_stmt|;
name|int
name|extra
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|writeset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fd
argument_list|,
operator|&
name|writeset
argument_list|)
expr_stmt|;
name|tim
operator|.
name|tv_sec
operator|=
literal|10
expr_stmt|;
name|tim
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|select
argument_list|(
name|fd
operator|+
literal|1
argument_list|,
operator|&
name|writeset
argument_list|,
operator|&
name|writeset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * SNDCTL_DSP_GETOPTR (and GETIPTR as well) return three items. The  * bytes field returns number of bytes played since start. It can be used  * as a real time clock.  *  * The blocks field returns number of fragment transitions (interrupts) since  * previous GETOPTR call. It can be used as a method to detect underrun   * situations.  *  * The ptr field is the DMA pointer inside the buffer area (in bytes from  * the beginning of total buffer area).  */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|SNDCTL_DSP_GETOPTR
argument_list|,
operator|&
name|count
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"GETOPTR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|.
name|ptr
operator|<
literal|0
condition|)
name|count
operator|.
name|ptr
operator|=
literal|0
expr_stmt|;
name|nfrag
operator|+=
name|count
operator|.
name|blocks
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"\rTotal: %09d, Fragment: %03d, Ptr: %06d"
argument_list|,
name|count
operator|.
name|bytes
argument_list|,
name|nfrag
argument_list|,
name|count
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  * Caution! This version doesn't check for bounds of the DMA  * memory area. It's possible that the returned pointer value is not aligned  * to fragment boundaries. It may be several samples behind the boundary  * in case there was extra delay between the actual hardware interrupt and  * the time when DSP_GETOPTR was called.  *  * Don't just call memcpy() with length set to 'fragment_size' without  * first checking that the transfer really fits to the buffer area.  * A mistake of just one byte causes seg fault. It may be easiest just  * to align the returned pointer value to fragment boundary before using it.  *  * It would be very good idea to write few extra samples to next fragment  * too. Otherwise several (uninitialized) samples from next fragment  * will get played before your program gets chance to initialize them.  * Take in count the fact thaat there are other processes batling about  * the same CPU. This effect is likely to be very annoying if fragment  * size is decreased too much.  */
comment|/*  * Just a minor clarification to the above. The following line alings  * the pointer to fragment boundaries. Note! Don't trust that fragment  * size is always a power of 2. It may not be so in future.  */
name|count
operator|.
name|ptr
operator|=
operator|(
operator|(
name|count
operator|.
name|ptr
operator|+
literal|16
operator|)
operator|/
name|fsz
operator|)
operator|*
name|fsz
expr_stmt|;
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|" memcpy(%6d, %4d)"
argument_list|,
operator|(
name|dp
operator|-
name|data
operator|)
argument_list|,
name|fsz
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  * Set few bytes in the beginning of next fragment too.  */
if|if
condition|(
operator|(
name|count
operator|.
name|ptr
operator|+
name|fsz
operator|+
literal|16
operator|)
operator|<
name|sz
condition|)
comment|/* Last fragment? */
name|extra
operator|=
literal|16
expr_stmt|;
else|else
name|extra
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|op
operator|+
name|count
operator|.
name|ptr
argument_list|,
name|dp
argument_list|,
operator|(
name|fsz
operator|+
name|extra
operator|)
argument_list|)
expr_stmt|;
name|dp
operator|+=
name|fsz
expr_stmt|;
if|if
condition|(
name|dp
operator|>
operator|(
name|data
operator|+
name|sl
operator|-
name|fsz
operator|)
condition|)
name|dp
operator|=
name|data
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

