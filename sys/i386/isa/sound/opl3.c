begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/opl3.c  *   * A low level driver for Yamaha YM3812 and OPL-3 -chips  *   * Copyright by Hannu Savolainen 1993  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   */
end_comment

begin_comment
comment|/*  * Major improvements to the FM handling 30AUG92 by Rob Hooft,  */
end_comment

begin_comment
comment|/*  * hooft@chem.ruu.nl  */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/sound/sound_config.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_YM3812
argument_list|)
end_if

begin_include
include|#
directive|include
file|<i386/isa/sound/opl3.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_define
define|#
directive|define
name|MAX_VOICE
value|18
end_define

begin_define
define|#
directive|define
name|OFFS_4OP
value|11
end_define

begin_struct
struct|struct
name|voice_info
block|{
name|u_char
name|keyon_byte
decl_stmt|;
name|long
name|bender
decl_stmt|;
name|long
name|bender_range
decl_stmt|;
name|u_long
name|orig_freq
decl_stmt|;
name|u_long
name|current_freq
decl_stmt|;
name|int
name|volume
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|opl_devinfo
block|{
name|int
name|left_io
decl_stmt|,
name|right_io
decl_stmt|;
name|int
name|nr_voice
decl_stmt|;
name|int
name|lv_map
index|[
name|MAX_VOICE
index|]
decl_stmt|;
name|struct
name|voice_info
name|voc
index|[
name|MAX_VOICE
index|]
decl_stmt|;
name|struct
name|voice_alloc_info
modifier|*
name|v_alloc
decl_stmt|;
name|struct
name|channel_info
modifier|*
name|chn_info
decl_stmt|;
name|struct
name|sbi_instrument
name|i_map
index|[
name|SBFM_MAXINSTR
index|]
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|act_i
index|[
name|MAX_VOICE
index|]
decl_stmt|;
name|struct
name|synth_info
name|fm_info
decl_stmt|;
name|int
name|busy
decl_stmt|;
name|int
name|model
decl_stmt|;
name|u_char
name|cmask
decl_stmt|;
name|int
name|is_opl4
decl_stmt|;
name|sound_os_info
modifier|*
name|osp
decl_stmt|;
block|}
name|opl_devinfo
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|opl_devinfo
modifier|*
name|devc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|detected_model
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|store_instr
parameter_list|(
name|int
name|instr_no
parameter_list|,
name|struct
name|sbi_instrument
modifier|*
name|instr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freq_to_fnum
parameter_list|(
name|int
name|freq
parameter_list|,
name|int
modifier|*
name|block
parameter_list|,
name|int
modifier|*
name|fnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|opl3_command
parameter_list|(
name|int
name|io_addr
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|u_int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|opl3_kill_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|enable_opl3_mode
parameter_list|(
name|int
name|left
parameter_list|,
name|int
name|right
parameter_list|,
name|int
name|both
parameter_list|)
block|{
comment|/* NOP */
block|}
end_function

begin_function
specifier|static
name|void
name|enter_4op_mode
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|v4op
index|[
name|MAX_VOICE
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|}
decl_stmt|;
name|devc
operator|->
name|cmask
operator|=
literal|0x3f
expr_stmt|;
comment|/* Connect all possible 4 OP voice operators */
name|opl3_command
argument_list|(
name|devc
operator|->
name|right_io
argument_list|,
name|CONNECTION_SELECT_REGISTER
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|pv_map
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|pv_map
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
name|pv_map
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|12
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
name|pv_map
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
name|devc
operator|->
name|lv_map
index|[
name|i
index|]
operator|=
name|v4op
index|[
name|i
index|]
expr_stmt|;
name|devc
operator|->
name|v_alloc
operator|->
name|max_voice
operator|=
name|devc
operator|->
name|nr_voice
operator|=
literal|12
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|ioctl_arg
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_FM_LOAD_INSTR
case|:
block|{
name|struct
name|sbi_instrument
name|ins
decl_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ins
argument_list|,
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ins
operator|.
name|channel
operator|<
literal|0
operator|||
name|ins
operator|.
name|channel
operator|>=
name|SBFM_MAXINSTR
condition|)
block|{
name|printf
argument_list|(
literal|"FM Error: Invalid instrument number %d\n"
argument_list|,
name|ins
operator|.
name|channel
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pmgr_inform
argument_list|(
name|dev
argument_list|,
name|PM_E_PATCH_LOADED
argument_list|,
name|ins
operator|.
name|channel
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|store_instr
argument_list|(
name|ins
operator|.
name|channel
argument_list|,
operator|&
name|ins
argument_list|)
return|;
block|}
break|break;
case|case
name|SNDCTL_SYNTH_INFO
case|:
name|devc
operator|->
name|fm_info
operator|.
name|nr_voices
operator|=
operator|(
name|devc
operator|->
name|nr_voice
operator|==
literal|12
operator|)
condition|?
literal|6
else|:
name|devc
operator|->
name|nr_voice
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|devc
operator|->
name|fm_info
argument_list|,
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|devc
operator|->
name|fm_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
return|return
literal|0x7fffffff
return|;
break|break;
case|case
name|SNDCTL_FM_4OP_ENABLE
case|:
if|if
condition|(
name|devc
operator|->
name|model
operator|==
literal|2
condition|)
name|enter_4op_mode
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
break|break;
default|default:
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|opl3_detect
parameter_list|(
name|int
name|ioaddr
parameter_list|,
name|sound_os_info
modifier|*
name|osp
parameter_list|)
block|{
comment|/*      * This function returns 1 if the FM chip is present at the given      * I/O port The detection algorithm plays with the timer built in the      * FM chip and looks for a change in the status register.      *       * Note! The timers of the FM chip are not connected to AdLib (and      * compatible) boards.      *       * Note2! The chip is initialized if detected.      */
name|u_char
name|stat1
decl_stmt|,
name|stat2
decl_stmt|,
name|signature
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|devc
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
name|devc
operator|=
operator|(
expr|struct
name|opl_devinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|devc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|devc
condition|)
name|panic
argument_list|(
literal|"SOUND: Cannot allocate memory\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|devc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"OPL3: Can't allocate memory for device control structure\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|devc
operator|->
name|osp
operator|=
name|osp
expr_stmt|;
comment|/* Reset timers 1 and 2 */
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|TIMER1_MASK
operator||
name|TIMER2_MASK
argument_list|)
expr_stmt|;
comment|/* Reset the IRQ of the FM chip */
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|IRQ_RESET
argument_list|)
expr_stmt|;
name|signature
operator|=
name|stat1
operator|=
name|inb
argument_list|(
name|ioaddr
argument_list|)
expr_stmt|;
comment|/* Status register */
if|if
condition|(
operator|(
name|stat1
operator|&
literal|0xE0
operator|)
operator|!=
literal|0x00
condition|)
block|{
return|return
literal|0
return|;
comment|/* Should be 0x00 */
block|}
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TIMER1_REGISTER
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Set timer1 to 0xff */
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|TIMER2_MASK
operator||
name|TIMER1_START
argument_list|)
expr_stmt|;
comment|/* Unmask and start timer 1 */
name|DELAY
argument_list|(
literal|150
argument_list|)
expr_stmt|;
comment|/* Now we have to delay at least 80 usec */
name|stat2
operator|=
name|inb
argument_list|(
name|ioaddr
argument_list|)
expr_stmt|;
comment|/* Read status after timers have expired */
comment|/*      * Stop the timers      */
comment|/* Reset timers 1 and 2 */
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|TIMER1_MASK
operator||
name|TIMER2_MASK
argument_list|)
expr_stmt|;
comment|/* Reset the IRQ of the FM chip */
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TIMER_CONTROL_REGISTER
argument_list|,
name|IRQ_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat2
operator|&
literal|0xE0
operator|)
operator|!=
literal|0xc0
condition|)
block|{
return|return
literal|0
return|;
comment|/* There is no YM3812 */
block|}
comment|/*      * There is a FM chicp in this address. Detect the type (OPL2 to      * OPL4)      */
if|if
condition|(
name|signature
operator|==
literal|0x06
condition|)
block|{
comment|/* OPL2 */
name|detected_model
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|signature
operator|==
literal|0x00
condition|)
block|{
comment|/* OPL3 or OPL4 */
name|u_char
name|tmp
decl_stmt|;
name|detected_model
operator|=
literal|3
expr_stmt|;
comment|/* 	 * Detect availability of OPL4 (_experimental_). Works 	 * propably only after a cold boot. In addition the OPL4 port 	 * of the chip may not be connected to the PC bus at all. 	 */
name|opl3_command
argument_list|(
name|ioaddr
operator|+
literal|2
argument_list|,
name|OPL3_MODE_REGISTER
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|ioaddr
operator|+
literal|2
argument_list|,
name|OPL3_MODE_REGISTER
argument_list|,
name|OPL3_ENABLE
operator||
name|OPL4_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|inb
argument_list|(
name|ioaddr
argument_list|)
operator|)
operator|==
literal|0x02
condition|)
block|{
comment|/* Have a OPL4 */
name|detected_model
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|!
literal|0
condition|)
block|{
comment|/* OPL4 port is free */
comment|/* XXX check here lr970711 */
name|int
name|tmp
decl_stmt|;
name|outb
argument_list|(
name|ioaddr
operator|-
literal|8
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Select OPL4 ID register */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|inb
argument_list|(
name|ioaddr
operator|-
literal|7
argument_list|)
expr_stmt|;
comment|/* Read it */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
literal|0x20
condition|)
block|{
comment|/* OPL4 should return 0x20 here */
name|detected_model
operator|=
literal|4
expr_stmt|;
name|outb
argument_list|(
name|ioaddr
operator|-
literal|8
argument_list|,
literal|0xF8
argument_list|)
expr_stmt|;
comment|/* Select OPL4 FM mixer control */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioaddr
operator|-
literal|7
argument_list|,
literal|0x1B
argument_list|)
expr_stmt|;
comment|/* Write value */
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
name|detected_model
operator|=
literal|3
expr_stmt|;
block|}
name|opl3_command
argument_list|(
name|ioaddr
operator|+
literal|2
argument_list|,
name|OPL3_MODE_REGISTER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|KEYON_BLOCK
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Note off */
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|TEST_REGISTER
argument_list|,
name|ENABLE_WAVE_SELECT
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|ioaddr
argument_list|,
name|PERCUSSION_REGISTER
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Melodic mode. */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_kill_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|)
block|{
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|devc
operator|->
name|nr_voice
condition|)
return|return
literal|0
return|;
name|devc
operator|->
name|v_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
name|map
operator|=
operator|&
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|voice
index|]
index|]
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"Kill note %d\n"
argument_list|,
name|voice
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|&
operator|~
literal|0x20
argument_list|)
expr_stmt|;
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|volume
operator|=
literal|64
expr_stmt|;
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
literal|200
expr_stmt|;
comment|/* 200 cents = 2 semitones */
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|orig_freq
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|HIHAT
value|0
end_define

begin_define
define|#
directive|define
name|CYMBAL
value|1
end_define

begin_define
define|#
directive|define
name|TOMTOM
value|2
end_define

begin_define
define|#
directive|define
name|SNARE
value|3
end_define

begin_define
define|#
directive|define
name|BDRUM
value|4
end_define

begin_define
define|#
directive|define
name|UNDEFINED
value|TOMTOM
end_define

begin_define
define|#
directive|define
name|DEFAULT
value|TOMTOM
end_define

begin_function
specifier|static
name|int
name|store_instr
parameter_list|(
name|int
name|instr_no
parameter_list|,
name|struct
name|sbi_instrument
modifier|*
name|instr
parameter_list|)
block|{
if|if
condition|(
name|instr
operator|->
name|key
operator|!=
name|FM_PATCH
operator|&&
operator|(
name|instr
operator|->
name|key
operator|!=
name|OPL3_PATCH
operator|||
name|devc
operator|->
name|model
operator|!=
literal|2
operator|)
condition|)
name|printf
argument_list|(
literal|"FM warning: Invalid patch format field (key) 0x%x\n"
argument_list|,
name|instr
operator|->
name|key
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|instr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|devc
operator|->
name|i_map
index|[
name|instr_no
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|instr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_set_instr
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|instr_no
parameter_list|)
block|{
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|devc
operator|->
name|nr_voice
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|instr_no
operator|<
literal|0
operator|||
name|instr_no
operator|>=
name|SBFM_MAXINSTR
condition|)
return|return
literal|0
return|;
name|devc
operator|->
name|act_i
index|[
name|voice
index|]
operator|=
operator|&
name|devc
operator|->
name|i_map
index|[
name|instr_no
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The next table looks magical, but it certainly is not. Its values have  * been calculated as table[i]=8*log(i/64)/log(2) with an obvious exception  * for i=0. This log-table converts a linear volume-scaling (0..127) to a  * logarithmic scaling as present in the FM-synthesizer chips. so :    Volume  * 64 =  0 db = relative volume  0 and:    Volume 32 = -6 db = relative  * volume -8 it was implemented as a table because it is only 128 bytes and  * it saves a lot of log() calculations. (RH)  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|fm_volume_table
index|[
literal|128
index|]
init|=
block|{
operator|-
literal|64
block|,
operator|-
literal|48
block|,
operator|-
literal|40
block|,
operator|-
literal|35
block|,
operator|-
literal|32
block|,
operator|-
literal|29
block|,
operator|-
literal|27
block|,
operator|-
literal|26
block|,
operator|-
literal|24
block|,
operator|-
literal|23
block|,
operator|-
literal|21
block|,
operator|-
literal|20
block|,
operator|-
literal|19
block|,
operator|-
literal|18
block|,
operator|-
literal|18
block|,
operator|-
literal|17
block|,
operator|-
literal|16
block|,
operator|-
literal|15
block|,
operator|-
literal|15
block|,
operator|-
literal|14
block|,
operator|-
literal|13
block|,
operator|-
literal|13
block|,
operator|-
literal|12
block|,
operator|-
literal|12
block|,
operator|-
literal|11
block|,
operator|-
literal|11
block|,
operator|-
literal|10
block|,
operator|-
literal|10
block|,
operator|-
literal|10
block|,
operator|-
literal|9
block|,
operator|-
literal|9
block|,
operator|-
literal|8
block|,
operator|-
literal|8
block|,
operator|-
literal|8
block|,
operator|-
literal|7
block|,
operator|-
literal|7
block|,
operator|-
literal|7
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|5
block|,
operator|-
literal|5
block|,
operator|-
literal|5
block|,
operator|-
literal|5
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
operator|-
literal|3
block|,
operator|-
literal|3
block|,
operator|-
literal|3
block|,
operator|-
literal|3
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|calc_vol
parameter_list|(
name|u_char
modifier|*
name|regbyte
parameter_list|,
name|int
name|volume
parameter_list|,
name|int
name|main_vol
parameter_list|)
block|{
name|int
name|level
init|=
operator|(
operator|~
operator|*
name|regbyte
operator|&
literal|0x3f
operator|)
decl_stmt|;
if|if
condition|(
name|main_vol
operator|>
literal|127
condition|)
name|main_vol
operator|=
literal|127
expr_stmt|;
name|volume
operator|=
operator|(
name|volume
operator|*
name|main_vol
operator|)
operator|/
literal|127
expr_stmt|;
if|if
condition|(
name|level
condition|)
name|level
operator|+=
name|fm_volume_table
index|[
name|volume
index|]
expr_stmt|;
name|RANGE
argument_list|(
name|level
argument_list|,
literal|0
argument_list|,
literal|0x3f
argument_list|)
expr_stmt|;
operator|*
name|regbyte
operator|=
operator|(
operator|*
name|regbyte
operator|&
literal|0xc0
operator|)
operator||
operator|(
operator|~
name|level
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_voice_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|,
name|int
name|main_vol
parameter_list|)
block|{
name|u_char
name|vol1
decl_stmt|,
name|vol2
decl_stmt|,
name|vol3
decl_stmt|,
name|vol4
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|instr
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|devc
operator|->
name|nr_voice
condition|)
return|return;
name|map
operator|=
operator|&
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|voice
index|]
index|]
expr_stmt|;
name|instr
operator|=
name|devc
operator|->
name|act_i
index|[
name|voice
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|instr
condition|)
name|instr
operator|=
operator|&
name|devc
operator|->
name|i_map
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|instr
operator|->
name|channel
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|mode
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|mode
operator|==
literal|2
condition|)
block|{
name|vol1
operator|=
name|instr
operator|->
name|operators
index|[
literal|2
index|]
expr_stmt|;
name|vol2
operator|=
name|instr
operator|->
name|operators
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
index|]
operator|&
literal|0x01
operator|)
condition|)
block|{
name|calc_vol
argument_list|(
operator|&
name|vol1
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
block|}
name|calc_vol
argument_list|(
operator|&
name|vol2
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|vol1
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|vol2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 4 OP voice */
name|int
name|connection
decl_stmt|;
name|vol1
operator|=
name|instr
operator|->
name|operators
index|[
literal|2
index|]
expr_stmt|;
name|vol2
operator|=
name|instr
operator|->
name|operators
index|[
literal|3
index|]
expr_stmt|;
name|vol3
operator|=
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|2
index|]
expr_stmt|;
name|vol4
operator|=
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|3
index|]
expr_stmt|;
comment|/* 	 * The connection method for 4 OP devc->voc is defined by the 	 * rightmost bits at the offsets 10 and 10+OFFS_4OP 	 */
name|connection
operator|=
operator|(
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
index|]
operator|&
literal|0x01
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
operator|+
name|OFFS_4OP
index|]
operator|&
literal|0x01
operator|)
expr_stmt|;
switch|switch
condition|(
name|connection
condition|)
block|{
case|case
literal|0
case|:
name|calc_vol
argument_list|(
operator|&
name|vol4
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|calc_vol
argument_list|(
operator|&
name|vol2
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
name|calc_vol
argument_list|(
operator|&
name|vol4
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|calc_vol
argument_list|(
operator|&
name|vol1
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
name|calc_vol
argument_list|(
operator|&
name|vol4
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|calc_vol
argument_list|(
operator|&
name|vol1
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
name|calc_vol
argument_list|(
operator|&
name|vol3
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
name|calc_vol
argument_list|(
operator|&
name|vol4
argument_list|,
name|volume
argument_list|,
name|main_vol
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|vol1
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|vol2
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|vol3
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|vol4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_start_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
name|u_char
name|data
decl_stmt|,
name|fpc
decl_stmt|;
name|int
name|block
decl_stmt|,
name|fnum
decl_stmt|,
name|freq
decl_stmt|,
name|voice_mode
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|instr
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|devc
operator|->
name|nr_voice
condition|)
return|return
literal|0
return|;
name|map
operator|=
operator|&
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|voice
index|]
index|]
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|note
operator|==
literal|255
condition|)
block|{
comment|/* Just change the volume */
name|set_voice_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|,
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|volume
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*      * Kill previous note before playing      */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Carrier volume to min */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Modulator volume to */
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
literal|4
condition|)
block|{
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Note off */
name|instr
operator|=
name|devc
operator|->
name|act_i
index|[
name|voice
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|instr
condition|)
name|instr
operator|=
operator|&
name|devc
operator|->
name|i_map
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|instr
operator|->
name|channel
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"OPL3: Initializing voice %d with undefined instrument\n"
argument_list|,
name|voice
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
literal|2
operator|&&
name|instr
operator|->
name|key
operator|==
name|OPL3_PATCH
condition|)
return|return
literal|0
return|;
comment|/* Cannot play */
name|voice_mode
operator|=
name|map
operator|->
name|voice_mode
expr_stmt|;
if|if
condition|(
name|voice_mode
operator|==
literal|4
condition|)
block|{
name|int
name|voice_shift
decl_stmt|;
name|voice_shift
operator|=
operator|(
name|map
operator|->
name|ioaddr
operator|==
name|devc
operator|->
name|left_io
operator|)
condition|?
literal|0
else|:
literal|3
expr_stmt|;
name|voice_shift
operator|+=
name|map
operator|->
name|voice_num
expr_stmt|;
if|if
condition|(
name|instr
operator|->
name|key
operator|!=
name|OPL3_PATCH
condition|)
block|{
comment|/* Just 2 OP patch */
name|voice_mode
operator|=
literal|2
expr_stmt|;
name|devc
operator|->
name|cmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|voice_shift
operator|)
expr_stmt|;
block|}
else|else
name|devc
operator|->
name|cmask
operator||=
operator|(
literal|1
operator|<<
name|voice_shift
operator|)
expr_stmt|;
name|opl3_command
argument_list|(
name|devc
operator|->
name|right_io
argument_list|,
name|CONNECTION_SELECT_REGISTER
argument_list|,
name|devc
operator|->
name|cmask
argument_list|)
expr_stmt|;
block|}
comment|/*      * Set Sound Characteristics      */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|AM_VIB
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|AM_VIB
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*      * Set Attack/Decay      */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|ATTACK_DECAY
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|ATTACK_DECAY
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/*      * Set Sustain/Release      */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|SUSTAIN_RELEASE
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|SUSTAIN_RELEASE
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
comment|/*      * Set Wave Select      */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|WAVE_SELECT
operator|+
name|map
operator|->
name|op
index|[
literal|0
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|WAVE_SELECT
operator|+
name|map
operator|->
name|op
index|[
literal|1
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/*      * Set Feedback/Connection      */
name|fpc
operator|=
name|instr
operator|->
name|operators
index|[
literal|10
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fpc
operator|&
literal|0x30
operator|)
condition|)
name|fpc
operator||=
literal|0x30
expr_stmt|;
comment|/* Ensure that at least one chn is enabled */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|FEEDBACK_CONNECTION
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|fpc
argument_list|)
expr_stmt|;
comment|/*      * If the voice is a 4 OP one, initialize the operators 3 and 4 also      */
if|if
condition|(
name|voice_mode
operator|==
literal|4
condition|)
block|{
comment|/* 	 * Set Sound Characteristics 	 */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|AM_VIB
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|0
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|AM_VIB
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Set Attack/Decay 	 */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|ATTACK_DECAY
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|4
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|ATTACK_DECAY
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Set Sustain/Release 	 */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|SUSTAIN_RELEASE
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|6
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|SUSTAIN_RELEASE
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|7
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Set Wave Select 	 */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|WAVE_SELECT
operator|+
name|map
operator|->
name|op
index|[
literal|2
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|8
index|]
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|WAVE_SELECT
operator|+
name|map
operator|->
name|op
index|[
literal|3
index|]
argument_list|,
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Set Feedback/Connection 	 */
name|fpc
operator|=
name|instr
operator|->
name|operators
index|[
name|OFFS_4OP
operator|+
literal|10
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fpc
operator|&
literal|0x30
operator|)
condition|)
name|fpc
operator||=
literal|0x30
expr_stmt|;
comment|/* Ensure that at least one chn is enabled */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|FEEDBACK_CONNECTION
operator|+
name|map
operator|->
name|voice_num
operator|+
literal|3
argument_list|,
name|fpc
argument_list|)
expr_stmt|;
block|}
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|mode
operator|=
name|voice_mode
expr_stmt|;
name|set_voice_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|,
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|volume
argument_list|)
expr_stmt|;
name|freq
operator|=
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|orig_freq
operator|=
name|note_to_freq
argument_list|(
name|note
argument_list|)
operator|/
literal|1000
expr_stmt|;
comment|/*      * Since the pitch bender may have been set before playing the note,      * we have to calculate the bending now.      */
name|freq
operator|=
name|compute_finetune
argument_list|(
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender
argument_list|,
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|freq
expr_stmt|;
name|freq_to_fnum
argument_list|(
name|freq
argument_list|,
operator|&
name|block
argument_list|,
operator|&
name|fnum
argument_list|)
expr_stmt|;
comment|/*      * Play note      */
name|data
operator|=
name|fnum
operator|&
literal|0xff
expr_stmt|;
comment|/* Least significant bits of fnumber */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|FNUM_LOW
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
literal|0x20
operator||
operator|(
operator|(
name|block
operator|&
literal|0x7
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|fnum
operator|>>
literal|8
operator|)
operator|&
literal|0x3
operator|)
expr_stmt|;
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|=
name|data
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|voice_mode
operator|==
literal|4
condition|)
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
operator|+
literal|3
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|freq_to_fnum
parameter_list|(
name|int
name|freq
parameter_list|,
name|int
modifier|*
name|block
parameter_list|,
name|int
modifier|*
name|fnum
parameter_list|)
block|{
name|int
name|f
decl_stmt|,
name|octave
decl_stmt|;
comment|/*      * Converts the note frequency to block and fnum values for the FM      * chip      */
comment|/*      * First try to compute the block -value (octave) where the note      * belongs      */
name|f
operator|=
name|freq
expr_stmt|;
name|octave
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
name|octave
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|f
operator|<
literal|261
condition|)
block|{
while|while
condition|(
name|f
operator|<
literal|261
condition|)
block|{
name|octave
operator|--
expr_stmt|;
name|f
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|f
operator|>
literal|493
condition|)
block|{
while|while
condition|(
name|f
operator|>
literal|493
condition|)
block|{
name|octave
operator|++
expr_stmt|;
name|f
operator|>>=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|octave
operator|>
literal|7
condition|)
name|octave
operator|=
literal|7
expr_stmt|;
operator|*
name|fnum
operator|=
name|freq
operator|*
operator|(
literal|1
operator|<<
operator|(
literal|20
operator|-
name|octave
operator|)
operator|)
operator|/
literal|49716
expr_stmt|;
operator|*
name|block
operator|=
name|octave
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_command
parameter_list|(
name|int
name|io_addr
parameter_list|,
name|u_int
name|addr
parameter_list|,
name|u_int
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/*      * The original 2-OP synth requires a quite long delay after writing      * to a register. The OPL-3 survives with just two INBs      */
name|outb
argument_list|(
name|io_addr
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|addr
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|devc
operator|->
name|model
operator|!=
literal|2
condition|)
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|inb
argument_list|(
name|io_addr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|io_addr
operator|+
literal|1
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|val
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|model
operator|!=
literal|2
condition|)
name|DELAY
argument_list|(
literal|30
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|inb
argument_list|(
name|io_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_reset
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
name|devc
operator|->
name|lv_map
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|devc
operator|->
name|nr_voice
condition|;
name|i
operator|++
control|)
block|{
name|opl3_command
argument_list|(
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|op
index|[
literal|0
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|op
index|[
literal|1
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|voice_mode
operator|==
literal|4
condition|)
block|{
name|opl3_command
argument_list|(
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|op
index|[
literal|2
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|ioaddr
argument_list|,
name|KSL_LEVEL
operator|+
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|i
index|]
index|]
operator|.
name|op
index|[
literal|3
index|]
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|opl3_kill_note
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devc
operator|->
name|model
operator|==
literal|2
condition|)
block|{
name|devc
operator|->
name|v_alloc
operator|->
name|max_voice
operator|=
name|devc
operator|->
name|nr_voice
operator|=
literal|18
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
name|pv_map
index|[
name|i
index|]
operator|.
name|voice_mode
operator|=
literal|2
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|devc
operator|->
name|busy
condition|)
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
name|devc
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
name|devc
operator|->
name|v_alloc
operator|->
name|max_voice
operator|=
name|devc
operator|->
name|nr_voice
operator|=
operator|(
name|devc
operator|->
name|model
operator|==
literal|2
operator|)
condition|?
literal|18
else|:
literal|9
expr_stmt|;
name|devc
operator|->
name|v_alloc
operator|->
name|timestamp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
block|{
name|devc
operator|->
name|v_alloc
operator|->
name|map
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|v_alloc
operator|->
name|alloc_times
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|devc
operator|->
name|cmask
operator|=
literal|0x00
expr_stmt|;
comment|/* Just 2 OP mode */
if|if
condition|(
name|devc
operator|->
name|model
operator|==
literal|2
condition|)
name|opl3_command
argument_list|(
name|devc
operator|->
name|right_io
argument_list|,
name|CONNECTION_SELECT_REGISTER
argument_list|,
name|devc
operator|->
name|cmask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|devc
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|v_alloc
operator|->
name|max_voice
operator|=
name|devc
operator|->
name|nr_voice
operator|=
operator|(
name|devc
operator|->
name|model
operator|==
literal|2
operator|)
condition|?
literal|18
else|:
literal|9
expr_stmt|;
name|devc
operator|->
name|fm_info
operator|.
name|nr_drums
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|fm_info
operator|.
name|perc_mode
operator|=
literal|0
expr_stmt|;
name|opl3_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_hw_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|opl3_load_patch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|format
parameter_list|,
name|snd_rw_buf
modifier|*
name|addr
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
block|{
name|struct
name|sbi_instrument
name|ins
decl_stmt|;
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"FM Error: Patch record too short\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|uiomove
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ins
operator|)
index|[
name|offs
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|ins
argument_list|)
operator|-
name|offs
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"sb: Bad copyin()!\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|ins
operator|.
name|channel
operator|<
literal|0
operator|||
name|ins
operator|.
name|channel
operator|>=
name|SBFM_MAXINSTR
condition|)
block|{
name|printf
argument_list|(
literal|"FM Error: Invalid instrument number %d\n"
argument_list|,
name|ins
operator|.
name|channel
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ins
operator|.
name|key
operator|=
name|format
expr_stmt|;
return|return
name|store_instr
argument_list|(
name|ins
operator|.
name|channel
argument_list|,
operator|&
name|ins
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_panning
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|pressure
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|opl3_volume_method
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{ }
end_function

begin_define
define|#
directive|define
name|SET_VIBRATO
parameter_list|(
name|cell
parameter_list|)
value|{ \       tmp = instr->operators[(cell-1)+(((cell-1)/2)*OFFS_4OP)]; \       if (pressure> 110) \ 	tmp |= 0x40;
comment|/* Vibrato on */
value|\       opl3_command (map->ioaddr, AM_VIB + map->op[cell-1], tmp);}
end_define

begin_function
specifier|static
name|void
name|opl3_aftertouch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|pressure
parameter_list|)
block|{
name|int
name|tmp
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|instr
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|devc
operator|->
name|nr_voice
condition|)
return|return;
name|map
operator|=
operator|&
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|voice
index|]
index|]
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"Aftertouch %d\n"
argument_list|,
name|voice
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
literal|0
condition|)
return|return;
comment|/*      * Adjust the amount of vibrato depending the pressure      */
name|instr
operator|=
name|devc
operator|->
name|act_i
index|[
name|voice
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|instr
condition|)
name|instr
operator|=
operator|&
name|devc
operator|->
name|i_map
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|mode
operator|==
literal|4
condition|)
block|{
name|int
name|connection
init|=
operator|(
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
index|]
operator|&
literal|0x01
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
operator|+
name|OFFS_4OP
index|]
operator|&
literal|0x01
operator|)
decl_stmt|;
switch|switch
condition|(
name|connection
condition|)
block|{
case|case
literal|0
case|:
name|SET_VIBRATO
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|SET_VIBRATO
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|SET_VIBRATO
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|SET_VIBRATO
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SET_VIBRATO
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|SET_VIBRATO
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SET_VIBRATO
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|SET_VIBRATO
argument_list|(
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Not implemented yet 	 */
block|}
else|else
block|{
name|SET_VIBRATO
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|instr
operator|->
name|operators
index|[
literal|10
index|]
operator|&
literal|0x01
operator|)
condition|)
comment|/* Additive synthesis */
name|SET_VIBRATO
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|SET_VIBRATO
end_undef

begin_function
specifier|static
name|void
name|bend_pitch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|u_char
name|data
decl_stmt|;
name|int
name|block
decl_stmt|,
name|fnum
decl_stmt|,
name|freq
decl_stmt|;
name|struct
name|physical_voice_info
modifier|*
name|map
decl_stmt|;
name|map
operator|=
operator|&
name|pv_map
index|[
name|devc
operator|->
name|lv_map
index|[
name|voice
index|]
index|]
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|voice_mode
operator|==
literal|0
condition|)
return|return;
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|&
literal|0x20
operator|)
condition|)
return|return;
comment|/* Not keyed on */
name|freq
operator|=
name|compute_finetune
argument_list|(
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender
argument_list|,
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|freq
expr_stmt|;
name|freq_to_fnum
argument_list|(
name|freq
argument_list|,
operator|&
name|block
argument_list|,
operator|&
name|fnum
argument_list|)
expr_stmt|;
name|data
operator|=
name|fnum
operator|&
literal|0xff
expr_stmt|;
comment|/* Least significant bits of fnumber */
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|FNUM_LOW
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
literal|0x20
operator||
operator|(
operator|(
name|block
operator|&
literal|0x7
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|fnum
operator|>>
literal|8
operator|)
operator|&
literal|0x3
operator|)
expr_stmt|;
comment|/* KEYON|OCTAVE|MS  bits of f-num */
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|keyon_byte
operator|=
name|data
expr_stmt|;
name|opl3_command
argument_list|(
name|map
operator|->
name|ioaddr
argument_list|,
name|KEYON_BLOCK
operator|+
name|map
operator|->
name|voice_num
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_controller
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|ctrl_num
parameter_list|,
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|devc
operator|->
name|nr_voice
condition|)
return|return;
switch|switch
condition|(
name|ctrl_num
condition|)
block|{
case|case
name|CTRL_PITCH_BENDER
case|:
name|bend_pitch
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL_PITCH_BENDER_RANGE
case|:
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|CTL_MAIN_VOLUME
case|:
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|volume
operator|=
name|value
operator|/
literal|128
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_patchmgr
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|patmgr_info
modifier|*
name|rec
parameter_list|)
block|{
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_bender
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|devc
operator|->
name|nr_voice
condition|)
return|return;
name|bend_pitch
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|value
operator|-
literal|8192
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|opl3_alloc_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|,
name|struct
name|voice_alloc_info
modifier|*
name|alloc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|p
decl_stmt|,
name|best
decl_stmt|,
name|first
decl_stmt|,
name|avail
decl_stmt|,
name|best_time
init|=
literal|0x7fffffff
decl_stmt|;
name|struct
name|sbi_instrument
modifier|*
name|instr
decl_stmt|;
name|int
name|is4op
decl_stmt|;
name|int
name|instr_no
decl_stmt|;
if|if
condition|(
name|chn
operator|<
literal|0
operator|||
name|chn
operator|>
literal|15
condition|)
name|instr_no
operator|=
literal|0
expr_stmt|;
else|else
name|instr_no
operator|=
name|devc
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|pgm_num
expr_stmt|;
name|instr
operator|=
operator|&
name|devc
operator|->
name|i_map
index|[
name|instr_no
index|]
expr_stmt|;
if|if
condition|(
name|instr
operator|->
name|channel
operator|<
literal|0
operator|||
comment|/* Instrument not loaded */
name|devc
operator|->
name|nr_voice
operator|!=
literal|12
condition|)
comment|/* Not in 4 OP mode */
name|is4op
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|devc
operator|->
name|nr_voice
operator|==
literal|12
condition|)
comment|/* 4 OP mode */
name|is4op
operator|=
operator|(
name|instr
operator|->
name|key
operator|==
name|OPL3_PATCH
operator|)
expr_stmt|;
else|else
name|is4op
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is4op
condition|)
block|{
name|first
operator|=
name|p
operator|=
literal|0
expr_stmt|;
name|avail
operator|=
literal|6
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|devc
operator|->
name|nr_voice
operator|==
literal|12
condition|)
comment|/* 4 OP mode. Use the '2 OP 					 * only' operators first */
name|first
operator|=
name|p
operator|=
literal|6
expr_stmt|;
else|else
name|first
operator|=
name|p
operator|=
literal|0
expr_stmt|;
name|avail
operator|=
name|devc
operator|->
name|nr_voice
expr_stmt|;
block|}
comment|/*      * Now try to find a free voice      */
name|best
operator|=
name|first
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|avail
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alloc
operator|->
name|map
index|[
name|p
index|]
operator|==
literal|0
condition|)
block|{
return|return
name|p
return|;
block|}
if|if
condition|(
name|alloc
operator|->
name|alloc_times
index|[
name|p
index|]
operator|<
name|best_time
condition|)
block|{
comment|/* Find oldest playing note */
name|best_time
operator|=
name|alloc
operator|->
name|alloc_times
index|[
name|p
index|]
expr_stmt|;
name|best
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
operator|%
name|avail
expr_stmt|;
block|}
comment|/*      * Insert some kind of priority mechanism here.      */
if|if
condition|(
name|best
operator|<
literal|0
condition|)
name|best
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|best
operator|>
name|devc
operator|->
name|nr_voice
condition|)
name|best
operator|-=
name|devc
operator|->
name|nr_voice
expr_stmt|;
return|return
name|best
return|;
comment|/* All devc->voc in use. Select the first 				 * one. */
block|}
end_function

begin_function
specifier|static
name|void
name|opl3_setup_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|chn
parameter_list|)
block|{
name|struct
name|channel_info
modifier|*
name|info
init|=
operator|&
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
decl_stmt|;
name|opl3_set_instr
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|info
operator|->
name|pgm_num
argument_list|)
expr_stmt|;
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|info
operator|->
name|bender_value
expr_stmt|;
name|devc
operator|->
name|voc
index|[
name|voice
index|]
operator|.
name|volume
operator|=
name|info
operator|->
name|controllers
index|[
name|CTL_MAIN_VOLUME
index|]
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|synth_operations
name|opl3_operations
init|=
block|{
name|NULL
block|,
literal|0
block|,
name|SYNTH_TYPE_FM
block|,
name|FM_TYPE_ADLIB
block|,
name|opl3_open
block|,
name|opl3_close
block|,
name|opl3_ioctl
block|,
name|opl3_kill_note
block|,
name|opl3_start_note
block|,
name|opl3_set_instr
block|,
name|opl3_reset
block|,
name|opl3_hw_control
block|,
name|opl3_load_patch
block|,
name|opl3_aftertouch
block|,
name|opl3_controller
block|,
name|opl3_panning
block|,
name|opl3_volume_method
block|,
name|opl3_patchmgr
block|,
name|opl3_bender
block|,
name|opl3_alloc_voice
block|,
name|opl3_setup_voice
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|opl3_init
parameter_list|(
name|int
name|ioaddr
parameter_list|,
name|sound_os_info
modifier|*
name|osp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|num_synths
operator|>=
name|MAX_SYNTH_DEV
condition|)
block|{
name|printf
argument_list|(
literal|"OPL3 Error: Too many synthesizers\n"
argument_list|)
expr_stmt|;
return|return ;
block|}
if|if
condition|(
name|devc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"OPL3: Device control structure not initialized.\n"
argument_list|)
expr_stmt|;
return|return ;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|devc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|devc
argument_list|)
argument_list|)
expr_stmt|;
name|devc
operator|->
name|osp
operator|=
name|osp
expr_stmt|;
name|devc
operator|->
name|nr_voice
operator|=
literal|9
expr_stmt|;
name|strcpy
argument_list|(
name|devc
operator|->
name|fm_info
operator|.
name|name
argument_list|,
literal|"OPL2-"
argument_list|)
expr_stmt|;
name|devc
operator|->
name|fm_info
operator|.
name|device
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|fm_info
operator|.
name|synth_type
operator|=
name|SYNTH_TYPE_FM
expr_stmt|;
name|devc
operator|->
name|fm_info
operator|.
name|synth_subtype
operator|=
name|FM_TYPE_ADLIB
expr_stmt|;
name|devc
operator|->
name|fm_info
operator|.
name|perc_mode
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|fm_info
operator|.
name|nr_voices
operator|=
literal|9
expr_stmt|;
name|devc
operator|->
name|fm_info
operator|.
name|nr_drums
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|fm_info
operator|.
name|instr_bank_size
operator|=
name|SBFM_MAXINSTR
expr_stmt|;
name|devc
operator|->
name|fm_info
operator|.
name|capabilities
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|left_io
operator|=
name|ioaddr
expr_stmt|;
name|devc
operator|->
name|right_io
operator|=
name|ioaddr
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|detected_model
operator|<=
literal|2
condition|)
name|devc
operator|->
name|model
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|devc
operator|->
name|model
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|detected_model
operator|==
literal|4
condition|)
name|devc
operator|->
name|is_opl4
operator|=
literal|1
expr_stmt|;
block|}
name|opl3_operations
operator|.
name|info
operator|=
operator|&
name|devc
operator|->
name|fm_info
expr_stmt|;
name|synth_devs
index|[
name|num_synths
operator|++
index|]
operator|=
operator|&
name|opl3_operations
expr_stmt|;
name|devc
operator|->
name|v_alloc
operator|=
operator|&
name|opl3_operations
operator|.
name|alloc
expr_stmt|;
name|devc
operator|->
name|chn_info
operator|=
operator|&
name|opl3_operations
operator|.
name|chn_info
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|model
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|devc
operator|->
name|is_opl4
condition|)
name|conf_printf2
argument_list|(
literal|"Yamaha OPL4/OPL3 FM"
argument_list|,
name|ioaddr
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|conf_printf2
argument_list|(
literal|"Yamaha OPL3 FM"
argument_list|,
name|ioaddr
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|devc
operator|->
name|v_alloc
operator|->
name|max_voice
operator|=
name|devc
operator|->
name|nr_voice
operator|=
literal|18
expr_stmt|;
name|devc
operator|->
name|fm_info
operator|.
name|nr_drums
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|fm_info
operator|.
name|capabilities
operator||=
name|SYNTH_CAP_OPL3
expr_stmt|;
name|strcpy
argument_list|(
name|devc
operator|->
name|fm_info
operator|.
name|name
argument_list|,
literal|"Yamaha OPL-3"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pv_map
index|[
name|i
index|]
operator|.
name|ioaddr
operator|==
name|USE_LEFT
condition|)
name|pv_map
index|[
name|i
index|]
operator|.
name|ioaddr
operator|=
name|devc
operator|->
name|left_io
expr_stmt|;
else|else
name|pv_map
index|[
name|i
index|]
operator|.
name|ioaddr
operator|=
name|devc
operator|->
name|right_io
expr_stmt|;
name|opl3_command
argument_list|(
name|devc
operator|->
name|right_io
argument_list|,
name|OPL3_MODE_REGISTER
argument_list|,
name|OPL3_ENABLE
argument_list|)
expr_stmt|;
name|opl3_command
argument_list|(
name|devc
operator|->
name|right_io
argument_list|,
name|CONNECTION_SELECT_REGISTER
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|conf_printf2
argument_list|(
literal|"Yamaha OPL2 FM"
argument_list|,
name|ioaddr
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|devc
operator|->
name|v_alloc
operator|->
name|max_voice
operator|=
name|devc
operator|->
name|nr_voice
operator|=
literal|9
expr_stmt|;
name|devc
operator|->
name|fm_info
operator|.
name|nr_drums
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|18
condition|;
name|i
operator|++
control|)
name|pv_map
index|[
name|i
index|]
operator|.
name|ioaddr
operator|=
name|devc
operator|->
name|left_io
expr_stmt|;
block|}
empty_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBFM_MAXINSTR
condition|;
name|i
operator|++
control|)
name|devc
operator|->
name|i_map
index|[
name|i
index|]
operator|.
name|channel
operator|=
operator|-
literal|1
expr_stmt|;
return|return ;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

