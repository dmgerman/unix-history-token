begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/ad1848.c  *   * Modified by Luigi Rizzo (luigi@iet.unipi.it)  *  * The low level driver for the AD1848/CS4248 codec chip which is used for  * example in the MS Sound System.  *   * The CS4231 which is used in the GUS MAX and some other cards is upwards  * compatible with AD1848 and this driver is able to drive it.  *   * CS4231A and AD1845 are upward compatible with CS4231. However the new  * features of these chips are different.  *   * CS4232 is a PnP audio chip which contains a CS4231A (and SB, MPU). CS4232A is  * an improved version of CS4232.  *   * CS4236 is also a PnP audio chip similar to the 4232  *  * OPTi931 is another high-end 1848-type chip. It differs in the use  * of the high 16 registers and configuration stuff. Luckily, being a  * PnP device, we can avoid black magic to identify the chip and be  * sure of its identity.  *   * Copyright by Hannu Savolainen 1994, 1995  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * Modified: Riccardo Facchetti  24 Mar 1995 - Added the Audio Excel DSP 16  * initialization routine.  */
end_comment

begin_define
define|#
directive|define
name|DEB
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DEB1
parameter_list|(
name|x
parameter_list|)
end_define

begin_include
include|#
directive|include
file|<i386/isa/sound/sound_config.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_AD1848
argument_list|)
end_if

begin_include
include|#
directive|include
file|<i386/isa/sound/ad1848_mixer.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/sound/iwdefs.h>
end_include

begin_function_decl
specifier|extern
name|void
name|IwaveStopDma
parameter_list|(
name|BYTE
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|base
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|int
name|dual_dma
decl_stmt|;
comment|/* 1, when two DMA channels allocated */
name|u_char
name|MCE_bit
decl_stmt|;
name|u_char
name|saved_regs
index|[
literal|16
index|]
decl_stmt|;
name|int
name|speed
decl_stmt|;
name|u_char
name|speed_bits
decl_stmt|;
name|int
name|channels
decl_stmt|;
name|int
name|audio_format
decl_stmt|;
name|u_char
name|format_bits
decl_stmt|;
name|u_long
name|xfer_count
decl_stmt|;
name|int
name|irq_mode
decl_stmt|;
name|int
name|intr_active
decl_stmt|;
name|int
name|opened
decl_stmt|;
name|char
modifier|*
name|chip_name
decl_stmt|;
name|int
name|mode
decl_stmt|;
define|#
directive|define
name|MD_1848
value|1
define|#
directive|define
name|MD_4231
value|2
define|#
directive|define
name|MD_4231A
value|3
define|#
directive|define
name|MD_4236
value|4
define|#
directive|define
name|MD_1845
value|5
define|#
directive|define
name|MD_MAXMODE
value|6
comment|/* Mixer parameters */
name|int
name|recmask
decl_stmt|;
name|int
name|supported_devices
decl_stmt|;
name|int
name|supported_rec_devices
decl_stmt|;
name|u_short
name|levels
index|[
literal|32
index|]
decl_stmt|;
name|int
name|dev_no
decl_stmt|;
specifier|volatile
name|u_long
name|timer_ticks
decl_stmt|;
name|int
name|timer_running
decl_stmt|;
name|int
name|irq_ok
decl_stmt|;
name|sound_os_info
modifier|*
name|osp
decl_stmt|;
block|}
name|ad1848_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|nr_ad1848_devs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|char
name|irq2dev
index|[
literal|17
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timer_installed
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mute_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|mixer2codec
index|[
name|MAX_MIXER_DEV
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ad_format_mask
index|[
name|MD_MAXMODE
comment|/* devc->mode */
index|]
init|=
block|{
comment|/* 0 - none	   */
literal|0
block|,
comment|/* 1 - AD1848  */
name|AFMT_U8
operator||
name|AFMT_S16_LE
operator||
name|AFMT_MU_LAW
operator||
name|AFMT_A_LAW
block|,
comment|/*      * AFMT_U8 | AFMT_S16_LE | AFMT_MU_LAW  | AFMT_A_LAW | AFMT_U16_LE |      * AFMT_IMA_ADPCM,      */
comment|/* 2 - CS4231  */
name|AFMT_U8
operator||
name|AFMT_S16_LE
operator||
name|AFMT_U16_LE
block|,
comment|/*      * AFMT_U8 | AFMT_S16_LE | AFMT_MU_LAW | AFMT_A_LAW | AFMT_U16_LE |      * AFMT_IMA_ADPCM,      */
comment|/* 3 - CS4231A */
name|AFMT_U8
operator||
name|AFMT_S16_LE
operator||
name|AFMT_MU_LAW
operator||
name|AFMT_A_LAW
block|,
comment|/* 4 - AD1845 */
name|AFMT_U8
operator||
name|AFMT_S16_LE
operator||
name|AFMT_MU_LAW
operator||
name|AFMT_A_LAW
block|,
comment|/* 5 - CS4236 */
name|AFMT_U8
operator||
name|AFMT_S16_LE
operator||
name|AFMT_MU_LAW
operator||
name|AFMT_A_LAW
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ad1848_info
name|dev_info
index|[
name|MAX_AUDIO_DEV
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|io_Index_Addr
parameter_list|(
name|d
parameter_list|)
value|((d)->base)
end_define

begin_define
define|#
directive|define
name|io_Indexed_Data
parameter_list|(
name|d
parameter_list|)
value|((d)->base+1)
end_define

begin_define
define|#
directive|define
name|io_Status
parameter_list|(
name|d
parameter_list|)
value|((d)->base+2)
end_define

begin_define
define|#
directive|define
name|io_Polled_IO
parameter_list|(
name|d
parameter_list|)
value|((d)->base+3)
end_define

begin_function_decl
specifier|static
name|int
name|ad1848_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ad1848_close
parameter_list|(
name|int
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ad1848_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|ioctl_arg
name|arg
parameter_list|,
name|int
name|local
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ad1848_output_block
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_long
name|buf
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|intrflag
parameter_list|,
name|int
name|dma_restart
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ad1848_start_input
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_long
name|buf
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|intrflag
parameter_list|,
name|int
name|dma_restart
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ad1848_prepare_for_IO
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|bsize
parameter_list|,
name|int
name|bcount
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ad1848_reset
parameter_list|(
name|int
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ad1848_halt
parameter_list|(
name|int
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ad1848_halt_input
parameter_list|(
name|int
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ad1848_halt_output
parameter_list|(
name|int
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ad1848_trigger
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|bits
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ad1848_tmr_install
parameter_list|(
name|int
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ad1848_tmr_reprogram
parameter_list|(
name|int
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * AD_WAIT_INIT waits if we are initializing the board and we cannot modify  * its settings  */
end_comment

begin_define
define|#
directive|define
name|AD_WAIT_INIT
parameter_list|(
name|x
parameter_list|)
value|{int t=x; while(t>0&& inb(devc->base) == 0x80) t-- ; }
end_define

begin_function_decl
name|short
name|ipri_to_irq
parameter_list|(
name|u_short
name|ipri
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|adintr
parameter_list|(
name|unit
parameter_list|)
block|{
specifier|static
name|short
name|unit_to_irq
index|[
literal|4
index|]
init|=
block|{
literal|9
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
if|if
condition|(
name|unit_to_irq
index|[
name|unit
index|]
operator|>
literal|0
condition|)
name|ad1848_interrupt
argument_list|(
name|unit_to_irq
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CS4232
argument_list|)
name|dev
operator|=
name|find_isadev
argument_list|(
name|isa_devtab_null
argument_list|,
operator|&
name|cssdriver
argument_list|,
name|unit
argument_list|)
expr_stmt|;
else|#
directive|else
name|dev
operator|=
name|find_isadev
argument_list|(
name|isa_devtab_null
argument_list|,
operator|&
name|mssdriver
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|dev
condition|)
name|printf
argument_list|(
literal|"ad1848: Couldn't determine unit\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|unit_to_irq
index|[
name|unit
index|]
operator|=
name|ipri_to_irq
argument_list|(
name|dev
operator|->
name|id_irq
argument_list|)
expr_stmt|;
name|ad1848_interrupt
argument_list|(
name|unit_to_irq
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ad_read
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|int
name|x
decl_stmt|;
name|AD_WAIT_INIT
argument_list|(
literal|900000
argument_list|)
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|io_Index_Addr
argument_list|(
name|devc
argument_list|)
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|reg
operator|&
literal|0xff
argument_list|)
operator||
name|devc
operator|->
name|MCE_bit
argument_list|)
expr_stmt|;
name|x
operator|=
name|inb
argument_list|(
name|io_Indexed_Data
argument_list|(
name|devc
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad_write
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|,
name|int
name|reg
parameter_list|,
name|u_char
name|data
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|AD_WAIT_INIT
argument_list|(
literal|90000
argument_list|)
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|io_Index_Addr
argument_list|(
name|devc
argument_list|)
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|reg
operator|&
literal|0xff
argument_list|)
operator||
name|devc
operator|->
name|MCE_bit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|io_Indexed_Data
argument_list|(
name|devc
argument_list|)
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|data
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wait_for_calibration
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|)
block|{
name|int
name|timeout
init|=
literal|0
decl_stmt|;
comment|/*      * Wait until the auto calibration process has finished.      *       * 1)       Wait until the chip becomes ready (reads don't return 0x80).      * 2)       Wait until the ACI bit of I11 gets on and then off.      */
name|AD_WAIT_INIT
argument_list|(
literal|100000
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|devc
operator|->
name|base
argument_list|)
operator|&
literal|0x80
condition|)
name|printf
argument_list|(
literal|"ad1848: Auto calibration timed out(1).\n"
argument_list|)
expr_stmt|;
name|timeout
operator|=
literal|100
expr_stmt|;
while|while
condition|(
name|timeout
operator|>
literal|0
operator|&&
operator|!
operator|(
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|11
argument_list|)
operator|&
literal|0x20
operator|)
condition|)
name|timeout
operator|--
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|11
argument_list|)
operator|&
literal|0x20
operator|)
condition|)
return|return;
name|timeout
operator|=
literal|20000
expr_stmt|;
while|while
condition|(
name|timeout
operator|>
literal|0
operator|&&
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|11
argument_list|)
operator|&
literal|0x20
condition|)
name|timeout
operator|--
expr_stmt|;
if|if
condition|(
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|11
argument_list|)
operator|&
literal|0x20
condition|)
name|printf
argument_list|(
literal|"ad1848: Auto calibration timed out(3).\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad_mute
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|prev
decl_stmt|;
name|mute_flag
operator|=
literal|1
expr_stmt|;
comment|/*      * Save old register settings and mute output channels      */
for|for
control|(
name|i
operator|=
literal|6
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|prev
operator|=
name|devc
operator|->
name|saved_regs
index|[
name|i
index|]
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
name|i
argument_list|,
name|prev
operator||
literal|0x80
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ad_unmute
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mute_flag
operator|=
literal|0
expr_stmt|;
comment|/*      * Restore back old volume registers (unmute)      */
for|for
control|(
name|i
operator|=
literal|6
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|ad_write
argument_list|(
name|devc
argument_list|,
name|i
argument_list|,
name|devc
operator|->
name|saved_regs
index|[
name|i
index|]
operator|&
operator|~
literal|0x80
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad_enter_MCE
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|AD_WAIT_INIT
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|devc
operator|->
name|MCE_bit
operator|=
literal|0x40
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|io_Index_Addr
argument_list|(
name|devc
argument_list|)
argument_list|)
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|)
name|outb
argument_list|(
name|io_Index_Addr
argument_list|(
name|devc
argument_list|)
argument_list|,
name|devc
operator|->
name|MCE_bit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad_leave_MCE
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|u_char
name|prev
decl_stmt|;
name|AD_WAIT_INIT
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|devc
operator|->
name|MCE_bit
operator|=
literal|0x00
expr_stmt|;
name|prev
operator|=
name|inb
argument_list|(
name|io_Index_Addr
argument_list|(
name|devc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX the next call is redundant ? */
name|outb
argument_list|(
name|io_Index_Addr
argument_list|(
name|devc
argument_list|)
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Clear the MCE bit */
if|if
condition|(
operator|(
name|prev
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Not in MCE mode */
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|outb
argument_list|(
name|io_Index_Addr
argument_list|(
name|devc
argument_list|)
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Clear the MCE bit */
name|wait_for_calibration
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ad1848_set_recmask
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|,
name|int
name|mask
parameter_list|)
block|{
name|u_char
name|recdev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|mask
operator|&=
name|devc
operator|->
name|supported_rec_devices
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
comment|/* Count selected device bits */
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|mask
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
block|{
comment|/* Too many devices selected */
name|mask
operator|&=
operator|~
name|devc
operator|->
name|recmask
expr_stmt|;
comment|/* Filter out active settings */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
comment|/* Count selected device bits */
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|1
condition|)
name|mask
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
block|}
switch|switch
condition|(
name|mask
condition|)
block|{
case|case
name|SOUND_MASK_MIC
case|:
name|recdev
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|SOUND_MASK_LINE
case|:
case|case
name|SOUND_MASK_LINE3
case|:
name|recdev
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SOUND_MASK_CD
case|:
case|case
name|SOUND_MASK_LINE1
case|:
name|recdev
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SOUND_MASK_IMIX
case|:
name|recdev
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|mask
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
name|recdev
operator|=
literal|2
expr_stmt|;
block|}
name|recdev
operator|<<=
literal|6
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|0
argument_list|,
operator|(
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|0
argument_list|)
operator|&
literal|0x3f
operator|)
operator||
name|recdev
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|1
argument_list|,
operator|(
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|1
argument_list|)
operator|&
literal|0x3f
operator|)
operator||
name|recdev
argument_list|)
expr_stmt|;
name|devc
operator|->
name|recmask
operator|=
name|mask
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|change_bits
parameter_list|(
name|u_char
modifier|*
name|regval
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|newval
parameter_list|)
block|{
name|u_char
name|mask
decl_stmt|;
name|int
name|shift
decl_stmt|;
if|if
condition|(
name|mix_devices
index|[
name|dev
index|]
index|[
name|chn
index|]
operator|.
name|polarity
operator|==
literal|1
condition|)
comment|/* Reverse */
name|newval
operator|=
literal|100
operator|-
name|newval
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
name|mix_devices
index|[
name|dev
index|]
index|[
name|chn
index|]
operator|.
name|nbits
operator|)
operator|-
literal|1
expr_stmt|;
name|shift
operator|=
name|mix_devices
index|[
name|dev
index|]
index|[
name|chn
index|]
operator|.
name|bitpos
expr_stmt|;
name|newval
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|newval
operator|*
name|mask
operator|)
operator|+
literal|50
argument_list|)
operator|/
literal|100
expr_stmt|;
comment|/* Scale it */
operator|*
name|regval
operator|&=
operator|~
operator|(
name|mask
operator|<<
name|shift
operator|)
expr_stmt|;
comment|/* Clear bits */
operator|*
name|regval
operator||=
operator|(
name|newval
operator|&
name|mask
operator|)
operator|<<
name|shift
expr_stmt|;
comment|/* Set new value */
block|}
end_function

begin_function
specifier|static
name|int
name|ad1848_mixer_get
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|,
name|int
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|&
name|devc
operator|->
name|supported_devices
operator|)
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
return|return
name|devc
operator|->
name|levels
index|[
name|dev
index|]
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CLMICI
value|0x00781601
end_define

begin_define
define|#
directive|define
name|CRMICI
value|0x00791701
end_define

begin_function
specifier|static
name|int
name|ad1848_mixer_set
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|int
name|left
init|=
name|value
operator|&
literal|0x000000ff
decl_stmt|;
name|int
name|right
init|=
operator|(
name|value
operator|&
literal|0x0000ff00
operator|)
operator|>>
literal|8
decl_stmt|;
name|int
name|retvol
decl_stmt|;
name|int
name|regoffs
decl_stmt|;
name|u_char
name|val
decl_stmt|;
comment|/* u_char  clci,  crmici,  clmici,  clici,  crici; */
if|if
condition|(
name|left
operator|>
literal|100
condition|)
name|left
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|right
operator|>
literal|100
condition|)
name|right
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|mix_devices
index|[
name|dev
index|]
index|[
name|RIGHT_CHN
index|]
operator|.
name|nbits
operator|==
literal|0
condition|)
comment|/* Mono control */
name|right
operator|=
name|left
expr_stmt|;
name|retvol
operator|=
name|left
operator||
operator|(
name|right
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Scale volumes */
name|left
operator|=
name|mix_cvt
index|[
name|left
index|]
expr_stmt|;
name|right
operator|=
name|mix_cvt
index|[
name|right
index|]
expr_stmt|;
comment|/* Scale it again */
name|left
operator|=
name|mix_cvt
index|[
name|left
index|]
expr_stmt|;
name|right
operator|=
name|mix_cvt
index|[
name|right
index|]
expr_stmt|;
if|if
condition|(
name|dev
operator|>
literal|31
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|devc
operator|->
name|supported_devices
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mix_devices
index|[
name|dev
index|]
index|[
name|LEFT_CHN
index|]
operator|.
name|nbits
operator|==
literal|0
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
name|devc
operator|->
name|levels
index|[
name|dev
index|]
operator|=
name|retvol
expr_stmt|;
comment|/*      * Set the left channel      */
comment|/* IwaveCodecMode(CODEC_MODE3);        Default codec mode  */
name|regoffs
operator|=
name|mix_devices
index|[
name|dev
index|]
index|[
name|LEFT_CHN
index|]
operator|.
name|regno
expr_stmt|;
name|val
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
name|regoffs
argument_list|)
expr_stmt|;
name|change_bits
argument_list|(
operator|&
name|val
argument_list|,
name|dev
argument_list|,
name|LEFT_CHN
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
name|regoffs
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|devc
operator|->
name|saved_regs
index|[
name|regoffs
index|]
operator|=
name|val
expr_stmt|;
comment|/*      * Set the right channel      */
if|if
condition|(
name|mix_devices
index|[
name|dev
index|]
index|[
name|RIGHT_CHN
index|]
operator|.
name|nbits
operator|==
literal|0
condition|)
return|return
name|retvol
return|;
comment|/* Was just a mono channel */
name|regoffs
operator|=
name|mix_devices
index|[
name|dev
index|]
index|[
name|RIGHT_CHN
index|]
operator|.
name|regno
expr_stmt|;
name|val
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
name|regoffs
argument_list|)
expr_stmt|;
name|change_bits
argument_list|(
operator|&
name|val
argument_list|,
name|dev
argument_list|,
name|RIGHT_CHN
argument_list|,
name|right
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
name|regoffs
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|devc
operator|->
name|saved_regs
index|[
name|regoffs
index|]
operator|=
name|val
expr_stmt|;
return|return
name|retvol
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad1848_mixer_reset
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|devc
operator|->
name|recmask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|mode
operator|!=
name|MD_1848
condition|)
name|devc
operator|->
name|supported_devices
operator|=
name|MODE2_MIXER_DEVICES
expr_stmt|;
else|else
name|devc
operator|->
name|supported_devices
operator|=
name|MODE1_MIXER_DEVICES
expr_stmt|;
name|devc
operator|->
name|supported_rec_devices
operator|=
name|MODE1_REC_DEVICES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SOUND_MIXER_NRDEVICES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|devc
operator|->
name|supported_devices
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|ad1848_mixer_set
argument_list|(
name|devc
argument_list|,
name|i
argument_list|,
name|default_mixer_levels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ad1848_set_recmask
argument_list|(
name|devc
argument_list|,
name|SOUND_MASK_MIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ad1848_mixer_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|ioctl_arg
name|arg
parameter_list|)
block|{
name|ad1848_info
modifier|*
name|devc
decl_stmt|;
name|int
name|codec_dev
init|=
name|mixer2codec
index|[
name|dev
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|codec_dev
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
name|codec_dev
operator|--
expr_stmt|;
name|devc
operator|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|codec_dev
index|]
operator|->
name|devc
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cmd
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|==
literal|'M'
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|IOC_IN
condition|)
switch|switch
condition|(
name|cmd
operator|&
literal|0xff
condition|)
block|{
case|case
name|SOUND_MIXER_RECSRC
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|ad1848_set_recmask
argument_list|(
name|devc
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
argument_list|)
return|;
break|break;
default|default:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|ad1848_mixer_set
argument_list|(
name|devc
argument_list|,
name|cmd
operator|&
literal|0xff
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
argument_list|)
return|;
block|}
else|else
switch|switch
condition|(
name|cmd
operator|&
literal|0xff
condition|)
block|{
comment|/* Return parameters */
case|case
name|SOUND_MIXER_RECSRC
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|devc
operator|->
name|recmask
return|;
break|break;
case|case
name|SOUND_MIXER_DEVMASK
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|devc
operator|->
name|supported_devices
return|;
break|break;
case|case
name|SOUND_MIXER_STEREODEVS
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|devc
operator|->
name|supported_devices
operator|&
operator|~
operator|(
name|SOUND_MASK_SPEAKER
operator||
name|SOUND_MASK_IMIX
operator|)
return|;
break|break;
case|case
name|SOUND_MIXER_RECMASK
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|devc
operator|->
name|supported_rec_devices
return|;
break|break;
case|case
name|SOUND_MIXER_CAPS
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|SOUND_CAP_EXCL_INPUT
return|;
break|break;
default|default:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|ad1848_mixer_get
argument_list|(
name|devc
argument_list|,
name|cmd
operator|&
literal|0xff
argument_list|)
return|;
block|}
block|}
else|else
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|audio_operations
name|ad1848_pcm_operations
index|[
name|MAX_AUDIO_DEV
index|]
init|=
block|{
block|{
literal|"Generic AD1848 codec"
block|,
comment|/* DMA_AUTOMODE | DMA_DUPLEX, */
name|DMA_AUTOMODE
block|,
name|AFMT_U8
block|,
comment|/* Will be set later */
name|NULL
block|,
name|ad1848_open
block|,
name|ad1848_close
block|,
name|ad1848_output_block
block|,
name|ad1848_start_input
block|,
name|ad1848_ioctl
block|,
name|ad1848_prepare_for_IO
block|,
name|ad1848_prepare_for_IO
block|,
name|ad1848_reset
block|,
name|ad1848_halt
block|,
name|NULL
block|,
name|NULL
block|,
name|ad1848_halt_input
block|,
name|ad1848_halt_output
block|,
name|ad1848_trigger
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mixer_operations
name|ad1848_mixer_operations
init|=
block|{
literal|"AD1848/CS4248/CS4231/CS4236"
block|,
name|ad1848_mixer_ioctl
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ad1848_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|ad1848_info
modifier|*
name|devc
init|=
name|NULL
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|int
name|otherside
init|=
name|audio_devs
index|[
name|dev
index|]
operator|->
name|otherside
decl_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_audiodevs
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|otherside
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|audio_devs
index|[
name|otherside
index|]
operator|->
name|busy
condition|)
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|audio_devs
index|[
name|dev
index|]
operator|->
name|busy
condition|)
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
name|devc
operator|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|audio_devs
index|[
name|dev
index|]
operator|->
name|busy
condition|)
block|{
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
block|}
name|devc
operator|->
name|dual_dma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|audio_devs
index|[
name|dev
index|]
operator|->
name|flags
operator|&
name|DMA_DUPLEX
condition|)
block|{
name|devc
operator|->
name|dual_dma
operator|=
literal|1
expr_stmt|;
block|}
name|devc
operator|->
name|intr_active
operator|=
literal|0
expr_stmt|;
name|audio_devs
index|[
name|dev
index|]
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
name|devc
operator|->
name|irq_mode
operator|=
literal|0
expr_stmt|;
name|ad1848_trigger
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/*      * Mute output until the playback really starts. This decreases      * clicking.      */
name|ad_mute
argument_list|(
name|devc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad1848_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|ad1848_info
modifier|*
name|devc
init|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
decl_stmt|;
name|int
name|otherside
init|=
name|audio_devs
index|[
name|dev
index|]
operator|->
name|otherside
decl_stmt|;
if|if
condition|(
name|otherside
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|audio_devs
index|[
name|otherside
index|]
operator|->
name|busy
condition|)
return|return;
block|}
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_close(void)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|ad_mute
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|,
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|)
operator|&
operator|~
literal|0x1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|io_Status
argument_list|(
name|devc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear interrupt status */
comment|/*      * ad_write (devc, 15,0); ad_write (devc, 14,0);      */
name|devc
operator|->
name|irq_mode
operator|&=
operator|~
name|PCM_ENABLE_OUTPUT
expr_stmt|;
name|devc
operator|->
name|intr_active
operator|=
literal|0
expr_stmt|;
name|ad1848_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|devc
operator|->
name|opened
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|irq_mode
operator|=
literal|0
expr_stmt|;
name|audio_devs
index|[
name|dev
index|]
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|ad_unmute
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_speed
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
comment|/*      * The sampling speed is encoded in the least significant nible of      * I8. The LSB selects the clock source (0=24.576 MHz, 1=16.9344 Mhz)      * and other three bits select the divisor (indirectly):      *       * The available speeds are in the following table. Keep the speeds in      * the increasing order.      */
typedef|typedef
struct|struct
block|{
name|int
name|speed
decl_stmt|;
name|u_char
name|bits
decl_stmt|;
block|}
name|speed_struct
typedef|;
specifier|static
name|speed_struct
name|speed_table
index|[]
init|=
block|{
block|{
literal|5510
block|,
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
literal|1
block|}
block|,
block|{
literal|5510
block|,
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
literal|1
block|}
block|,
block|{
literal|6620
block|,
operator|(
literal|7
operator|<<
literal|1
operator|)
operator||
literal|1
block|}
block|,
block|{
literal|8000
block|,
operator|(
literal|0
operator|<<
literal|1
operator|)
operator||
literal|0
block|}
block|,
block|{
literal|9600
block|,
operator|(
literal|7
operator|<<
literal|1
operator|)
operator||
literal|0
block|}
block|,
block|{
literal|11025
block|,
operator|(
literal|1
operator|<<
literal|1
operator|)
operator||
literal|1
block|}
block|,
block|{
literal|16000
block|,
operator|(
literal|1
operator|<<
literal|1
operator|)
operator||
literal|0
block|}
block|,
block|{
literal|18900
block|,
operator|(
literal|2
operator|<<
literal|1
operator|)
operator||
literal|1
block|}
block|,
block|{
literal|22050
block|,
operator|(
literal|3
operator|<<
literal|1
operator|)
operator||
literal|1
block|}
block|,
block|{
literal|27420
block|,
operator|(
literal|2
operator|<<
literal|1
operator|)
operator||
literal|0
block|}
block|,
block|{
literal|32000
block|,
operator|(
literal|3
operator|<<
literal|1
operator|)
operator||
literal|0
block|}
block|,
block|{
literal|33075
block|,
operator|(
literal|6
operator|<<
literal|1
operator|)
operator||
literal|1
block|}
block|,
block|{
literal|37800
block|,
operator|(
literal|4
operator|<<
literal|1
operator|)
operator||
literal|1
block|}
block|,
block|{
literal|44100
block|,
operator|(
literal|5
operator|<<
literal|1
operator|)
operator||
literal|1
block|}
block|,
block|{
literal|48000
block|,
operator|(
literal|6
operator|<<
literal|1
operator|)
operator||
literal|0
block|}
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|selected
init|=
operator|-
literal|1
decl_stmt|;
name|n
operator|=
sizeof|sizeof
argument_list|(
name|speed_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|speed_struct
argument_list|)
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|mode
operator|==
name|MD_1845
condition|)
block|{
comment|/* AD1845 has different timer than others */
name|RANGE
argument_list|(
name|arg
argument_list|,
literal|4000
argument_list|,
literal|50000
argument_list|)
expr_stmt|;
name|devc
operator|->
name|speed
operator|=
name|arg
expr_stmt|;
name|devc
operator|->
name|speed_bits
operator|=
name|speed_table
index|[
name|selected
index|]
operator|.
name|bits
expr_stmt|;
return|return
name|devc
operator|->
name|speed
return|;
block|}
if|if
condition|(
name|arg
operator|<
name|speed_table
index|[
literal|0
index|]
operator|.
name|speed
condition|)
name|selected
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arg
operator|>
name|speed_table
index|[
name|n
operator|-
literal|1
index|]
operator|.
name|speed
condition|)
name|selected
operator|=
name|n
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
comment|/* really */
init|;
name|selected
operator|==
operator|-
literal|1
operator|&&
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|speed_table
index|[
name|i
index|]
operator|.
name|speed
operator|==
name|arg
condition|)
name|selected
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|speed_table
index|[
name|i
index|]
operator|.
name|speed
operator|>
name|arg
condition|)
block|{
name|int
name|diff1
decl_stmt|,
name|diff2
decl_stmt|;
name|diff1
operator|=
name|arg
operator|-
name|speed_table
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|speed
expr_stmt|;
name|diff2
operator|=
name|speed_table
index|[
name|i
index|]
operator|.
name|speed
operator|-
name|arg
expr_stmt|;
if|if
condition|(
name|diff1
operator|<
name|diff2
condition|)
name|selected
operator|=
name|i
operator|-
literal|1
expr_stmt|;
else|else
name|selected
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|selected
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"ad1848: Can't find speed???\n"
argument_list|)
expr_stmt|;
name|selected
operator|=
literal|3
expr_stmt|;
block|}
name|devc
operator|->
name|speed
operator|=
name|speed_table
index|[
name|selected
index|]
operator|.
name|speed
expr_stmt|;
name|devc
operator|->
name|speed_bits
operator|=
name|speed_table
index|[
name|selected
index|]
operator|.
name|bits
expr_stmt|;
return|return
name|devc
operator|->
name|speed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_channels
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
name|arg
operator|!=
literal|1
operator|&&
name|arg
operator|!=
literal|2
condition|)
return|return
name|devc
operator|->
name|channels
return|;
name|devc
operator|->
name|channels
operator|=
name|arg
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_format
parameter_list|(
name|ad1848_info
modifier|*
name|devc
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
specifier|static
struct|struct
name|format_tbl
block|{
name|int
name|format
decl_stmt|;
name|u_char
name|bits
decl_stmt|;
block|}
name|format2bits
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
name|AFMT_MU_LAW
block|,
literal|1
block|}
block|,
block|{
name|AFMT_A_LAW
block|,
literal|3
block|}
block|,
block|{
name|AFMT_IMA_ADPCM
block|,
literal|5
block|}
block|,
block|{
name|AFMT_U8
block|,
literal|0
block|}
block|,
block|{
name|AFMT_S16_LE
block|,
literal|2
block|}
block|,
block|{
name|AFMT_S16_BE
block|,
literal|6
block|}
block|,
block|{
name|AFMT_S8
block|,
literal|0
block|}
block|,
block|{
name|AFMT_U16_LE
block|,
literal|0
block|}
block|,
block|{
name|AFMT_U16_BE
block|,
literal|0
block|}
block|}
struct|;
name|int
name|i
decl_stmt|,
name|n
init|=
sizeof|sizeof
argument_list|(
name|format2bits
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|format_tbl
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|arg
operator|&
name|ad_format_mask
index|[
name|devc
operator|->
name|mode
index|]
operator|)
condition|)
name|arg
operator|=
name|AFMT_U8
expr_stmt|;
name|devc
operator|->
name|audio_format
operator|=
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|format2bits
index|[
name|i
index|]
operator|.
name|format
operator|==
name|arg
condition|)
block|{
if|if
condition|(
operator|(
name|devc
operator|->
name|format_bits
operator|=
name|format2bits
index|[
name|i
index|]
operator|.
name|bits
operator|)
operator|==
literal|0
condition|)
return|return
name|devc
operator|->
name|audio_format
operator|=
name|AFMT_U8
return|;
comment|/* Was not supported */
return|return
name|arg
return|;
block|}
comment|/* Still hanging here. Something must be terribly wrong */
name|devc
operator|->
name|format_bits
operator|=
literal|0
expr_stmt|;
return|return
name|devc
operator|->
name|audio_format
operator|=
name|AFMT_U8
return|;
block|}
end_function

begin_comment
comment|/* XXX check what is arg,  (int) or *(int *) lr970705 */
end_comment

begin_function
specifier|static
name|int
name|ad1848_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|ioctl_arg
name|arg
parameter_list|,
name|int
name|local
parameter_list|)
block|{
name|ad1848_info
modifier|*
name|devc
init|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SOUND_PCM_WRITE_RATE
case|:
if|if
condition|(
name|local
condition|)
return|return
name|set_speed
argument_list|(
name|devc
argument_list|,
operator|(
name|int
operator|)
name|arg
argument_list|)
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|set_speed
argument_list|(
name|devc
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
argument_list|)
return|;
case|case
name|SOUND_PCM_READ_RATE
case|:
if|if
condition|(
name|local
condition|)
return|return
name|devc
operator|->
name|speed
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|devc
operator|->
name|speed
return|;
case|case
name|SNDCTL_DSP_STEREO
case|:
if|if
condition|(
name|local
condition|)
return|return
name|set_channels
argument_list|(
name|devc
argument_list|,
operator|(
name|int
operator|)
name|arg
operator|+
literal|1
argument_list|)
operator|-
literal|1
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|set_channels
argument_list|(
name|devc
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
operator|+
literal|1
argument_list|)
operator|-
literal|1
return|;
case|case
name|SOUND_PCM_WRITE_CHANNELS
case|:
if|if
condition|(
name|local
condition|)
return|return
name|set_channels
argument_list|(
name|devc
argument_list|,
operator|(
name|int
operator|)
name|arg
argument_list|)
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|set_channels
argument_list|(
name|devc
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
argument_list|)
return|;
case|case
name|SOUND_PCM_READ_CHANNELS
case|:
if|if
condition|(
name|local
condition|)
return|return
name|devc
operator|->
name|channels
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|devc
operator|->
name|channels
return|;
case|case
name|SNDCTL_DSP_SAMPLESIZE
case|:
if|if
condition|(
name|local
condition|)
return|return
name|set_format
argument_list|(
name|devc
argument_list|,
operator|(
name|int
operator|)
name|arg
argument_list|)
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|set_format
argument_list|(
name|devc
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
argument_list|)
return|;
case|case
name|SOUND_PCM_READ_BITS
case|:
if|if
condition|(
name|local
condition|)
return|return
name|devc
operator|->
name|audio_format
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|devc
operator|->
name|audio_format
return|;
case|case
name|FIOASYNC
case|:
if|if
condition|(
name|local
condition|)
return|return
literal|1
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|1
return|;
case|case
name|FIONBIO
case|:
if|if
condition|(
name|local
condition|)
return|return
literal|1
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|1
return|;
default|default:
empty_stmt|;
block|}
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad1848_output_block
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_long
name|buf
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|intrflag
parameter_list|,
name|int
name|dma_restart
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|,
name|cnt
decl_stmt|;
name|ad1848_info
modifier|*
name|devc
init|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
decl_stmt|;
name|cnt
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|audio_format
operator|==
name|AFMT_IMA_ADPCM
condition|)
block|{
name|cnt
operator|/=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|devc
operator|->
name|audio_format
operator|&
operator|(
name|AFMT_S16_LE
operator||
name|AFMT_S16_BE
operator|)
condition|)
comment|/* 16 bit data */
name|cnt
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|devc
operator|->
name|channels
operator|>
literal|1
condition|)
name|cnt
operator|>>=
literal|1
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
name|mute_flag
condition|)
name|ad_unmute
argument_list|(
name|devc
argument_list|)
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|irq_mode
operator|&
name|PCM_ENABLE_OUTPUT
operator|&&
name|audio_devs
index|[
name|dev
index|]
operator|->
name|flags
operator|&
name|DMA_AUTOMODE
operator|&&
name|intrflag
operator|&&
name|cnt
operator|==
name|devc
operator|->
name|xfer_count
condition|)
block|{
name|devc
operator|->
name|irq_mode
operator||=
name|PCM_ENABLE_OUTPUT
expr_stmt|;
name|devc
operator|->
name|intr_active
operator|=
literal|1
expr_stmt|;
block|}
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|dma_restart
condition|)
block|{
name|DMAbuf_start_dma
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
name|count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|15
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|cnt
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|14
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cnt
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|devc
operator|->
name|xfer_count
operator|=
name|cnt
expr_stmt|;
name|devc
operator|->
name|irq_mode
operator||=
name|PCM_ENABLE_OUTPUT
expr_stmt|;
name|devc
operator|->
name|intr_active
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad1848_start_input
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_long
name|buf
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|intrflag
parameter_list|,
name|int
name|dma_restart
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|,
name|cnt
decl_stmt|;
name|ad1848_info
modifier|*
name|devc
init|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
decl_stmt|;
name|cnt
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|audio_format
operator|==
name|AFMT_IMA_ADPCM
condition|)
name|cnt
operator|/=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|devc
operator|->
name|audio_format
operator|&
operator|(
name|AFMT_S16_LE
operator||
name|AFMT_S16_BE
operator|)
condition|)
comment|/* 16 bit data */
name|cnt
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|channels
operator|>
literal|1
condition|)
name|cnt
operator|>>=
literal|1
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|irq_mode
operator|&
name|PCM_ENABLE_INPUT
operator|&&
name|audio_devs
index|[
name|dev
index|]
operator|->
name|flags
operator|&
name|DMA_AUTOMODE
operator|&&
name|intrflag
operator|&&
name|cnt
operator|==
name|devc
operator|->
name|xfer_count
condition|)
block|{
name|devc
operator|->
name|irq_mode
operator||=
name|PCM_ENABLE_INPUT
expr_stmt|;
name|devc
operator|->
name|intr_active
operator|=
literal|1
expr_stmt|;
return|return;
comment|/* Auto DMA mode on. No need to react */
block|}
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|dma_restart
condition|)
block|{
comment|/* ad1848_halt (dev); */
name|DMAbuf_start_dma
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devc
operator|->
name|mode
operator|==
name|MD_1848
operator|||
operator|!
name|devc
operator|->
name|dual_dma
condition|)
block|{
comment|/* Single DMA chan. mode */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|15
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|cnt
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|14
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cnt
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Dual DMA channel mode */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|31
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|cnt
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|30
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|cnt
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ad_write (devc, 9, ad_read (devc, 9) | 0x02); */
comment|/* Capture enable */
name|ad_unmute
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|devc
operator|->
name|xfer_count
operator|=
name|cnt
expr_stmt|;
name|devc
operator|->
name|irq_mode
operator||=
name|PCM_ENABLE_INPUT
expr_stmt|;
name|devc
operator|->
name|intr_active
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ad1848_prepare_for_IO
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|bsize
parameter_list|,
name|int
name|bcount
parameter_list|)
block|{
name|int
name|timeout
decl_stmt|;
name|u_char
name|fs
decl_stmt|,
name|old_fs
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|ad1848_info
modifier|*
name|devc
init|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
decl_stmt|;
if|if
condition|(
name|devc
operator|->
name|irq_mode
condition|)
return|return
literal|0
return|;
name|fs
operator|=
name|devc
operator|->
name|speed_bits
operator||
operator|(
name|devc
operator|->
name|format_bits
operator|<<
literal|5
operator|)
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|channels
operator|>
literal|1
condition|)
name|fs
operator||=
literal|0x10
expr_stmt|;
name|old_fs
operator|=
name|fs
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|mode
operator|==
name|MD_1845
condition|)
block|{
comment|/* Use alternate speed select regs */
name|fs
operator|&=
literal|0xf0
expr_stmt|;
comment|/* Mask off the rate select bits */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|22
argument_list|,
operator|(
name|devc
operator|->
name|speed
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Speed MSB */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|23
argument_list|,
name|devc
operator|->
name|speed
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Speed LSB */
block|}
name|ad_enter_MCE
argument_list|(
name|devc
argument_list|)
expr_stmt|;
comment|/* Enables changes to the format select reg */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|8
argument_list|,
name|fs
argument_list|)
expr_stmt|;
comment|/*      * Write to I8 starts resyncronization. Wait until it completes.      */
name|AD_WAIT_INIT
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/*      * If mode == 2 (CS4231), set I28 also. It's the capture format      * register.      */
if|if
condition|(
name|devc
operator|->
name|mode
operator|!=
name|MD_1848
condition|)
block|{
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|28
argument_list|,
name|fs
argument_list|)
expr_stmt|;
comment|/* 	 * Write to I28 starts resyncronization. Wait until it completes. 	 */
name|AD_WAIT_INIT
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|,
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|)
operator|&
operator|~
literal|0x08
argument_list|)
expr_stmt|;
name|ad_leave_MCE
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|devc
operator|->
name|xfer_count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_SEQUENCER
if|if
condition|(
name|dev
operator|==
name|timer_installed
operator|&&
name|devc
operator|->
name|timer_running
condition|)
if|if
condition|(
operator|(
name|fs
operator|&
literal|0x01
operator|)
operator|!=
operator|(
name|old_fs
operator|&
literal|0x01
operator|)
condition|)
block|{
name|ad1848_tmr_reprogram
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad1848_reset
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|ad1848_halt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad1848_halt
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|ad1848_info
modifier|*
name|devc
init|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|ad_mute
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|,
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|)
operator|&
operator|~
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Stop DMA */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|14
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear DMA counter */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear DMA counter */
if|if
condition|(
name|devc
operator|->
name|mode
operator|!=
name|MD_1848
condition|)
block|{
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|30
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear DMA counter */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|31
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear DMA counter */
block|}
for|for
control|(
name|timeout
operator|=
literal|0
init|;
name|timeout
operator|<
literal|1000
operator|&&
operator|!
operator|(
name|inb
argument_list|(
name|io_Status
argument_list|(
name|devc
argument_list|)
argument_list|)
operator|&
literal|0x01
operator|)
condition|;
name|timeout
operator|++
control|)
empty_stmt|;
comment|/* Wait for interrupt */
name|outb
argument_list|(
name|io_Status
argument_list|(
name|devc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear interrupt status */
name|devc
operator|->
name|irq_mode
operator|=
literal|0
expr_stmt|;
comment|/* DMAbuf_reset_dma (dev); */
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad1848_halt_input
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|ad1848_info
modifier|*
name|devc
init|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|u_char
name|playing
decl_stmt|;
if|if
condition|(
name|devc
operator|->
name|mode
operator|==
name|MD_1848
condition|)
block|{
name|ad1848_halt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
name|playing
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|playing
operator|&
literal|0x2
operator|)
condition|)
return|return;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|ad_mute
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|,
name|playing
operator|&
operator|~
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Stop capture */
name|outb
argument_list|(
name|io_Status
argument_list|(
name|devc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear interrupt status */
name|outb
argument_list|(
name|io_Status
argument_list|(
name|devc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear interrupt status */
name|devc
operator|->
name|irq_mode
operator|&=
operator|~
name|PCM_ENABLE_INPUT
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad1848_halt_output
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|ad1848_info
modifier|*
name|devc
init|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|u_char
name|playing
decl_stmt|;
name|playing
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|playing
operator|&
literal|0x1
operator|)
condition|)
block|{
name|devc
operator|->
name|irq_mode
operator|&=
operator|~
name|PCM_ENABLE_OUTPUT
expr_stmt|;
return|return;
block|}
comment|/* IwaveStopDma(PLAYBACK);  */
if|if
condition|(
name|devc
operator|->
name|mode
operator|==
name|MD_1848
condition|)
block|{
name|ad1848_halt
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* ad_mute (devc);  */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|,
name|playing
operator|&
operator|~
literal|0x1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|io_Status
argument_list|(
name|devc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear interrupt status */
comment|/*      * ad_write (devc, 15,0); ad_write (devc, 14,0);      */
name|devc
operator|->
name|irq_mode
operator|&=
operator|~
name|PCM_ENABLE_OUTPUT
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad1848_trigger
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|ad1848_info
modifier|*
name|devc
init|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|u_char
name|tmp
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|state
operator|&=
name|devc
operator|->
name|irq_mode
expr_stmt|;
name|tmp
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|)
operator|&
operator|~
literal|0x03
expr_stmt|;
if|if
condition|(
name|state
operator|&
name|PCM_ENABLE_INPUT
condition|)
name|tmp
operator||=
literal|0x02
expr_stmt|;
if|if
condition|(
name|state
operator|&
name|PCM_ENABLE_OUTPUT
condition|)
block|{
name|tmp
operator||=
literal|0x01
expr_stmt|;
block|}
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ad1848_detect
parameter_list|(
name|int
name|io_base
parameter_list|,
name|int
modifier|*
name|ad_flags
parameter_list|,
name|sound_os_info
modifier|*
name|osp
parameter_list|)
block|{
specifier|static
name|int
name|last_probe_addr
init|=
literal|0
decl_stmt|,
name|last_result
init|=
literal|0
decl_stmt|;
comment|/* to avoid multiple probes*/
name|int
name|i
decl_stmt|;
name|ad1848_info
modifier|*
name|devc
init|=
operator|&
name|dev_info
index|[
name|nr_ad1848_devs
index|]
decl_stmt|;
name|u_char
name|tmp
decl_stmt|,
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_detect(%x)\n"
argument_list|,
name|io_base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_base
operator|==
name|last_probe_addr
condition|)
return|return
name|last_result
return|;
else|else
block|{
name|last_result
operator|=
literal|0
expr_stmt|;
comment|/* default value for detect */
name|last_probe_addr
operator|=
name|io_base
expr_stmt|;
block|}
if|if
condition|(
name|ad_flags
condition|)
operator|*
name|ad_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nr_ad1848_devs
operator|>=
name|MAX_AUDIO_DEV
condition|)
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848 detect error - step 0\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|devc
operator|->
name|base
operator|=
name|io_base
expr_stmt|;
name|devc
operator|->
name|irq_ok
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|timer_running
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|MCE_bit
operator|=
literal|0x40
expr_stmt|;
name|devc
operator|->
name|irq
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|opened
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|chip_name
operator|=
literal|"AD1848"
expr_stmt|;
name|devc
operator|->
name|mode
operator|=
name|MD_1848
expr_stmt|;
comment|/* AD1848 or CS4248 */
name|devc
operator|->
name|osp
operator|=
name|osp
expr_stmt|;
comment|/*      * Check that the I/O address is in use.      *       * The bit 0x80 of the base I/O port is known to be 0 after the chip has      * performed it's power on initialization. Just assume this has      * happened before the OS is starting.      *       * If the I/O address is unused, it typically returns 0xff.      */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_detect() - step A\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|devc
operator|->
name|base
argument_list|)
operator|&
literal|0x80
operator|)
operator|!=
literal|0x00
condition|)
block|{
comment|/* Not a AD1848 */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848 detect error - step A,"
literal|" inb(base) = 0x%02x, want 0XXX.XXXX\n"
argument_list|,
name|inb
argument_list|(
name|devc
operator|->
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*      * Test if it's possible to change contents of the indirect      * registers. Registers 0 and 1 are ADC volume registers. The bit      * 0x10 is read only so try to avoid using it.      */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_detect() - step B, test indirect register\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|0
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|1
argument_list|,
literal|0x45
argument_list|)
expr_stmt|;
comment|/* 0x55 with bit 0x10 clear */
name|tmp1
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|!=
literal|0xaa
operator|||
name|tmp2
operator|!=
literal|0x45
condition|)
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848 detect error - step B (0x%02x/0x%02x) want 0xaa/0x45\n"
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_detect() - step C\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|0
argument_list|,
literal|0x45
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|1
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp2
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|!=
literal|0x45
operator|||
name|tmp2
operator|!=
literal|0xaa
condition|)
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848 detect error - step C (%x/%x)\n"
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*      * The indirect register I12 has some read only bits. Lets try to      * change them.      */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_detect() - step D, last 4 bits of I12 readonly\n"
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|12
argument_list|,
operator|(
operator|~
name|tmp
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
literal|0x0f
operator|)
operator|!=
operator|(
name|tmp1
operator|&
literal|0x0f
operator|)
condition|)
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848 detect error - step D, I12 (0x%02x was 0x%02x)\n"
argument_list|,
name|tmp1
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*      * NOTE! Last 4 bits of the reg I12 tell the chip revision.      *	0x01=RevB      *  0x0A=RevC. also CS4231/CS4231A and OPTi931      */
comment|/*      * The original AD1848/CS4248 has just 15 indirect registers. This      * means that I0 and I16 should return the same value (etc.). Ensure      * that the Mode2 enable bit of I12 is 0. Otherwise this test fails      * with CS4231.      */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_detect() - step F\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mode2=disabled */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|tmp1
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
operator|(
name|tmp2
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
name|i
operator|+
literal|16
argument_list|)
operator|)
condition|)
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848 detect warning - step F(I%d/0x%02x/0x%02x)\n"
argument_list|,
name|i
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	     * note - this seems to fail on the 4232 on I11. So we just break 	     * rather than fail. 	     */
break|break ;
comment|/* return 0; */
block|}
comment|/*      * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit      * (0x40). The bit 0x80 is always 1 in CS4248 and CS4231.      *      * On the OPTi931, however, I12 is readonly and only contains the      * chip revision ID (as in the CS4231A). The upper bits return 0.      */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_detect() - step G\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|12
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Set mode2, clear 0x80 */
name|tmp1
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|ad_flags
condition|)
operator|*
name|ad_flags
operator||=
name|AD_F_CS4248
expr_stmt|;
name|devc
operator|->
name|chip_name
operator|=
literal|"CS4248"
expr_stmt|;
comment|/* Our best knowledge just now */
block|}
if|if
condition|(
operator|(
name|tmp1
operator|&
literal|0xf0
operator|)
operator|==
literal|0x00
condition|)
block|{
name|printf
argument_list|(
literal|"this should be an OPTi931\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tmp1
operator|&
literal|0xc0
operator|)
operator|==
literal|0xC0
condition|)
block|{
comment|/* 	 * The 4231 has bit7=1 always, and bit6 we just set to 1. 	 * We want to check that this is really a CS4231 	 * Verify that setting I0 doesn't change I16. 	 */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_detect() - step H\n"
argument_list|)
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set I16 to known value */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|0
argument_list|,
literal|0x45
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp1
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|16
argument_list|)
operator|)
operator|!=
literal|0x45
condition|)
block|{
comment|/* No change -> CS4231? */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|0
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp1
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
literal|0xaa
condition|)
block|{
comment|/* Rotten bits? */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848 detect error - step H(%x)\n"
argument_list|,
name|tmp1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	     * Verify that some bits of I25 are read only. 	     */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_detect() - step I\n"
argument_list|)
argument_list|)
expr_stmt|;
name|tmp1
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|25
argument_list|)
expr_stmt|;
comment|/* Original bits */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|25
argument_list|,
operator|~
name|tmp1
argument_list|)
expr_stmt|;
comment|/* Invert all bits */
if|if
condition|(
operator|(
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|25
argument_list|)
operator|&
literal|0xe7
operator|)
operator|==
operator|(
name|tmp1
operator|&
literal|0xe7
operator|)
condition|)
block|{
name|int
name|id
decl_stmt|;
comment|/* 		 * It's at least CS4231 		 */
name|devc
operator|->
name|chip_name
operator|=
literal|"CS4231"
expr_stmt|;
name|devc
operator|->
name|mode
operator|=
name|MD_4231
expr_stmt|;
comment|/* 		 * It could be an AD1845 or CS4231A as well. 		 * CS4231 and AD1845 report the same revision info in I25 		 * while the CS4231A reports different. 		 */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_detect() - step I\n"
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|25
argument_list|)
operator|&
literal|0xe7
expr_stmt|;
comment|/* 		 * b7-b5 = version number; 		 *	100 : all CS4231 		 *	101 : CS4231A 		 *       		 * b2-b0 = chip id; 		 */
switch|switch
condition|(
name|id
condition|)
block|{
case|case
literal|0xa0
case|:
name|devc
operator|->
name|chip_name
operator|=
literal|"CS4231A"
expr_stmt|;
name|devc
operator|->
name|mode
operator|=
name|MD_4231A
expr_stmt|;
break|break;
case|case
literal|0xa2
case|:
name|devc
operator|->
name|chip_name
operator|=
literal|"CS4232"
expr_stmt|;
name|devc
operator|->
name|mode
operator|=
name|MD_4231A
expr_stmt|;
break|break;
case|case
literal|0xb2
case|:
comment|/* strange: the 4231 data sheet says b4-b3 are XX 		     * so this should be the same as 0xa2 		     */
name|devc
operator|->
name|chip_name
operator|=
literal|"CS4232A"
expr_stmt|;
name|devc
operator|->
name|mode
operator|=
name|MD_4231A
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
comment|/* 		     * It must be a CS4231 or AD1845. The register I23 		     * of CS4231 is undefined and it appears to be read 		     * only. AD1845 uses I23 for setting sample rate. 		     * Assume the chip is AD1845 if I23 is changeable. 		     */
name|tmp
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|23
argument_list|,
operator|~
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|23
argument_list|)
operator|!=
name|tmp
condition|)
block|{
comment|/* AD1845 ? */
name|devc
operator|->
name|chip_name
operator|=
literal|"AD1845"
expr_stmt|;
name|devc
operator|->
name|mode
operator|=
name|MD_1845
expr_stmt|;
block|}
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|23
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Restore */
break|break;
case|case
literal|0x83
case|:
comment|/* CS4236 */
case|case
literal|0x03
case|:
comment|/* Mutant CS4236 on Intel PR440fx board */
name|devc
operator|->
name|chip_name
operator|=
literal|"CS4236"
expr_stmt|;
name|devc
operator|->
name|mode
operator|=
name|MD_4236
expr_stmt|;
break|break;
default|default:
comment|/* Assume CS4231 */
name|printf
argument_list|(
literal|"unknown id 0x%02x, assuming CS4231\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|devc
operator|->
name|mode
operator|=
name|MD_4231
expr_stmt|;
block|}
block|}
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|25
argument_list|,
name|tmp1
argument_list|)
expr_stmt|;
comment|/* Restore bits */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_detect() - step K\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_detect() - step L\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad_flags
condition|)
block|{
if|if
condition|(
name|devc
operator|->
name|mode
operator|!=
name|MD_1848
condition|)
operator|*
name|ad_flags
operator||=
name|AD_F_CS4231
expr_stmt|;
block|}
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"ad1848_detect() - Detected OK\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|last_result
operator|=
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ad1848_init
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|io_base
parameter_list|,
name|int
name|irq
parameter_list|,
name|int
name|dma_playback
parameter_list|,
name|int
name|dma_capture
parameter_list|,
name|int
name|share_dma
parameter_list|,
name|sound_os_info
modifier|*
name|osp
parameter_list|)
block|{
comment|/*      * NOTE! If irq< 0, there is another driver which has allocated the      * IRQ so that this driver doesn't need to allocate/deallocate it.      * The actually used IRQ is ABS(irq).      */
comment|/*      * Initial values for the indirect registers of CS4248/AD1848.      */
specifier|static
name|int
name|init_values
index|[]
init|=
block|{
literal|0xa8
block|,
comment|/* MIXOUTL: src:mic, +20dB, gain +12dB */
literal|0xa8
block|,
comment|/* MIXOUTR: src:mic, +20dB, gain +12dB */
literal|0x08
block|,
comment|/* CDL Input: mute, +6dB	*/
literal|0x08
block|,
comment|/* CDR Input: mute, +6dB        */
literal|0x08
block|,
comment|/* FML Input: mute, +6dB        */
literal|0x08
block|,
comment|/* FMR Input: mute, +6dB        */
literal|0x80
block|,
comment|/* DAC-L Input: enable, 0dB	*/
literal|0x80
block|,
comment|/* DAC-R Input: enable, 0dB     */
comment|/* 0xa8, 0xa8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, */
literal|0x00
block|,
comment|/* 8bit, lin, uns, mono, 8KHz	*/
literal|0x0c
block|,
comment|/* dma-cap, dma-pb, autocal, single dma, disable cap/pb */
literal|0x02
block|,
comment|/* int enable */
literal|0x00
block|,
comment|/* clear error status */
literal|0x8a
block|,
comment|/* rev. id (low bytes readonly) */
literal|0x00
block|,
literal|0x00
block|,
comment|/* playback upper base count */
literal|0x00
block|,
comment|/* playback lower base count */
comment|/* Positions 16 to 31 just for CS4231 and newer devices */
comment|/* I16-I17: alt. feature enable on the 4231, but AUXL Input 	 * on the OPTi931 (where the features are set elsewhere 	 */
literal|0x81
block|,
literal|0x00
block|,
literal|0x10
block|,
literal|0x10
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|my_dev
decl_stmt|;
name|ad1848_info
modifier|*
name|devc
init|=
operator|&
name|dev_info
index|[
name|nr_ad1848_devs
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ad1848_detect
argument_list|(
name|io_base
argument_list|,
name|NULL
argument_list|,
name|osp
argument_list|)
condition|)
return|return;
name|devc
operator|->
name|irq
operator|=
operator|(
name|irq
operator|>
literal|0
operator|)
condition|?
name|irq
else|:
literal|0
expr_stmt|;
name|devc
operator|->
name|opened
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|timer_ticks
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|osp
operator|=
name|osp
expr_stmt|;
if|if
condition|(
name|nr_ad1848_devs
operator|!=
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ad1848_pcm_operations
index|[
literal|0
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ad1848_pcm_operations
index|[
name|nr_ad1848_devs
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|audio_operations
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|ad_write
argument_list|(
name|devc
argument_list|,
name|i
argument_list|,
name|init_values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ad_mute
argument_list|(
name|devc
argument_list|)
expr_stmt|;
comment|/* Initialize some variables */
name|ad_unmute
argument_list|(
name|devc
argument_list|)
expr_stmt|;
comment|/* Leave it unmuted now */
if|if
condition|(
name|devc
operator|->
name|mode
operator|>
name|MD_1848
condition|)
block|{
if|if
condition|(
name|dma_capture
operator|==
name|dma_playback
operator|||
name|dma_capture
operator|==
operator|-
literal|1
operator|||
name|dma_playback
operator|==
operator|-
literal|1
condition|)
block|{
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|,
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|)
operator||
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Single DMA mode */
name|ad1848_pcm_operations
index|[
name|nr_ad1848_devs
index|]
operator|.
name|flags
operator|&=
operator|~
name|DMA_DUPLEX
expr_stmt|;
block|}
else|else
block|{
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|,
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|)
operator|&
operator|~
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Dual DMA mode */
name|ad1848_pcm_operations
index|[
name|nr_ad1848_devs
index|]
operator|.
name|flags
operator||=
name|DMA_DUPLEX
expr_stmt|;
block|}
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|12
argument_list|,
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|12
argument_list|)
operator||
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Mode2 = enabled */
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|ad_write
argument_list|(
name|devc
argument_list|,
name|i
argument_list|,
name|init_values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|mode
operator|==
name|MD_4231A
condition|)
block|{
comment|/* Enable full * calibration */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|,
name|init_values
index|[
literal|9
index|]
operator||
literal|0x18
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devc
operator|->
name|mode
operator|==
name|MD_1845
condition|)
block|{
comment|/* Alternate freq select enabled */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|27
argument_list|,
name|init_values
index|[
literal|27
index|]
operator||
literal|0x08
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ad1848_pcm_operations
index|[
name|nr_ad1848_devs
index|]
operator|.
name|flags
operator|&=
operator|~
name|DMA_DUPLEX
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|,
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|9
argument_list|)
operator||
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Single DMA mode */
block|}
name|outb
argument_list|(
name|io_Status
argument_list|(
name|devc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear pending interrupts */
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|sprintf
argument_list|(
name|ad1848_pcm_operations
index|[
name|nr_ad1848_devs
index|]
operator|.
name|name
argument_list|,
literal|"%s (%s)"
argument_list|,
name|name
argument_list|,
name|devc
operator|->
name|chip_name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|ad1848_pcm_operations
index|[
name|nr_ad1848_devs
index|]
operator|.
name|name
argument_list|,
literal|"Generic audio codec (%s)"
argument_list|,
name|devc
operator|->
name|chip_name
argument_list|)
expr_stmt|;
name|conf_printf2
argument_list|(
name|ad1848_pcm_operations
index|[
name|nr_ad1848_devs
index|]
operator|.
name|name
argument_list|,
name|devc
operator|->
name|base
argument_list|,
name|devc
operator|->
name|irq
argument_list|,
name|dma_playback
argument_list|,
name|dma_capture
argument_list|)
expr_stmt|;
comment|/* ad1848_pcm_operations[nr_ad1848_devs].flags |= DMA_AUTOMODE ; */
if|if
condition|(
name|num_audiodevs
operator|<
name|MAX_AUDIO_DEV
condition|)
block|{
name|audio_devs
index|[
name|my_dev
operator|=
name|num_audiodevs
operator|++
index|]
operator|=
operator|&
name|ad1848_pcm_operations
index|[
name|nr_ad1848_devs
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|>
literal|0
condition|)
block|{
name|audio_devs
index|[
name|my_dev
index|]
operator|->
name|devc
operator|=
name|devc
expr_stmt|;
name|irq2dev
index|[
name|irq
index|]
operator|=
name|my_dev
expr_stmt|;
if|if
condition|(
name|snd_set_irq_handler
argument_list|(
name|devc
operator|->
name|irq
argument_list|,
name|ad1848_interrupt
argument_list|,
name|devc
operator|->
name|osp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ad1848: IRQ in use\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NO_IRQ_TEST
if|if
condition|(
name|devc
operator|->
name|mode
operator|!=
name|MD_1848
condition|)
block|{
name|int
name|x
decl_stmt|;
name|u_char
name|tmp
init|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|devc
operator|->
name|timer_ticks
operator|=
literal|0
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|21
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Timer msb */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|20
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Timer lsb */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|16
argument_list|,
name|tmp
operator||
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Enable timer */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|100000
operator|&&
name|devc
operator|->
name|timer_ticks
operator|==
literal|0
condition|;
name|x
operator|++
control|)
empty_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|16
argument_list|,
name|tmp
operator|&
operator|~
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Disable timer */
if|if
condition|(
name|devc
operator|->
name|timer_ticks
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"[IRQ conflict???]"
argument_list|)
expr_stmt|;
else|else
name|devc
operator|->
name|irq_ok
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|devc
operator|->
name|irq_ok
operator|=
literal|1
expr_stmt|;
comment|/* Couldn't test. assume it's OK */
else|#
directive|else
name|devc
operator|->
name|irq_ok
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|irq
operator|<
literal|0
condition|)
name|irq2dev
index|[
operator|-
name|irq
index|]
operator|=
name|devc
operator|->
name|dev_no
operator|=
name|my_dev
expr_stmt|;
name|audio_devs
index|[
name|my_dev
index|]
operator|->
name|otherside
operator|=
operator|-
literal|1
expr_stmt|;
name|audio_devs
index|[
name|my_dev
index|]
operator|->
name|flags
operator||=
name|DMA_AUTOMODE
expr_stmt|;
name|audio_devs
index|[
name|my_dev
index|]
operator|->
name|dmachan1
operator|=
name|dma_playback
expr_stmt|;
name|audio_devs
index|[
name|my_dev
index|]
operator|->
name|dmachan2
operator|=
name|dma_capture
expr_stmt|;
name|audio_devs
index|[
name|my_dev
index|]
operator|->
name|buffsize
operator|=
name|DSP_BUFFSIZE
expr_stmt|;
name|audio_devs
index|[
name|my_dev
index|]
operator|->
name|devc
operator|=
name|devc
expr_stmt|;
name|audio_devs
index|[
name|my_dev
index|]
operator|->
name|format_mask
operator|=
name|ad_format_mask
index|[
name|devc
operator|->
name|mode
index|]
expr_stmt|;
name|nr_ad1848_devs
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_SEQUENCER
if|if
condition|(
name|devc
operator|->
name|mode
operator|!=
name|MD_1848
operator|&&
name|devc
operator|->
name|irq_ok
condition|)
name|ad1848_tmr_install
argument_list|(
name|my_dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Toggle the MCE bit. It completes the initialization phase. 	 */
name|ad_enter_MCE
argument_list|(
name|devc
argument_list|)
expr_stmt|;
comment|/* In case the bit was off */
name|ad_leave_MCE
argument_list|(
name|devc
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_mixers
operator|<
name|MAX_MIXER_DEV
condition|)
block|{
name|mixer2codec
index|[
name|num_mixers
index|]
operator|=
name|my_dev
operator|+
literal|1
expr_stmt|;
name|audio_devs
index|[
name|my_dev
index|]
operator|->
name|mixer_dev
operator|=
name|num_mixers
expr_stmt|;
name|mixer_devs
index|[
name|num_mixers
operator|++
index|]
operator|=
operator|&
name|ad1848_mixer_operations
expr_stmt|;
name|ad1848_mixer_reset
argument_list|(
name|devc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"AD1848: Too many PCM devices available\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ad1848_interrupt
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|u_char
name|status
decl_stmt|;
name|ad1848_info
modifier|*
name|devc
decl_stmt|;
name|int
name|dev
decl_stmt|;
if|if
condition|(
name|irq
operator|<
literal|0
operator|||
name|irq
operator|>
literal|15
condition|)
name|dev
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|dev
operator|=
name|irq2dev
index|[
name|irq
index|]
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_audiodevs
condition|)
block|{
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<
literal|17
condition|;
name|irq
operator|++
control|)
if|if
condition|(
name|irq2dev
index|[
name|irq
index|]
operator|!=
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|irq
operator|>
literal|15
condition|)
block|{
name|printf
argument_list|(
literal|"ad1848.c: Bogus interrupt %d\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return;
block|}
name|dev
operator|=
name|irq2dev
index|[
name|irq
index|]
expr_stmt|;
block|}
name|devc
operator|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
expr_stmt|;
name|status
operator|=
name|inb
argument_list|(
name|io_Status
argument_list|(
name|devc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x01
condition|)
block|{
comment|/* we have an interrupt */
name|int
name|alt_stat
init|=
literal|0xff
decl_stmt|;
if|if
condition|(
name|devc
operator|->
name|mode
operator|!=
name|MD_1848
condition|)
block|{
comment|/* 	     * high-end devices have full-duplex dma and timer. 	     * the exact reason for the interrupt is in reg. I24. 	     * For old devices, we fake the interrupt bits, and 	     * determine the real reason basing on the device mode. 	     */
name|alt_stat
operator|=
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt_stat
operator|&
literal|0x40
condition|)
block|{
comment|/* Timer interrupt */
name|devc
operator|->
name|timer_ticks
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_SEQUENCER
if|if
condition|(
name|timer_installed
operator|==
name|dev
operator|&&
name|devc
operator|->
name|timer_running
condition|)
name|sound_timer_interrupt
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|outb
argument_list|(
name|io_Status
argument_list|(
name|devc
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clear interrupt status */
if|if
condition|(
name|audio_devs
index|[
name|dev
index|]
operator|->
name|busy
condition|)
block|{
if|if
condition|(
name|devc
operator|->
name|irq_mode
operator|&
name|PCM_ENABLE_OUTPUT
operator|&&
name|alt_stat
operator|&
literal|0x10
condition|)
name|DMAbuf_outputintr
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|irq_mode
operator|&
name|PCM_ENABLE_INPUT
operator|&&
name|alt_stat
operator|&
literal|0x20
condition|)
name|DMAbuf_inputintr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Some extra code for the MS Sound System  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|amancio
end_ifdef

begin_function
name|void
name|check_opl3
parameter_list|(
name|int
name|base
parameter_list|,
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
if|if
condition|(
operator|!
name|opl3_detect
argument_list|(
name|base
argument_list|,
name|hw_config
operator|->
name|osp
argument_list|)
condition|)
return|return;
name|opl3_init
argument_list|(
literal|0
argument_list|,
name|base
argument_list|,
name|hw_config
operator|->
name|osp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * this is the probe routine. Note, it is not necessary to  * go through this for PnP devices, since they are already  * indentified precisely using their PnP id.  *  */
end_comment

begin_function
name|int
name|probe_mss
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|u_char
name|tmp
decl_stmt|;
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"Entered probe_mss(io 0x%x, type %d)\n"
argument_list|,
name|hw_config
operator|->
name|io_base
argument_list|,
name|hw_config
operator|->
name|card_subtype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw_config
operator|->
name|card_subtype
operator|==
literal|1
condition|)
block|{
comment|/* Has no IRQ/DMA registers */
comment|/* check_opl3(0x388, hw_config); */
goto|goto
name|probe_ms_end
goto|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_AEDSP16
argument_list|)
operator|&&
name|defined
argument_list|(
name|AEDSP16_MSS
argument_list|)
comment|/*      * Initialize Audio Excel DSP 16 to MSS: before any operation we must      * enable MSS I/O ports.      */
name|InitAEDSP16_MSS
argument_list|(
name|hw_config
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Check if the IO port returns valid signature. The original MS      * Sound system returns 0x04 while some cards (AudioTriX Pro for      * example) return 0x00 or 0x0f.      */
if|if
condition|(
operator|(
name|tmp
operator|=
name|inb
argument_list|(
name|hw_config
operator|->
name|io_base
operator|+
literal|3
argument_list|)
operator|)
operator|==
literal|0xff
condition|)
block|{
comment|/* Bus float */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"I/O address inactive (%x), force type 1\n"
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|hw_config
operator|->
name|card_subtype
operator|=
literal|1
expr_stmt|;
goto|goto
name|probe_ms_end
goto|;
block|}
if|if
condition|(
operator|(
name|tmp
operator|&
literal|0x3f
operator|)
operator|!=
literal|0x04
operator|&&
operator|(
name|tmp
operator|&
literal|0x3f
operator|)
operator|!=
literal|0x0f
operator|&&
operator|(
name|tmp
operator|&
literal|0x3f
operator|)
operator|!=
literal|0x00
condition|)
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"No MSS signature detected on port 0x%x (0x%x)\n"
argument_list|,
name|hw_config
operator|->
name|io_base
argument_list|,
name|inb
argument_list|(
name|hw_config
operator|->
name|io_base
operator|+
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|hw_config
operator|->
name|irq
operator|>
literal|11
condition|)
block|{
name|printf
argument_list|(
literal|"MSS: Bad IRQ %d\n"
argument_list|,
name|hw_config
operator|->
name|irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|hw_config
operator|->
name|dma
operator|!=
literal|0
operator|&&
name|hw_config
operator|->
name|dma
operator|!=
literal|1
operator|&&
name|hw_config
operator|->
name|dma
operator|!=
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"MSS: Bad DMA %d\n"
argument_list|,
name|hw_config
operator|->
name|dma
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*      * Check that DMA0 is not in use with a 8 bit board.      */
if|if
condition|(
name|hw_config
operator|->
name|dma
operator|==
literal|0
operator|&&
name|inb
argument_list|(
name|hw_config
operator|->
name|io_base
operator|+
literal|3
argument_list|)
operator|&
literal|0x80
condition|)
block|{
name|printf
argument_list|(
literal|"MSS: Can't use DMA0 with a 8 bit card/slot\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|hw_config
operator|->
name|irq
operator|>
literal|7
operator|&&
name|hw_config
operator|->
name|irq
operator|!=
literal|9
operator|&&
name|inb
argument_list|(
name|hw_config
operator|->
name|io_base
operator|+
literal|3
argument_list|)
operator|&
literal|0x80
condition|)
block|{
name|printf
argument_list|(
literal|"MSS: Can't use IRQ%d with a 8 bit card/slot\n"
argument_list|,
name|hw_config
operator|->
name|irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|probe_ms_end
label|:
return|return
name|ad1848_detect
argument_list|(
name|hw_config
operator|->
name|io_base
operator|+
literal|4
argument_list|,
name|NULL
argument_list|,
name|hw_config
operator|->
name|osp
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|attach_mss
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/*      * XXX do we really need to detect it again ? - lr970712      */
block|if (!ad1848_detect(hw_config->io_base + 4, NULL, hw_config->osp)) 	return ;
endif|#
directive|endif
if|if
condition|(
name|hw_config
operator|->
name|card_subtype
operator|==
literal|1
condition|)
block|{
comment|/* Has no IRQ/DMA registers */
name|ad1848_init
argument_list|(
literal|"MS Sound System1"
argument_list|,
name|hw_config
operator|->
name|io_base
operator|+
literal|4
argument_list|,
name|hw_config
operator|->
name|irq
argument_list|,
name|hw_config
operator|->
name|dma
argument_list|,
name|hw_config
operator|->
name|dma2
argument_list|,
literal|0
argument_list|,
name|hw_config
operator|->
name|osp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Set the IRQ and DMA addresses. 	 */
specifier|static
name|char
name|interrupt_bits
index|[
literal|12
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0x08
block|,
operator|-
literal|1
block|,
literal|0x10
block|,
literal|0x18
block|,
literal|0x20
block|}
decl_stmt|;
specifier|static
name|char
name|dma_bits
index|[
literal|4
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|}
decl_stmt|;
name|int
name|config_port
init|=
name|hw_config
operator|->
name|io_base
operator|+
literal|0
decl_stmt|;
name|int
name|version_port
init|=
name|hw_config
operator|->
name|io_base
operator|+
literal|3
decl_stmt|;
name|char
name|bits
init|=
name|interrupt_bits
index|[
name|hw_config
operator|->
name|irq
index|]
decl_stmt|;
if|if
condition|(
name|bits
operator|==
operator|-
literal|1
condition|)
return|return ;
name|outb
argument_list|(
name|config_port
argument_list|,
name|bits
operator||
literal|0x40
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|version_port
argument_list|)
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"[IRQ Conflict?]"
argument_list|)
expr_stmt|;
comment|/* Write IRQ+DMA setup */
name|outb
argument_list|(
name|config_port
argument_list|,
name|bits
operator||
name|dma_bits
index|[
name|hw_config
operator|->
name|dma
index|]
argument_list|)
expr_stmt|;
name|ad1848_init
argument_list|(
literal|"MS Sound System0"
argument_list|,
name|hw_config
operator|->
name|io_base
operator|+
literal|4
argument_list|,
name|hw_config
operator|->
name|irq
argument_list|,
name|hw_config
operator|->
name|dma
argument_list|,
name|hw_config
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
name|hw_config
operator|->
name|osp
argument_list|)
expr_stmt|;
block|}
return|return ;
block|}
end_function

begin_comment
comment|/*  * WSS compatible PnP codec support.  * XXX I doubt it works now - lr970712  */
end_comment

begin_function
name|int
name|probe_pnp_ad1848
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
return|return
name|ad1848_detect
argument_list|(
name|hw_config
operator|->
name|io_base
argument_list|,
name|NULL
argument_list|,
name|hw_config
operator|->
name|osp
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|attach_pnp_ad1848
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|ad1848_init
argument_list|(
name|hw_config
operator|->
name|name
argument_list|,
name|hw_config
operator|->
name|io_base
argument_list|,
name|hw_config
operator|->
name|irq
argument_list|,
name|hw_config
operator|->
name|dma
argument_list|,
name|hw_config
operator|->
name|dma2
argument_list|,
literal|0
argument_list|,
name|hw_config
operator|->
name|osp
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_SEQUENCER
end_ifdef

begin_comment
comment|/*  * Timer stuff (for /dev/music).  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|current_interval
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|u_int
name|ad1848_tmr_start
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int
name|usecs
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|ad1848_info
modifier|*
name|devc
init|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
decl_stmt|;
name|u_long
name|xtal_nsecs
decl_stmt|;
comment|/* nanoseconds per xtal oscillaror tick */
name|u_long
name|divider
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/*      * Length of the timer interval (in nanoseconds) depends on the      * selected crystal oscillator. Check this from bit 0x01 of I8.      *       * AD1845 has just one oscillator which has cycle time of 10.050 us      * (when a 24.576 MHz xtal oscillator is used).      *       * Convert requested interval to nanoseconds before computing the timer      * divider.      */
if|if
condition|(
name|devc
operator|->
name|mode
operator|==
name|MD_1845
condition|)
name|xtal_nsecs
operator|=
literal|10050
expr_stmt|;
elseif|else
if|if
condition|(
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|8
argument_list|)
operator|&
literal|0x01
condition|)
name|xtal_nsecs
operator|=
literal|9920
expr_stmt|;
else|else
name|xtal_nsecs
operator|=
literal|9969
expr_stmt|;
name|divider
operator|=
operator|(
name|usecs
operator|*
literal|1000
operator|+
name|xtal_nsecs
operator|/
literal|2
operator|)
operator|/
name|xtal_nsecs
expr_stmt|;
if|if
condition|(
name|divider
operator|<
literal|100
condition|)
comment|/* Don't allow shorter intervals than about 1ms */
name|divider
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|divider
operator|>
literal|65535
condition|)
comment|/* Overflow check */
name|divider
operator|=
literal|65535
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|21
argument_list|,
operator|(
name|divider
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Set upper bits */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|20
argument_list|,
name|divider
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Set lower bits */
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|16
argument_list|,
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|16
argument_list|)
operator||
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Start the timer */
name|devc
operator|->
name|timer_running
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|current_interval
operator|=
operator|(
name|divider
operator|*
name|xtal_nsecs
operator|+
literal|500
operator|)
operator|/
literal|1000
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad1848_tmr_reprogram
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
comment|/*      * Audio driver has changed sampling rate so that a different xtal      * oscillator was selected. We have to reprogram the timer rate.      */
name|ad1848_tmr_start
argument_list|(
name|dev
argument_list|,
name|current_interval
argument_list|)
expr_stmt|;
name|sound_timer_syncinterval
argument_list|(
name|current_interval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad1848_tmr_disable
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|ad1848_info
modifier|*
name|devc
init|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|16
argument_list|,
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|16
argument_list|)
operator|&
operator|~
literal|0x40
argument_list|)
expr_stmt|;
name|devc
operator|->
name|timer_running
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ad1848_tmr_restart
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|ad1848_info
modifier|*
name|devc
init|=
operator|(
name|ad1848_info
operator|*
operator|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|devc
decl_stmt|;
if|if
condition|(
name|current_interval
operator|==
literal|0
condition|)
return|return;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|ad_write
argument_list|(
name|devc
argument_list|,
literal|16
argument_list|,
name|ad_read
argument_list|(
name|devc
argument_list|,
literal|16
argument_list|)
operator||
literal|0x40
argument_list|)
expr_stmt|;
name|devc
operator|->
name|timer_running
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|sound_lowlev_timer
name|ad1848_tmr
init|=
block|{
literal|0
block|,
name|ad1848_tmr_start
block|,
name|ad1848_tmr_disable
block|,
name|ad1848_tmr_restart
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ad1848_tmr_install
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
if|if
condition|(
name|timer_installed
operator|!=
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Don't install another timer */
name|timer_installed
operator|=
name|ad1848_tmr
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|sound_timer_init
argument_list|(
operator|&
name|ad1848_tmr
argument_list|,
name|audio_devs
index|[
name|dev
index|]
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

