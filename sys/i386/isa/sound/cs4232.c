begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/cs4232.c  *   * The low level driver for Crystal CS4232 based cards. The CS4232 is a PnP  * compatible chip which contains a CS4231A codec, SB emulation, a MPU401  * compatible MIDI port, joystick and synthesizer and IDE CD-ROM interfaces.  * This is just a temporary driver until full PnP support gets inplemented.  * Just the WSS codec, FM synth and the MIDI ports are supported. Other  * interfaces are left uninitialized.  *   * Copyright by Hannu Savolainen 1995  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/sound/sound_config.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_CS4232
argument_list|)
end_if

begin_define
define|#
directive|define
name|KEY_PORT
value|0x279
end_define

begin_comment
comment|/* Same as LPT1 status port */
end_comment

begin_define
define|#
directive|define
name|CSN_NUM
value|0x99
end_define

begin_comment
comment|/* Just a random number */
end_comment

begin_define
define|#
directive|define
name|CS_OUT
parameter_list|(
name|a
parameter_list|)
value|outb( KEY_PORT,  a)
end_define

begin_define
define|#
directive|define
name|CS_OUT2
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|{CS_OUT(a);CS_OUT(b);}
end_define

begin_define
define|#
directive|define
name|CS_OUT3
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|{CS_OUT(a);CS_OUT(b);CS_OUT(c);}
end_define

begin_decl_stmt
specifier|static
name|int
name|mpu_base
init|=
literal|0
decl_stmt|,
name|mpu_irq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|probe_cs4232_mpu
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
comment|/*      * Just write down the config values.      */
name|mpu_base
operator|=
name|hw_config
operator|->
name|io_base
expr_stmt|;
name|mpu_irq
operator|=
name|hw_config
operator|->
name|irq
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|attach_cs4232_mpu
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{ }
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|crystal_key
index|[]
init|=
comment|/* A 32 byte magic key sequence */
block|{
literal|0x96
block|,
literal|0x35
block|,
literal|0x9a
block|,
literal|0xcd
block|,
literal|0xe6
block|,
literal|0xf3
block|,
literal|0x79
block|,
literal|0xbc
block|,
literal|0x5e
block|,
literal|0xaf
block|,
literal|0x57
block|,
literal|0x2b
block|,
literal|0x15
block|,
literal|0x8a
block|,
literal|0xc5
block|,
literal|0xe2
block|,
literal|0xf1
block|,
literal|0xf8
block|,
literal|0x7c
block|,
literal|0x3e
block|,
literal|0x9f
block|,
literal|0x4f
block|,
literal|0x27
block|,
literal|0x13
block|,
literal|0x09
block|,
literal|0x84
block|,
literal|0x42
block|,
literal|0xa1
block|,
literal|0xd0
block|,
literal|0x68
block|,
literal|0x34
block|,
literal|0x1a
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|probe_cs4232
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|base
init|=
name|hw_config
operator|->
name|io_base
decl_stmt|,
name|irq
init|=
name|hw_config
operator|->
name|irq
decl_stmt|;
name|int
name|dma1
init|=
name|hw_config
operator|->
name|dma
decl_stmt|,
name|dma2
init|=
name|hw_config
operator|->
name|dma2
decl_stmt|;
comment|/*      * Verify that the I/O port range is free.      */
if|if
condition|(
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"cs4232.c: I/O port 0x%03x not free\n"
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*      * This version of the driver doesn't use the PnP method when      * configuring the card but a simplified method defined by Crystal.      * This means that just one CS4232 compatible device can exist on the      * system. Also this method conflicts with possible PnP support in      * the OS. For this reason driver is just a temporary kludge.      */
comment|/*      * Wake up the card by sending a 32 byte Crystal key to the key port.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|CS_OUT
argument_list|(
name|crystal_key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/*      * Now set the CSN (Card Select Number).      */
name|CS_OUT2
argument_list|(
literal|0x06
argument_list|,
name|CSN_NUM
argument_list|)
expr_stmt|;
comment|/*      * Ensure that there is no other codec using the same address.      */
name|CS_OUT2
argument_list|(
literal|0x15
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Select logical device 0 (WSS/SB/FM) */
name|CS_OUT2
argument_list|(
literal|0x33
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Inactivate logical dev 0 */
comment|/*      * Then set some config bytes. First logical device 0      */
name|CS_OUT2
argument_list|(
literal|0x15
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Select logical device 0 (WSS/SB/FM) */
name|CS_OUT3
argument_list|(
literal|0x47
argument_list|,
operator|(
name|base
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|base
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* WSSbase */
if|if
condition|(
literal|0
condition|)
comment|/* Not free */
name|CS_OUT3
argument_list|(
literal|0x48
argument_list|,
literal|0x00
argument_list|,
literal|0x00
argument_list|)
comment|/* FMbase off */
else|else
name|CS_OUT3
argument_list|(
literal|0x48
argument_list|,
literal|0x03
argument_list|,
literal|0x88
argument_list|)
expr_stmt|;
comment|/* FMbase 0x388 */
name|CS_OUT3
argument_list|(
literal|0x42
argument_list|,
literal|0x00
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* SBbase off */
name|CS_OUT2
argument_list|(
literal|0x22
argument_list|,
name|irq
argument_list|)
expr_stmt|;
comment|/* SB+WSS IRQ */
name|CS_OUT2
argument_list|(
literal|0x2a
argument_list|,
name|dma1
argument_list|)
expr_stmt|;
comment|/* SB+WSS DMA */
if|if
condition|(
name|dma2
operator|!=
operator|-
literal|1
condition|)
name|CS_OUT2
argument_list|(
literal|0x25
argument_list|,
argument|dma2
argument_list|)
comment|/* WSS DMA2 */
else|else
name|CS_OUT2
argument_list|(
literal|0x25
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* No WSS DMA2 */
name|CS_OUT2
argument_list|(
literal|0x33
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Activate logical dev 0 */
comment|/*      * Initialize logical device 3 (MPU)      */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|CONFIG_MPU401
argument_list|)
operator|||
name|defined
argument_list|(
name|CONFIG_MPU_EMU
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|CONFIG_MIDI
argument_list|)
if|if
condition|(
name|mpu_base
operator|!=
literal|0
operator|&&
name|mpu_irq
operator|!=
literal|0
condition|)
block|{
name|CS_OUT2
argument_list|(
literal|0x15
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Select logical device 3 (MPU) */
name|CS_OUT3
argument_list|(
literal|0x47
argument_list|,
operator|(
name|mpu_base
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|mpu_base
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* MPUbase */
name|CS_OUT2
argument_list|(
literal|0x22
argument_list|,
name|mpu_irq
argument_list|)
expr_stmt|;
comment|/* MPU IRQ */
name|CS_OUT2
argument_list|(
literal|0x33
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Activate logical dev 3 */
block|}
endif|#
directive|endif
comment|/*      * Finally activate the chip      */
name|CS_OUT
argument_list|(
literal|0x79
argument_list|)
expr_stmt|;
comment|/*      * Then try to detect the codec part of the chip      */
return|return
name|ad1848_detect
argument_list|(
name|hw_config
operator|->
name|io_base
argument_list|,
name|NULL
argument_list|,
name|hw_config
operator|->
name|osp
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|attach_cs4232
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|int
name|base
init|=
name|hw_config
operator|->
name|io_base
decl_stmt|,
name|irq
init|=
name|hw_config
operator|->
name|irq
decl_stmt|;
name|int
name|dma1
init|=
name|hw_config
operator|->
name|dma
decl_stmt|,
name|dma2
init|=
name|hw_config
operator|->
name|dma2
decl_stmt|;
if|if
condition|(
name|dma2
operator|==
operator|-
literal|1
condition|)
name|dma2
operator|=
name|dma1
expr_stmt|;
name|ad1848_init
argument_list|(
literal|"CS4232"
argument_list|,
name|base
argument_list|,
name|irq
argument_list|,
name|dma1
argument_list|,
comment|/* Playback DMA */
name|dma2
argument_list|,
comment|/* Capture DMA */
literal|0
argument_list|,
name|hw_config
operator|->
name|osp
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|CONFIG_MPU401
argument_list|)
operator|||
name|defined
argument_list|(
name|CONFIG_MPU_EMU
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|CONFIG_MIDI
argument_list|)
if|if
condition|(
name|mpu_base
operator|!=
literal|0
operator|&&
name|mpu_irq
operator|!=
literal|0
condition|)
block|{
specifier|static
name|struct
name|address_info
name|hw_config2
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* Ensure it's initialized */
name|hw_config2
operator|.
name|io_base
operator|=
name|mpu_base
expr_stmt|;
name|hw_config2
operator|.
name|irq
operator|=
name|mpu_irq
expr_stmt|;
name|hw_config2
operator|.
name|dma
operator|=
operator|-
literal|1
expr_stmt|;
name|hw_config2
operator|.
name|dma2
operator|=
operator|-
literal|1
expr_stmt|;
name|hw_config2
operator|.
name|always_detect
operator|=
literal|0
expr_stmt|;
name|hw_config2
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|hw_config2
operator|.
name|card_subtype
operator|=
literal|0
expr_stmt|;
name|hw_config2
operator|.
name|osp
operator|=
name|hw_config
operator|->
name|osp
expr_stmt|;
if|if
condition|(
name|probe_mpu401
argument_list|(
operator|&
name|hw_config2
argument_list|)
condition|)
name|attach_mpu401
argument_list|(
operator|&
name|hw_config2
argument_list|)
expr_stmt|;
else|else
name|mpu_base
operator|=
name|mpu_irq
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

