begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/mad16.c  *   * Initialization code for OPTi MAD16 compatible audio chips. Including  *   * OPTi 82C928     MAD16           (replaced by C929) OAK OTI-601D    Mozart  * OPTi 82C929     MAD16 Pro  *   * These audio interface chips don't prduce sound themselves. They just connect  * some other components (OPL-[234] and a WSS compatible codec) to the PC bus  * and perform I/O, DMA and IRQ address decoding. There is also a UART for  * the MPU-401 mode (not 82C928/Mozart). The Mozart chip appears to be  * compatible with the 82C928 (can anybody confirm this?).  *   * NOTE! If you want to set CD-ROM address and/or joystick enable, define  * MAD16_CONF in local.h as combination of the following bits:  *   * 0x01    - joystick disabled  *   * CD-ROM type selection (select just one): 0x00    - none 0x02    - Sony 31A  * 0x04    - Mitsumi 0x06    - Panasonic (type "LaserMate", not  * "SoundBlaster") 0x08    - Secondary IDE (address 0x170) 0x0a    - Primary  * IDE (address 0x1F0)  *   * For example Mitsumi with joystick disabled = 0x04|0x01 = 0x05 For example  * LaserMate (for use with sbpcd) plus joystick = 0x06  *   * MAD16_CDSEL: This defaults to CD I/O 0x340, no IRQ and DMA3 (DMA5 with  * Mitsumi or IDE). If you like to change these, define MAD16_CDSEL with the  * following bits:  *   * CD-ROM port: 0x00=340, 0x40=330, 0x80=360 or 0xc0=320 OPL4 select: 0x20=OPL4,  * 0x00=OPL3 CD-ROM irq: 0x00=disabled, 0x04=IRQ5, 0x08=IRQ7, 0x0a=IRQ3,  * 0x10=IRQ9, 0x14=IRQ10 and 0x18=IRQ11.  *   * CD-ROM DMA (Sony or Panasonic): 0x00=DMA3, 0x01=DMA2, 0x02=DMA1 or  * 0x03=disabled or CD-ROM DMA (Mitsumi or IDE):    0x00=DMA5, 0x01=DMA6,  * 0x02=DMA7 or 0x03=disabled  *   * For use with sbpcd, address 0x340, set MAD16_CDSEL to 0x03 or 0x23.  *   * Copyright by Hannu Savolainen 1995  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/sound/sound_config.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_MAD16
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|already_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|C928
value|1
end_define

begin_define
define|#
directive|define
name|MOZART
value|2
end_define

begin_define
define|#
directive|define
name|C929
value|3
end_define

begin_comment
comment|/*  * Registers  *   * The MAD16 occupies I/O ports 0xf8d to 0xf93 (fixed locations). All ports are  * inactive by default. They can be activated by writing 0xE2 or 0xE3 to the  * password register. The password is valid only until the next I/O read or  * write.  */
end_comment

begin_define
define|#
directive|define
name|MC1_PORT
value|0xf8d
end_define

begin_comment
comment|/* SB address, CDROM interface type, joystick */
end_comment

begin_define
define|#
directive|define
name|MC2_PORT
value|0xf8e
end_define

begin_comment
comment|/* CDROM address, IRQ, DMA, plus OPL4 bit */
end_comment

begin_define
define|#
directive|define
name|MC3_PORT
value|0xf8f
end_define

begin_define
define|#
directive|define
name|PASSWD_REG
value|0xf8f
end_define

begin_define
define|#
directive|define
name|MC4_PORT
value|0xf90
end_define

begin_define
define|#
directive|define
name|MC5_PORT
value|0xf91
end_define

begin_define
define|#
directive|define
name|MC6_PORT
value|0xf92
end_define

begin_define
define|#
directive|define
name|MC7_PORT
value|0xf93
end_define

begin_decl_stmt
specifier|static
name|int
name|board_type
init|=
name|C928
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sound_os_info
modifier|*
name|mad16_osp
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|DDB
end_ifndef

begin_define
define|#
directive|define
name|DDB
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|unsigned
name|char
name|mad_read
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|tmp
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|board_type
condition|)
block|{
comment|/* Output password */
case|case
name|C928
case|:
case|case
name|MOZART
case|:
name|outb
argument_list|(
name|PASSWD_REG
argument_list|,
literal|0xE2
argument_list|)
expr_stmt|;
break|break;
case|case
name|C929
case|:
name|outb
argument_list|(
name|PASSWD_REG
argument_list|,
literal|0xE3
argument_list|)
expr_stmt|;
break|break;
block|}
name|tmp
operator|=
name|inb
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mad_write
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|board_type
condition|)
block|{
comment|/* Output password */
case|case
name|C928
case|:
case|case
name|MOZART
case|:
name|outb
argument_list|(
name|PASSWD_REG
argument_list|,
literal|0xE2
argument_list|)
expr_stmt|;
break|break;
case|case
name|C929
case|:
name|outb
argument_list|(
name|PASSWD_REG
argument_list|,
literal|0xE3
argument_list|)
expr_stmt|;
break|break;
block|}
name|outb
argument_list|(
name|port
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|detect_mad16
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|tmp
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/* 	 * Check that reading a register doesn't return bus float (0xff) when 	 * the card is accessed using password. This may fail in case the 	 * card is in low power mode. Normally at least the power saving mode 	 * bit should be 0. 	 */
if|if
condition|(
operator|(
name|tmp
operator|=
name|mad_read
argument_list|(
name|MC1_PORT
argument_list|)
operator|)
operator|==
literal|0xff
condition|)
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"MC1_PORT returned 0xff\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Now check that the gate is closed on first I/O after writing the 	 * password. (This is how a MAD16 compatible card works). 	 */
if|if
condition|(
operator|(
name|tmp2
operator|=
name|inb
argument_list|(
name|MC1_PORT
argument_list|)
operator|)
operator|==
name|tmp
condition|)
block|{
comment|/* It didn't close */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"MC1_PORT didn't close after read (0x%02x)\n"
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mad_write
argument_list|(
name|MC1_PORT
argument_list|,
name|tmp
operator|^
literal|0x80
argument_list|)
expr_stmt|;
comment|/* Togge a bit */
if|if
condition|(
operator|(
name|tmp2
operator|=
name|mad_read
argument_list|(
name|MC1_PORT
argument_list|)
operator|)
operator|!=
operator|(
name|tmp
operator|^
literal|0x80
operator|)
condition|)
block|{
comment|/* Compare the bit */
name|mad_write
argument_list|(
name|MC1_PORT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Restore */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"Bit revert test failed (0x%02x, 0x%02x)\n"
argument_list|,
name|tmp
argument_list|,
name|tmp2
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mad_write
argument_list|(
name|MC1_PORT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Restore */
return|return
literal|1
return|;
comment|/* Bingo */
block|}
end_function

begin_function
name|int
name|probe_mad16
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|valid_ports
index|[]
init|=
block|{
literal|0x530
block|,
literal|0xe80
block|,
literal|0xf40
block|,
literal|0x604
block|}
decl_stmt|;
name|unsigned
name|char
name|tmp
decl_stmt|;
name|unsigned
name|char
name|cs4231_mode
init|=
literal|0
decl_stmt|;
name|int
name|ad_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|already_initialized
condition|)
return|return
literal|0
return|;
name|mad16_osp
operator|=
name|hw_config
operator|->
name|osp
expr_stmt|;
comment|/* 	 * Check that all ports return 0xff (bus float) when no password is 	 * written to the password register. 	 */
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"--- Detecting MAD16 / Mozart ---\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Then try to detect with the old password 	 */
name|board_type
operator|=
name|C928
expr_stmt|;
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"Detect using password = 0xE2\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|detect_mad16
argument_list|()
condition|)
block|{
comment|/* No luck. Try different model */
name|board_type
operator|=
name|C929
expr_stmt|;
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"Detect using password = 0xE3\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|detect_mad16
argument_list|()
condition|)
return|return
literal|0
return|;
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"mad16.c: 82C929 detected\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|char
name|model
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|model
operator|=
name|mad_read
argument_list|(
name|MC3_PORT
argument_list|)
operator|)
operator|&
literal|0x03
operator|)
operator|==
literal|0x03
condition|)
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"mad16.c: Mozart detected\n"
argument_list|)
argument_list|)
expr_stmt|;
name|board_type
operator|=
name|MOZART
expr_stmt|;
block|}
else|else
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"mad16.c: 82C928 detected???\n"
argument_list|)
argument_list|)
expr_stmt|;
name|board_type
operator|=
name|C928
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0xf8d
init|;
name|i
operator|<=
literal|0xf93
condition|;
name|i
operator|++
control|)
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"port %03x = %03x\n"
argument_list|,
name|i
argument_list|,
name|mad_read
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set the WSS address 	 */
name|tmp
operator|=
literal|0x80
expr_stmt|;
comment|/* Enable WSS, Disable SB */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|3
condition|)
block|{
comment|/* Not a valid port */
name|printf
argument_list|(
literal|"MAD16/Mozart: Bad WSS base address 0x%x\n"
argument_list|,
name|hw_config
operator|->
name|io_base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|valid_ports
index|[
name|i
index|]
operator|==
name|hw_config
operator|->
name|io_base
condition|)
block|{
name|tmp
operator||=
name|i
operator|<<
literal|4
expr_stmt|;
comment|/* WSS port select bits */
break|break;
block|}
block|}
comment|/* 	 * Set optional CD-ROM and joystick settings. 	 */
ifdef|#
directive|ifdef
name|MAD16_CONF
name|tmp
operator||=
operator|(
operator|(
name|MAD16_CONF
operator|)
operator|&
literal|0x0f
operator|)
expr_stmt|;
comment|/* CD-ROM and joystick bits */
endif|#
directive|endif
name|mad_write
argument_list|(
name|MC1_PORT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MAD16_CONF
argument_list|)
operator|&&
name|defined
argument_list|(
name|MAD16_CDSEL
argument_list|)
name|tmp
operator|=
name|MAD16_CDSEL
expr_stmt|;
else|#
directive|else
name|tmp
operator|=
literal|0x03
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAD16_OPL4
name|tmp
operator||=
literal|0x20
expr_stmt|;
comment|/* Enable OPL4 access */
endif|#
directive|endif
name|mad_write
argument_list|(
name|MC2_PORT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|mad_write
argument_list|(
name|MC3_PORT
argument_list|,
literal|0xf0
argument_list|)
expr_stmt|;
comment|/* Disable SB */
if|if
condition|(
operator|!
name|ad1848_detect
argument_list|(
name|hw_config
operator|->
name|io_base
operator|+
literal|4
argument_list|,
operator|&
name|ad_flags
argument_list|,
name|mad16_osp
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ad_flags
operator|&
operator|(
name|AD_F_CS4231
operator||
name|AD_F_CS4248
operator|)
condition|)
name|cs4231_mode
operator|=
literal|0x02
expr_stmt|;
comment|/* CS4248/CS4231 sync delay switch */
if|if
condition|(
name|board_type
operator|==
name|C929
condition|)
block|{
name|mad_write
argument_list|(
name|MC4_PORT
argument_list|,
literal|0xa2
argument_list|)
expr_stmt|;
name|mad_write
argument_list|(
name|MC5_PORT
argument_list|,
literal|0xA5
operator||
name|cs4231_mode
argument_list|)
expr_stmt|;
name|mad_write
argument_list|(
name|MC6_PORT
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Disable MPU401 */
block|}
else|else
block|{
name|mad_write
argument_list|(
name|MC4_PORT
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|mad_write
argument_list|(
name|MC5_PORT
argument_list|,
literal|0x30
operator||
name|cs4231_mode
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0xf8d
init|;
name|i
operator|<=
literal|0xf93
condition|;
name|i
operator|++
control|)
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"port %03x after init = %03x\n"
argument_list|,
name|i
argument_list|,
name|mad_read
argument_list|(
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Verify the WSS parameters 	 */
if|if
condition|(
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"MSS: I/O port conflict\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Check if the IO port returns valid signature. The original MS 	 * Sound system returns 0x04 while some cards (AudioTriX Pro for 	 * example) return 0x00. 	 */
if|if
condition|(
operator|(
name|inb
argument_list|(
name|hw_config
operator|->
name|io_base
operator|+
literal|3
argument_list|)
operator|&
literal|0x3f
operator|)
operator|!=
literal|0x04
operator|&&
operator|(
name|inb
argument_list|(
name|hw_config
operator|->
name|io_base
operator|+
literal|3
argument_list|)
operator|&
literal|0x3f
operator|)
operator|!=
literal|0x00
condition|)
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"No MSS signature detected on port 0x%x (0x%x)\n"
argument_list|,
name|hw_config
operator|->
name|io_base
argument_list|,
name|inb
argument_list|(
name|hw_config
operator|->
name|io_base
operator|+
literal|3
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|hw_config
operator|->
name|irq
operator|>
literal|11
condition|)
block|{
name|printf
argument_list|(
literal|"MSS: Bad IRQ %d\n"
argument_list|,
name|hw_config
operator|->
name|irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|hw_config
operator|->
name|dma
operator|!=
literal|0
operator|&&
name|hw_config
operator|->
name|dma
operator|!=
literal|1
operator|&&
name|hw_config
operator|->
name|dma
operator|!=
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"MSS: Bad DMA %d\n"
argument_list|,
name|hw_config
operator|->
name|dma
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Check that DMA0 is not in use with a 8 bit board. 	 */
if|if
condition|(
name|hw_config
operator|->
name|dma
operator|==
literal|0
operator|&&
name|inb
argument_list|(
name|hw_config
operator|->
name|io_base
operator|+
literal|3
argument_list|)
operator|&
literal|0x80
condition|)
block|{
name|printf
argument_list|(
literal|"MSS: Can't use DMA0 with a 8 bit card/slot\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|hw_config
operator|->
name|irq
operator|>
literal|7
operator|&&
name|hw_config
operator|->
name|irq
operator|!=
literal|9
operator|&&
name|inb
argument_list|(
name|hw_config
operator|->
name|io_base
operator|+
literal|3
argument_list|)
operator|&
literal|0x80
condition|)
block|{
name|printf
argument_list|(
literal|"MSS: Can't use IRQ%d with a 8 bit card/slot\n"
argument_list|,
name|hw_config
operator|->
name|irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|attach_mad16
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
specifier|static
name|char
name|interrupt_bits
index|[
literal|12
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0x08
block|,
operator|-
literal|1
block|,
literal|0x10
block|,
literal|0x18
block|,
literal|0x20
block|}
decl_stmt|;
name|char
name|bits
decl_stmt|;
specifier|static
name|char
name|dma_bits
index|[
literal|4
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|}
decl_stmt|;
name|int
name|config_port
init|=
name|hw_config
operator|->
name|io_base
operator|+
literal|0
decl_stmt|,
name|version_port
init|=
name|hw_config
operator|->
name|io_base
operator|+
literal|3
decl_stmt|;
name|int
name|ad_flags
init|=
literal|0
decl_stmt|,
name|dma
init|=
name|hw_config
operator|->
name|dma
decl_stmt|,
name|dma2
init|=
name|hw_config
operator|->
name|dma2
decl_stmt|;
name|unsigned
name|char
name|dma2_bit
init|=
literal|0
decl_stmt|;
name|already_initialized
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|ad1848_detect
argument_list|(
name|hw_config
operator|->
name|io_base
operator|+
literal|4
argument_list|,
operator|&
name|ad_flags
argument_list|,
name|mad16_osp
argument_list|)
condition|)
return|return;
comment|/* 	 * Set the IRQ and DMA addresses. 	 */
name|bits
operator|=
name|interrupt_bits
index|[
name|hw_config
operator|->
name|irq
index|]
expr_stmt|;
if|if
condition|(
name|bits
operator|==
operator|-
literal|1
condition|)
return|return;
name|outb
argument_list|(
name|config_port
argument_list|,
name|bits
operator||
literal|0x40
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|version_port
argument_list|)
operator|&
literal|0x40
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"[IRQ Conflict?]"
argument_list|)
expr_stmt|;
comment|/* 	 * Handle the capture DMA channel 	 */
if|if
condition|(
name|ad_flags
operator|&
name|AD_F_CS4231
operator|&&
name|dma2
operator|!=
operator|-
literal|1
operator|&&
name|dma2
operator|!=
name|dma
condition|)
block|{
if|if
condition|(
operator|(
name|dma
operator|==
literal|0
operator|&&
name|dma2
operator|==
literal|1
operator|)
operator|||
operator|(
name|dma
operator|==
literal|1
operator|&&
name|dma2
operator|==
literal|0
operator|)
operator|||
operator|(
name|dma
operator|==
literal|3
operator|&&
name|dma2
operator|==
literal|0
operator|)
condition|)
block|{
name|dma2_bit
operator|=
literal|0x04
expr_stmt|;
comment|/* Enable capture DMA */
block|}
else|else
block|{
name|printf
argument_list|(
literal|"MAD16: Invalid capture DMA\n"
argument_list|)
expr_stmt|;
name|dma2
operator|=
name|dma
expr_stmt|;
block|}
block|}
else|else
name|dma2
operator|=
name|dma
expr_stmt|;
name|outb
argument_list|(
name|config_port
argument_list|,
name|bits
operator||
name|dma_bits
index|[
name|dma
index|]
operator||
name|dma2_bit
argument_list|)
expr_stmt|;
comment|/* Write IRQ+DMA setup */
name|ad1848_init
argument_list|(
literal|"MAD16 WSS"
argument_list|,
name|hw_config
operator|->
name|io_base
operator|+
literal|4
argument_list|,
name|hw_config
operator|->
name|irq
argument_list|,
name|dma
argument_list|,
name|dma2
argument_list|,
literal|0
argument_list|,
name|hw_config
operator|->
name|osp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|attach_mad16_mpu
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
if|if
condition|(
name|board_type
operator|<
name|C929
condition|)
block|{
comment|/* Early chip. No MPU support. Just SB MIDI */
ifdef|#
directive|ifdef
name|CONFIG_MIDI
if|if
condition|(
name|mad_read
argument_list|(
name|MC1_PORT
argument_list|)
operator|&
literal|0x20
condition|)
name|hw_config
operator|->
name|io_base
operator|=
literal|0x240
expr_stmt|;
else|else
name|hw_config
operator|->
name|io_base
operator|=
literal|0x220
expr_stmt|;
return|return
name|mad16_sb_dsp_init
argument_list|(
name|hw_config
argument_list|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|CONFIG_MPU401
argument_list|)
operator|||
name|defined
argument_list|(
name|CONFIG_MPU_EMU
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|CONFIG_MIDI
argument_list|)
if|if
condition|(
operator|!
name|already_initialized
condition|)
return|return;
name|attach_mpu401
argument_list|(
name|hw_config
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|probe_mad16_mpu
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
if|#
directive|if
operator|(
name|defined
argument_list|(
name|CONFIG_MPU401
argument_list|)
operator|||
name|defined
argument_list|(
name|CONFIG_MPU_EMU
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|CONFIG_MIDI
argument_list|)
specifier|static
name|int
name|mpu_attached
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|valid_ports
index|[]
init|=
block|{
literal|0x330
block|,
literal|0x320
block|,
literal|0x310
block|,
literal|0x300
block|}
decl_stmt|;
specifier|static
name|short
name|valid_irqs
index|[]
init|=
block|{
literal|9
block|,
literal|10
block|,
literal|5
block|,
literal|7
block|}
decl_stmt|;
name|unsigned
name|char
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* A variable with secret power */
if|if
condition|(
operator|!
name|already_initialized
condition|)
comment|/* The MSS port must be initialized 					 * first */
return|return
literal|0
return|;
if|if
condition|(
name|mpu_attached
condition|)
comment|/* Don't let them call this twice */
return|return
literal|0
return|;
name|mpu_attached
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|board_type
operator|<
name|C929
condition|)
block|{
comment|/* Early chip. No MPU support. Just SB MIDI */
ifdef|#
directive|ifdef
name|CONFIG_MIDI
name|unsigned
name|char
name|tmp
decl_stmt|;
name|tmp
operator|=
name|mad_read
argument_list|(
name|MC3_PORT
argument_list|)
expr_stmt|;
comment|/* 		 * MAD16 SB base is defined by the WSS base. It cannot be 		 * changed alone. Ignore configured I/O base. Use the active 		 * setting. 		 */
if|if
condition|(
name|mad_read
argument_list|(
name|MC1_PORT
argument_list|)
operator|&
literal|0x20
condition|)
name|hw_config
operator|->
name|io_base
operator|=
literal|0x240
expr_stmt|;
else|else
name|hw_config
operator|->
name|io_base
operator|=
literal|0x220
expr_stmt|;
switch|switch
condition|(
name|hw_config
operator|->
name|irq
condition|)
block|{
case|case
literal|5
case|:
name|tmp
operator|=
operator|(
name|tmp
operator|&
literal|0x3f
operator|)
operator||
literal|0x80
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|tmp
operator|=
operator|(
name|tmp
operator|&
literal|0x3f
operator|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|tmp
operator|=
operator|(
name|tmp
operator|&
literal|0x3f
operator|)
operator||
literal|0x40
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"mad16/Mozart: Invalid MIDI IRQ\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mad_write
argument_list|(
name|MC3_PORT
argument_list|,
name|tmp
operator||
literal|0x04
argument_list|)
expr_stmt|;
return|return
name|mad16_sb_dsp_detect
argument_list|(
name|hw_config
argument_list|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
name|tmp
operator|=
literal|0x83
expr_stmt|;
comment|/* MPU-401 enable */
comment|/* 	 * Set the MPU base bits 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|3
condition|)
block|{
comment|/* Out of array bounds */
name|printf
argument_list|(
literal|"MAD16 / Mozart: Invalid MIDI port 0x%x\n"
argument_list|,
name|hw_config
operator|->
name|io_base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|valid_ports
index|[
name|i
index|]
operator|==
name|hw_config
operator|->
name|io_base
condition|)
block|{
name|tmp
operator||=
name|i
operator|<<
literal|5
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Set the MPU IRQ bits 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|3
condition|)
block|{
comment|/* Out of array bounds */
name|printf
argument_list|(
literal|"MAD16 / Mozart: Invalid MIDI IRQ %d\n"
argument_list|,
name|hw_config
operator|->
name|irq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|valid_irqs
index|[
name|i
index|]
operator|==
name|hw_config
operator|->
name|irq
condition|)
block|{
name|tmp
operator||=
name|i
operator|<<
literal|3
expr_stmt|;
break|break;
block|}
block|}
name|mad_write
argument_list|(
name|MC6_PORT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Write MPU401 config */
return|return
name|probe_mpu401
argument_list|(
name|hw_config
argument_list|)
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* That's all folks */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

