begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/gus_wave.c  *   * Driver for the Gravis UltraSound wave table synth.  *   * Copyright by Hannu Savolainen 1993, 1994  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/sound/sound_config.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/sound/ultrasound.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/sound/gus_hw.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/sound/iwdefs.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_comment
comment|/* PnP stuff */
end_comment

begin_define
define|#
directive|define
name|GUS_PNP_ID
value|0x100561e
end_define

begin_define
define|#
directive|define
name|MAX_CARDS
value|8
end_define

begin_define
define|#
directive|define
name|MAX_GUS_PNP
value|12
end_define

begin_comment
comment|/* Static ports */
end_comment

begin_define
define|#
directive|define
name|PADDRESS
value|0x279
end_define

begin_define
define|#
directive|define
name|PWRITE_DATA
value|0xa79
end_define

begin_define
define|#
directive|define
name|SET_CSN
value|0x06
end_define

begin_define
define|#
directive|define
name|PSTATUS
value|0x05
end_define

begin_comment
comment|/* PnP Registers.  Write to ADDRESS and then use WRITE/READ_DATA */
end_comment

begin_define
define|#
directive|define
name|SET_RD_DATA
value|0x00
end_define

begin_define
define|#
directive|define
name|SERIAL_ISOLATION
value|0x01
end_define

begin_define
define|#
directive|define
name|WAKE
value|0x03
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_GUS
argument_list|)
end_if

begin_decl_stmt
name|IWAVE
name|iw
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ENTER_CRITICAL
end_define

begin_define
define|#
directive|define
name|LEAVE_CRITICAL
end_define

begin_define
define|#
directive|define
name|MAX_SAMPLE
value|150
end_define

begin_define
define|#
directive|define
name|MAX_PATCH
value|256
end_define

begin_decl_stmt
name|u_int
name|gus_pnp_found
index|[
name|MAX_GUS_PNP
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|voice_info
block|{
name|u_long
name|orig_freq
decl_stmt|;
name|u_long
name|current_freq
decl_stmt|;
name|u_long
name|mode
decl_stmt|;
name|int
name|bender
decl_stmt|;
name|int
name|bender_range
decl_stmt|;
name|int
name|panning
decl_stmt|;
name|int
name|midi_volume
decl_stmt|;
name|u_int
name|initial_volume
decl_stmt|;
name|u_int
name|current_volume
decl_stmt|;
name|int
name|loop_irq_mode
decl_stmt|,
name|loop_irq_parm
decl_stmt|;
define|#
directive|define
name|LMODE_FINISH
value|1
define|#
directive|define
name|LMODE_PCM
value|2
define|#
directive|define
name|LMODE_PCM_STOP
value|3
name|int
name|volume_irq_mode
decl_stmt|,
name|volume_irq_parm
decl_stmt|;
define|#
directive|define
name|VMODE_HALT
value|1
define|#
directive|define
name|VMODE_ENVELOPE
value|2
define|#
directive|define
name|VMODE_START_NOTE
value|3
name|int
name|env_phase
decl_stmt|;
name|u_char
name|env_rate
index|[
literal|6
index|]
decl_stmt|;
name|u_char
name|env_offset
index|[
literal|6
index|]
decl_stmt|;
comment|/* 	 * Volume computation parameters for gus_adagio_vol() 	 */
name|int
name|main_vol
decl_stmt|,
name|expression_vol
decl_stmt|,
name|patch_vol
decl_stmt|;
comment|/* Variables for "Ultraclick" removal */
name|int
name|dev_pending
decl_stmt|,
name|note_pending
decl_stmt|,
name|volume_pending
decl_stmt|,
name|sample_pending
decl_stmt|;
name|char
name|kill_pending
decl_stmt|;
name|long
name|offset_pending
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|voice_alloc_info
modifier|*
name|voice_alloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gus_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gus_irq
decl_stmt|,
name|gus_dma
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_dma2
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dual_dma_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|gus_mem_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|free_mem_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_no_dma
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nr_voices
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_devnum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|volume_base
decl_stmt|,
name|volume_scale
decl_stmt|,
name|volume_method
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_recmask
init|=
name|SOUND_MASK_MIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|recording_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|only_read_access
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|only_8_bits
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gus_wave_volume
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gus_pcm_volume
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|have_gus_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_line_vol
init|=
literal|100
decl_stmt|,
name|gus_mic_vol
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|mix_image
init|=
literal|0x00
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gus_timer_enabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Current version of this driver doesn't allow synth and PCM functions at  * the same time. The active_device specifies the active driver  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|active_device
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GUS_DEV_WAVE
value|1
end_define

begin_comment
comment|/* Wave table synth */
end_comment

begin_define
define|#
directive|define
name|GUS_DEV_PCM_DONE
value|2
end_define

begin_comment
comment|/* PCM device, transfer done */
end_comment

begin_define
define|#
directive|define
name|GUS_DEV_PCM_CONTINUE
value|3
end_define

begin_comment
comment|/* PCM device, transfer done ch. 1/2 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gus_sampling_speed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_sampling_channels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_sampling_bits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|dram_sleeper
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|struct
name|snd_wait
name|dram_sleep_flag
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Variables and buffers for PCM output  */
end_comment

begin_define
define|#
directive|define
name|MAX_PCM_BUFFERS
value|(32*MAX_REALTIME_FACTOR)
end_define

begin_comment
comment|/* Don't change */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pcm_bsize
decl_stmt|,
name|pcm_nblk
decl_stmt|,
name|pcm_banksize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_datasize
index|[
name|MAX_PCM_BUFFERS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|pcm_head
decl_stmt|,
name|pcm_tail
decl_stmt|,
name|pcm_qlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|pcm_active
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|dma_active
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_opened
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_current_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_current_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|pcm_current_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_current_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_current_intrflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|sound_os_info
modifier|*
name|gus_osp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|voice_info
name|voices
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|freq_div_table
index|[]
init|=
block|{
literal|44100
block|,
comment|/* 14 */
literal|41160
block|,
comment|/* 15 */
literal|38587
block|,
comment|/* 16 */
literal|36317
block|,
comment|/* 17 */
literal|34300
block|,
comment|/* 18 */
literal|32494
block|,
comment|/* 19 */
literal|30870
block|,
comment|/* 20 */
literal|29400
block|,
comment|/* 21 */
literal|28063
block|,
comment|/* 22 */
literal|26843
block|,
comment|/* 23 */
literal|25725
block|,
comment|/* 24 */
literal|24696
block|,
comment|/* 25 */
literal|23746
block|,
comment|/* 26 */
literal|22866
block|,
comment|/* 27 */
literal|22050
block|,
comment|/* 28 */
literal|21289
block|,
comment|/* 29 */
literal|20580
block|,
comment|/* 30 */
literal|19916
block|,
comment|/* 31 */
literal|19293
comment|/* 32 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|patch_info
modifier|*
name|samples
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|patch_info
modifier|*
name|dbg_samples
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dbg_samplep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|sample_ptrs
index|[
name|MAX_SAMPLE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sample_map
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|free_sample
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mixer_type
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|patch_table
index|[
name|MAX_PATCH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|patch_map
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|synth_info
name|gus_info
init|=
block|{
literal|"Gravis UltraSound"
block|,
literal|0
block|,
name|SYNTH_TYPE_SAMPLE
block|,
name|SAMPLE_TYPE_GUS
block|,
literal|0
block|,
literal|16
block|,
literal|0
block|,
name|MAX_PATCH
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|gus_default_mixer_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|guswave_start_note2
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note_num
parameter_list|,
name|int
name|volume
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gus_poke
parameter_list|(
name|long
name|addr
parameter_list|,
name|u_char
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|compute_and_set_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|,
name|int
name|ramp_time
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_short
name|gus_adagio_vol
parameter_list|(
name|int
name|vel
parameter_list|,
name|int
name|mainv
parameter_list|,
name|int
name|xpn
parameter_list|,
name|int
name|voicev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|u_short
name|gus_linear_vol
parameter_list|(
name|int
name|vol
parameter_list|,
name|int
name|mainvol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|compute_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|do_volume_irq
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_input_volumes
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gus_tmr_install
parameter_list|(
name|int
name|io_base
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|SEND
parameter_list|(
name|int
name|d
parameter_list|,
name|int
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|get_serial
parameter_list|(
name|int
name|rd_port
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|send_Initiation_LFSR
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|isolation_protocol
parameter_list|(
name|int
name|rd_port
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|INSTANT_RAMP
value|-1
end_define

begin_comment
comment|/* Instant change. No ramping */
end_comment

begin_define
define|#
directive|define
name|FAST_RAMP
value|0
end_define

begin_comment
comment|/* Fastest possible ramp */
end_comment

begin_comment
comment|/* Crystal Select */
end_comment

begin_define
define|#
directive|define
name|CODEC_XTAL2
value|0x01
end_define

begin_comment
comment|/* 16.9344 crystal */
end_comment

begin_define
define|#
directive|define
name|CODEC_XTAL1
value|0x00
end_define

begin_comment
comment|/* 24.576 crystal */
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* Definitions for CONFIG_1 register                                    */
end_comment

begin_define
define|#
directive|define
name|CODEC_CFIG1I_DEFAULT
value|0x03 | 0x8
end_define

begin_define
define|#
directive|define
name|CODEC_CAPTURE_PIO
value|0x80
end_define

begin_comment
comment|/* Capture PIO enable */
end_comment

begin_define
define|#
directive|define
name|CODEC_PLAYBACK_PIO
value|0x40
end_define

begin_comment
comment|/* Playback PIO enable */
end_comment

begin_define
define|#
directive|define
name|CODEC_AUTOCALIB
value|0x08
end_define

begin_comment
comment|/* auto calibrate */
end_comment

begin_define
define|#
directive|define
name|CODEC_SINGLE_DMA
value|0x04
end_define

begin_comment
comment|/* Use single DMA channel */
end_comment

begin_define
define|#
directive|define
name|CODEC_RE
value|0x02
end_define

begin_comment
comment|/* Capture enable */
end_comment

begin_define
define|#
directive|define
name|CODEC_PE
value|0x01
end_define

begin_comment
comment|/* playback enable */
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* Definitions for CONFIG_2 register                                    */
end_comment

begin_define
define|#
directive|define
name|CODEC_CFIG2I_DEFAULT
value|0x81
end_define

begin_define
define|#
directive|define
name|CODEC_OFVS
value|0x80
end_define

begin_comment
comment|/* Output Full Scale Voltage */
end_comment

begin_define
define|#
directive|define
name|CODEC_TE
value|0x40
end_define

begin_comment
comment|/* Timer Enable */
end_comment

begin_define
define|#
directive|define
name|CODEC_RSCD
value|0x20
end_define

begin_comment
comment|/* Recors Sample Counter Disable */
end_comment

begin_define
define|#
directive|define
name|CODEC_PSCD
value|0x10
end_define

begin_comment
comment|/* Playback Sample Counter Disable */
end_comment

begin_define
define|#
directive|define
name|CODEC_DAOF
value|0x01
end_define

begin_comment
comment|/* D/A Ouput Force Enable */
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* Definitions for CONFIG_3 register                                    */
end_comment

begin_comment
comment|/* #define CODEC_CFIG3I_DEFAULT    0xe0  0x02 when synth DACs are working */
end_comment

begin_define
define|#
directive|define
name|CODEC_CFIG3I_DEFAULT
value|0xc0
end_define

begin_comment
comment|/* 0x02 when synth DACs are working */
end_comment

begin_define
define|#
directive|define
name|CODEC_RPIE
value|0x80
end_define

begin_comment
comment|/* Record FIFO IRQ Enable */
end_comment

begin_define
define|#
directive|define
name|CODEC_PPIE
value|0x40
end_define

begin_comment
comment|/* Playback FIFO IRQ Enable */
end_comment

begin_define
define|#
directive|define
name|CODEC_FT_MASK
value|0x30
end_define

begin_comment
comment|/* FIFO Threshold Select */
end_comment

begin_define
define|#
directive|define
name|CODEC_PVFM
value|0x04
end_define

begin_comment
comment|/* Playback Variable Frequency Mode */
end_comment

begin_define
define|#
directive|define
name|CODEC_SYNA
value|0x02
end_define

begin_comment
comment|/* AUX1/Synth Signal Select */
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* Definitions for EXTERNAL_CONTROL register                            */
end_comment

begin_define
define|#
directive|define
name|CODEC_CEXTI_DEFAULT
value|0x00
end_define

begin_define
define|#
directive|define
name|CODEC_IRQ_ENABLE
value|0x02
end_define

begin_comment
comment|/* interrupt enable */
end_comment

begin_define
define|#
directive|define
name|CODEC_GPOUT1
value|0x80
end_define

begin_comment
comment|/* external control #1 */
end_comment

begin_define
define|#
directive|define
name|CODEC_GPOUT0
value|0x40
end_define

begin_comment
comment|/* external control #0 */
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* Definitions for MODE_SELECT_ID register                              */
end_comment

begin_define
define|#
directive|define
name|CODEC_MODE_DEFAULT
value|0x40
end_define

begin_define
define|#
directive|define
name|CODEC_MODE_MASK
value|0x60
end_define

begin_define
define|#
directive|define
name|CODEC_ID_BIT4
value|0x80
end_define

begin_define
define|#
directive|define
name|CODEC_ID_BIT3_0
value|0x0F
end_define

begin_comment
comment|/************************************************************************/
end_comment

begin_define
define|#
directive|define
name|CONFIG_1
value|0x09
end_define

begin_define
define|#
directive|define
name|EXTERNAL_CONTROL
value|0x0a
end_define

begin_comment
comment|/* Pin control */
end_comment

begin_define
define|#
directive|define
name|STATUS_2
value|0x0b
end_define

begin_comment
comment|/* Test and initialization */
end_comment

begin_define
define|#
directive|define
name|MODE_SELECT_ID
value|0x0c
end_define

begin_comment
comment|/* Miscellaneaous information */
end_comment

begin_define
define|#
directive|define
name|LOOPBACK
value|0x0d
end_define

begin_comment
comment|/* Digital Mix */
end_comment

begin_define
define|#
directive|define
name|UPPER_PLAY_COUNT
value|0x0e
end_define

begin_comment
comment|/* Playback Upper Base Count */
end_comment

begin_define
define|#
directive|define
name|LOWER_PLAY_COUNT
value|0x0f
end_define

begin_comment
comment|/* Playback Lower Base Count */
end_comment

begin_define
define|#
directive|define
name|CONFIG_2
value|0x10
end_define

begin_define
define|#
directive|define
name|CONFIG_3
value|0x11
end_define

begin_define
define|#
directive|define
name|IWL_CODEC_OUT
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|{ outb(iwl_codec_base, reg); outb(iwl_codec_data, val); }
end_define

begin_define
define|#
directive|define
name|IWL_CODEC_IN
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|{ outb(iwl_codec_base, reg); val = inb(iwl_codec_data); }
end_define

begin_function_decl
name|u_char
name|gus_look8
parameter_list|(
name|int
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gus_write16
parameter_list|(
name|int
name|reg
parameter_list|,
name|u_int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_short
name|gus_read16
parameter_list|(
name|int
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|gus_write_addr
parameter_list|(
name|int
name|reg
parameter_list|,
name|u_long
name|address
parameter_list|,
name|int
name|is16bit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwaveLineLevel
parameter_list|(
name|char
name|level
parameter_list|,
name|char
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwaveInputSource
parameter_list|(
name|BYTE
name|index
parameter_list|,
name|BYTE
name|source
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwaveDelay
parameter_list|(
name|WORD
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwaveStopDma
parameter_list|(
name|BYTE
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwavePnpGetCfg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwavePnpDevice
parameter_list|(
name|BYTE
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwavePnpSetCfg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwavePnpKey
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BYTE
name|IwavePnpIsol
parameter_list|(
name|PORT
modifier|*
name|pnpread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwaveCfgIOSpace
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwavePnpSerial
parameter_list|(
name|PORT
name|pnprdp
parameter_list|,
name|BYTE
name|csn
parameter_list|,
name|BYTE
modifier|*
name|vendor
parameter_list|,
name|DWORD
modifier|*
name|serial
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwavePnpPeek
parameter_list|(
name|PORT
name|pnprdp
parameter_list|,
name|WORD
name|bytes
parameter_list|,
name|BYTE
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwavePnpEeprom
parameter_list|(
name|BYTE
name|ctrl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwavePnpActivate
parameter_list|(
name|BYTE
name|dev
parameter_list|,
name|BYTE
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwavePnpPower
parameter_list|(
name|BYTE
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwavePnpWake
parameter_list|(
name|BYTE
name|csn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|PORT
name|IwavePnpIOcheck
parameter_list|(
name|PORT
name|base
parameter_list|,
name|BYTE
name|no_ports
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BYTE
name|IwavePnpGetCSN
parameter_list|(
name|DWORD
name|VendorID
parameter_list|,
name|BYTE
name|csn_max
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BYTE
name|IwavePnpPing
parameter_list|(
name|DWORD
name|VendorID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|WORD
name|IwaveMemSize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|BYTE
name|IwaveMemPeek
parameter_list|(
name|ADDRESS
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwaveMemPoke
parameter_list|(
name|ADDRESS
name|addr
parameter_list|,
name|BYTE
name|datum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwaveMemCfg
parameter_list|(
name|DWORD
modifier|*
name|lpbanks
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwaveCodecIrq
parameter_list|(
name|BYTE
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|WORD
name|IwaveRegPeek
parameter_list|(
name|DWORD
name|reg_mnem
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwaveRegPoke
parameter_list|(
name|DWORD
name|reg_mnem
parameter_list|,
name|WORD
name|datum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwaveCodecMode
parameter_list|(
name|char
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|IwaveLineMute
parameter_list|(
name|BYTE
name|mute
parameter_list|,
name|BYTE
name|inx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|Iwaveinitcodec
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|IwaveOpen
parameter_list|(
name|char
name|voices
parameter_list|,
name|char
name|mode
parameter_list|,
name|struct
name|address_info
modifier|*
name|hw
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|reset_sample_memory
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_SAMPLE
condition|;
name|i
operator|++
control|)
name|sample_ptrs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|sample_map
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|patch_map
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|gus_poke
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put a silent sample to the beginning */
name|gus_poke
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_mem_ptr
operator|=
literal|2
expr_stmt|;
name|free_sample
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PATCH
condition|;
name|i
operator|++
control|)
name|patch_table
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gus_delay
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|inb
argument_list|(
name|u_DRAMIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_poke
parameter_list|(
name|long
name|addr
parameter_list|,
name|u_char
name|data
parameter_list|)
block|{
comment|/* Writes a byte to the DRAM */
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|u_Command
argument_list|,
literal|0x43
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|u_DataLo
argument_list|,
name|addr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|u_DataHi
argument_list|,
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|u_Command
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|u_DataHi
argument_list|,
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|u_DRAMIO
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_char
name|gus_peek
parameter_list|(
name|long
name|addr
parameter_list|)
block|{
comment|/* Reads a byte from the DRAM */
name|u_long
name|flags
decl_stmt|;
name|u_char
name|tmp
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|u_Command
argument_list|,
literal|0x43
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|u_DataLo
argument_list|,
name|addr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|u_DataHi
argument_list|,
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|u_Command
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|u_DataHi
argument_list|,
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|inb
argument_list|(
name|u_DRAMIO
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
name|void
name|gus_write8
parameter_list|(
name|int
name|reg
parameter_list|,
name|u_int
name|data
parameter_list|)
block|{
comment|/* Writes to an indirect register (8 bit) */
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|u_Command
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|u_DataHi
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|data
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_char
name|gus_read8
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
comment|/* Reads from an indirect register (8 bit). Offset 0x80. */
name|u_long
name|flags
decl_stmt|;
name|u_char
name|val
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|u_Command
argument_list|,
name|reg
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|u_DataHi
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|u_char
name|gus_look8
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
comment|/* Reads from an indirect register (8 bit). No additional offset. */
name|u_long
name|flags
decl_stmt|;
name|u_char
name|val
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|u_Command
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|u_DataHi
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|gus_write16
parameter_list|(
name|int
name|reg
parameter_list|,
name|u_int
name|data
parameter_list|)
block|{
comment|/* Writes to an indirect register (16 bit) */
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|u_Command
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|u_DataLo
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|data
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|u_DataHi
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_short
name|gus_read16
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
comment|/* Reads from an indirect register (16 bit). Offset 0x80. */
name|u_long
name|flags
decl_stmt|;
name|u_char
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|u_Command
argument_list|,
name|reg
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|lo
operator|=
name|inb
argument_list|(
name|u_DataLo
argument_list|)
expr_stmt|;
name|hi
operator|=
name|inb
argument_list|(
name|u_DataHi
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|hi
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
operator||
name|lo
return|;
block|}
end_function

begin_function
name|void
name|gus_write_addr
parameter_list|(
name|int
name|reg
parameter_list|,
name|u_long
name|address
parameter_list|,
name|int
name|is16bit
parameter_list|)
block|{
comment|/* Writes an 24 bit memory address */
name|u_long
name|hold_address
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|is16bit
condition|)
block|{
comment|/* 	 * Special processing required for 16 bit patches 	 */
name|hold_address
operator|=
name|address
expr_stmt|;
name|address
operator|=
name|address
operator|>>
literal|1
expr_stmt|;
name|address
operator|&=
literal|0x0001ffffL
expr_stmt|;
name|address
operator||=
operator|(
name|hold_address
operator|&
literal|0x000c0000L
operator|)
expr_stmt|;
block|}
name|gus_write16
argument_list|(
name|reg
argument_list|,
call|(
name|u_short
call|)
argument_list|(
operator|(
name|address
operator|>>
literal|7
operator|)
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
name|gus_write16
argument_list|(
name|reg
operator|+
literal|1
argument_list|,
call|(
name|u_short
call|)
argument_list|(
operator|(
name|address
operator|<<
literal|9
operator|)
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Could writing twice fix problems with GUS_VOICE_POS() ? Lets try...      */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write16
argument_list|(
name|reg
argument_list|,
call|(
name|u_short
call|)
argument_list|(
operator|(
name|address
operator|>>
literal|7
operator|)
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
name|gus_write16
argument_list|(
name|reg
operator|+
literal|1
argument_list|,
call|(
name|u_short
call|)
argument_list|(
operator|(
name|address
operator|<<
literal|9
operator|)
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_select_voice
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>
literal|31
condition|)
return|return;
name|outb
argument_list|(
name|u_Voice
argument_list|,
name|voice
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_select_max_voices
parameter_list|(
name|int
name|nvoices
parameter_list|)
block|{
if|if
condition|(
name|nvoices
operator|<
literal|14
condition|)
name|nvoices
operator|=
literal|14
expr_stmt|;
if|if
condition|(
name|nvoices
operator|>
literal|32
condition|)
name|nvoices
operator|=
literal|32
expr_stmt|;
name|voice_alloc
operator|->
name|max_voice
operator|=
name|nr_voices
operator|=
name|nvoices
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x0e
argument_list|,
operator|(
name|nvoices
operator|-
literal|1
operator|)
operator||
literal|0xc0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_on
parameter_list|(
name|u_int
name|mode
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|mode
operator|&
literal|0xfc
argument_list|)
argument_list|)
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|mode
operator|&
literal|0xfc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_off
parameter_list|(
name|void
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
operator||
literal|0x03
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_mode
parameter_list|(
name|u_int
name|m
parameter_list|)
block|{
name|u_char
name|mode
init|=
call|(
name|u_char
call|)
argument_list|(
name|m
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
operator|(
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
operator|&
literal|0x03
operator|)
operator||
operator|(
name|mode
operator|&
literal|0xfc
operator|)
argument_list|)
expr_stmt|;
comment|/* Don't touch last two bits */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
operator|(
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
operator|&
literal|0x03
operator|)
operator||
operator|(
name|mode
operator|&
literal|0xfc
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_freq
parameter_list|(
name|u_long
name|freq
parameter_list|)
block|{
name|u_long
name|divisor
init|=
name|freq_div_table
index|[
name|nr_voices
operator|-
literal|14
index|]
decl_stmt|;
name|u_short
name|fc
decl_stmt|;
name|fc
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
operator|(
name|freq
operator|<<
literal|9
operator|)
operator|+
operator|(
name|divisor
operator|>>
literal|1
operator|)
operator|)
operator|/
name|divisor
argument_list|)
expr_stmt|;
name|fc
operator|=
name|fc
operator|<<
literal|1
expr_stmt|;
name|gus_write16
argument_list|(
literal|0x01
argument_list|,
name|fc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_volume
parameter_list|(
name|u_int
name|vol
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Stop ramp before setting volume */
name|gus_write16
argument_list|(
literal|0x09
argument_list|,
call|(
name|u_short
call|)
argument_list|(
name|vol
operator|<<
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_balance
parameter_list|(
name|u_int
name|balance
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x0c
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|balance
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_ramp_range
parameter_list|(
name|u_int
name|low
parameter_list|,
name|u_int
name|high
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x07
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|low
operator|>>
literal|4
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x08
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
name|high
operator|>>
literal|4
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_ramp_rate
parameter_list|(
name|u_int
name|scale
parameter_list|,
name|u_int
name|rate
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x06
argument_list|,
call|(
name|u_char
call|)
argument_list|(
operator|(
operator|(
name|scale
operator|&
literal|0x03
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|rate
operator|&
literal|0x3f
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_rampon
parameter_list|(
name|u_int
name|m
parameter_list|)
block|{
name|u_char
name|mode
init|=
call|(
name|u_char
call|)
argument_list|(
name|m
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
name|mode
operator|&
literal|0xfc
argument_list|)
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
name|mode
operator|&
literal|0xfc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_ramp_mode
parameter_list|(
name|u_int
name|m
parameter_list|)
block|{
name|u_char
name|mode
init|=
call|(
name|u_char
call|)
argument_list|(
name|m
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
operator|(
name|gus_read8
argument_list|(
literal|0x0d
argument_list|)
operator|&
literal|0x03
operator|)
operator||
operator|(
name|mode
operator|&
literal|0xfc
operator|)
argument_list|)
expr_stmt|;
comment|/* Leave the last 2 bits alone */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
operator|(
name|gus_read8
argument_list|(
literal|0x0d
argument_list|)
operator|&
literal|0x03
operator|)
operator||
operator|(
name|mode
operator|&
literal|0xfc
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_rampoff
parameter_list|(
name|void
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_set_voice_pos
parameter_list|(
name|int
name|voice
parameter_list|,
name|long
name|position
parameter_list|)
block|{
name|int
name|sample_no
decl_stmt|;
if|if
condition|(
operator|(
name|sample_no
operator|=
name|sample_map
index|[
name|voice
index|]
operator|)
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|position
operator|<
name|samples
index|[
name|sample_no
index|]
operator|.
name|len
condition|)
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|==
name|VMODE_START_NOTE
condition|)
name|voices
index|[
name|voice
index|]
operator|.
name|offset_pending
operator|=
name|position
expr_stmt|;
else|else
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
name|sample_ptrs
index|[
name|sample_no
index|]
operator|+
name|position
argument_list|,
name|samples
index|[
name|sample_no
index|]
operator|.
name|mode
operator|&
name|WAVE_16_BITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_init
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_volume
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set current position to 0 */
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Voice off */
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Ramping off */
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
name|voice_alloc
operator|->
name|alloc_times
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_init2
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
operator|=
literal|20000
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
literal|20000
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
literal|200
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_parm
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_parm
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
operator|=
literal|127
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|patch_vol
operator|=
literal|127
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
operator|=
literal|127
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|step_envelope
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|u_int
name|vol
decl_stmt|,
name|prev_vol
decl_stmt|,
name|phase
decl_stmt|;
name|u_char
name|rate
decl_stmt|;
name|long
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_SUSTAIN_ON
operator|&&
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|==
literal|2
condition|)
block|{
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return;
comment|/* 	 * Sustain phase begins. Continue envelope after receiving 	 * note off. 	 */
block|}
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|>=
literal|5
condition|)
block|{
comment|/* Envelope finished. Shoot 					 * the voice down */
name|gus_voice_init
argument_list|(
name|voice
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev_vol
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
expr_stmt|;
name|phase
operator|=
operator|++
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
expr_stmt|;
name|compute_volume
argument_list|(
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|)
expr_stmt|;
name|vol
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|*
name|voices
index|[
name|voice
index|]
operator|.
name|env_offset
index|[
name|phase
index|]
operator|/
literal|255
expr_stmt|;
name|rate
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|env_rate
index|[
name|phase
index|]
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_volume
argument_list|(
name|prev_vol
argument_list|)
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x06
argument_list|,
name|rate
argument_list|)
expr_stmt|;
comment|/* Ramping rate */
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
name|VMODE_ENVELOPE
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|vol
operator|-
name|prev_vol
operator|)
operator|/
literal|64
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* No significant volume 					 * change */
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|step_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
comment|/* Continue the envelope on the next 				 * step */
return|return;
block|}
if|if
condition|(
name|vol
operator|>
name|prev_vol
condition|)
block|{
if|if
condition|(
name|vol
operator|>=
operator|(
literal|4096
operator|-
literal|64
operator|)
condition|)
name|vol
operator|=
literal|4096
operator|-
literal|65
expr_stmt|;
name|gus_ramp_range
argument_list|(
literal|0
argument_list|,
name|vol
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x20
argument_list|)
expr_stmt|;
comment|/* Increasing volume, with IRQ */
block|}
else|else
block|{
if|if
condition|(
name|vol
operator|<=
literal|64
condition|)
name|vol
operator|=
literal|65
expr_stmt|;
name|gus_ramp_range
argument_list|(
name|vol
argument_list|,
literal|4030
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x60
argument_list|)
expr_stmt|;
comment|/* Decreasing volume, with IRQ */
block|}
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
name|vol
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_envelope
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|=
operator|-
literal|1
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
literal|64
expr_stmt|;
name|step_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_release
parameter_list|(
name|int
name|voice
parameter_list|,
name|long
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
operator|&
literal|0x03
condition|)
return|return;
comment|/* Voice already stopped */
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|=
literal|2
expr_stmt|;
comment|/* Will be incremented by 				     * step_envelope */
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
expr_stmt|;
comment|/* Get current volume */
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&=
operator|~
name|WAVE_SUSTAIN_ON
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|step_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_fade
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|int
name|instr_no
init|=
name|sample_map
index|[
name|voice
index|]
decl_stmt|,
name|is16bits
decl_stmt|;
name|long
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
if|if
condition|(
name|instr_no
operator|<
literal|0
operator|||
name|instr_no
operator|>
name|MAX_SAMPLE
condition|)
block|{
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Hard stop */
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|is16bits
operator|=
operator|(
name|samples
index|[
name|instr_no
index|]
operator|.
name|mode
operator|&
name|WAVE_16_BITS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 8 or 16 bits */
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|start_release
argument_list|(
name|voice
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * Ramp the volume down but not too quickly.      */
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
argument_list|)
operator|<
literal|100
condition|)
block|{
comment|/* Get current volume */
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_init
argument_list|(
name|voice
argument_list|)
expr_stmt|;
return|return;
block|}
name|gus_ramp_range
argument_list|(
literal|65
argument_list|,
literal|4030
argument_list|)
expr_stmt|;
name|gus_ramp_rate
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x40
operator||
literal|0x20
argument_list|)
expr_stmt|;
comment|/* Down, once, with IRQ */
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
name|VMODE_HALT
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_reset
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gus_select_max_voices
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|volume_base
operator|=
literal|3071
expr_stmt|;
name|volume_scale
operator|=
literal|4
expr_stmt|;
name|volume_method
operator|=
name|VOL_METHOD_ADAGIO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|gus_voice_init
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Turn voice off */
name|gus_voice_init2
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
name|u_Status
argument_list|)
expr_stmt|;
comment|/* Touch the status register */
name|gus_look8
argument_list|(
literal|0x41
argument_list|)
expr_stmt|;
comment|/* Clear any pending DMA IRQs */
name|gus_look8
argument_list|(
literal|0x49
argument_list|)
expr_stmt|;
comment|/* Clear any pending sample IRQs */
name|gus_read8
argument_list|(
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* Clear pending IRQs */
block|}
end_function

begin_function
specifier|static
name|void
name|gus_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|u_char
name|dma_image
decl_stmt|,
name|irq_image
decl_stmt|,
name|tmp
decl_stmt|;
specifier|static
name|u_char
name|gus_irq_map
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|,
literal|7
block|}
decl_stmt|;
specifier|static
name|u_char
name|gus_dma_map
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset GF1 */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Release Reset */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
comment|/*      * Clear all interrupts      */
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DMA control */
name|gus_write8
argument_list|(
literal|0x45
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Timer control */
name|gus_write8
argument_list|(
literal|0x49
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Sample control */
name|gus_select_max_voices
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|u_Status
argument_list|)
expr_stmt|;
comment|/* Touch the status register */
name|gus_look8
argument_list|(
literal|0x41
argument_list|)
expr_stmt|;
comment|/* Clear any pending DMA IRQs */
name|gus_look8
argument_list|(
literal|0x49
argument_list|)
expr_stmt|;
comment|/* Clear any pending sample IRQs */
name|gus_read8
argument_list|(
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* Clear pending IRQs */
name|gus_reset
argument_list|()
expr_stmt|;
comment|/* Resets all voices */
name|gus_look8
argument_list|(
literal|0x41
argument_list|)
expr_stmt|;
comment|/* Clear any pending DMA IRQs */
name|gus_look8
argument_list|(
literal|0x49
argument_list|)
expr_stmt|;
comment|/* Clear any pending sample IRQs */
name|gus_read8
argument_list|(
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* Clear pending IRQs */
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* Master reset | DAC enable | IRQ enable */
comment|/*      * Set up for Digital ASIC      */
name|outb
argument_list|(
name|gus_base
operator|+
literal|0x0f
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|mix_image
operator||=
literal|0x02
expr_stmt|;
comment|/* Disable line out (for a moment) */
name|outb
argument_list|(
name|u_Mixer
argument_list|,
name|mix_image
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|u_IRQDMAControl
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|gus_base
operator|+
literal|0x0f
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*      * Now set up the DMA and IRQ interface      *       * The GUS supports two IRQs and two DMAs.      *       * Just one DMA channel is used. This prevents simultaneous ADC and DAC.      * Adding this support requires significant changes to the dmabuf.c,      * dsp.c and audio.c also.      */
name|irq_image
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|gus_irq_map
index|[
name|gus_irq
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|printf
argument_list|(
literal|"Warning! GUS IRQ not selected\n"
argument_list|)
expr_stmt|;
name|irq_image
operator||=
name|tmp
expr_stmt|;
name|irq_image
operator||=
literal|0x40
expr_stmt|;
comment|/* Combine IRQ1 (GF1) and IRQ2 (Midi) */
name|dual_dma_mode
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|gus_dma2
operator|==
name|gus_dma
operator|||
name|gus_dma2
operator|==
operator|-
literal|1
condition|)
block|{
name|dual_dma_mode
operator|=
literal|0
expr_stmt|;
name|dma_image
operator|=
literal|0x40
expr_stmt|;
comment|/* Combine DMA1 (DRAM) and IRQ2 (ADC) */
name|tmp
operator|=
name|gus_dma_map
index|[
name|gus_dma
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|printf
argument_list|(
literal|"Warning! GUS DMA not selected\n"
argument_list|)
expr_stmt|;
name|dma_image
operator||=
name|tmp
expr_stmt|;
block|}
else|else
comment|/* Setup dual DMA channel mode for GUS MAX */
block|{
name|dma_image
operator|=
name|gus_dma_map
index|[
name|gus_dma
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|dma_image
condition|)
name|printf
argument_list|(
literal|"Warning! GUS DMA not selected\n"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gus_dma_map
index|[
name|gus_dma2
index|]
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|printf
argument_list|(
literal|"Warning! Invalid GUS MAX DMA\n"
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0x40
expr_stmt|;
comment|/* Combine DMA channels */
name|dual_dma_mode
operator|=
literal|0
expr_stmt|;
block|}
name|dma_image
operator||=
name|tmp
expr_stmt|;
block|}
comment|/*      * For some reason the IRQ and DMA addresses must be written twice      */
comment|/*      * Doing it first time      */
name|outb
argument_list|(
name|u_Mixer
argument_list|,
name|mix_image
argument_list|)
expr_stmt|;
comment|/* Select DMA control */
name|outb
argument_list|(
name|u_IRQDMAControl
argument_list|,
name|dma_image
operator||
literal|0x80
argument_list|)
expr_stmt|;
comment|/* Set DMA address */
name|outb
argument_list|(
name|u_Mixer
argument_list|,
name|mix_image
operator||
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Select IRQ control */
name|outb
argument_list|(
name|u_IRQDMAControl
argument_list|,
name|irq_image
argument_list|)
expr_stmt|;
comment|/* Set IRQ address */
comment|/*      * Doing it second time      */
name|outb
argument_list|(
name|u_Mixer
argument_list|,
name|mix_image
argument_list|)
expr_stmt|;
comment|/* Select DMA control */
name|outb
argument_list|(
name|u_IRQDMAControl
argument_list|,
name|dma_image
argument_list|)
expr_stmt|;
comment|/* Set DMA address */
name|outb
argument_list|(
name|u_Mixer
argument_list|,
name|mix_image
operator||
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Select IRQ control */
name|outb
argument_list|(
name|u_IRQDMAControl
argument_list|,
name|irq_image
argument_list|)
expr_stmt|;
comment|/* Set IRQ address */
name|gus_select_voice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This disables writes to IRQ/DMA reg */
name|mix_image
operator|&=
operator|~
literal|0x02
expr_stmt|;
comment|/* Enable line out */
name|mix_image
operator||=
literal|0x08
expr_stmt|;
comment|/* Enable IRQ */
name|outb
argument_list|(
name|u_Mixer
argument_list|,
name|mix_image
argument_list|)
expr_stmt|;
comment|/* Turn mixer channels on Note! Mic 				 * in is left off. */
name|gus_select_voice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This disables writes to IRQ/DMA reg */
name|gusintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Serve pending interrupts */
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gus_wave_detect
parameter_list|(
name|int
name|baseaddr
parameter_list|)
block|{
name|u_long
name|i
decl_stmt|;
name|u_long
name|loc
decl_stmt|;
name|gus_base
operator|=
name|baseaddr
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset GF1 */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Release Reset */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
comment|/* See if there is first block there.... */
name|gus_poke
argument_list|(
literal|0L
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_peek
argument_list|(
literal|0L
argument_list|)
operator|!=
literal|0xaa
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Now zero it out so that I can check for mirroring .. */
name|gus_poke
argument_list|(
literal|0L
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1L
init|;
name|i
operator|<
literal|1024L
condition|;
name|i
operator|++
control|)
block|{
name|int
name|n
decl_stmt|,
name|failed
decl_stmt|;
comment|/* check for mirroring ... */
if|if
condition|(
name|gus_peek
argument_list|(
literal|0L
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|loc
operator|=
name|i
operator|<<
literal|10
expr_stmt|;
for|for
control|(
name|n
operator|=
name|loc
operator|-
literal|1
operator|,
name|failed
operator|=
literal|0
init|;
name|n
operator|<=
name|loc
condition|;
name|n
operator|++
control|)
block|{
name|gus_poke
argument_list|(
name|loc
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_peek
argument_list|(
name|loc
argument_list|)
operator|!=
literal|0xaa
condition|)
name|failed
operator|=
literal|1
expr_stmt|;
name|gus_poke
argument_list|(
name|loc
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_peek
argument_list|(
name|loc
argument_list|)
operator|!=
literal|0x55
condition|)
name|failed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|failed
condition|)
break|break;
block|}
name|gus_mem_size
operator|=
name|i
operator|<<
literal|10
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|ioctl_arg
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_SYNTH_INFO
case|:
name|gus_info
operator|.
name|nr_voices
operator|=
name|nr_voices
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|gus_info
argument_list|,
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|gus_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_RESETSAMPLES
case|:
name|reset_sample_memory
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_PERCMODE
case|:
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
return|return
name|gus_mem_size
operator|-
name|free_mem_ptr
operator|-
literal|32
return|;
default|default:
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_set_instr
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|instr_no
parameter_list|)
block|{
name|int
name|sample_no
decl_stmt|;
if|if
condition|(
name|instr_no
operator|<
literal|0
operator|||
name|instr_no
operator|>
name|MAX_PATCH
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>
literal|31
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|==
name|VMODE_START_NOTE
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
operator|=
name|instr_no
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sample_no
operator|=
name|patch_table
index|[
name|instr_no
index|]
expr_stmt|;
name|patch_map
index|[
name|voice
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sample_no
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"GUS: Undefined patch %d for voice %d\n"
argument_list|,
name|instr_no
argument_list|,
name|voice
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
comment|/* Patch not defined */
block|}
if|if
condition|(
name|sample_ptrs
index|[
name|sample_no
index|]
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Sample not loaded */
name|printf
argument_list|(
literal|"GUS: Sample #%d not loaded for patch %d (voice %d)\n"
argument_list|,
name|sample_no
argument_list|,
name|instr_no
argument_list|,
name|voice
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sample_map
index|[
name|voice
index|]
operator|=
name|sample_no
expr_stmt|;
name|patch_map
index|[
name|voice
index|]
operator|=
name|instr_no
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_kill_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* voice_alloc->map[voice] = 0xffff; */
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|==
name|VMODE_START_NOTE
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|kill_pending
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_voice_fade
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_aftertouch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|pressure
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|guswave_panning
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|voice
operator|>=
literal|0
operator|||
name|voice
operator|<
literal|32
condition|)
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_volume_method
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|VOL_METHOD_LINEAR
operator|||
name|mode
operator|==
name|VOL_METHOD_ADAGIO
condition|)
name|volume_method
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_function
name|void
name|compute_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
if|if
condition|(
name|volume
operator|<
literal|128
condition|)
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
operator|=
name|volume
expr_stmt|;
switch|switch
condition|(
name|volume_method
condition|)
block|{
case|case
name|VOL_METHOD_ADAGIO
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|gus_adagio_vol
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|patch_vol
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOL_METHOD_LINEAR
case|:
comment|/* Totally ignores patch-volume and expression */
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|gus_linear_vol
argument_list|(
name|volume
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
argument_list|)
expr_stmt|;
break|break;
default|default:
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|volume_base
operator|+
operator|(
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
operator|*
name|volume_scale
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|>
literal|4030
condition|)
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
literal|4030
expr_stmt|;
block|}
end_function

begin_function
name|void
name|compute_and_set_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|,
name|int
name|ramp_time
parameter_list|)
block|{
name|int
name|curr
decl_stmt|,
name|target
decl_stmt|,
name|rate
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|compute_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/*      * CAUTION! Interrupts disabled. Enable them before returning      */
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|curr
operator|=
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
expr_stmt|;
name|target
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
expr_stmt|;
if|if
condition|(
name|ramp_time
operator|==
name|INSTANT_RAMP
condition|)
block|{
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_volume
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ramp_time
operator|==
name|FAST_RAMP
condition|)
name|rate
operator|=
literal|63
expr_stmt|;
else|else
name|rate
operator|=
literal|16
expr_stmt|;
name|gus_ramp_rate
argument_list|(
literal|0
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|-
name|curr
operator|)
operator|/
literal|64
operator|==
literal|0
condition|)
block|{
comment|/* Close enough to target. */
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_volume
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|target
operator|>
name|curr
condition|)
block|{
if|if
condition|(
name|target
operator|>
operator|(
literal|4095
operator|-
literal|65
operator|)
condition|)
name|target
operator|=
literal|4095
operator|-
literal|65
expr_stmt|;
name|gus_ramp_range
argument_list|(
name|curr
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Ramp up, once, no IRQ */
block|}
else|else
block|{
if|if
condition|(
name|target
operator|<
literal|65
condition|)
name|target
operator|=
literal|65
expr_stmt|;
name|gus_ramp_range
argument_list|(
name|target
argument_list|,
name|curr
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Ramp down, once, no irq */
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dynamic_volume_change
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|u_char
name|status
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|status
operator|=
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Get voice status */
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x03
condition|)
return|return;
comment|/* Voice was not running */
if|if
condition|(
operator|!
operator|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
operator|)
condition|)
block|{
name|compute_and_set_volume
argument_list|(
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Voice is running and has envelopes. 	 */
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|status
operator|=
name|gus_read8
argument_list|(
literal|0x0d
argument_list|)
expr_stmt|;
comment|/* Ramping status */
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x03
condition|)
block|{
comment|/* Sustain phase? */
name|compute_and_set_volume
argument_list|(
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|<
literal|0
condition|)
return|return;
name|compute_volume
argument_list|(
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_controller
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|ctrl_num
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|u_long
name|freq
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>
literal|31
condition|)
return|return;
switch|switch
condition|(
name|ctrl_num
condition|)
block|{
case|case
name|CTRL_PITCH_BENDER
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|!=
name|VMODE_START_NOTE
condition|)
block|{
name|freq
operator|=
name|compute_finetune
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|value
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|freq
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_freq
argument_list|(
name|freq
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTRL_PITCH_BENDER_RANGE
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|CTL_EXPRESSION
case|:
name|value
operator|/=
literal|128
expr_stmt|;
case|case
name|CTRL_EXPRESSION
case|:
if|if
condition|(
name|volume_method
operator|==
name|VOL_METHOD_ADAGIO
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|!=
name|VMODE_START_NOTE
condition|)
name|dynamic_volume_change
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTL_PAN
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
operator|(
name|value
operator|*
literal|2
operator|)
operator|-
literal|128
expr_stmt|;
break|break;
case|case
name|CTL_MAIN_VOLUME
case|:
name|value
operator|=
operator|(
name|value
operator|*
literal|100
operator|)
operator|/
literal|16383
expr_stmt|;
case|case
name|CTRL_MAIN_VOLUME
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|!=
name|VMODE_START_NOTE
condition|)
name|dynamic_volume_change
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|int
name|guswave_start_note2
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note_num
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
name|int
name|sample
decl_stmt|,
name|best_sample
decl_stmt|,
name|best_delta
decl_stmt|,
name|delta_freq
decl_stmt|;
name|int
name|is16bits
decl_stmt|,
name|samplep
decl_stmt|,
name|patch
decl_stmt|,
name|pan
decl_stmt|;
name|u_long
name|note_freq
decl_stmt|,
name|base_note
decl_stmt|,
name|freq
decl_stmt|,
name|flags
decl_stmt|;
name|u_char
name|mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>
literal|31
condition|)
block|{
name|printf
argument_list|(
literal|"GUS: Invalid voice\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|note_num
operator|==
literal|255
condition|)
block|{
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
operator|=
name|volume
expr_stmt|;
name|dynamic_volume_change
argument_list|(
name|voice
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|compute_and_set_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|patch
operator|=
name|patch_map
index|[
name|voice
index|]
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|samplep
operator|=
name|patch_table
index|[
name|patch
index|]
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
name|note_freq
operator|=
name|note_to_freq
argument_list|(
name|note_num
argument_list|)
expr_stmt|;
comment|/*      * Find a sample within a patch so that the note_freq is between      * low_note and high_note.      */
name|sample
operator|=
operator|-
literal|1
expr_stmt|;
name|best_sample
operator|=
name|samplep
expr_stmt|;
name|best_delta
operator|=
literal|1000000
expr_stmt|;
while|while
condition|(
name|samplep
operator|>=
literal|0
operator|&&
name|sample
operator|==
operator|-
literal|1
condition|)
block|{
name|dbg_samples
operator|=
name|samples
expr_stmt|;
name|dbg_samplep
operator|=
name|samplep
expr_stmt|;
name|delta_freq
operator|=
name|note_freq
operator|-
name|samples
index|[
name|samplep
index|]
operator|.
name|base_note
expr_stmt|;
if|if
condition|(
name|delta_freq
operator|<
literal|0
condition|)
name|delta_freq
operator|=
operator|-
name|delta_freq
expr_stmt|;
if|if
condition|(
name|delta_freq
operator|<
name|best_delta
condition|)
block|{
name|best_sample
operator|=
name|samplep
expr_stmt|;
name|best_delta
operator|=
name|delta_freq
expr_stmt|;
block|}
if|if
condition|(
name|samples
index|[
name|samplep
index|]
operator|.
name|low_note
operator|<=
name|note_freq
operator|&&
name|note_freq
operator|<=
name|samples
index|[
name|samplep
index|]
operator|.
name|high_note
condition|)
name|sample
operator|=
name|samplep
expr_stmt|;
else|else
name|samplep
operator|=
name|samples
index|[
name|samplep
index|]
operator|.
name|key
expr_stmt|;
comment|/* Follow link */
block|}
if|if
condition|(
name|sample
operator|==
operator|-
literal|1
condition|)
name|sample
operator|=
name|best_sample
expr_stmt|;
if|if
condition|(
name|sample
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"GUS: Patch %d not defined for note %d\n"
argument_list|,
name|patch
argument_list|,
name|note_num
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Should play default patch ??? */
block|}
name|is16bits
operator|=
operator|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_16_BITS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|mode
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|patch_vol
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|volume
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|env_rate
index|[
name|i
index|]
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|env_rate
index|[
name|i
index|]
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|env_offset
index|[
name|i
index|]
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|env_offset
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|sample_map
index|[
name|voice
index|]
operator|=
name|sample
expr_stmt|;
name|base_note
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|base_note
operator|/
literal|100
expr_stmt|;
comment|/* Try to avoid overflows */
name|note_freq
operator|/=
literal|100
expr_stmt|;
name|freq
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|base_freq
operator|*
name|note_freq
operator|/
name|base_note
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
operator|=
name|freq
expr_stmt|;
comment|/*      * Since the pitch bender may have been set before playing the note,      * we have to calculate the bending now.      */
name|freq
operator|=
name|compute_finetune
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|freq
expr_stmt|;
name|pan
operator|=
operator|(
name|samples
index|[
name|sample
index|]
operator|.
name|panning
operator|+
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|)
operator|/
literal|32
expr_stmt|;
name|pan
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|pan
operator|<
literal|0
condition|)
name|pan
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pan
operator|>
literal|15
condition|)
name|pan
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_16_BITS
condition|)
block|{
name|mode
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bits */
if|if
condition|(
operator|(
name|sample_ptrs
index|[
name|sample
index|]
operator|>>
literal|18
operator|)
operator|!=
operator|(
operator|(
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|len
operator|)
operator|>>
literal|18
operator|)
condition|)
name|printf
argument_list|(
literal|"GUS: Sample address error\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      *    CAUTION!        Interrupts disabled. Don't return before enabling      */
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|compute_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|init_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|compute_and_set_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_LOOP_BACK
condition|)
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|len
operator|-
name|voices
index|[
name|voice
index|]
operator|.
name|offset_pending
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* start=end */
else|else
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|voices
index|[
name|voice
index|]
operator|.
name|offset_pending
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Sample start=begin */
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_LOOPING
condition|)
block|{
name|mode
operator||=
literal|0x08
expr_stmt|;
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_BIDIR_LOOP
condition|)
name|mode
operator||=
literal|0x10
expr_stmt|;
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_LOOP_BACK
condition|)
block|{
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|loop_end
operator|-
name|voices
index|[
name|voice
index|]
operator|.
name|offset_pending
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
name|mode
operator||=
literal|0x40
expr_stmt|;
block|}
name|gus_write_addr
argument_list|(
literal|0x02
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|loop_start
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop start location */
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|loop_end
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
block|}
else|else
block|{
name|mode
operator||=
literal|0x20
expr_stmt|;
comment|/* Loop IRQ at the end */
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
operator|=
name|LMODE_FINISH
expr_stmt|;
comment|/* Ramp down at the end */
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_parm
operator|=
literal|1
expr_stmt|;
name|gus_write_addr
argument_list|(
literal|0x02
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop start location */
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|len
operator|-
literal|1
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
block|}
name|gus_voice_freq
argument_list|(
name|freq
argument_list|)
expr_stmt|;
name|gus_voice_balance
argument_list|(
name|pan
argument_list|)
expr_stmt|;
name|gus_voice_on
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * New guswave_start_note by Andrew J. Robinson attempts to minimize clicking  * when the note playing on the voice is changed.  It uses volume ramping.  */
end_comment

begin_function
specifier|static
name|int
name|guswave_start_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note_num
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
name|long
name|int
name|flags
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|ret_val
init|=
literal|0
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|note_num
operator|==
literal|255
condition|)
block|{
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|==
name|VMODE_START_NOTE
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|volume_pending
operator|=
name|volume
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
name|guswave_start_note2
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|note_num
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|mode
operator|=
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
literal|0x20
condition|)
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
name|mode
operator|&
literal|0xdf
argument_list|)
expr_stmt|;
comment|/* No interrupt! */
name|voices
index|[
name|voice
index|]
operator|.
name|offset_pending
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|kill_pending
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
operator|>=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* Run temporarily with interrupts 				 * enabled */
name|guswave_set_instr
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|dev_pending
argument_list|,
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
operator|=
operator|-
literal|1
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
comment|/* Reselect the voice 					 * (just to be sure) */
block|}
if|if
condition|(
operator|(
name|mode
operator|&
literal|0x01
operator|)
operator|||
call|(
name|int
call|)
argument_list|(
operator|(
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
operator|)
operator|<
literal|2065
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|guswave_start_note2
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|note_num
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|dev_pending
operator|=
name|dev
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|note_pending
operator|=
name|note_num
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_pending
operator|=
name|volume
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
name|VMODE_START_NOTE
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_ramp_range
argument_list|(
literal|2000
argument_list|,
literal|4065
argument_list|)
expr_stmt|;
name|gus_ramp_rate
argument_list|(
literal|0
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/* Fastest possible rate */
name|gus_rampon
argument_list|(
literal|0x20
operator||
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Ramp down, once, irq */
block|}
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_reset
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|gus_voice_init
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|gus_voice_init2
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|otherside
init|=
name|audio_devs
index|[
name|dev
index|]
operator|->
name|otherside
decl_stmt|;
if|if
condition|(
name|otherside
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|audio_devs
index|[
name|otherside
index|]
operator|->
name|busy
condition|)
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|audio_devs
index|[
name|dev
index|]
operator|->
name|busy
condition|)
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
name|gus_initialize
argument_list|()
expr_stmt|;
name|voice_alloc
operator|->
name|timestamp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|DMAbuf_open_dma
argument_list|(
name|gus_devnum
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"GUS: Loading saples without DMA\n"
argument_list|)
expr_stmt|;
name|gus_no_dma
operator|=
literal|1
expr_stmt|;
comment|/* Upload samples using PIO */
block|}
else|else
name|gus_no_dma
operator|=
literal|0
expr_stmt|;
name|dram_sleep_flag
operator|.
name|aborting
operator|=
literal|0
expr_stmt|;
name|dram_sleep_flag
operator|.
name|mode
operator|=
name|WK_NONE
expr_stmt|;
name|active_device
operator|=
name|GUS_DEV_WAVE
expr_stmt|;
name|audio_devs
index|[
name|dev
index|]
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
name|gus_reset
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|otherside
init|=
name|audio_devs
index|[
name|dev
index|]
operator|->
name|otherside
decl_stmt|;
if|if
condition|(
name|otherside
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|audio_devs
index|[
name|otherside
index|]
operator|->
name|busy
condition|)
return|return;
block|}
name|audio_devs
index|[
name|dev
index|]
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
name|active_device
operator|=
literal|0
expr_stmt|;
name|gus_reset
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gus_no_dma
condition|)
name|DMAbuf_close_dma
argument_list|(
name|gus_devnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_load_patch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|format
parameter_list|,
name|snd_rw_buf
modifier|*
name|addr
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
block|{
name|struct
name|patch_info
name|patch
decl_stmt|;
name|int
name|instr
decl_stmt|;
name|long
name|sizeof_patch
decl_stmt|;
name|u_long
name|blk_size
decl_stmt|,
name|blk_end
decl_stmt|,
name|left
decl_stmt|,
name|src_offs
decl_stmt|,
name|target
decl_stmt|;
name|sizeof_patch
operator|=
operator|(
name|long
operator|)
operator|&
name|patch
operator|.
name|data
index|[
literal|0
index|]
operator|-
operator|(
name|long
operator|)
operator|&
name|patch
expr_stmt|;
comment|/* Header size */
if|if
condition|(
name|format
operator|!=
name|GUS_PATCH
condition|)
block|{
name|printf
argument_list|(
literal|"GUS Error: Invalid patch format (key) 0x%x\n"
argument_list|,
name|format
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|count
operator|<
name|sizeof_patch
condition|)
block|{
name|printf
argument_list|(
literal|"GUS Error: Patch header too short\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
name|count
operator|-=
name|sizeof_patch
expr_stmt|;
if|if
condition|(
name|free_sample
operator|>=
name|MAX_SAMPLE
condition|)
block|{
name|printf
argument_list|(
literal|"GUS: Sample table full\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|ENOSPC
operator|)
return|;
block|}
comment|/*      * Copy the header from user space but ignore the first bytes which      * have been transferred already.      */
if|if
condition|(
name|uiomove
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|patch
operator|)
index|[
name|offs
index|]
argument_list|,
name|sizeof_patch
operator|-
name|offs
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"audio: Bad copyin()!\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|instr
operator|=
name|patch
operator|.
name|instr_no
expr_stmt|;
if|if
condition|(
name|instr
operator|<
literal|0
operator|||
name|instr
operator|>
name|MAX_PATCH
condition|)
block|{
name|printf
argument_list|(
literal|"GUS: Invalid patch number %d\n"
argument_list|,
name|instr
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|count
operator|<
name|patch
operator|.
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"GUS Warning: Patch record too short (%d<%d)\n"
argument_list|,
name|count
argument_list|,
operator|(
name|int
operator|)
name|patch
operator|.
name|len
argument_list|)
expr_stmt|;
name|patch
operator|.
name|len
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|patch
operator|.
name|len
operator|<=
literal|0
operator|||
name|patch
operator|.
name|len
operator|>
name|gus_mem_size
condition|)
block|{
name|printf
argument_list|(
literal|"GUS: Invalid sample length %d\n"
argument_list|,
operator|(
name|int
operator|)
name|patch
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_LOOPING
condition|)
block|{
if|if
condition|(
name|patch
operator|.
name|loop_start
operator|<
literal|0
operator|||
name|patch
operator|.
name|loop_start
operator|>=
name|patch
operator|.
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"GUS: Invalid loop start\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|patch
operator|.
name|loop_end
operator|<
name|patch
operator|.
name|loop_start
operator|||
name|patch
operator|.
name|loop_end
operator|>
name|patch
operator|.
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"GUS: Invalid loop end\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|free_mem_ptr
operator|=
operator|(
name|free_mem_ptr
operator|+
literal|31
operator|)
operator|&
operator|~
literal|31
expr_stmt|;
comment|/* 32 byte alignment */
define|#
directive|define
name|GUS_BANK_SIZE
value|(256*1024)
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_16_BITS
condition|)
block|{
comment|/* 	 * 16 bit samples must fit one 256k bank. 	 */
if|if
condition|(
name|patch
operator|.
name|len
operator|>=
name|GUS_BANK_SIZE
condition|)
block|{
name|printf
argument_list|(
literal|"GUS: Sample (16 bit) too long %d\n"
argument_list|,
operator|(
name|int
operator|)
name|patch
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|ENOSPC
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|free_mem_ptr
operator|/
name|GUS_BANK_SIZE
operator|)
operator|!=
operator|(
operator|(
name|free_mem_ptr
operator|+
name|patch
operator|.
name|len
operator|)
operator|/
name|GUS_BANK_SIZE
operator|)
condition|)
block|{
name|u_long
name|tmp_mem
init|=
comment|/* Aligning to 256K */
operator|(
operator|(
name|free_mem_ptr
operator|/
name|GUS_BANK_SIZE
operator|)
operator|+
literal|1
operator|)
operator|*
name|GUS_BANK_SIZE
decl_stmt|;
if|if
condition|(
operator|(
name|tmp_mem
operator|+
name|patch
operator|.
name|len
operator|)
operator|>
name|gus_mem_size
condition|)
return|return
operator|-
operator|(
name|ENOSPC
operator|)
return|;
name|free_mem_ptr
operator|=
name|tmp_mem
expr_stmt|;
comment|/* This leaves unusable memory */
block|}
block|}
if|if
condition|(
operator|(
name|free_mem_ptr
operator|+
name|patch
operator|.
name|len
operator|)
operator|>
name|gus_mem_size
condition|)
return|return
operator|-
operator|(
name|ENOSPC
operator|)
return|;
name|sample_ptrs
index|[
name|free_sample
index|]
operator|=
name|free_mem_ptr
expr_stmt|;
comment|/*      * Tremolo is not possible with envelopes      */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
name|patch
operator|.
name|mode
operator|&=
operator|~
name|WAVE_TREMOLO
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|patch
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|samples
index|[
name|free_sample
index|]
argument_list|,
name|sizeof_patch
argument_list|)
expr_stmt|;
comment|/*      * Link this_one sample to the list of samples for patch 'instr'.      */
name|samples
index|[
name|free_sample
index|]
operator|.
name|key
operator|=
name|patch_table
index|[
name|instr
index|]
expr_stmt|;
name|patch_table
index|[
name|instr
index|]
operator|=
name|free_sample
expr_stmt|;
comment|/*      * Use DMA to transfer the wave data to the DRAM      */
name|left
operator|=
name|patch
operator|.
name|len
expr_stmt|;
name|src_offs
operator|=
literal|0
expr_stmt|;
name|target
operator|=
name|free_mem_ptr
expr_stmt|;
while|while
condition|(
name|left
condition|)
block|{
comment|/* Not completely transferred yet */
comment|/* blk_size = audio_devs[gus_devnum]->buffsize; */
name|blk_size
operator|=
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmap_out
operator|->
name|bytes_in_use
expr_stmt|;
if|if
condition|(
name|blk_size
operator|>
name|left
condition|)
name|blk_size
operator|=
name|left
expr_stmt|;
comment|/* 	 * DMA cannot cross 256k bank boundaries. Check for that. 	 */
name|blk_end
operator|=
name|target
operator|+
name|blk_size
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|>>
literal|18
operator|)
operator|!=
operator|(
name|blk_end
operator|>>
literal|18
operator|)
condition|)
block|{
comment|/* Split the block */
name|blk_end
operator|&=
operator|~
operator|(
literal|256
operator|*
literal|1024
operator|-
literal|1
operator|)
expr_stmt|;
name|blk_size
operator|=
name|blk_end
operator|-
name|target
expr_stmt|;
block|}
if|if
condition|(
name|gus_no_dma
condition|)
block|{
comment|/* 	     * For some reason the DMA is not possible. We have 	     * to use PIO. 	     */
name|long
name|i
decl_stmt|;
name|u_char
name|data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blk_size
condition|;
name|i
operator|++
control|)
block|{
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|data
operator|)
argument_list|,
literal|1
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_UNSIGNED
condition|)
if|if
condition|(
operator|!
operator|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_16_BITS
operator|)
operator|||
operator|(
name|i
operator|&
literal|0x01
operator|)
condition|)
name|data
operator|^=
literal|0x80
expr_stmt|;
comment|/* Convert to signed */
name|gus_poke
argument_list|(
name|target
operator|+
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|u_long
name|address
decl_stmt|,
name|hold_address
decl_stmt|;
name|u_char
name|dma_command
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
comment|/* 	     * OK, move now. First in and then out. 	     */
if|if
condition|(
name|uiomove
argument_list|(
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmap_out
operator|->
name|raw_buf
argument_list|,
name|blk_size
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"audio: Bad copyin()!\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/******** INTERRUPTS DISABLED NOW ********/
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable GF1 DMA */
name|DMAbuf_start_dma
argument_list|(
name|gus_devnum
argument_list|,
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmap_out
operator|->
name|raw_buf_phys
argument_list|,
name|blk_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	     * Set the DRAM address for the wave data 	     */
name|address
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmachan1
operator|>
literal|3
condition|)
block|{
name|hold_address
operator|=
name|address
expr_stmt|;
name|address
operator|=
name|address
operator|>>
literal|1
expr_stmt|;
name|address
operator|&=
literal|0x0001ffffL
expr_stmt|;
name|address
operator||=
operator|(
name|hold_address
operator|&
literal|0x000c0000L
operator|)
expr_stmt|;
block|}
name|gus_write16
argument_list|(
literal|0x42
argument_list|,
operator|(
name|address
operator|>>
literal|4
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* DRAM DMA address */
comment|/* 	     * Start the DMA transfer 	     */
name|dma_command
operator|=
literal|0x21
expr_stmt|;
comment|/* IRQ enable, DMA start */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_UNSIGNED
condition|)
name|dma_command
operator||=
literal|0x80
expr_stmt|;
comment|/* Invert MSB */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_16_BITS
condition|)
name|dma_command
operator||=
literal|0x40
expr_stmt|;
comment|/* 16 bit _DATA_ */
if|if
condition|(
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmachan1
operator|>
literal|3
condition|)
name|dma_command
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bit DMA _channel_ */
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
name|dma_command
argument_list|)
expr_stmt|;
comment|/* Lets bo luteet (=bugs) */
comment|/* 	     * Sleep here until the DRAM DMA done interrupt is 	     * served 	     */
name|active_device
operator|=
name|GUS_DEV_WAVE
expr_stmt|;
block|{
name|int
name|chn
decl_stmt|;
name|dram_sleep_flag
operator|.
name|mode
operator|=
name|WK_SLEEP
expr_stmt|;
name|dram_sleeper
operator|=
operator|&
name|chn
expr_stmt|;
name|DO_SLEEP
argument_list|(
name|chn
argument_list|,
name|dram_sleep_flag
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
operator|(
name|dram_sleep_flag
operator|.
name|mode
operator|&
name|WK_TIMEOUT
operator|)
condition|)
name|printf
argument_list|(
literal|"GUS: DMA Transfer timed out\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now the next part 	 */
name|left
operator|-=
name|blk_size
expr_stmt|;
name|src_offs
operator|+=
name|blk_size
expr_stmt|;
name|target
operator|+=
name|blk_size
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop DMA */
block|}
name|free_mem_ptr
operator|+=
name|patch
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|pmgr_flag
condition|)
name|pmgr_inform
argument_list|(
name|dev
argument_list|,
name|PM_E_PATCH_LOADED
argument_list|,
name|instr
argument_list|,
name|free_sample
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_sample
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_hw_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|voice
decl_stmt|,
name|cmd
decl_stmt|;
name|u_short
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|u_long
name|plong
decl_stmt|,
name|flags
decl_stmt|;
name|cmd
operator|=
name|event
index|[
literal|2
index|]
expr_stmt|;
name|voice
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
name|p1
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|event
index|[
literal|6
index|]
expr_stmt|;
name|plong
operator|=
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|==
name|VMODE_START_NOTE
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|_GUS_VOICESAMPLE
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|_GUS_VOICE_POS
operator|)
condition|)
name|do_volume_irq
argument_list|(
name|voice
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|_GUS_NUMVOICES
case|:
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_select_max_voices
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICESAMPLE
case|:
name|guswave_set_instr
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEON
case|:
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Don't allow interrupts */
name|gus_voice_on
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEOFF
case|:
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_off
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEFADE
case|:
name|gus_voice_fade
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEMODE
case|:
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Don't allow interrupts */
name|gus_voice_mode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEBALA
case|:
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_balance
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEFREQ
case|:
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_freq
argument_list|(
name|plong
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEVOL
case|:
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_volume
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEVOL2
case|:
comment|/* Just update the software voice level */
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
name|p1
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPRANGE
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* NO-NO */
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_ramp_range
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPRATE
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* NJET-NJET */
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_ramp_rate
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPMODE
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* NO-NO */
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Don't allow interrupts */
name|gus_ramp_mode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPON
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* EI-EI */
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Don't allow interrupts */
name|gus_rampon
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPOFF
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* NEJ-NEJ */
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOLUME_SCALE
case|:
name|volume_base
operator|=
name|p1
expr_stmt|;
name|volume_scale
operator|=
name|p2
expr_stmt|;
break|break;
case|case
name|_GUS_VOICE_POS
case|:
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_set_voice_pos
argument_list|(
name|voice
argument_list|,
name|plong
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_set_speed
parameter_list|(
name|int
name|speed
parameter_list|)
block|{
if|if
condition|(
name|speed
operator|<=
literal|0
condition|)
name|speed
operator|=
name|gus_sampling_speed
expr_stmt|;
name|RANGE
argument_list|(
name|speed
argument_list|,
literal|4000
argument_list|,
literal|44100
argument_list|)
expr_stmt|;
name|gus_sampling_speed
operator|=
name|speed
expr_stmt|;
if|if
condition|(
name|only_read_access
condition|)
block|{
comment|/* Compute nearest valid recording speed  and return it */
name|speed
operator|=
operator|(
literal|9878400
operator|/
operator|(
name|gus_sampling_speed
operator|+
literal|2
operator|)
operator|)
operator|/
literal|16
expr_stmt|;
name|speed
operator|=
operator|(
literal|9878400
operator|/
operator|(
name|speed
operator|*
literal|16
operator|)
operator|)
operator|-
literal|2
expr_stmt|;
block|}
return|return
name|speed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_set_channels
parameter_list|(
name|int
name|channels
parameter_list|)
block|{
if|if
condition|(
operator|!
name|channels
condition|)
return|return
name|gus_sampling_channels
return|;
name|RANGE
argument_list|(
name|channels
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|gus_sampling_channels
operator|=
name|channels
expr_stmt|;
return|return
name|channels
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_set_bits
parameter_list|(
name|int
name|bits
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bits
condition|)
return|return
name|gus_sampling_bits
return|;
if|if
condition|(
name|bits
operator|!=
literal|8
operator|&&
name|bits
operator|!=
literal|16
condition|)
name|bits
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|only_8_bits
condition|)
name|bits
operator|=
literal|8
expr_stmt|;
name|gus_sampling_bits
operator|=
name|bits
expr_stmt|;
return|return
name|bits
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|ioctl_arg
name|arg
parameter_list|,
name|int
name|local
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SOUND_PCM_WRITE_RATE
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_set_speed
argument_list|(
operator|(
name|int
operator|)
name|arg
argument_list|)
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_sampling_set_speed
argument_list|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_PCM_READ_RATE
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_speed
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_sampling_speed
return|;
break|break;
case|case
name|SNDCTL_DSP_STEREO
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_set_channels
argument_list|(
operator|(
name|int
operator|)
name|arg
operator|+
literal|1
argument_list|)
operator|-
literal|1
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_sampling_set_channels
argument_list|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
operator|+
literal|1
argument_list|)
operator|-
literal|1
return|;
break|break;
case|case
name|SOUND_PCM_WRITE_CHANNELS
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_set_channels
argument_list|(
operator|(
name|int
operator|)
name|arg
argument_list|)
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_sampling_set_channels
argument_list|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_PCM_READ_CHANNELS
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_channels
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_sampling_channels
return|;
break|break;
case|case
name|SNDCTL_DSP_SETFMT
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_set_bits
argument_list|(
operator|(
name|int
operator|)
name|arg
argument_list|)
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_sampling_set_bits
argument_list|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_PCM_READ_BITS
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_bits
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_sampling_bits
return|;
case|case
name|SOUND_PCM_WRITE_FILTER
case|:
comment|/* NOT POSSIBLE */
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
operator|-
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|SOUND_PCM_READ_FILTER
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
operator|-
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_reset
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
if|if
condition|(
name|recording_active
condition|)
block|{
name|gus_write8
argument_list|(
literal|0x49
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Halt recording */
name|set_input_volumes
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|otherside
init|=
name|audio_devs
index|[
name|dev
index|]
operator|->
name|otherside
decl_stmt|;
if|if
condition|(
name|otherside
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|audio_devs
index|[
name|otherside
index|]
operator|->
name|busy
condition|)
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
name|audio_devs
index|[
name|dev
index|]
operator|->
name|busy
condition|)
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
name|gus_initialize
argument_list|()
expr_stmt|;
name|active_device
operator|=
literal|0
expr_stmt|;
name|gus_reset
argument_list|()
expr_stmt|;
name|reset_sample_memory
argument_list|()
expr_stmt|;
name|gus_select_max_voices
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|pcm_active
operator|=
literal|0
expr_stmt|;
name|dma_active
operator|=
literal|0
expr_stmt|;
name|pcm_opened
operator|=
literal|1
expr_stmt|;
name|audio_devs
index|[
name|dev
index|]
operator|->
name|busy
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|OPEN_READ
condition|)
block|{
name|recording_active
operator|=
literal|1
expr_stmt|;
name|set_input_volumes
argument_list|()
expr_stmt|;
block|}
name|only_read_access
operator|=
operator|!
operator|(
name|mode
operator|&
name|OPEN_WRITE
operator|)
expr_stmt|;
name|only_8_bits
operator|=
name|mode
operator|&
name|OPEN_READ
expr_stmt|;
if|if
condition|(
name|only_8_bits
condition|)
name|audio_devs
index|[
name|dev
index|]
operator|->
name|format_mask
operator|=
name|AFMT_U8
expr_stmt|;
else|else
name|audio_devs
index|[
name|dev
index|]
operator|->
name|format_mask
operator|=
name|AFMT_U8
operator||
name|AFMT_S16_LE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|otherside
init|=
name|audio_devs
index|[
name|dev
index|]
operator|->
name|otherside
decl_stmt|;
name|audio_devs
index|[
name|dev
index|]
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|otherside
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|audio_devs
index|[
name|otherside
index|]
operator|->
name|busy
condition|)
return|return;
block|}
name|gus_reset
argument_list|()
expr_stmt|;
name|pcm_opened
operator|=
literal|0
expr_stmt|;
name|active_device
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|recording_active
condition|)
block|{
name|gus_write8
argument_list|(
literal|0x49
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Halt recording */
name|set_input_volumes
argument_list|()
expr_stmt|;
block|}
name|recording_active
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_update_volume
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|int
name|voice
decl_stmt|;
if|if
condition|(
name|pcm_active
operator|&&
name|pcm_opened
condition|)
for|for
control|(
name|voice
operator|=
literal|0
init|;
name|voice
operator|<
name|gus_sampling_channels
condition|;
name|voice
operator|++
control|)
block|{
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_volume
argument_list|(
literal|1530
operator|+
operator|(
literal|25
operator|*
name|gus_pcm_volume
operator|)
argument_list|)
expr_stmt|;
name|gus_ramp_range
argument_list|(
literal|65
argument_list|,
literal|1530
operator|+
operator|(
literal|25
operator|*
name|gus_pcm_volume
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|play_next_pcm_block
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|int
name|speed
init|=
name|gus_sampling_speed
decl_stmt|;
name|int
name|this_one
decl_stmt|,
name|is16bits
decl_stmt|,
name|chn
decl_stmt|;
name|u_long
name|dram_loc
decl_stmt|;
name|u_char
name|mode
index|[
literal|2
index|]
decl_stmt|,
name|ramp_mode
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|pcm_qlen
condition|)
return|return;
name|this_one
operator|=
name|pcm_head
expr_stmt|;
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
name|gus_sampling_channels
condition|;
name|chn
operator|++
control|)
block|{
name|mode
index|[
name|chn
index|]
operator|=
literal|0x00
expr_stmt|;
name|ramp_mode
index|[
name|chn
index|]
operator|=
literal|0x03
expr_stmt|;
comment|/* Ramping and rollover off */
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
block|{
name|mode
index|[
name|chn
index|]
operator||=
literal|0x20
expr_stmt|;
comment|/* Loop IRQ */
name|voices
index|[
name|chn
index|]
operator|.
name|loop_irq_mode
operator|=
name|LMODE_PCM
expr_stmt|;
block|}
if|if
condition|(
name|gus_sampling_bits
operator|!=
literal|8
condition|)
block|{
name|is16bits
operator|=
literal|1
expr_stmt|;
name|mode
index|[
name|chn
index|]
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bit data */
block|}
else|else
name|is16bits
operator|=
literal|0
expr_stmt|;
name|dram_loc
operator|=
name|this_one
operator|*
name|pcm_bsize
expr_stmt|;
name|dram_loc
operator|+=
name|chn
operator|*
name|pcm_banksize
expr_stmt|;
if|if
condition|(
name|this_one
operator|==
operator|(
name|pcm_nblk
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Last fragment of the 						 * DRAM buffer */
name|mode
index|[
name|chn
index|]
operator||=
literal|0x08
expr_stmt|;
comment|/* Enable loop */
name|ramp_mode
index|[
name|chn
index|]
operator|=
literal|0x03
expr_stmt|;
comment|/* Disable rollover bit */
block|}
else|else
block|{
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
name|ramp_mode
index|[
name|chn
index|]
operator|=
literal|0x04
expr_stmt|;
comment|/* Enable rollover bit */
block|}
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|gus_voice_freq
argument_list|(
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_sampling_channels
operator|==
literal|1
condition|)
name|gus_voice_balance
argument_list|(
literal|7
argument_list|)
expr_stmt|;
comment|/* mono */
elseif|else
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
name|gus_voice_balance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* left */
else|else
name|gus_voice_balance
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* right */
if|if
condition|(
operator|!
name|pcm_active
condition|)
block|{
comment|/* Playback not already active */
comment|/* 	     * The playback was not started yet (or there has 	     * been a pause). Start the voice (again) and ask for 	     * a rollover irq at the end of this_one block. If 	     * this_one one is last of the buffers, use just the 	     * normal loop with irq. 	     */
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_volume
argument_list|(
literal|1530
operator|+
operator|(
literal|25
operator|*
name|gus_pcm_volume
operator|)
argument_list|)
expr_stmt|;
name|gus_ramp_range
argument_list|(
literal|65
argument_list|,
literal|1530
operator|+
operator|(
literal|25
operator|*
name|gus_pcm_volume
operator|)
argument_list|)
expr_stmt|;
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
name|dram_loc
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Starting position */
name|gus_write_addr
argument_list|(
literal|0x02
argument_list|,
name|chn
operator|*
name|pcm_banksize
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop start */
if|if
condition|(
name|chn
operator|!=
literal|0
condition|)
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|pcm_banksize
operator|+
operator|(
name|pcm_bsize
operator|*
name|pcm_nblk
operator|)
operator|-
literal|1
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
block|}
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|dram_loc
operator|+
name|pcm_datasize
index|[
name|this_one
index|]
operator|-
literal|1
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
else|else
name|mode
index|[
name|chn
index|]
operator||=
literal|0x08
expr_stmt|;
comment|/* Enable looping */
if|if
condition|(
name|pcm_datasize
index|[
name|this_one
index|]
operator|!=
name|pcm_bsize
condition|)
block|{
comment|/* 	     * Incompletely filled block. Possibly the last one. 	     */
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
block|{
name|mode
index|[
name|chn
index|]
operator|&=
operator|~
literal|0x08
expr_stmt|;
comment|/* Disable looping */
name|mode
index|[
name|chn
index|]
operator||=
literal|0x20
expr_stmt|;
comment|/* Enable IRQ at the end */
name|voices
index|[
literal|0
index|]
operator|.
name|loop_irq_mode
operator|=
name|LMODE_PCM_STOP
expr_stmt|;
name|ramp_mode
index|[
name|chn
index|]
operator|=
literal|0x03
expr_stmt|;
comment|/* No rollover bit */
block|}
else|else
block|{
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|dram_loc
operator|+
name|pcm_datasize
index|[
name|this_one
index|]
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
name|mode
index|[
name|chn
index|]
operator|&=
operator|~
literal|0x08
expr_stmt|;
comment|/* Disable looping */
block|}
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
name|gus_sampling_channels
condition|;
name|chn
operator|++
control|)
block|{
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
name|ramp_mode
index|[
name|chn
index|]
argument_list|)
expr_stmt|;
name|gus_voice_on
argument_list|(
name|mode
index|[
name|chn
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
name|pcm_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_transfer_output_block
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_long
name|buf
parameter_list|,
name|int
name|total_count
parameter_list|,
name|int
name|intrflag
parameter_list|,
name|int
name|chn
parameter_list|)
block|{
comment|/* 	 * This routine transfers one block of audio data to the DRAM. In 	 * mono mode it's called just once. When in stereo mode, this_one 	 * routine is called once for both channels. 	 *  	 * The left/mono channel data is transferred to the beginning of dram 	 * and the right data to the area pointed by gus_page_size. 	 */
name|int
name|this_one
decl_stmt|,
name|count
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|u_char
name|dma_command
decl_stmt|;
name|u_long
name|address
decl_stmt|,
name|hold_address
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|count
operator|=
name|total_count
operator|/
name|gus_sampling_channels
expr_stmt|;
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pcm_qlen
operator|>=
name|pcm_nblk
condition|)
name|printf
argument_list|(
literal|"GUS Warning: PCM buffers out of sync\n"
argument_list|)
expr_stmt|;
name|this_one
operator|=
name|pcm_current_block
operator|=
name|pcm_tail
expr_stmt|;
name|pcm_qlen
operator|++
expr_stmt|;
name|pcm_tail
operator|=
operator|(
name|pcm_tail
operator|+
literal|1
operator|)
operator|%
name|pcm_nblk
expr_stmt|;
name|pcm_datasize
index|[
name|this_one
index|]
operator|=
name|count
expr_stmt|;
block|}
else|else
name|this_one
operator|=
name|pcm_current_block
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable GF1 DMA */
name|DMAbuf_start_dma
argument_list|(
name|dev
argument_list|,
name|buf
operator|+
operator|(
name|chn
operator|*
name|count
operator|)
argument_list|,
name|count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|address
operator|=
name|this_one
operator|*
name|pcm_bsize
expr_stmt|;
name|address
operator|+=
name|chn
operator|*
name|pcm_banksize
expr_stmt|;
if|if
condition|(
name|audio_devs
index|[
name|dev
index|]
operator|->
name|dmachan1
operator|>
literal|3
condition|)
block|{
name|hold_address
operator|=
name|address
expr_stmt|;
name|address
operator|=
name|address
operator|>>
literal|1
expr_stmt|;
name|address
operator|&=
literal|0x0001ffffL
expr_stmt|;
name|address
operator||=
operator|(
name|hold_address
operator|&
literal|0x000c0000L
operator|)
expr_stmt|;
block|}
name|gus_write16
argument_list|(
literal|0x42
argument_list|,
operator|(
name|address
operator|>>
literal|4
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* DRAM DMA address */
name|dma_command
operator|=
literal|0x21
expr_stmt|;
comment|/* IRQ enable, DMA start */
if|if
condition|(
name|gus_sampling_bits
operator|!=
literal|8
condition|)
name|dma_command
operator||=
literal|0x40
expr_stmt|;
comment|/* 16 bit _DATA_ */
else|else
name|dma_command
operator||=
literal|0x80
expr_stmt|;
comment|/* Invert MSB */
if|if
condition|(
name|audio_devs
index|[
name|dev
index|]
operator|->
name|dmachan1
operator|>
literal|3
condition|)
name|dma_command
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bit DMA channel */
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
name|dma_command
argument_list|)
expr_stmt|;
comment|/* Kickstart */
if|if
condition|(
name|chn
operator|==
operator|(
name|gus_sampling_channels
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Last channel */
comment|/* 		 * Last (right or mono) channel data 		 */
name|dma_active
operator|=
literal|1
expr_stmt|;
comment|/* DMA started. There is a unacknowledged 				 * buffer */
name|active_device
operator|=
name|GUS_DEV_PCM_DONE
expr_stmt|;
if|if
condition|(
operator|!
name|pcm_active
operator|&&
operator|(
name|pcm_qlen
operator|>
literal|0
operator|||
name|count
operator|<
name|pcm_bsize
operator|)
condition|)
block|{
name|play_next_pcm_block
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Left channel data. The right channel is transferred after 		 * DMA interrupt 		 */
name|active_device
operator|=
name|GUS_DEV_PCM_CONTINUE
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_output_block
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_long
name|buf
parameter_list|,
name|int
name|total_count
parameter_list|,
name|int
name|intrflag
parameter_list|,
name|int
name|restart_dma
parameter_list|)
block|{
name|pcm_current_buf
operator|=
name|buf
expr_stmt|;
name|pcm_current_count
operator|=
name|total_count
expr_stmt|;
name|pcm_current_intrflag
operator|=
name|intrflag
expr_stmt|;
name|pcm_current_dev
operator|=
name|dev
expr_stmt|;
name|gus_transfer_output_block
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
name|total_count
argument_list|,
name|intrflag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_start_input
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_long
name|buf
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|intrflag
parameter_list|,
name|int
name|restart_dma
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|u_char
name|mode
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|DMAbuf_start_dma
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
literal|0xa0
expr_stmt|;
comment|/* DMA IRQ enabled, invert MSB */
if|if
condition|(
name|audio_devs
index|[
name|dev
index|]
operator|->
name|dmachan2
operator|>
literal|3
condition|)
name|mode
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bit DMA channel */
if|if
condition|(
name|gus_sampling_channels
operator|>
literal|1
condition|)
name|mode
operator||=
literal|0x02
expr_stmt|;
comment|/* Stereo */
name|mode
operator||=
literal|0x01
expr_stmt|;
comment|/* DMA enable */
name|gus_write8
argument_list|(
literal|0x49
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_prepare_for_input
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|bsize
parameter_list|,
name|int
name|bcount
parameter_list|)
block|{
name|u_int
name|rate
decl_stmt|;
name|rate
operator|=
operator|(
literal|9878400
operator|/
operator|(
name|gus_sampling_speed
operator|+
literal|2
operator|)
operator|)
operator|/
literal|16
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x48
argument_list|,
name|rate
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Set sampling rate */
if|if
condition|(
name|gus_sampling_bits
operator|!=
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"GUS Error: 16 bit recording not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_prepare_for_output
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|bsize
parameter_list|,
name|int
name|bcount
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|long
name|mem_ptr
decl_stmt|,
name|mem_size
decl_stmt|;
name|mem_ptr
operator|=
literal|0
expr_stmt|;
name|mem_size
operator|=
name|gus_mem_size
operator|/
name|gus_sampling_channels
expr_stmt|;
if|if
condition|(
name|mem_size
operator|>
operator|(
literal|256
operator|*
literal|1024
operator|)
condition|)
name|mem_size
operator|=
literal|256
operator|*
literal|1024
expr_stmt|;
name|pcm_bsize
operator|=
name|bsize
operator|/
name|gus_sampling_channels
expr_stmt|;
name|pcm_head
operator|=
name|pcm_tail
operator|=
name|pcm_qlen
operator|=
literal|0
expr_stmt|;
name|pcm_nblk
operator|=
name|MAX_PCM_BUFFERS
expr_stmt|;
if|if
condition|(
operator|(
name|pcm_bsize
operator|*
name|pcm_nblk
operator|)
operator|>
name|mem_size
condition|)
name|pcm_nblk
operator|=
name|mem_size
operator|/
name|pcm_bsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcm_nblk
condition|;
name|i
operator|++
control|)
name|pcm_datasize
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|pcm_banksize
operator|=
name|pcm_nblk
operator|*
name|pcm_bsize
expr_stmt|;
if|if
condition|(
name|gus_sampling_bits
operator|!=
literal|8
operator|&&
name|pcm_banksize
operator|==
operator|(
literal|256
operator|*
literal|1024
operator|)
condition|)
name|pcm_nblk
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_local_qlen
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
return|return
name|pcm_qlen
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_copy_from_user
parameter_list|(
name|int
name|dev
parameter_list|,
name|char
modifier|*
name|localbuf
parameter_list|,
name|int
name|localoffs
parameter_list|,
name|snd_rw_buf
modifier|*
name|userbuf
parameter_list|,
name|int
name|useroffs
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|gus_sampling_channels
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|uiomove
argument_list|(
operator|&
name|localbuf
index|[
name|localoffs
index|]
argument_list|,
name|len
argument_list|,
name|userbuf
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"audio: Bad copyin()!\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|gus_sampling_bits
operator|==
literal|8
condition|)
block|{
name|int
name|in_left
init|=
name|useroffs
decl_stmt|;
name|int
name|in_right
init|=
name|useroffs
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|out_left
decl_stmt|,
modifier|*
name|out_right
decl_stmt|;
name|int
name|i
decl_stmt|;
name|len
operator|/=
literal|2
expr_stmt|;
name|localoffs
operator|/=
literal|2
expr_stmt|;
name|out_left
operator|=
operator|&
name|localbuf
index|[
name|localoffs
index|]
expr_stmt|;
name|out_right
operator|=
name|out_left
operator|+
name|pcm_bsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|*
name|out_left
operator|++
operator|)
argument_list|,
literal|1
argument_list|,
name|userbuf
argument_list|)
expr_stmt|;
name|in_left
operator|+=
literal|2
expr_stmt|;
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|*
name|out_right
operator|++
operator|)
argument_list|,
literal|1
argument_list|,
name|userbuf
argument_list|)
expr_stmt|;
name|in_right
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|in_left
init|=
name|useroffs
decl_stmt|;
name|int
name|in_right
init|=
name|useroffs
operator|+
literal|2
decl_stmt|;
name|short
modifier|*
name|out_left
decl_stmt|,
modifier|*
name|out_right
decl_stmt|;
name|int
name|i
decl_stmt|;
name|len
operator|/=
literal|4
expr_stmt|;
name|localoffs
operator|/=
literal|2
expr_stmt|;
name|out_left
operator|=
operator|(
name|short
operator|*
operator|)
operator|&
name|localbuf
index|[
name|localoffs
index|]
expr_stmt|;
name|out_right
operator|=
name|out_left
operator|+
operator|(
name|pcm_bsize
operator|/
literal|2
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|*
name|out_left
operator|++
operator|)
argument_list|,
literal|2
argument_list|,
name|userbuf
argument_list|)
expr_stmt|;
name|in_left
operator|+=
literal|2
expr_stmt|;
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|*
name|out_right
operator|++
operator|)
argument_list|,
literal|2
argument_list|,
name|userbuf
argument_list|)
expr_stmt|;
name|in_right
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|audio_operations
name|gus_sampling_operations
init|=
block|{
literal|"Gravis UltraSound"
block|,
name|NEEDS_RESTART
block|,
name|AFMT_U8
operator||
name|AFMT_S16_LE
block|,
name|NULL
block|,
name|gus_sampling_open
block|,
name|gus_sampling_close
block|,
name|gus_sampling_output_block
block|,
name|gus_sampling_start_input
block|,
name|gus_sampling_ioctl
block|,
name|gus_sampling_prepare_for_input
block|,
name|gus_sampling_prepare_for_output
block|,
name|gus_sampling_reset
block|,
name|gus_sampling_reset
block|,
name|gus_local_qlen
block|,
name|gus_copy_from_user
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|guswave_setup_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|chn
parameter_list|)
block|{
name|struct
name|channel_info
modifier|*
name|info
init|=
operator|&
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
decl_stmt|;
name|guswave_set_instr
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|info
operator|->
name|pgm_num
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
operator|=
name|info
operator|->
name|controllers
index|[
name|CTL_EXPRESSION
index|]
expr_stmt|;
comment|/* Just msb */
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
operator|=
operator|(
name|info
operator|->
name|controllers
index|[
name|CTL_MAIN_VOLUME
index|]
operator|*
literal|100
operator|)
operator|/
literal|128
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
operator|(
name|info
operator|->
name|controllers
index|[
name|CTL_PAN
index|]
operator|*
literal|2
operator|)
operator|-
literal|128
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|info
operator|->
name|bender_value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_bender
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|int
name|freq
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|value
operator|-
literal|8192
expr_stmt|;
name|freq
operator|=
name|compute_finetune
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|value
operator|-
literal|8192
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|freq
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_freq
argument_list|(
name|freq
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_patchmgr
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|patmgr_info
modifier|*
name|rec
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
switch|switch
condition|(
name|rec
operator|->
name|command
condition|)
block|{
case|case
name|PM_GET_DEVTYPE
case|:
name|rec
operator|->
name|parm1
operator|=
name|PMTYPE_WAVE
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|PM_GET_NRPGM
case|:
name|rec
operator|->
name|parm1
operator|=
name|MAX_PATCH
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|PM_GET_PGMMAP
case|:
name|rec
operator|->
name|parm1
operator|=
name|MAX_PATCH
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PATCH
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ptr
init|=
name|patch_table
index|[
name|i
index|]
decl_stmt|;
name|rec
operator|->
name|data
operator|.
name|data8
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ptr
operator|>=
literal|0
operator|&&
name|ptr
operator|<
name|free_sample
condition|)
block|{
name|rec
operator|->
name|data
operator|.
name|data8
index|[
name|i
index|]
operator|++
expr_stmt|;
name|ptr
operator|=
name|samples
index|[
name|ptr
index|]
operator|.
name|key
expr_stmt|;
comment|/* Follow link */
block|}
block|}
return|return
literal|0
return|;
break|break;
case|case
name|PM_GET_PGM_PATCHES
case|:
block|{
name|int
name|ptr
init|=
name|patch_table
index|[
name|rec
operator|->
name|parm1
index|]
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ptr
operator|>=
literal|0
operator|&&
name|ptr
operator|<
name|free_sample
condition|)
block|{
name|rec
operator|->
name|data
operator|.
name|data32
index|[
name|n
operator|++
index|]
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|samples
index|[
name|ptr
index|]
operator|.
name|key
expr_stmt|;
comment|/* Follow link */
block|}
block|}
name|rec
operator|->
name|parm1
operator|=
name|n
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|PM_GET_PATCH
case|:
block|{
name|int
name|ptr
init|=
name|rec
operator|->
name|parm1
decl_stmt|;
name|struct
name|patch_info
modifier|*
name|pat
decl_stmt|;
if|if
condition|(
name|ptr
operator|<
literal|0
operator|||
name|ptr
operator|>=
name|free_sample
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|samples
index|[
name|ptr
index|]
argument_list|,
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|patch_info
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
operator|(
expr|struct
name|patch_info
operator|*
operator|)
name|rec
operator|->
name|data
operator|.
name|data8
expr_stmt|;
name|pat
operator|->
name|key
operator|=
name|GUS_PATCH
expr_stmt|;
comment|/* Restore patch type */
name|rec
operator|->
name|parm1
operator|=
name|sample_ptrs
index|[
name|ptr
index|]
expr_stmt|;
comment|/* DRAM location */
name|rec
operator|->
name|parm2
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|patch_info
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
break|break;
case|case
name|PM_SET_PATCH
case|:
block|{
name|int
name|ptr
init|=
name|rec
operator|->
name|parm1
decl_stmt|;
name|struct
name|patch_info
modifier|*
name|pat
decl_stmt|;
if|if
condition|(
name|ptr
operator|<
literal|0
operator|||
name|ptr
operator|>=
name|free_sample
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
name|pat
operator|=
operator|(
expr|struct
name|patch_info
operator|*
operator|)
name|rec
operator|->
name|data
operator|.
name|data8
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|len
operator|>
name|samples
index|[
name|ptr
index|]
operator|.
name|len
condition|)
comment|/* Cannot expand sample */
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
name|pat
operator|->
name|key
operator|=
name|samples
index|[
name|ptr
index|]
operator|.
name|key
expr_stmt|;
comment|/* Ensure the link is 							 * correct */
name|bcopy
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|samples
index|[
name|ptr
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|patch_info
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|->
name|key
operator|=
name|GUS_PATCH
expr_stmt|;
block|}
return|return
literal|0
return|;
break|break;
case|case
name|PM_READ_PATCH
case|:
comment|/* Returns a block of wave data from the DRAM */
block|{
name|int
name|sample
init|=
name|rec
operator|->
name|parm1
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|offs
init|=
name|rec
operator|->
name|parm2
decl_stmt|;
name|int
name|l
init|=
name|rec
operator|->
name|parm3
decl_stmt|;
if|if
condition|(
name|sample
operator|<
literal|0
operator|||
name|sample
operator|>=
name|free_sample
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|offs
operator|<
literal|0
operator|||
name|offs
operator|>=
name|samples
index|[
name|sample
index|]
operator|.
name|len
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
comment|/* Invalid offset */
name|n
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|len
operator|-
name|offs
expr_stmt|;
comment|/* Num of bytes left */
if|if
condition|(
name|l
operator|>
name|n
condition|)
name|l
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|)
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<=
literal|0
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
comment|/* Was there a bug? */
name|offs
operator|+=
name|sample_ptrs
index|[
name|sample
index|]
expr_stmt|;
comment|/* Begin offsess + 							 * offset to DRAM */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|l
condition|;
name|n
operator|++
control|)
name|rec
operator|->
name|data
operator|.
name|data8
index|[
name|n
index|]
operator|=
name|gus_peek
argument_list|(
name|offs
operator|++
argument_list|)
expr_stmt|;
name|rec
operator|->
name|parm1
operator|=
name|n
expr_stmt|;
comment|/* Nr of bytes copied */
block|}
return|return
literal|0
return|;
break|break;
case|case
name|PM_WRITE_PATCH
case|:
comment|/* Writes a block of wave data to the DRAM */
block|{
name|int
name|sample
init|=
name|rec
operator|->
name|parm1
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|offs
init|=
name|rec
operator|->
name|parm2
decl_stmt|;
name|int
name|l
init|=
name|rec
operator|->
name|parm3
decl_stmt|;
if|if
condition|(
name|sample
operator|<
literal|0
operator|||
name|sample
operator|>=
name|free_sample
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|offs
operator|<
literal|0
operator|||
name|offs
operator|>=
name|samples
index|[
name|sample
index|]
operator|.
name|len
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
comment|/* Invalid offset */
name|n
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|len
operator|-
name|offs
expr_stmt|;
comment|/* Nr of bytes left */
if|if
condition|(
name|l
operator|>
name|n
condition|)
name|l
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|)
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<=
literal|0
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
comment|/* Was there a bug? */
name|offs
operator|+=
name|sample_ptrs
index|[
name|sample
index|]
expr_stmt|;
comment|/* Begin offsess + 							 * offset to DRAM */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|l
condition|;
name|n
operator|++
control|)
name|gus_poke
argument_list|(
name|offs
operator|++
argument_list|,
name|rec
operator|->
name|data
operator|.
name|data8
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|rec
operator|->
name|parm1
operator|=
name|n
expr_stmt|;
comment|/* Nr of bytes copied */
block|}
return|return
literal|0
return|;
break|break;
default|default:
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_alloc
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|,
name|struct
name|voice_alloc_info
modifier|*
name|alloc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|p
decl_stmt|,
name|best
init|=
operator|-
literal|1
decl_stmt|,
name|best_time
init|=
literal|0x7fffffff
decl_stmt|;
name|p
operator|=
name|alloc
operator|->
name|ptr
expr_stmt|;
comment|/* 	 * First look for a completely stopped voice 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alloc
operator|->
name|max_voice
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alloc
operator|->
name|map
index|[
name|p
index|]
operator|==
literal|0
condition|)
block|{
name|alloc
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
if|if
condition|(
name|alloc
operator|->
name|alloc_times
index|[
name|p
index|]
operator|<
name|best_time
condition|)
block|{
name|best
operator|=
name|p
expr_stmt|;
name|best_time
operator|=
name|alloc
operator|->
name|alloc_times
index|[
name|p
index|]
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
operator|%
name|alloc
operator|->
name|max_voice
expr_stmt|;
block|}
comment|/* 	 * Then look for a releasing voice 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alloc
operator|->
name|max_voice
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alloc
operator|->
name|map
index|[
name|p
index|]
operator|==
literal|0xffff
condition|)
block|{
name|alloc
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
name|p
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
operator|%
name|alloc
operator|->
name|max_voice
expr_stmt|;
block|}
if|if
condition|(
name|best
operator|>=
literal|0
condition|)
name|p
operator|=
name|best
expr_stmt|;
name|alloc
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|synth_operations
name|guswave_operations
init|=
block|{
operator|&
name|gus_info
block|,
literal|0
block|,
name|SYNTH_TYPE_SAMPLE
block|,
name|SAMPLE_TYPE_GUS
block|,
name|guswave_open
block|,
name|guswave_close
block|,
name|guswave_ioctl
block|,
name|guswave_kill_note
block|,
name|guswave_start_note
block|,
name|guswave_set_instr
block|,
name|guswave_reset
block|,
name|guswave_hw_control
block|,
name|guswave_load_patch
block|,
name|guswave_aftertouch
block|,
name|guswave_controller
block|,
name|guswave_panning
block|,
name|guswave_volume_method
block|,
name|guswave_patchmgr
block|,
name|guswave_bender
block|,
name|guswave_alloc
block|,
name|guswave_setup_voice
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_input_volumes
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|u_char
name|mask
init|=
literal|0xff
operator|&
operator|~
literal|0x06
decl_stmt|;
comment|/* Just line out enabled */
if|if
condition|(
name|have_gus_max
condition|)
comment|/* Don't disturb GUS MAX */
return|return;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* 	 * Enable channels having vol> 10% Note! bit 0x01 means the line in 	 * DISABLED while 0x04 means the mic in ENABLED. 	 */
if|if
condition|(
name|gus_line_vol
operator|>
literal|10
condition|)
name|mask
operator|&=
operator|~
literal|0x01
expr_stmt|;
if|if
condition|(
name|gus_mic_vol
operator|>
literal|10
condition|)
name|mask
operator||=
literal|0x04
expr_stmt|;
if|if
condition|(
name|recording_active
condition|)
block|{
comment|/* 		 * Disable channel, if not selected for recording 		 */
if|if
condition|(
operator|!
operator|(
name|gus_recmask
operator|&
name|SOUND_MASK_LINE
operator|)
condition|)
name|mask
operator||=
literal|0x01
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gus_recmask
operator|&
name|SOUND_MASK_MIC
operator|)
condition|)
name|mask
operator|&=
operator|~
literal|0x04
expr_stmt|;
block|}
name|mix_image
operator|&=
operator|~
literal|0x07
expr_stmt|;
name|mix_image
operator||=
name|mask
operator|&
literal|0x07
expr_stmt|;
name|outb
argument_list|(
name|u_Mixer
argument_list|,
name|mix_image
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gus_default_mixer_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|ioctl_arg
name|arg
parameter_list|)
block|{
define|#
directive|define
name|MIX_DEVS
value|(SOUND_MASK_MIC|SOUND_MASK_LINE| \ 			 SOUND_MASK_SYNTH|SOUND_MASK_PCM)
if|if
condition|(
operator|(
operator|(
name|cmd
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|==
literal|'M'
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|IOC_IN
condition|)
switch|switch
condition|(
name|cmd
operator|&
literal|0xff
condition|)
block|{
case|case
name|SOUND_MIXER_RECSRC
case|:
name|gus_recmask
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
operator|&
name|MIX_DEVS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gus_recmask
operator|&
operator|(
name|SOUND_MASK_MIC
operator||
name|SOUND_MASK_LINE
operator|)
operator|)
condition|)
name|gus_recmask
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
comment|/* 		 * Note! Input volumes are updated during 		 * next open for recording 		 */
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_recmask
return|;
break|break;
case|case
name|SOUND_MIXER_MIC
case|:
block|{
name|int
name|vol
init|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|vol
operator|<
literal|0
condition|)
name|vol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vol
operator|>
literal|100
condition|)
name|vol
operator|=
literal|100
expr_stmt|;
name|gus_mic_vol
operator|=
name|vol
expr_stmt|;
name|set_input_volumes
argument_list|()
expr_stmt|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|vol
operator||
operator|(
name|vol
operator|<<
literal|8
operator|)
return|;
block|}
break|break;
case|case
name|SOUND_MIXER_LINE
case|:
block|{
name|int
name|vol
init|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|vol
operator|<
literal|0
condition|)
name|vol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vol
operator|>
literal|100
condition|)
name|vol
operator|=
literal|100
expr_stmt|;
name|gus_line_vol
operator|=
name|vol
expr_stmt|;
name|set_input_volumes
argument_list|()
expr_stmt|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|vol
operator||
operator|(
name|vol
operator|<<
literal|8
operator|)
return|;
block|}
break|break;
case|case
name|SOUND_MIXER_PCM
case|:
name|gus_pcm_volume
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
operator|&
literal|0xff
expr_stmt|;
name|RANGE
argument_list|(
name|gus_pcm_volume
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|gus_sampling_update_volume
argument_list|()
expr_stmt|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_pcm_volume
operator||
operator|(
name|gus_pcm_volume
operator|<<
literal|8
operator|)
return|;
break|break;
case|case
name|SOUND_MIXER_SYNTH
case|:
block|{
name|int
name|voice
decl_stmt|;
name|gus_wave_volume
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
operator|&
literal|0xff
expr_stmt|;
name|RANGE
argument_list|(
name|gus_wave_volume
argument_list|,
literal|0
argument_list|,
literal|100
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_device
operator|==
name|GUS_DEV_WAVE
condition|)
for|for
control|(
name|voice
operator|=
literal|0
init|;
name|voice
operator|<
name|nr_voices
condition|;
name|voice
operator|++
control|)
name|dynamic_volume_change
argument_list|(
name|voice
argument_list|)
expr_stmt|;
comment|/* Apply the new vol */
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_wave_volume
operator||
operator|(
name|gus_wave_volume
operator|<<
literal|8
operator|)
return|;
block|}
break|break;
default|default:
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
switch|switch
condition|(
name|cmd
operator|&
literal|0xff
condition|)
block|{
comment|/* Return parameters */
case|case
name|SOUND_MIXER_RECSRC
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_recmask
return|;
break|break;
case|case
name|SOUND_MIXER_DEVMASK
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|MIX_DEVS
return|;
break|break;
case|case
name|SOUND_MIXER_STEREODEVS
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|0
return|;
break|break;
case|case
name|SOUND_MIXER_RECMASK
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|SOUND_MASK_MIC
operator||
name|SOUND_MASK_LINE
return|;
break|break;
case|case
name|SOUND_MIXER_CAPS
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
literal|0
return|;
break|break;
case|case
name|SOUND_MIXER_MIC
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_mic_vol
operator||
operator|(
name|gus_mic_vol
operator|<<
literal|8
operator|)
return|;
break|break;
case|case
name|SOUND_MIXER_LINE
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_line_vol
operator||
operator|(
name|gus_line_vol
operator|<<
literal|8
operator|)
return|;
break|break;
case|case
name|SOUND_MIXER_PCM
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_pcm_volume
operator||
operator|(
name|gus_pcm_volume
operator|<<
literal|8
operator|)
return|;
break|break;
case|case
name|SOUND_MIXER_SYNTH
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|gus_wave_volume
operator||
operator|(
name|gus_wave_volume
operator|<<
literal|8
operator|)
return|;
break|break;
default|default:
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mixer_operations
name|gus_mixer_operations
init|=
block|{
literal|"Gravis Ultrasound"
block|,
name|gus_default_mixer_ioctl
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|gus_default_mixer_init
parameter_list|()
block|{
if|if
condition|(
name|num_mixers
operator|<
name|MAX_MIXER_DEV
condition|)
comment|/* Don't install if there is another 			     * mixer */
name|mixer_devs
index|[
name|num_mixers
operator|++
index|]
operator|=
operator|&
name|gus_mixer_operations
expr_stmt|;
if|if
condition|(
name|have_gus_max
condition|)
block|{
comment|/*      * Enable all mixer channels on the GF1 side. Otherwise      * recording will not be possible using GUS MAX.      */
name|mix_image
operator|&=
operator|~
literal|0x07
expr_stmt|;
name|mix_image
operator||=
literal|0x04
expr_stmt|;
comment|/* All channels enabled */
name|outb
argument_list|(
name|u_Mixer
argument_list|,
name|mix_image
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* start of pnp code */
end_comment

begin_function
name|void
name|SEND
parameter_list|(
name|int
name|d
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|outb
argument_list|(
name|PADDRESS
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PWRITE_DATA
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the device's serial number.  Returns 1 if the serial is valid.  */
end_comment

begin_function
name|int
name|get_serial
parameter_list|(
name|int
name|rd_port
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|bit
decl_stmt|,
name|valid
init|=
literal|0
decl_stmt|,
name|sum
init|=
literal|0x6a
decl_stmt|;
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|9
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|72
condition|;
name|i
operator|++
control|)
block|{
name|bit
operator|=
name|inb
argument_list|(
operator|(
name|rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
operator|==
literal|0x55
expr_stmt|;
name|DELAY
argument_list|(
literal|250
argument_list|)
expr_stmt|;
comment|/* Delay 250 usec */
comment|/* Can't Short Circuit the next evaluation, so 'and' is last */
name|bit
operator|=
operator|(
name|inb
argument_list|(
operator|(
name|rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
operator|==
literal|0xaa
operator|)
operator|&&
name|bit
expr_stmt|;
name|DELAY
argument_list|(
literal|250
argument_list|)
expr_stmt|;
comment|/* Delay 250 usec */
name|valid
operator|=
name|valid
operator|||
name|bit
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|64
condition|)
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|sum
operator|^
operator|(
name|sum
operator|>>
literal|1
operator|)
operator|^
name|bit
operator|)
operator|<<
literal|7
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|data
index|[
name|i
operator|/
literal|8
index|]
operator|=
operator|(
name|data
index|[
name|i
operator|/
literal|8
index|]
operator|>>
literal|1
operator|)
operator||
operator|(
name|bit
condition|?
literal|0x80
else|:
literal|0
operator|)
expr_stmt|;
block|}
name|valid
operator|=
name|valid
operator|&&
operator|(
name|data
index|[
literal|8
index|]
operator|==
name|sum
operator|)
expr_stmt|;
return|return
name|valid
return|;
block|}
end_function

begin_function
name|void
name|send_Initiation_LFSR
parameter_list|()
block|{
name|int
name|cur
decl_stmt|,
name|i
decl_stmt|;
comment|/* Reset the LSFR */
name|outb
argument_list|(
name|PADDRESS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PADDRESS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur
operator|=
literal|0x6a
expr_stmt|;
name|outb
argument_list|(
name|PADDRESS
argument_list|,
name|cur
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|cur
operator|=
operator|(
name|cur
operator|>>
literal|1
operator|)
operator||
operator|(
operator|(
operator|(
name|cur
operator|^
operator|(
name|cur
operator|>>
literal|1
operator|)
operator|)
operator|<<
literal|7
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
name|outb
argument_list|(
name|PADDRESS
argument_list|,
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|isolation_protocol
parameter_list|(
name|int
name|rd_port
parameter_list|)
block|{
name|int
name|csn
decl_stmt|;
name|u_char
name|data
index|[
literal|9
index|]
decl_stmt|;
name|send_Initiation_LFSR
argument_list|()
expr_stmt|;
comment|/* Reset CSN for All Cards */
name|SEND
argument_list|(
literal|0x02
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
for|for
control|(
name|csn
operator|=
literal|1
init|;
operator|(
name|csn
operator|<
name|MAX_CARDS
operator|)
condition|;
name|csn
operator|++
control|)
block|{
comment|/* Wake up cards without a CSN */
name|SEND
argument_list|(
name|WAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SEND
argument_list|(
name|SET_RD_DATA
argument_list|,
name|rd_port
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PADDRESS
argument_list|,
name|SERIAL_ISOLATION
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* Delay 1 msec */
if|if
condition|(
name|get_serial
argument_list|(
name|rd_port
argument_list|,
name|data
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Board Vendor ID: %c%c%c%02x%02x"
argument_list|,
operator|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x7c
operator|)
operator|>>
literal|2
operator|)
operator|+
literal|64
argument_list|,
operator|(
operator|(
operator|(
name|data
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0xe0
operator|)
operator|>>
literal|5
operator|)
operator|)
operator|+
literal|64
argument_list|,
operator|(
name|data
index|[
literal|1
index|]
operator|&
literal|0x1f
operator|)
operator|+
literal|64
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     Board Serial Number: %08x\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
operator|(
name|data
index|[
literal|4
index|]
operator|)
argument_list|)
expr_stmt|;
name|SEND
argument_list|(
name|SET_CSN
argument_list|,
name|csn
argument_list|)
expr_stmt|;
comment|/* Move this out of this 						 * function XXX */
name|outb
argument_list|(
name|PADDRESS
argument_list|,
name|PSTATUS
argument_list|)
expr_stmt|;
return|return
name|rd_port
return|;
block|}
else|else
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|IwaveDelay
parameter_list|(
name|WORD
name|count
parameter_list|)
block|{
name|WORD
name|cur_cnt
init|=
literal|0
decl_stmt|,
name|last_cnt
decl_stmt|;
name|BYTE
name|reg
decl_stmt|,
name|portb
decl_stmt|;
name|count
operator|=
literal|1193
operator|*
name|count
expr_stmt|;
comment|/* convert number of ms to counter */
name|last_cnt
operator|=
name|count
expr_stmt|;
name|portb
operator|=
name|inb
argument_list|(
literal|0x61
argument_list|)
operator|&
literal|0xFC
expr_stmt|;
name|outb
argument_list|(
literal|0x61
argument_list|,
name|portb
argument_list|)
expr_stmt|;
comment|/* disable counter */
name|outb
argument_list|(
literal|0x43
argument_list|,
literal|0xB0
argument_list|)
expr_stmt|;
comment|/* load LSB first then MSB */
name|outb
argument_list|(
literal|0x42
argument_list|,
operator|(
name|BYTE
operator|)
name|count
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x42
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|count
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x61
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|portb
operator||
literal|0x01
argument_list|)
argument_list|)
expr_stmt|;
comment|/* enable counter */
while|while
condition|(
name|cur_cnt
operator|<=
name|count
condition|)
block|{
name|outb
argument_list|(
literal|0x43
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* latch counter */
name|reg
operator|=
name|inb
argument_list|(
literal|0x42
argument_list|)
expr_stmt|;
comment|/* read latched value */
name|cur_cnt
operator|=
operator|(
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
literal|0x42
argument_list|)
operator|)
operator|<<
literal|8
operator|)
operator||
name|reg
expr_stmt|;
if|if
condition|(
name|cur_cnt
operator|>
name|last_cnt
condition|)
break|break;
name|last_cnt
operator|=
name|cur_cnt
expr_stmt|;
block|}
name|outb
argument_list|(
literal|0x61
argument_list|,
name|portb
argument_list|)
expr_stmt|;
comment|/* disable counter */
block|}
end_function

begin_comment
comment|/*  * ########################################################################  *   * FUNCTION: IwaveStopDma  *   * PROFILE: This function stops an active DMA transfer to or from the record or  * playback FIFOs. Set the "path" variable to either PLAYBACK or RECORD.  * ########################################################################  */
end_comment

begin_function
name|void
name|IwaveStopDma
parameter_list|(
name|BYTE
name|path
parameter_list|)
block|{
name|BYTE
name|reg
decl_stmt|;
name|ENTER_CRITICAL
expr_stmt|;
name|reg
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|)
operator|&
literal|0xE0
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|,
name|reg
operator||
name|_CFIG1I
argument_list|)
expr_stmt|;
comment|/* select CFIG1I */
name|outb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|inb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|)
operator|&
operator|~
name|path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* disable playback path */
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ########################################################################  *   * FUNCTION : IwaveInputSource  *   * PROFILE: This function allows the calling program to select among any of  * several possible sources to the ADC's. The possible input sources and  * their corresponding symbolic constants are: - Line        (LINE_IN) - Aux1  * (AUX1_IN) - Microphone  (MIC_IN) - Mixer       (MIX_IN)  *   * Set the first argument to either LEFT_SOURCE or RIGHT_SOURCE. Always use the  * symbolic contants for the arguments.  *   * ########################################################################  */
end_comment

begin_function
name|void
name|IwaveInputSource
parameter_list|(
name|BYTE
name|index
parameter_list|,
name|BYTE
name|source
parameter_list|)
block|{
name|BYTE
name|reg
decl_stmt|;
name|ENTER_CRITICAL
expr_stmt|;
name|reg
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|)
operator|&
literal|0xE0
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|,
name|reg
operator||
name|index
argument_list|)
expr_stmt|;
comment|/* select register CLICI or CRICI */
name|reg
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|)
operator|&
operator|~
name|MIX_IN
expr_stmt|;
name|source
operator|&=
name|MIX_IN
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|reg
operator||
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|IwavePnpGetCfg
parameter_list|(
name|void
parameter_list|)
block|{
name|WORD
name|val
decl_stmt|;
name|ENTER_CRITICAL
expr_stmt|;
name|IwavePnpDevice
argument_list|(
name|AUDIO
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select P2X0HI */
name|val
operator|=
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* get P2XR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select P2XRLI */
name|iw
operator|.
name|p2xr
operator|=
name|val
operator|+
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
expr_stmt|;
comment|/* get P2XR[7:4] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x62
argument_list|)
expr_stmt|;
comment|/* select P3X0HI */
name|val
operator|=
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* get P3XR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x63
argument_list|)
expr_stmt|;
comment|/* select P3X0LI */
name|iw
operator|.
name|p3xr
operator|=
name|val
operator|+
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
expr_stmt|;
comment|/* get P3XR[7:3] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x64
argument_list|)
expr_stmt|;
comment|/* select PHCAI */
name|val
operator|=
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* get PCODAR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x65
argument_list|)
expr_stmt|;
comment|/* select PLCAI */
name|iw
operator|.
name|pcodar
operator|=
name|val
operator|+
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
expr_stmt|;
comment|/* get PCODAR[7:2] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* select PUI1SI */
name|iw
operator|.
name|synth_irq
operator|=
call|(
name|WORD
call|)
argument_list|(
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
comment|/* Synth IRQ number */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x72
argument_list|)
expr_stmt|;
comment|/* select PUI2SI */
name|iw
operator|.
name|midi_irq
operator|=
call|(
name|WORD
call|)
argument_list|(
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
comment|/* MIDI IRQ number */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x74
argument_list|)
expr_stmt|;
comment|/* select PUD1SI */
name|iw
operator|.
name|dma1_chan
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|&
literal|0x07
expr_stmt|;
comment|/* DMA1 chan (LMC/Codec Rec) */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x75
argument_list|)
expr_stmt|;
comment|/* select PUD2SI */
name|iw
operator|.
name|dma2_chan
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|&
literal|0x07
expr_stmt|;
comment|/* DMA2 chan (codec play) */
name|IwavePnpDevice
argument_list|(
name|EXT
argument_list|)
expr_stmt|;
comment|/* select external device */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select PRAHI */
name|val
operator|=
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* get PCDRAR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select PRALI */
name|iw
operator|.
name|pcdrar
operator|=
name|val
operator|+
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
expr_stmt|;
comment|/* get PCDRAR[7:4] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x62
argument_list|)
expr_stmt|;
comment|/* select PATAHI */
name|val
operator|=
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* get PATAAR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x63
argument_list|)
expr_stmt|;
comment|/* select PATALI */
name|iw
operator|.
name|pataar
operator|=
name|val
operator|+
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
expr_stmt|;
comment|/* get PATAAR[7:1] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* select PRISI */
name|iw
operator|.
name|ext_irq
operator|=
call|(
name|WORD
call|)
argument_list|(
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
comment|/* Ext Dev IRQ number */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x74
argument_list|)
expr_stmt|;
comment|/* select PRDSI */
name|iw
operator|.
name|ext_chan
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|&
literal|0x07
expr_stmt|;
comment|/* Ext Dev DMA channel */
name|IwavePnpDevice
argument_list|(
name|MPU401
argument_list|)
expr_stmt|;
comment|/* Select MPU401 Device */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select P401HI */
name|val
operator|=
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* get P401AR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select P401LI */
name|iw
operator|.
name|p401ar
operator|=
name|val
operator|+
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
expr_stmt|;
comment|/* get P401AR[7:1] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* select PMISI */
name|iw
operator|.
name|mpu_irq
operator|=
call|(
name|WORD
call|)
argument_list|(
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
comment|/* MPU401 Dev IRQ number */
name|IwavePnpDevice
argument_list|(
name|GAME
argument_list|)
expr_stmt|;
comment|/* Select GAME logical Device */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select P201HI */
name|val
operator|=
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* get P201AR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select P201LI */
name|iw
operator|.
name|p201ar
operator|=
name|val
operator|+
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
expr_stmt|;
comment|/* get P201AR[7:6] */
name|IwavePnpDevice
argument_list|(
name|EMULATION
argument_list|)
expr_stmt|;
comment|/* Select SB and ADLIB Device */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select P388HI */
name|val
operator|=
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|)
operator|<<
literal|8
expr_stmt|;
comment|/* get P388AR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select P388LI */
name|iw
operator|.
name|p388ar
operator|=
name|val
operator|+
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
expr_stmt|;
comment|/* get P388AR[7:6] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* select PSBISI */
name|iw
operator|.
name|emul_irq
operator|=
call|(
name|WORD
call|)
argument_list|(
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|&
literal|0x0F
argument_list|)
expr_stmt|;
comment|/* emulation Dev IRQ 							 * number */
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|IwavePnpSetCfg
parameter_list|(
name|void
parameter_list|)
block|{
name|ENTER_CRITICAL
expr_stmt|;
name|IwavePnpDevice
argument_list|(
name|AUDIO
argument_list|)
expr_stmt|;
comment|/* select audio device */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select P2X0HI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|p2xr
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set P2XR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select P2X0LI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|p2xr
argument_list|)
expr_stmt|;
comment|/* set P2XR[7:4] */
comment|/* P2XR[3:0]=0   */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x62
argument_list|)
expr_stmt|;
comment|/* select P3X0HI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|p3xr
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set P3XR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x63
argument_list|)
expr_stmt|;
comment|/* select P3X0LI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|p3xr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set P3XR[7:3] */
comment|/* P3XR[2:0]=0   */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x64
argument_list|)
expr_stmt|;
comment|/* select PHCAI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|pcodar
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set PCODAR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x65
argument_list|)
expr_stmt|;
comment|/* select PLCAI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|pcodar
argument_list|)
expr_stmt|;
comment|/* set PCODAR[7:2] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* select PUI1SI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|synth_irq
operator|&
literal|0x0F
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Synth IRQ number */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x72
argument_list|)
expr_stmt|;
comment|/* select PUI2SI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|midi_irq
operator|&
literal|0x0F
argument_list|)
argument_list|)
expr_stmt|;
comment|/* MIDI IRQ number */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x74
argument_list|)
expr_stmt|;
comment|/* select PUD1SI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|dma1_chan
operator|&
literal|0x07
argument_list|)
argument_list|)
expr_stmt|;
comment|/* DMA channel 1 */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x75
argument_list|)
expr_stmt|;
comment|/* select PUD2SI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|dma2_chan
operator|&
literal|0x07
argument_list|)
argument_list|)
expr_stmt|;
comment|/* DMA channel 2 */
name|IwavePnpDevice
argument_list|(
name|EXT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select PRAHI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|pcdrar
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set PCDRAR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select PRALI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|pcdrar
argument_list|)
expr_stmt|;
comment|/* set PCDRAR[7:3] */
comment|/* PCDRAR[2:0]=0 */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x62
argument_list|)
expr_stmt|;
comment|/* select PATAHI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|pataar
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set PATAAR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x63
argument_list|)
expr_stmt|;
comment|/* select PATALI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|pataar
argument_list|)
expr_stmt|;
comment|/* set PATAAR[7:1] */
comment|/* PATAAR[0]=0 */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* select PRISI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|ext_irq
operator|&
literal|0x0F
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ext Dev IRQ number */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x74
argument_list|)
expr_stmt|;
comment|/* select PRDSI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|ext_chan
operator|&
literal|0x07
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ext Dev DMA channel */
name|IwavePnpDevice
argument_list|(
name|GAME
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select P201HI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|p201ar
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set P201RAR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select P201LI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|p201ar
argument_list|)
expr_stmt|;
comment|/* set P201AR[7:6] */
name|IwavePnpDevice
argument_list|(
name|EMULATION
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select P388HI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|p388ar
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set P388AR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select P388LI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|p388ar
argument_list|)
expr_stmt|;
comment|/* set P388AR[7:6] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* select PSBISI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|emul_irq
operator|&
literal|0x0F
argument_list|)
argument_list|)
expr_stmt|;
comment|/* emulation IRQ number */
name|IwavePnpDevice
argument_list|(
name|MPU401
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select P401HI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|p401ar
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set P401AR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select P401LI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|p401ar
argument_list|)
expr_stmt|;
comment|/* set P401AR[7:1] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* select PMISI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|mpu_irq
operator|&
literal|0x0F
argument_list|)
argument_list|)
expr_stmt|;
comment|/* MPU emulation IRQ 							 * number */
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|IwaveCfgIOSpace
parameter_list|(
name|void
parameter_list|)
block|{
name|ENTER_CRITICAL
expr_stmt|;
name|IwavePnpDevice
argument_list|(
name|AUDIO
argument_list|)
expr_stmt|;
comment|/* select audio device */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select P2X0HI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|p2xr
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set P2XR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select P2X0LI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|p2xr
argument_list|)
expr_stmt|;
comment|/* set P2XR[7:4] */
comment|/* P2XR[3:0]=0   */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x62
argument_list|)
expr_stmt|;
comment|/* select P3X0HI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|p3xr
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set P3XR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x63
argument_list|)
expr_stmt|;
comment|/* select P3X0LI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|p3xr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set P3XR[7:3] */
comment|/* P3XR[2:0]=0   */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x64
argument_list|)
expr_stmt|;
comment|/* select PHCAI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|pcodar
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set PCODAR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x65
argument_list|)
expr_stmt|;
comment|/* select PLCAI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|pcodar
argument_list|)
expr_stmt|;
comment|/* set PCODAR[7:2] */
name|IwavePnpDevice
argument_list|(
name|EXT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select PRAHI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|pcdrar
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set PCDRAR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select PRALI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|pcdrar
argument_list|)
expr_stmt|;
comment|/* set PCDRAR[7:3] */
comment|/* PCDRAR[2:0]=0 */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x62
argument_list|)
expr_stmt|;
comment|/* select PATAHI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|pataar
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set PATAAR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x63
argument_list|)
expr_stmt|;
comment|/* select PATALI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|pataar
argument_list|)
expr_stmt|;
comment|/* set PATAAR[7:1] */
comment|/* PATAAR[0]=0 */
name|IwavePnpDevice
argument_list|(
name|GAME
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select P201HI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|p201ar
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set P201RAR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select P201LI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|p201ar
argument_list|)
expr_stmt|;
comment|/* set P201AR[7:6] */
name|IwavePnpDevice
argument_list|(
name|EMULATION
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select P388HI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|p388ar
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set P388AR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select P388LI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|p388ar
argument_list|)
expr_stmt|;
comment|/* set P388AR[7:6] */
name|IwavePnpDevice
argument_list|(
name|MPU401
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/* select P401HI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iw
operator|.
name|p401ar
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set P401AR[9:8] */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x61
argument_list|)
expr_stmt|;
comment|/* select P401LI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
operator|(
name|BYTE
operator|)
name|iw
operator|.
name|p401ar
argument_list|)
expr_stmt|;
comment|/* set P401AR[7:1] */
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/* FILE: iwpnp.c */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* REMARKS: This file contains the definitions for the InterWave's DDK */
end_comment

begin_comment
comment|/* functions dedicated to the configuration of the InterWave */
end_comment

begin_comment
comment|/* PNP logic. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* UPDATE: 4/07/95 */
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* FUNCTION: IwavePnpKey */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* PROFILE: This function issues the initiation key that places the PNP */
end_comment

begin_comment
comment|/* logic into configuration mode. The PNP logic is quiescent at */
end_comment

begin_comment
comment|/* power up and must be enabled by software. This function will */
end_comment

begin_comment
comment|/* do 32 I/O writes to the PIDXR (0x0279). The function will */
end_comment

begin_comment
comment|/* first reset the LFSR to its initial value by a sequence of two */
end_comment

begin_comment
comment|/* write cycles of 0x00 to PIDXR before issuing the key. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_function
name|void
name|IwavePnpKey
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* send_Initiation_LFSR(); */
name|BYTE
name|code
init|=
literal|0x6A
decl_stmt|;
name|BYTE
name|msb
decl_stmt|;
name|BYTE
name|i
decl_stmt|;
comment|/* ############################################### */
comment|/* Reset Linear Feedback Shift Reg. */
comment|/* ############################################### */
name|outb
argument_list|(
literal|0x279
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x279
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x279
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/* Initial value */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|msb
operator|=
operator|(
operator|(
name|code
operator|&
literal|0x01
operator|)
operator|^
operator|(
operator|(
name|code
operator|&
literal|0x02
operator|)
operator|>>
literal|1
operator|)
operator|)
operator|<<
literal|7
expr_stmt|;
name|code
operator|=
operator|(
name|code
operator|>>
literal|1
operator|)
operator||
name|msb
expr_stmt|;
name|outb
argument_list|(
literal|0x279
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|BYTE
name|IwavePnpIsol
parameter_list|(
name|PORT
modifier|*
name|pnpread
parameter_list|)
block|{
name|int
name|num_pnp_devs
decl_stmt|;
name|int
name|rd_port
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"Checking for GUS Plug-n-Play ...\n"
argument_list|)
expr_stmt|;
comment|/* Try various READ_DATA ports from 0x203-0x3ff */
for|for
control|(
name|rd_port
operator|=
literal|0x80
init|;
operator|(
name|rd_port
operator|<
literal|0xff
operator|)
condition|;
name|rd_port
operator|+=
literal|0x10
control|)
block|{
if|if
condition|(
literal|0
condition|)
name|printf
argument_list|(
literal|"Trying Read_Port at %x\n"
argument_list|,
operator|(
name|rd_port
operator|<<
literal|2
operator|)
operator||
literal|0x3
argument_list|)
expr_stmt|;
name|num_pnp_devs
operator|=
name|isolation_protocol
argument_list|(
name|rd_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_pnp_devs
condition|)
block|{
operator|*
name|pnpread
operator|=
name|rd_port
operator|<<
literal|2
operator||
literal|0x3
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|num_pnp_devs
condition|)
block|{
name|printf
argument_list|(
literal|"No Plug-n-Play devices were found\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* FUNCTION: IwavePnpSerial */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* PROFILE: This function reads the first nine bytes of the data from */
end_comment

begin_comment
comment|/* the serial EEPROM and returns the Vendor ID and the serial */
end_comment

begin_comment
comment|/* number. First, it resets the EEPROM control logic by */
end_comment

begin_comment
comment|/* issuing a WAKE[CSN] command. The function will return an */
end_comment

begin_comment
comment|/* ASCII string for the vendor ID into the char array pointed */
end_comment

begin_comment
comment|/* to by "vendor" in the VVVNNNN format. The serial number */
end_comment

begin_comment
comment|/* is placed in the 32-bit variable pointed to by "serial". */
end_comment

begin_comment
comment|/* Note that the 9th byte is read but not used as it is invalid */
end_comment

begin_comment
comment|/* when the serial identifier is read via PRESDI. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* This function assumes that the PNP state machine is not in */
end_comment

begin_comment
comment|/* the "wait for key state". Otherwise, unpredictable results */
end_comment

begin_comment
comment|/* will be obtained. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_function
name|void
name|IwavePnpSerial
parameter_list|(
name|PORT
name|pnprdp
parameter_list|,
name|BYTE
name|csn
parameter_list|,
name|BYTE
modifier|*
name|vendor
parameter_list|,
name|DWORD
modifier|*
name|serial
parameter_list|)
block|{
name|BYTE
name|presdi
decl_stmt|,
name|digit
decl_stmt|,
name|i
decl_stmt|;
operator|*
name|serial
operator|=
literal|0L
expr_stmt|;
comment|/* ####################################### */
comment|/* Reset Serial EEPROM logic */
comment|/* ####################################### */
name|IwavePnpWake
argument_list|(
name|csn
argument_list|)
expr_stmt|;
comment|/* Wake card up */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|IwavePnpPeek
argument_list|(
name|pnprdp
argument_list|,
literal|1
argument_list|,
operator|&
name|presdi
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|1
case|:
operator|*
operator|(
name|vendor
operator|++
operator|)
operator|=
operator|(
operator|(
name|presdi
operator|&
literal|0x7C
operator|)
operator|>>
literal|2
operator|)
operator||
literal|0x40
expr_stmt|;
comment|/* 1st char */
operator|*
name|vendor
operator|=
operator|(
name|presdi
operator|&
literal|0x03
operator|)
operator|<<
literal|3
expr_stmt|;
comment|/* isolate bits[4:3] of 							 * 2nd char */
break|break;
case|case
literal|2
case|:
operator|*
name|vendor
operator|=
operator|(
operator|(
name|presdi
operator|&
literal|0xE0
operator|)
operator|>>
literal|5
operator|)
operator||
operator|(
operator|*
name|vendor
operator|)
expr_stmt|;
operator|*
operator|(
name|vendor
operator|++
operator|)
operator|=
operator|(
operator|*
name|vendor
operator|)
operator||
literal|0x40
expr_stmt|;
comment|/* 2nd char */
operator|*
name|vendor
operator|=
operator|(
name|presdi
operator|&
literal|0x1F
operator|)
operator||
literal|0x40
expr_stmt|;
comment|/* 3rd char */
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
name|digit
operator|=
operator|(
name|presdi
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|digit
operator|<=
literal|0x09
condition|)
operator|*
operator|(
operator|++
name|vendor
operator|)
operator|=
name|digit
operator|+
literal|0x30
expr_stmt|;
comment|/* ASCII of digit */
else|else
operator|*
operator|(
operator|++
name|vendor
operator|)
operator|=
operator|(
name|digit
operator|&
literal|0x07
operator|)
operator|+
literal|0x3F
expr_stmt|;
name|digit
operator|=
name|presdi
operator|&
literal|0x0F
expr_stmt|;
if|if
condition|(
name|digit
operator|<=
literal|0x09
condition|)
operator|*
operator|(
operator|++
name|vendor
operator|)
operator|=
name|digit
operator|+
literal|0x30
expr_stmt|;
else|else
operator|*
operator|(
operator|++
name|vendor
operator|)
operator|=
operator|(
name|digit
operator|&
literal|0x07
operator|)
operator|+
literal|0x3F
expr_stmt|;
break|break;
block|}
block|}
operator|*
operator|(
operator|++
name|vendor
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|IwavePnpPeek
argument_list|(
name|pnprdp
argument_list|,
literal|4
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
name|serial
argument_list|)
expr_stmt|;
name|IwavePnpPeek
argument_list|(
name|pnprdp
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* discard checksum */
block|}
end_function

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* FUNCTION: IwavePnpPeek */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* PROFILE: This function will return the number of specified bytes of */
end_comment

begin_comment
comment|/* resource data from the serial EEPROM. The function will NOT */
end_comment

begin_comment
comment|/* reset the serial EEPROM logic to allow reading the entire */
end_comment

begin_comment
comment|/* EEPROM by issuing repeated calls. The caller must supply a */
end_comment

begin_comment
comment|/* pointer to where the data are to be stored. */
end_comment

begin_comment
comment|/* It is assumed that the InterWave is not in either "sleep" */
end_comment

begin_comment
comment|/* or "wait for key" states. Note that on the first call, if */
end_comment

begin_comment
comment|/* the caller means to read from the beggining of data the */
end_comment

begin_comment
comment|/* serial EEPROM logic must be reset. For this, the caller */
end_comment

begin_comment
comment|/* should issue a WAKE[CSN] command */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_function
name|void
name|IwavePnpPeek
parameter_list|(
name|PORT
name|pnprdp
parameter_list|,
name|WORD
name|bytes
parameter_list|,
name|BYTE
modifier|*
name|data
parameter_list|)
block|{
name|WORD
name|i
decl_stmt|;
name|BYTE
name|datum
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|bytes
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* select PRESSI */
while|while
condition|(
name|TRUE
condition|)
block|{
comment|/* wait til new data byte is ready */
if|if
condition|(
name|inb
argument_list|(
name|pnprdp
argument_list|)
operator|&
name|PNP_DATA_RDY
condition|)
break|break;
comment|/* new resource byte ready */
block|}
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* select PRESDI */
name|datum
operator|=
name|inb
argument_list|(
name|pnprdp
argument_list|)
expr_stmt|;
comment|/* read resource byte */
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|data
operator|++
operator|)
operator|=
name|datum
expr_stmt|;
comment|/* store it */
block|}
block|}
end_function

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* FUNCTION: IwavePnpEeprom */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* PROFILE: This function allows the caller to control the serial */
end_comment

begin_comment
comment|/* EEPROM directly while the audio device is inactive. To */
end_comment

begin_comment
comment|/* de-activate the audio device issue the call */
end_comment

begin_comment
comment|/* IwavePnpActivate(AUDIO,OFF). */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_function
name|void
name|IwavePnpEeprom
parameter_list|(
name|BYTE
name|ctrl
parameter_list|)
block|{
name|ENTER_CRITICAL
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0xF1
argument_list|)
expr_stmt|;
comment|/* select PSECI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
name|ctrl
argument_list|)
expr_stmt|;
comment|/* write PSECI */
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* FUNCTION: IwavePnpActivate */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* PROFILE: This function will activate or de-activate the audio device */
end_comment

begin_comment
comment|/* or the external device on the InterWave. Set the "dev" arg */
end_comment

begin_comment
comment|/* to AUDIO for the audio device or EXT for the external device. */
end_comment

begin_comment
comment|/* Set "bool" to ON or OFF to turn the device on or off the ISA */
end_comment

begin_comment
comment|/* bus. Notice that for a logical device to work, it must be */
end_comment

begin_comment
comment|/* activated. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_function
name|void
name|IwavePnpActivate
parameter_list|(
name|BYTE
name|dev
parameter_list|,
name|BYTE
name|bool
parameter_list|)
block|{
name|IwavePnpDevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* select audio device */
name|ENTER_CRITICAL
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
name|ACTIVATE_DEV
argument_list|)
expr_stmt|;
comment|/* select Activate Register */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
name|bool
argument_list|)
expr_stmt|;
comment|/* write register */
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* FUNCTION: IwavePnpDevice */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* PROFILE: This function allows the caller to select between five */
end_comment

begin_comment
comment|/* logical devices available on the InterWave.It is assumed */
end_comment

begin_comment
comment|/* that the PNP state machine is in configuration mode. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_function
name|void
name|IwavePnpDevice
parameter_list|(
name|BYTE
name|dev
parameter_list|)
block|{
name|ENTER_CRITICAL
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
name|_PLDNI
argument_list|)
expr_stmt|;
comment|/* select PLDNI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* write PLDNI */
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* FUNCTION: IwavePnpPower */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* PROFILE: This function allows the caller to disable major sections of */
end_comment

begin_comment
comment|/* the InterWave to prevent them from consuming power and */
end_comment

begin_comment
comment|/* loading the ISA bus. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* It is assumed that the PNP state machine is in configuration */
end_comment

begin_comment
comment|/* mode. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_function
name|void
name|IwavePnpPower
parameter_list|(
name|BYTE
name|mode
parameter_list|)
block|{
name|ENTER_CRITICAL
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
name|_PPWRI
argument_list|)
expr_stmt|;
comment|/* select PPWRI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* write PPWRI */
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* FUNCTION: IwavePnpWake */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* PROFILE: This function issues a WAKE[CSN] command to the InterWave. If */
end_comment

begin_comment
comment|/* the CSN matches the PNP state machine will enter the */
end_comment

begin_comment
comment|/* configuration state. Otherwise it will enter the sleep mode. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* It is assumed that the PNP state machine is not in the */
end_comment

begin_comment
comment|/* "wait for key" state. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_function
name|void
name|IwavePnpWake
parameter_list|(
name|BYTE
name|csn
parameter_list|)
block|{
name|ENTER_CRITICAL
expr_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
name|_PWAKEI
argument_list|)
expr_stmt|;
comment|/* select PWAKEI */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
name|csn
argument_list|)
expr_stmt|;
comment|/* write csn */
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* FUNCTION: IwavePnpIOcheck */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* PROFILE: This function allows the caller to perform a conflict check */
end_comment

begin_comment
comment|/* on an I/O port to be used by a logical device. The function */
end_comment

begin_comment
comment|/* receives the base address of the I/O range as well as the */
end_comment

begin_comment
comment|/* number of ports in the range and then performs the I/O check */
end_comment

begin_comment
comment|/* protocol. It returns the address of the port if a conflict */
end_comment

begin_comment
comment|/* is detected or IO_CHK if no conflict is detected. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* This function assumes that the logical device has been de- */
end_comment

begin_comment
comment|/* activated and that the PNP state machine is in config mode. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_function
name|PORT
name|IwavePnpIOcheck
parameter_list|(
name|PORT
name|base
parameter_list|,
name|BYTE
name|no_ports
parameter_list|)
block|{
name|BYTE
name|i
decl_stmt|;
name|PORT
name|portid
decl_stmt|;
name|outb
argument_list|(
name|_PIDXR
argument_list|,
name|RANGE_IOCHK
argument_list|)
expr_stmt|;
comment|/* select IO range check reg */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|no_ports
condition|;
name|i
operator|++
control|)
block|{
name|portid
operator|=
name|base
operator|+
name|i
expr_stmt|;
comment|/* port to check */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* must drive 0xAA onto bus */
if|if
condition|(
name|inb
argument_list|(
name|portid
argument_list|)
operator|!=
literal|0xAA
condition|)
return|return
operator|(
name|portid
operator|)
return|;
comment|/* IO conflict detected */
name|outb
argument_list|(
name|_PNPWRP
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* must drive 0x55 onto bus */
if|if
condition|(
name|inb
argument_list|(
name|portid
argument_list|)
operator|!=
literal|0x55
condition|)
return|return
operator|(
name|portid
operator|)
return|;
comment|/* IO conflict detected */
block|}
return|return
operator|(
name|IO_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* FUNCTION: IwavePnpGetCSN */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* PROFILE: This function allows the caller to detect an InterWave based */
end_comment

begin_comment
comment|/* adapter board and will return its asigned CSN so that an */
end_comment

begin_comment
comment|/* an application can access its PnP interface and determine the */
end_comment

begin_comment
comment|/* borad's current configuration. In conducting its search for */
end_comment

begin_comment
comment|/* the InterWave IC, the function will use the first 32 bits of */
end_comment

begin_comment
comment|/* the Serial Identifier called the vendor ID in the PnP ISA */
end_comment

begin_comment
comment|/* spec. The last 4 bits in the Vendor ID represent a revision */
end_comment

begin_comment
comment|/* number for the particular product and this function gives the */
end_comment

begin_comment
comment|/* caller the option of taking this revision number into account */
end_comment

begin_comment
comment|/* or not in the search. If the function fails to find the */
end_comment

begin_comment
comment|/* InterWave IC it will return FALSE. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_function
name|BYTE
name|IwavePnpGetCSN
parameter_list|(
name|DWORD
name|VendorID
parameter_list|,
name|BYTE
name|csn_max
parameter_list|)
block|{
name|BYTE
name|csn
decl_stmt|;
name|DWORD
name|vendor
decl_stmt|;
name|IwavePnpKey
argument_list|()
expr_stmt|;
comment|/* Key to access PnP Interface */
name|VendorID
operator|&=
operator|(
literal|0xFFFFFFF0
operator|)
expr_stmt|;
comment|/* reset 4 least significant bits */
for|for
control|(
name|csn
operator|=
literal|1
init|;
name|csn
operator|<=
name|csn_max
condition|;
name|csn
operator|++
control|)
block|{
name|IwavePnpWake
argument_list|(
name|csn
argument_list|)
expr_stmt|;
comment|/* Select card */
name|IwavePnpPeek
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|,
literal|4
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
operator|&
name|vendor
argument_list|)
expr_stmt|;
comment|/* get vendor ID */
name|vendor
operator|&=
operator|(
literal|0xFFFFFFF0
operator|)
expr_stmt|;
if|if
condition|(
name|vendor
operator|==
name|VendorID
condition|)
block|{
comment|/* If IDs match, InterWave is 						 * found */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Place all cards in 						 * wait-for-key state */
name|outb
argument_list|(
literal|0x0A79
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
return|return
operator|(
name|csn
operator|)
return|;
block|}
block|}
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Place all cards in wait-for-key state */
name|outb
argument_list|(
literal|0x0A79
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* InterWave IC not found */
block|}
end_function

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/*  * FUNCTION: IwavePnpPing  */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* PROFILE: This function allows the caller to detect an InterWave based */
end_comment

begin_comment
comment|/* adapter board and will return its asigned CSN so that an */
end_comment

begin_comment
comment|/* an application can access its PnP interface and determine the */
end_comment

begin_comment
comment|/* borad's current configuration. In conducting its search for */
end_comment

begin_comment
comment|/* the InterWave IC, the function will use the first 32 bits of */
end_comment

begin_comment
comment|/* the Serial Identifier called the vendor ID in the PnP ISA */
end_comment

begin_comment
comment|/* spec. The last 4 bits in the Vendor ID represent a revision */
end_comment

begin_comment
comment|/* number for the particular product and will not be included */
end_comment

begin_comment
comment|/* in the search. The function will return the Vendor ID and the */
end_comment

begin_comment
comment|/* calling application should check the revision bits to make */
end_comment

begin_comment
comment|/* sure they are compatible with the board. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_function
name|BYTE
name|IwavePnpPing
parameter_list|(
name|DWORD
name|VendorID
parameter_list|)
block|{
name|BYTE
name|csn
decl_stmt|;
name|VendorID
operator|&=
operator|(
literal|0xFFFFFFF0
operator|)
expr_stmt|;
comment|/* reset 4 least significant bits */
name|IwavePnpKey
argument_list|()
expr_stmt|;
comment|/* Key to access PnP Interface */
while|while
condition|(
name|iw
operator|.
name|pnprdp
operator|<=
literal|0x23F
condition|)
block|{
for|for
control|(
name|csn
operator|=
literal|1
init|;
name|csn
operator|<=
literal|10
condition|;
name|csn
operator|++
control|)
block|{
name|IwavePnpWake
argument_list|(
name|csn
argument_list|)
expr_stmt|;
comment|/* Select card */
name|IwavePnpPeek
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|,
literal|4
argument_list|,
operator|(
name|BYTE
operator|*
operator|)
operator|&
name|iw
operator|.
name|vendor
argument_list|)
expr_stmt|;
comment|/* get vendor ID */
if|if
condition|(
operator|(
operator|(
name|iw
operator|.
name|vendor
operator|)
operator|&
literal|0xFFFFFFF0
operator|)
operator|==
name|VendorID
condition|)
block|{
comment|/* If IDs match, 									 * InterWave is found */
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Place all cards in 							 * wait-for-key state */
name|outb
argument_list|(
literal|0x0A79
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
return|return
operator|(
name|csn
operator|)
return|;
block|}
block|}
name|iw
operator|.
name|pnprdp
operator|+=
literal|0x04
expr_stmt|;
block|}
name|outb
argument_list|(
name|_PIDXR
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Place all cards in wait-for-key state */
name|outb
argument_list|(
literal|0x0A79
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* InterWave IC not found */
block|}
end_function

begin_comment
comment|/* end of pnp code */
end_comment

begin_function
name|WORD
name|IwaveMemSize
parameter_list|(
name|void
parameter_list|)
block|{
name|BYTE
name|datum
init|=
literal|0x55
decl_stmt|;
name|ADDRESS
name|local
init|=
literal|0L
decl_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
name|_LMCI
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
name|inb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|)
operator|&
literal|0xFD
argument_list|)
expr_stmt|;
comment|/* DRAM I/O cycles selected */
while|while
condition|(
name|TRUE
condition|)
block|{
name|IwaveMemPoke
argument_list|(
name|local
argument_list|,
name|datum
argument_list|)
expr_stmt|;
name|IwaveMemPoke
argument_list|(
name|local
operator|+
literal|1L
argument_list|,
name|datum
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IwaveMemPeek
argument_list|(
name|local
argument_list|)
operator|!=
name|datum
operator|||
name|IwaveMemPeek
argument_list|(
name|local
operator|+
literal|1L
argument_list|)
operator|!=
operator|(
name|datum
operator|+
literal|1
operator|)
operator|||
name|IwaveMemPeek
argument_list|(
literal|0L
argument_list|)
operator|!=
literal|0x55
condition|)
break|break;
name|local
operator|+=
name|RAM_STEP
expr_stmt|;
name|datum
operator|++
expr_stmt|;
block|}
return|return
operator|(
call|(
name|WORD
call|)
argument_list|(
name|local
operator|>>
literal|10
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|BYTE
name|IwaveMemPeek
parameter_list|(
name|ADDRESS
name|addr
parameter_list|)
block|{
name|PORT
name|p3xr
decl_stmt|;
name|p3xr
operator|=
name|iw
operator|.
name|p3xr
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
literal|0x43
argument_list|)
expr_stmt|;
comment|/* Select LMALI */
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
operator|(
name|WORD
operator|)
name|addr
argument_list|)
expr_stmt|;
comment|/* Lower 16 bits of LM */
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
comment|/* Select LMAHI */
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|addr
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Upper 8 bits of LM */
return|return
operator|(
name|inb
argument_list|(
name|iw
operator|.
name|lmbdr
argument_list|)
operator|)
return|;
comment|/* return byte from LMBDR */
block|}
end_function

begin_function
name|void
name|IwaveMemPoke
parameter_list|(
name|ADDRESS
name|addr
parameter_list|,
name|BYTE
name|datum
parameter_list|)
block|{
name|PORT
name|p3xr
decl_stmt|;
name|p3xr
operator|=
name|iw
operator|.
name|p3xr
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
literal|0x43
argument_list|)
expr_stmt|;
comment|/* Select LMALI */
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
operator|(
name|WORD
operator|)
name|addr
argument_list|)
expr_stmt|;
comment|/* Lower 16 bits of LM */
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
literal|0x44
argument_list|)
expr_stmt|;
comment|/* Select LMAHI */
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|addr
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Upper 8 bits of LM */
name|outb
argument_list|(
name|iw
operator|.
name|lmbdr
argument_list|,
name|datum
argument_list|)
expr_stmt|;
comment|/* Write byte to LMBDR */
block|}
end_function

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* FUNCTION: IwaveMemCfg */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* PROFILE : This function determines the amount of DRAM from its */
end_comment

begin_comment
comment|/* configuration accross all banks. It sets the configuration */
end_comment

begin_comment
comment|/* into register LMCFI and stores the total amount of DRAM */
end_comment

begin_comment
comment|/* into iw.size_mem (Kbytes). */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* The function first places the IC in enhanced mode to allow */
end_comment

begin_comment
comment|/* full access to all DRAM locations. Then it selects full */
end_comment

begin_comment
comment|/* addressing span (LMCFI[3:0]=0x0C). Finally, it determines */
end_comment

begin_comment
comment|/* the amount of DRAM in each bank and from this the actual */
end_comment

begin_comment
comment|/* configuration. */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* Note that if a configuration other than one indicated in */
end_comment

begin_comment
comment|/* the manual is implemented, this function will select */
end_comment

begin_comment
comment|/* full addressing span (LMCFI[3:0]=0xC). */
end_comment

begin_comment
comment|/* */
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_function
name|void
name|IwaveMemCfg
parameter_list|(
name|DWORD
modifier|*
name|lpbanks
parameter_list|)
block|{
name|DWORD
name|bank
index|[
literal|4
index|]
init|=
block|{
literal|0L
block|,
literal|0L
block|,
literal|0L
block|,
literal|0L
block|}
decl_stmt|;
name|DWORD
name|addr
init|=
literal|0L
decl_stmt|,
name|base
init|=
literal|0L
decl_stmt|,
name|cnt
init|=
literal|0L
decl_stmt|;
name|BYTE
name|i
decl_stmt|,
name|reg
decl_stmt|,
name|ram
init|=
name|FALSE
decl_stmt|;
name|WORD
name|lmcfi
decl_stmt|;
comment|/* */
name|ENTER_CRITICAL
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
literal|0x99
argument_list|)
expr_stmt|;
name|reg
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|)
expr_stmt|;
comment|/* image of sgmi */
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|reg
operator||
literal|0x01
argument_list|)
argument_list|)
expr_stmt|;
comment|/* enable enhaced mode */
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
name|_LMCFI
argument_list|)
expr_stmt|;
comment|/* select LM Conf Reg */
name|lmcfi
operator|=
name|inw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|)
operator|&
literal|0xFFF0
expr_stmt|;
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|lmcfi
operator||
literal|0x000C
argument_list|)
expr_stmt|;
comment|/* max addr span */
comment|/* */
comment|/* Clear every RAM_STEPth location */
comment|/* */
while|while
condition|(
name|addr
operator|<
name|RAM_MAX
condition|)
block|{
name|IwaveMemPoke
argument_list|(
name|addr
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|RAM_STEP
expr_stmt|;
block|}
comment|/* */
comment|/* Determine amount of RAM in each bank */
comment|/* */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|IwaveMemPoke
argument_list|(
name|base
argument_list|,
literal|0xAA
argument_list|)
expr_stmt|;
comment|/* mark start of bank */
name|IwaveMemPoke
argument_list|(
name|base
operator|+
literal|1L
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|IwaveMemPeek
argument_list|(
name|base
argument_list|)
operator|==
literal|0xAA
operator|)
operator|&&
operator|(
name|IwaveMemPeek
argument_list|(
name|base
operator|+
literal|1L
argument_list|)
operator|==
literal|0x55
operator|)
condition|)
name|ram
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ram
condition|)
block|{
while|while
condition|(
name|cnt
operator|<
name|BANK_MAX
condition|)
block|{
name|bank
index|[
name|i
index|]
operator|+=
name|RAM_STEP
expr_stmt|;
name|cnt
operator|+=
name|RAM_STEP
expr_stmt|;
name|addr
operator|=
name|base
operator|+
name|cnt
expr_stmt|;
if|if
condition|(
name|IwaveMemPeek
argument_list|(
name|addr
argument_list|)
operator|==
literal|0xAA
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|lpbanks
operator|!=
name|NULL
condition|)
block|{
operator|*
name|lpbanks
operator|=
name|bank
index|[
name|i
index|]
expr_stmt|;
name|lpbanks
operator|++
expr_stmt|;
block|}
name|bank
index|[
name|i
index|]
operator|=
name|bank
index|[
name|i
index|]
operator|>>
literal|10
expr_stmt|;
name|base
operator|+=
name|BANK_MAX
expr_stmt|;
name|cnt
operator|=
literal|0L
expr_stmt|;
name|ram
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* */
name|iw
operator|.
name|flags
operator|&=
operator|~
name|DRAM_HOLES
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
name|_LMCFI
argument_list|)
expr_stmt|;
if|if
condition|(
name|bank
index|[
literal|0
index|]
operator|==
literal|256
operator|&&
name|bank
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|bank
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|bank
index|[
literal|3
index|]
operator|==
literal|0
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|lmcfi
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bank
index|[
literal|0
index|]
operator|==
literal|256
operator|&&
name|bank
index|[
literal|1
index|]
operator|==
literal|256
operator|&&
name|bank
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|bank
index|[
literal|3
index|]
operator|==
literal|0
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|lmcfi
operator||
literal|0x01
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bank
index|[
literal|0
index|]
operator|==
literal|256
operator|&&
name|bank
index|[
literal|1
index|]
operator|==
literal|256
operator|&&
name|bank
index|[
literal|2
index|]
operator|==
literal|256
operator|&&
name|bank
index|[
literal|3
index|]
operator|==
literal|256
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|lmcfi
operator||
literal|0x02
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bank
index|[
literal|0
index|]
operator|==
literal|256
operator|&&
name|bank
index|[
literal|1
index|]
operator|==
literal|1024
operator|&&
name|bank
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|bank
index|[
literal|3
index|]
operator|==
literal|0
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|lmcfi
operator||
literal|0x03
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bank
index|[
literal|0
index|]
operator|==
literal|256
operator|&&
name|bank
index|[
literal|1
index|]
operator|==
literal|1024
operator|&&
name|bank
index|[
literal|2
index|]
operator|==
literal|1024
operator|&&
name|bank
index|[
literal|3
index|]
operator|==
literal|1024
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|lmcfi
operator||
literal|0x04
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bank
index|[
literal|0
index|]
operator|==
literal|256
operator|&&
name|bank
index|[
literal|1
index|]
operator|==
literal|256
operator|&&
name|bank
index|[
literal|2
index|]
operator|==
literal|1024
operator|&&
name|bank
index|[
literal|3
index|]
operator|==
literal|0
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|lmcfi
operator||
literal|0x05
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bank
index|[
literal|0
index|]
operator|==
literal|256
operator|&&
name|bank
index|[
literal|1
index|]
operator|==
literal|256
operator|&&
name|bank
index|[
literal|2
index|]
operator|==
literal|1024
operator|&&
name|bank
index|[
literal|3
index|]
operator|==
literal|1024
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|lmcfi
operator||
literal|0x06
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bank
index|[
literal|0
index|]
operator|==
literal|1024
operator|&&
name|bank
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|bank
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|bank
index|[
literal|3
index|]
operator|==
literal|0
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|lmcfi
operator||
literal|0x07
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bank
index|[
literal|0
index|]
operator|==
literal|1024
operator|&&
name|bank
index|[
literal|1
index|]
operator|==
literal|1024
operator|&&
name|bank
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|bank
index|[
literal|3
index|]
operator|==
literal|0
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|lmcfi
operator||
literal|0x08
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bank
index|[
literal|0
index|]
operator|==
literal|1024
operator|&&
name|bank
index|[
literal|1
index|]
operator|==
literal|1024
operator|&&
name|bank
index|[
literal|2
index|]
operator|==
literal|1024
operator|&&
name|bank
index|[
literal|3
index|]
operator|==
literal|1024
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|lmcfi
operator||
literal|0x09
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bank
index|[
literal|0
index|]
operator|==
literal|4096
operator|&&
name|bank
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|bank
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|bank
index|[
literal|3
index|]
operator|==
literal|0
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|lmcfi
operator||
literal|0x0A
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bank
index|[
literal|0
index|]
operator|==
literal|4096
operator|&&
name|bank
index|[
literal|1
index|]
operator|==
literal|4096
operator|&&
name|bank
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|bank
index|[
literal|3
index|]
operator|==
literal|0
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|lmcfi
operator||
literal|0x0B
argument_list|)
expr_stmt|;
else|else
comment|/* Flag the non-contiguous config of memory */
name|iw
operator|.
name|flags
operator||=
name|DRAM_HOLES
expr_stmt|;
comment|/* */
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
comment|/* restore sgmi */
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ######################################################################## */
end_comment

begin_comment
comment|/**/
end_comment

begin_comment
comment|/* FUNCTION: IwaveCodecIrq */
end_comment

begin_comment
comment|/**/
end_comment

begin_comment
comment|/* PROFILE: This function disables or enables the Codec Interrupts. To */
end_comment

begin_comment
comment|/* enable interrupts set CEXTI[2] high thus causing all interrupt */
end_comment

begin_comment
comment|/* sources (CSR3I[6:4]) to pass onto the IRQ pin. To disable */
end_comment

begin_comment
comment|/* interrupts set CEXTI[1]=0. To enable Code IRQs issue this call: */
end_comment

begin_comment
comment|/**/
end_comment

begin_comment
comment|/* IwaveCodecIrq(CODEC_IRQ_ENABLE). To disable IRQs issue the call */
end_comment

begin_comment
comment|/**/
end_comment

begin_comment
comment|/* IwaveCodeIrq(~CODEC_IRQ_ENABLE). */
end_comment

begin_comment
comment|/**/
end_comment

begin_comment
comment|/* ######################################################################## */
end_comment

begin_function
name|void
name|IwaveCodecIrq
parameter_list|(
name|BYTE
name|mode
parameter_list|)
block|{
name|BYTE
name|reg
decl_stmt|;
name|ENTER_CRITICAL
expr_stmt|;
name|reg
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|)
operator|&
literal|0xE0
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|,
name|reg
operator||
name|_CSR3I
argument_list|)
expr_stmt|;
comment|/* select CSR3I */
name|outb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* clear all interrupts */
name|outb
argument_list|(
name|iw
operator|.
name|pcodar
operator|+
literal|0x02
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* clear CSR1R */
name|outb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|,
name|reg
operator||
name|_CEXTI
argument_list|)
expr_stmt|;
comment|/* select CEXTI */
name|reg
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|CODEC_IRQ_ENABLE
condition|)
comment|/* enable Codec Irqs */
name|outb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|reg
operator||
name|CODEC_IRQ_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* disable Codec Irqs */
name|outb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|reg
operator|&
operator|~
name|CODEC_IRQ_ENABLE
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ######################################################################### */
end_comment

begin_comment
comment|/**/
end_comment

begin_comment
comment|/* FUNCTION: IwaveRegPeek */
end_comment

begin_comment
comment|/**/
end_comment

begin_comment
comment|/* PROFILE : This function returns the value stored in any readable */
end_comment

begin_comment
comment|/* InterWave register. It takes as input a pointer to a */
end_comment

begin_comment
comment|/* structure containing the addresses of the relocatable I/O */
end_comment

begin_comment
comment|/* space as well as a register mnemonic. To correctly use this */
end_comment

begin_comment
comment|/* function, the programmer must use the mnemonics defined in */
end_comment

begin_comment
comment|/* "iwdefs.h". These mnemonics contain coded information used */
end_comment

begin_comment
comment|/* by the function to properly access the desired register. */
end_comment

begin_comment
comment|/**/
end_comment

begin_comment
comment|/* An attempt to read from a write-only register will return */
end_comment

begin_comment
comment|/* meaningless data. */
end_comment

begin_comment
comment|/**/
end_comment

begin_comment
comment|/* ######################################################################### */
end_comment

begin_function
name|WORD
name|IwaveRegPeek
parameter_list|(
name|DWORD
name|reg_mnem
parameter_list|)
block|{
name|BYTE
name|index
decl_stmt|,
name|val
decl_stmt|;
name|WORD
name|reg_id
decl_stmt|,
name|offset
decl_stmt|;
name|offset
operator|=
call|(
name|WORD
call|)
argument_list|(
operator|(
name|BYTE
operator|)
name|reg_mnem
argument_list|)
expr_stmt|;
name|reg_id
operator|=
call|(
name|WORD
call|)
argument_list|(
name|reg_mnem
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|index
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|reg_mnem
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* ################################################### */
comment|/* Logic to read registers in P2XR block& GMCR */
comment|/* ################################################### */
if|if
condition|(
name|reg_id
operator|>=
literal|0x0001
operator|&&
name|reg_id
operator|<=
literal|0x001A
condition|)
block|{
comment|/* UMCR to GMCR */
if|if
condition|(
name|reg_id
operator|<=
literal|0x000E
condition|)
comment|/* UMCR to USRR */
return|return
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|p2xr
operator|+
name|offset
argument_list|)
operator|)
return|;
if|if
condition|(
name|reg_id
operator|==
literal|0x0019
condition|)
return|return
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|p201ar
argument_list|)
operator|)
return|;
else|else
block|{
comment|/* GUS Hidden registers or GMCR */
name|BYTE
name|iveri
decl_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
literal|0x5B
argument_list|)
expr_stmt|;
comment|/* select IVERI */
name|iveri
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|)
expr_stmt|;
comment|/* read IVERI */
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iveri
operator||
literal|0x09
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set IVERI[3,0] */
if|if
condition|(
name|reg_id
operator|==
literal|0x001A
condition|)
block|{
comment|/* GMCR */
name|val
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|p3xr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
name|iveri
argument_list|)
expr_stmt|;
comment|/* restore IVERI */
return|return
operator|(
operator|(
name|WORD
operator|)
name|val
operator|)
return|;
block|}
name|val
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|p2xr
operator|+
literal|0x0F
argument_list|)
expr_stmt|;
comment|/* read URCR */
name|val
operator|=
operator|(
name|val
operator|&
literal|0xF8
operator|)
operator||
name|index
expr_stmt|;
comment|/* value for URCR[2:0] */
name|outb
argument_list|(
name|iw
operator|.
name|p2xr
operator|+
literal|0x0F
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* set URCR[2:0] */
if|if
condition|(
name|reg_mnem
operator|==
name|UDCI
operator|||
name|reg_mnem
operator|==
name|UICI
condition|)
block|{
name|val
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|p2xr
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_mnem
operator|==
name|UDCI
condition|)
name|outb
argument_list|(
name|iw
operator|.
name|p2xr
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|val
operator|&
literal|0xBF
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|iw
operator|.
name|p2xr
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|val
operator||
literal|0x40
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|p2xr
operator|+
literal|0x0B
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
literal|0x5B
argument_list|)
expr_stmt|;
comment|/* select IVERI */
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
name|iveri
argument_list|)
expr_stmt|;
comment|/* restore IVERI */
return|return
operator|(
operator|(
name|WORD
operator|)
name|val
operator|)
return|;
comment|/* read register */
block|}
block|}
comment|/* ################################################### */
comment|/* Logic to read registers in P3XR block */
comment|/* ################################################### */
if|if
condition|(
name|reg_id
operator|>=
literal|0x001B
operator|&&
name|reg_id
operator|<=
literal|0x005C
condition|)
block|{
comment|/* GMSR to LMBDR */
if|if
condition|(
name|reg_id
operator|==
literal|0x005C
condition|)
comment|/* LMBDR */
return|return
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|lmbdr
argument_list|)
operator|)
return|;
if|if
condition|(
name|reg_id
operator|>=
literal|0x001B
operator|&&
name|reg_id
operator|<=
literal|0x0021
condition|)
comment|/* GMSR to I8DP */
if|if
condition|(
name|offset
operator|==
literal|0x04
condition|)
return|return
operator|(
name|inw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|p3xr
operator|+
name|offset
argument_list|)
operator|)
return|;
else|else
block|{
comment|/* indexed registers */
if|if
condition|(
name|reg_id
operator|<=
literal|0x003F
condition|)
name|index
operator||=
literal|0x80
expr_stmt|;
comment|/* adjust for reading */
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* select register */
if|if
condition|(
name|offset
operator|==
literal|0x04
condition|)
return|return
operator|(
name|inw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* #################################################### */
comment|/* Logic to read registers in PCODAR block */
comment|/* #################################################### */
if|if
condition|(
name|reg_id
operator|>=
literal|0x005D
operator|&&
name|reg_id
operator|<=
literal|0x0081
condition|)
block|{
comment|/* CIDXR to CLRCTI */
if|if
condition|(
name|reg_id
operator|<=
literal|0x0061
condition|)
return|return
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pcodar
operator|+
name|offset
argument_list|)
operator|)
return|;
comment|/* CRDR */
else|else
block|{
comment|/* indexed registers */
name|BYTE
name|cidxr
decl_stmt|;
name|cidxr
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|)
expr_stmt|;
name|cidxr
operator|=
operator|(
name|cidxr
operator|&
literal|0xE0
operator|)
operator|+
name|index
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|,
name|cidxr
argument_list|)
expr_stmt|;
comment|/* select register */
return|return
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* ##################################################### */
comment|/* Logic to read the PnP registers */
comment|/* ##################################################### */
if|if
condition|(
name|reg_id
operator|>=
literal|0x0082
operator|&&
name|reg_id
operator|<=
literal|0x00B7
condition|)
block|{
comment|/* PCSNBR to PMITI */
if|if
condition|(
name|reg_id
operator|==
literal|0x0085
condition|)
return|return
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|)
return|;
if|if
condition|(
name|reg_id
operator|<
literal|0x0085
condition|)
return|return
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
operator|(
name|WORD
operator|)
name|reg_mnem
argument_list|)
operator|)
return|;
else|else
block|{
comment|/* indexed registers */
if|if
condition|(
name|reg_id
operator|>=
literal|0x008E
operator|&&
name|reg_id
operator|<=
literal|0x00B7
condition|)
block|{
name|outb
argument_list|(
literal|0x0279
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
comment|/* select PLDNI */
name|outb
argument_list|(
literal|0xA79
argument_list|,
operator|(
name|BYTE
operator|)
name|offset
argument_list|)
expr_stmt|;
comment|/* select logical dev */
block|}
name|outb
argument_list|(
literal|0x0279
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* select the register */
return|return
operator|(
operator|(
name|WORD
operator|)
name|inb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|)
operator|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ######################################################################### */
end_comment

begin_comment
comment|/**/
end_comment

begin_comment
comment|/* FUNCTION: IwaveRegPoke */
end_comment

begin_comment
comment|/**/
end_comment

begin_comment
comment|/* PROFILE : This function writes a value to any writable */
end_comment

begin_comment
comment|/* InterWave register. It takes as input a pointer to a */
end_comment

begin_comment
comment|/* structure containing the addresses of the relocatable I/O */
end_comment

begin_comment
comment|/* space as well as a register mnemonic. To correctly use this */
end_comment

begin_comment
comment|/* function, the programmer must use the mnemonics defined in */
end_comment

begin_comment
comment|/* "iwdefs.h". These mnemonics contain coded information used */
end_comment

begin_comment
comment|/* by the function to properly access the desired register. */
end_comment

begin_comment
comment|/**/
end_comment

begin_comment
comment|/* This function does not guard against writing to read-only */
end_comment

begin_comment
comment|/* registers. It is the programmer's responsibility to ensure */
end_comment

begin_comment
comment|/* that the writes are to valid registers. */
end_comment

begin_comment
comment|/**/
end_comment

begin_comment
comment|/* ######################################################################### */
end_comment

begin_function
name|void
name|IwaveRegPoke
parameter_list|(
name|DWORD
name|reg_mnem
parameter_list|,
name|WORD
name|datum
parameter_list|)
block|{
name|BYTE
name|index
decl_stmt|;
name|BYTE
name|val
decl_stmt|;
name|WORD
name|reg_id
decl_stmt|;
name|WORD
name|offset
decl_stmt|;
name|offset
operator|=
call|(
name|WORD
call|)
argument_list|(
operator|(
name|BYTE
operator|)
name|reg_mnem
argument_list|)
expr_stmt|;
name|reg_id
operator|=
call|(
name|WORD
call|)
argument_list|(
name|reg_mnem
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|index
operator|=
call|(
name|BYTE
call|)
argument_list|(
name|reg_mnem
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* ####################################################### */
comment|/* Logic to write to registers in P2XR block */
comment|/* ####################################################### */
if|if
condition|(
name|reg_id
operator|>=
literal|0x0001
operator|&&
name|reg_id
operator|<=
literal|0x0019
condition|)
block|{
comment|/* UMCR to GGCR */
if|if
condition|(
name|reg_id
operator|<=
literal|0x000E
condition|)
block|{
comment|/* UMCR to USRR */
name|outb
argument_list|(
name|iw
operator|.
name|p2xr
operator|+
name|offset
argument_list|,
operator|(
name|BYTE
operator|)
name|datum
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reg_id
operator|==
literal|0x0019
condition|)
block|{
name|outb
argument_list|(
name|iw
operator|.
name|p201ar
argument_list|,
operator|(
name|BYTE
operator|)
name|datum
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* GUS Hidden registers */
name|BYTE
name|iveri
decl_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
literal|0x5B
argument_list|)
expr_stmt|;
comment|/* select IVERI */
name|iveri
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|)
expr_stmt|;
comment|/* read IVERI */
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|iveri
operator||
literal|0x09
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set IVERI[3,0] */
name|val
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|p2xr
operator|+
literal|0x0F
argument_list|)
expr_stmt|;
comment|/* read URCR */
name|val
operator|=
operator|(
name|val
operator|&
literal|0xF8
operator|)
operator||
name|index
expr_stmt|;
comment|/* value for URCR[2:0] */
name|outb
argument_list|(
name|iw
operator|.
name|p2xr
operator|+
literal|0x0F
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/* set URCR[2:0] */
if|if
condition|(
name|reg_mnem
operator|==
name|UDCI
operator|||
name|reg_mnem
operator|==
name|UICI
condition|)
block|{
name|val
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|p2xr
argument_list|)
expr_stmt|;
comment|/* read UMCR */
if|if
condition|(
name|reg_mnem
operator|==
name|UDCI
condition|)
name|outb
argument_list|(
name|iw
operator|.
name|p2xr
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|val
operator|&
literal|0xBF
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set UMCR[6]=0 */
else|else
name|outb
argument_list|(
name|iw
operator|.
name|p2xr
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|val
operator||
literal|0x40
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set UMCR[6]=1 */
block|}
name|outb
argument_list|(
name|iw
operator|.
name|p2xr
operator|+
literal|0x0B
argument_list|,
operator|(
name|BYTE
operator|)
name|datum
argument_list|)
expr_stmt|;
comment|/* write register */
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
literal|0x5B
argument_list|)
expr_stmt|;
comment|/* select IVERI */
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
name|iveri
argument_list|)
expr_stmt|;
comment|/* restore IVERI */
return|return;
block|}
block|}
comment|/* ############################################################# */
comment|/* Logic to write to registers in P3XR block */
comment|/* ############################################################# */
if|if
condition|(
name|reg_id
operator|>=
literal|0x001A
operator|&&
name|reg_id
operator|<=
literal|0x005C
condition|)
block|{
comment|/* GMCR to LMBDR */
if|if
condition|(
name|reg_id
operator|==
literal|0x005C
condition|)
block|{
comment|/* LMBDR */
name|outb
argument_list|(
name|iw
operator|.
name|lmbdr
argument_list|,
operator|(
name|BYTE
operator|)
name|datum
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reg_id
operator|==
literal|0x001B
condition|)
comment|/* GMSR */
return|return;
if|if
condition|(
name|reg_id
operator|>=
literal|0x001A
operator|&&
name|reg_id
operator|<=
literal|0x0021
condition|)
comment|/* GMCR to I8DP */
if|if
condition|(
name|offset
operator|==
literal|0x04
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|datum
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|iw
operator|.
name|p3xr
operator|+
name|offset
argument_list|,
operator|(
name|BYTE
operator|)
name|datum
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* indexed registers */
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* select register */
if|if
condition|(
name|offset
operator|==
literal|0x04
condition|)
name|outw
argument_list|(
name|iw
operator|.
name|i16dp
argument_list|,
name|datum
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
operator|(
name|BYTE
operator|)
name|datum
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* /################################################### */
comment|/* Logic to write to registers in PCODAR block */
comment|/* ################################################### */
if|if
condition|(
name|reg_id
operator|>=
literal|0x005C
operator|&&
name|reg_id
operator|<=
literal|0x0081
condition|)
block|{
comment|/* CIDXR to CLRCTI */
if|if
condition|(
name|reg_id
operator|<=
literal|0x0061
condition|)
name|outb
argument_list|(
name|iw
operator|.
name|pcodar
operator|+
name|offset
argument_list|,
operator|(
name|BYTE
operator|)
name|datum
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* one of the indexed registers */
name|BYTE
name|cidxr
decl_stmt|;
name|cidxr
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|)
expr_stmt|;
name|cidxr
operator|=
operator|(
name|cidxr
operator|&
literal|0xE0
operator|)
operator|+
name|index
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|,
name|cidxr
argument_list|)
expr_stmt|;
comment|/* select register */
name|outb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|,
operator|(
name|BYTE
operator|)
name|datum
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ###################################################### */
comment|/* Logic to write to the PnP registers */
comment|/* ###################################################### */
if|if
condition|(
name|reg_id
operator|>=
literal|0x0082
operator|&&
name|reg_id
operator|<=
literal|0x00B7
condition|)
block|{
if|if
condition|(
name|reg_id
operator|==
literal|0x0085
condition|)
block|{
name|outb
argument_list|(
name|iw
operator|.
name|pnprdp
argument_list|,
operator|(
name|BYTE
operator|)
name|datum
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|reg_id
operator|<
literal|0x0085
condition|)
name|outb
argument_list|(
operator|(
name|WORD
operator|)
name|reg_mnem
argument_list|,
operator|(
name|BYTE
operator|)
name|datum
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* one of the indexed registers */
if|if
condition|(
name|reg_id
operator|>=
literal|0x008E
operator|&&
name|reg_id
operator|<=
literal|0x00B7
condition|)
block|{
name|outb
argument_list|(
literal|0x0279
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
comment|/* select PLDNI */
name|outb
argument_list|(
literal|0xA79
argument_list|,
operator|(
name|BYTE
operator|)
name|offset
argument_list|)
expr_stmt|;
comment|/* select logical dev */
block|}
name|outb
argument_list|(
literal|0x0279
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* select the register */
name|outb
argument_list|(
literal|0xA79
argument_list|,
operator|(
name|BYTE
operator|)
name|datum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|IwaveLineLevel
parameter_list|(
name|char
name|level
parameter_list|,
name|char
name|index
parameter_list|)
block|{
name|char
name|reg
decl_stmt|;
name|level
operator|&=
literal|0x1F
expr_stmt|;
name|ENTER_CRITICAL
expr_stmt|;
name|reg
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|)
operator|&
literal|0xE0
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|,
name|reg
operator||
name|index
argument_list|)
expr_stmt|;
comment|/* select register */
name|outb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
operator|(
name|inb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|)
operator|&
literal|0x80
operator|)
operator||
name|level
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set level */
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|IwaveCodecMode
parameter_list|(
name|char
name|mode
parameter_list|)
block|{
name|char
name|reg
decl_stmt|;
name|ENTER_CRITICAL
expr_stmt|;
name|reg
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|)
operator|&
literal|0xE0
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|,
name|reg
operator||
name|_CMODEI
argument_list|)
expr_stmt|;
comment|/* select CMODEI */
name|outb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|LEAVE_CRITICAL
expr_stmt|;
name|iw
operator|.
name|cmode
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_function
name|void
name|IwaveLineMute
parameter_list|(
name|BYTE
name|mute
parameter_list|,
name|BYTE
name|inx
parameter_list|)
block|{
name|BYTE
name|reg
decl_stmt|;
name|ENTER_CRITICAL
expr_stmt|;
name|reg
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|)
operator|&
literal|0xE0
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|,
name|reg
operator||
name|inx
argument_list|)
expr_stmt|;
comment|/* select register */
if|if
condition|(
name|mute
operator|==
name|ON
condition|)
name|outb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|inb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|)
operator||
literal|0x80
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mute */
else|else
name|outb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|,
call|(
name|BYTE
call|)
argument_list|(
name|inb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|)
operator|&
literal|0x7F
argument_list|)
argument_list|)
expr_stmt|;
comment|/* unmute */
name|LEAVE_CRITICAL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Iwaveinitcodec
parameter_list|()
block|{
name|u_short
name|iwl_codec_base
init|=
name|iw
operator|.
name|pcodar
decl_stmt|;
name|u_short
name|iwl_codec_data
init|=
name|iw
operator|.
name|pcodar
operator|+
literal|1
decl_stmt|;
name|u_short
name|foo
decl_stmt|;
comment|/* 	 * Set the CEXTI register foo = CODEC_CEXTI_DEFAULT; 	 * IWL_CODEC_OUT(EXTERNAL_CONTROL, foo); 	 */
comment|/* 	 * Disable Interrupts iwl_codec_disable_irqs(); 	 */
comment|/* Set the CODEC to Operate in Mode 3 */
name|IWL_CODEC_OUT
argument_list|(
name|MODE_SELECT_ID
argument_list|,
literal|0x6C
argument_list|)
expr_stmt|;
name|foo
operator|=
name|inb
argument_list|(
name|iwl_codec_data
argument_list|)
expr_stmt|;
comment|/* Set the configuration registers to their default values */
name|foo
operator|=
name|CODEC_CFIG1I_DEFAULT
expr_stmt|;
name|IWL_CODEC_OUT
argument_list|(
name|CONFIG_1
operator||
name|CODEC_MCE
argument_list|,
name|foo
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iwl_codec_base
argument_list|,
name|CONFIG_1
argument_list|)
expr_stmt|;
name|foo
operator|=
name|CODEC_CFIG2I_DEFAULT
expr_stmt|;
name|IWL_CODEC_OUT
argument_list|(
name|CONFIG_2
argument_list|,
name|foo
argument_list|)
expr_stmt|;
name|foo
operator|=
name|CODEC_CFIG3I_DEFAULT
expr_stmt|;
name|IWL_CODEC_OUT
argument_list|(
name|CONFIG_3
argument_list|,
name|foo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|IwaveOpen
parameter_list|(
name|char
name|voices
parameter_list|,
name|char
name|mode
parameter_list|,
name|struct
name|address_info
modifier|*
name|hw
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|u_char
name|tmp
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|iw
operator|.
name|pnprdp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IwavePnpIsol
argument_list|(
operator|&
name|iw
operator|.
name|pnprdp
argument_list|)
condition|)
block|{
name|iw
operator|.
name|vendor
operator|=
name|GUS_PNP_ID
expr_stmt|;
name|iw
operator|.
name|csn
operator|=
name|IwavePnpPing
argument_list|(
name|iw
operator|.
name|vendor
argument_list|)
expr_stmt|;
name|IwavePnpKey
argument_list|()
expr_stmt|;
name|IwavePnpWake
argument_list|(
name|iw
operator|.
name|csn
argument_list|)
expr_stmt|;
name|IwavePnpGetCfg
argument_list|()
expr_stmt|;
name|IwavePnpKey
argument_list|()
expr_stmt|;
name|IwavePnpWake
argument_list|(
name|iw
operator|.
name|csn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hw
operator|->
name|irq
operator|>
literal|0
condition|)
block|{
comment|/* I see the user wants to set the GUS PnP */
comment|/* Okay lets do it */
name|iw
operator|.
name|csn
operator|=
literal|1
expr_stmt|;
name|iw
operator|.
name|p2xr
operator|=
name|hw
operator|->
name|io_base
expr_stmt|;
name|iw
operator|.
name|p3xr
operator|=
name|hw
operator|->
name|io_base
operator|+
literal|0x100
expr_stmt|;
name|iw
operator|.
name|pcodar
operator|=
name|hw
operator|->
name|io_base
operator|+
literal|0x10c
expr_stmt|;
name|iw
operator|.
name|synth_irq
operator|=
name|hw
operator|->
name|irq
expr_stmt|;
name|iw
operator|.
name|midi_irq
operator|=
name|hw
operator|->
name|irq
expr_stmt|;
name|iw
operator|.
name|dma1_chan
operator|=
name|hw
operator|->
name|dma
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|dma2
operator|==
operator|-
literal|1
condition|)
block|{
name|iw
operator|.
name|dma2_chan
operator|=
name|hw
operator|->
name|dma
expr_stmt|;
block|}
else|else
block|{
name|iw
operator|.
name|dma2_chan
operator|=
name|hw
operator|->
name|dma2
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* tell the os what we are doing 8) */
name|hw
operator|->
name|io_base
operator|=
name|iw
operator|.
name|p2xr
expr_stmt|;
name|hw
operator|->
name|irq
operator|=
name|iw
operator|.
name|synth_irq
expr_stmt|;
comment|/* 		 * iw.dma1_chan = 1; iw.dma2_chan = 3 ; 		 */
name|hw
operator|->
name|dma
operator|=
name|iw
operator|.
name|dma1_chan
expr_stmt|;
name|hw
operator|->
name|dma2
operator|=
name|iw
operator|.
name|dma2_chan
expr_stmt|;
block|}
if|if
condition|(
name|iw
operator|.
name|csn
operator|>
literal|0
operator|&&
name|iw
operator|.
name|csn
operator|<
name|MAX_GUS_PNP
condition|)
block|{
name|gus_pnp_found
index|[
name|iw
operator|.
name|csn
index|]
operator|=
name|hw
operator|->
name|io_base
expr_stmt|;
block|}
name|iw
operator|.
name|cdatap
operator|=
name|iw
operator|.
name|pcodar
operator|+
literal|1
expr_stmt|;
name|iw
operator|.
name|csr1r
operator|=
name|iw
operator|.
name|pcodar
operator|+
literal|2
expr_stmt|;
name|iw
operator|.
name|cxdr
operator|=
name|iw
operator|.
name|pcodar
operator|+
literal|3
expr_stmt|;
comment|/* CPDR or CRDR */
name|iw
operator|.
name|gmxr
operator|=
name|iw
operator|.
name|p3xr
expr_stmt|;
name|iw
operator|.
name|gmxdr
operator|=
name|iw
operator|.
name|p3xr
operator|+
literal|1
expr_stmt|;
comment|/* GMTDR or GMRDR */
name|iw
operator|.
name|svsr
operator|=
name|iw
operator|.
name|p3xr
operator|+
literal|2
expr_stmt|;
name|iw
operator|.
name|igidxr
operator|=
name|iw
operator|.
name|p3xr
operator|+
literal|3
expr_stmt|;
name|iw
operator|.
name|i16dp
operator|=
name|iw
operator|.
name|p3xr
operator|+
literal|4
expr_stmt|;
name|iw
operator|.
name|i8dp
operator|=
name|iw
operator|.
name|p3xr
operator|+
literal|5
expr_stmt|;
name|iw
operator|.
name|lmbdr
operator|=
name|iw
operator|.
name|p3xr
operator|+
literal|7
expr_stmt|;
name|iw
operator|.
name|voices
operator|=
name|voices
expr_stmt|;
if|if
condition|(
name|iw
operator|.
name|pnprdp
operator|>
literal|0
operator|&&
name|iw
operator|.
name|csn
operator|>
literal|0
condition|)
block|{
name|IwavePnpSetCfg
argument_list|()
expr_stmt|;
name|IwavePnpActivate
argument_list|(
name|AUDIO
argument_list|,
name|ON
argument_list|)
expr_stmt|;
name|IwavePnpActivate
argument_list|(
name|EXT
argument_list|,
name|ON
argument_list|)
expr_stmt|;
block|}
comment|/* IwavePnpActivate(EMULATION,ON); */
comment|/* reset */
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
name|_URSTI
argument_list|)
expr_stmt|;
comment|/* Pull reset */
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|30
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Release reset */
name|DELAY
argument_list|(
literal|1000
operator|*
literal|30
argument_list|)
expr_stmt|;
comment|/* end of reset */
name|IwaveMemCfg
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|IwaveRegPeek
argument_list|(
name|IDECI
argument_list|)
expr_stmt|;
name|IwaveRegPoke
argument_list|(
name|IDECI
argument_list|,
name|tmp
operator||
literal|0x18
argument_list|)
expr_stmt|;
name|IwaveCodecMode
argument_list|(
name|CODEC_MODE2
argument_list|)
expr_stmt|;
comment|/* Default codec mode  */
name|IwaveRegPoke
argument_list|(
name|ICMPTI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
literal|0x99
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|inb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|IwaveCodecIrq
argument_list|(
operator|~
name|CODEC_IRQ_ENABLE
argument_list|)
expr_stmt|;
name|Iwaveinitcodec
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|p2xr
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
comment|/* Disable line in, mic and line out */
name|IwaveRegPoke
argument_list|(
name|CLCI
argument_list|,
literal|0x3f
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|IwaveLineLevel
argument_list|(
literal|0
argument_list|,
name|_CLOAI
argument_list|)
expr_stmt|;
name|IwaveLineLevel
argument_list|(
literal|0
argument_list|,
name|_CROAI
argument_list|)
expr_stmt|;
name|IwaveLineMute
argument_list|(
name|OFF
argument_list|,
name|_CLOAI
argument_list|)
expr_stmt|;
name|IwaveLineMute
argument_list|(
name|OFF
argument_list|,
name|_CROAI
argument_list|)
expr_stmt|;
name|IwaveLineLevel
argument_list|(
literal|0
argument_list|,
name|_CLLICI
argument_list|)
expr_stmt|;
name|IwaveLineLevel
argument_list|(
literal|0
argument_list|,
name|_CRLICI
argument_list|)
expr_stmt|;
name|IwaveLineMute
argument_list|(
name|OFF
argument_list|,
name|_CLLICI
argument_list|)
expr_stmt|;
name|IwaveLineMute
argument_list|(
name|OFF
argument_list|,
name|_CRLICI
argument_list|)
expr_stmt|;
name|IwaveLineLevel
argument_list|(
literal|0
argument_list|,
name|_CLDACI
argument_list|)
expr_stmt|;
name|IwaveLineLevel
argument_list|(
literal|0
argument_list|,
name|_CRDACI
argument_list|)
expr_stmt|;
name|IwaveLineMute
argument_list|(
name|ON
argument_list|,
name|_CLDACI
argument_list|)
expr_stmt|;
name|IwaveLineMute
argument_list|(
name|ON
argument_list|,
name|_CRDACI
argument_list|)
expr_stmt|;
name|IwaveLineLevel
argument_list|(
literal|0
argument_list|,
name|_CLLICI
argument_list|)
expr_stmt|;
name|IwaveLineLevel
argument_list|(
literal|0
argument_list|,
name|_CRLICI
argument_list|)
expr_stmt|;
name|IwaveLineMute
argument_list|(
name|ON
argument_list|,
name|_CLLICI
argument_list|)
expr_stmt|;
name|IwaveLineMute
argument_list|(
name|ON
argument_list|,
name|_CRLICI
argument_list|)
expr_stmt|;
name|IwaveInputSource
argument_list|(
name|LEFT_SOURCE
argument_list|,
name|MIC_IN
argument_list|)
expr_stmt|;
name|IwaveInputSource
argument_list|(
name|RIGHT_SOURCE
argument_list|,
name|MIC_IN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|,
literal|0x9
operator||
literal|0x40
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IwaveCodecIrq
argument_list|(
name|CODEC_IRQ_ENABLE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|pcodar
argument_list|,
name|_CFIG3I
operator||
literal|0x20
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|cdatap
argument_list|,
literal|0xC2
argument_list|)
expr_stmt|;
comment|/* Enable Mode 3 IRQs& Synth  */
name|outb
argument_list|(
name|iw
operator|.
name|igidxr
argument_list|,
name|_URSTI
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iw
operator|.
name|i8dp
argument_list|,
name|GF1_SET
operator||
name|GF1_OUT_ENABLE
operator||
name|GF1_IRQ_ENABLE
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|30
argument_list|)
expr_stmt|;
name|iw
operator|.
name|size_mem
operator|=
name|IwaveMemSize
argument_list|()
expr_stmt|;
comment|/* Bytes of RAM in this mode */
name|outb
argument_list|(
name|iw
operator|.
name|p2xr
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
comment|/* enable output */
name|IwaveRegPoke
argument_list|(
name|CLCI
argument_list|,
literal|0x3f
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|IwaveCodecIrq
argument_list|(
name|CODEC_IRQ_ENABLE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
operator|*
literal|100
argument_list|)
expr_stmt|;
name|IwaveRegPoke
argument_list|(
name|CPDFI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gus_wave_init
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|u_char
name|val
decl_stmt|,
name|gus_pnp_seen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|model_num
init|=
literal|"2.4"
decl_stmt|;
name|int
name|gus_type
init|=
literal|0x24
decl_stmt|;
comment|/* 2.4 */
name|int
name|irq
init|=
name|hw_config
operator|->
name|irq
decl_stmt|,
name|dma
init|=
name|hw_config
operator|->
name|dma
decl_stmt|,
name|dma2
init|=
name|hw_config
operator|->
name|dma2
decl_stmt|;
name|int
name|otherside
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|irq
operator|<
literal|0
operator|||
name|irq
operator|>
literal|15
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR! Invalid IRQ#%d. GUS Disabled"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dma
operator|<
literal|0
operator|||
name|dma
operator|>
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR! Invalid DMA#%d. GUS Disabled"
argument_list|,
name|dma
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_GUS_PNP
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gus_pnp_found
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|gus_pnp_found
index|[
name|i
index|]
operator|==
name|hw_config
operator|->
name|io_base
condition|)
name|gus_pnp_seen
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NOGUSPNP
name|gus_pnp_seen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|gus_irq
operator|=
name|irq
expr_stmt|;
name|gus_dma
operator|=
name|dma
expr_stmt|;
name|gus_dma2
operator|=
name|dma2
expr_stmt|;
if|if
condition|(
name|gus_dma2
operator|==
operator|-
literal|1
condition|)
name|gus_dma2
operator|=
name|dma
expr_stmt|;
comment|/*      * Try to identify the GUS model.      *       * Versions< 3.6 don't have the digital ASIC. Try to probe it first.      */
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|gus_base
operator|+
literal|0x0f
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|gus_base
operator|+
literal|0x0f
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0xff
operator|&&
operator|(
name|val
operator|&
literal|0x06
operator|)
condition|)
block|{
comment|/* Should be 0x02?? */
comment|/* 	 * It has the digital ASIC so the card is at least v3.4. Next 	 * try to detect the true model. 	 */
name|val
operator|=
name|inb
argument_list|(
name|u_MixSelect
argument_list|)
expr_stmt|;
comment|/* 	 * Value 255 means pre-3.7 which don't have mixer. Values 5 	 * thru 9 mean v3.7 which has a ICS2101 mixer. 10 and above 	 * is GUS MAX which has the CS4231 codec/mixer. 	 *  	 */
if|if
condition|(
name|gus_pnp_seen
condition|)
name|val
operator|=
literal|66
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|255
operator|||
name|val
operator|<
literal|5
condition|)
block|{
name|model_num
operator|=
literal|"3.4"
expr_stmt|;
name|gus_type
operator|=
literal|0x34
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|<
literal|10
condition|)
block|{
name|model_num
operator|=
literal|"3.7"
expr_stmt|;
name|gus_type
operator|=
literal|0x37
expr_stmt|;
name|mixer_type
operator|=
name|ICS2101
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gus_pnp_seen
condition|)
name|model_num
operator|=
literal|"PNP"
expr_stmt|;
else|else
name|model_num
operator|=
literal|"MAX"
expr_stmt|;
name|gus_type
operator|=
literal|0x40
expr_stmt|;
name|mixer_type
operator|=
name|CS4231
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_GUSMAX
block|{
name|u_char
name|max_config
init|=
literal|0x40
decl_stmt|;
comment|/* Codec enable */
if|if
condition|(
name|gus_dma2
operator|==
operator|-
literal|1
condition|)
name|gus_dma2
operator|=
name|gus_dma
expr_stmt|;
if|if
condition|(
name|gus_dma
operator|>
literal|3
condition|)
name|max_config
operator||=
literal|0x10
expr_stmt|;
comment|/* 16 bit capture DMA */
if|if
condition|(
name|gus_dma2
operator|>
literal|3
condition|)
name|max_config
operator||=
literal|0x20
expr_stmt|;
comment|/* 16 bit playback DMA */
name|max_config
operator||=
operator|(
name|gus_base
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
expr_stmt|;
comment|/* Extract the X from 							 * 2X0 */
name|outb
argument_list|(
name|gus_base
operator|+
literal|0x106
argument_list|,
name|max_config
argument_list|)
expr_stmt|;
comment|/* UltraMax control */
block|}
if|if
condition|(
name|ad1848_detect
argument_list|(
name|gus_base
operator|+
literal|0x10c
argument_list|,
name|NULL
argument_list|,
name|hw_config
operator|->
name|osp
argument_list|)
condition|)
block|{
name|gus_mic_vol
operator|=
name|gus_line_vol
operator|=
name|gus_pcm_volume
operator|=
literal|100
expr_stmt|;
name|gus_wave_volume
operator|=
literal|90
expr_stmt|;
name|have_gus_max
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|gus_pnp_seen
condition|)
block|{
name|ad1848_init
argument_list|(
literal|"GUS PNP"
argument_list|,
name|gus_base
operator|+
literal|0x10c
argument_list|,
operator|-
name|irq
argument_list|,
name|gus_dma2
argument_list|,
comment|/* Playback DMA */
name|gus_dma
argument_list|,
comment|/* Capture DMA */
literal|1
argument_list|,
comment|/* Share DMA channels with GF1 */
name|hw_config
operator|->
name|osp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ad1848_init
argument_list|(
literal|"GUS MAX"
argument_list|,
name|gus_base
operator|+
literal|0x10c
argument_list|,
operator|-
name|irq
argument_list|,
name|gus_dma2
argument_list|,
comment|/* Playback DMA */
name|gus_dma
argument_list|,
comment|/* Capture DMA */
literal|1
argument_list|,
comment|/* Share DMA channels with GF1 */
name|hw_config
operator|->
name|osp
argument_list|)
expr_stmt|;
block|}
name|otherside
operator|=
name|num_audiodevs
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"[Where's the CS4231?]"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"\n\n\nGUS MAX support was not compiled in!!!\n\n\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* 	 * ASIC not detected so the card must be 2.2 or 2.4. There 	 * could still be the 16-bit/mixer daughter card. 	 */
block|}
if|if
condition|(
name|gus_pnp_seen
condition|)
block|{
name|sprintf
argument_list|(
name|gus_info
operator|.
name|name
argument_list|,
literal|"Gravis %s (%dk)"
argument_list|,
name|model_num
argument_list|,
operator|(
name|int
operator|)
name|gus_mem_size
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|gus_info
operator|.
name|name
argument_list|,
literal|"Gravis UltraSound %s (%dk)"
argument_list|,
name|model_num
argument_list|,
operator|(
name|int
operator|)
name|gus_mem_size
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
name|conf_printf
argument_list|(
name|gus_info
operator|.
name|name
argument_list|,
name|hw_config
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_synths
operator|>=
name|MAX_SYNTH_DEV
condition|)
name|printf
argument_list|(
literal|"GUS Error: Too many synthesizers\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|voice_alloc
operator|=
operator|&
name|guswave_operations
operator|.
name|alloc
expr_stmt|;
name|synth_devs
index|[
name|num_synths
operator|++
index|]
operator|=
operator|&
name|guswave_operations
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_SEQUENCER
name|gus_tmr_install
argument_list|(
name|gus_base
operator|+
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|samples
operator|=
operator|(
expr|struct
name|patch_info
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|MAX_SAMPLE
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|samples
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|samples
condition|)
name|panic
argument_list|(
literal|"SOUND: Cannot allocate memory\n"
argument_list|)
expr_stmt|;
name|reset_sample_memory
argument_list|()
expr_stmt|;
name|gus_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_audiodevs
operator|<
name|MAX_AUDIO_DEV
condition|)
block|{
name|audio_devs
index|[
name|gus_devnum
operator|=
name|num_audiodevs
operator|++
index|]
operator|=
operator|&
name|gus_sampling_operations
expr_stmt|;
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|otherside
operator|=
name|otherside
expr_stmt|;
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmachan1
operator|=
name|dma
expr_stmt|;
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmachan2
operator|=
name|dma2
expr_stmt|;
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|buffsize
operator|=
name|DSP_BUFFSIZE
expr_stmt|;
if|if
condition|(
name|otherside
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 	     * glue logic to prevent people from opening the gus 	     * max via the gf1 and the cs4231 side . Only the gf1 	     * or the cs4231 are allowed to be open 	     */
name|audio_devs
index|[
name|otherside
index|]
operator|->
name|otherside
operator|=
name|gus_devnum
expr_stmt|;
block|}
if|if
condition|(
name|dma2
operator|!=
name|dma
operator|&&
name|dma2
operator|!=
operator|-
literal|1
condition|)
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|flags
operator||=
name|DMA_DUPLEX
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"GUS: Too many PCM devices available\n"
argument_list|)
expr_stmt|;
comment|/*      * Mixer dependent initialization.      */
switch|switch
condition|(
name|mixer_type
condition|)
block|{
case|case
name|ICS2101
case|:
name|gus_mic_vol
operator|=
name|gus_line_vol
operator|=
name|gus_pcm_volume
operator|=
literal|100
expr_stmt|;
name|gus_wave_volume
operator|=
literal|90
expr_stmt|;
name|ics2101_mixer_init
argument_list|()
expr_stmt|;
return|return;
case|case
name|CS4231
case|:
comment|/* Initialized elsewhere (ad1848.c) */
default|default:
name|gus_default_mixer_init
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_loop_irq
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|u_char
name|tmp
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|parm
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Disable wave IRQ for this_one voice */
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
literal|0x03
condition|)
comment|/* Voice stopped */
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
operator|=
literal|0
expr_stmt|;
name|parm
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_parm
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|LMODE_FINISH
case|:
comment|/* Final loop finished, shoot volume down */
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
argument_list|)
operator|<
literal|100
condition|)
block|{
comment|/* Get current volume */
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_init
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
block|}
name|gus_ramp_range
argument_list|(
literal|65
argument_list|,
literal|4065
argument_list|)
expr_stmt|;
name|gus_ramp_rate
argument_list|(
literal|0
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/* Fastest possible rate */
name|gus_rampon
argument_list|(
literal|0x20
operator||
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Ramp down, once, irq */
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
name|VMODE_HALT
expr_stmt|;
break|break;
case|case
name|LMODE_PCM_STOP
case|:
name|pcm_active
operator|=
literal|0
expr_stmt|;
comment|/* Signal to the play_next_pcm_block routine */
case|case
name|LMODE_PCM
case|:
block|{
name|int
name|flag
decl_stmt|;
comment|/* 0 or 2 */
name|pcm_qlen
operator|--
expr_stmt|;
name|pcm_head
operator|=
operator|(
name|pcm_head
operator|+
literal|1
operator|)
operator|%
name|pcm_nblk
expr_stmt|;
if|if
condition|(
name|pcm_qlen
operator|&&
name|pcm_active
condition|)
block|{
name|play_next_pcm_block
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Underrun. Just stop the voice */
name|gus_select_voice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Left channel */
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Right channel */
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|pcm_active
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * If the queue was full before this interrupt, the 			 * DMA transfer was suspended. Let it continue now. 			 */
if|if
condition|(
name|dma_active
condition|)
block|{
if|if
condition|(
name|pcm_qlen
operator|==
literal|0
condition|)
name|flag
operator|=
literal|1
expr_stmt|;
comment|/* Underflow */
else|else
name|flag
operator|=
literal|0
expr_stmt|;
name|dma_active
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|flag
operator|=
literal|2
expr_stmt|;
comment|/* Just notify the dmabuf.c */
name|DMAbuf_outputintr
argument_list|(
name|gus_devnum
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_volume_irq
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|u_char
name|tmp
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|parm
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gus_read8
argument_list|(
literal|0x0d
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Disable volume ramp IRQ */
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|mode
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
literal|0
expr_stmt|;
name|parm
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_parm
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|VMODE_HALT
case|:
comment|/* Decay phase finished */
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_voice_init
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMODE_ENVELOPE
case|:
name|gus_rampoff
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|step_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMODE_START_NOTE
case|:
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|guswave_start_note2
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|dev_pending
argument_list|,
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|note_pending
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|volume_pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|kill_pending
condition|)
name|guswave_kill_note
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|dev_pending
argument_list|,
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|note_pending
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
operator|>=
literal|0
condition|)
block|{
name|guswave_set_instr
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|dev_pending
argument_list|,
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|gus_voice_irq
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|wave_ignore
init|=
literal|0
decl_stmt|,
name|volume_ignore
init|=
literal|0
decl_stmt|;
name|u_long
name|voice_bit
decl_stmt|;
name|u_char
name|src
decl_stmt|,
name|voice
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|src
operator|=
name|gus_read8
argument_list|(
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* Get source info */
name|voice
operator|=
name|src
operator|&
literal|0x1f
expr_stmt|;
name|src
operator|&=
literal|0xc0
expr_stmt|;
if|if
condition|(
name|src
operator|==
operator|(
literal|0x80
operator||
literal|0x40
operator|)
condition|)
return|return;
comment|/* No interrupt */
name|voice_bit
operator|=
literal|1
operator|<<
name|voice
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|src
operator|&
literal|0x80
operator|)
condition|)
comment|/* Wave IRQ pending */
if|if
condition|(
operator|!
operator|(
name|wave_ignore
operator|&
name|voice_bit
operator|)
operator|&&
operator|(
name|int
operator|)
name|voice
operator|<
name|nr_voices
condition|)
block|{
comment|/* Not done yet */
name|wave_ignore
operator||=
name|voice_bit
expr_stmt|;
name|do_loop_irq
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|src
operator|&
literal|0x40
operator|)
condition|)
comment|/* Volume IRQ pending */
if|if
condition|(
operator|!
operator|(
name|volume_ignore
operator|&
name|voice_bit
operator|)
operator|&&
operator|(
name|int
operator|)
name|voice
operator|<
name|nr_voices
condition|)
block|{
comment|/* Not done yet */
name|volume_ignore
operator||=
name|voice_bit
expr_stmt|;
name|do_volume_irq
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|guswave_dma_irq
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|status
decl_stmt|;
name|status
operator|=
name|gus_look8
argument_list|(
literal|0x41
argument_list|)
expr_stmt|;
comment|/* Get DMA IRQ Status */
if|if
condition|(
name|status
operator|&
literal|0x40
condition|)
comment|/* DMA interrupt pending */
switch|switch
condition|(
name|active_device
condition|)
block|{
case|case
name|GUS_DEV_WAVE
case|:
if|if
condition|(
operator|(
name|dram_sleep_flag
operator|.
name|mode
operator|&
name|WK_SLEEP
operator|)
condition|)
block|{
name|dram_sleep_flag
operator|.
name|mode
operator|=
name|WK_WAKEUP
expr_stmt|;
name|wakeup
argument_list|(
name|dram_sleeper
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
name|GUS_DEV_PCM_CONTINUE
case|:
comment|/* Left channel data transferred */
name|gus_transfer_output_block
argument_list|(
name|pcm_current_dev
argument_list|,
name|pcm_current_buf
argument_list|,
name|pcm_current_count
argument_list|,
name|pcm_current_intrflag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GUS_DEV_PCM_DONE
case|:
comment|/* Right or mono channel data transferred */
if|if
condition|(
name|pcm_qlen
operator|<
name|pcm_nblk
condition|)
block|{
name|int
name|flag
init|=
operator|(
literal|1
operator|-
name|dma_active
operator|)
operator|*
literal|2
decl_stmt|;
comment|/* 0 or 2 */
if|if
condition|(
name|pcm_qlen
operator|==
literal|0
condition|)
name|flag
operator|=
literal|1
expr_stmt|;
comment|/* Underrun */
name|dma_active
operator|=
literal|0
expr_stmt|;
name|DMAbuf_outputintr
argument_list|(
name|gus_devnum
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
name|status
operator|=
name|gus_look8
argument_list|(
literal|0x49
argument_list|)
expr_stmt|;
comment|/* Get Sampling IRQ Status */
if|if
condition|(
name|status
operator|&
literal|0x40
condition|)
block|{
comment|/* Sampling Irq pending */
name|DMAbuf_inputintr
argument_list|(
name|gus_devnum
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_SEQUENCER
end_ifdef

begin_comment
comment|/*  * Timer stuff  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|select_addr
decl_stmt|,
name|data_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|curr_timer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|gus_timer_command
parameter_list|(
name|u_int
name|addr
parameter_list|,
name|u_int
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|outb
argument_list|(
name|select_addr
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|addr
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|inb
argument_list|(
name|select_addr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|data_addr
argument_list|,
call|(
name|u_char
call|)
argument_list|(
name|val
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|inb
argument_list|(
name|select_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_timer
parameter_list|(
name|int
name|timer
parameter_list|,
name|u_int
name|interval
parameter_list|)
block|{
name|curr_timer
operator|=
name|timer
expr_stmt|;
if|if
condition|(
name|timer
operator|==
literal|1
condition|)
block|{
name|gus_write8
argument_list|(
literal|0x46
argument_list|,
literal|256
operator|-
name|interval
argument_list|)
expr_stmt|;
comment|/* Set counter for timer 1 */
name|gus_write8
argument_list|(
literal|0x45
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Enable timer 1 IRQ */
name|gus_timer_command
argument_list|(
literal|0x04
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Start timer 1 */
block|}
else|else
block|{
name|gus_write8
argument_list|(
literal|0x47
argument_list|,
literal|256
operator|-
name|interval
argument_list|)
expr_stmt|;
comment|/* Set counter for timer 2 */
name|gus_write8
argument_list|(
literal|0x45
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Enable timer 2 IRQ */
name|gus_timer_command
argument_list|(
literal|0x04
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Start timer 2 */
block|}
name|gus_timer_enabled
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|gus_tmr_start
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int
name|usecs_per_tick
parameter_list|)
block|{
name|int
name|timer_no
decl_stmt|,
name|resolution
decl_stmt|;
name|int
name|divisor
decl_stmt|;
if|if
condition|(
name|usecs_per_tick
operator|>
operator|(
literal|256
operator|*
literal|80
operator|)
condition|)
block|{
name|timer_no
operator|=
literal|2
expr_stmt|;
name|resolution
operator|=
literal|320
expr_stmt|;
comment|/* usec */
block|}
else|else
block|{
name|timer_no
operator|=
literal|1
expr_stmt|;
name|resolution
operator|=
literal|80
expr_stmt|;
comment|/* usec */
block|}
name|divisor
operator|=
operator|(
name|usecs_per_tick
operator|+
operator|(
name|resolution
operator|/
literal|2
operator|)
operator|)
operator|/
name|resolution
expr_stmt|;
name|arm_timer
argument_list|(
name|timer_no
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
return|return
name|divisor
operator|*
name|resolution
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_tmr_disable
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x45
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable both timers */
name|gus_timer_enabled
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_tmr_restart
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
if|if
condition|(
name|curr_timer
operator|==
literal|1
condition|)
name|gus_write8
argument_list|(
literal|0x45
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Start timer 1 again */
else|else
name|gus_write8
argument_list|(
literal|0x45
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Start timer 2 again */
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|sound_lowlev_timer
name|gus_tmr
init|=
block|{
literal|0
block|,
name|gus_tmr_start
block|,
name|gus_tmr_disable
block|,
name|gus_tmr_restart
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|gus_tmr_install
parameter_list|(
name|int
name|io_base
parameter_list|)
block|{
name|select_addr
operator|=
name|io_base
expr_stmt|;
name|data_addr
operator|=
name|io_base
operator|+
literal|1
expr_stmt|;
name|sound_timer_init
argument_list|(
operator|&
name|gus_tmr
argument_list|,
literal|"GUS"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

