begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/gus_wave.c  *  * Driver for the Gravis UltraSound wave table synth.  *  * Copyright by Hannu Savolainen 1993, 1994  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|"sound_config.h"
end_include

begin_include
include|#
directive|include
file|<machine/ultrasound.h>
end_include

begin_include
include|#
directive|include
file|"gus_hw.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIGURE_SOUNDCARD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EXCLUDE_GUS
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAX_SAMPLE
value|150
end_define

begin_define
define|#
directive|define
name|MAX_PATCH
value|256
end_define

begin_struct
struct|struct
name|voice_info
block|{
name|unsigned
name|long
name|orig_freq
decl_stmt|;
name|unsigned
name|long
name|current_freq
decl_stmt|;
name|unsigned
name|long
name|mode
decl_stmt|;
name|int
name|bender
decl_stmt|;
name|int
name|bender_range
decl_stmt|;
name|int
name|panning
decl_stmt|;
name|int
name|midi_volume
decl_stmt|;
name|unsigned
name|int
name|initial_volume
decl_stmt|;
name|unsigned
name|int
name|current_volume
decl_stmt|;
name|int
name|loop_irq_mode
decl_stmt|,
name|loop_irq_parm
decl_stmt|;
define|#
directive|define
name|LMODE_FINISH
value|1
define|#
directive|define
name|LMODE_PCM
value|2
define|#
directive|define
name|LMODE_PCM_STOP
value|3
name|int
name|volume_irq_mode
decl_stmt|,
name|volume_irq_parm
decl_stmt|;
define|#
directive|define
name|VMODE_HALT
value|1
define|#
directive|define
name|VMODE_ENVELOPE
value|2
define|#
directive|define
name|VMODE_START_NOTE
value|3
name|int
name|env_phase
decl_stmt|;
name|unsigned
name|char
name|env_rate
index|[
literal|6
index|]
decl_stmt|;
name|unsigned
name|char
name|env_offset
index|[
literal|6
index|]
decl_stmt|;
comment|/*      * Volume computation parameters for gus_adagio_vol()      */
name|int
name|main_vol
decl_stmt|,
name|expression_vol
decl_stmt|,
name|patch_vol
decl_stmt|;
comment|/* Variables for "Ultraclick" removal */
name|int
name|dev_pending
decl_stmt|,
name|note_pending
decl_stmt|,
name|volume_pending
decl_stmt|,
name|sample_pending
decl_stmt|;
name|char
name|kill_pending
decl_stmt|;
name|long
name|offset_pending
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|voice_alloc_info
modifier|*
name|voice_alloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gus_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gus_irq
decl_stmt|,
name|gus_dma
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|gus_mem_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|free_mem_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gus_busy
index|[
name|MAX_AUDIO_DEV
index|]
decl_stmt|,
name|gus_dspnum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_dma_read
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nr_voices
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gus_devnum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|volume_base
decl_stmt|,
name|volume_scale
decl_stmt|,
name|volume_method
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_recmask
init|=
name|SOUND_MASK_MIC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|recording_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|only_read_access
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gus_wave_volume
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|gus_pcm_volume
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|have_gus_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_line_vol
init|=
literal|100
decl_stmt|,
name|gus_mic_vol
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|mix_image
init|=
literal|0x00
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Current version of this driver doesn't allow synth and PCM functions  * at the same time. The active_device specifies the active driver  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|active_device
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GUS_DEV_WAVE
value|1
end_define

begin_comment
comment|/* Wave table synth */
end_comment

begin_define
define|#
directive|define
name|GUS_DEV_PCM_DONE
value|2
end_define

begin_comment
comment|/* PCM device, transfer done */
end_comment

begin_define
define|#
directive|define
name|GUS_DEV_PCM_CONTINUE
value|3
end_define

begin_comment
comment|/* PCM device, transfer done ch. 1/2 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gus_sampling_speed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_sampling_channels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_sampling_bits
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_WAIT_QUEUE
argument_list|(
name|dram_sleeper
argument_list|,
name|dram_sleep_flag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Variables and buffers for PCM output  */
end_comment

begin_define
define|#
directive|define
name|MAX_PCM_BUFFERS
value|(32*MAX_REALTIME_FACTOR)
end_define

begin_comment
comment|/* Don't change */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pcm_bsize
decl_stmt|,
name|pcm_nblk
decl_stmt|,
name|pcm_banksize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_datasize
index|[
name|MAX_PCM_BUFFERS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|pcm_head
decl_stmt|,
name|pcm_tail
decl_stmt|,
name|pcm_qlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|pcm_active
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|dma_active
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_opened
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_current_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_current_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|pcm_current_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_current_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_current_intrflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|voice_info
name|voices
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|freq_div_table
index|[]
init|=
block|{
literal|44100
block|,
comment|/* 14 */
literal|41160
block|,
comment|/* 15 */
literal|38587
block|,
comment|/* 16 */
literal|36317
block|,
comment|/* 17 */
literal|34300
block|,
comment|/* 18 */
literal|32494
block|,
comment|/* 19 */
literal|30870
block|,
comment|/* 20 */
literal|29400
block|,
comment|/* 21 */
literal|28063
block|,
comment|/* 22 */
literal|26843
block|,
comment|/* 23 */
literal|25725
block|,
comment|/* 24 */
literal|24696
block|,
comment|/* 25 */
literal|23746
block|,
comment|/* 26 */
literal|22866
block|,
comment|/* 27 */
literal|22050
block|,
comment|/* 28 */
literal|21289
block|,
comment|/* 29 */
literal|20580
block|,
comment|/* 30 */
literal|19916
block|,
comment|/* 31 */
literal|19293
comment|/* 32 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|patch_info
modifier|*
name|samples
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|sample_ptrs
index|[
name|MAX_SAMPLE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sample_map
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|free_sample
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|patch_table
index|[
name|MAX_PATCH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|patch_map
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|synth_info
name|gus_info
init|=
block|{
literal|"Gravis UltraSound"
block|,
literal|0
block|,
name|SYNTH_TYPE_SAMPLE
block|,
name|SAMPLE_TYPE_GUS
block|,
literal|0
block|,
literal|16
block|,
literal|0
block|,
name|MAX_PATCH
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|gus_poke
parameter_list|(
name|long
name|addr
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_and_set_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|,
name|int
name|ramp_time
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|unsigned
name|short
name|gus_adagio_vol
parameter_list|(
name|int
name|vel
parameter_list|,
name|int
name|mainv
parameter_list|,
name|int
name|xpn
parameter_list|,
name|int
name|voicev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|unsigned
name|short
name|gus_linear_vol
parameter_list|(
name|int
name|vol
parameter_list|,
name|int
name|mainvol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_volume_irq
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_input_volumes
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|INSTANT_RAMP
value|-1
end_define

begin_comment
comment|/* Instant change. No ramping */
end_comment

begin_define
define|#
directive|define
name|FAST_RAMP
value|0
end_define

begin_comment
comment|/* Fastest possible ramp */
end_comment

begin_function
specifier|static
name|void
name|reset_sample_memory
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_SAMPLE
condition|;
name|i
operator|++
control|)
name|sample_ptrs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|sample_map
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|patch_map
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|gus_poke
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put a silent sample to the beginning */
name|gus_poke
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_mem_ptr
operator|=
literal|2
expr_stmt|;
name|free_sample
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PATCH
condition|;
name|i
operator|++
control|)
name|patch_table
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gus_delay
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|INB
argument_list|(
name|u_DRAMIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_poke
parameter_list|(
name|long
name|addr
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
block|{
comment|/* Writes a byte to the DRAM */
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x43
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|addr
operator|&
literal|0xff
argument_list|,
name|u_DataLo
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|u_DataHi
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x44
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
name|u_DataHi
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|data
argument_list|,
name|u_DRAMIO
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
name|gus_peek
parameter_list|(
name|long
name|addr
parameter_list|)
block|{
comment|/* Reads a byte from the DRAM */
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|tmp
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x43
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|addr
operator|&
literal|0xff
argument_list|,
name|u_DataLo
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|u_DataHi
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x44
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
name|u_DataHi
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|INB
argument_list|(
name|u_DRAMIO
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
name|void
name|gus_write8
parameter_list|(
name|int
name|reg
parameter_list|,
name|unsigned
name|int
name|data
parameter_list|)
block|{
comment|/* Writes to an indirect register (8 bit) */
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|reg
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|data
operator|&
literal|0xff
argument_list|)
argument_list|,
name|u_DataHi
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|char
name|gus_read8
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
comment|/* Reads from an indirect register (8 bit). Offset 0x80. */
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|reg
operator||
literal|0x80
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|val
operator|=
name|INB
argument_list|(
name|u_DataHi
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|unsigned
name|char
name|gus_look8
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
comment|/* Reads from an indirect register (8 bit). No additional offset. */
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|reg
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|val
operator|=
name|INB
argument_list|(
name|u_DataHi
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|gus_write16
parameter_list|(
name|int
name|reg
parameter_list|,
name|unsigned
name|int
name|data
parameter_list|)
block|{
comment|/* Writes to an indirect register (16 bit) */
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|reg
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
name|data
operator|&
literal|0xff
argument_list|)
argument_list|,
name|u_DataLo
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|,
name|u_DataHi
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|short
name|gus_read16
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
comment|/* Reads from an indirect register (16 bit). Offset 0x80. */
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|reg
operator||
literal|0x80
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|lo
operator|=
name|INB
argument_list|(
name|u_DataLo
argument_list|)
expr_stmt|;
name|hi
operator|=
name|INB
argument_list|(
name|u_DataHi
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|hi
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
operator||
name|lo
return|;
block|}
end_function

begin_function
name|void
name|gus_write_addr
parameter_list|(
name|int
name|reg
parameter_list|,
name|unsigned
name|long
name|address
parameter_list|,
name|int
name|is16bit
parameter_list|)
block|{
comment|/* Writes an 24 bit memory address */
name|unsigned
name|long
name|hold_address
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|is16bit
condition|)
block|{
comment|/*        * Special processing required for 16 bit patches        */
name|hold_address
operator|=
name|address
expr_stmt|;
name|address
operator|=
name|address
operator|>>
literal|1
expr_stmt|;
name|address
operator|&=
literal|0x0001ffffL
expr_stmt|;
name|address
operator||=
operator|(
name|hold_address
operator|&
literal|0x000c0000L
operator|)
expr_stmt|;
block|}
name|gus_write16
argument_list|(
name|reg
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
name|address
operator|>>
literal|7
operator|)
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
name|gus_write16
argument_list|(
name|reg
operator|+
literal|1
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
name|address
operator|<<
literal|9
operator|)
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Could writing twice fix problems with GUS_VOICE_POS() ? Lets try... */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write16
argument_list|(
name|reg
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
name|address
operator|>>
literal|7
operator|)
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
name|gus_write16
argument_list|(
name|reg
operator|+
literal|1
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
name|address
operator|<<
literal|9
operator|)
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_select_voice
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>
literal|31
condition|)
return|return;
name|OUTB
argument_list|(
name|voice
argument_list|,
name|u_Voice
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_select_max_voices
parameter_list|(
name|int
name|nvoices
parameter_list|)
block|{
if|if
condition|(
name|nvoices
operator|<
literal|14
condition|)
name|nvoices
operator|=
literal|14
expr_stmt|;
if|if
condition|(
name|nvoices
operator|>
literal|32
condition|)
name|nvoices
operator|=
literal|32
expr_stmt|;
name|voice_alloc
operator|->
name|max_voice
operator|=
name|nr_voices
operator|=
name|nvoices
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x0e
argument_list|,
operator|(
name|nvoices
operator|-
literal|1
operator|)
operator||
literal|0xc0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_on
parameter_list|(
name|unsigned
name|int
name|mode
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|mode
operator|&
literal|0xfc
argument_list|)
argument_list|)
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|mode
operator|&
literal|0xfc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_off
parameter_list|(
name|void
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
operator||
literal|0x03
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_mode
parameter_list|(
name|unsigned
name|int
name|m
parameter_list|)
block|{
name|unsigned
name|char
name|mode
init|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|m
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
operator|(
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
operator|&
literal|0x03
operator|)
operator||
operator|(
name|mode
operator|&
literal|0xfc
operator|)
argument_list|)
expr_stmt|;
comment|/* Don't touch last two bits */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
operator|(
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
operator|&
literal|0x03
operator|)
operator||
operator|(
name|mode
operator|&
literal|0xfc
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_freq
parameter_list|(
name|unsigned
name|long
name|freq
parameter_list|)
block|{
name|unsigned
name|long
name|divisor
init|=
name|freq_div_table
index|[
name|nr_voices
operator|-
literal|14
index|]
decl_stmt|;
name|unsigned
name|short
name|fc
decl_stmt|;
name|fc
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
operator|(
name|freq
operator|<<
literal|9
operator|)
operator|+
operator|(
name|divisor
operator|>>
literal|1
operator|)
operator|)
operator|/
name|divisor
argument_list|)
expr_stmt|;
name|fc
operator|=
name|fc
operator|<<
literal|1
expr_stmt|;
name|gus_write16
argument_list|(
literal|0x01
argument_list|,
name|fc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_volume
parameter_list|(
name|unsigned
name|int
name|vol
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Stop ramp before setting volume */
name|gus_write16
argument_list|(
literal|0x09
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
name|vol
operator|<<
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_balance
parameter_list|(
name|unsigned
name|int
name|balance
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x0c
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|balance
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_ramp_range
parameter_list|(
name|unsigned
name|int
name|low
parameter_list|,
name|unsigned
name|int
name|high
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x07
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|low
operator|>>
literal|4
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x08
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|high
operator|>>
literal|4
operator|)
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_ramp_rate
parameter_list|(
name|unsigned
name|int
name|scale
parameter_list|,
name|unsigned
name|int
name|rate
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x06
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
operator|(
name|scale
operator|&
literal|0x03
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|rate
operator|&
literal|0x3f
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_rampon
parameter_list|(
name|unsigned
name|int
name|m
parameter_list|)
block|{
name|unsigned
name|char
name|mode
init|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|m
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
name|mode
operator|&
literal|0xfc
argument_list|)
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
name|mode
operator|&
literal|0xfc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_ramp_mode
parameter_list|(
name|unsigned
name|int
name|m
parameter_list|)
block|{
name|unsigned
name|char
name|mode
init|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|m
operator|&
literal|0xff
argument_list|)
decl_stmt|;
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
operator|(
name|gus_read8
argument_list|(
literal|0x0d
argument_list|)
operator|&
literal|0x03
operator|)
operator||
operator|(
name|mode
operator|&
literal|0xfc
operator|)
argument_list|)
expr_stmt|;
comment|/* Leave the last 2 bits alone */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
operator|(
name|gus_read8
argument_list|(
literal|0x0d
argument_list|)
operator|&
literal|0x03
operator|)
operator||
operator|(
name|mode
operator|&
literal|0xfc
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_rampoff
parameter_list|(
name|void
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_set_voice_pos
parameter_list|(
name|int
name|voice
parameter_list|,
name|long
name|position
parameter_list|)
block|{
name|int
name|sample_no
decl_stmt|;
if|if
condition|(
operator|(
name|sample_no
operator|=
name|sample_map
index|[
name|voice
index|]
operator|)
operator|!=
operator|-
literal|1
condition|)
if|if
condition|(
name|position
operator|<
name|samples
index|[
name|sample_no
index|]
operator|.
name|len
condition|)
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|==
name|VMODE_START_NOTE
condition|)
name|voices
index|[
name|voice
index|]
operator|.
name|offset_pending
operator|=
name|position
expr_stmt|;
else|else
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
name|sample_ptrs
index|[
name|sample_no
index|]
operator|+
name|position
argument_list|,
name|samples
index|[
name|sample_no
index|]
operator|.
name|mode
operator|&
name|WAVE_16_BITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_init
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_volume
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set current position to 0 */
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Voice off */
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Ramping off */
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
name|voice_alloc
operator|->
name|alloc_times
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_init2
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
operator|=
literal|20000
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
literal|20000
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
literal|200
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_parm
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_parm
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
operator|=
literal|127
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|patch_vol
operator|=
literal|127
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
operator|=
literal|127
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|step_envelope
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|unsigned
name|vol
decl_stmt|,
name|prev_vol
decl_stmt|,
name|phase
decl_stmt|;
name|unsigned
name|char
name|rate
decl_stmt|;
name|long
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_SUSTAIN_ON
operator|&&
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|==
literal|2
condition|)
block|{
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return;
comment|/*        * Sustain phase begins. Continue envelope after receiving note off.        */
block|}
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|>=
literal|5
condition|)
block|{
comment|/* Envelope finished. Shoot the voice down */
name|gus_voice_init
argument_list|(
name|voice
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev_vol
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
expr_stmt|;
name|phase
operator|=
operator|++
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
expr_stmt|;
name|compute_volume
argument_list|(
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|)
expr_stmt|;
name|vol
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|*
name|voices
index|[
name|voice
index|]
operator|.
name|env_offset
index|[
name|phase
index|]
operator|/
literal|255
expr_stmt|;
name|rate
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|env_rate
index|[
name|phase
index|]
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_volume
argument_list|(
name|prev_vol
argument_list|)
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x06
argument_list|,
name|rate
argument_list|)
expr_stmt|;
comment|/* Ramping rate */
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
name|VMODE_ENVELOPE
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|vol
operator|-
name|prev_vol
operator|)
operator|/
literal|64
operator|)
operator|==
literal|0
condition|)
comment|/* No significant volume change */
block|{
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|step_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
comment|/* Continue the envelope on the next step */
return|return;
block|}
if|if
condition|(
name|vol
operator|>
name|prev_vol
condition|)
block|{
if|if
condition|(
name|vol
operator|>=
operator|(
literal|4096
operator|-
literal|64
operator|)
condition|)
name|vol
operator|=
literal|4096
operator|-
literal|65
expr_stmt|;
name|gus_ramp_range
argument_list|(
literal|0
argument_list|,
name|vol
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x20
argument_list|)
expr_stmt|;
comment|/* Increasing volume, with IRQ */
block|}
else|else
block|{
if|if
condition|(
name|vol
operator|<=
literal|64
condition|)
name|vol
operator|=
literal|65
expr_stmt|;
name|gus_ramp_range
argument_list|(
name|vol
argument_list|,
literal|4030
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x60
argument_list|)
expr_stmt|;
comment|/* Decreasing volume, with IRQ */
block|}
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
name|vol
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_envelope
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|=
operator|-
literal|1
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
literal|64
expr_stmt|;
name|step_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_release
parameter_list|(
name|int
name|voice
parameter_list|,
name|long
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
operator|&
literal|0x03
condition|)
return|return;
comment|/* Voice already stopped */
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|=
literal|2
expr_stmt|;
comment|/* Will be incremented by step_envelope */
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
expr_stmt|;
comment|/* Get current volume */
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&=
operator|~
name|WAVE_SUSTAIN_ON
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|step_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_fade
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|int
name|instr_no
init|=
name|sample_map
index|[
name|voice
index|]
decl_stmt|,
name|is16bits
decl_stmt|;
name|long
name|int
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
if|if
condition|(
name|instr_no
operator|<
literal|0
operator|||
name|instr_no
operator|>
name|MAX_SAMPLE
condition|)
block|{
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Hard stop */
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|is16bits
operator|=
operator|(
name|samples
index|[
name|instr_no
index|]
operator|.
name|mode
operator|&
name|WAVE_16_BITS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 8 or 16 bits */
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|start_release
argument_list|(
name|voice
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * Ramp the volume down but not too quickly.    */
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
argument_list|)
operator|<
literal|100
condition|)
comment|/* Get current volume */
block|{
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_init
argument_list|(
name|voice
argument_list|)
expr_stmt|;
return|return;
block|}
name|gus_ramp_range
argument_list|(
literal|65
argument_list|,
literal|4030
argument_list|)
expr_stmt|;
name|gus_ramp_rate
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x40
operator||
literal|0x20
argument_list|)
expr_stmt|;
comment|/* Down, once, with IRQ */
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
name|VMODE_HALT
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_reset
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gus_select_max_voices
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|volume_base
operator|=
literal|3071
expr_stmt|;
name|volume_scale
operator|=
literal|4
expr_stmt|;
name|volume_method
operator|=
name|VOL_METHOD_ADAGIO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|gus_voice_init
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Turn voice off */
name|gus_voice_init2
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|INB
argument_list|(
name|u_Status
argument_list|)
expr_stmt|;
comment|/* Touch the status register */
name|gus_look8
argument_list|(
literal|0x41
argument_list|)
expr_stmt|;
comment|/* Clear any pending DMA IRQs */
name|gus_look8
argument_list|(
literal|0x49
argument_list|)
expr_stmt|;
comment|/* Clear any pending sample IRQs */
name|gus_read8
argument_list|(
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* Clear pending IRQs */
block|}
end_function

begin_function
specifier|static
name|void
name|gus_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|dma_image
decl_stmt|,
name|irq_image
decl_stmt|,
name|tmp
decl_stmt|;
specifier|static
name|unsigned
name|char
name|gus_irq_map
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|,
literal|7
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|gus_dma_map
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset GF1 */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Release Reset */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
comment|/*    * Clear all interrupts    */
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DMA control */
name|gus_write8
argument_list|(
literal|0x45
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Timer control */
name|gus_write8
argument_list|(
literal|0x49
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Sample control */
name|gus_select_max_voices
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|INB
argument_list|(
name|u_Status
argument_list|)
expr_stmt|;
comment|/* Touch the status register */
name|gus_look8
argument_list|(
literal|0x41
argument_list|)
expr_stmt|;
comment|/* Clear any pending DMA IRQs */
name|gus_look8
argument_list|(
literal|0x49
argument_list|)
expr_stmt|;
comment|/* Clear any pending sample IRQs */
name|gus_read8
argument_list|(
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* Clear pending IRQs */
name|gus_reset
argument_list|()
expr_stmt|;
comment|/* Resets all voices */
name|gus_look8
argument_list|(
literal|0x41
argument_list|)
expr_stmt|;
comment|/* Clear any pending DMA IRQs */
name|gus_look8
argument_list|(
literal|0x49
argument_list|)
expr_stmt|;
comment|/* Clear any pending sample IRQs */
name|gus_read8
argument_list|(
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* Clear pending IRQs */
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* Master reset | DAC enable | IRQ enable */
comment|/*    * Set up for Digital ASIC    */
name|OUTB
argument_list|(
literal|0x05
argument_list|,
name|gus_base
operator|+
literal|0x0f
argument_list|)
expr_stmt|;
name|mix_image
operator||=
literal|0x02
expr_stmt|;
comment|/* Disable line out */
name|OUTB
argument_list|(
name|mix_image
argument_list|,
name|u_Mixer
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x00
argument_list|,
name|u_IRQDMAControl
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x00
argument_list|,
name|gus_base
operator|+
literal|0x0f
argument_list|)
expr_stmt|;
comment|/*    * Now set up the DMA and IRQ interface    *    * The GUS supports two IRQs and two DMAs.    *    * Just one DMA channel is used. This prevents simultaneous ADC and DAC.    * Adding this support requires significant changes to the dmabuf.c, dsp.c    * and audio.c also.    */
name|irq_image
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|gus_irq_map
index|[
name|gus_irq
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|printk
argument_list|(
literal|"Warning! GUS IRQ not selected\n"
argument_list|)
expr_stmt|;
name|irq_image
operator||=
name|tmp
expr_stmt|;
name|irq_image
operator||=
literal|0x40
expr_stmt|;
comment|/* Combine IRQ1 (GF1) and IRQ2 (Midi) */
name|dma_image
operator|=
name|gus_dma_map
index|[
name|gus_dma_read
index|]
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|dma_image
condition|)
name|printk
argument_list|(
literal|"Warning!  GUS DMA read channel not selected.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_dma_read
operator|==
name|gus_dma
condition|)
block|{
name|dma_image
operator|=
literal|0x40
expr_stmt|;
comment|/* dual dma inhibited  				   Combine DMA1 (DRAM) and IRQ2 (ADC) */
block|}
name|tmp
operator|=
name|gus_dma_map
index|[
name|gus_dma
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|printk
argument_list|(
literal|"Warning! GUS DMA not selected\n"
argument_list|)
expr_stmt|;
name|dma_image
operator||=
name|tmp
expr_stmt|;
comment|/*    * For some reason the IRQ and DMA addresses must be written twice    */
comment|/*    * Doing it first time    */
name|OUTB
argument_list|(
name|mix_image
argument_list|,
name|u_Mixer
argument_list|)
expr_stmt|;
comment|/* Select DMA control */
name|OUTB
argument_list|(
name|dma_image
operator||
literal|0x80
argument_list|,
name|u_IRQDMAControl
argument_list|)
expr_stmt|;
comment|/* Set DMA address */
name|OUTB
argument_list|(
name|mix_image
operator||
literal|0x40
argument_list|,
name|u_Mixer
argument_list|)
expr_stmt|;
comment|/* Select IRQ control */
name|OUTB
argument_list|(
name|irq_image
argument_list|,
name|u_IRQDMAControl
argument_list|)
expr_stmt|;
comment|/* Set IRQ address */
comment|/*    * Doing it second time    */
name|OUTB
argument_list|(
name|mix_image
argument_list|,
name|u_Mixer
argument_list|)
expr_stmt|;
comment|/* Select DMA control */
name|OUTB
argument_list|(
name|dma_image
argument_list|,
name|u_IRQDMAControl
argument_list|)
expr_stmt|;
comment|/* Set DMA address */
name|OUTB
argument_list|(
name|mix_image
operator||
literal|0x40
argument_list|,
name|u_Mixer
argument_list|)
expr_stmt|;
comment|/* Select IRQ control */
name|OUTB
argument_list|(
name|irq_image
argument_list|,
name|u_IRQDMAControl
argument_list|)
expr_stmt|;
comment|/* Set IRQ address */
name|gus_select_voice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This disables writes to IRQ/DMA reg */
name|mix_image
operator|&=
operator|~
literal|0x02
expr_stmt|;
comment|/* Enable line out */
name|mix_image
operator||=
literal|0x08
expr_stmt|;
comment|/* Enable IRQ */
name|OUTB
argument_list|(
name|mix_image
argument_list|,
name|u_Mixer
argument_list|)
expr_stmt|;
comment|/* 				 * Turn mixer channels on 				 * Note! Mic in is left off. 				 */
name|gus_select_voice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This disables writes to IRQ/DMA reg */
name|gusintr
argument_list|(
name|INT_HANDLER_CALL
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Serve pending interrupts */
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gus_wave_detect
parameter_list|(
name|int
name|baseaddr
parameter_list|)
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|unsigned
name|long
name|loc
decl_stmt|;
name|gus_base
operator|=
name|baseaddr
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset GF1 */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Release Reset */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
comment|/* See if there is first block there.... */
name|gus_poke
argument_list|(
literal|0L
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_peek
argument_list|(
literal|0L
argument_list|)
operator|!=
literal|0xaa
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Now zero it out so that I can check for mirroring .. */
name|gus_poke
argument_list|(
literal|0L
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1L
init|;
name|i
operator|<
literal|1024L
condition|;
name|i
operator|++
control|)
block|{
name|int
name|n
decl_stmt|,
name|failed
decl_stmt|;
comment|/* check for mirroring ... */
if|if
condition|(
name|gus_peek
argument_list|(
literal|0L
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|loc
operator|=
name|i
operator|<<
literal|10
expr_stmt|;
for|for
control|(
name|n
operator|=
name|loc
operator|-
literal|1
operator|,
name|failed
operator|=
literal|0
init|;
name|n
operator|<=
name|loc
condition|;
name|n
operator|++
control|)
block|{
name|gus_poke
argument_list|(
name|loc
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_peek
argument_list|(
name|loc
argument_list|)
operator|!=
literal|0xaa
condition|)
name|failed
operator|=
literal|1
expr_stmt|;
name|gus_poke
argument_list|(
name|loc
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_peek
argument_list|(
name|loc
argument_list|)
operator|!=
literal|0x55
condition|)
name|failed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|failed
condition|)
break|break;
block|}
name|gus_mem_size
operator|=
name|i
operator|<<
literal|10
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_SYNTH_INFO
case|:
name|gus_info
operator|.
name|nr_voices
operator|=
name|nr_voices
expr_stmt|;
name|IOCTL_TO_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
operator|&
name|gus_info
argument_list|,
sizeof|sizeof
argument_list|(
name|gus_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_RESETSAMPLES
case|:
name|reset_sample_memory
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_PERCMODE
case|:
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
return|return
name|gus_mem_size
operator|-
name|free_mem_ptr
operator|-
literal|32
return|;
default|default:
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_set_instr
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|instr_no
parameter_list|)
block|{
name|int
name|sample_no
decl_stmt|;
if|if
condition|(
name|instr_no
operator|<
literal|0
operator|||
name|instr_no
operator|>
name|MAX_PATCH
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>
literal|31
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|==
name|VMODE_START_NOTE
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
operator|=
name|instr_no
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sample_no
operator|=
name|patch_table
index|[
name|instr_no
index|]
expr_stmt|;
name|patch_map
index|[
name|voice
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sample_no
operator|<
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Undefined patch %d for voice %d\n"
argument_list|,
name|instr_no
argument_list|,
name|voice
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* Patch not defined */
block|}
if|if
condition|(
name|sample_ptrs
index|[
name|sample_no
index|]
operator|==
operator|-
literal|1
condition|)
comment|/* Sample not loaded */
block|{
name|printk
argument_list|(
literal|"GUS: Sample #%d not loaded for patch %d (voice %d)\n"
argument_list|,
name|sample_no
argument_list|,
name|instr_no
argument_list|,
name|voice
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|sample_map
index|[
name|voice
index|]
operator|=
name|sample_no
expr_stmt|;
name|patch_map
index|[
name|voice
index|]
operator|=
name|instr_no
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_kill_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* voice_alloc->map[voice] = 0xffff; */
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|==
name|VMODE_START_NOTE
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|kill_pending
operator|=
literal|1
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_voice_fade
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_aftertouch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|pressure
parameter_list|)
block|{
if|#
directive|if
literal|0
block|short           lo_limit, hi_limit;   unsigned long   flags;    if (voice< 0 || voice> 31)     return;    if (voices[voice].mode& WAVE_ENVELOPES&& voices[voice].env_phase != 2)     return;
comment|/* Don't mix with envelopes */
block|if (pressure< 32)     {       DISABLE_INTR (flags);       gus_select_voice (voice);       gus_rampoff ();       compute_and_set_volume (voice, 255, 0);
comment|/* Back to original volume */
block|RESTORE_INTR (flags);       return;     }    hi_limit = voices[voice].current_volume;   lo_limit = hi_limit * 99 / 100;   if (lo_limit< 65)     lo_limit = 65;    DISABLE_INTR (flags);   gus_select_voice (voice);   if (hi_limit> (4095 - 65))     {       hi_limit = 4095 - 65;       gus_voice_volume (hi_limit);     }   gus_ramp_range (lo_limit, hi_limit);   gus_ramp_rate (3, 8);   gus_rampon (0x58);
comment|/* Bidirectional, dow, loop */
block|RESTORE_INTR (flags);
endif|#
directive|endif
comment|/* 0 */
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_panning
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|voice
operator|>=
literal|0
operator|||
name|voice
operator|<
literal|32
condition|)
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_volume_method
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|VOL_METHOD_LINEAR
operator|||
name|mode
operator|==
name|VOL_METHOD_ADAGIO
condition|)
name|volume_method
operator|=
name|mode
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compute_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
if|if
condition|(
name|volume
operator|<
literal|128
condition|)
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
operator|=
name|volume
expr_stmt|;
switch|switch
condition|(
name|volume_method
condition|)
block|{
case|case
name|VOL_METHOD_ADAGIO
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|gus_adagio_vol
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|patch_vol
argument_list|)
expr_stmt|;
break|break;
case|case
name|VOL_METHOD_LINEAR
case|:
comment|/* Totally ignores patch-volume and expression */
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|gus_linear_vol
argument_list|(
name|volume
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
argument_list|)
expr_stmt|;
break|break;
default|default:
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|volume_base
operator|+
operator|(
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
operator|*
name|volume_scale
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|>
literal|4030
condition|)
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
literal|4030
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compute_and_set_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|,
name|int
name|ramp_time
parameter_list|)
block|{
name|int
name|current
decl_stmt|,
name|target
decl_stmt|,
name|rate
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|compute_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/*      * CAUTION! Interrupts disabled. Enable them before returning    */
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|current
operator|=
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
expr_stmt|;
name|target
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
expr_stmt|;
if|if
condition|(
name|ramp_time
operator|==
name|INSTANT_RAMP
condition|)
block|{
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_volume
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ramp_time
operator|==
name|FAST_RAMP
condition|)
name|rate
operator|=
literal|63
expr_stmt|;
else|else
name|rate
operator|=
literal|16
expr_stmt|;
name|gus_ramp_rate
argument_list|(
literal|0
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|-
name|current
operator|)
operator|/
literal|64
operator|==
literal|0
condition|)
comment|/* Close enough to target. */
block|{
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_volume
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|target
operator|>
name|current
condition|)
block|{
if|if
condition|(
name|target
operator|>
operator|(
literal|4095
operator|-
literal|65
operator|)
condition|)
name|target
operator|=
literal|4095
operator|-
literal|65
expr_stmt|;
name|gus_ramp_range
argument_list|(
name|current
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Ramp up, once, no IRQ */
block|}
else|else
block|{
if|if
condition|(
name|target
operator|<
literal|65
condition|)
name|target
operator|=
literal|65
expr_stmt|;
name|gus_ramp_range
argument_list|(
name|target
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Ramp down, once, no irq */
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dynamic_volume_change
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|unsigned
name|char
name|status
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|status
operator|=
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Get voice status */
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x03
condition|)
return|return;
comment|/* Voice was not running */
if|if
condition|(
operator|!
operator|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
operator|)
condition|)
block|{
name|compute_and_set_volume
argument_list|(
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * Voice is running and has envelopes.    */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|status
operator|=
name|gus_read8
argument_list|(
literal|0x0d
argument_list|)
expr_stmt|;
comment|/* Ramping status */
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x03
condition|)
comment|/* Sustain phase? */
block|{
name|compute_and_set_volume
argument_list|(
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|<
literal|0
condition|)
return|return;
name|compute_volume
argument_list|(
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_controller
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|ctrl_num
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|long
name|freq
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>
literal|31
condition|)
return|return;
switch|switch
condition|(
name|ctrl_num
condition|)
block|{
case|case
name|CTRL_PITCH_BENDER
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|!=
name|VMODE_START_NOTE
condition|)
block|{
name|freq
operator|=
name|compute_finetune
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|value
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|freq
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_freq
argument_list|(
name|freq
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTRL_PITCH_BENDER_RANGE
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|CTL_EXPRESSION
case|:
name|value
operator|/=
literal|128
expr_stmt|;
case|case
name|CTRL_EXPRESSION
case|:
if|if
condition|(
name|volume_method
operator|==
name|VOL_METHOD_ADAGIO
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|!=
name|VMODE_START_NOTE
condition|)
name|dynamic_volume_change
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CTL_PAN
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
operator|(
name|value
operator|*
literal|2
operator|)
operator|-
literal|128
expr_stmt|;
break|break;
case|case
name|CTL_MAIN_VOLUME
case|:
name|value
operator|=
operator|(
name|value
operator|*
literal|100
operator|)
operator|/
literal|16383
expr_stmt|;
case|case
name|CTRL_MAIN_VOLUME
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|!=
name|VMODE_START_NOTE
condition|)
name|dynamic_volume_change
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_start_note2
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note_num
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
name|int
name|sample
decl_stmt|,
name|best_sample
decl_stmt|,
name|best_delta
decl_stmt|,
name|delta_freq
decl_stmt|;
name|int
name|is16bits
decl_stmt|,
name|samplep
decl_stmt|,
name|patch
decl_stmt|,
name|pan
decl_stmt|;
name|unsigned
name|long
name|note_freq
decl_stmt|,
name|base_note
decl_stmt|,
name|freq
decl_stmt|,
name|flags
decl_stmt|;
name|unsigned
name|char
name|mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>
literal|31
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Invalid voice\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|note_num
operator|==
literal|255
condition|)
block|{
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
operator|=
name|volume
expr_stmt|;
name|dynamic_volume_change
argument_list|(
name|voice
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|compute_and_set_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|patch
operator|=
name|patch_map
index|[
name|voice
index|]
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|samplep
operator|=
name|patch_table
index|[
name|patch
index|]
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|note_freq
operator|=
name|note_to_freq
argument_list|(
name|note_num
argument_list|)
expr_stmt|;
comment|/*    * Find a sample within a patch so that the note_freq is between low_note    * and high_note.    */
name|sample
operator|=
operator|-
literal|1
expr_stmt|;
name|best_sample
operator|=
name|samplep
expr_stmt|;
name|best_delta
operator|=
literal|1000000
expr_stmt|;
while|while
condition|(
name|samplep
operator|>=
literal|0
operator|&&
name|sample
operator|==
operator|-
literal|1
condition|)
block|{
name|delta_freq
operator|=
name|note_freq
operator|-
name|samples
index|[
name|samplep
index|]
operator|.
name|base_note
expr_stmt|;
if|if
condition|(
name|delta_freq
operator|<
literal|0
condition|)
name|delta_freq
operator|=
operator|-
name|delta_freq
expr_stmt|;
if|if
condition|(
name|delta_freq
operator|<
name|best_delta
condition|)
block|{
name|best_sample
operator|=
name|samplep
expr_stmt|;
name|best_delta
operator|=
name|delta_freq
expr_stmt|;
block|}
if|if
condition|(
name|samples
index|[
name|samplep
index|]
operator|.
name|low_note
operator|<=
name|note_freq
operator|&&
name|note_freq
operator|<=
name|samples
index|[
name|samplep
index|]
operator|.
name|high_note
condition|)
name|sample
operator|=
name|samplep
expr_stmt|;
else|else
name|samplep
operator|=
name|samples
index|[
name|samplep
index|]
operator|.
name|key
expr_stmt|;
comment|/* 						   * Follow link 						 */
block|}
if|if
condition|(
name|sample
operator|==
operator|-
literal|1
condition|)
name|sample
operator|=
name|best_sample
expr_stmt|;
if|if
condition|(
name|sample
operator|==
operator|-
literal|1
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Patch %d not defined for note %d\n"
argument_list|,
name|patch
argument_list|,
name|note_num
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Should play default patch ??? */
block|}
name|is16bits
operator|=
operator|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_16_BITS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|mode
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|patch_vol
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|volume
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|env_rate
index|[
name|i
index|]
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|env_rate
index|[
name|i
index|]
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|env_offset
index|[
name|i
index|]
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|env_offset
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|sample_map
index|[
name|voice
index|]
operator|=
name|sample
expr_stmt|;
name|base_note
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|base_note
operator|/
literal|100
expr_stmt|;
comment|/* Try to avoid overflows */
name|note_freq
operator|/=
literal|100
expr_stmt|;
name|freq
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|base_freq
operator|*
name|note_freq
operator|/
name|base_note
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
operator|=
name|freq
expr_stmt|;
comment|/*    * Since the pitch bender may have been set before playing the note, we    * have to calculate the bending now.    */
name|freq
operator|=
name|compute_finetune
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|freq
expr_stmt|;
name|pan
operator|=
operator|(
name|samples
index|[
name|sample
index|]
operator|.
name|panning
operator|+
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|)
operator|/
literal|32
expr_stmt|;
name|pan
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|pan
operator|<
literal|0
condition|)
name|pan
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pan
operator|>
literal|15
condition|)
name|pan
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_16_BITS
condition|)
block|{
name|mode
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bits */
if|if
condition|(
operator|(
name|sample_ptrs
index|[
name|sample
index|]
operator|>>
literal|18
operator|)
operator|!=
operator|(
operator|(
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|len
operator|)
operator|>>
literal|18
operator|)
condition|)
name|printk
argument_list|(
literal|"GUS: Sample address error\n"
argument_list|)
expr_stmt|;
block|}
comment|/*************************************************************************    *    CAUTION!        Interrupts disabled. Don't return before enabling    *************************************************************************/
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|compute_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|init_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
else|else
name|compute_and_set_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_LOOP_BACK
condition|)
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|len
operator|-
name|voices
index|[
name|voice
index|]
operator|.
name|offset_pending
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* start=end */
else|else
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|voices
index|[
name|voice
index|]
operator|.
name|offset_pending
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Sample start=begin */
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_LOOPING
condition|)
block|{
name|mode
operator||=
literal|0x08
expr_stmt|;
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_BIDIR_LOOP
condition|)
name|mode
operator||=
literal|0x10
expr_stmt|;
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_LOOP_BACK
condition|)
block|{
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|loop_end
operator|-
name|voices
index|[
name|voice
index|]
operator|.
name|offset_pending
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
name|mode
operator||=
literal|0x40
expr_stmt|;
block|}
name|gus_write_addr
argument_list|(
literal|0x02
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|loop_start
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop start location */
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|loop_end
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
block|}
else|else
block|{
name|mode
operator||=
literal|0x20
expr_stmt|;
comment|/* Loop IRQ at the end */
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
operator|=
name|LMODE_FINISH
expr_stmt|;
comment|/* Ramp down at the end */
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_parm
operator|=
literal|1
expr_stmt|;
name|gus_write_addr
argument_list|(
literal|0x02
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop start location */
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|len
operator|-
literal|1
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
block|}
name|gus_voice_freq
argument_list|(
name|freq
argument_list|)
expr_stmt|;
name|gus_voice_balance
argument_list|(
name|pan
argument_list|)
expr_stmt|;
name|gus_voice_on
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * New guswave_start_note by Andrew J. Robinson attempts to minimize clicking  * when the note playing on the voice is changed.  It uses volume  * ramping.  */
end_comment

begin_function
specifier|static
name|int
name|guswave_start_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note_num
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
name|long
name|int
name|flags
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|ret_val
init|=
literal|0
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|note_num
operator|==
literal|255
condition|)
block|{
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|==
name|VMODE_START_NOTE
condition|)
name|voices
index|[
name|voice
index|]
operator|.
name|volume_pending
operator|=
name|volume
expr_stmt|;
else|else
block|{
name|ret_val
operator|=
name|guswave_start_note2
argument_list|(
name|gus_devnum
argument_list|,
name|voice
argument_list|,
name|note_num
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|mode
operator|=
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
literal|0x20
condition|)
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
name|mode
operator|&
literal|0xdf
argument_list|)
expr_stmt|;
comment|/* No interrupt! */
name|voices
index|[
name|voice
index|]
operator|.
name|offset_pending
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|kill_pending
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
operator|>=
literal|0
condition|)
block|{
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* Run temporarily with interrupts enabled */
name|guswave_set_instr
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|dev_pending
argument_list|,
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
operator|=
operator|-
literal|1
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
comment|/* Reselect the voice (just to be sure) */
block|}
if|if
condition|(
operator|(
name|mode
operator|&
literal|0x01
operator|)
operator|||
call|(
name|int
call|)
argument_list|(
operator|(
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
operator|)
operator|<
literal|2065
argument_list|)
condition|)
block|{
name|ret_val
operator|=
name|guswave_start_note2
argument_list|(
name|gus_devnum
argument_list|,
name|voice
argument_list|,
name|note_num
argument_list|,
name|volume
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|dev_pending
operator|=
name|gus_devnum
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|note_pending
operator|=
name|note_num
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_pending
operator|=
name|volume
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
name|VMODE_START_NOTE
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_ramp_range
argument_list|(
literal|2000
argument_list|,
literal|4065
argument_list|)
expr_stmt|;
name|gus_ramp_rate
argument_list|(
literal|0
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/* Fastest possible rate */
name|gus_rampon
argument_list|(
literal|0x20
operator||
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Ramp down, once, irq */
block|}
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_reset
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|gus_voice_init
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|gus_voice_init2
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|mode
operator|&
name|OPEN_WRITE
operator|&&
name|gus_busy
index|[
name|gus_devnum
index|]
operator|||
name|mode
operator|&
name|OPEN_READ
operator|&&
name|gus_busy
index|[
name|gus_dspnum
index|]
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
if|if
condition|(
name|gus_busy
index|[
name|gus_devnum
index|]
operator|==
literal|0
operator|&&
name|gus_busy
index|[
name|gus_dspnum
index|]
operator|==
literal|0
condition|)
name|gus_initialize
argument_list|()
expr_stmt|;
name|voice_alloc
operator|->
name|timestamp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|DMAbuf_open_dma
argument_list|(
name|gus_devnum
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|err
return|;
name|RESET_WAIT_QUEUE
argument_list|(
name|dram_sleeper
argument_list|,
name|dram_sleep_flag
argument_list|)
expr_stmt|;
name|gus_busy
index|[
name|gus_devnum
index|]
operator|=
literal|1
expr_stmt|;
name|active_device
operator|=
name|GUS_DEV_WAVE
expr_stmt|;
name|gus_reset
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|gus_busy
index|[
name|gus_devnum
index|]
operator|=
literal|0
expr_stmt|;
name|active_device
operator|=
literal|0
expr_stmt|;
name|gus_reset
argument_list|()
expr_stmt|;
name|DMAbuf_close_dma
argument_list|(
name|gus_devnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_load_patch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|format
parameter_list|,
name|snd_rw_buf
modifier|*
name|addr
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
block|{
name|struct
name|patch_info
name|patch
decl_stmt|;
name|int
name|instr
decl_stmt|;
name|long
name|sizeof_patch
decl_stmt|;
name|unsigned
name|long
name|blk_size
decl_stmt|,
name|blk_end
decl_stmt|,
name|left
decl_stmt|,
name|src_offs
decl_stmt|,
name|target
decl_stmt|;
name|sizeof_patch
operator|=
operator|(
name|long
operator|)
operator|&
name|patch
operator|.
name|data
index|[
literal|0
index|]
operator|-
operator|(
name|long
operator|)
operator|&
name|patch
expr_stmt|;
comment|/* Header size */
if|if
condition|(
name|format
operator|!=
name|GUS_PATCH
condition|)
block|{
name|printk
argument_list|(
literal|"GUS Error: Invalid patch format (key) 0x%x\n"
argument_list|,
name|format
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|count
operator|<
name|sizeof_patch
condition|)
block|{
name|printk
argument_list|(
literal|"GUS Error: Patch header too short\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|count
operator|-=
name|sizeof_patch
expr_stmt|;
if|if
condition|(
name|free_sample
operator|>=
name|MAX_SAMPLE
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Sample table full\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
comment|/*    * Copy the header from user space but ignore the first bytes which have    * been transferred already.    */
name|COPY_FROM_USER
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|patch
operator|)
index|[
name|offs
index|]
argument_list|,
name|addr
argument_list|,
name|offs
argument_list|,
name|sizeof_patch
operator|-
name|offs
argument_list|)
expr_stmt|;
name|instr
operator|=
name|patch
operator|.
name|instr_no
expr_stmt|;
if|if
condition|(
name|instr
operator|<
literal|0
operator|||
name|instr
operator|>
name|MAX_PATCH
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Invalid patch number %d\n"
argument_list|,
name|instr
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|count
operator|<
name|patch
operator|.
name|len
condition|)
block|{
name|printk
argument_list|(
literal|"GUS Warning: Patch record too short (%d<%d)\n"
argument_list|,
name|count
argument_list|,
operator|(
name|int
operator|)
name|patch
operator|.
name|len
argument_list|)
expr_stmt|;
name|patch
operator|.
name|len
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|patch
operator|.
name|len
operator|<=
literal|0
operator|||
name|patch
operator|.
name|len
operator|>
name|gus_mem_size
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Invalid sample length %d\n"
argument_list|,
operator|(
name|int
operator|)
name|patch
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_LOOPING
condition|)
block|{
if|if
condition|(
name|patch
operator|.
name|loop_start
operator|<
literal|0
operator|||
name|patch
operator|.
name|loop_start
operator|>=
name|patch
operator|.
name|len
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Invalid loop start\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|patch
operator|.
name|loop_end
operator|<
name|patch
operator|.
name|loop_start
operator|||
name|patch
operator|.
name|loop_end
operator|>
name|patch
operator|.
name|len
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Invalid loop end\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
name|free_mem_ptr
operator|=
operator|(
name|free_mem_ptr
operator|+
literal|31
operator|)
operator|&
operator|~
literal|31
expr_stmt|;
comment|/* 32 byte alignment */
define|#
directive|define
name|GUS_BANK_SIZE
value|(256*1024)
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_16_BITS
condition|)
block|{
comment|/*        * 16 bit samples must fit one 256k bank.        */
if|if
condition|(
name|patch
operator|.
name|len
operator|>=
name|GUS_BANK_SIZE
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Sample (16 bit) too long %d\n"
argument_list|,
operator|(
name|int
operator|)
name|patch
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|free_mem_ptr
operator|/
name|GUS_BANK_SIZE
operator|)
operator|!=
operator|(
operator|(
name|free_mem_ptr
operator|+
name|patch
operator|.
name|len
operator|)
operator|/
name|GUS_BANK_SIZE
operator|)
condition|)
block|{
name|unsigned
name|long
name|tmp_mem
init|=
comment|/* Aling to 256K */
operator|(
operator|(
name|free_mem_ptr
operator|/
name|GUS_BANK_SIZE
operator|)
operator|+
literal|1
operator|)
operator|*
name|GUS_BANK_SIZE
decl_stmt|;
if|if
condition|(
operator|(
name|tmp_mem
operator|+
name|patch
operator|.
name|len
operator|)
operator|>
name|gus_mem_size
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
name|free_mem_ptr
operator|=
name|tmp_mem
expr_stmt|;
comment|/* This leaves unusable memory */
block|}
block|}
if|if
condition|(
operator|(
name|free_mem_ptr
operator|+
name|patch
operator|.
name|len
operator|)
operator|>
name|gus_mem_size
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
name|sample_ptrs
index|[
name|free_sample
index|]
operator|=
name|free_mem_ptr
expr_stmt|;
comment|/*    * Tremolo is not possible with envelopes    */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
name|patch
operator|.
name|mode
operator|&=
operator|~
name|WAVE_TREMOLO
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|samples
index|[
name|free_sample
index|]
argument_list|,
operator|&
name|patch
argument_list|,
name|sizeof_patch
argument_list|)
expr_stmt|;
comment|/*    * Link this_one sample to the list of samples for patch 'instr'.    */
name|samples
index|[
name|free_sample
index|]
operator|.
name|key
operator|=
name|patch_table
index|[
name|instr
index|]
expr_stmt|;
name|patch_table
index|[
name|instr
index|]
operator|=
name|free_sample
expr_stmt|;
comment|/*    * Use DMA to transfer the wave data to the DRAM    */
name|left
operator|=
name|patch
operator|.
name|len
expr_stmt|;
name|src_offs
operator|=
literal|0
expr_stmt|;
name|target
operator|=
name|free_mem_ptr
expr_stmt|;
while|while
condition|(
name|left
condition|)
comment|/* Not completely transferred yet */
block|{
name|blk_size
operator|=
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|buffsize
expr_stmt|;
if|if
condition|(
name|blk_size
operator|>
name|left
condition|)
name|blk_size
operator|=
name|left
expr_stmt|;
comment|/*        * DMA cannot cross 256k bank boundaries. Check for that.        */
name|blk_end
operator|=
name|target
operator|+
name|blk_size
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|>>
literal|18
operator|)
operator|!=
operator|(
name|blk_end
operator|>>
literal|18
operator|)
condition|)
block|{
comment|/* Split the block */
name|blk_end
operator|&=
operator|~
operator|(
literal|256
operator|*
literal|1024
operator|-
literal|1
operator|)
expr_stmt|;
name|blk_size
operator|=
name|blk_end
operator|-
name|target
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|GUS_NO_DMA
argument_list|)
operator|||
name|defined
argument_list|(
name|GUS_PATCH_NO_DMA
argument_list|)
comment|/*        * For some reason the DMA is not possible. We have to use PIO.        */
block|{
name|long
name|i
decl_stmt|;
name|unsigned
name|char
name|data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blk_size
condition|;
name|i
operator|++
control|)
block|{
name|GET_BYTE_FROM_USER
argument_list|(
name|data
argument_list|,
name|addr
argument_list|,
name|sizeof_patch
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_UNSIGNED
condition|)
if|if
condition|(
operator|!
operator|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_16_BITS
operator|)
operator|||
operator|(
name|i
operator|&
literal|0x01
operator|)
condition|)
name|data
operator|^=
literal|0x80
expr_stmt|;
comment|/* Convert to signed */
name|gus_poke
argument_list|(
name|target
operator|+
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* GUS_NO_DMA */
block|{
name|unsigned
name|long
name|address
decl_stmt|,
name|hold_address
decl_stmt|;
name|unsigned
name|char
name|dma_command
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
comment|/* 	 * OK, move now. First in and then out. 	 */
name|COPY_FROM_USER
argument_list|(
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmap
operator|->
name|raw_buf
index|[
literal|0
index|]
argument_list|,
name|addr
argument_list|,
name|sizeof_patch
operator|+
name|src_offs
argument_list|,
name|blk_size
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/******** INTERRUPTS DISABLED NOW ********/
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable GF1 DMA */
name|DMAbuf_start_dma
argument_list|(
name|gus_devnum
argument_list|,
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmap
operator|->
name|raw_buf_phys
index|[
literal|0
index|]
argument_list|,
name|blk_size
argument_list|,
name|DMA_MODE_WRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Set the DRAM address for the wave data 	 */
name|address
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmachan
operator|>
literal|3
condition|)
block|{
name|hold_address
operator|=
name|address
expr_stmt|;
name|address
operator|=
name|address
operator|>>
literal|1
expr_stmt|;
name|address
operator|&=
literal|0x0001ffffL
expr_stmt|;
name|address
operator||=
operator|(
name|hold_address
operator|&
literal|0x000c0000L
operator|)
expr_stmt|;
block|}
name|gus_write16
argument_list|(
literal|0x42
argument_list|,
operator|(
name|address
operator|>>
literal|4
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* DRAM DMA address */
comment|/* 	 * Start the DMA transfer 	 */
name|dma_command
operator|=
literal|0x21
expr_stmt|;
comment|/* IRQ enable, DMA start */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_UNSIGNED
condition|)
name|dma_command
operator||=
literal|0x80
expr_stmt|;
comment|/* Invert MSB */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_16_BITS
condition|)
name|dma_command
operator||=
literal|0x40
expr_stmt|;
comment|/* 16 bit _DATA_ */
if|if
condition|(
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmachan
operator|>
literal|3
condition|)
name|dma_command
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bit DMA _channel_ */
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
name|dma_command
argument_list|)
expr_stmt|;
comment|/* Lets bo luteet (=bugs) */
comment|/* 	 * Sleep here until the DRAM DMA done interrupt is served 	 */
name|active_device
operator|=
name|GUS_DEV_WAVE
expr_stmt|;
name|DO_SLEEP
argument_list|(
name|dram_sleeper
argument_list|,
name|dram_sleep_flag
argument_list|,
name|HZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|TIMED_OUT
argument_list|(
name|dram_sleeper
argument_list|,
name|dram_sleep_flag
argument_list|)
condition|)
name|printk
argument_list|(
literal|"GUS: DMA Transfer timed out\n"
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* GUS_NO_DMA */
comment|/*        * Now the next part        */
name|left
operator|-=
name|blk_size
expr_stmt|;
name|src_offs
operator|+=
name|blk_size
expr_stmt|;
name|target
operator|+=
name|blk_size
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop DMA */
block|}
name|free_mem_ptr
operator|+=
name|patch
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|pmgr_flag
condition|)
name|pmgr_inform
argument_list|(
name|gus_devnum
argument_list|,
name|PM_E_PATCH_LOADED
argument_list|,
name|instr
argument_list|,
name|free_sample
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_sample
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_hw_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|voice
decl_stmt|,
name|cmd
decl_stmt|;
name|unsigned
name|short
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|unsigned
name|long
name|plong
decl_stmt|,
name|flags
decl_stmt|;
name|cmd
operator|=
name|event
index|[
literal|2
index|]
expr_stmt|;
name|voice
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
name|p1
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|6
index|]
expr_stmt|;
name|plong
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|==
name|VMODE_START_NOTE
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|_GUS_VOICESAMPLE
operator|)
operator|&&
operator|(
name|cmd
operator|!=
name|_GUS_VOICE_POS
operator|)
condition|)
name|do_volume_irq
argument_list|(
name|voice
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|_GUS_NUMVOICES
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_select_max_voices
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICESAMPLE
case|:
name|guswave_set_instr
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEON
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Don't allow interrupts */
name|gus_voice_on
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEOFF
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_off
argument_list|()
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEFADE
case|:
name|gus_voice_fade
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEMODE
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Don't allow interrupts */
name|gus_voice_mode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEBALA
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_balance
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEFREQ
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_freq
argument_list|(
name|plong
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEVOL
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_volume
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEVOL2
case|:
comment|/* Just update the software voice level */
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
name|p1
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPRANGE
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* NO-NO */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_ramp_range
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPRATE
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* NJET-NJET */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_ramp_rate
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPMODE
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* NO-NO */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Don't allow interrupts */
name|gus_ramp_mode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPON
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* EI-EI */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Don't allow interrupts */
name|gus_rampon
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPOFF
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* NEJ-NEJ */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOLUME_SCALE
case|:
name|volume_base
operator|=
name|p1
expr_stmt|;
name|volume_scale
operator|=
name|p2
expr_stmt|;
break|break;
case|case
name|_GUS_VOICE_POS
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_set_voice_pos
argument_list|(
name|voice
argument_list|,
name|plong
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_set_speed
parameter_list|(
name|int
name|speed
parameter_list|)
block|{
if|if
condition|(
name|speed
operator|<=
literal|0
condition|)
name|speed
operator|=
name|gus_sampling_speed
expr_stmt|;
if|if
condition|(
name|speed
operator|<
literal|4000
condition|)
name|speed
operator|=
literal|4000
expr_stmt|;
if|if
condition|(
name|speed
operator|>
literal|44100
condition|)
name|speed
operator|=
literal|44100
expr_stmt|;
name|gus_sampling_speed
operator|=
name|speed
expr_stmt|;
if|if
condition|(
name|only_read_access
condition|)
block|{
comment|/* Compute nearest valid recording speed  and return it */
name|speed
operator|=
operator|(
literal|9878400
operator|/
operator|(
name|gus_sampling_speed
operator|+
literal|2
operator|)
operator|)
operator|/
literal|16
expr_stmt|;
name|speed
operator|=
operator|(
literal|9878400
operator|/
operator|(
name|speed
operator|*
literal|16
operator|)
operator|)
operator|-
literal|2
expr_stmt|;
block|}
return|return
name|speed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_set_channels
parameter_list|(
name|int
name|channels
parameter_list|)
block|{
if|if
condition|(
operator|!
name|channels
condition|)
return|return
name|gus_sampling_channels
return|;
if|if
condition|(
name|channels
operator|>
literal|2
condition|)
name|channels
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|channels
operator|<
literal|1
condition|)
name|channels
operator|=
literal|1
expr_stmt|;
name|gus_sampling_channels
operator|=
name|channels
expr_stmt|;
return|return
name|channels
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_set_bits
parameter_list|(
name|int
name|bits
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bits
condition|)
return|return
name|gus_sampling_bits
return|;
if|if
condition|(
name|bits
operator|!=
literal|8
operator|&&
name|bits
operator|!=
literal|16
condition|)
name|bits
operator|=
literal|8
expr_stmt|;
name|gus_sampling_bits
operator|=
name|bits
expr_stmt|;
return|return
name|bits
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|arg
parameter_list|,
name|int
name|local
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SOUND_PCM_WRITE_RATE
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_set_speed
argument_list|(
name|arg
argument_list|)
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_set_speed
argument_list|(
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_PCM_READ_RATE
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_speed
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_speed
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_DSP_STEREO
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_set_channels
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
operator|-
literal|1
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_set_channels
argument_list|(
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
operator|-
literal|1
argument_list|)
return|;
break|break;
case|case
name|SOUND_PCM_WRITE_CHANNELS
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_set_channels
argument_list|(
name|arg
argument_list|)
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_set_channels
argument_list|(
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_PCM_READ_CHANNELS
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_channels
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_channels
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_DSP_SETFMT
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_set_bits
argument_list|(
name|arg
argument_list|)
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_set_bits
argument_list|(
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_PCM_READ_BITS
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_bits
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_bits
argument_list|)
return|;
case|case
name|SOUND_PCM_WRITE_FILTER
case|:
comment|/* NOT POSSIBLE */
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_PCM_READ_FILTER
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
argument_list|)
return|;
break|break;
block|}
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_reset
parameter_list|(
name|int
name|dev
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|gus_sampling_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|dev_flag
decl_stmt|;
ifdef|#
directive|ifdef
name|GUS_NO_DMA
name|printk
argument_list|(
literal|"GUS: DMA mode not enabled. Device not supported\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
endif|#
directive|endif
name|dev_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|OPEN_WRITE
condition|)
block|{
if|if
condition|(
name|gus_busy
index|[
name|gus_devnum
index|]
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
if|if
condition|(
name|dev
operator|!=
name|gus_devnum
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
name|dev_flag
operator|=
name|gus_busy
index|[
name|gus_devnum
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|&
name|OPEN_READ
condition|)
block|{
if|if
condition|(
name|gus_busy
index|[
name|gus_dspnum
index|]
condition|)
block|{
if|if
condition|(
name|dev_flag
condition|)
name|gus_busy
index|[
name|gus_devnum
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
if|if
condition|(
name|dev
operator|!=
name|gus_dspnum
condition|)
block|{
if|if
condition|(
name|dev_flag
condition|)
name|gus_busy
index|[
name|gus_devnum
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|gus_busy
index|[
name|gus_devnum
index|]
operator|==
literal|0
operator|&&
name|gus_busy
index|[
name|gus_dspnum
index|]
operator|==
literal|0
condition|)
name|gus_initialize
argument_list|()
expr_stmt|;
name|active_device
operator|=
literal|0
expr_stmt|;
name|gus_reset
argument_list|()
expr_stmt|;
name|reset_sample_memory
argument_list|()
expr_stmt|;
name|gus_select_max_voices
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|pcm_active
operator|=
literal|0
expr_stmt|;
name|dma_active
operator|=
literal|0
expr_stmt|;
name|pcm_opened
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|OPEN_READ
condition|)
block|{
name|recording_active
operator|=
literal|1
expr_stmt|;
name|set_input_volumes
argument_list|()
expr_stmt|;
block|}
name|only_read_access
operator|=
operator|!
operator|(
name|mode
operator|&
name|OPEN_WRITE
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|gus_busy
index|[
name|dev
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gus_busy
index|[
name|gus_devnum
index|]
operator|==
literal|0
operator|&&
name|gus_busy
index|[
name|gus_dspnum
index|]
condition|)
block|{
name|active_device
operator|=
literal|0
expr_stmt|;
name|gus_reset
argument_list|()
expr_stmt|;
name|pcm_opened
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|recording_active
condition|)
name|set_input_volumes
argument_list|()
expr_stmt|;
name|recording_active
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_update_volume
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|voice
decl_stmt|;
if|if
condition|(
name|pcm_active
operator|&&
name|pcm_opened
condition|)
for|for
control|(
name|voice
operator|=
literal|0
init|;
name|voice
operator|<
name|gus_sampling_channels
condition|;
name|voice
operator|++
control|)
block|{
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_volume
argument_list|(
literal|1530
operator|+
operator|(
literal|25
operator|*
name|gus_pcm_volume
operator|)
argument_list|)
expr_stmt|;
name|gus_ramp_range
argument_list|(
literal|65
argument_list|,
literal|1530
operator|+
operator|(
literal|25
operator|*
name|gus_pcm_volume
operator|)
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|play_next_pcm_block
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|speed
init|=
name|gus_sampling_speed
decl_stmt|;
name|int
name|this_one
decl_stmt|,
name|is16bits
decl_stmt|,
name|chn
decl_stmt|;
name|unsigned
name|long
name|dram_loc
decl_stmt|;
name|unsigned
name|char
name|mode
index|[
literal|2
index|]
decl_stmt|,
name|ramp_mode
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|pcm_qlen
condition|)
return|return;
name|this_one
operator|=
name|pcm_head
expr_stmt|;
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
name|gus_sampling_channels
condition|;
name|chn
operator|++
control|)
block|{
name|mode
index|[
name|chn
index|]
operator|=
literal|0x00
expr_stmt|;
name|ramp_mode
index|[
name|chn
index|]
operator|=
literal|0x03
expr_stmt|;
comment|/* Ramping and rollover off */
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
block|{
name|mode
index|[
name|chn
index|]
operator||=
literal|0x20
expr_stmt|;
comment|/* Loop IRQ */
name|voices
index|[
name|chn
index|]
operator|.
name|loop_irq_mode
operator|=
name|LMODE_PCM
expr_stmt|;
block|}
if|if
condition|(
name|gus_sampling_bits
operator|!=
literal|8
condition|)
block|{
name|is16bits
operator|=
literal|1
expr_stmt|;
name|mode
index|[
name|chn
index|]
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bit data */
block|}
else|else
name|is16bits
operator|=
literal|0
expr_stmt|;
name|dram_loc
operator|=
name|this_one
operator|*
name|pcm_bsize
expr_stmt|;
name|dram_loc
operator|+=
name|chn
operator|*
name|pcm_banksize
expr_stmt|;
if|if
condition|(
name|this_one
operator|==
operator|(
name|pcm_nblk
operator|-
literal|1
operator|)
condition|)
comment|/* Last fragment of the DRAM buffer */
block|{
name|mode
index|[
name|chn
index|]
operator||=
literal|0x08
expr_stmt|;
comment|/* Enable loop */
name|ramp_mode
index|[
name|chn
index|]
operator|=
literal|0x03
expr_stmt|;
comment|/* Disable rollover bit */
block|}
else|else
block|{
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
name|ramp_mode
index|[
name|chn
index|]
operator|=
literal|0x04
expr_stmt|;
comment|/* Enable rollover bit */
block|}
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|gus_voice_freq
argument_list|(
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_sampling_channels
operator|==
literal|1
condition|)
name|gus_voice_balance
argument_list|(
literal|7
argument_list|)
expr_stmt|;
comment|/* mono */
elseif|else
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
name|gus_voice_balance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* left */
else|else
name|gus_voice_balance
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* right */
if|if
condition|(
operator|!
name|pcm_active
condition|)
comment|/* Playback not already active */
block|{
comment|/* 	   * The playback was not started yet (or there has been a pause). 	   * Start the voice (again) and ask for a rollover irq at the end of 	   * this_one block. If this_one one is last of the buffers, use just 	   * the normal loop with irq. 	   */
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_volume
argument_list|(
literal|1530
operator|+
operator|(
literal|25
operator|*
name|gus_pcm_volume
operator|)
argument_list|)
expr_stmt|;
name|gus_ramp_range
argument_list|(
literal|65
argument_list|,
literal|1530
operator|+
operator|(
literal|25
operator|*
name|gus_pcm_volume
operator|)
argument_list|)
expr_stmt|;
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
name|dram_loc
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Starting position */
name|gus_write_addr
argument_list|(
literal|0x02
argument_list|,
name|chn
operator|*
name|pcm_banksize
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop start */
if|if
condition|(
name|chn
operator|!=
literal|0
condition|)
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|pcm_banksize
operator|+
operator|(
name|pcm_bsize
operator|*
name|pcm_nblk
operator|)
operator|-
literal|1
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
block|}
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|dram_loc
operator|+
name|pcm_datasize
index|[
name|this_one
index|]
operator|-
literal|1
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
else|else
name|mode
index|[
name|chn
index|]
operator||=
literal|0x08
expr_stmt|;
comment|/* Enable looping */
if|if
condition|(
name|pcm_datasize
index|[
name|this_one
index|]
operator|!=
name|pcm_bsize
condition|)
block|{
comment|/* 	   * Incompletely filled block. Possibly the last one. 	   */
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
block|{
name|mode
index|[
name|chn
index|]
operator|&=
operator|~
literal|0x08
expr_stmt|;
comment|/* Disable looping */
name|mode
index|[
name|chn
index|]
operator||=
literal|0x20
expr_stmt|;
comment|/* Enable IRQ at the end */
name|voices
index|[
literal|0
index|]
operator|.
name|loop_irq_mode
operator|=
name|LMODE_PCM_STOP
expr_stmt|;
name|ramp_mode
index|[
name|chn
index|]
operator|=
literal|0x03
expr_stmt|;
comment|/* No rollover bit */
block|}
else|else
block|{
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|dram_loc
operator|+
name|pcm_datasize
index|[
name|this_one
index|]
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
name|mode
index|[
name|chn
index|]
operator|&=
operator|~
literal|0x08
expr_stmt|;
comment|/* Disable looping */
block|}
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
name|gus_sampling_channels
condition|;
name|chn
operator|++
control|)
block|{
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
name|ramp_mode
index|[
name|chn
index|]
argument_list|)
expr_stmt|;
name|gus_voice_on
argument_list|(
name|mode
index|[
name|chn
index|]
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
name|pcm_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_transfer_output_block
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|long
name|buf
parameter_list|,
name|int
name|total_count
parameter_list|,
name|int
name|intrflag
parameter_list|,
name|int
name|chn
parameter_list|)
block|{
comment|/*    * This routine transfers one block of audio data to the DRAM. In mono mode    * it's called just once. When in stereo mode, this_one routine is called    * once for both channels.    *    * The left/mono channel data is transferred to the beginning of dram and the    * right data to the area pointed by gus_page_size.    */
name|int
name|this_one
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|dma_command
decl_stmt|;
name|unsigned
name|long
name|address
decl_stmt|,
name|hold_address
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|count
operator|=
name|total_count
operator|/
name|gus_sampling_channels
expr_stmt|;
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pcm_qlen
operator|>=
name|pcm_nblk
condition|)
name|printk
argument_list|(
literal|"GUS Warning: PCM buffers out of sync\n"
argument_list|)
expr_stmt|;
name|this_one
operator|=
name|pcm_current_block
operator|=
name|pcm_tail
expr_stmt|;
name|pcm_qlen
operator|++
expr_stmt|;
name|pcm_tail
operator|=
operator|(
name|pcm_tail
operator|+
literal|1
operator|)
operator|%
name|pcm_nblk
expr_stmt|;
name|pcm_datasize
index|[
name|this_one
index|]
operator|=
name|count
expr_stmt|;
block|}
else|else
name|this_one
operator|=
name|pcm_current_block
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable GF1 DMA */
name|DMAbuf_start_dma
argument_list|(
name|gus_devnum
argument_list|,
name|buf
operator|+
operator|(
name|chn
operator|*
name|count
operator|)
argument_list|,
name|count
argument_list|,
name|DMA_MODE_WRITE
argument_list|)
expr_stmt|;
name|address
operator|=
name|this_one
operator|*
name|pcm_bsize
expr_stmt|;
name|address
operator|+=
name|chn
operator|*
name|pcm_banksize
expr_stmt|;
if|if
condition|(
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmachan
operator|>
literal|3
condition|)
block|{
name|hold_address
operator|=
name|address
expr_stmt|;
name|address
operator|=
name|address
operator|>>
literal|1
expr_stmt|;
name|address
operator|&=
literal|0x0001ffffL
expr_stmt|;
name|address
operator||=
operator|(
name|hold_address
operator|&
literal|0x000c0000L
operator|)
expr_stmt|;
block|}
name|gus_write16
argument_list|(
literal|0x42
argument_list|,
operator|(
name|address
operator|>>
literal|4
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* DRAM DMA address */
name|dma_command
operator|=
literal|0x21
expr_stmt|;
comment|/* IRQ enable, DMA start */
if|if
condition|(
name|gus_sampling_bits
operator|!=
literal|8
condition|)
name|dma_command
operator||=
literal|0x40
expr_stmt|;
comment|/* 16 bit _DATA_ */
else|else
name|dma_command
operator||=
literal|0x80
expr_stmt|;
comment|/* Invert MSB */
if|if
condition|(
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmachan
operator|>
literal|3
condition|)
name|dma_command
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bit DMA channel */
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
name|dma_command
argument_list|)
expr_stmt|;
comment|/* Kickstart */
if|if
condition|(
name|chn
operator|==
operator|(
name|gus_sampling_channels
operator|-
literal|1
operator|)
condition|)
comment|/* Last channel */
block|{
comment|/*        * Last (right or mono) channel data        */
name|dma_active
operator|=
literal|1
expr_stmt|;
comment|/* DMA started. There is a unacknowledged buffer */
name|active_device
operator|=
name|GUS_DEV_PCM_DONE
expr_stmt|;
if|if
condition|(
operator|!
name|pcm_active
operator|&&
operator|(
name|pcm_qlen
operator|>
literal|0
operator|||
name|count
operator|<
name|pcm_bsize
operator|)
condition|)
block|{
name|play_next_pcm_block
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*          * Left channel data. The right channel          * is transferred after DMA interrupt        */
name|active_device
operator|=
name|GUS_DEV_PCM_CONTINUE
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_output_block
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|long
name|buf
parameter_list|,
name|int
name|total_count
parameter_list|,
name|int
name|intrflag
parameter_list|,
name|int
name|restart_dma
parameter_list|)
block|{
name|pcm_current_buf
operator|=
name|buf
expr_stmt|;
name|pcm_current_count
operator|=
name|total_count
expr_stmt|;
name|pcm_current_intrflag
operator|=
name|intrflag
expr_stmt|;
name|pcm_current_dev
operator|=
name|gus_devnum
expr_stmt|;
name|gus_transfer_output_block
argument_list|(
name|gus_devnum
argument_list|,
name|buf
argument_list|,
name|total_count
argument_list|,
name|intrflag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_start_input
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|long
name|buf
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|intrflag
parameter_list|,
name|int
name|restart_dma
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|mode
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|DMAbuf_start_dma
argument_list|(
name|gus_dspnum
argument_list|,
name|buf
argument_list|,
name|count
argument_list|,
name|DMA_MODE_READ
argument_list|)
expr_stmt|;
name|mode
operator|=
literal|0xa0
expr_stmt|;
comment|/* DMA IRQ enabled, invert MSB */
if|if
condition|(
name|audio_devs
index|[
name|gus_dspnum
index|]
operator|->
name|dmachan
operator|>
literal|3
condition|)
name|mode
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bit DMA channel */
if|if
condition|(
name|gus_sampling_channels
operator|>
literal|1
condition|)
name|mode
operator||=
literal|0x02
expr_stmt|;
comment|/* Stereo */
name|mode
operator||=
literal|0x01
expr_stmt|;
comment|/* DMA enable */
name|gus_write8
argument_list|(
literal|0x49
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_prepare_for_input
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|bsize
parameter_list|,
name|int
name|bcount
parameter_list|)
block|{
name|unsigned
name|int
name|rate
decl_stmt|;
name|rate
operator|=
operator|(
literal|9878400
operator|/
operator|(
name|gus_sampling_speed
operator|+
literal|2
operator|)
operator|)
operator|/
literal|16
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x48
argument_list|,
name|rate
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Set sampling rate */
if|if
condition|(
name|gus_sampling_bits
operator|!=
literal|8
condition|)
block|{
name|printk
argument_list|(
literal|"GUS Error: 16 bit recording not supported\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_prepare_for_output
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|bsize
parameter_list|,
name|int
name|bcount
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|long
name|mem_ptr
decl_stmt|,
name|mem_size
decl_stmt|;
name|mem_ptr
operator|=
literal|0
expr_stmt|;
name|mem_size
operator|=
name|gus_mem_size
operator|/
name|gus_sampling_channels
expr_stmt|;
if|if
condition|(
name|mem_size
operator|>
operator|(
literal|256
operator|*
literal|1024
operator|)
condition|)
name|mem_size
operator|=
literal|256
operator|*
literal|1024
expr_stmt|;
name|pcm_bsize
operator|=
name|bsize
operator|/
name|gus_sampling_channels
expr_stmt|;
name|pcm_head
operator|=
name|pcm_tail
operator|=
name|pcm_qlen
operator|=
literal|0
expr_stmt|;
name|pcm_nblk
operator|=
name|MAX_PCM_BUFFERS
expr_stmt|;
if|if
condition|(
operator|(
name|pcm_bsize
operator|*
name|pcm_nblk
operator|)
operator|>
name|mem_size
condition|)
name|pcm_nblk
operator|=
name|mem_size
operator|/
name|pcm_bsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcm_nblk
condition|;
name|i
operator|++
control|)
name|pcm_datasize
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|pcm_banksize
operator|=
name|pcm_nblk
operator|*
name|pcm_bsize
expr_stmt|;
if|if
condition|(
name|gus_sampling_bits
operator|!=
literal|8
operator|&&
name|pcm_banksize
operator|==
operator|(
literal|256
operator|*
literal|1024
operator|)
condition|)
name|pcm_nblk
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_local_qlen
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
return|return
name|pcm_qlen
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_copy_from_user
parameter_list|(
name|int
name|dev
parameter_list|,
name|char
modifier|*
name|localbuf
parameter_list|,
name|int
name|localoffs
parameter_list|,
name|snd_rw_buf
modifier|*
name|userbuf
parameter_list|,
name|int
name|useroffs
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|gus_sampling_channels
operator|==
literal|1
condition|)
block|{
name|COPY_FROM_USER
argument_list|(
operator|&
name|localbuf
index|[
name|localoffs
index|]
argument_list|,
name|userbuf
argument_list|,
name|useroffs
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|gus_sampling_bits
operator|==
literal|8
condition|)
block|{
name|int
name|in_left
init|=
name|useroffs
decl_stmt|;
name|int
name|in_right
init|=
name|useroffs
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|out_left
decl_stmt|,
modifier|*
name|out_right
decl_stmt|;
name|int
name|i
decl_stmt|;
name|len
operator|/=
literal|2
expr_stmt|;
name|localoffs
operator|/=
literal|2
expr_stmt|;
name|out_left
operator|=
operator|&
name|localbuf
index|[
name|localoffs
index|]
expr_stmt|;
name|out_right
operator|=
name|out_left
operator|+
name|pcm_bsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|GET_BYTE_FROM_USER
argument_list|(
operator|*
name|out_left
operator|++
argument_list|,
name|userbuf
argument_list|,
name|in_left
argument_list|)
expr_stmt|;
name|in_left
operator|+=
literal|2
expr_stmt|;
name|GET_BYTE_FROM_USER
argument_list|(
operator|*
name|out_right
operator|++
argument_list|,
name|userbuf
argument_list|,
name|in_right
argument_list|)
expr_stmt|;
name|in_right
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|in_left
init|=
name|useroffs
operator|/
literal|2
decl_stmt|;
name|int
name|in_right
init|=
name|useroffs
operator|/
literal|2
operator|+
literal|1
decl_stmt|;
name|short
modifier|*
name|out_left
decl_stmt|,
modifier|*
name|out_right
decl_stmt|;
name|int
name|i
decl_stmt|;
name|len
operator|/=
literal|4
expr_stmt|;
name|localoffs
operator|/=
literal|4
expr_stmt|;
name|out_left
operator|=
operator|(
name|short
operator|*
operator|)
operator|&
name|localbuf
index|[
name|localoffs
index|]
expr_stmt|;
name|out_right
operator|=
name|out_left
operator|+
operator|(
name|pcm_bsize
operator|/
literal|2
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|GET_SHORT_FROM_USER
argument_list|(
operator|*
name|out_left
operator|++
argument_list|,
operator|(
name|short
operator|*
operator|)
name|userbuf
argument_list|,
name|in_left
argument_list|)
expr_stmt|;
name|in_left
operator|+=
literal|2
expr_stmt|;
name|GET_SHORT_FROM_USER
argument_list|(
operator|*
name|out_right
operator|++
argument_list|,
operator|(
name|short
operator|*
operator|)
name|userbuf
argument_list|,
name|in_right
argument_list|)
expr_stmt|;
name|in_right
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|audio_operations
name|gus_sampling_operations
init|=
block|{
literal|"Gravis UltraSound"
block|,
name|NEEDS_RESTART
block|,
name|AFMT_U8
operator||
name|AFMT_S16_LE
block|,
name|NULL
block|,
name|gus_sampling_open
block|,
name|gus_sampling_close
block|,
name|gus_sampling_output_block
block|,
name|gus_sampling_start_input
block|,
name|gus_sampling_ioctl
block|,
name|gus_sampling_prepare_for_input
block|,
name|gus_sampling_prepare_for_output
block|,
name|gus_sampling_reset
block|,
name|gus_sampling_reset
block|,
name|gus_local_qlen
block|,
name|gus_copy_from_user
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|audio_operations
name|gus_sampling_operations_read
init|=
block|{
literal|"Gravis UltraSound - read only"
block|,
name|NEEDS_RESTART
block|,
name|AFMT_U8
operator||
name|AFMT_S16_LE
block|,
name|NULL
block|,
name|gus_sampling_open
block|,
name|gus_sampling_close
block|,
name|gus_sampling_output_block
block|,
name|gus_sampling_start_input
block|,
name|gus_sampling_ioctl
block|,
name|gus_sampling_prepare_for_input
block|,
name|gus_sampling_prepare_for_output
block|,
name|gus_sampling_reset
block|,
name|gus_sampling_reset
block|,
name|gus_local_qlen
block|,
name|gus_copy_from_user
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|guswave_setup_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|chn
parameter_list|)
block|{
name|struct
name|channel_info
modifier|*
name|info
init|=
operator|&
name|synth_devs
index|[
name|gus_devnum
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
decl_stmt|;
name|guswave_set_instr
argument_list|(
name|gus_devnum
argument_list|,
name|voice
argument_list|,
name|info
operator|->
name|pgm_num
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
operator|=
name|info
operator|->
name|controllers
index|[
name|CTL_EXPRESSION
index|]
expr_stmt|;
comment|/* Just msb */
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
operator|=
operator|(
name|info
operator|->
name|controllers
index|[
name|CTL_MAIN_VOLUME
index|]
operator|*
literal|100
operator|)
operator|/
literal|128
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
operator|(
name|info
operator|->
name|controllers
index|[
name|CTL_PAN
index|]
operator|*
literal|2
operator|)
operator|-
literal|128
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|info
operator|->
name|bender_value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_bender
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|int
name|freq
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|value
operator|-
literal|8192
expr_stmt|;
name|freq
operator|=
name|compute_finetune
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|value
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|freq
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_freq
argument_list|(
name|freq
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_patchmgr
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|patmgr_info
modifier|*
name|rec
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
switch|switch
condition|(
name|rec
operator|->
name|command
condition|)
block|{
case|case
name|PM_GET_DEVTYPE
case|:
name|rec
operator|->
name|parm1
operator|=
name|PMTYPE_WAVE
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|PM_GET_NRPGM
case|:
name|rec
operator|->
name|parm1
operator|=
name|MAX_PATCH
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|PM_GET_PGMMAP
case|:
name|rec
operator|->
name|parm1
operator|=
name|MAX_PATCH
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PATCH
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ptr
init|=
name|patch_table
index|[
name|i
index|]
decl_stmt|;
name|rec
operator|->
name|data
operator|.
name|data8
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ptr
operator|>=
literal|0
operator|&&
name|ptr
operator|<
name|free_sample
condition|)
block|{
name|rec
operator|->
name|data
operator|.
name|data8
index|[
name|i
index|]
operator|++
expr_stmt|;
name|ptr
operator|=
name|samples
index|[
name|ptr
index|]
operator|.
name|key
expr_stmt|;
comment|/* Follow link */
block|}
block|}
return|return
literal|0
return|;
break|break;
case|case
name|PM_GET_PGM_PATCHES
case|:
block|{
name|int
name|ptr
init|=
name|patch_table
index|[
name|rec
operator|->
name|parm1
index|]
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ptr
operator|>=
literal|0
operator|&&
name|ptr
operator|<
name|free_sample
condition|)
block|{
name|rec
operator|->
name|data
operator|.
name|data32
index|[
name|n
operator|++
index|]
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|samples
index|[
name|ptr
index|]
operator|.
name|key
expr_stmt|;
comment|/* Follow link */
block|}
block|}
name|rec
operator|->
name|parm1
operator|=
name|n
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|PM_GET_PATCH
case|:
block|{
name|int
name|ptr
init|=
name|rec
operator|->
name|parm1
decl_stmt|;
name|struct
name|patch_info
modifier|*
name|pat
decl_stmt|;
if|if
condition|(
name|ptr
operator|<
literal|0
operator|||
name|ptr
operator|>=
name|free_sample
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|memcpy
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|samples
index|[
name|ptr
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|patch_info
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
operator|(
expr|struct
name|patch_info
operator|*
operator|)
name|rec
operator|->
name|data
operator|.
name|data8
expr_stmt|;
name|pat
operator|->
name|key
operator|=
name|GUS_PATCH
expr_stmt|;
comment|/* Restore patch type */
name|rec
operator|->
name|parm1
operator|=
name|sample_ptrs
index|[
name|ptr
index|]
expr_stmt|;
comment|/* DRAM location */
name|rec
operator|->
name|parm2
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|patch_info
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
break|break;
case|case
name|PM_SET_PATCH
case|:
block|{
name|int
name|ptr
init|=
name|rec
operator|->
name|parm1
decl_stmt|;
name|struct
name|patch_info
modifier|*
name|pat
decl_stmt|;
if|if
condition|(
name|ptr
operator|<
literal|0
operator|||
name|ptr
operator|>=
name|free_sample
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|pat
operator|=
operator|(
expr|struct
name|patch_info
operator|*
operator|)
name|rec
operator|->
name|data
operator|.
name|data8
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|len
operator|>
name|samples
index|[
name|ptr
index|]
operator|.
name|len
condition|)
comment|/* Cannot expand sample */
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|pat
operator|->
name|key
operator|=
name|samples
index|[
name|ptr
index|]
operator|.
name|key
expr_stmt|;
comment|/* Ensure the link is correct */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|samples
index|[
name|ptr
index|]
argument_list|,
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|patch_info
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|->
name|key
operator|=
name|GUS_PATCH
expr_stmt|;
block|}
return|return
literal|0
return|;
break|break;
case|case
name|PM_READ_PATCH
case|:
comment|/* Returns a block of wave data from the DRAM */
block|{
name|int
name|sample
init|=
name|rec
operator|->
name|parm1
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|offs
init|=
name|rec
operator|->
name|parm2
decl_stmt|;
name|int
name|l
init|=
name|rec
operator|->
name|parm3
decl_stmt|;
if|if
condition|(
name|sample
operator|<
literal|0
operator|||
name|sample
operator|>=
name|free_sample
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|offs
operator|<
literal|0
operator|||
name|offs
operator|>=
name|samples
index|[
name|sample
index|]
operator|.
name|len
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* Invalid offset */
name|n
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|len
operator|-
name|offs
expr_stmt|;
comment|/* Num of bytes left */
if|if
condition|(
name|l
operator|>
name|n
condition|)
name|l
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|)
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<=
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* 					 * Was there a bug? 					 */
name|offs
operator|+=
name|sample_ptrs
index|[
name|sample
index|]
expr_stmt|;
comment|/* 					 * Begin offsess + offset to DRAM 					 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|l
condition|;
name|n
operator|++
control|)
name|rec
operator|->
name|data
operator|.
name|data8
index|[
name|n
index|]
operator|=
name|gus_peek
argument_list|(
name|offs
operator|++
argument_list|)
expr_stmt|;
name|rec
operator|->
name|parm1
operator|=
name|n
expr_stmt|;
comment|/* 				 * Nr of bytes copied 				 */
block|}
return|return
literal|0
return|;
break|break;
case|case
name|PM_WRITE_PATCH
case|:
comment|/* 				 * Writes a block of wave data to the DRAM 				 */
block|{
name|int
name|sample
init|=
name|rec
operator|->
name|parm1
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|offs
init|=
name|rec
operator|->
name|parm2
decl_stmt|;
name|int
name|l
init|=
name|rec
operator|->
name|parm3
decl_stmt|;
if|if
condition|(
name|sample
operator|<
literal|0
operator|||
name|sample
operator|>=
name|free_sample
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|offs
operator|<
literal|0
operator|||
name|offs
operator|>=
name|samples
index|[
name|sample
index|]
operator|.
name|len
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* 					 * Invalid offset 					 */
name|n
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|len
operator|-
name|offs
expr_stmt|;
comment|/* 						   * Nr of bytes left 						 */
if|if
condition|(
name|l
operator|>
name|n
condition|)
name|l
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|)
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<=
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* 					 * Was there a bug? 					 */
name|offs
operator|+=
name|sample_ptrs
index|[
name|sample
index|]
expr_stmt|;
comment|/* 					 * Begin offsess + offset to DRAM 					 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|l
condition|;
name|n
operator|++
control|)
name|gus_poke
argument_list|(
name|offs
operator|++
argument_list|,
name|rec
operator|->
name|data
operator|.
name|data8
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|rec
operator|->
name|parm1
operator|=
name|n
expr_stmt|;
comment|/* 				 * Nr of bytes copied 				 */
block|}
return|return
literal|0
return|;
break|break;
default|default:
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_alloc
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|,
name|struct
name|voice_alloc_info
modifier|*
name|alloc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|p
decl_stmt|,
name|best
init|=
operator|-
literal|1
decl_stmt|,
name|best_time
init|=
literal|0x7fffffff
decl_stmt|;
name|p
operator|=
name|alloc
operator|->
name|ptr
expr_stmt|;
comment|/*      * First look for a completely stopped voice    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alloc
operator|->
name|max_voice
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alloc
operator|->
name|map
index|[
name|p
index|]
operator|==
literal|0
condition|)
block|{
name|alloc
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
if|if
condition|(
name|alloc
operator|->
name|alloc_times
index|[
name|p
index|]
operator|<
name|best_time
condition|)
block|{
name|best
operator|=
name|p
expr_stmt|;
name|best_time
operator|=
name|alloc
operator|->
name|alloc_times
index|[
name|p
index|]
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
operator|%
name|alloc
operator|->
name|max_voice
expr_stmt|;
block|}
comment|/*      * Then look for a releasing voice    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alloc
operator|->
name|max_voice
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alloc
operator|->
name|map
index|[
name|p
index|]
operator|==
literal|0xffff
condition|)
block|{
name|alloc
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
name|p
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
operator|%
name|alloc
operator|->
name|max_voice
expr_stmt|;
block|}
if|if
condition|(
name|best
operator|>=
literal|0
condition|)
name|p
operator|=
name|best
expr_stmt|;
name|alloc
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|synth_operations
name|guswave_operations
init|=
block|{
operator|&
name|gus_info
block|,
literal|0
block|,
name|SYNTH_TYPE_SAMPLE
block|,
name|SAMPLE_TYPE_GUS
block|,
name|guswave_open
block|,
name|guswave_close
block|,
name|guswave_ioctl
block|,
name|guswave_kill_note
block|,
name|guswave_start_note
block|,
name|guswave_set_instr
block|,
name|guswave_reset
block|,
name|guswave_hw_control
block|,
name|guswave_load_patch
block|,
name|guswave_aftertouch
block|,
name|guswave_controller
block|,
name|guswave_panning
block|,
name|guswave_volume_method
block|,
name|guswave_patchmgr
block|,
name|guswave_bender
block|,
name|guswave_alloc
block|,
name|guswave_setup_voice
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_input_volumes
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|mask
init|=
literal|0xff
operator|&
operator|~
literal|0x06
decl_stmt|;
comment|/* Just line out enabled */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/*      *    Enable channels having vol> 10%      *      Note! bit 0x01 means line in DISABLED while 0x04 means      *            mic in ENABLED.    */
if|if
condition|(
name|gus_line_vol
operator|>
literal|10
condition|)
name|mask
operator|&=
operator|~
literal|0x01
expr_stmt|;
if|if
condition|(
name|gus_mic_vol
operator|>
literal|10
condition|)
name|mask
operator||=
literal|0x04
expr_stmt|;
if|if
condition|(
name|recording_active
condition|)
block|{
comment|/*          *    Disable channel, if not selected for recording        */
if|if
condition|(
operator|!
operator|(
name|gus_recmask
operator|&
name|SOUND_MASK_LINE
operator|)
condition|)
name|mask
operator||=
literal|0x01
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gus_recmask
operator|&
name|SOUND_MASK_MIC
operator|)
condition|)
name|mask
operator|&=
operator|~
literal|0x04
expr_stmt|;
block|}
name|mix_image
operator|&=
operator|~
literal|0x07
expr_stmt|;
name|mix_image
operator||=
name|mask
operator|&
literal|0x07
expr_stmt|;
name|OUTB
argument_list|(
name|mix_image
argument_list|,
name|u_Mixer
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gus_default_mixer_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|arg
parameter_list|)
block|{
define|#
directive|define
name|MIX_DEVS
value|(SOUND_MASK_MIC|SOUND_MASK_LINE| \ 			 SOUND_MASK_SYNTH|SOUND_MASK_PCM)
if|if
condition|(
operator|(
operator|(
name|cmd
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|==
literal|'M'
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|IOC_IN
condition|)
switch|switch
condition|(
name|cmd
operator|&
literal|0xff
condition|)
block|{
case|case
name|SOUND_MIXER_RECSRC
case|:
name|gus_recmask
operator|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
operator|&
name|MIX_DEVS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|gus_recmask
operator|&
operator|(
name|SOUND_MASK_MIC
operator||
name|SOUND_MASK_LINE
operator|)
operator|)
condition|)
name|gus_recmask
operator|=
name|SOUND_MASK_MIC
expr_stmt|;
comment|/* Note! Input volumes are updated during next open for recording */
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_recmask
argument_list|)
return|;
break|break;
case|case
name|SOUND_MIXER_MIC
case|:
block|{
name|int
name|vol
init|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|vol
operator|<
literal|0
condition|)
name|vol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vol
operator|>
literal|100
condition|)
name|vol
operator|=
literal|100
expr_stmt|;
name|gus_mic_vol
operator|=
name|vol
expr_stmt|;
name|set_input_volumes
argument_list|()
expr_stmt|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|vol
operator||
operator|(
name|vol
operator|<<
literal|8
operator|)
argument_list|)
return|;
block|}
break|break;
case|case
name|SOUND_MIXER_LINE
case|:
block|{
name|int
name|vol
init|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
operator|&
literal|0xff
decl_stmt|;
if|if
condition|(
name|vol
operator|<
literal|0
condition|)
name|vol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vol
operator|>
literal|100
condition|)
name|vol
operator|=
literal|100
expr_stmt|;
name|gus_line_vol
operator|=
name|vol
expr_stmt|;
name|set_input_volumes
argument_list|()
expr_stmt|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|vol
operator||
operator|(
name|vol
operator|<<
literal|8
operator|)
argument_list|)
return|;
block|}
break|break;
case|case
name|SOUND_MIXER_PCM
case|:
name|gus_pcm_volume
operator|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|gus_pcm_volume
operator|<
literal|0
condition|)
name|gus_pcm_volume
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gus_pcm_volume
operator|>
literal|100
condition|)
name|gus_pcm_volume
operator|=
literal|100
expr_stmt|;
name|gus_sampling_update_volume
argument_list|()
expr_stmt|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_pcm_volume
operator||
operator|(
name|gus_pcm_volume
operator|<<
literal|8
operator|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_MIXER_SYNTH
case|:
block|{
name|int
name|voice
decl_stmt|;
name|gus_wave_volume
operator|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|gus_wave_volume
operator|<
literal|0
condition|)
name|gus_wave_volume
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gus_wave_volume
operator|>
literal|100
condition|)
name|gus_wave_volume
operator|=
literal|100
expr_stmt|;
if|if
condition|(
name|active_device
operator|==
name|GUS_DEV_WAVE
condition|)
for|for
control|(
name|voice
operator|=
literal|0
init|;
name|voice
operator|<
name|nr_voices
condition|;
name|voice
operator|++
control|)
name|dynamic_volume_change
argument_list|(
name|voice
argument_list|)
expr_stmt|;
comment|/* Apply the new vol */
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_wave_volume
operator||
operator|(
name|gus_wave_volume
operator|<<
literal|8
operator|)
argument_list|)
return|;
block|}
break|break;
default|default:
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
else|else
switch|switch
condition|(
name|cmd
operator|&
literal|0xff
condition|)
comment|/* 				 * Return parameters 				 */
block|{
case|case
name|SOUND_MIXER_RECSRC
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_recmask
argument_list|)
return|;
break|break;
case|case
name|SOUND_MIXER_DEVMASK
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|MIX_DEVS
argument_list|)
return|;
break|break;
case|case
name|SOUND_MIXER_STEREODEVS
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|SOUND_MIXER_RECMASK
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|SOUND_MASK_MIC
operator||
name|SOUND_MASK_LINE
argument_list|)
return|;
break|break;
case|case
name|SOUND_MIXER_CAPS
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
return|;
break|break;
case|case
name|SOUND_MIXER_MIC
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_mic_vol
operator||
operator|(
name|gus_mic_vol
operator|<<
literal|8
operator|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_MIXER_LINE
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_line_vol
operator||
operator|(
name|gus_line_vol
operator|<<
literal|8
operator|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_MIXER_PCM
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_pcm_volume
operator||
operator|(
name|gus_pcm_volume
operator|<<
literal|8
operator|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_MIXER_SYNTH
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_wave_volume
operator||
operator|(
name|gus_wave_volume
operator|<<
literal|8
operator|)
argument_list|)
return|;
break|break;
default|default:
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
else|else
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mixer_operations
name|gus_mixer_operations
init|=
block|{
literal|"Gravis Ultrasound"
block|,
name|gus_default_mixer_ioctl
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|long
name|gus_default_mixer_init
parameter_list|(
name|long
name|mem_start
parameter_list|)
block|{
if|if
condition|(
name|num_mixers
operator|<
name|MAX_MIXER_DEV
condition|)
comment|/* 					 * Don't install if there is another 					 * mixer 					 */
name|mixer_devs
index|[
name|num_mixers
operator|++
index|]
operator|=
operator|&
name|gus_mixer_operations
expr_stmt|;
return|return
name|mem_start
return|;
block|}
end_function

begin_function
name|long
name|gus_wave_init
parameter_list|(
name|long
name|mem_start
parameter_list|,
name|int
name|irq
parameter_list|,
name|int
name|dma
parameter_list|,
name|int
name|dma_read
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|;
name|char
modifier|*
name|model_num
init|=
literal|"2.4"
decl_stmt|;
name|int
name|gus_type
init|=
literal|0x24
decl_stmt|;
comment|/* 2.4 */
name|int
name|mixer_type
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|irq
operator|<
literal|0
operator|||
name|irq
operator|>
literal|15
condition|)
block|{
name|printk
argument_list|(
literal|"ERROR! Invalid IRQ#%d. GUS Disabled"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
name|mem_start
return|;
block|}
if|if
condition|(
name|dma
operator|<
literal|0
operator|||
name|dma
operator|>
literal|7
condition|)
block|{
name|printk
argument_list|(
literal|"ERROR! Invalid DMA#%d. GUS Disabled"
argument_list|,
name|dma
argument_list|)
expr_stmt|;
return|return
name|mem_start
return|;
block|}
if|if
condition|(
name|dma_read
operator|==
literal|0
condition|)
name|dma_read
operator|=
name|dma
expr_stmt|;
if|if
condition|(
name|dma_read
operator|<
literal|0
operator|||
name|dma_read
operator|>
literal|7
condition|)
block|{
name|printk
argument_list|(
literal|"ERROR! Invalid DMA#%d. GUS DMA-read disabled"
argument_list|,
name|dma_read
argument_list|)
expr_stmt|;
name|dma_read
operator|=
name|dma
expr_stmt|;
block|}
comment|/*      * Try to identify the GUS model.      *      *  Versions< 3.6 don't have the digital ASIC. Try to probe it first.    */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x20
argument_list|,
name|gus_base
operator|+
literal|0x0f
argument_list|)
expr_stmt|;
name|val
operator|=
name|INB
argument_list|(
name|gus_base
operator|+
literal|0x0f
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0xff
operator|&&
operator|(
name|val
operator|&
literal|0x06
operator|)
condition|)
comment|/* Should be 0x02?? */
block|{
comment|/*          * It has the digital ASIC so the card is at least v3.4.          * Next try to detect the true model.        */
name|val
operator|=
name|INB
argument_list|(
name|u_MixSelect
argument_list|)
expr_stmt|;
comment|/*          * Value 255 means pre-3.7 which don't have mixer.          * Values 5 thru 9 mean v3.7 which has a ICS2101 mixer.          * 10 and above is GUS MAX which has the CS4231 codec/mixer.          *          * Sorry. No GUS max support yet but it should be available          * soon after the SDK for GUS MAX is available.        */
if|if
condition|(
name|val
operator|==
literal|255
operator|||
name|val
operator|<
literal|5
condition|)
block|{
name|model_num
operator|=
literal|"3.4"
expr_stmt|;
name|gus_type
operator|=
literal|0x34
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|<
literal|10
condition|)
block|{
name|model_num
operator|=
literal|"3.7"
expr_stmt|;
name|gus_type
operator|=
literal|0x37
expr_stmt|;
name|mixer_type
operator|=
name|ICS2101
expr_stmt|;
block|}
else|else
block|{
name|model_num
operator|=
literal|"MAX"
expr_stmt|;
name|gus_type
operator|=
literal|0x40
expr_stmt|;
name|mixer_type
operator|=
name|CS4231
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*          * ASIC not detected so the card must be 2.2 or 2.4.          * There could still be the 16-bit/mixer daughter card.          * It has the same codec/mixer than MAX.          * At this time there is no support for it but it will appear soon.        */
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|printk
argument_list|(
literal|"gus0:<Gravis UltraSound %s (%dk)>"
argument_list|,
name|model_num
argument_list|,
operator|(
name|int
operator|)
name|gus_mem_size
operator|/
literal|1024
argument_list|)
expr_stmt|;
else|#
directive|else
name|printk
argument_list|(
literal|"<Gravis UltraSound %s (%dk)>"
argument_list|,
name|model_num
argument_list|,
operator|(
name|int
operator|)
name|gus_mem_size
operator|/
literal|1024
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sprintf
argument_list|(
name|gus_info
operator|.
name|name
argument_list|,
literal|"Gravis UltraSound %s (%dk)"
argument_list|,
name|model_num
argument_list|,
operator|(
name|int
operator|)
name|gus_mem_size
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|gus_irq
operator|=
name|irq
expr_stmt|;
name|gus_dma
operator|=
name|dma
expr_stmt|;
name|gus_dma_read
operator|=
name|dma_read
expr_stmt|;
if|if
condition|(
name|num_synths
operator|>=
name|MAX_SYNTH_DEV
condition|)
name|printk
argument_list|(
literal|"GUS Error: Too many synthesizers\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|voice_alloc
operator|=
operator|&
name|guswave_operations
operator|.
name|alloc
expr_stmt|;
name|synth_devs
index|[
name|num_synths
operator|++
index|]
operator|=
operator|&
name|guswave_operations
expr_stmt|;
block|}
name|PERMANENT_MALLOC
argument_list|(
expr|struct
name|patch_info
operator|*
argument_list|,
name|samples
argument_list|,
operator|(
name|MAX_SAMPLE
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|samples
argument_list|)
argument_list|,
name|mem_start
argument_list|)
expr_stmt|;
name|reset_sample_memory
argument_list|()
expr_stmt|;
name|gus_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_audiodevs
operator|<
name|MAX_AUDIO_DEV
condition|)
block|{
name|audio_devs
index|[
name|gus_devnum
operator|=
name|num_audiodevs
operator|++
index|]
operator|=
operator|&
name|gus_sampling_operations
expr_stmt|;
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|dmachan
operator|=
name|dma
expr_stmt|;
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|buffcount
operator|=
literal|1
expr_stmt|;
name|audio_devs
index|[
name|gus_devnum
index|]
operator|->
name|buffsize
operator|=
name|DSP_BUFFSIZE
expr_stmt|;
name|gus_dspnum
operator|=
name|gus_devnum
expr_stmt|;
name|gus_busy
index|[
name|gus_devnum
index|]
operator|=
literal|0
expr_stmt|;
name|gus_busy
index|[
name|gus_dspnum
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|printk
argument_list|(
literal|"GUS: Too many PCM devices available\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_audiodevs
operator|<
name|MAX_AUDIO_DEV
condition|)
block|{
if|if
condition|(
name|dma_read
operator|&&
name|dma
operator|!=
name|dma_read
condition|)
block|{
name|audio_devs
index|[
name|gus_dspnum
operator|=
name|num_audiodevs
operator|++
index|]
operator|=
operator|&
name|gus_sampling_operations_read
expr_stmt|;
name|audio_devs
index|[
name|gus_dspnum
index|]
operator|->
name|dmachan
operator|=
name|gus_dma_read
expr_stmt|;
name|audio_devs
index|[
name|gus_dspnum
index|]
operator|->
name|buffcount
operator|=
literal|1
expr_stmt|;
name|audio_devs
index|[
name|gus_dspnum
index|]
operator|->
name|buffsize
operator|=
name|DSP_BUFFSIZE
expr_stmt|;
name|gus_busy
index|[
name|gus_dspnum
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|gus_dspnum
operator|=
name|gus_devnum
expr_stmt|;
block|}
block|}
else|else
name|printk
argument_list|(
literal|"GUS READ: Too many PCM devices available\n"
argument_list|)
expr_stmt|;
comment|/*      *  Mixer dependent initialization.    */
switch|switch
condition|(
name|mixer_type
condition|)
block|{
case|case
name|ICS2101
case|:
name|gus_mic_vol
operator|=
name|gus_line_vol
operator|=
name|gus_pcm_volume
operator|=
literal|100
expr_stmt|;
name|gus_wave_volume
operator|=
literal|90
expr_stmt|;
return|return
name|ics2101_mixer_init
argument_list|(
name|mem_start
argument_list|)
return|;
case|case
name|CS4231
case|:
comment|/* Initialized elsewhere (ad1848.c) */
ifndef|#
directive|ifndef
name|EXCLUDE_GUSMAX
block|{
name|unsigned
name|char
name|max_config
init|=
literal|0x40
decl_stmt|;
comment|/* Codec enable */
name|long
name|mixer_init_return
decl_stmt|;
if|if
condition|(
name|dma
operator|>
literal|3
condition|)
name|max_config
operator||=
literal|0x30
expr_stmt|;
comment|/* 16 bit playback and capture DMAs */
name|max_config
operator||=
operator|(
name|gus_base
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
expr_stmt|;
comment|/* Extract the X from 2X0 */
name|OUTB
argument_list|(
name|max_config
argument_list|,
name|gus_base
operator|+
literal|0x106
argument_list|)
expr_stmt|;
comment|/* UltraMax control */
name|mixer_init_return
operator|=
name|gus_default_mixer_init
argument_list|(
name|mem_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|ad1848_detect
argument_list|(
name|gus_base
operator|+
literal|0x10c
argument_list|)
condition|)
block|{
name|gus_mic_vol
operator|=
name|gus_line_vol
operator|=
name|gus_pcm_volume
operator|=
literal|100
expr_stmt|;
name|gus_wave_volume
operator|=
literal|90
expr_stmt|;
name|have_gus_max
operator|=
literal|1
expr_stmt|;
name|ad1848_init
argument_list|(
literal|"GUS MAX"
argument_list|,
name|gus_base
operator|+
literal|0x10c
argument_list|,
operator|-
name|irq
argument_list|,
name|dma_read
argument_list|,
comment|/* read write reversed */
name|dma
argument_list|)
expr_stmt|;
block|}
else|else
name|printk
argument_list|(
literal|"[Where's the CS4231?]"
argument_list|)
expr_stmt|;
return|return
name|mixer_init_return
return|;
block|}
endif|#
directive|endif
default|default:
return|return
name|gus_default_mixer_init
argument_list|(
name|mem_start
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_loop_irq
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|unsigned
name|char
name|tmp
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|parm
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* 				 * Disable wave IRQ for this_one voice 				 */
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
literal|0x03
condition|)
comment|/* Voice stopped */
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
operator|=
literal|0
expr_stmt|;
name|parm
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_parm
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|LMODE_FINISH
case|:
comment|/* 				 * Final loop finished, shoot volume down 				 */
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
argument_list|)
operator|<
literal|100
condition|)
comment|/* 							 * Get current volume 							 */
block|{
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_init
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
block|}
name|gus_ramp_range
argument_list|(
literal|65
argument_list|,
literal|4065
argument_list|)
expr_stmt|;
name|gus_ramp_rate
argument_list|(
literal|0
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/* 				 * Fastest possible rate 				 */
name|gus_rampon
argument_list|(
literal|0x20
operator||
literal|0x40
argument_list|)
expr_stmt|;
comment|/* 				 * Ramp down, once, irq 				 */
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
name|VMODE_HALT
expr_stmt|;
break|break;
case|case
name|LMODE_PCM_STOP
case|:
name|pcm_active
operator|=
literal|0
expr_stmt|;
comment|/* Signal to the play_next_pcm_block routine */
case|case
name|LMODE_PCM
case|:
block|{
name|int
name|flag
decl_stmt|;
comment|/* 0 or 2 */
name|pcm_qlen
operator|--
expr_stmt|;
name|pcm_head
operator|=
operator|(
name|pcm_head
operator|+
literal|1
operator|)
operator|%
name|pcm_nblk
expr_stmt|;
if|if
condition|(
name|pcm_qlen
operator|&&
name|pcm_active
condition|)
block|{
name|play_next_pcm_block
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Underrun. Just stop the voice */
name|gus_select_voice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Left channel */
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_select_voice
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Right channel */
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|pcm_active
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	   * If the queue was full before this interrupt, the DMA transfer was 	   * suspended. Let it continue now. 	 */
if|if
condition|(
name|dma_active
condition|)
block|{
if|if
condition|(
name|pcm_qlen
operator|==
literal|0
condition|)
name|flag
operator|=
literal|1
expr_stmt|;
comment|/* Underflow */
else|else
name|flag
operator|=
literal|0
expr_stmt|;
name|dma_active
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|flag
operator|=
literal|2
expr_stmt|;
comment|/* Just notify the dmabuf.c */
name|DMAbuf_outputintr
argument_list|(
name|gus_devnum
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_volume_irq
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|unsigned
name|char
name|tmp
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|parm
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gus_read8
argument_list|(
literal|0x0d
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* 				 * Disable volume ramp IRQ 				 */
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|mode
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
literal|0
expr_stmt|;
name|parm
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_parm
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|VMODE_HALT
case|:
comment|/* 				 * Decay phase finished 				 */
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_voice_init
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMODE_ENVELOPE
case|:
name|gus_rampoff
argument_list|()
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|step_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMODE_START_NOTE
case|:
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|guswave_start_note2
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|dev_pending
argument_list|,
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|note_pending
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|volume_pending
argument_list|)
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|kill_pending
condition|)
name|guswave_kill_note
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|dev_pending
argument_list|,
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|note_pending
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
operator|>=
literal|0
condition|)
block|{
name|guswave_set_instr
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|dev_pending
argument_list|,
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|sample_pending
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|gus_voice_irq
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|wave_ignore
init|=
literal|0
decl_stmt|,
name|volume_ignore
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|voice_bit
decl_stmt|;
name|unsigned
name|char
name|src
decl_stmt|,
name|voice
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|src
operator|=
name|gus_read8
argument_list|(
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* 				 * Get source info 				 */
name|voice
operator|=
name|src
operator|&
literal|0x1f
expr_stmt|;
name|src
operator|&=
literal|0xc0
expr_stmt|;
if|if
condition|(
name|src
operator|==
operator|(
literal|0x80
operator||
literal|0x40
operator|)
condition|)
return|return;
comment|/* 				 * No interrupt 				 */
name|voice_bit
operator|=
literal|1
operator|<<
name|voice
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|src
operator|&
literal|0x80
operator|)
condition|)
comment|/* 				 * Wave IRQ pending 				 */
if|if
condition|(
operator|!
operator|(
name|wave_ignore
operator|&
name|voice_bit
operator|)
operator|&&
operator|(
name|int
operator|)
name|voice
operator|<
name|nr_voices
condition|)
comment|/* 									   * Not done 									   * yet 									 */
block|{
name|wave_ignore
operator||=
name|voice_bit
expr_stmt|;
name|do_loop_irq
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|src
operator|&
literal|0x40
operator|)
condition|)
comment|/* 				 * Volume IRQ pending 				 */
if|if
condition|(
operator|!
operator|(
name|volume_ignore
operator|&
name|voice_bit
operator|)
operator|&&
operator|(
name|int
operator|)
name|voice
operator|<
name|nr_voices
condition|)
comment|/* 									   * Not done 									   * yet 									 */
block|{
name|volume_ignore
operator||=
name|voice_bit
expr_stmt|;
name|do_volume_irq
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|guswave_dma_irq
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|status
decl_stmt|;
name|status
operator|=
name|gus_look8
argument_list|(
literal|0x41
argument_list|)
expr_stmt|;
comment|/* Get DMA IRQ Status */
if|if
condition|(
name|status
operator|&
literal|0x40
condition|)
comment|/* DMA interrupt pending */
switch|switch
condition|(
name|active_device
condition|)
block|{
case|case
name|GUS_DEV_WAVE
case|:
if|if
condition|(
name|SOMEONE_WAITING
argument_list|(
name|dram_sleeper
argument_list|,
name|dram_sleep_flag
argument_list|)
condition|)
name|WAKE_UP
argument_list|(
name|dram_sleeper
argument_list|,
name|dram_sleep_flag
argument_list|)
expr_stmt|;
break|break;
case|case
name|GUS_DEV_PCM_CONTINUE
case|:
comment|/* Left channel data transferred */
name|gus_transfer_output_block
argument_list|(
name|pcm_current_dev
argument_list|,
name|pcm_current_buf
argument_list|,
name|pcm_current_count
argument_list|,
name|pcm_current_intrflag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GUS_DEV_PCM_DONE
case|:
comment|/* Right or mono channel data transferred */
if|if
condition|(
name|pcm_qlen
operator|<
name|pcm_nblk
condition|)
block|{
name|int
name|flag
init|=
operator|(
literal|1
operator|-
name|dma_active
operator|)
operator|*
literal|2
decl_stmt|;
comment|/* 0 or 2 */
if|if
condition|(
name|pcm_qlen
operator|==
literal|0
condition|)
name|flag
operator|=
literal|1
expr_stmt|;
comment|/* Underrun */
name|dma_active
operator|=
literal|0
expr_stmt|;
name|DMAbuf_outputintr
argument_list|(
name|gus_devnum
argument_list|,
name|flag
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
name|status
operator|=
name|gus_look8
argument_list|(
literal|0x49
argument_list|)
expr_stmt|;
comment|/* 				 * Get Sampling IRQ Status 				 */
if|if
condition|(
name|status
operator|&
literal|0x40
condition|)
comment|/* 				 * Sampling Irq pending 				 */
block|{
if|if
condition|(
name|gus_dma_read
operator|&&
name|gus_dma_read
operator|!=
name|gus_dma
condition|)
name|DMAbuf_inputintr
argument_list|(
name|gus_dspnum
argument_list|)
expr_stmt|;
else|else
name|DMAbuf_inputintr
argument_list|(
name|gus_devnum
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

