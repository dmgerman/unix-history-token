begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * linux/kernel/chr_drv/sound/gus_wave.c  *   * Driver for the Gravis UltraSound wave table synth.  *   * Copyright by Hannu Savolainen 1993  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   */
end_comment

begin_comment
comment|/* #define GUS_LINEAR_VOLUME	 */
end_comment

begin_include
include|#
directive|include
file|"sound_config.h"
end_include

begin_include
include|#
directive|include
file|"ultrasound.h"
end_include

begin_include
include|#
directive|include
file|"gus_hw.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIGURE_SOUNDCARD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EXCLUDE_GUS
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAX_SAMPLE
value|256
end_define

begin_define
define|#
directive|define
name|MAX_PATCH
value|256
end_define

begin_struct
struct|struct
name|voice_info
block|{
name|unsigned
name|long
name|orig_freq
decl_stmt|;
name|unsigned
name|long
name|current_freq
decl_stmt|;
name|unsigned
name|long
name|mode
decl_stmt|;
name|int
name|bender
decl_stmt|;
name|int
name|bender_range
decl_stmt|;
name|int
name|panning
decl_stmt|;
name|int
name|midi_volume
decl_stmt|;
name|unsigned
name|int
name|initial_volume
decl_stmt|;
name|unsigned
name|int
name|current_volume
decl_stmt|;
name|int
name|loop_irq_mode
decl_stmt|,
name|loop_irq_parm
decl_stmt|;
define|#
directive|define
name|LMODE_FINISH
value|1
define|#
directive|define
name|LMODE_PCM
value|2
define|#
directive|define
name|LMODE_PCM_STOP
value|3
name|int
name|volume_irq_mode
decl_stmt|,
name|volume_irq_parm
decl_stmt|;
define|#
directive|define
name|VMODE_HALT
value|1
define|#
directive|define
name|VMODE_ENVELOPE
value|2
name|int
name|env_phase
decl_stmt|;
name|unsigned
name|char
name|env_rate
index|[
literal|6
index|]
decl_stmt|;
name|unsigned
name|char
name|env_offset
index|[
literal|6
index|]
decl_stmt|;
comment|/*      * Volume computation parameters for gus_adagio_vol()      */
name|int
name|main_vol
decl_stmt|,
name|expression_vol
decl_stmt|,
name|patch_vol
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|int
name|gus_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|gus_irq
decl_stmt|,
name|gus_dma
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|snd_raw_buf
index|[
name|MAX_DSP_DEV
index|]
index|[
name|DSP_BUFFCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|snd_raw_buf_phys
index|[
name|MAX_DSP_DEV
index|]
index|[
name|DSP_BUFFCOUNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|snd_raw_count
index|[
name|MAX_DSP_DEV
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|gus_mem_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|free_mem_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_busy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nr_voices
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of currently allowed voices */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gus_devnum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|volume_base
decl_stmt|,
name|volume_scale
decl_stmt|,
name|volume_method
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VOL_METHOD_ADAGIO
value|1
end_define

begin_decl_stmt
name|int
name|gus_wave_volume
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Master wolume for wave (0 to 100) */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|mix_image
init|=
literal|0x00
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Current version of this_one driver doesn't allow synth and PCM functions  * at the same time. The active_device specifies the active driver  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|active_device
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GUS_DEV_WAVE
value|1
end_define

begin_comment
comment|/* Wave table synth */
end_comment

begin_define
define|#
directive|define
name|GUS_DEV_PCM_DONE
value|2
end_define

begin_comment
comment|/* PCM device, transfer done */
end_comment

begin_define
define|#
directive|define
name|GUS_DEV_PCM_CONTINUE
value|3
end_define

begin_comment
comment|/* PCM device, transfer the second 					 * chn */
end_comment

begin_decl_stmt
specifier|static
name|int
name|gus_sampling_speed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_sampling_channels
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gus_sampling_bits
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_WAIT_QUEUE
argument_list|(
name|dram_sleeper
argument_list|,
name|dram_sleep_flag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Variables and buffers for PCM output  */
end_comment

begin_define
define|#
directive|define
name|MAX_PCM_BUFFERS
value|32
end_define

begin_comment
comment|/* Don't change */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pcm_bsize
decl_stmt|,
comment|/* Current blocksize */
name|pcm_nblk
decl_stmt|,
comment|/* Current # of blocks */
name|pcm_banksize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # bytes allocated for channels */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pcm_datasize
index|[
name|MAX_PCM_BUFFERS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Actual # of bytes in blk */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|pcm_head
decl_stmt|,
name|pcm_tail
decl_stmt|,
name|pcm_qlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DRAM queue */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|pcm_active
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_current_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_current_block
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|pcm_current_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_current_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pcm_current_intrflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|voice_info
name|voices
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|freq_div_table
index|[]
init|=
block|{
literal|44100
block|,
comment|/* 14 */
literal|41160
block|,
comment|/* 15 */
literal|38587
block|,
comment|/* 16 */
literal|36317
block|,
comment|/* 17 */
literal|34300
block|,
comment|/* 18 */
literal|32494
block|,
comment|/* 19 */
literal|30870
block|,
comment|/* 20 */
literal|29400
block|,
comment|/* 21 */
literal|28063
block|,
comment|/* 22 */
literal|26843
block|,
comment|/* 23 */
literal|25725
block|,
comment|/* 24 */
literal|24696
block|,
comment|/* 25 */
literal|23746
block|,
comment|/* 26 */
literal|22866
block|,
comment|/* 27 */
literal|22050
block|,
comment|/* 28 */
literal|21289
block|,
comment|/* 29 */
literal|20580
block|,
comment|/* 30 */
literal|19916
block|,
comment|/* 31 */
literal|19293
comment|/* 32 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|patch_info
name|samples
index|[
name|MAX_SAMPLE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|sample_ptrs
index|[
name|MAX_SAMPLE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sample_map
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|free_sample
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|patch_table
index|[
name|MAX_PATCH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|patch_map
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|synth_info
name|gus_info
init|=
block|{
literal|"Gravis UltraSound"
block|,
literal|0
block|,
name|SYNTH_TYPE_SAMPLE
block|,
name|SAMPLE_TYPE_GUS
block|,
literal|0
block|,
literal|16
block|,
literal|0
block|,
name|MAX_PATCH
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|gus_poke
parameter_list|(
name|long
name|addr
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_and_set_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|,
name|int
name|ramp_time
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|unsigned
name|short
name|gus_adagio_vol
parameter_list|(
name|int
name|vel
parameter_list|,
name|int
name|mainv
parameter_list|,
name|int
name|xpn
parameter_list|,
name|int
name|voicev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compute_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|INSTANT_RAMP
value|-1
end_define

begin_comment
comment|/* Dont use ramping */
end_comment

begin_define
define|#
directive|define
name|FAST_RAMP
value|0
end_define

begin_comment
comment|/* Fastest possible ramp */
end_comment

begin_function
specifier|static
name|void
name|reset_sample_memory
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_SAMPLE
condition|;
name|i
operator|++
control|)
name|sample_ptrs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|sample_map
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|patch_map
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|gus_poke
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put silence here */
name|gus_poke
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_mem_ptr
operator|=
literal|2
expr_stmt|;
name|free_sample
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PATCH
condition|;
name|i
operator|++
control|)
name|patch_table
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gus_delay
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|INB
argument_list|(
name|u_DRAMIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_poke
parameter_list|(
name|long
name|addr
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x43
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|addr
operator|&
literal|0xff
argument_list|,
name|u_DataLo
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|u_DataHi
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x44
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
name|u_DataHi
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|data
argument_list|,
name|u_DRAMIO
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
name|gus_peek
parameter_list|(
name|long
name|addr
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|tmp
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x43
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|addr
operator|&
literal|0xff
argument_list|,
name|u_DataLo
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
operator|(
name|addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|u_DataHi
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x44
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
operator|(
name|addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
name|u_DataHi
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|INB
argument_list|(
name|u_DRAMIO
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
name|void
name|gus_write8
parameter_list|(
name|int
name|reg
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|reg
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|data
argument_list|,
name|u_DataHi
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|char
name|gus_read8
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|reg
operator||
literal|0x80
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|val
operator|=
name|INB
argument_list|(
name|u_DataHi
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|unsigned
name|char
name|gus_look8
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|val
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|reg
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|val
operator|=
name|INB
argument_list|(
name|u_DataHi
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|void
name|gus_write16
parameter_list|(
name|int
name|reg
parameter_list|,
name|unsigned
name|short
name|data
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|reg
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|data
operator|&
literal|0xff
argument_list|,
name|u_DataLo
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
operator|(
name|data
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|u_DataHi
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|short
name|gus_read16
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
name|reg
operator||
literal|0x80
argument_list|,
name|u_Command
argument_list|)
expr_stmt|;
name|lo
operator|=
name|INB
argument_list|(
name|u_DataLo
argument_list|)
expr_stmt|;
name|hi
operator|=
name|INB
argument_list|(
name|u_DataHi
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|hi
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
operator||
name|lo
return|;
block|}
end_function

begin_function
name|void
name|gus_write_addr
parameter_list|(
name|int
name|reg
parameter_list|,
name|unsigned
name|long
name|address
parameter_list|,
name|int
name|is16bit
parameter_list|)
block|{
name|unsigned
name|long
name|hold_address
decl_stmt|;
if|if
condition|(
name|is16bit
condition|)
block|{
comment|/*        * Special processing required for 16 bit patches        */
name|hold_address
operator|=
name|address
expr_stmt|;
name|address
operator|=
name|address
operator|>>
literal|1
expr_stmt|;
name|address
operator|&=
literal|0x0001ffffL
expr_stmt|;
name|address
operator||=
operator|(
name|hold_address
operator|&
literal|0x000c0000L
operator|)
expr_stmt|;
block|}
name|gus_write16
argument_list|(
name|reg
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
name|address
operator|>>
literal|7
operator|)
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
name|gus_write16
argument_list|(
name|reg
operator|+
literal|1
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
name|address
operator|<<
literal|9
operator|)
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_select_voice
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>
literal|31
condition|)
return|return;
name|OUTB
argument_list|(
name|voice
argument_list|,
name|u_Voice
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_select_max_voices
parameter_list|(
name|int
name|nvoices
parameter_list|)
block|{
if|if
condition|(
name|nvoices
operator|<
literal|14
condition|)
name|nvoices
operator|=
literal|14
expr_stmt|;
if|if
condition|(
name|nvoices
operator|>
literal|32
condition|)
name|nvoices
operator|=
literal|32
expr_stmt|;
name|nr_voices
operator|=
name|nvoices
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x0e
argument_list|,
operator|(
name|nvoices
operator|-
literal|1
operator|)
operator||
literal|0xc0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_on
parameter_list|(
name|unsigned
name|char
name|mode
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
name|mode
operator|&
literal|0xfc
argument_list|)
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
name|mode
operator|&
literal|0xfc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_off
parameter_list|(
name|void
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
operator||
literal|0x03
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_mode
parameter_list|(
name|unsigned
name|char
name|mode
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
operator|(
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
operator|&
literal|0x03
operator|)
operator||
operator|(
name|mode
operator|&
literal|0xfc
operator|)
argument_list|)
expr_stmt|;
comment|/* Don't start or stop 								 * voice */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
operator|(
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
operator|&
literal|0x03
operator|)
operator||
operator|(
name|mode
operator|&
literal|0xfc
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_freq
parameter_list|(
name|unsigned
name|long
name|freq
parameter_list|)
block|{
name|unsigned
name|long
name|divisor
init|=
name|freq_div_table
index|[
name|nr_voices
operator|-
literal|14
index|]
decl_stmt|;
name|unsigned
name|short
name|fc
decl_stmt|;
name|fc
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
operator|(
operator|(
name|freq
operator|<<
literal|9
operator|)
operator|+
operator|(
name|divisor
operator|>>
literal|1
operator|)
operator|)
operator|/
name|divisor
argument_list|)
expr_stmt|;
name|fc
operator|=
name|fc
operator|<<
literal|1
expr_stmt|;
name|gus_write16
argument_list|(
literal|0x01
argument_list|,
name|fc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_volume
parameter_list|(
name|unsigned
name|short
name|vol
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Stop ramp before setting volume */
name|gus_write16
argument_list|(
literal|0x09
argument_list|,
name|vol
operator|<<
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_balance
parameter_list|(
name|unsigned
name|char
name|balance
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x0c
argument_list|,
name|balance
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_ramp_range
parameter_list|(
name|unsigned
name|short
name|low
parameter_list|,
name|unsigned
name|short
name|high
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x07
argument_list|,
operator|(
name|low
operator|>>
literal|4
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x08
argument_list|,
operator|(
name|high
operator|>>
literal|4
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_ramp_rate
parameter_list|(
name|unsigned
name|char
name|scale
parameter_list|,
name|unsigned
name|char
name|rate
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x06
argument_list|,
operator|(
operator|(
name|scale
operator|&
literal|0x03
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
name|rate
operator|&
literal|0x3f
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_rampon
parameter_list|(
name|unsigned
name|char
name|mode
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
name|mode
operator|&
literal|0xfc
argument_list|)
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
name|mode
operator|&
literal|0xfc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_ramp_mode
parameter_list|(
name|unsigned
name|char
name|mode
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
operator|(
name|gus_read8
argument_list|(
literal|0x0d
argument_list|)
operator|&
literal|0x03
operator|)
operator||
operator|(
name|mode
operator|&
literal|0xfc
operator|)
argument_list|)
expr_stmt|;
comment|/* Don't start or stop 								 * ramping */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
operator|(
name|gus_read8
argument_list|(
literal|0x0d
argument_list|)
operator|&
literal|0x03
operator|)
operator||
operator|(
name|mode
operator|&
literal|0xfc
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_rampoff
parameter_list|(
name|void
parameter_list|)
block|{
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_init
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_volume
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set current position to 0 */
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Voice off */
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Ramping off */
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
operator|=
literal|20000
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
literal|20000
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
literal|200
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_parm
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_parm
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
operator|=
literal|127
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|patch_vol
operator|=
literal|127
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
operator|=
literal|127
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|step_envelope
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|unsigned
name|vol
decl_stmt|,
name|prev_vol
decl_stmt|,
name|phase
decl_stmt|;
name|unsigned
name|char
name|rate
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_SUSTAIN_ON
operator|&&
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|==
literal|2
condition|)
block|{
name|gus_rampoff
argument_list|()
expr_stmt|;
return|return;
comment|/* Sustain */
block|}
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|>=
literal|5
condition|)
block|{
comment|/*        * Shoot the voice off        */
name|gus_voice_init
argument_list|(
name|voice
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev_vol
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
expr_stmt|;
name|gus_voice_volume
argument_list|(
name|prev_vol
argument_list|)
expr_stmt|;
name|phase
operator|=
operator|++
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
expr_stmt|;
name|compute_volume
argument_list|(
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|)
expr_stmt|;
name|vol
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|*
name|voices
index|[
name|voice
index|]
operator|.
name|env_offset
index|[
name|phase
index|]
operator|/
literal|255
expr_stmt|;
name|rate
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|env_rate
index|[
name|phase
index|]
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x06
argument_list|,
name|rate
argument_list|)
expr_stmt|;
comment|/* Ramping rate */
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
name|VMODE_ENVELOPE
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|vol
operator|-
name|prev_vol
operator|)
operator|/
literal|64
operator|)
operator|==
literal|0
condition|)
comment|/* No significant volume change */
block|{
name|step_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
comment|/* Continue with the next phase */
return|return;
block|}
if|if
condition|(
name|vol
operator|>
name|prev_vol
condition|)
block|{
if|if
condition|(
name|vol
operator|>=
operator|(
literal|4096
operator|-
literal|64
operator|)
condition|)
name|vol
operator|=
literal|4096
operator|-
literal|65
expr_stmt|;
name|gus_ramp_range
argument_list|(
literal|0
argument_list|,
name|vol
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x20
argument_list|)
expr_stmt|;
comment|/* Increasing, irq */
block|}
else|else
block|{
if|if
condition|(
name|vol
operator|<=
literal|64
condition|)
name|vol
operator|=
literal|65
expr_stmt|;
name|gus_ramp_range
argument_list|(
name|vol
argument_list|,
literal|4095
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x60
argument_list|)
expr_stmt|;
comment|/* Decreasing, irq */
block|}
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
name|vol
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_envelope
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|=
operator|-
literal|1
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
literal|64
expr_stmt|;
name|step_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_release
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
if|if
condition|(
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
operator|&
literal|0x03
condition|)
return|return;
comment|/* Voice already stopped */
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|=
literal|2
expr_stmt|;
comment|/* Will be incremented by step_envelope */
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
expr_stmt|;
comment|/* Get current volume */
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&=
operator|~
name|WAVE_SUSTAIN_ON
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|step_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_voice_fade
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|int
name|instr_no
init|=
name|sample_map
index|[
name|voice
index|]
decl_stmt|,
name|is16bits
decl_stmt|;
if|if
condition|(
name|instr_no
operator|<
literal|0
operator|||
name|instr_no
operator|>
name|MAX_SAMPLE
condition|)
block|{
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Hard stop */
return|return;
block|}
name|is16bits
operator|=
operator|(
name|samples
index|[
name|instr_no
index|]
operator|.
name|mode
operator|&
name|WAVE_16_BITS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 8 or 16 bit samples */
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|start_release
argument_list|(
name|voice
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * Ramp the volume down but not too quickly.    */
if|if
condition|(
operator|(
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
operator|)
operator|<
literal|100
condition|)
comment|/* Get current volume */
block|{
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_init
argument_list|(
name|voice
argument_list|)
expr_stmt|;
return|return;
block|}
name|gus_ramp_range
argument_list|(
literal|65
argument_list|,
literal|4095
argument_list|)
expr_stmt|;
name|gus_ramp_rate
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x40
operator||
literal|0x20
argument_list|)
expr_stmt|;
comment|/* Down, once, irq */
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
name|VMODE_HALT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_reset
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gus_select_max_voices
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|volume_base
operator|=
literal|3071
expr_stmt|;
name|volume_scale
operator|=
literal|4
expr_stmt|;
name|volume_method
operator|=
name|VOL_METHOD_ADAGIO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|gus_voice_init
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* Turn voice off */
block|}
name|INB
argument_list|(
name|u_Status
argument_list|)
expr_stmt|;
comment|/* Touch the status register */
name|gus_look8
argument_list|(
literal|0x41
argument_list|)
expr_stmt|;
comment|/* Clear any pending DMA IRQs */
name|gus_look8
argument_list|(
literal|0x49
argument_list|)
expr_stmt|;
comment|/* Clear any pending sample IRQs */
name|gus_read8
argument_list|(
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* Clear pending IRQs */
block|}
end_function

begin_function
specifier|static
name|void
name|gus_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|dma_image
decl_stmt|,
name|irq_image
decl_stmt|,
name|tmp
decl_stmt|;
specifier|static
name|unsigned
name|char
name|gus_irq_map
index|[
literal|16
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|,
literal|7
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|gus_dma_map
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|}
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset GF1 */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Release Reset */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
comment|/*    * Clear all interrupts    */
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DMA control */
name|gus_write8
argument_list|(
literal|0x45
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Timer control */
name|gus_write8
argument_list|(
literal|0x49
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Sample control */
name|gus_select_max_voices
argument_list|(
literal|24
argument_list|)
expr_stmt|;
name|INB
argument_list|(
name|u_Status
argument_list|)
expr_stmt|;
comment|/* Touch the status register */
name|gus_look8
argument_list|(
literal|0x41
argument_list|)
expr_stmt|;
comment|/* Clear any pending DMA IRQs */
name|gus_look8
argument_list|(
literal|0x49
argument_list|)
expr_stmt|;
comment|/* Clear any pending sample IRQs */
name|gus_read8
argument_list|(
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* Clear pending IRQs */
name|gus_reset
argument_list|()
expr_stmt|;
comment|/* Resets all voices */
name|gus_look8
argument_list|(
literal|0x41
argument_list|)
expr_stmt|;
comment|/* Clear any pending DMA IRQs */
name|gus_look8
argument_list|(
literal|0x49
argument_list|)
expr_stmt|;
comment|/* Clear any pending sample IRQs */
name|gus_read8
argument_list|(
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* Clear pending IRQs */
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* Master reset | DAC enable | IRQ enable */
comment|/*    * Set up for Digital ASIC    */
name|OUTB
argument_list|(
literal|0x05
argument_list|,
name|gus_base
operator|+
literal|0x0f
argument_list|)
expr_stmt|;
name|mix_image
operator||=
literal|0x02
expr_stmt|;
comment|/* Disable line out */
name|OUTB
argument_list|(
name|mix_image
argument_list|,
name|u_Mixer
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x00
argument_list|,
name|u_IRQDMAControl
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x00
argument_list|,
name|gus_base
operator|+
literal|0x0f
argument_list|)
expr_stmt|;
comment|/*    * Now set up the DMA and IRQ interface    *     * The GUS supports two IRQs and two DMAs.    *     * If GUS_MIDI_IRQ is defined and if it's != GUS_IRQ, separate Midi IRQ is set    * up. Otherwise the same IRQ is shared by the both devices.    *     * Just one DMA channel is used. This prevents simultaneous ADC and DAC.    * Adding this support requires significant changes to the dmabuf.c, dsp.c    * and audio.c also.    */
name|irq_image
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|gus_irq_map
index|[
name|gus_irq
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|printk
argument_list|(
literal|"Warning! GUS IRQ not selected\n"
argument_list|)
expr_stmt|;
name|irq_image
operator||=
name|tmp
expr_stmt|;
if|if
condition|(
name|GUS_MIDI_IRQ
operator|!=
name|gus_irq
condition|)
block|{
comment|/* The midi irq was defined and != wave irq */
name|tmp
operator|=
name|gus_irq_map
index|[
name|GUS_MIDI_IRQ
index|]
expr_stmt|;
name|tmp
operator|<<=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|printk
argument_list|(
literal|"Warning! GUS Midi IRQ not selected\n"
argument_list|)
expr_stmt|;
else|else
name|gus_set_midi_irq
argument_list|(
name|GUS_MIDI_IRQ
argument_list|)
expr_stmt|;
name|irq_image
operator||=
name|tmp
expr_stmt|;
block|}
else|else
name|irq_image
operator||=
literal|0x40
expr_stmt|;
comment|/* Combine IRQ1 (GF1) and IRQ2 (Midi) */
name|dma_image
operator|=
literal|0x40
expr_stmt|;
comment|/* Combine DMA1 (DRAM) and IRQ2 (ADC) */
name|tmp
operator|=
name|gus_dma_map
index|[
name|gus_dma
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|printk
argument_list|(
literal|"Warning! GUS DMA not selected\n"
argument_list|)
expr_stmt|;
name|dma_image
operator||=
name|tmp
expr_stmt|;
comment|/*    * For some reason the IRQ and DMA addresses must be written twice    */
comment|/* Doing it first time */
name|OUTB
argument_list|(
name|mix_image
argument_list|,
name|u_Mixer
argument_list|)
expr_stmt|;
comment|/* Select DMA control */
name|OUTB
argument_list|(
name|dma_image
argument_list|,
name|u_IRQDMAControl
argument_list|)
expr_stmt|;
comment|/* Set DMA address */
name|OUTB
argument_list|(
name|mix_image
operator||
literal|0x40
argument_list|,
name|u_Mixer
argument_list|)
expr_stmt|;
comment|/* Select IRQ control */
name|OUTB
argument_list|(
name|irq_image
argument_list|,
name|u_IRQDMAControl
argument_list|)
expr_stmt|;
comment|/* Set IRQ address */
comment|/* Doing it second time */
name|OUTB
argument_list|(
name|mix_image
argument_list|,
name|u_Mixer
argument_list|)
expr_stmt|;
comment|/* Select DMA control */
name|OUTB
argument_list|(
name|dma_image
argument_list|,
name|u_IRQDMAControl
argument_list|)
expr_stmt|;
comment|/* Set DMA address */
name|OUTB
argument_list|(
name|mix_image
operator||
literal|0x40
argument_list|,
name|u_Mixer
argument_list|)
expr_stmt|;
comment|/* Select IRQ control */
name|OUTB
argument_list|(
name|irq_image
argument_list|,
name|u_IRQDMAControl
argument_list|)
expr_stmt|;
comment|/* Set IRQ address */
name|gus_select_voice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This disables writes to IRQ/DMA reg */
name|mix_image
operator|&=
operator|~
literal|0x02
expr_stmt|;
comment|/* Enable line out */
name|mix_image
operator||=
literal|0x08
expr_stmt|;
comment|/* Enable IRQ */
name|OUTB
argument_list|(
name|mix_image
argument_list|,
name|u_Mixer
argument_list|)
expr_stmt|;
comment|/* Turn mixer channels on */
name|gus_select_voice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* This disables writes to IRQ/DMA reg */
name|gusintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Serve pending interrupts */
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gus_wave_detect
parameter_list|(
name|int
name|baseaddr
parameter_list|)
block|{
name|gus_base
operator|=
name|baseaddr
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset GF1 */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x4c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Release Reset */
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_delay
argument_list|()
expr_stmt|;
name|gus_poke
argument_list|(
literal|0x000
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|gus_poke
argument_list|(
literal|0x100
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_peek
argument_list|(
literal|0x000
argument_list|)
operator|!=
literal|0xaa
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|gus_peek
argument_list|(
literal|0x100
argument_list|)
operator|!=
literal|0x55
condition|)
return|return
literal|0
return|;
name|gus_mem_size
operator|=
literal|0x40000
expr_stmt|;
comment|/* 256k */
name|gus_poke
argument_list|(
literal|0x40000
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_peek
argument_list|(
literal|0x40000
argument_list|)
operator|!=
literal|0xaa
condition|)
return|return
literal|1
return|;
name|gus_mem_size
operator|=
literal|0x80000
expr_stmt|;
comment|/* 512k */
name|gus_poke
argument_list|(
literal|0x80000
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_peek
argument_list|(
literal|0x80000
argument_list|)
operator|!=
literal|0xaa
condition|)
return|return
literal|1
return|;
name|gus_mem_size
operator|=
literal|0xc0000
expr_stmt|;
comment|/* 768k */
name|gus_poke
argument_list|(
literal|0xc0000
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_peek
argument_list|(
literal|0xc0000
argument_list|)
operator|!=
literal|0xaa
condition|)
return|return
literal|1
return|;
name|gus_mem_size
operator|=
literal|0x100000
expr_stmt|;
comment|/* 1M */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_SYNTH_INFO
case|:
name|gus_info
operator|.
name|nr_voices
operator|=
name|nr_voices
expr_stmt|;
name|IOCTL_TO_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
operator|&
name|gus_info
argument_list|,
sizeof|sizeof
argument_list|(
name|gus_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_RESETSAMPLES
case|:
name|reset_sample_memory
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_PERCMODE
case|:
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
return|return
name|gus_mem_size
operator|-
name|free_mem_ptr
operator|-
literal|32
return|;
default|default:
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_set_instr
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|instr_no
parameter_list|)
block|{
name|int
name|sample_no
decl_stmt|;
if|if
condition|(
name|instr_no
operator|<
literal|0
operator|||
name|instr_no
operator|>
name|MAX_PATCH
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>
literal|31
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|sample_no
operator|=
name|patch_table
index|[
name|instr_no
index|]
expr_stmt|;
name|patch_map
index|[
name|voice
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sample_no
operator|<
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Undefined patch %d for voice %d\n"
argument_list|,
name|instr_no
argument_list|,
name|voice
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* Patch not defined */
block|}
if|if
condition|(
name|sample_ptrs
index|[
name|sample_no
index|]
operator|==
operator|-
literal|1
condition|)
comment|/* Sample not loaded */
block|{
name|printk
argument_list|(
literal|"GUS: Sample #%d not loaded for patch %d (voice %d)\n"
argument_list|,
name|sample_no
argument_list|,
name|instr_no
argument_list|,
name|voice
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|sample_map
index|[
name|voice
index|]
operator|=
name|sample_no
expr_stmt|;
name|patch_map
index|[
name|voice
index|]
operator|=
name|instr_no
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_kill_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|velocity
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_fade
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_aftertouch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|pressure
parameter_list|)
block|{
name|short
name|lo_limit
decl_stmt|,
name|hi_limit
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
return|return;
comment|/* Currently disabled */
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>
literal|31
condition|)
return|return;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
operator|&&
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|!=
literal|2
condition|)
return|return;
comment|/* Don't mix with envelopes */
if|if
condition|(
name|pressure
operator|<
literal|32
condition|)
block|{
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|compute_and_set_volume
argument_list|(
name|voice
argument_list|,
literal|255
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Back to original volume */
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|hi_limit
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
expr_stmt|;
name|lo_limit
operator|=
name|hi_limit
operator|*
literal|99
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|lo_limit
operator|<
literal|65
condition|)
name|lo_limit
operator|=
literal|65
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi_limit
operator|>
operator|(
literal|4095
operator|-
literal|65
operator|)
condition|)
block|{
name|hi_limit
operator|=
literal|4095
operator|-
literal|65
expr_stmt|;
name|gus_voice_volume
argument_list|(
name|hi_limit
argument_list|)
expr_stmt|;
block|}
name|gus_ramp_range
argument_list|(
name|lo_limit
argument_list|,
name|hi_limit
argument_list|)
expr_stmt|;
name|gus_ramp_rate
argument_list|(
literal|3
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x58
argument_list|)
expr_stmt|;
comment|/* Bidirectional, Down, Loop */
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_panning
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
if|if
condition|(
name|voice
operator|>=
literal|0
operator|||
name|voice
operator|<
literal|32
condition|)
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compute_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
if|if
condition|(
name|volume
operator|<
literal|128
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
operator|=
name|volume
expr_stmt|;
switch|switch
condition|(
name|volume_method
condition|)
block|{
case|case
name|VOL_METHOD_ADAGIO
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|gus_adagio_vol
argument_list|(
name|volume
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|patch_vol
argument_list|)
expr_stmt|;
break|break;
default|default:
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|volume_base
operator|+
operator|(
name|volume
operator|*
name|volume_scale
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|>
literal|4095
condition|)
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
literal|4095
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compute_and_set_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|volume
parameter_list|,
name|int
name|ramp_time
parameter_list|)
block|{
name|int
name|current
decl_stmt|,
name|target
decl_stmt|,
name|rate
decl_stmt|;
name|compute_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
expr_stmt|;
name|current
operator|=
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
expr_stmt|;
name|target
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
expr_stmt|;
if|if
condition|(
name|ramp_time
operator|==
name|INSTANT_RAMP
condition|)
block|{
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_volume
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ramp_time
operator|==
name|FAST_RAMP
condition|)
name|rate
operator|=
literal|63
expr_stmt|;
else|else
name|rate
operator|=
literal|16
expr_stmt|;
name|gus_ramp_rate
argument_list|(
literal|0
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|-
name|current
operator|)
operator|/
literal|64
operator|==
literal|0
condition|)
comment|/* Too close */
block|{
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_volume
argument_list|(
name|target
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|target
operator|>
name|current
condition|)
block|{
if|if
condition|(
name|target
operator|>
operator|(
literal|4095
operator|-
literal|65
operator|)
condition|)
name|target
operator|=
literal|4095
operator|-
literal|65
expr_stmt|;
name|gus_ramp_range
argument_list|(
name|current
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Ramp up, once, no irq */
block|}
else|else
block|{
if|if
condition|(
name|target
operator|<
literal|65
condition|)
name|target
operator|=
literal|65
expr_stmt|;
name|gus_ramp_range
argument_list|(
name|target
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|gus_rampon
argument_list|(
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Ramp down, once, no irq */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dynamic_volume_change
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|unsigned
name|char
name|status
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|status
operator|=
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Voice status */
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x03
condition|)
return|return;
comment|/* Voice not started */
if|if
condition|(
operator|!
operator|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
operator|)
condition|)
block|{
name|compute_and_set_volume
argument_list|(
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * Voice is running and has envelopes.    */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|status
operator|=
name|gus_read8
argument_list|(
literal|0x0d
argument_list|)
expr_stmt|;
comment|/* Ramping status */
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
literal|0x03
condition|)
comment|/* Sustain phase? */
block|{
name|compute_and_set_volume
argument_list|(
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|env_phase
operator|<
literal|0
condition|)
return|return;
name|compute_volume
argument_list|(
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Is this really required */
block|voices[voice].current_volume =     gus_read16 (0x09)>> 4;
comment|/* Get current volume */
block|voices[voice].env_phase--;   step_envelope (voice);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_controller
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|ctrl_num
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|long
name|freq
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>
literal|31
condition|)
return|return;
switch|switch
condition|(
name|ctrl_num
condition|)
block|{
case|case
name|CTRL_PITCH_BENDER
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|value
expr_stmt|;
name|freq
operator|=
name|compute_finetune
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|value
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|freq
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_freq
argument_list|(
name|freq
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL_PITCH_BENDER_RANGE
case|:
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|CTRL_EXPRESSION
case|:
name|volume_method
operator|=
name|VOL_METHOD_ADAGIO
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
operator|=
name|value
expr_stmt|;
name|dynamic_volume_change
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL_MAIN_VOLUME
case|:
name|volume_method
operator|=
name|VOL_METHOD_ADAGIO
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
operator|=
name|value
expr_stmt|;
name|dynamic_volume_change
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Ignore */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_start_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note_num
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
name|int
name|sample
decl_stmt|,
name|best_sample
decl_stmt|,
name|best_delta
decl_stmt|,
name|delta_freq
decl_stmt|;
name|int
name|is16bits
decl_stmt|,
name|samplep
decl_stmt|,
name|patch
decl_stmt|,
name|pan
decl_stmt|;
name|unsigned
name|long
name|note_freq
decl_stmt|,
name|base_note
decl_stmt|,
name|freq
decl_stmt|,
name|flags
decl_stmt|;
name|unsigned
name|char
name|mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>
literal|31
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Invalid voice\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|note_num
operator|==
literal|255
condition|)
block|{
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|midi_volume
operator|=
name|volume
expr_stmt|;
name|dynamic_volume_change
argument_list|(
name|voice
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|compute_and_set_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|patch
operator|=
name|patch_map
index|[
name|voice
index|]
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|samplep
operator|=
name|patch_table
index|[
name|patch
index|]
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|note_freq
operator|=
name|note_to_freq
argument_list|(
name|note_num
argument_list|)
expr_stmt|;
comment|/*    * Find a sample within a patch so that the note_freq is between low_note    * and high_note.    */
name|sample
operator|=
operator|-
literal|1
expr_stmt|;
name|best_sample
operator|=
name|samplep
expr_stmt|;
name|best_delta
operator|=
literal|1000000
expr_stmt|;
while|while
condition|(
name|samplep
operator|>=
literal|0
operator|&&
name|sample
operator|==
operator|-
literal|1
condition|)
block|{
name|delta_freq
operator|=
name|note_freq
operator|-
name|samples
index|[
name|samplep
index|]
operator|.
name|base_note
expr_stmt|;
if|if
condition|(
name|delta_freq
operator|<
literal|0
condition|)
name|delta_freq
operator|=
operator|-
name|delta_freq
expr_stmt|;
if|if
condition|(
name|delta_freq
operator|<
name|best_delta
condition|)
block|{
name|best_sample
operator|=
name|samplep
expr_stmt|;
name|best_delta
operator|=
name|delta_freq
expr_stmt|;
block|}
if|if
condition|(
name|samples
index|[
name|samplep
index|]
operator|.
name|low_note
operator|<=
name|note_freq
operator|&&
name|note_freq
operator|<=
name|samples
index|[
name|samplep
index|]
operator|.
name|high_note
condition|)
name|sample
operator|=
name|samplep
expr_stmt|;
else|else
name|samplep
operator|=
name|samples
index|[
name|samplep
index|]
operator|.
name|key
expr_stmt|;
comment|/* Follow link */
block|}
if|if
condition|(
name|sample
operator|==
operator|-
literal|1
condition|)
name|sample
operator|=
name|best_sample
expr_stmt|;
if|if
condition|(
name|sample
operator|==
operator|-
literal|1
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Patch %d not defined for note %d\n"
argument_list|,
name|patch
argument_list|,
name|note_num
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Should play default patch ??? */
block|}
name|is16bits
operator|=
operator|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_16_BITS
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 8 or 16 bit samples */
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|mode
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|patch_vol
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|volume
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|env_rate
index|[
name|i
index|]
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|env_rate
index|[
name|i
index|]
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|env_offset
index|[
name|i
index|]
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|env_offset
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
name|sample_map
index|[
name|voice
index|]
operator|=
name|sample
expr_stmt|;
name|base_note
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|base_note
operator|/
literal|100
expr_stmt|;
comment|/* To avoid overflows */
name|note_freq
operator|/=
literal|100
expr_stmt|;
name|freq
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|base_freq
operator|*
name|note_freq
operator|/
name|base_note
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
operator|=
name|freq
expr_stmt|;
comment|/*    * Since the pitch bender may have been set before playing the note, we    * have to calculate the bending now.    */
name|freq
operator|=
name|compute_finetune
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|orig_freq
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|current_freq
operator|=
name|freq
expr_stmt|;
name|pan
operator|=
operator|(
name|samples
index|[
name|sample
index|]
operator|.
name|panning
operator|+
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|)
operator|/
literal|32
expr_stmt|;
name|pan
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|pan
operator|<
literal|0
condition|)
name|pan
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pan
operator|>
literal|15
condition|)
name|pan
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_16_BITS
condition|)
block|{
name|mode
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bits */
if|if
condition|(
operator|(
name|sample_ptrs
index|[
name|sample
index|]
operator|>>
literal|18
operator|)
operator|!=
operator|(
operator|(
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|len
operator|)
operator|>>
literal|18
operator|)
condition|)
name|printk
argument_list|(
literal|"GUS: Sample address error\n"
argument_list|)
expr_stmt|;
block|}
comment|/*************************************************************************  *	CAUTION!	Interrupts disabled. Don't return before enabling  *************************************************************************/
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_off
argument_list|()
expr_stmt|;
comment|/* It may still be running */
name|gus_rampoff
argument_list|()
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|compute_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|)
expr_stmt|;
name|init_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
else|else
name|compute_and_set_volume
argument_list|(
name|voice
argument_list|,
name|volume
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_LOOP_BACK
condition|)
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|len
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Sample start=end */
else|else
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Sample start=begin */
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_LOOPING
condition|)
block|{
name|mode
operator||=
literal|0x08
expr_stmt|;
comment|/* Looping on */
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_BIDIR_LOOP
condition|)
name|mode
operator||=
literal|0x10
expr_stmt|;
comment|/* Bidirectional looping on */
if|if
condition|(
name|samples
index|[
name|sample
index|]
operator|.
name|mode
operator|&
name|WAVE_LOOP_BACK
condition|)
block|{
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
comment|/* Put the current location = loop_end */
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|loop_end
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
name|mode
operator||=
literal|0x40
expr_stmt|;
comment|/* Loop backwards */
block|}
name|gus_write_addr
argument_list|(
literal|0x02
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|loop_start
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop start location */
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|loop_end
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
block|}
else|else
block|{
name|mode
operator||=
literal|0x20
expr_stmt|;
comment|/* Loop irq at the end */
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
operator|=
name|LMODE_FINISH
expr_stmt|;
comment|/* Ramp it down at the 							 * end */
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_parm
operator|=
literal|1
expr_stmt|;
name|gus_write_addr
argument_list|(
literal|0x02
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop start location */
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|sample_ptrs
index|[
name|sample
index|]
operator|+
name|samples
index|[
name|sample
index|]
operator|.
name|len
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
block|}
name|gus_voice_freq
argument_list|(
name|freq
argument_list|)
expr_stmt|;
name|gus_voice_balance
argument_list|(
name|pan
argument_list|)
expr_stmt|;
name|gus_voice_on
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_reset
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|gus_voice_init
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|gus_busy
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|DMAbuf_open_dma
argument_list|(
name|gus_devnum
argument_list|)
operator|)
condition|)
return|return
name|err
return|;
name|gus_busy
operator|=
literal|1
expr_stmt|;
name|active_device
operator|=
name|GUS_DEV_WAVE
expr_stmt|;
name|gus_reset
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|gus_busy
operator|=
literal|0
expr_stmt|;
name|active_device
operator|=
literal|0
expr_stmt|;
name|gus_reset
argument_list|()
expr_stmt|;
name|DMAbuf_close_dma
argument_list|(
name|gus_devnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|guswave_load_patch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|format
parameter_list|,
name|snd_rw_buf
modifier|*
name|addr
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
block|{
name|struct
name|patch_info
name|patch
decl_stmt|;
name|int
name|instr
decl_stmt|;
name|unsigned
name|long
name|blk_size
decl_stmt|,
name|blk_end
decl_stmt|,
name|left
decl_stmt|,
name|src_offs
decl_stmt|,
name|target
decl_stmt|;
if|if
condition|(
name|format
operator|!=
name|GUS_PATCH
condition|)
block|{
name|printk
argument_list|(
literal|"GUS Error: Invalid patch format (key) 0x%04x\n"
argument_list|,
name|format
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
name|patch
argument_list|)
condition|)
block|{
name|printk
argument_list|(
literal|"GUS Error: Patch header too short\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|count
operator|-=
sizeof|sizeof
argument_list|(
name|patch
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_sample
operator|>=
name|MAX_SAMPLE
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Sample table full\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
comment|/*    * Copy the header from user space but ignore the first bytes which have    * been transferred already.    */
name|COPY_FROM_USER
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|patch
operator|)
index|[
name|offs
index|]
argument_list|,
name|addr
argument_list|,
name|offs
argument_list|,
sizeof|sizeof
argument_list|(
name|patch
argument_list|)
operator|-
name|offs
argument_list|)
expr_stmt|;
name|instr
operator|=
name|patch
operator|.
name|instr_no
expr_stmt|;
if|if
condition|(
name|instr
operator|<
literal|0
operator|||
name|instr
operator|>
name|MAX_PATCH
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Invalid patch number %d\n"
argument_list|,
name|instr
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|count
operator|<
name|patch
operator|.
name|len
condition|)
block|{
name|printk
argument_list|(
literal|"GUS Warning: Patch record too short (%d<%d)\n"
argument_list|,
name|count
argument_list|,
name|patch
operator|.
name|len
argument_list|)
expr_stmt|;
name|patch
operator|.
name|len
operator|=
name|count
expr_stmt|;
block|}
if|if
condition|(
name|patch
operator|.
name|len
operator|<=
literal|0
operator|||
name|patch
operator|.
name|len
operator|>
name|gus_mem_size
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Invalid sample length %d\n"
argument_list|,
name|patch
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_LOOPING
condition|)
block|{
if|if
condition|(
name|patch
operator|.
name|loop_start
operator|<
literal|0
operator|||
name|patch
operator|.
name|loop_start
operator|>=
name|patch
operator|.
name|len
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Invalid loop start\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|patch
operator|.
name|loop_end
operator|<
name|patch
operator|.
name|loop_start
operator|||
name|patch
operator|.
name|loop_end
operator|>
name|patch
operator|.
name|len
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Invalid loop end\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
name|free_mem_ptr
operator|=
operator|(
name|free_mem_ptr
operator|+
literal|31
operator|)
operator|&
operator|~
literal|31
expr_stmt|;
comment|/* Alignment 32 bytes */
define|#
directive|define
name|GUS_BANK_SIZE
value|(256*1024)
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_16_BITS
condition|)
block|{
comment|/*        * 16 bit samples must fit one 256k bank.        */
if|if
condition|(
name|patch
operator|.
name|len
operator|>=
name|GUS_BANK_SIZE
condition|)
block|{
name|printk
argument_list|(
literal|"GUS: Sample (16 bit) too long %d\n"
argument_list|,
name|patch
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|free_mem_ptr
operator|/
name|GUS_BANK_SIZE
operator|)
operator|!=
operator|(
operator|(
name|free_mem_ptr
operator|+
name|patch
operator|.
name|len
operator|)
operator|/
name|GUS_BANK_SIZE
operator|)
condition|)
block|{
name|unsigned
name|long
name|tmp_mem
init|=
comment|/* Align to 256K*N */
operator|(
operator|(
name|free_mem_ptr
operator|/
name|GUS_BANK_SIZE
operator|)
operator|+
literal|1
operator|)
operator|*
name|GUS_BANK_SIZE
decl_stmt|;
if|if
condition|(
operator|(
name|tmp_mem
operator|+
name|patch
operator|.
name|len
operator|)
operator|>
name|gus_mem_size
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
name|free_mem_ptr
operator|=
name|tmp_mem
expr_stmt|;
comment|/* This leaves unusable memory */
block|}
block|}
if|if
condition|(
operator|(
name|free_mem_ptr
operator|+
name|patch
operator|.
name|len
operator|)
operator|>
name|gus_mem_size
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
name|sample_ptrs
index|[
name|free_sample
index|]
operator|=
name|free_mem_ptr
expr_stmt|;
comment|/* Tremolo is not possible with envelopes */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
name|patch
operator|.
name|mode
operator|&=
operator|~
name|WAVE_TREMOLO
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|samples
index|[
name|free_sample
index|]
argument_list|,
operator|&
name|patch
argument_list|,
sizeof|sizeof
argument_list|(
name|patch
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Link this_one sample to the list of samples for patch 'instr'.    */
name|samples
index|[
name|free_sample
index|]
operator|.
name|key
operator|=
name|patch_table
index|[
name|instr
index|]
expr_stmt|;
name|patch_table
index|[
name|instr
index|]
operator|=
name|free_sample
expr_stmt|;
comment|/*    * Use DMA to transfer the wave data to the DRAM    */
name|left
operator|=
name|patch
operator|.
name|len
expr_stmt|;
name|src_offs
operator|=
literal|0
expr_stmt|;
name|target
operator|=
name|free_mem_ptr
expr_stmt|;
while|while
condition|(
name|left
condition|)
comment|/* Not all moved */
block|{
name|blk_size
operator|=
name|sound_buffsizes
index|[
name|gus_devnum
index|]
expr_stmt|;
if|if
condition|(
name|blk_size
operator|>
name|left
condition|)
name|blk_size
operator|=
name|left
expr_stmt|;
comment|/*        * DMA cannot cross 256k bank boundaries. Check for that.        */
name|blk_end
operator|=
name|target
operator|+
name|blk_size
expr_stmt|;
if|if
condition|(
operator|(
name|target
operator|>>
literal|18
operator|)
operator|!=
operator|(
name|blk_end
operator|>>
literal|18
operator|)
condition|)
block|{
comment|/* Have to split the block */
name|blk_end
operator|&=
operator|~
operator|(
literal|256
operator|*
literal|1024
operator|-
literal|1
operator|)
expr_stmt|;
name|blk_size
operator|=
name|blk_end
operator|-
name|target
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GUS_NO_DMA
comment|/*        * For some reason the DMA is not possible. We have to use PIO.        */
block|{
name|long
name|i
decl_stmt|;
name|unsigned
name|char
name|data
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blk_size
condition|;
name|i
operator|++
control|)
block|{
name|GET_BYTE_FROM_USER
argument_list|(
name|data
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|patch
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|gus_poke
argument_list|(
name|target
operator|+
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* GUS_NO_DMA */
block|{
name|unsigned
name|long
name|address
decl_stmt|,
name|hold_address
decl_stmt|;
name|unsigned
name|char
name|dma_command
decl_stmt|;
comment|/* 	 * OK, move now. First in and then out. 	 */
name|COPY_FROM_USER
argument_list|(
name|snd_raw_buf
index|[
name|gus_devnum
index|]
index|[
literal|0
index|]
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|patch
argument_list|)
operator|+
name|src_offs
argument_list|,
name|blk_size
argument_list|)
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable GF1 DMA */
name|DMAbuf_start_dma
argument_list|(
name|gus_devnum
argument_list|,
name|snd_raw_buf_phys
index|[
name|gus_devnum
index|]
index|[
literal|0
index|]
argument_list|,
name|blk_size
argument_list|,
name|DMA_MODE_WRITE
argument_list|)
expr_stmt|;
comment|/* 	 * Set the DRAM address for the wave data 	 */
name|address
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|sound_dsp_dmachan
index|[
name|gus_devnum
index|]
operator|>
literal|3
condition|)
block|{
name|hold_address
operator|=
name|address
expr_stmt|;
name|address
operator|=
name|address
operator|>>
literal|1
expr_stmt|;
name|address
operator|&=
literal|0x0001ffffL
expr_stmt|;
name|address
operator||=
operator|(
name|hold_address
operator|&
literal|0x000c0000L
operator|)
expr_stmt|;
block|}
name|gus_write16
argument_list|(
literal|0x42
argument_list|,
operator|(
name|address
operator|>>
literal|4
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* DRAM DMA address */
comment|/* 	 * Start the DMA transfer 	 */
name|dma_command
operator|=
literal|0x21
expr_stmt|;
comment|/* IRQ enable, DMA start */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_UNSIGNED
condition|)
name|dma_command
operator||=
literal|0x80
expr_stmt|;
comment|/* Invert MSB */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_16_BITS
condition|)
name|dma_command
operator||=
literal|0x40
expr_stmt|;
comment|/* 16 bit _DATA_ */
if|if
condition|(
name|sound_dsp_dmachan
index|[
name|gus_devnum
index|]
operator|>
literal|3
condition|)
name|dma_command
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bit DMA channel */
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
name|dma_command
argument_list|)
expr_stmt|;
comment|/* Let's go luteet (=bugs) */
comment|/* 	 * Sleep here until the DRAM DMA done interrupt is served 	 */
name|active_device
operator|=
name|GUS_DEV_WAVE
expr_stmt|;
name|INTERRUPTIBLE_SLEEP_ON
argument_list|(
name|dram_sleeper
argument_list|,
name|dram_sleep_flag
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* GUS_NO_DMA */
comment|/*        * Now the next part        */
name|left
operator|-=
name|blk_size
expr_stmt|;
name|src_offs
operator|+=
name|blk_size
expr_stmt|;
name|target
operator|+=
name|blk_size
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop DMA */
block|}
name|free_mem_ptr
operator|+=
name|patch
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|pmgr_flag
condition|)
name|pmgr_inform
argument_list|(
name|dev
argument_list|,
name|PM_E_PATCH_LOADED
argument_list|,
name|instr
argument_list|,
name|free_sample
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_sample
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|guswave_hw_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|voice
decl_stmt|,
name|cmd
decl_stmt|;
name|unsigned
name|short
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|unsigned
name|long
name|plong
decl_stmt|,
name|flags
decl_stmt|;
name|cmd
operator|=
name|event
index|[
literal|2
index|]
expr_stmt|;
name|voice
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
name|p1
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|6
index|]
expr_stmt|;
name|plong
operator|=
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|_GUS_NUMVOICES
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_select_max_voices
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICESAMPLE
case|:
name|guswave_set_instr
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEON
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Disable intr */
name|gus_voice_on
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEOFF
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_off
argument_list|()
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEFADE
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_fade
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEMODE
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Disable intr */
name|gus_voice_mode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEBALA
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_balance
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEFREQ
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_freq
argument_list|(
name|plong
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEVOL
case|:
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_voice_volume
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEVOL2
case|:
comment|/* Just update the voice value */
name|voices
index|[
name|voice
index|]
operator|.
name|initial_volume
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|current_volume
operator|=
name|p1
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPRANGE
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* NO-NO */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_ramp_range
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPRATE
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* NO-NO */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_ramp_rate
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPMODE
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* NO-NO */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Disable intr */
name|gus_ramp_mode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPON
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* NO-NO */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Disable intr */
name|gus_rampon
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_RAMPOFF
case|:
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
break|break;
comment|/* NO-NO */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOLUME_SCALE
case|:
name|volume_base
operator|=
name|p1
expr_stmt|;
name|volume_scale
operator|=
name|p2
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_set_speed
parameter_list|(
name|int
name|speed
parameter_list|)
block|{
if|if
condition|(
name|speed
operator|<=
literal|0
condition|)
return|return
name|gus_sampling_speed
return|;
if|if
condition|(
name|speed
operator|>
literal|44100
condition|)
name|speed
operator|=
literal|44100
expr_stmt|;
name|gus_sampling_speed
operator|=
name|speed
expr_stmt|;
return|return
name|speed
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_set_channels
parameter_list|(
name|int
name|channels
parameter_list|)
block|{
if|if
condition|(
operator|!
name|channels
condition|)
return|return
name|gus_sampling_channels
return|;
if|if
condition|(
name|channels
operator|>
literal|2
condition|)
name|channels
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|channels
operator|<
literal|1
condition|)
name|channels
operator|=
literal|1
expr_stmt|;
name|gus_sampling_channels
operator|=
name|channels
expr_stmt|;
return|return
name|channels
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_set_bits
parameter_list|(
name|int
name|bits
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bits
condition|)
return|return
name|gus_sampling_bits
return|;
if|if
condition|(
name|bits
operator|!=
literal|8
operator|&&
name|bits
operator|!=
literal|16
condition|)
name|bits
operator|=
literal|8
expr_stmt|;
name|gus_sampling_bits
operator|=
name|bits
expr_stmt|;
return|return
name|bits
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|arg
parameter_list|,
name|int
name|local
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SOUND_PCM_WRITE_RATE
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_set_speed
argument_list|(
name|arg
argument_list|)
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_set_speed
argument_list|(
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_PCM_READ_RATE
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_speed
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_speed
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_DSP_STEREO
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_set_channels
argument_list|(
name|arg
operator|+
literal|1
argument_list|)
operator|-
literal|1
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_set_channels
argument_list|(
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
operator|+
literal|1
argument_list|)
operator|-
literal|1
argument_list|)
return|;
break|break;
case|case
name|SOUND_PCM_WRITE_CHANNELS
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_set_channels
argument_list|(
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_PCM_READ_CHANNELS
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_channels
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_channels
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_DSP_SAMPLESIZE
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_set_bits
argument_list|(
name|arg
argument_list|)
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_set_bits
argument_list|(
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_PCM_READ_BITS
case|:
if|if
condition|(
name|local
condition|)
return|return
name|gus_sampling_bits
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|gus_sampling_bits
argument_list|)
return|;
case|case
name|SOUND_PCM_WRITE_FILTER
case|:
comment|/* NOT YET IMPLEMENTED */
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
argument_list|)
return|;
break|break;
case|case
name|SOUND_PCM_READ_FILTER
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
argument_list|)
return|;
break|break;
default|default:
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_reset
parameter_list|(
name|int
name|dev
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|gus_sampling_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GUS_NO_DMA
name|printk
argument_list|(
literal|"GUS: DMA mode not enabled. Device not supported\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|gus_busy
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
name|gus_busy
operator|=
literal|1
expr_stmt|;
name|active_device
operator|=
literal|0
expr_stmt|;
name|gus_reset
argument_list|()
expr_stmt|;
name|reset_sample_memory
argument_list|()
expr_stmt|;
name|gus_select_max_voices
argument_list|(
literal|14
argument_list|)
expr_stmt|;
name|gus_sampling_set_bits
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|gus_sampling_set_channels
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|gus_sampling_set_speed
argument_list|(
name|DSP_DEFAULT_SPEED
argument_list|)
expr_stmt|;
name|pcm_active
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|gus_reset
argument_list|()
expr_stmt|;
name|gus_busy
operator|=
literal|0
expr_stmt|;
name|active_device
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|play_next_pcm_block
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|speed
init|=
name|gus_sampling_speed
decl_stmt|;
name|int
name|this_one
decl_stmt|,
name|is16bits
decl_stmt|,
name|chn
decl_stmt|;
name|unsigned
name|long
name|dram_loc
decl_stmt|;
name|unsigned
name|char
name|mode
index|[
literal|2
index|]
decl_stmt|,
name|ramp_mode
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|pcm_qlen
condition|)
return|return;
name|this_one
operator|=
name|pcm_head
expr_stmt|;
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
name|gus_sampling_channels
condition|;
name|chn
operator|++
control|)
block|{
name|mode
index|[
name|chn
index|]
operator|=
literal|0x00
expr_stmt|;
name|ramp_mode
index|[
name|chn
index|]
operator|=
literal|0x03
expr_stmt|;
comment|/* Ramping and rollover off */
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
block|{
name|mode
index|[
name|chn
index|]
operator||=
literal|0x20
expr_stmt|;
comment|/* Loop irq */
name|voices
index|[
name|chn
index|]
operator|.
name|loop_irq_mode
operator|=
name|LMODE_PCM
expr_stmt|;
block|}
if|if
condition|(
name|gus_sampling_bits
operator|!=
literal|8
condition|)
block|{
name|is16bits
operator|=
literal|1
expr_stmt|;
name|mode
index|[
name|chn
index|]
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bit data */
block|}
else|else
name|is16bits
operator|=
literal|0
expr_stmt|;
name|dram_loc
operator|=
name|this_one
operator|*
name|pcm_bsize
expr_stmt|;
name|dram_loc
operator|+=
name|chn
operator|*
name|pcm_banksize
expr_stmt|;
if|if
condition|(
name|this_one
operator|==
operator|(
name|pcm_nblk
operator|-
literal|1
operator|)
condition|)
comment|/* Last of the DRAM buffers */
block|{
name|mode
index|[
name|chn
index|]
operator||=
literal|0x08
expr_stmt|;
comment|/* Enable loop */
name|ramp_mode
index|[
name|chn
index|]
operator|=
literal|0x03
expr_stmt|;
comment|/* Disable rollover */
block|}
else|else
block|{
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
name|ramp_mode
index|[
name|chn
index|]
operator|=
literal|0x04
expr_stmt|;
comment|/* Enable rollover bit */
block|}
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|gus_voice_freq
argument_list|(
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|gus_sampling_channels
operator|==
literal|1
condition|)
name|gus_voice_balance
argument_list|(
literal|7
argument_list|)
expr_stmt|;
comment|/* mono */
elseif|else
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
name|gus_voice_balance
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* left */
else|else
name|gus_voice_balance
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* right */
if|if
condition|(
operator|!
name|pcm_active
condition|)
comment|/* Voice not started yet */
block|{
comment|/* 	   * The playback was not started yet (or there has been a pause). 	   * Start the voice (again) and ask for a rollover irq at the end of 	   * this_one block. If this_one one is last of the buffers, use just 	   * the normal loop with irq. 	   */
name|gus_voice_off
argument_list|()
expr_stmt|;
comment|/* It could already be running */
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_volume
argument_list|(
literal|4000
argument_list|)
expr_stmt|;
name|gus_ramp_range
argument_list|(
literal|65
argument_list|,
literal|4030
argument_list|)
expr_stmt|;
name|gus_write_addr
argument_list|(
literal|0x0a
argument_list|,
name|dram_loc
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Starting position */
name|gus_write_addr
argument_list|(
literal|0x02
argument_list|,
name|chn
operator|*
name|pcm_banksize
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop start location */
if|if
condition|(
name|chn
operator|!=
literal|0
condition|)
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|pcm_banksize
operator|+
operator|(
name|pcm_bsize
operator|*
name|pcm_nblk
operator|)
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
block|}
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|dram_loc
operator|+
name|pcm_datasize
index|[
name|this_one
index|]
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
else|else
name|mode
index|[
name|chn
index|]
operator||=
literal|0x08
expr_stmt|;
comment|/* Enable loop */
if|if
condition|(
name|pcm_datasize
index|[
name|this_one
index|]
operator|!=
name|pcm_bsize
condition|)
block|{
comment|/* Incomplete block. Possibly the last one. */
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
block|{
name|mode
index|[
name|chn
index|]
operator|&=
operator|~
literal|0x08
expr_stmt|;
comment|/* Disable loop */
name|mode
index|[
name|chn
index|]
operator||=
literal|0x20
expr_stmt|;
comment|/* Enable loop IRQ */
name|voices
index|[
literal|0
index|]
operator|.
name|loop_irq_mode
operator|=
name|LMODE_PCM_STOP
expr_stmt|;
name|ramp_mode
index|[
name|chn
index|]
operator|=
literal|0x03
expr_stmt|;
comment|/* No rollover bit */
block|}
else|else
block|{
name|gus_write_addr
argument_list|(
literal|0x04
argument_list|,
name|dram_loc
operator|+
name|pcm_datasize
index|[
name|this_one
index|]
argument_list|,
name|is16bits
argument_list|)
expr_stmt|;
comment|/* Loop end location */
name|mode
index|[
name|chn
index|]
operator|&=
operator|~
literal|0x08
expr_stmt|;
comment|/* Disable loop */
block|}
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
name|gus_sampling_channels
condition|;
name|chn
operator|++
control|)
block|{
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|chn
argument_list|)
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
name|ramp_mode
index|[
name|chn
index|]
argument_list|)
expr_stmt|;
name|gus_voice_on
argument_list|(
name|mode
index|[
name|chn
index|]
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
name|pcm_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_transfer_output_block
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|long
name|buf
parameter_list|,
name|int
name|total_count
parameter_list|,
name|int
name|intrflag
parameter_list|,
name|int
name|chn
parameter_list|)
block|{
comment|/*    * This routine transfers one block of audio data to the DRAM. In mono mode    * it's called just once. When in stereo mode, this_one routine is called    * once for both channels.    *     * The left/mono channel data is transferred to the beginning of dram and the    * right data to the area pointed by gus_page_size.    */
name|int
name|this_one
decl_stmt|,
name|count
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|dma_command
decl_stmt|;
name|unsigned
name|long
name|address
decl_stmt|,
name|hold_address
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|count
operator|=
name|total_count
operator|/
name|gus_sampling_channels
expr_stmt|;
if|if
condition|(
name|chn
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pcm_qlen
operator|>=
name|pcm_nblk
condition|)
name|printk
argument_list|(
literal|"GUS Warning: PCM buffers out of sync\n"
argument_list|)
expr_stmt|;
name|this_one
operator|=
name|pcm_current_block
operator|=
name|pcm_tail
expr_stmt|;
name|pcm_qlen
operator|++
expr_stmt|;
name|pcm_tail
operator|=
operator|(
name|pcm_tail
operator|+
literal|1
operator|)
operator|%
name|pcm_nblk
expr_stmt|;
name|pcm_datasize
index|[
name|this_one
index|]
operator|=
name|count
expr_stmt|;
block|}
else|else
name|this_one
operator|=
name|pcm_current_block
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable GF1 DMA */
name|DMAbuf_start_dma
argument_list|(
name|dev
argument_list|,
name|buf
operator|+
operator|(
name|chn
operator|*
name|count
operator|)
argument_list|,
name|count
argument_list|,
name|DMA_MODE_WRITE
argument_list|)
expr_stmt|;
name|address
operator|=
name|this_one
operator|*
name|pcm_bsize
expr_stmt|;
name|address
operator|+=
name|chn
operator|*
name|pcm_banksize
expr_stmt|;
if|if
condition|(
name|sound_dsp_dmachan
index|[
name|dev
index|]
operator|>
literal|3
condition|)
block|{
name|hold_address
operator|=
name|address
expr_stmt|;
name|address
operator|=
name|address
operator|>>
literal|1
expr_stmt|;
name|address
operator|&=
literal|0x0001ffffL
expr_stmt|;
name|address
operator||=
operator|(
name|hold_address
operator|&
literal|0x000c0000L
operator|)
expr_stmt|;
block|}
name|gus_write16
argument_list|(
literal|0x42
argument_list|,
operator|(
name|address
operator|>>
literal|4
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* DRAM DMA address */
name|dma_command
operator|=
literal|0x21
expr_stmt|;
comment|/* IRQ enable, DMA start */
if|if
condition|(
name|gus_sampling_bits
operator|!=
literal|8
condition|)
name|dma_command
operator||=
literal|0x40
expr_stmt|;
comment|/* 16 bit _DATA_ */
else|else
name|dma_command
operator||=
literal|0x80
expr_stmt|;
comment|/* Invert MSB */
if|if
condition|(
name|sound_dsp_dmachan
index|[
name|dev
index|]
operator|>
literal|3
condition|)
name|dma_command
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bit DMA channel */
name|gus_write8
argument_list|(
literal|0x41
argument_list|,
name|dma_command
argument_list|)
expr_stmt|;
comment|/* Kick on */
if|if
condition|(
name|chn
operator|==
operator|(
name|gus_sampling_channels
operator|-
literal|1
operator|)
condition|)
comment|/* Last channel */
block|{
comment|/* Last (right or mono) channel data */
name|active_device
operator|=
name|GUS_DEV_PCM_DONE
expr_stmt|;
if|if
condition|(
operator|!
name|pcm_active
operator|&&
operator|(
name|pcm_qlen
operator|>
literal|2
operator|||
name|count
operator|<
name|pcm_bsize
operator|)
condition|)
block|{
name|play_next_pcm_block
argument_list|()
expr_stmt|;
block|}
block|}
else|else
comment|/* Left channel data. The right channel is 				 * transferred after DMA interrupt */
name|active_device
operator|=
name|GUS_DEV_PCM_CONTINUE
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_output_block
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|long
name|buf
parameter_list|,
name|int
name|total_count
parameter_list|,
name|int
name|intrflag
parameter_list|)
block|{
name|pcm_current_buf
operator|=
name|buf
expr_stmt|;
name|pcm_current_count
operator|=
name|total_count
expr_stmt|;
name|pcm_current_intrflag
operator|=
name|intrflag
expr_stmt|;
name|pcm_current_dev
operator|=
name|dev
expr_stmt|;
name|gus_transfer_output_block
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
name|total_count
argument_list|,
name|intrflag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_sampling_start_input
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|long
name|buf
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|intrflag
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|char
name|mode
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|DMAbuf_start_dma
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
name|count
argument_list|,
name|DMA_MODE_READ
argument_list|)
expr_stmt|;
name|mode
operator|=
literal|0xa0
expr_stmt|;
comment|/* DMA IRQ enable, invert MSB */
if|if
condition|(
name|sound_dsp_dmachan
index|[
name|dev
index|]
operator|>
literal|3
condition|)
name|mode
operator||=
literal|0x04
expr_stmt|;
comment|/* 16 bit DMA channel */
if|if
condition|(
name|gus_sampling_channels
operator|>
literal|1
condition|)
name|mode
operator||=
literal|0x02
expr_stmt|;
comment|/* Stereo */
name|mode
operator||=
literal|0x01
expr_stmt|;
comment|/* DMA enable */
name|gus_write8
argument_list|(
literal|0x49
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_prepare_for_input
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|bsize
parameter_list|,
name|int
name|bcount
parameter_list|)
block|{
name|unsigned
name|int
name|rate
decl_stmt|;
name|rate
operator|=
operator|(
literal|9878400
operator|/
operator|(
name|gus_sampling_speed
operator|+
literal|2
operator|)
operator|)
operator|/
literal|16
expr_stmt|;
name|gus_write8
argument_list|(
literal|0x48
argument_list|,
name|rate
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* Set sampling frequency */
if|if
condition|(
name|gus_sampling_bits
operator|!=
literal|8
condition|)
block|{
name|printk
argument_list|(
literal|"GUS Error: 16 bit recording not supported\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_sampling_prepare_for_output
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|bsize
parameter_list|,
name|int
name|bcount
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|long
name|mem_ptr
decl_stmt|,
name|mem_size
decl_stmt|;
name|mem_ptr
operator|=
literal|0
expr_stmt|;
name|mem_size
operator|=
name|gus_mem_size
operator|/
name|gus_sampling_channels
expr_stmt|;
if|if
condition|(
name|mem_size
operator|>
operator|(
literal|256
operator|*
literal|1024
operator|)
condition|)
name|mem_size
operator|=
literal|256
operator|*
literal|1024
expr_stmt|;
name|pcm_bsize
operator|=
name|bsize
operator|/
name|gus_sampling_channels
expr_stmt|;
name|pcm_head
operator|=
name|pcm_tail
operator|=
name|pcm_qlen
operator|=
literal|0
expr_stmt|;
name|pcm_nblk
operator|=
name|MAX_PCM_BUFFERS
expr_stmt|;
if|if
condition|(
operator|(
name|pcm_bsize
operator|*
name|pcm_nblk
operator|)
operator|>
name|mem_size
condition|)
name|pcm_nblk
operator|=
name|mem_size
operator|/
name|pcm_bsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcm_nblk
condition|;
name|i
operator|++
control|)
name|pcm_datasize
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|pcm_banksize
operator|=
name|pcm_nblk
operator|*
name|pcm_bsize
expr_stmt|;
if|if
condition|(
name|gus_sampling_bits
operator|!=
literal|8
operator|&&
name|pcm_banksize
operator|==
operator|(
literal|256
operator|*
literal|1024
operator|)
condition|)
name|pcm_nblk
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gus_has_output_drained
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
return|return
operator|!
name|pcm_qlen
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gus_copy_from_user
parameter_list|(
name|int
name|dev
parameter_list|,
name|char
modifier|*
name|localbuf
parameter_list|,
name|int
name|localoffs
parameter_list|,
name|snd_rw_buf
modifier|*
name|userbuf
parameter_list|,
name|int
name|useroffs
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|gus_sampling_channels
operator|==
literal|1
condition|)
name|COPY_FROM_USER
argument_list|(
operator|&
name|localbuf
index|[
name|localoffs
index|]
argument_list|,
name|userbuf
argument_list|,
name|useroffs
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|gus_sampling_bits
operator|==
literal|8
condition|)
block|{
name|int
name|in_left
init|=
name|useroffs
decl_stmt|;
name|int
name|in_right
init|=
name|useroffs
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|out_left
decl_stmt|,
modifier|*
name|out_right
decl_stmt|;
name|int
name|i
decl_stmt|;
name|len
operator|/=
literal|2
expr_stmt|;
name|localoffs
operator|/=
literal|2
expr_stmt|;
name|out_left
operator|=
operator|&
name|localbuf
index|[
name|localoffs
index|]
expr_stmt|;
name|out_right
operator|=
name|out_left
operator|+
name|pcm_bsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|GET_BYTE_FROM_USER
argument_list|(
operator|*
name|out_left
operator|++
argument_list|,
name|userbuf
argument_list|,
name|in_left
argument_list|)
expr_stmt|;
name|in_left
operator|+=
literal|2
expr_stmt|;
name|GET_BYTE_FROM_USER
argument_list|(
operator|*
name|out_right
operator|++
argument_list|,
name|userbuf
argument_list|,
name|in_right
argument_list|)
expr_stmt|;
name|in_right
operator|+=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|in_left
init|=
name|useroffs
decl_stmt|;
name|int
name|in_right
init|=
name|useroffs
operator|+
literal|1
decl_stmt|;
name|short
modifier|*
name|out_left
decl_stmt|,
modifier|*
name|out_right
decl_stmt|;
name|int
name|i
decl_stmt|;
name|len
operator|/=
literal|4
expr_stmt|;
name|localoffs
operator|/=
literal|4
expr_stmt|;
name|out_left
operator|=
operator|(
name|short
operator|*
operator|)
operator|&
name|localbuf
index|[
name|localoffs
index|]
expr_stmt|;
name|out_right
operator|=
name|out_left
operator|+
operator|(
name|pcm_bsize
operator|/
literal|2
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|GET_SHORT_FROM_USER
argument_list|(
operator|*
name|out_left
operator|++
argument_list|,
operator|(
name|short
operator|*
operator|)
name|userbuf
argument_list|,
name|in_left
argument_list|)
expr_stmt|;
name|in_left
operator|+=
literal|2
expr_stmt|;
name|GET_SHORT_FROM_USER
argument_list|(
operator|*
name|out_right
operator|++
argument_list|,
operator|(
name|short
operator|*
operator|)
name|userbuf
argument_list|,
name|in_right
argument_list|)
expr_stmt|;
name|in_right
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|audio_operations
name|gus_sampling_operations
init|=
block|{
literal|"Gravis UltraSound"
block|,
name|gus_sampling_open
block|,
comment|/* */
name|gus_sampling_close
block|,
comment|/* */
name|gus_sampling_output_block
block|,
comment|/* */
name|gus_sampling_start_input
block|,
comment|/* */
name|gus_sampling_ioctl
block|,
comment|/* */
name|gus_sampling_prepare_for_input
block|,
comment|/* */
name|gus_sampling_prepare_for_output
block|,
comment|/* */
name|gus_sampling_reset
block|,
comment|/* */
name|gus_sampling_reset
block|,
comment|/* halt_xfer */
name|gus_has_output_drained
block|,
name|gus_copy_from_user
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|guswave_patchmgr
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|patmgr_info
modifier|*
name|rec
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
switch|switch
condition|(
name|rec
operator|->
name|command
condition|)
block|{
case|case
name|PM_GET_DEVTYPE
case|:
name|rec
operator|->
name|parm1
operator|=
name|PMTYPE_WAVE
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|PM_GET_NRPGM
case|:
name|rec
operator|->
name|parm1
operator|=
name|MAX_PATCH
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|PM_GET_PGMMAP
case|:
name|rec
operator|->
name|parm1
operator|=
name|MAX_PATCH
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_PATCH
condition|;
name|i
operator|++
control|)
block|{
name|int
name|ptr
init|=
name|patch_table
index|[
name|i
index|]
decl_stmt|;
name|rec
operator|->
name|data
operator|.
name|data8
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ptr
operator|>=
literal|0
operator|&&
name|ptr
operator|<
name|free_sample
condition|)
block|{
name|rec
operator|->
name|data
operator|.
name|data8
index|[
name|i
index|]
operator|++
expr_stmt|;
name|ptr
operator|=
name|samples
index|[
name|ptr
index|]
operator|.
name|key
expr_stmt|;
comment|/* Follow link */
block|}
block|}
return|return
literal|0
return|;
break|break;
case|case
name|PM_GET_PGM_PATCHES
case|:
block|{
name|int
name|ptr
init|=
name|patch_table
index|[
name|rec
operator|->
name|parm1
index|]
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ptr
operator|>=
literal|0
operator|&&
name|ptr
operator|<
name|free_sample
condition|)
block|{
name|rec
operator|->
name|data
operator|.
name|data32
index|[
name|n
operator|++
index|]
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|=
name|samples
index|[
name|ptr
index|]
operator|.
name|key
expr_stmt|;
comment|/* Follow link */
block|}
block|}
name|rec
operator|->
name|parm1
operator|=
name|n
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|PM_GET_PATCH
case|:
block|{
name|int
name|ptr
init|=
name|rec
operator|->
name|parm1
decl_stmt|;
name|struct
name|patch_info
modifier|*
name|pat
decl_stmt|;
if|if
condition|(
name|ptr
operator|<
literal|0
operator|||
name|ptr
operator|>=
name|free_sample
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|memcpy
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|samples
index|[
name|ptr
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|patch_info
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|=
operator|(
expr|struct
name|patch_info
operator|*
operator|)
name|rec
operator|->
name|data
operator|.
name|data8
expr_stmt|;
name|pat
operator|->
name|key
operator|=
name|GUS_PATCH
expr_stmt|;
comment|/* Restore patch type */
name|rec
operator|->
name|parm1
operator|=
name|sample_ptrs
index|[
name|ptr
index|]
expr_stmt|;
comment|/* DRAM address */
name|rec
operator|->
name|parm2
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|patch_info
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
break|break;
case|case
name|PM_SET_PATCH
case|:
block|{
name|int
name|ptr
init|=
name|rec
operator|->
name|parm1
decl_stmt|;
name|struct
name|patch_info
modifier|*
name|pat
decl_stmt|;
if|if
condition|(
name|ptr
operator|<
literal|0
operator|||
name|ptr
operator|>=
name|free_sample
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|pat
operator|=
operator|(
expr|struct
name|patch_info
operator|*
operator|)
name|rec
operator|->
name|data
operator|.
name|data8
expr_stmt|;
if|if
condition|(
name|pat
operator|->
name|len
operator|>
name|samples
index|[
name|ptr
index|]
operator|.
name|len
condition|)
comment|/* Cannot expand sample */
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|pat
operator|->
name|key
operator|=
name|samples
index|[
name|ptr
index|]
operator|.
name|key
expr_stmt|;
comment|/* Ensure the link is correct */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|samples
index|[
name|ptr
index|]
argument_list|,
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|patch_info
argument_list|)
argument_list|)
expr_stmt|;
name|pat
operator|->
name|key
operator|=
name|GUS_PATCH
expr_stmt|;
block|}
return|return
literal|0
return|;
break|break;
case|case
name|PM_READ_PATCH
case|:
comment|/* Returns a block of wave data from the DRAM */
block|{
name|int
name|sample
init|=
name|rec
operator|->
name|parm1
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|offs
init|=
name|rec
operator|->
name|parm2
decl_stmt|;
name|int
name|l
init|=
name|rec
operator|->
name|parm3
decl_stmt|;
if|if
condition|(
name|sample
operator|<
literal|0
operator|||
name|sample
operator|>=
name|free_sample
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|offs
operator|<
literal|0
operator|||
name|offs
operator|>=
name|samples
index|[
name|sample
index|]
operator|.
name|len
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* Invalid offset */
name|n
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|len
operator|-
name|offs
expr_stmt|;
comment|/* Nr of bytes left */
if|if
condition|(
name|l
operator|>
name|n
condition|)
name|l
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|)
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<=
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* Was there a bug? */
name|offs
operator|+=
name|sample_ptrs
index|[
name|sample
index|]
expr_stmt|;
comment|/* Begin offsess + offset to DRAM */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|l
condition|;
name|n
operator|++
control|)
name|rec
operator|->
name|data
operator|.
name|data8
index|[
name|n
index|]
operator|=
name|gus_peek
argument_list|(
name|offs
operator|++
argument_list|)
expr_stmt|;
name|rec
operator|->
name|parm1
operator|=
name|n
expr_stmt|;
comment|/* Nr of bytes copied */
block|}
return|return
literal|0
return|;
break|break;
case|case
name|PM_WRITE_PATCH
case|:
comment|/* Writes a block of wave data to the DRAM */
block|{
name|int
name|sample
init|=
name|rec
operator|->
name|parm1
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|offs
init|=
name|rec
operator|->
name|parm2
decl_stmt|;
name|int
name|l
init|=
name|rec
operator|->
name|parm3
decl_stmt|;
if|if
condition|(
name|sample
operator|<
literal|0
operator|||
name|sample
operator|>=
name|free_sample
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|offs
operator|<
literal|0
operator|||
name|offs
operator|>=
name|samples
index|[
name|sample
index|]
operator|.
name|len
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* Invalid offset */
name|n
operator|=
name|samples
index|[
name|sample
index|]
operator|.
name|len
operator|-
name|offs
expr_stmt|;
comment|/* Nr of bytes left */
if|if
condition|(
name|l
operator|>
name|n
condition|)
name|l
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|l
operator|>
sizeof|sizeof
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|)
condition|)
name|l
operator|=
sizeof|sizeof
argument_list|(
name|rec
operator|->
name|data
operator|.
name|data8
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|<=
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* Was there a bug? */
name|offs
operator|+=
name|sample_ptrs
index|[
name|sample
index|]
expr_stmt|;
comment|/* Begin offsess + offset to DRAM */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|l
condition|;
name|n
operator|++
control|)
name|gus_poke
argument_list|(
name|offs
operator|++
argument_list|,
name|rec
operator|->
name|data
operator|.
name|data8
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|rec
operator|->
name|parm1
operator|=
name|n
expr_stmt|;
comment|/* Nr of bytes copied */
block|}
return|return
literal|0
return|;
break|break;
default|default:
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|synth_operations
name|guswave_operations
init|=
block|{
operator|&
name|gus_info
block|,
name|SYNTH_TYPE_SAMPLE
block|,
name|SAMPLE_TYPE_GUS
block|,
name|guswave_open
block|,
name|guswave_close
block|,
name|guswave_ioctl
block|,
name|guswave_kill_note
block|,
name|guswave_start_note
block|,
name|guswave_set_instr
block|,
name|guswave_reset
block|,
name|guswave_hw_control
block|,
name|guswave_load_patch
block|,
name|guswave_aftertouch
block|,
name|guswave_controller
block|,
name|guswave_panning
block|,
name|guswave_patchmgr
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|long
name|gus_wave_init
parameter_list|(
name|long
name|mem_start
parameter_list|,
name|int
name|irq
parameter_list|,
name|int
name|dma
parameter_list|)
block|{
name|printk
argument_list|(
literal|"snd4:<Gravis UltraSound %dk>"
argument_list|,
name|gus_mem_size
operator|/
literal|1024
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|<
literal|0
operator|||
name|irq
operator|>
literal|15
condition|)
block|{
name|printk
argument_list|(
literal|"ERROR! Invalid IRQ#%d. GUS Disabled"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
name|mem_start
return|;
block|}
if|if
condition|(
name|dma
operator|<
literal|0
operator|||
name|dma
operator|>
literal|7
condition|)
block|{
name|printk
argument_list|(
literal|"ERROR! Invalid DMA#%d. GUS Disabled"
argument_list|,
name|dma
argument_list|)
expr_stmt|;
return|return
name|mem_start
return|;
block|}
name|gus_irq
operator|=
name|irq
expr_stmt|;
name|gus_dma
operator|=
name|dma
expr_stmt|;
if|if
condition|(
name|num_synths
operator|>=
name|MAX_SYNTH_DEV
condition|)
name|printk
argument_list|(
literal|"GUS Error: Too many synthesizers\n"
argument_list|)
expr_stmt|;
else|else
name|synth_devs
index|[
name|num_synths
operator|++
index|]
operator|=
operator|&
name|guswave_operations
expr_stmt|;
name|reset_sample_memory
argument_list|()
expr_stmt|;
name|gus_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_dspdevs
operator|<
name|MAX_DSP_DEV
condition|)
block|{
name|dsp_devs
index|[
name|gus_devnum
operator|=
name|num_dspdevs
operator|++
index|]
operator|=
operator|&
name|gus_sampling_operations
expr_stmt|;
name|sound_dsp_dmachan
index|[
name|gus_devnum
index|]
operator|=
name|dma
expr_stmt|;
name|sound_buffcounts
index|[
name|gus_devnum
index|]
operator|=
literal|1
expr_stmt|;
name|sound_buffsizes
index|[
name|gus_devnum
index|]
operator|=
name|DSP_BUFFSIZE
expr_stmt|;
name|sound_dma_automode
index|[
name|gus_devnum
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|printk
argument_list|(
literal|"GUS: Too many PCM devices available\n"
argument_list|)
expr_stmt|;
return|return
name|mem_start
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_loop_irq
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|unsigned
name|char
name|tmp
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|parm
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gus_read8
argument_list|(
literal|0x00
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Disable wave IRQ for this_one voice */
name|gus_write8
argument_list|(
literal|0x00
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|mode
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_mode
operator|=
literal|0
expr_stmt|;
name|parm
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|loop_irq_parm
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|LMODE_FINISH
case|:
comment|/* Final loop finished, shoot volume down */
if|if
condition|(
operator|(
name|gus_read16
argument_list|(
literal|0x09
argument_list|)
operator|>>
literal|4
operator|)
operator|<
literal|100
condition|)
comment|/* Get current volume */
block|{
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|gus_voice_init
argument_list|(
name|voice
argument_list|)
expr_stmt|;
return|return;
block|}
name|gus_ramp_range
argument_list|(
literal|65
argument_list|,
literal|4065
argument_list|)
expr_stmt|;
name|gus_ramp_rate
argument_list|(
literal|0
argument_list|,
literal|63
argument_list|)
expr_stmt|;
comment|/* Fastest possible rate */
name|gus_rampon
argument_list|(
literal|0x20
operator||
literal|0x40
argument_list|)
expr_stmt|;
comment|/* Ramp down, once, irq */
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
name|VMODE_HALT
expr_stmt|;
break|break;
case|case
name|LMODE_PCM_STOP
case|:
name|pcm_active
operator|=
literal|0
expr_stmt|;
comment|/* Requires extensive processing */
case|case
name|LMODE_PCM
case|:
block|{
name|int
name|orig_qlen
init|=
name|pcm_qlen
decl_stmt|;
name|pcm_qlen
operator|--
expr_stmt|;
name|pcm_head
operator|=
operator|(
name|pcm_head
operator|+
literal|1
operator|)
operator|%
name|pcm_nblk
expr_stmt|;
if|if
condition|(
name|pcm_qlen
condition|)
block|{
name|play_next_pcm_block
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* Out of data. Just stop the voice */
name|gus_voice_off
argument_list|()
expr_stmt|;
name|gus_rampoff
argument_list|()
expr_stmt|;
name|pcm_active
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|orig_qlen
operator|==
name|pcm_nblk
condition|)
block|{
name|DMAbuf_outputintr
argument_list|(
name|gus_devnum
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
empty_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_volume_irq
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|unsigned
name|char
name|tmp
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|parm
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|gus_select_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gus_read8
argument_list|(
literal|0x0d
argument_list|)
expr_stmt|;
name|tmp
operator|&=
operator|~
literal|0x20
expr_stmt|;
comment|/* Disable volume ramp IRQ */
name|gus_write8
argument_list|(
literal|0x0d
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|mode
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_mode
operator|=
literal|0
expr_stmt|;
name|parm
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|volume_irq_parm
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|VMODE_HALT
case|:
comment|/* Decay phase finished */
name|gus_voice_init
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
case|case
name|VMODE_ENVELOPE
case|:
name|gus_rampoff
argument_list|()
expr_stmt|;
name|step_envelope
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gus_voice_irq
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|wave_ignore
init|=
literal|0
decl_stmt|,
name|volume_ignore
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|voice_bit
decl_stmt|;
name|unsigned
name|char
name|src
decl_stmt|,
name|voice
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|src
operator|=
name|gus_read8
argument_list|(
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* Get source info */
name|voice
operator|=
name|src
operator|&
literal|0x1f
expr_stmt|;
name|src
operator|&=
literal|0xc0
expr_stmt|;
if|if
condition|(
name|src
operator|==
operator|(
literal|0x80
operator||
literal|0x40
operator|)
condition|)
return|return;
comment|/* No interrupt */
name|voice_bit
operator|=
literal|1
operator|<<
name|voice
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|src
operator|&
literal|0x80
operator|)
condition|)
comment|/* Wave IRQ pending */
if|if
condition|(
operator|!
operator|(
name|wave_ignore
operator|&
name|voice_bit
operator|)
operator|&&
name|voice
operator|<
name|nr_voices
condition|)
comment|/* Not done yet */
block|{
name|wave_ignore
operator||=
name|voice_bit
expr_stmt|;
name|do_loop_irq
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|src
operator|&
literal|0x40
operator|)
condition|)
comment|/* Volume IRQ pending */
if|if
condition|(
operator|!
operator|(
name|volume_ignore
operator|&
name|voice_bit
operator|)
operator|&&
name|voice
operator|<
name|nr_voices
condition|)
comment|/* Not done yet */
block|{
name|volume_ignore
operator||=
name|voice_bit
expr_stmt|;
name|do_volume_irq
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|guswave_dma_irq
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|status
decl_stmt|;
name|status
operator|=
name|gus_look8
argument_list|(
literal|0x41
argument_list|)
expr_stmt|;
comment|/* Get DMA IRQ Status */
if|if
condition|(
name|status
operator|&
literal|0x40
condition|)
comment|/* DMA Irq pending */
switch|switch
condition|(
name|active_device
condition|)
block|{
case|case
name|GUS_DEV_WAVE
case|:
if|if
condition|(
name|dram_sleep_flag
condition|)
name|WAKE_UP
argument_list|(
name|dram_sleeper
argument_list|)
expr_stmt|;
break|break;
case|case
name|GUS_DEV_PCM_CONTINUE
case|:
name|gus_transfer_output_block
argument_list|(
name|pcm_current_dev
argument_list|,
name|pcm_current_buf
argument_list|,
name|pcm_current_count
argument_list|,
name|pcm_current_intrflag
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|GUS_DEV_PCM_DONE
case|:
if|if
condition|(
name|pcm_qlen
operator|<
name|pcm_nblk
condition|)
block|{
name|DMAbuf_outputintr
argument_list|(
name|gus_devnum
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
name|status
operator|=
name|gus_look8
argument_list|(
literal|0x49
argument_list|)
expr_stmt|;
comment|/* Get Sampling IRQ Status */
if|if
condition|(
name|status
operator|&
literal|0x40
condition|)
comment|/* Sampling Irq pending */
block|{
name|DMAbuf_inputintr
argument_list|(
name|gus_devnum
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

