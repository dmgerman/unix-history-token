begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/mpu401.c  *   * The low level driver for Roland MPU-401 compatible Midi cards.  *   * Copyright by Hannu Savolainen 1993  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * Modified: Riccardo Facchetti  24 Mar 1995 - Added the Audio Excel DSP 16  * initialization routine.  */
end_comment

begin_define
define|#
directive|define
name|USE_SEQ_MACROS
end_define

begin_define
define|#
directive|define
name|USE_SIMPLE_MACROS
end_define

begin_include
include|#
directive|include
file|<i386/isa/sound/sound_config.h>
end_include

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|CONFIG_MPU401
argument_list|)
operator|||
name|defined
argument_list|(
name|CONFIG_MPU_EMU
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|CONFIG_MIDI
argument_list|)
end_if

begin_include
include|#
directive|include
file|<i386/isa/sound/coproc.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|init_sequence
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NOTE! pos 0 = len, start pos 1. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_SEQUENCER
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|timer_mode
init|=
name|TMR_INTERNAL
decl_stmt|,
name|timer_caps
init|=
name|TMR_INTERNAL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|mpu_config
block|{
name|int
name|base
decl_stmt|;
comment|/* I/O base */
name|int
name|irq
decl_stmt|;
name|int
name|opened
decl_stmt|;
comment|/* Open mode */
name|int
name|devno
decl_stmt|;
name|int
name|synthno
decl_stmt|;
name|int
name|uart_mode
decl_stmt|;
name|int
name|initialized
decl_stmt|;
name|int
name|mode
decl_stmt|;
define|#
directive|define
name|MODE_MIDI
value|1
define|#
directive|define
name|MODE_SYNTH
value|2
name|u_char
name|version
decl_stmt|,
name|revision
decl_stmt|;
name|u_int
name|capabilities
decl_stmt|;
define|#
directive|define
name|MPU_CAP_INTLG
value|0x10000000
define|#
directive|define
name|MPU_CAP_SYNC
value|0x00000010
define|#
directive|define
name|MPU_CAP_FSK
value|0x00000020
define|#
directive|define
name|MPU_CAP_CLS
value|0x00000040
define|#
directive|define
name|MPU_CAP_SMPTE
value|0x00000080
define|#
directive|define
name|MPU_CAP_2PORT
value|0x00000001
name|int
name|timer_flag
decl_stmt|;
define|#
directive|define
name|MBUF_MAX
value|10
define|#
directive|define
name|BUFTEST
parameter_list|(
name|dc
parameter_list|)
value|if (dc->m_ptr>= MBUF_MAX || dc->m_ptr< 0) \ 	{printf("MPU: Invalid buffer pointer %d/%d, s=%d\n", dc->m_ptr, dc->m_left, dc->m_state);dc->m_ptr--;}
name|int
name|m_busy
decl_stmt|;
name|u_char
name|m_buf
index|[
name|MBUF_MAX
index|]
decl_stmt|;
name|int
name|m_ptr
decl_stmt|;
name|int
name|m_state
decl_stmt|;
name|int
name|m_left
decl_stmt|;
name|u_char
name|last_status
decl_stmt|;
name|void
function_decl|(
modifier|*
name|inputintr
function_decl|)
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_char
name|data
parameter_list|)
function_decl|;
name|int
name|shared_irq
decl_stmt|;
name|sound_os_info
modifier|*
name|osp
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DATAPORT
parameter_list|(
name|base
parameter_list|)
value|(base)
end_define

begin_define
define|#
directive|define
name|COMDPORT
parameter_list|(
name|base
parameter_list|)
value|(base+1)
end_define

begin_define
define|#
directive|define
name|STATPORT
parameter_list|(
name|base
parameter_list|)
value|(base+1)
end_define

begin_define
define|#
directive|define
name|mpu401_status
parameter_list|(
name|devc
parameter_list|)
value|inb( STATPORT(devc->base))
end_define

begin_define
define|#
directive|define
name|input_avail
parameter_list|(
name|devc
parameter_list|)
value|(!(mpu401_status(devc)&INPUT_AVAIL))
end_define

begin_define
define|#
directive|define
name|output_ready
parameter_list|(
name|devc
parameter_list|)
value|(!(mpu401_status(devc)&OUTPUT_READY))
end_define

begin_define
define|#
directive|define
name|write_command
parameter_list|(
name|devc
parameter_list|,
name|cmd
parameter_list|)
value|outb( COMDPORT(devc->base),  cmd)
end_define

begin_define
define|#
directive|define
name|read_data
parameter_list|(
name|devc
parameter_list|)
value|inb( DATAPORT(devc->base))
end_define

begin_define
define|#
directive|define
name|write_data
parameter_list|(
name|devc
parameter_list|,
name|byte
parameter_list|)
value|outb( DATAPORT(devc->base),  byte)
end_define

begin_define
define|#
directive|define
name|OUTPUT_READY
value|0x40
end_define

begin_define
define|#
directive|define
name|INPUT_AVAIL
value|0x80
end_define

begin_define
define|#
directive|define
name|MPU_ACK
value|0xFE
end_define

begin_define
define|#
directive|define
name|MPU_RESET
value|0xFF
end_define

begin_define
define|#
directive|define
name|UART_MODE_ON
value|0x3F
end_define

begin_decl_stmt
specifier|static
name|struct
name|mpu_config
name|dev_conf
index|[
name|MAX_MIDI_DEV
index|]
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_mpu_devs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|irq2dev
index|[
literal|17
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|reset_mpu401
parameter_list|(
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_uart_mode
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|,
name|int
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpu_timer_init
parameter_list|(
name|int
name|midi_dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mpu_timer_interrupt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timer_ext_event
parameter_list|(
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|,
name|int
name|event
parameter_list|,
name|int
name|parm
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|synth_info
name|mpu_synth_info_proto
init|=
block|{
literal|"MPU-401 MIDI interface"
block|,
literal|0
block|,
name|SYNTH_TYPE_MIDI
block|,
literal|0
block|,
literal|0
block|,
literal|128
block|,
literal|0
block|,
literal|128
block|,
name|SYNTH_CAP_INPUT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|synth_info
name|mpu_synth_info
index|[
name|MAX_MIDI_DEV
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * States for the input scanner  */
end_comment

begin_define
define|#
directive|define
name|ST_INIT
value|0
end_define

begin_comment
comment|/* Ready for timing byte or msg */
end_comment

begin_define
define|#
directive|define
name|ST_TIMED
value|1
end_define

begin_comment
comment|/* Leading timing byte rcvd */
end_comment

begin_define
define|#
directive|define
name|ST_DATABYTE
value|2
end_define

begin_comment
comment|/* Waiting for (nr_left) data bytes */
end_comment

begin_define
define|#
directive|define
name|ST_SYSMSG
value|100
end_define

begin_comment
comment|/* System message (sysx etc). */
end_comment

begin_define
define|#
directive|define
name|ST_SYSEX
value|101
end_define

begin_comment
comment|/* System exclusive msg */
end_comment

begin_define
define|#
directive|define
name|ST_MTC
value|102
end_define

begin_comment
comment|/* Midi Time Code (MTC) qframe msg */
end_comment

begin_define
define|#
directive|define
name|ST_SONGSEL
value|103
end_define

begin_comment
comment|/* Song select */
end_comment

begin_define
define|#
directive|define
name|ST_SONGPOS
value|104
end_define

begin_comment
comment|/* Song position pointer */
end_comment

begin_decl_stmt
specifier|static
name|u_char
name|len_tab
index|[]
init|=
comment|/* # of data bytes following a status */
block|{
literal|2
block|,
comment|/* 8x */
literal|2
block|,
comment|/* 9x */
literal|2
block|,
comment|/* Ax */
literal|2
block|,
comment|/* Bx */
literal|1
block|,
comment|/* Cx */
literal|1
block|,
comment|/* Dx */
literal|2
block|,
comment|/* Ex */
literal|0
comment|/* Fx */
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CONFIG_SEQUENCER
end_ifndef

begin_define
define|#
directive|define
name|STORE
parameter_list|(
name|cmd
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STORE
parameter_list|(
name|cmd
parameter_list|)
define|\
value|{ \   int len; \   u_char obuf[8]; \   cmd; \   seq_input_event(obuf, len); \ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_seqbuf
value|obuf
end_define

begin_define
define|#
directive|define
name|_seqbufptr
value|0
end_define

begin_define
define|#
directive|define
name|_SEQ_ADVBUF
parameter_list|(
name|x
parameter_list|)
value|len=x
end_define

begin_function
specifier|static
name|int
name|mpu_input_scanner
parameter_list|(
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|,
name|u_char
name|midic
parameter_list|)
block|{
switch|switch
condition|(
name|devc
operator|->
name|m_state
condition|)
block|{
case|case
name|ST_INIT
case|:
switch|switch
condition|(
name|midic
condition|)
block|{
case|case
literal|0xf8
case|:
comment|/* Timer overflow */
break|break;
case|case
literal|0xfc
case|:
name|printf
argument_list|(
literal|"<all end>"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xfd
case|:
if|if
condition|(
name|devc
operator|->
name|timer_flag
condition|)
name|mpu_timer_interrupt
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0xfe
case|:
return|return
name|MPU_ACK
return|;
break|break;
case|case
literal|0xf0
case|:
case|case
literal|0xf1
case|:
case|case
literal|0xf2
case|:
case|case
literal|0xf3
case|:
case|case
literal|0xf4
case|:
case|case
literal|0xf5
case|:
case|case
literal|0xf6
case|:
case|case
literal|0xf7
case|:
name|printf
argument_list|(
literal|"<Trk data rq #%d>"
argument_list|,
name|midic
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xf9
case|:
name|printf
argument_list|(
literal|"<conductor rq>"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xff
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_SYSMSG
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|midic
operator|<=
literal|0xef
condition|)
block|{
comment|/* printf("mpu time: %d ", midic); */
name|devc
operator|->
name|m_state
operator|=
name|ST_TIMED
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"<MPU: Unknown event %02x> "
argument_list|,
name|midic
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ST_TIMED
case|:
block|{
name|int
name|msg
init|=
operator|(
call|(
name|int
call|)
argument_list|(
name|midic
operator|&
literal|0xf0
argument_list|)
operator|>>
literal|4
operator|)
decl_stmt|;
name|devc
operator|->
name|m_state
operator|=
name|ST_DATABYTE
expr_stmt|;
if|if
condition|(
name|msg
operator|<
literal|8
condition|)
block|{
comment|/* Data byte */
comment|/* printf("midi msg (running status) "); */
name|msg
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|devc
operator|->
name|last_status
operator|&
literal|0xf0
argument_list|)
operator|>>
literal|4
operator|)
expr_stmt|;
name|msg
operator|-=
literal|8
expr_stmt|;
name|devc
operator|->
name|m_left
operator|=
name|len_tab
index|[
name|msg
index|]
operator|-
literal|1
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|2
expr_stmt|;
name|devc
operator|->
name|m_buf
index|[
literal|0
index|]
operator|=
name|devc
operator|->
name|last_status
expr_stmt|;
name|devc
operator|->
name|m_buf
index|[
literal|1
index|]
operator|=
name|midic
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|m_left
operator|<=
literal|0
condition|)
block|{
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|do_midi_msg
argument_list|(
name|devc
operator|->
name|synthno
argument_list|,
name|devc
operator|->
name|m_buf
argument_list|,
name|devc
operator|->
name|m_ptr
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|msg
operator|==
literal|0xf
condition|)
block|{
comment|/* MPU MARK */
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
switch|switch
condition|(
name|midic
condition|)
block|{
case|case
literal|0xf8
case|:
comment|/* printf("NOP "); */
break|break;
case|case
literal|0xf9
case|:
comment|/* printf("meas end "); */
break|break;
case|case
literal|0xfc
case|:
comment|/* printf("data end "); */
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown MPU mark %02x\n"
argument_list|,
name|midic
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|devc
operator|->
name|last_status
operator|=
name|midic
expr_stmt|;
comment|/* printf ("midi msg "); */
name|msg
operator|-=
literal|8
expr_stmt|;
name|devc
operator|->
name|m_left
operator|=
name|len_tab
index|[
name|msg
index|]
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|1
expr_stmt|;
name|devc
operator|->
name|m_buf
index|[
literal|0
index|]
operator|=
name|midic
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|m_left
operator|<=
literal|0
condition|)
block|{
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|do_midi_msg
argument_list|(
name|devc
operator|->
name|synthno
argument_list|,
name|devc
operator|->
name|m_buf
argument_list|,
name|devc
operator|->
name|m_ptr
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|ST_SYSMSG
case|:
switch|switch
condition|(
name|midic
condition|)
block|{
case|case
literal|0xf0
case|:
name|printf
argument_list|(
literal|"<SYX>"
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_state
operator|=
name|ST_SYSEX
expr_stmt|;
break|break;
case|case
literal|0xf1
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_MTC
expr_stmt|;
break|break;
case|case
literal|0xf2
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_SONGPOS
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0xf3
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_SONGSEL
expr_stmt|;
break|break;
case|case
literal|0xf6
case|:
comment|/* printf("tune_request\n"); */
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
comment|/* XXX do we need a break here ? - lr 970710 */
comment|/* 	     * Real time messages 	     */
case|case
literal|0xf8
case|:
comment|/* midi clock */
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|timer_ext_event
argument_list|(
name|devc
argument_list|,
name|TMR_CLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xfA
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|timer_ext_event
argument_list|(
name|devc
argument_list|,
name|TMR_START
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xFB
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|timer_ext_event
argument_list|(
name|devc
argument_list|,
name|TMR_CONTINUE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xFC
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|timer_ext_event
argument_list|(
name|devc
argument_list|,
name|TMR_STOP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xFE
case|:
comment|/* active sensing */
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
break|break;
case|case
literal|0xff
case|:
comment|/* printf("midi hard reset"); */
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown MIDI sysmsg %0x\n"
argument_list|,
name|midic
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
block|}
break|break;
case|case
name|ST_MTC
case|:
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|printf
argument_list|(
literal|"MTC frame %x02\n"
argument_list|,
name|midic
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST_SYSEX
case|:
if|if
condition|(
name|midic
operator|==
literal|0xf7
condition|)
block|{
name|printf
argument_list|(
literal|"<EOX>"
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%02x "
argument_list|,
name|midic
argument_list|)
expr_stmt|;
break|break;
case|case
name|ST_SONGPOS
case|:
name|BUFTEST
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_buf
index|[
name|devc
operator|->
name|m_ptr
operator|++
index|]
operator|=
name|midic
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|m_ptr
operator|==
literal|2
condition|)
block|{
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|0
expr_stmt|;
name|timer_ext_event
argument_list|(
name|devc
argument_list|,
name|TMR_SPP
argument_list|,
operator|(
operator|(
name|devc
operator|->
name|m_buf
index|[
literal|1
index|]
operator|&
literal|0x7f
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
name|devc
operator|->
name|m_buf
index|[
literal|0
index|]
operator|&
literal|0x7f
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ST_DATABYTE
case|:
name|BUFTEST
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_buf
index|[
name|devc
operator|->
name|m_ptr
operator|++
index|]
operator|=
name|midic
expr_stmt|;
if|if
condition|(
operator|(
operator|--
name|devc
operator|->
name|m_left
operator|)
operator|<=
literal|0
condition|)
block|{
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|do_midi_msg
argument_list|(
name|devc
operator|->
name|synthno
argument_list|,
name|devc
operator|->
name|m_buf
argument_list|,
name|devc
operator|->
name|m_ptr
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"Bad state %d "
argument_list|,
name|devc
operator|->
name|m_state
argument_list|)
expr_stmt|;
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpu401_input_loop
parameter_list|(
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|int
name|n
decl_stmt|,
name|busy
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|busy
operator|=
name|devc
operator|->
name|m_busy
expr_stmt|;
name|devc
operator|->
name|m_busy
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|busy
condition|)
comment|/* Already inside the scanner */
return|return;
name|n
operator|=
literal|50
expr_stmt|;
while|while
condition|(
name|input_avail
argument_list|(
name|devc
argument_list|)
operator|&&
name|n
operator|--
operator|>
literal|0
condition|)
block|{
name|u_char
name|c
init|=
name|read_data
argument_list|(
name|devc
argument_list|)
decl_stmt|;
if|if
condition|(
name|devc
operator|->
name|mode
operator|==
name|MODE_SYNTH
condition|)
block|{
name|mpu_input_scanner
argument_list|(
name|devc
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|devc
operator|->
name|opened
operator|&
name|OPEN_READ
operator|&&
name|devc
operator|->
name|inputintr
operator|!=
name|NULL
condition|)
name|devc
operator|->
name|inputintr
argument_list|(
name|devc
operator|->
name|devno
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|devc
operator|->
name|m_busy
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mpuintr
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|int
name|dev
decl_stmt|;
comment|/*      * FreeBSD (and some others) pass unit number to the interrupt      * handler. In this case we have to scan the table for first handler.      */
if|if
condition|(
name|irq
operator|<
literal|1
operator|||
name|irq
operator|>
literal|15
condition|)
block|{
name|dev
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|dev
operator|=
name|irq2dev
index|[
name|irq
index|]
expr_stmt|;
if|if
condition|(
name|dev
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|origirq
init|=
name|irq
decl_stmt|;
for|for
control|(
name|irq
operator|=
literal|0
init|;
name|irq
operator|<=
literal|16
condition|;
name|irq
operator|++
control|)
if|if
condition|(
name|irq2dev
index|[
name|irq
index|]
operator|!=
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|irq
operator|>
literal|15
condition|)
block|{
name|printf
argument_list|(
literal|"MPU-401: Bogus interrupt #%d?\n"
argument_list|,
name|origirq
argument_list|)
expr_stmt|;
return|return;
block|}
name|dev
operator|=
name|irq2dev
index|[
name|irq
index|]
expr_stmt|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|dev
index|]
expr_stmt|;
block|}
else|else
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|dev
index|]
expr_stmt|;
if|if
condition|(
name|input_avail
argument_list|(
name|devc
argument_list|)
condition|)
if|if
condition|(
name|devc
operator|->
name|base
operator|!=
literal|0
operator|&&
operator|(
name|devc
operator|->
name|opened
operator|&
name|OPEN_READ
operator|||
name|devc
operator|->
name|mode
operator|==
name|MODE_SYNTH
operator|)
condition|)
name|mpu401_input_loop
argument_list|(
name|devc
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Dummy read (just to acknowledge the interrupt) */
name|read_data
argument_list|(
name|devc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mpu401_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|,
name|void
function_decl|(
modifier|*
name|input
function_decl|)
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_char
name|data
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|output
function_decl|)
parameter_list|(
name|int
name|dev
parameter_list|)
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_midis
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|dev
index|]
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|opened
condition|)
block|{
name|printf
argument_list|(
literal|"MPU-401: Midi busy\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/*      * Verify that the device is really running. Some devices (such as      * Ensoniq SoundScape don't work before the on board processor (OBP)      * is initialized by downloadin it's microcode.      */
if|if
condition|(
operator|!
name|devc
operator|->
name|initialized
condition|)
block|{
if|if
condition|(
name|mpu401_status
argument_list|(
name|devc
argument_list|)
operator|==
literal|0xff
condition|)
block|{
comment|/* Bus float */
name|printf
argument_list|(
literal|"MPU-401: Device not initialized properly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
block|}
name|reset_mpu401
argument_list|(
name|devc
argument_list|)
expr_stmt|;
block|}
name|irq2dev
index|[
name|devc
operator|->
name|irq
index|]
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|midi_devs
index|[
name|dev
index|]
operator|->
name|coproc
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|midi_devs
index|[
name|dev
index|]
operator|->
name|coproc
operator|->
name|open
argument_list|(
name|midi_devs
index|[
name|dev
index|]
operator|->
name|coproc
operator|->
name|devc
argument_list|,
name|COPR_MIDI
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"MPU-401: Can't access coprocessor device\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|set_uart_mode
argument_list|(
name|dev
argument_list|,
name|devc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|devc
operator|->
name|mode
operator|=
name|MODE_MIDI
expr_stmt|;
name|devc
operator|->
name|synthno
operator|=
literal|0
expr_stmt|;
name|mpu401_input_loop
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|devc
operator|->
name|inputintr
operator|=
name|input
expr_stmt|;
name|devc
operator|->
name|opened
operator|=
name|mode
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpu401_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|dev
index|]
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|uart_mode
condition|)
name|reset_mpu401
argument_list|(
name|devc
argument_list|)
expr_stmt|;
comment|/* This disables the UART mode */
name|devc
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|inputintr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|midi_devs
index|[
name|dev
index|]
operator|->
name|coproc
condition|)
name|midi_devs
index|[
name|dev
index|]
operator|->
name|coproc
operator|->
name|close
argument_list|(
name|midi_devs
index|[
name|dev
index|]
operator|->
name|coproc
operator|->
name|devc
argument_list|,
name|COPR_MIDI
argument_list|)
expr_stmt|;
name|devc
operator|->
name|opened
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu401_out
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_char
name|midi_byte
parameter_list|)
block|{
name|int
name|timeout
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|dev
index|]
expr_stmt|;
comment|/*      * Sometimes it takes about 13000 loops before the output becomes      * ready (After reset). Normally it takes just about 10 loops.      */
for|for
control|(
name|timeout
operator|=
literal|3000
init|;
name|timeout
operator|>
literal|0
operator|&&
operator|!
name|output_ready
argument_list|(
name|devc
argument_list|)
condition|;
name|timeout
operator|--
control|)
empty_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|output_ready
argument_list|(
name|devc
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"MPU-401: Send data timeout\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|write_data
argument_list|(
name|devc
argument_list|,
name|midi_byte
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu401_command
parameter_list|(
name|int
name|dev
parameter_list|,
name|mpu_command_rec
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|timeout
decl_stmt|,
name|ok
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|dev
index|]
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|uart_mode
condition|)
block|{
comment|/* Not possible in UART mode */
name|printf
argument_list|(
literal|"MPU-401 commands not possible in the UART mode\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/*      * Test for input since pending input seems to block the output.      */
if|if
condition|(
name|input_avail
argument_list|(
name|devc
argument_list|)
condition|)
name|mpu401_input_loop
argument_list|(
name|devc
argument_list|)
expr_stmt|;
comment|/*      * Sometimes it takes about 30000 loops before the output becomes      * ready (After reset). Normally it takes just about 10 loops.      */
name|timeout
operator|=
literal|30000
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|timeout
operator|--
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"MPU-401: Command (0x%x) timeout\n"
argument_list|,
operator|(
name|int
operator|)
name|cmd
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
block|}
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|output_ready
argument_list|(
name|devc
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|write_command
argument_list|(
name|devc
argument_list|,
name|cmd
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|timeout
operator|=
literal|50000
init|;
name|timeout
operator|>
literal|0
operator|&&
operator|!
name|ok
condition|;
name|timeout
operator|--
control|)
if|if
condition|(
name|input_avail
argument_list|(
name|devc
argument_list|)
condition|)
if|if
condition|(
name|devc
operator|->
name|opened
operator|&&
name|devc
operator|->
name|mode
operator|==
name|MODE_SYNTH
condition|)
block|{
if|if
condition|(
name|mpu_input_scanner
argument_list|(
name|devc
argument_list|,
name|read_data
argument_list|(
name|devc
argument_list|)
argument_list|)
operator|==
name|MPU_ACK
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Device is not currently open. Use simplier method */
if|if
condition|(
name|read_data
argument_list|(
name|devc
argument_list|)
operator|==
name|MPU_ACK
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* printf ("MPU: No ACK to command (0x%x)\n", (int) cmd->cmd); */
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|cmd
operator|->
name|nr_args
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmd
operator|->
name|nr_args
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|timeout
operator|=
literal|3000
init|;
name|timeout
operator|>
literal|0
operator|&&
operator|!
name|output_ready
argument_list|(
name|devc
argument_list|)
condition|;
name|timeout
operator|--
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|mpu401_out
argument_list|(
name|dev
argument_list|,
name|cmd
operator|->
name|data
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MPU: Command (0x%x), parm send failed.\n"
argument_list|,
operator|(
name|int
operator|)
name|cmd
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
block|}
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|cmd
operator|->
name|data
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|nr_returns
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmd
operator|->
name|nr_returns
condition|;
name|i
operator|++
control|)
block|{
name|ok
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|timeout
operator|=
literal|5000
init|;
name|timeout
operator|>
literal|0
operator|&&
operator|!
name|ok
condition|;
name|timeout
operator|--
control|)
if|if
condition|(
name|input_avail
argument_list|(
name|devc
argument_list|)
condition|)
block|{
name|cmd
operator|->
name|data
index|[
name|i
index|]
operator|=
name|read_data
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* printf ("MPU: No response(%d) to command (0x%x)\n", 		     *	i, (int) cmd->cmd); 		     */
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
block|}
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu_cmd
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
specifier|static
name|mpu_command_rec
name|rec
decl_stmt|;
name|rec
operator|.
name|cmd
operator|=
name|cmd
operator|&
literal|0xff
expr_stmt|;
name|rec
operator|.
name|nr_args
operator|=
operator|(
operator|(
name|cmd
operator|&
literal|0xf0
operator|)
operator|==
literal|0xE0
operator|)
expr_stmt|;
name|rec
operator|.
name|nr_returns
operator|=
operator|(
operator|(
name|cmd
operator|&
literal|0xf0
operator|)
operator|==
literal|0xA0
operator|)
expr_stmt|;
name|rec
operator|.
name|data
index|[
literal|0
index|]
operator|=
name|data
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|mpu401_command
argument_list|(
name|dev
argument_list|,
operator|&
name|rec
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
return|return
operator|(
name|u_char
operator|)
name|rec
operator|.
name|data
index|[
literal|0
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu401_prefix_cmd
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_char
name|status
parameter_list|)
block|{
name|struct
name|mpu_config
modifier|*
name|devc
init|=
operator|&
name|dev_conf
index|[
name|dev
index|]
decl_stmt|;
if|if
condition|(
name|devc
operator|->
name|uart_mode
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|status
operator|<
literal|0xf0
condition|)
block|{
if|if
condition|(
name|mpu_cmd
argument_list|(
name|dev
argument_list|,
literal|0xD0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
switch|switch
condition|(
name|status
condition|)
block|{
case|case
literal|0xF0
case|:
if|if
condition|(
name|mpu_cmd
argument_list|(
name|dev
argument_list|,
literal|0xDF
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mpu401_start_read
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu401_end_read
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu401_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|ioctl_arg
name|arg
parameter_list|)
block|{
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|dev
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|1
case|:
name|bcopy
argument_list|(
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|init_sequence
argument_list|,
sizeof|sizeof
argument_list|(
name|init_sequence
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_MIDI_MPUMODE
case|:
if|if
condition|(
operator|!
operator|(
name|devc
operator|->
name|capabilities
operator|&
name|MPU_CAP_INTLG
operator|)
condition|)
block|{
comment|/* No intelligent mode */
name|printf
argument_list|(
literal|"MPU-401: Intelligent mode not supported by the HW\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
name|set_uart_mode
argument_list|(
name|dev
argument_list|,
name|devc
argument_list|,
operator|!
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_MIDI_MPUCMD
case|:
block|{
name|int
name|ret
decl_stmt|;
name|mpu_command_rec
name|rec
decl_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rec
argument_list|,
sizeof|sizeof
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|mpu401_command
argument_list|(
name|dev
argument_list|,
operator|&
name|rec
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|ret
return|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rec
argument_list|,
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|rec
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
default|default:
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mpu401_kick
parameter_list|(
name|int
name|dev
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|mpu401_buffer_status
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
comment|/* No data in buffers */
block|}
end_function

begin_function
specifier|static
name|int
name|mpu_synth_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|ioctl_arg
name|arg
parameter_list|)
block|{
name|int
name|midi_dev
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|midi_dev
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|midi_dev
expr_stmt|;
if|if
condition|(
name|midi_dev
operator|<
literal|0
operator|||
name|midi_dev
operator|>
name|num_midis
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|midi_dev
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_SYNTH_INFO
case|:
name|bcopy
argument_list|(
operator|&
name|mpu_synth_info
index|[
name|midi_dev
index|]
argument_list|,
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|synth_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
return|return
literal|0x7fffffff
return|;
break|break;
default|default:
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mpu_synth_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|midi_dev
decl_stmt|,
name|err
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|midi_dev
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|midi_dev
expr_stmt|;
if|if
condition|(
name|midi_dev
operator|<
literal|0
operator|||
name|midi_dev
operator|>
name|num_midis
condition|)
block|{
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
block|}
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|midi_dev
index|]
expr_stmt|;
comment|/*      * Verify that the device is really running. Some devices (such as      * Ensoniq SoundScape don't work before the on board processor (OBP)      * is initialized by downloadin it's microcode.      */
if|if
condition|(
operator|!
name|devc
operator|->
name|initialized
condition|)
block|{
if|if
condition|(
name|mpu401_status
argument_list|(
name|devc
argument_list|)
operator|==
literal|0xff
condition|)
block|{
comment|/* Bus float */
name|printf
argument_list|(
literal|"MPU-401: Device not initialized properly\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
block|}
name|reset_mpu401
argument_list|(
name|devc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|devc
operator|->
name|opened
condition|)
block|{
name|printf
argument_list|(
literal|"MPU-401: Midi busy\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
block|}
name|devc
operator|->
name|mode
operator|=
name|MODE_SYNTH
expr_stmt|;
name|devc
operator|->
name|synthno
operator|=
name|dev
expr_stmt|;
name|devc
operator|->
name|inputintr
operator|=
name|NULL
expr_stmt|;
name|irq2dev
index|[
name|devc
operator|->
name|irq
index|]
operator|=
name|midi_dev
expr_stmt|;
if|if
condition|(
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|coproc
condition|)
if|if
condition|(
operator|(
name|err
operator|=
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|coproc
operator|->
name|open
argument_list|(
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|coproc
operator|->
name|devc
argument_list|,
name|COPR_MIDI
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"MPU-401: Can't access coprocessor device\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|devc
operator|->
name|opened
operator|=
name|mode
expr_stmt|;
name|reset_mpu401
argument_list|(
name|devc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|OPEN_READ
condition|)
block|{
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x8B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable data in stop mode */
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x34
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Return timing bytes in stop mode */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpu_synth_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|midi_dev
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|midi_dev
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|midi_dev
expr_stmt|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|midi_dev
index|]
expr_stmt|;
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop recording, playback and MIDI */
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x8a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable data in stopped mode */
name|devc
operator|->
name|inputintr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|coproc
condition|)
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|coproc
operator|->
name|close
argument_list|(
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|coproc
operator|->
name|devc
argument_list|,
name|COPR_MIDI
argument_list|)
expr_stmt|;
name|devc
operator|->
name|opened
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MIDI_SYNTH_NAME
value|"MPU-401 UART Midi"
end_define

begin_define
define|#
directive|define
name|MIDI_SYNTH_CAPS
value|SYNTH_CAP_INPUT
end_define

begin_include
include|#
directive|include
file|<i386/isa/sound/midi_synth.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|synth_operations
name|mpu401_synth_proto
init|=
block|{
name|NULL
block|,
literal|0
block|,
name|SYNTH_TYPE_MIDI
block|,
literal|0
block|,
name|mpu_synth_open
block|,
name|mpu_synth_close
block|,
name|mpu_synth_ioctl
block|,
name|midi_synth_kill_note
block|,
name|midi_synth_start_note
block|,
name|midi_synth_set_instr
block|,
name|midi_synth_reset
block|,
name|midi_synth_hw_control
block|,
name|midi_synth_load_patch
block|,
name|midi_synth_aftertouch
block|,
name|midi_synth_controller
block|,
name|midi_synth_panning
block|,
name|NULL
block|,
name|midi_synth_patchmgr
block|,
name|midi_synth_bender
block|,
name|NULL
block|,
comment|/* alloc */
name|midi_synth_setup_voice
block|,
name|midi_synth_send_sysex
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|synth_operations
modifier|*
name|mpu401_synth_operations
index|[
name|MAX_MIDI_DEV
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|midi_operations
name|mpu401_midi_proto
init|=
block|{
block|{
literal|"MPU-401 Midi"
block|,
literal|0
block|,
name|MIDI_CAP_MPU401
block|,
name|SNDCARD_MPU401
block|}
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|,
name|mpu401_open
block|,
name|mpu401_close
block|,
name|mpu401_ioctl
block|,
name|mpu401_out
block|,
name|mpu401_start_read
block|,
name|mpu401_end_read
block|,
name|mpu401_kick
block|,
name|NULL
block|,
name|mpu401_buffer_status
block|,
name|mpu401_prefix_cmd
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|midi_operations
name|mpu401_midi_operations
index|[
name|MAX_MIDI_DEV
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mpu401_chk_version
parameter_list|(
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|)
block|{
name|int
name|tmp
decl_stmt|;
name|devc
operator|->
name|version
operator|=
name|devc
operator|->
name|revision
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|mpu_cmd
argument_list|(
name|num_midis
argument_list|,
literal|0xAC
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|tmp
operator|&
literal|0xf0
operator|)
operator|>
literal|0x20
condition|)
comment|/* Why it's larger than 2.x ??? */
return|return;
name|devc
operator|->
name|version
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|mpu_cmd
argument_list|(
name|num_midis
argument_list|,
literal|0xAD
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|devc
operator|->
name|version
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|devc
operator|->
name|revision
operator|=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|attach_mpu401
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|char
name|revision_char
decl_stmt|;
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
if|if
condition|(
name|num_midis
operator|>=
name|MAX_MIDI_DEV
condition|)
block|{
name|printf
argument_list|(
literal|"MPU-401: Too many midi devices detected\n"
argument_list|)
expr_stmt|;
return|return ;
block|}
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|num_midis
index|]
expr_stmt|;
name|devc
operator|->
name|base
operator|=
name|hw_config
operator|->
name|io_base
expr_stmt|;
name|devc
operator|->
name|osp
operator|=
name|hw_config
operator|->
name|osp
expr_stmt|;
name|devc
operator|->
name|irq
operator|=
name|hw_config
operator|->
name|irq
expr_stmt|;
name|devc
operator|->
name|opened
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|uart_mode
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|initialized
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|version
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|revision
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|capabilities
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|timer_flag
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|m_busy
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|devc
operator|->
name|shared_irq
operator|=
name|hw_config
operator|->
name|always_detect
expr_stmt|;
name|devc
operator|->
name|irq
operator|=
name|hw_config
operator|->
name|irq
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|irq
operator|<
literal|0
condition|)
block|{
name|devc
operator|->
name|irq
operator|*=
operator|-
literal|1
expr_stmt|;
name|devc
operator|->
name|shared_irq
operator|=
literal|1
expr_stmt|;
block|}
name|irq2dev
index|[
name|devc
operator|->
name|irq
index|]
operator|=
name|num_midis
expr_stmt|;
if|if
condition|(
operator|!
name|hw_config
operator|->
name|always_detect
condition|)
block|{
comment|/* Verify the hardware again */
if|if
condition|(
operator|!
name|reset_mpu401
argument_list|(
name|devc
argument_list|)
condition|)
return|return ;
if|if
condition|(
operator|!
name|devc
operator|->
name|shared_irq
condition|)
if|if
condition|(
name|snd_set_irq_handler
argument_list|(
name|devc
operator|->
name|irq
argument_list|,
name|mpuintr
argument_list|,
name|devc
operator|->
name|osp
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return ;
block|}
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|mpu401_chk_version
argument_list|(
name|devc
argument_list|)
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|version
operator|==
literal|0
condition|)
name|mpu401_chk_version
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|devc
operator|->
name|version
operator|!=
literal|0
condition|)
if|if
condition|(
name|mpu_cmd
argument_list|(
name|num_midis
argument_list|,
literal|0xC5
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
comment|/* Set timebase OK */
if|if
condition|(
name|mpu_cmd
argument_list|(
name|num_midis
argument_list|,
literal|0xE0
argument_list|,
literal|120
argument_list|)
operator|>=
literal|0
condition|)
comment|/* Set tempo OK */
name|devc
operator|->
name|capabilities
operator||=
name|MPU_CAP_INTLG
expr_stmt|;
comment|/* Supports intelligent 							 * mode */
name|mpu401_synth_operations
index|[
name|num_midis
index|]
operator|=
operator|(
expr|struct
name|synth_operations
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|synth_operations
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mpu401_synth_operations
index|[
name|num_midis
index|]
condition|)
name|panic
argument_list|(
literal|"SOUND: Cannot allocate memory\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpu401_synth_operations
index|[
name|num_midis
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"mpu401: Can't allocate memory\n"
argument_list|)
expr_stmt|;
return|return ;
block|}
if|if
condition|(
operator|!
operator|(
name|devc
operator|->
name|capabilities
operator|&
name|MPU_CAP_INTLG
operator|)
condition|)
block|{
comment|/* No intelligent mode */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|std_midi_synth
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mpu401_synth_operations
index|[
name|num_midis
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|synth_operations
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mpu401_synth_proto
argument_list|,
operator|(
name|char
operator|*
operator|)
name|mpu401_synth_operations
index|[
name|num_midis
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|synth_operations
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mpu401_midi_proto
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mpu401_midi_operations
index|[
name|num_midis
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|midi_operations
argument_list|)
argument_list|)
expr_stmt|;
name|mpu401_midi_operations
index|[
name|num_midis
index|]
operator|.
name|converter
operator|=
name|mpu401_synth_operations
index|[
name|num_midis
index|]
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mpu_synth_info_proto
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mpu_synth_info
index|[
name|num_midis
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|synth_info
argument_list|)
argument_list|)
expr_stmt|;
name|n_mpu_devs
operator|++
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|version
operator|==
literal|0x20
operator|&&
name|devc
operator|->
name|revision
operator|>=
literal|0x07
condition|)
block|{
comment|/* MusicQuest interface */
name|int
name|ports
init|=
operator|(
name|devc
operator|->
name|revision
operator|&
literal|0x08
operator|)
condition|?
literal|32
else|:
literal|16
decl_stmt|;
name|devc
operator|->
name|capabilities
operator||=
name|MPU_CAP_SYNC
operator||
name|MPU_CAP_SMPTE
operator||
name|MPU_CAP_CLS
operator||
name|MPU_CAP_2PORT
expr_stmt|;
name|revision_char
operator|=
operator|(
name|devc
operator|->
name|revision
operator|==
literal|0x7f
operator|)
condition|?
literal|'M'
else|:
literal|' '
expr_stmt|;
name|sprintf
argument_list|(
name|mpu_synth_info
index|[
name|num_midis
index|]
operator|.
name|name
argument_list|,
literal|"MQX-%d%c MIDI Interface #%d"
argument_list|,
name|ports
argument_list|,
name|revision_char
argument_list|,
name|n_mpu_devs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|revision_char
operator|=
name|devc
operator|->
name|revision
condition|?
name|devc
operator|->
name|revision
operator|+
literal|'@'
else|:
literal|' '
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|devc
operator|->
name|revision
operator|>
operator|(
literal|'Z'
operator|-
literal|'@'
operator|)
condition|)
name|revision_char
operator|=
literal|'+'
expr_stmt|;
name|devc
operator|->
name|capabilities
operator||=
name|MPU_CAP_SYNC
operator||
name|MPU_CAP_FSK
expr_stmt|;
name|sprintf
argument_list|(
name|mpu_synth_info
index|[
name|num_midis
index|]
operator|.
name|name
argument_list|,
literal|"MPU-401 %d.%d%c Midi interface #%d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|devc
operator|->
name|version
operator|&
literal|0xf0
argument_list|)
operator|>>
literal|4
argument_list|,
name|devc
operator|->
name|version
operator|&
literal|0x0f
argument_list|,
name|revision_char
argument_list|,
name|n_mpu_devs
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|mpu401_midi_operations
index|[
name|num_midis
index|]
operator|.
name|info
operator|.
name|name
argument_list|,
name|mpu_synth_info
index|[
name|num_midis
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|conf_printf
argument_list|(
name|mpu_synth_info
index|[
name|num_midis
index|]
operator|.
name|name
argument_list|,
name|hw_config
argument_list|)
expr_stmt|;
name|mpu401_synth_operations
index|[
name|num_midis
index|]
operator|->
name|midi_dev
operator|=
name|devc
operator|->
name|devno
operator|=
name|num_midis
expr_stmt|;
name|mpu401_synth_operations
index|[
name|devc
operator|->
name|devno
index|]
operator|->
name|info
operator|=
operator|&
name|mpu_synth_info
index|[
name|devc
operator|->
name|devno
index|]
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|capabilities
operator|&
name|MPU_CAP_INTLG
condition|)
comment|/* Intelligent mode */
name|mpu_timer_init
argument_list|(
name|num_midis
argument_list|)
expr_stmt|;
name|irq2dev
index|[
name|devc
operator|->
name|irq
index|]
operator|=
name|num_midis
expr_stmt|;
name|midi_devs
index|[
name|num_midis
operator|++
index|]
operator|=
operator|&
name|mpu401_midi_operations
index|[
name|devc
operator|->
name|devno
index|]
expr_stmt|;
return|return ;
block|}
end_function

begin_function
specifier|static
name|int
name|reset_mpu401
parameter_list|(
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|int
name|ok
decl_stmt|,
name|timeout
decl_stmt|,
name|n
decl_stmt|;
name|int
name|timeout_limit
decl_stmt|;
comment|/*      * Send the RESET command. Try again if no success at the first time.      * (If the device is in the UART mode, it will not ack the reset      * cmd).      */
name|ok
operator|=
literal|0
expr_stmt|;
name|timeout_limit
operator|=
name|devc
operator|->
name|initialized
condition|?
literal|30000
else|:
literal|100000
expr_stmt|;
name|devc
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|2
operator|&&
operator|!
name|ok
condition|;
name|n
operator|++
control|)
block|{
for|for
control|(
name|timeout
operator|=
name|timeout_limit
init|;
name|timeout
operator|>
literal|0
operator|&&
operator|!
name|ok
condition|;
name|timeout
operator|--
control|)
name|ok
operator|=
name|output_ready
argument_list|(
name|devc
argument_list|)
expr_stmt|;
name|write_command
argument_list|(
name|devc
argument_list|,
name|MPU_RESET
argument_list|)
expr_stmt|;
comment|/* Send MPU-401 RESET Command */
comment|/* 	 * Wait at least 25 msec. This method is not accurate so 	 * let's make the loop bit longer. Cannot sleep since this is 	 * called during boot. 	 */
for|for
control|(
name|timeout
operator|=
name|timeout_limit
operator|*
literal|2
init|;
name|timeout
operator|>
literal|0
operator|&&
operator|!
name|ok
condition|;
name|timeout
operator|--
control|)
block|{
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|input_avail
argument_list|(
name|devc
argument_list|)
operator|)
operator|&&
operator|(
name|read_data
argument_list|(
name|devc
argument_list|)
operator|==
name|MPU_ACK
operator|)
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
name|devc
operator|->
name|m_state
operator|=
name|ST_INIT
expr_stmt|;
name|devc
operator|->
name|m_ptr
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|m_left
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|last_status
operator|=
literal|0
expr_stmt|;
name|devc
operator|->
name|uart_mode
operator|=
literal|0
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_uart_mode
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
if|if
condition|(
operator|!
name|arg
operator|&&
operator|(
name|devc
operator|->
name|capabilities
operator|&
name|MPU_CAP_INTLG
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|devc
operator|->
name|uart_mode
operator|==
literal|0
operator|)
operator|==
operator|(
name|arg
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* Already set */
name|reset_mpu401
argument_list|(
name|devc
argument_list|)
expr_stmt|;
comment|/* This exits the uart mode */
if|if
condition|(
name|arg
operator|&&
operator|(
name|mpu_cmd
argument_list|(
name|dev
argument_list|,
name|UART_MODE_ON
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"MPU%d: Can't enter UART mode\n"
argument_list|,
name|devc
operator|->
name|devno
argument_list|)
expr_stmt|;
name|devc
operator|->
name|uart_mode
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|devc
operator|->
name|uart_mode
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_function
name|int
name|probe_mpu401
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|int
name|ok
init|=
literal|0
decl_stmt|;
name|struct
name|mpu_config
name|tmp_devc
decl_stmt|;
name|tmp_devc
operator|.
name|base
operator|=
name|hw_config
operator|->
name|io_base
expr_stmt|;
name|tmp_devc
operator|.
name|irq
operator|=
name|hw_config
operator|->
name|irq
expr_stmt|;
name|tmp_devc
operator|.
name|initialized
operator|=
literal|0
expr_stmt|;
name|tmp_devc
operator|.
name|opened
operator|=
literal|0
expr_stmt|;
name|tmp_devc
operator|.
name|osp
operator|=
name|hw_config
operator|->
name|osp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_AEDSP16
argument_list|)
operator|&&
name|defined
argument_list|(
name|AEDSP16_MPU401
argument_list|)
comment|/*      * Initialize Audio Excel DSP 16 to MPU-401, before any operation.      */
name|InitAEDSP16_MPU401
argument_list|(
name|hw_config
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hw_config
operator|->
name|always_detect
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|inb
argument_list|(
name|hw_config
operator|->
name|io_base
operator|+
literal|1
argument_list|)
operator|==
literal|0xff
condition|)
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"MPU401: Port %x looks dead.\n"
argument_list|,
name|hw_config
operator|->
name|io_base
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Just bus float? */
block|}
name|ok
operator|=
name|reset_mpu401
argument_list|(
operator|&
name|tmp_devc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|DDB
argument_list|(
name|printf
argument_list|(
literal|"MPU401: Reset failed on port %x\n"
argument_list|,
name|hw_config
operator|->
name|io_base
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/*  *      Timer stuff  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_SEQUENCER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|timer_initialized
init|=
literal|0
decl_stmt|,
name|timer_open
init|=
literal|0
decl_stmt|,
name|tmr_running
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|curr_tempo
decl_stmt|,
name|curr_timebase
decl_stmt|,
name|hw_timebase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_timebase
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 8*24=192 ppqn */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|u_long
name|next_event_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|u_long
name|curr_ticks
decl_stmt|,
name|curr_clocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|prev_event_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|metronome_mode
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|u_long
name|clocks2ticks
parameter_list|(
name|u_long
name|clocks
parameter_list|)
block|{
comment|/*      * The MPU-401 supports just a limited set of possible timebase      * values. Since the applications require more choices, the driver      * has to program the HW to do it's best and to convert between the      * HW and actual timebases.      */
return|return
operator|(
operator|(
name|clocks
operator|*
name|curr_timebase
operator|)
operator|+
operator|(
name|hw_timebase
operator|/
literal|2
operator|)
operator|)
operator|/
name|hw_timebase
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_timebase
parameter_list|(
name|int
name|midi_dev
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|int
name|hw_val
decl_stmt|;
if|if
condition|(
name|val
operator|<
literal|48
condition|)
name|val
operator|=
literal|48
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|1000
condition|)
name|val
operator|=
literal|1000
expr_stmt|;
name|hw_val
operator|=
name|val
expr_stmt|;
name|hw_val
operator|=
operator|(
name|hw_val
operator|+
literal|12
operator|)
operator|/
literal|24
expr_stmt|;
if|if
condition|(
name|hw_val
operator|>
name|max_timebase
condition|)
name|hw_val
operator|=
name|max_timebase
expr_stmt|;
if|if
condition|(
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0xC0
operator||
operator|(
name|hw_val
operator|&
literal|0x0f
operator|)
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"MPU: Can't set HW timebase to %d\n"
argument_list|,
name|hw_val
operator|*
literal|24
argument_list|)
expr_stmt|;
return|return;
block|}
name|hw_timebase
operator|=
name|hw_val
operator|*
literal|24
expr_stmt|;
name|curr_timebase
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tmr_reset
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|next_event_time
operator|=
literal|0xffffffff
expr_stmt|;
name|prev_event_time
operator|=
literal|0
expr_stmt|;
name|curr_ticks
operator|=
name|curr_clocks
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_timer_mode
parameter_list|(
name|int
name|midi_dev
parameter_list|)
block|{
if|if
condition|(
name|timer_mode
operator|&
name|TMR_MODE_CLS
condition|)
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x3c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use CLS sync */
elseif|else
if|if
condition|(
name|timer_mode
operator|&
name|TMR_MODE_SMPTE
condition|)
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x3d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use SMPTE sync */
if|if
condition|(
name|timer_mode
operator|&
name|TMR_INTERNAL
condition|)
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x80
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use MIDI sync */
else|else
block|{
if|if
condition|(
name|timer_mode
operator|&
operator|(
name|TMR_MODE_MIDI
operator||
name|TMR_MODE_CLS
operator|)
condition|)
block|{
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x82
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use MIDI sync */
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x91
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable ext MIDI ctrl */
block|}
elseif|else
if|if
condition|(
name|timer_mode
operator|&
name|TMR_MODE_FSK
condition|)
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x81
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use FSK sync */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|stop_metronome
parameter_list|(
name|int
name|midi_dev
parameter_list|)
block|{
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x84
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable metronome */
block|}
end_function

begin_function
specifier|static
name|void
name|setup_metronome
parameter_list|(
name|int
name|midi_dev
parameter_list|)
block|{
name|int
name|numerator
decl_stmt|,
name|denominator
decl_stmt|;
name|int
name|clks_per_click
decl_stmt|,
name|num_32nds_per_beat
decl_stmt|;
name|int
name|beats_per_measure
decl_stmt|;
name|numerator
operator|=
operator|(
operator|(
name|u_int
operator|)
name|metronome_mode
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|denominator
operator|=
operator|(
operator|(
name|u_int
operator|)
name|metronome_mode
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|clks_per_click
operator|=
operator|(
operator|(
name|u_int
operator|)
name|metronome_mode
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|num_32nds_per_beat
operator|=
operator|(
name|u_int
operator|)
name|metronome_mode
operator|&
literal|0xff
expr_stmt|;
name|beats_per_measure
operator|=
operator|(
name|numerator
operator|*
literal|4
operator|)
operator|>>
name|denominator
expr_stmt|;
if|if
condition|(
operator|!
name|metronome_mode
condition|)
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x84
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable metronome */
else|else
block|{
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0xE4
argument_list|,
name|clks_per_click
argument_list|)
expr_stmt|;
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0xE6
argument_list|,
name|beats_per_measure
argument_list|)
expr_stmt|;
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x83
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable metronome without 					 * accents */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mpu_start_timer
parameter_list|(
name|int
name|midi_dev
parameter_list|)
block|{
name|tmr_reset
argument_list|()
expr_stmt|;
name|set_timer_mode
argument_list|(
name|midi_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmr_running
condition|)
return|return
name|TIMER_NOT_ARMED
return|;
comment|/* Already running */
if|if
condition|(
name|timer_mode
operator|&
name|TMR_INTERNAL
condition|)
block|{
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x02
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Send MIDI start */
name|tmr_running
operator|=
literal|1
expr_stmt|;
return|return
name|TIMER_NOT_ARMED
return|;
block|}
else|else
block|{
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x35
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable mode messages to PC */
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x38
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable sys common messages to PC */
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x39
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable real time messages to PC */
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x97
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable system exclusive 					 * messages to PC */
block|}
return|return
name|TIMER_ARMED
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu_timer_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|midi_dev
init|=
name|sound_timer_devs
index|[
name|dev
index|]
operator|->
name|devlink
decl_stmt|;
if|if
condition|(
name|timer_open
condition|)
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
name|tmr_reset
argument_list|()
expr_stmt|;
name|curr_tempo
operator|=
literal|50
expr_stmt|;
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0xE0
argument_list|,
literal|50
argument_list|)
expr_stmt|;
name|curr_timebase
operator|=
name|hw_timebase
operator|=
literal|120
expr_stmt|;
name|set_timebase
argument_list|(
name|midi_dev
argument_list|,
literal|120
argument_list|)
expr_stmt|;
name|timer_open
operator|=
literal|1
expr_stmt|;
name|metronome_mode
operator|=
literal|0
expr_stmt|;
name|set_timer_mode
argument_list|(
name|midi_dev
argument_list|)
expr_stmt|;
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0xe7
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Send all clocks to host */
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x95
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable clock to host */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpu_timer_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|midi_dev
init|=
name|sound_timer_devs
index|[
name|dev
index|]
operator|->
name|devlink
decl_stmt|;
name|timer_open
operator|=
name|tmr_running
operator|=
literal|0
expr_stmt|;
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x15
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop all */
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x94
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable clock to host */
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x8c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable measure end messages to 					 * host */
name|stop_metronome
argument_list|(
name|midi_dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu_timer_event
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|u_char
name|command
init|=
name|event
index|[
literal|1
index|]
decl_stmt|;
name|u_long
name|parm
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
decl_stmt|;
name|int
name|midi_dev
init|=
name|sound_timer_devs
index|[
name|dev
index|]
operator|->
name|devlink
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|TMR_WAIT_REL
case|:
name|parm
operator|+=
name|prev_event_time
expr_stmt|;
case|case
name|TMR_WAIT_ABS
case|:
if|if
condition|(
name|parm
operator|>
literal|0
condition|)
block|{
name|long
name|time
decl_stmt|;
if|if
condition|(
name|parm
operator|<=
name|curr_ticks
condition|)
comment|/* It's the time */
return|return
name|TIMER_NOT_ARMED
return|;
name|time
operator|=
name|parm
expr_stmt|;
name|next_event_time
operator|=
name|prev_event_time
operator|=
name|time
expr_stmt|;
return|return
name|TIMER_ARMED
return|;
block|}
break|break;
case|case
name|TMR_START
case|:
if|if
condition|(
name|tmr_running
condition|)
break|break;
return|return
name|mpu_start_timer
argument_list|(
name|midi_dev
argument_list|)
return|;
break|break;
case|case
name|TMR_STOP
case|:
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x01
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Send MIDI stop */
name|stop_metronome
argument_list|(
name|midi_dev
argument_list|)
expr_stmt|;
name|tmr_running
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TMR_CONTINUE
case|:
if|if
condition|(
name|tmr_running
condition|)
break|break;
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x03
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Send MIDI continue */
name|setup_metronome
argument_list|(
name|midi_dev
argument_list|)
expr_stmt|;
name|tmr_running
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|TMR_TEMPO
case|:
if|if
condition|(
name|parm
condition|)
block|{
if|if
condition|(
name|parm
operator|<
literal|8
condition|)
name|parm
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|parm
operator|>
literal|250
condition|)
name|parm
operator|=
literal|250
expr_stmt|;
if|if
condition|(
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0xE0
argument_list|,
name|parm
argument_list|)
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"MPU: Can't set tempo to %d\n"
argument_list|,
operator|(
name|int
operator|)
name|parm
argument_list|)
expr_stmt|;
name|curr_tempo
operator|=
name|parm
expr_stmt|;
block|}
break|break;
case|case
name|TMR_ECHO
case|:
name|seq_copy_to_input
argument_list|(
name|event
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
name|TMR_TIMESIG
case|:
if|if
condition|(
name|metronome_mode
condition|)
block|{
comment|/* Metronome enabled */
name|metronome_mode
operator|=
name|parm
expr_stmt|;
name|setup_metronome
argument_list|(
name|midi_dev
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
return|return
name|TIMER_NOT_ARMED
return|;
block|}
end_function

begin_function
specifier|static
name|u_long
name|mpu_timer_get_time
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|timer_open
condition|)
return|return
literal|0
return|;
return|return
name|curr_ticks
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mpu_timer_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_int
name|command
parameter_list|,
name|ioctl_arg
name|arg
parameter_list|)
block|{
name|int
name|midi_dev
init|=
name|sound_timer_devs
index|[
name|dev
index|]
operator|->
name|devlink
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SNDCTL_TMR_SOURCE
case|:
block|{
name|int
name|parm
init|=
call|(
name|int
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
operator|&
name|timer_caps
decl_stmt|;
if|if
condition|(
name|parm
operator|!=
literal|0
condition|)
block|{
name|timer_mode
operator|=
name|parm
expr_stmt|;
if|if
condition|(
name|timer_mode
operator|&
name|TMR_MODE_CLS
condition|)
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x3c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use CLS sync */
elseif|else
if|if
condition|(
name|timer_mode
operator|&
name|TMR_MODE_SMPTE
condition|)
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x3d
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use SMPTE sync */
block|}
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|timer_mode
return|;
block|}
break|break;
case|case
name|SNDCTL_TMR_START
case|:
name|mpu_start_timer
argument_list|(
name|midi_dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_TMR_STOP
case|:
name|tmr_running
operator|=
literal|0
expr_stmt|;
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x01
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Send MIDI stop */
name|stop_metronome
argument_list|(
name|midi_dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_TMR_CONTINUE
case|:
if|if
condition|(
name|tmr_running
condition|)
return|return
literal|0
return|;
name|tmr_running
operator|=
literal|1
expr_stmt|;
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0x03
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Send MIDI continue */
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_TMR_TIMEBASE
case|:
block|{
name|int
name|val
init|=
call|(
name|int
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
condition|)
name|set_timebase
argument_list|(
name|midi_dev
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|curr_timebase
return|;
block|}
break|break;
case|case
name|SNDCTL_TMR_TEMPO
case|:
block|{
name|int
name|val
init|=
call|(
name|int
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|val
condition|)
block|{
name|RANGE
argument_list|(
name|val
argument_list|,
literal|8
argument_list|,
literal|250
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|mpu_cmd
argument_list|(
name|midi_dev
argument_list|,
literal|0xE0
argument_list|,
name|val
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"MPU: Can't set tempo to %d\n"
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|curr_tempo
operator|=
name|val
expr_stmt|;
block|}
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|curr_tempo
return|;
block|}
break|break;
case|case
name|SNDCTL_SEQ_CTRLRATE
case|:
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
operator|!=
literal|0
condition|)
comment|/* Can't change */
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
operator|(
operator|(
name|curr_tempo
operator|*
name|curr_timebase
operator|)
operator|+
literal|30
operator|)
operator|/
literal|60
return|;
break|break;
case|case
name|SNDCTL_TMR_METRONOME
case|:
name|metronome_mode
operator|=
call|(
name|int
call|)
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
name|setup_metronome
argument_list|(
name|midi_dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
default|default:
empty_stmt|;
block|}
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mpu_timer_arm
parameter_list|(
name|int
name|dev
parameter_list|,
name|long
name|time
parameter_list|)
block|{
if|if
condition|(
name|time
operator|<
literal|0
condition|)
name|time
operator|=
name|curr_ticks
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|time
operator|<=
name|curr_ticks
condition|)
comment|/* It's the time */
return|return;
name|next_event_time
operator|=
name|prev_event_time
operator|=
name|time
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|sound_timer_operations
name|mpu_timer
init|=
block|{
block|{
literal|"MPU-401 Timer"
block|,
literal|0
block|}
block|,
literal|10
block|,
comment|/* Priority */
literal|0
block|,
comment|/* Local device link */
name|mpu_timer_open
block|,
name|mpu_timer_close
block|,
name|mpu_timer_event
block|,
name|mpu_timer_get_time
block|,
name|mpu_timer_ioctl
block|,
name|mpu_timer_arm
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mpu_timer_interrupt
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|timer_open
condition|)
return|return;
if|if
condition|(
operator|!
name|tmr_running
condition|)
return|return;
name|curr_clocks
operator|++
expr_stmt|;
name|curr_ticks
operator|=
name|clocks2ticks
argument_list|(
name|curr_clocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_ticks
operator|>=
name|next_event_time
condition|)
block|{
name|next_event_time
operator|=
literal|0xffffffff
expr_stmt|;
name|sequencer_timer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|timer_ext_event
parameter_list|(
name|struct
name|mpu_config
modifier|*
name|devc
parameter_list|,
name|int
name|event
parameter_list|,
name|int
name|parm
parameter_list|)
block|{
name|int
name|midi_dev
init|=
name|devc
operator|->
name|devno
decl_stmt|;
if|if
condition|(
operator|!
name|devc
operator|->
name|timer_flag
condition|)
return|return;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|TMR_CLOCK
case|:
name|printf
argument_list|(
literal|"<MIDI clk>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TMR_START
case|:
name|printf
argument_list|(
literal|"Ext MIDI start\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmr_running
condition|)
if|if
condition|(
name|timer_mode
operator|&
name|TMR_EXTERNAL
condition|)
block|{
name|tmr_running
operator|=
literal|1
expr_stmt|;
name|setup_metronome
argument_list|(
name|midi_dev
argument_list|)
expr_stmt|;
name|next_event_time
operator|=
literal|0
expr_stmt|;
name|STORE
argument_list|(
name|SEQ_START_TIMER
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TMR_STOP
case|:
name|printf
argument_list|(
literal|"Ext MIDI stop\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer_mode
operator|&
name|TMR_EXTERNAL
condition|)
block|{
name|tmr_running
operator|=
literal|0
expr_stmt|;
name|stop_metronome
argument_list|(
name|midi_dev
argument_list|)
expr_stmt|;
name|STORE
argument_list|(
name|SEQ_STOP_TIMER
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TMR_CONTINUE
case|:
name|printf
argument_list|(
literal|"Ext MIDI continue\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer_mode
operator|&
name|TMR_EXTERNAL
condition|)
block|{
name|tmr_running
operator|=
literal|1
expr_stmt|;
name|setup_metronome
argument_list|(
name|midi_dev
argument_list|)
expr_stmt|;
name|STORE
argument_list|(
name|SEQ_CONTINUE_TIMER
argument_list|()
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TMR_SPP
case|:
name|printf
argument_list|(
literal|"Songpos: %d\n"
argument_list|,
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer_mode
operator|&
name|TMR_EXTERNAL
condition|)
block|{
name|STORE
argument_list|(
name|SEQ_SONGPOS
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mpu_timer_init
parameter_list|(
name|int
name|midi_dev
parameter_list|)
block|{
name|struct
name|mpu_config
modifier|*
name|devc
decl_stmt|;
name|int
name|n
decl_stmt|;
name|devc
operator|=
operator|&
name|dev_conf
index|[
name|midi_dev
index|]
expr_stmt|;
if|if
condition|(
name|timer_initialized
condition|)
return|return;
comment|/* There is already a similar timer */
name|timer_initialized
operator|=
literal|1
expr_stmt|;
name|mpu_timer
operator|.
name|devlink
operator|=
name|midi_dev
expr_stmt|;
name|dev_conf
index|[
name|midi_dev
index|]
operator|.
name|timer_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|num_sound_timers
operator|>=
name|MAX_TIMER_DEV
condition|)
name|n
operator|=
literal|0
expr_stmt|;
comment|/* Overwrite the system timer */
else|else
name|n
operator|=
name|num_sound_timers
operator|++
expr_stmt|;
name|sound_timer_devs
index|[
name|n
index|]
operator|=
operator|&
name|mpu_timer
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|version
operator|<
literal|0x20
condition|)
comment|/* Original MPU-401 */
name|timer_caps
operator|=
name|TMR_INTERNAL
operator||
name|TMR_EXTERNAL
operator||
name|TMR_MODE_FSK
operator||
name|TMR_MODE_MIDI
expr_stmt|;
else|else
block|{
comment|/* 	 * The version number 2.0 is used (at least) by the 	 * MusicQuest cards and the Roland Super-MPU. 	 *  	 * MusicQuest has given a special meaning to the bits of the 	 * revision number. The Super-MPU returns 0. 	 */
if|if
condition|(
name|devc
operator|->
name|revision
condition|)
name|timer_caps
operator||=
name|TMR_EXTERNAL
operator||
name|TMR_MODE_MIDI
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|revision
operator|&
literal|0x02
condition|)
name|timer_caps
operator||=
name|TMR_MODE_CLS
expr_stmt|;
if|if
condition|(
name|devc
operator|->
name|revision
operator|&
literal|0x40
condition|)
name|max_timebase
operator|=
literal|10
expr_stmt|;
comment|/* Has the 216 and 240 ppqn modes */
block|}
name|timer_mode
operator|=
operator|(
name|TMR_INTERNAL
operator||
name|TMR_MODE_MIDI
operator|)
operator|&
name|timer_caps
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

