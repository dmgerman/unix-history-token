begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Marc.Hoffman@analog.com     This is a pss driver.     it is based on Greg.Yukna@analog.com @file{host} for DOG     Unfortunately I can't distribute the ld file needed to    make the pss card to emulate the SB stuff.     I have provided a simple interface to the PSS unlike the    DOG version.  to download a new algorithim just cat it to    /dev/pss 14,9.     You really need to rebuild this with the synth.ld file     get the<synth>.ld from your dos directory maybe    voyetra\dsp001.ld     ld2inc< synth.ld> synth-ld.h    (make config does the same).     rebuild     Okay if you blow things away no problem just     main(){ioctl(open("/dev/pss"),SNDCTL_PSS_RESET)};     and everything will be okay.     At first I was going to wory about applications that were using    the sound stuff and disallow the use of /dev/pss.  But for    now I figured it doesn't matter.     And if you change algos all the other applications running die off    due to DMA problems.  Yeah just pull the plug and watch em die.     If the registers get hosed    main(){ioctl(open("/dev/pss"),SNDCTL_PSS_SETUP_REGISTERS)};     Probably everything else can be done via mmap     Oh if you want to develope code for the ADSP-21xx or Program the    1848 just send me mail and I will hook you up.                 marc.hoffman@analog.com     */
end_comment

begin_include
include|#
directive|include
file|"sound_config.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIGURE_SOUNDCARD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EXCLUDE_PSS
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|PSS_MSS_BASE
end_ifndef

begin_define
define|#
directive|define
name|PSS_MSS_BASE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PSS_MPU_BASE
end_ifndef

begin_define
define|#
directive|define
name|PSS_MPU_BASE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PSS_MPU_IRQ
end_ifndef

begin_define
define|#
directive|define
name|PSS_MPU_IRQ
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|DEB
end_undef

begin_define
define|#
directive|define
name|DEB
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_include
include|#
directive|include
file|"pss.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|pss_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sb_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pss_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pss_irq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pss_dma
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gamePort
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sbInt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cdPol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cdAddr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0x340;	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|cdInt
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define these by hand in local.h */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wssAddr
init|=
name|PSS_MSS_BASE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|midiAddr
init|=
name|PSS_MPU_BASE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|midiInt
init|=
name|PSS_MPU_IRQ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SoundPortAddress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|SoundPortData
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|speaker
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pss_speaker
name|default_speaker
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|PSS_STEREO
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_WAIT_QUEUE
argument_list|(
name|pss_sleeper
argument_list|,
name|pss_sleep_flag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"synth-ld.h"
end_include

begin_function_decl
specifier|static
name|int
name|pss_download_boot
parameter_list|(
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pss_reset_dsp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|void
name|pss_outpw
parameter_list|(
name|unsigned
name|short
name|port
parameter_list|,
name|unsigned
name|short
name|value
parameter_list|)
block|{
asm|__asm__
specifier|__volatile__
asm|("outw %w0, %w1" 				:
comment|/* no outputs */
asm|:"a"            (value), "d" (port));
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|int
name|pss_inpw
parameter_list|(
name|unsigned
name|short
name|port
parameter_list|)
block|{
name|unsigned
name|int
name|_v
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|("inw %w1,%w0" 				:"=a"           (_v):"d" (port), "0" (0));
return|return
name|_v
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|PSS_write
parameter_list|(
name|int
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|limit
decl_stmt|;
name|limit
operator|=
name|GET_TIME
argument_list|()
operator|+
literal|10
expr_stmt|;
comment|/* The timeout is 0.1 secods */
comment|/*    * Note! the i<5000000 is an emergency exit. The dsp_command() is sometimes    * called while interrupts are disabled. This means that the timer is    * disabled also. However the timeout situation is a abnormal condition.    * Normally the DSP should be ready to accept commands after just couple of    * loops.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5000000
operator|&&
name|GET_TIME
argument_list|()
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_STATUS
argument_list|)
operator|&
name|PSS_WRITE_EMPTY
condition|)
block|{
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_DATA
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|printk
argument_list|(
literal|"PSS: DSP Command (%04x) Timeout.\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"IRQ conflict???\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pss_setaddr
parameter_list|(
name|int
name|addr
parameter_list|,
name|int
name|configAddr
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|pss_inpw
argument_list|(
name|configAddr
argument_list|)
expr_stmt|;
name|val
operator|&=
name|ADDR_MASK
expr_stmt|;
name|val
operator||=
operator|(
name|addr
operator|<<
literal|4
operator|)
expr_stmt|;
name|pss_outpw
argument_list|(
name|configAddr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*_____ pss_checkint          This function tests an interrupt number to see if 	 it is availible. It takes the interrupt button 	 as it's argument and returns TRUE if the interrupt 	 is ok. */
end_comment

begin_function
specifier|static
name|int
name|pss_checkint
parameter_list|(
name|int
name|intNum
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*_____ Set the interrupt bits */
switch|switch
condition|(
name|intNum
condition|)
block|{
case|case
literal|3
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_3_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_5_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_7_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_9_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_10_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_11_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_12_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printk
argument_list|(
literal|"unknown interupt selected. %d\n"
argument_list|,
name|intNum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*_____ Set the interrupt test bit */
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|)
expr_stmt|;
name|val
operator||=
name|INT_TEST_BIT
expr_stmt|;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
comment|/*_____ Check if the interrupt is in use */
comment|/*_____ Do it a few times in case there is a delay */
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|INT_TEST_PASS
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/*_____ Clear the Test bit and the interrupt bits */
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_TEST_BIT_MASK
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*____ pss_setint         This function sets the correct bits in the 	configuration register to 	enable the chosen interrupt. */
end_comment

begin_function
specifier|static
name|void
name|pss_setint
parameter_list|(
name|int
name|intNum
parameter_list|,
name|int
name|configAddress
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
switch|switch
condition|(
name|intNum
condition|)
block|{
case|case
literal|0
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|configAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|pss_outpw
argument_list|(
name|configAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|configAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_3_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|configAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|configAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_5_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|configAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|configAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_7_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|configAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|9
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|configAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_9_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|configAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|configAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_10_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|configAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|configAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_11_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|configAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|configAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_12_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|configAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printk
argument_list|(
literal|"pss_setint unkown int\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*____ pss_setsbint         This function sets the correct bits in the 	SoundBlaster configuration PSS register to 	enable the chosen interrupt. 	It takes a interrupt button as its argument. */
end_comment

begin_function
specifier|static
name|void
name|pss_setsbint
parameter_list|(
name|int
name|intNum
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|int
name|sbConfigAddress
decl_stmt|;
name|sbConfigAddress
operator|=
name|pss_base
operator|+
name|SB_CONFIG
expr_stmt|;
switch|switch
condition|(
name|intNum
condition|)
block|{
case|case
literal|3
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|sbConfigAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_3_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|sbConfigAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|sbConfigAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_5_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|sbConfigAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|sbConfigAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|INT_MASK
expr_stmt|;
name|val
operator||=
name|INT_7_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|sbConfigAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printk
argument_list|(
literal|"pss_setsbint: unknown_int\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*____ pss_setsbdma         This function sets the correct bits in the 	SoundBlaster configuration PSS register to 	enable the chosen DMA channel. 	It takes a DMA button as its argument. */
end_comment

begin_function
specifier|static
name|void
name|pss_setsbdma
parameter_list|(
name|int
name|dmaNum
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|int
name|sbConfigAddress
decl_stmt|;
name|sbConfigAddress
operator|=
name|pss_base
operator|+
name|SB_CONFIG
expr_stmt|;
switch|switch
condition|(
name|dmaNum
condition|)
block|{
case|case
literal|1
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|sbConfigAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|DMA_MASK
expr_stmt|;
name|val
operator||=
name|DMA_1_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|sbConfigAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printk
argument_list|(
literal|"Personal Sound System ERROR! pss_setsbdma: unknown_dma\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*____ pss_setwssdma         This function sets the correct bits in the 	WSS configuration PSS register to 	enable the chosen DMA channel. 	It takes a DMA button as its argument. */
end_comment

begin_function
specifier|static
name|void
name|pss_setwssdma
parameter_list|(
name|int
name|dmaNum
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
name|int
name|wssConfigAddress
decl_stmt|;
name|wssConfigAddress
operator|=
name|pss_base
operator|+
name|PSS_WSS_CONFIG
expr_stmt|;
switch|switch
condition|(
name|dmaNum
condition|)
block|{
case|case
literal|0
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|wssConfigAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|DMA_MASK
expr_stmt|;
name|val
operator||=
name|DMA_0_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|wssConfigAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|wssConfigAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|DMA_MASK
expr_stmt|;
name|val
operator||=
name|DMA_1_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|wssConfigAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|val
operator|=
name|pss_inpw
argument_list|(
name|wssConfigAddress
argument_list|)
expr_stmt|;
name|val
operator|&=
name|DMA_MASK
expr_stmt|;
name|val
operator||=
name|DMA_3_BITS
expr_stmt|;
name|pss_outpw
argument_list|(
name|wssConfigAddress
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printk
argument_list|(
literal|"Personal Sound System ERROR! pss_setwssdma: unknown_dma\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*_____ SetSpeakerOut          This function sets the Volume, Bass, Treble and Mode of 	 the speaker out channel. 	 */
end_comment

begin_function
name|void
name|pss_setspeaker
parameter_list|(
name|struct
name|pss_speaker
modifier|*
name|spk
parameter_list|)
block|{
name|PSS_write
argument_list|(
name|SET_MASTER_COMMAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|spk
operator|->
name|volume
operator|>
name|PHILLIPS_VOL_MAX
condition|)
name|spk
operator|->
name|volume
operator|=
name|PHILLIPS_VOL_MAX
expr_stmt|;
if|if
condition|(
name|spk
operator|->
name|volume
operator|<
name|PHILLIPS_VOL_MIN
condition|)
name|spk
operator|->
name|volume
operator|=
name|PHILLIPS_VOL_MIN
expr_stmt|;
name|PSS_write
argument_list|(
name|MASTER_VOLUME_LEFT
operator||
operator|(
name|PHILLIPS_VOL_CONSTANT
operator|+
name|spk
operator|->
name|volume
operator|/
name|PHILLIPS_VOL_STEP
operator|)
argument_list|)
expr_stmt|;
name|PSS_write
argument_list|(
name|SET_MASTER_COMMAND
argument_list|)
expr_stmt|;
name|PSS_write
argument_list|(
name|MASTER_VOLUME_RIGHT
operator||
operator|(
name|PHILLIPS_VOL_CONSTANT
operator|+
name|spk
operator|->
name|volume
operator|/
name|PHILLIPS_VOL_STEP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spk
operator|->
name|bass
operator|>
name|PHILLIPS_BASS_MAX
condition|)
name|spk
operator|->
name|bass
operator|=
name|PHILLIPS_BASS_MAX
expr_stmt|;
if|if
condition|(
name|spk
operator|->
name|bass
operator|<
name|PHILLIPS_BASS_MIN
condition|)
name|spk
operator|->
name|bass
operator|=
name|PHILLIPS_BASS_MIN
expr_stmt|;
name|PSS_write
argument_list|(
name|SET_MASTER_COMMAND
argument_list|)
expr_stmt|;
name|PSS_write
argument_list|(
name|MASTER_BASS
operator||
operator|(
name|PHILLIPS_BASS_CONSTANT
operator|+
name|spk
operator|->
name|bass
operator|/
name|PHILLIPS_BASS_STEP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spk
operator|->
name|treb
operator|>
name|PHILLIPS_TREBLE_MAX
condition|)
name|spk
operator|->
name|treb
operator|=
name|PHILLIPS_TREBLE_MAX
expr_stmt|;
if|if
condition|(
name|spk
operator|->
name|treb
operator|<
name|PHILLIPS_TREBLE_MIN
condition|)
name|spk
operator|->
name|treb
operator|=
name|PHILLIPS_TREBLE_MIN
expr_stmt|;
name|PSS_write
argument_list|(
name|SET_MASTER_COMMAND
argument_list|)
expr_stmt|;
name|PSS_write
argument_list|(
name|MASTER_TREBLE
operator||
operator|(
name|PHILLIPS_TREBLE_CONSTANT
operator|+
name|spk
operator|->
name|treb
operator|/
name|PHILLIPS_TREBLE_STEP
operator|)
argument_list|)
expr_stmt|;
name|PSS_write
argument_list|(
name|SET_MASTER_COMMAND
argument_list|)
expr_stmt|;
name|PSS_write
argument_list|(
name|MASTER_SWITCH
operator||
name|spk
operator|->
name|mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pss_init1848
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*_____ Wait for 1848 to init */
while|while
condition|(
name|INB
argument_list|(
name|SoundPortAddress
argument_list|)
operator|&
name|SP_IN_INIT
condition|)
empty_stmt|;
comment|/*_____ Wait for 1848 to autocal */
name|OUTB
argument_list|(
name|SoundPortAddress
argument_list|,
name|SP_TEST_AND_INIT
argument_list|)
expr_stmt|;
while|while
condition|(
name|INB
argument_list|(
name|SoundPortData
argument_list|)
operator|&
name|AUTO_CAL_IN_PROG
condition|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pss_configure_registers_to_look_like_sb
parameter_list|(
name|void
parameter_list|)
block|{
name|pss_setaddr
argument_list|(
name|wssAddr
argument_list|,
name|pss_base
operator|+
name|PSS_WSS_CONFIG
argument_list|)
expr_stmt|;
name|SoundPortAddress
operator|=
name|wssAddr
operator|+
literal|4
expr_stmt|;
name|SoundPortData
operator|=
name|wssAddr
operator|+
literal|5
expr_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"Turning Game Port %s.\n"
argument_list|,
name|gamePort
condition|?
literal|"On"
else|:
literal|"Off"
argument_list|)
argument_list|)
expr_stmt|;
comment|/*_____ Turn on the Game port */
if|if
condition|(
name|gamePort
condition|)
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_STATUS
argument_list|,
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_STATUS
argument_list|)
operator||
name|GAME_BIT
argument_list|)
expr_stmt|;
else|else
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_STATUS
argument_list|,
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_STATUS
argument_list|)
operator|&
name|GAME_BIT_MASK
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"PSS attaching base %x irq %d dma %d\n"
argument_list|,
name|pss_base
argument_list|,
name|pss_irq
argument_list|,
name|pss_dma
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if sb is enabled if it is check the interrupt */
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|SB_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pss_irq
operator|!=
literal|0
condition|)
block|{
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"PSS Emulating Sound Blaster ADDR %04x\n"
argument_list|,
name|pss_base
argument_list|)
argument_list|)
expr_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"PSS SBC: attaching base %x irq %d dma %d\n"
argument_list|,
name|SBC_BASE
argument_list|,
name|SBC_IRQ
argument_list|,
name|SBC_DMA
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pss_checkint
argument_list|(
name|SBC_IRQ
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"PSS! attach: int_error\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|pss_setsbint
argument_list|(
name|SBC_IRQ
argument_list|)
expr_stmt|;
name|pss_setsbdma
argument_list|(
name|SBC_DMA
argument_list|)
expr_stmt|;
name|sb_ok
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sb_ok
operator|=
literal|0
expr_stmt|;
name|printk
argument_list|(
literal|"PSS: sound blaster error init\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Check if cd is enabled if it is check the interrupt */
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|CD_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdAddr
operator|!=
literal|0
condition|)
block|{
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"PSS:CD drive %x irq: %d"
argument_list|,
name|cdAddr
argument_list|,
name|cdInt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdInt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pss_checkint
argument_list|(
name|cdInt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"Can't allocate cdInt %d\n"
argument_list|,
name|cdInt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|val
decl_stmt|;
name|printk
argument_list|(
literal|"CD poll "
argument_list|)
expr_stmt|;
name|pss_setaddr
argument_list|(
name|cdAddr
argument_list|,
name|pss_base
operator|+
name|CD_CONFIG
argument_list|)
expr_stmt|;
name|pss_setint
argument_list|(
name|cdInt
argument_list|,
name|pss_base
operator|+
name|CD_CONFIG
argument_list|)
expr_stmt|;
comment|/* set the correct bit in the 		 configuration register to 		 set the irq polarity for the CD-Rom. 		 NOTE: This bit is in the address config 		 field, It must be configured after setting 		 the CD-ROM ADDRESS!!! */
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|CD_CONFIG
argument_list|)
expr_stmt|;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|CD_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|val
operator|&=
name|CD_POL_MASK
expr_stmt|;
if|if
condition|(
name|cdPol
condition|)
name|val
operator||=
name|CD_POL_BIT
expr_stmt|;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|CD_CONFIG
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Check if midi is enabled if it is check the interrupt */
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|MIDI_CONFIG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|midiAddr
operator|!=
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"midi init %x %d\n"
argument_list|,
name|midiAddr
argument_list|,
name|midiInt
argument_list|)
expr_stmt|;
if|if
condition|(
name|pss_checkint
argument_list|(
name|midiInt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"midi init int error %x %d\n"
argument_list|,
name|midiAddr
argument_list|,
name|midiInt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pss_setaddr
argument_list|(
name|midiAddr
argument_list|,
name|pss_base
operator|+
name|MIDI_CONFIG
argument_list|)
expr_stmt|;
name|pss_setint
argument_list|(
name|midiInt
argument_list|,
name|pss_base
operator|+
name|MIDI_CONFIG
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|long
name|attach_pss
parameter_list|(
name|long
name|mem_start
parameter_list|,
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
if|if
condition|(
name|pss_ok
condition|)
block|{
if|if
condition|(
name|hw_config
condition|)
block|{
name|printk
argument_list|(
literal|"<PSS-ESC614>"
argument_list|)
expr_stmt|;
block|}
return|return
name|mem_start
return|;
block|}
name|pss_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pss_configure_registers_to_look_like_sb
argument_list|()
operator|==
literal|0
condition|)
return|return
name|mem_start
return|;
if|if
condition|(
name|sb_ok
condition|)
if|if
condition|(
name|pss_synthLen
operator|&&
name|pss_download_boot
argument_list|(
name|pss_synth
argument_list|,
name|pss_synthLen
argument_list|)
condition|)
block|{
if|if
condition|(
name|speaker
condition|)
name|pss_setspeaker
argument_list|(
operator|&
name|default_speaker
argument_list|)
expr_stmt|;
name|pss_ok
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|pss_reset_dsp
argument_list|()
expr_stmt|;
return|return
name|mem_start
return|;
block|}
end_function

begin_function
name|int
name|probe_pss
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|pss_base
operator|=
name|hw_config
operator|->
name|io_base
expr_stmt|;
name|pss_irq
operator|=
name|hw_config
operator|->
name|irq
expr_stmt|;
name|pss_dma
operator|=
name|hw_config
operator|->
name|dma
expr_stmt|;
if|if
condition|(
operator|(
name|pss_inpw
argument_list|(
name|pss_base
operator|+
literal|4
argument_list|)
operator|&
literal|0xff00
operator|)
operator|==
literal|0x4500
condition|)
block|{
name|attach_pss
argument_list|(
literal|0
argument_list|,
name|hw_config
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|printk
argument_list|(
literal|" fail base %x irq %d dma %d\n"
argument_list|,
name|pss_base
argument_list|,
name|pss_irq
argument_list|,
name|pss_dma
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pss_reattach
parameter_list|(
name|void
parameter_list|)
block|{
name|pss_ok
operator|=
literal|0
expr_stmt|;
name|attach_pss
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pss_reset_dsp
parameter_list|()
block|{
name|unsigned
name|long
name|i
decl_stmt|,
name|limit
init|=
name|GET_TIME
argument_list|()
operator|+
literal|10
decl_stmt|;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONTROL
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32768
operator|&&
name|GET_TIME
argument_list|()
operator|<
name|limit
condition|;
name|i
operator|++
control|)
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONTROL
argument_list|)
expr_stmt|;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_CONTROL
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pss_download_boot
parameter_list|(
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|limit
decl_stmt|,
name|val
decl_stmt|,
name|count
decl_stmt|;
name|printk
argument_list|(
literal|"PSS: downloading boot code synth.ld... "
argument_list|)
expr_stmt|;
comment|/*_____ Warn DSP software that a boot is coming */
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_DATA
argument_list|,
literal|0x00fe
argument_list|)
expr_stmt|;
name|limit
operator|=
name|GET_TIME
argument_list|()
operator|+
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32768
operator|&&
name|GET_TIME
argument_list|()
operator|<
name|limit
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_DATA
argument_list|)
operator|==
literal|0x5500
condition|)
break|break;
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_DATA
argument_list|,
operator|*
name|block
operator|++
argument_list|)
expr_stmt|;
name|pss_reset_dsp
argument_list|()
expr_stmt|;
name|printk
argument_list|(
literal|"start "
argument_list|)
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|327670
condition|;
name|j
operator|++
control|)
block|{
comment|/*_____ Wait for BG to appear */
if|if
condition|(
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_STATUS
argument_list|)
operator|&
name|PSS_FLAG3
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
literal|327670
condition|)
block|{
comment|/* It's ok we timed out when the file was empty */
if|if
condition|(
name|count
operator|>=
name|size
condition|)
break|break;
else|else
block|{
name|printk
argument_list|(
literal|"\nPSS: DownLoad timeout problems, byte %d=%d\n"
argument_list|,
name|count
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/*_____ Send the next byte */
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_DATA
argument_list|,
operator|*
name|block
operator|++
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/*_____ Why */
name|pss_outpw
argument_list|(
name|pss_base
operator|+
name|PSS_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|limit
operator|=
name|GET_TIME
argument_list|()
operator|+
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32768
operator|&&
name|GET_TIME
argument_list|()
operator|<
name|limit
condition|;
name|i
operator|++
control|)
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_STATUS
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"downloaded\n"
argument_list|)
expr_stmt|;
name|limit
operator|=
name|GET_TIME
argument_list|()
operator|+
literal|10
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32768
operator|&&
name|GET_TIME
argument_list|()
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
literal|0x4000
condition|)
break|break;
block|}
comment|/* now read the version */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32000
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_STATUS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&
name|PSS_READ_FULL
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|32000
condition|)
return|return
literal|0
return|;
name|val
operator|=
name|pss_inpw
argument_list|(
name|pss_base
operator|+
name|PSS_DATA_REG
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* The following is a simple device driver for the pss.    All I really care about is comunication to and from the pss.     The ability to reinitialize the<synth.ld>  This will be    default when release is choosen.     SNDCTL_PSS_DOWNLOAD:     Okay we need to creat new minor numbers for the    DOWNLOAD functionality.     14,0x19 -- /dev/pssld where a read operation would output the                          current ld to user space                          where a write operation would effectively 			 download a new ld.     14,0x09 -- /dev/psecho  would open up a comunication path to the                          esc614 asic.  Given the ability to send 			 messages to the asic and recive messages too.  			 All messages would get read and written in the 			 same manner.  It would be up to the application 			 and the ld to maintain a relationship 			 of what the messages mean. 			 			 for this device we need to implement select. */
end_comment

begin_define
define|#
directive|define
name|CODE_BUFFER_LEN
value|(64*1024)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|code_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|code_length
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lock_pss
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pss_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"pss_open\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pss_ok
operator|==
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|lock_pss
condition|)
return|return
literal|0
return|;
name|lock_pss
operator|=
literal|1
expr_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|mode
operator|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|O_WRONLY
condition|)
block|{
name|printk
argument_list|(
literal|"pss-open for WRONLY\n"
argument_list|)
expr_stmt|;
name|code_length
operator|=
literal|0
expr_stmt|;
block|}
name|RESET_WAIT_QUEUE
argument_list|(
name|pss_sleeper
argument_list|,
name|pss_sleep_flag
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|pss_release
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|)
block|{
name|int
name|mode
decl_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"pss_release\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pss_ok
operator|==
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|mode
operator|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|O_WRONLY
operator|&&
name|code_length
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|linux
comment|/* This just allows interrupts while the conversion is running */
asm|__asm__ ("sti");
endif|#
directive|endif
if|if
condition|(
operator|!
name|pss_download_boot
argument_list|(
name|code_buffer
argument_list|,
name|code_length
argument_list|)
condition|)
block|{
name|pss_reattach
argument_list|()
expr_stmt|;
block|}
block|}
name|lock_pss
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pss_read
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|snd_rw_buf
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|p
decl_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"pss_read\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pss_ok
operator|==
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
name|c
operator|=
name|count
expr_stmt|;
return|return
name|count
operator|-
name|c
return|;
block|}
end_function

begin_function
name|int
name|pss_write
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|snd_rw_buf
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"pss_write\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pss_ok
operator|==
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|count
condition|)
comment|/* Flush output */
block|{
name|COPY_FROM_USER
argument_list|(
operator|&
name|code_buffer
index|[
name|code_length
index|]
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|code_length
operator|+=
name|count
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
name|int
name|pss_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|arg
parameter_list|)
block|{
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"pss_ioctl dev=%d cmd=%x\n"
argument_list|,
name|dev
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pss_ok
operator|==
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_PSS_RESET
case|:
name|pss_reattach
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SNDCTL_PSS_SETUP_REGISTERS
case|:
name|pss_configure_registers_to_look_like_sb
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SNDCTL_PSS_SPEAKER
case|:
block|{
name|struct
name|pss_speaker
name|params
decl_stmt|;
name|COPY_FROM_USER
argument_list|(
operator|&
name|params
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pss_speaker
argument_list|)
argument_list|)
expr_stmt|;
name|pss_setspeaker
argument_list|(
operator|&
name|params
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
default|default:
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* This is going to be used to implement    waiting on messages sent from the DSP and to the    DSP when comunication is used via the pss directly.     We need to find out if the pss can generate a diffrent    interupt other than the one it has been setup for.     This way we can carry on a conversation with the pss    on a seprate chanel.  This would be usefull for debugging. */
end_comment

begin_macro
name|pss_select
argument_list|(
argument|int dev
argument_list|,
argument|struct fileinfo * file
argument_list|,
argument|int sel_type
argument_list|,
argument|select_table * wait
argument_list|)
end_macro

begin_block
block|{
return|return
literal|0
return|;
if|if
condition|(
name|pss_ok
operator|==
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
switch|switch
condition|(
name|sel_type
condition|)
block|{
case|case
name|SEL_IN
case|:
name|select_wait
argument_list|(
operator|&
name|pss_sleeper
argument_list|,
name|wait
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SEL_OUT
case|:
name|select_wait
argument_list|(
operator|&
name|pss_sleeper
argument_list|,
name|wait
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SEL_EX
case|:
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
name|long
name|pss_init
parameter_list|(
name|long
name|mem_start
parameter_list|)
block|{
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"pss_init\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pss_ok
condition|)
block|{
name|code_buffer
operator|=
name|mem_start
expr_stmt|;
name|mem_start
operator|+=
name|CODE_BUFFER_LEN
expr_stmt|;
block|}
return|return
name|mem_start
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

