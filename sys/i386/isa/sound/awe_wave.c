begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/awe_wave.c  *  * The low level driver for the AWE32/Sound Blaster 32 wave table synth.  *   version 0.2.0a; Oct. 30, 1996  *  * (C) 1996 Takashi Iwai  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/* if you're using obsolete VoxWare 3.0.x on Linux 1.2.x (or FreeBSD),  * uncomment the following line  */
end_comment

begin_define
define|#
directive|define
name|AWE_OBSOLETE_VOXWARE
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_OBSOLETE_VOXWARE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<i386/isa/sound/sound_config.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"sound_config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIGURE_SOUNDCARD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EXCLUDE_AWE32
argument_list|)
end_if

begin_define
define|#
directive|define
name|CONFIG_AWE32_SYNTH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* AWE_OBSOLETE_VOXWARE */
end_comment

begin_include
include|#
directive|include
file|"../sound_config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AWE_OBSOLETE_VOXWARE */
end_comment

begin_comment
comment|/*----------------------------------------------------------------*  * compile condition  *----------------------------------------------------------------*/
end_comment

begin_comment
comment|/* initialize FM passthrough even without extended RAM */
end_comment

begin_comment
comment|/*#define AWE_ALWAYS_INIT_FM*/
end_comment

begin_comment
comment|/* debug on */
end_comment

begin_define
define|#
directive|define
name|AWE_DEBUG_ON
end_define

begin_comment
comment|/* verify checksum for uploading samples */
end_comment

begin_define
define|#
directive|define
name|AWE_CHECKSUM_DATA
end_define

begin_define
define|#
directive|define
name|AWE_CHECKSUM_MEMORY
end_define

begin_comment
comment|/* disable interruption during sequencer operation */
end_comment

begin_comment
comment|/*#define AWE_NEED_DISABLE_INTR*/
end_comment

begin_comment
comment|/* use buffered access to user wave data */
end_comment

begin_define
define|#
directive|define
name|AWE_USE_BUFFERED_IO
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_comment
comment|/* i tested this only on my linux */
end_comment

begin_define
define|#
directive|define
name|INLINE
value|__inline__
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INLINE
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_AWE32_SYNTH
end_ifdef

begin_include
include|#
directive|include
file|<i386/isa/sound/awe_hw.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/sound/awe_voice.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_OBSOLETE_VOXWARE
end_ifdef

begin_include
include|#
directive|include
file|<i386/isa/sound/tuning.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"../tuning.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_include
include|#
directive|include
file|<linux/ultrasound.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<machine/ultrasound.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------------  * debug message  *----------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_DEBUG_ON
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|debug_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEBUG
parameter_list|(
name|LVL
parameter_list|,
name|XXX
parameter_list|)
value|{if (debug_mode> LVL) { XXX; }}
end_define

begin_define
define|#
directive|define
name|ERRMSG
parameter_list|(
name|XXX
parameter_list|)
value|{if (debug_mode) { XXX; }}
end_define

begin_define
define|#
directive|define
name|FATALERR
parameter_list|(
name|XXX
parameter_list|)
value|XXX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEBUG
parameter_list|(
name|LVL
parameter_list|,
name|XXX
parameter_list|)
end_define

begin_comment
comment|/**/
end_comment

begin_define
define|#
directive|define
name|ERRMSG
parameter_list|(
name|XXX
parameter_list|)
value|XXX
end_define

begin_define
define|#
directive|define
name|FATALERR
parameter_list|(
name|XXX
parameter_list|)
value|XXX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------------  * bank and voice record  *----------------------------------------------------------------*/
end_comment

begin_comment
comment|/* bank record */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_awe_voice_list
block|{
name|unsigned
name|char
name|bank
decl_stmt|,
name|instr
decl_stmt|;
name|awe_voice_info
name|v
decl_stmt|;
name|struct
name|_awe_voice_list
modifier|*
name|next_instr
decl_stmt|;
name|struct
name|_awe_voice_list
modifier|*
name|next_bank
decl_stmt|;
block|}
name|awe_voice_list
typedef|;
end_typedef

begin_comment
comment|/* sample and information table */
end_comment

begin_decl_stmt
specifier|static
name|awe_sample_info
modifier|*
name|samples
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|awe_voice_list
modifier|*
name|infos
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AWE_MAX_PRESETS
value|256
end_define

begin_define
define|#
directive|define
name|AWE_DEFAULT_BANK
value|0
end_define

begin_comment
comment|/* preset table index */
end_comment

begin_decl_stmt
specifier|static
name|awe_voice_list
modifier|*
name|preset_table
index|[
name|AWE_MAX_PRESETS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*----------------------------------------------------------------  * voice table  *----------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|AWE_FX_BYTES
value|((AWE_FX_END+7)/8)
end_define

begin_typedef
typedef|typedef
struct|struct
name|_voice_info
block|{
name|int
name|state
decl_stmt|;
comment|/* status (on = 1, off = 0) */
name|int
name|note
decl_stmt|;
comment|/* midi key (0-127) */
name|int
name|velocity
decl_stmt|;
comment|/* midi velocity (0-127) */
name|int
name|bender
decl_stmt|;
comment|/* midi pitchbend (-8192 - 8192) */
name|int
name|bender_range
decl_stmt|;
comment|/* midi bender range (x100) */
name|int
name|panning
decl_stmt|;
comment|/* panning (0-127) */
name|int
name|main_vol
decl_stmt|;
comment|/* channel volume (0-127) */
name|int
name|expression_vol
decl_stmt|;
comment|/* midi expression (0-127) */
comment|/* EMU8000 parameters */
name|int
name|apitch
decl_stmt|;
comment|/* pitch parameter */
name|int
name|avol
decl_stmt|;
comment|/* volume parameter */
comment|/* instrument parameters */
name|int
name|bank
decl_stmt|;
comment|/* current tone bank */
name|int
name|instr
decl_stmt|;
comment|/* current program */
name|awe_voice_list
modifier|*
name|vrec
decl_stmt|;
name|awe_voice_info
modifier|*
name|sample
decl_stmt|;
comment|/* channel effects */
name|unsigned
name|char
name|fx_flags
index|[
name|AWE_FX_BYTES
index|]
decl_stmt|;
name|short
name|fx
index|[
name|AWE_FX_END
index|]
decl_stmt|;
block|}
name|voice_info
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|voice_info
name|voices
index|[
name|AWE_MAX_VOICES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*----------------------------------------------------------------  * global variables  *----------------------------------------------------------------*/
end_comment

begin_comment
comment|/* awe32 base address (overwritten at initialization) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awe_base
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* memory byte size (overwritten at initialization) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|awe_mem_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum channels for playing */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awe_max_voices
init|=
name|AWE_MAX_VOICES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|free_mem_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free word byte size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|free_info
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free info tables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_info
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last loaded info index */
end_comment

begin_decl_stmt
specifier|static
name|int
name|free_sample
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free sample tables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_sample
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last loaded sample index */
end_comment

begin_decl_stmt
specifier|static
name|int
name|loaded_once
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* samples are loaded after init? */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|current_sf_id
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal id */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reverb_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reverb mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chorus_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* chorus mode */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|init_atten
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12dB */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awe_present
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* awe device present? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awe_busy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* awe device opened? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awe_gus_bank
init|=
name|AWE_DEFAULT_BANK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GUS default bank number */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|synth_info
name|awe_info
init|=
block|{
literal|"AWE32 Synth"
block|,
comment|/* name */
literal|0
block|,
comment|/* device */
name|SYNTH_TYPE_SAMPLE
block|,
comment|/* synth_type */
name|SAMPLE_TYPE_AWE32
block|,
comment|/* synth_subtype */
literal|0
block|,
comment|/* perc_mode (obsolete) */
name|AWE_MAX_VOICES
block|,
comment|/* nr_voices */
literal|0
block|,
comment|/* nr_drums (obsolete) */
name|AWE_MAX_INFOS
comment|/* instr_bank_size */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|voice_alloc_info
modifier|*
name|voice_alloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set at initialization */
end_comment

begin_comment
comment|/*----------------------------------------------------------------  * function prototypes  *----------------------------------------------------------------*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AWE_OBSOLETE_VOXWARE
end_ifndef

begin_function_decl
specifier|static
name|int
name|awe_check_port
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_request_region
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_release_region
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|awe_reset_samples
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* emu8000 chip i/o access */
end_comment

begin_function_decl
specifier|static
name|void
name|awe_poke
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|,
name|unsigned
name|short
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_poke_dw
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|,
name|unsigned
name|long
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|short
name|awe_peek
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|awe_peek_dw
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_wait
parameter_list|(
name|unsigned
name|short
name|delay
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* initialize emu8000 chip */
end_comment

begin_function_decl
specifier|static
name|void
name|awe_initialize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* set voice parameters */
end_comment

begin_function_decl
specifier|static
name|void
name|awe_init_voice_info
parameter_list|(
name|awe_voice_info
modifier|*
name|vp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_init_voice_parm
parameter_list|(
name|awe_voice_parm
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|freq_to_note
parameter_list|(
name|int
name|freq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|calc_rate_offset
parameter_list|(
name|int
name|Hz
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*static int calc_parm_delay(int msec);*/
end_comment

begin_function_decl
specifier|static
name|int
name|calc_parm_hold
parameter_list|(
name|int
name|msec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|calc_parm_attack
parameter_list|(
name|int
name|msec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|calc_parm_decay
parameter_list|(
name|int
name|msec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|calc_parm_search
parameter_list|(
name|int
name|msec
parameter_list|,
name|short
modifier|*
name|table
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* turn on/off note */
end_comment

begin_function_decl
specifier|static
name|void
name|awe_note_on
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_note_off
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_terminate
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_exclusive_off
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* calculate voice parameters */
end_comment

begin_function_decl
specifier|static
name|void
name|awe_set_pitch
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_set_volume
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_set_pan
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_fx_fmmod
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_fx_tremfrq
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_fx_fm2frq2
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_fx_cutoff
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_fx_initpitch
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_calc_pitch
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_calc_pitch_from_freq
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|freq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_calc_volume
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_voice_init
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|inst_only
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* sequencer interface */
end_comment

begin_function_decl
specifier|static
name|int
name|awe_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_close
parameter_list|(
name|int
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_kill_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_start_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|v
parameter_list|,
name|int
name|note_num
parameter_list|,
name|int
name|volume
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_set_instr
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|instr_no
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_reset
parameter_list|(
name|int
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_hw_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_load_patch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_aftertouch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|pressure
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_controller
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|ctrl_num
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_panning
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_volume_method
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_patchmgr
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|patmgr_info
modifier|*
name|rec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_bender
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_alloc
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|,
name|struct
name|voice_alloc_info
modifier|*
name|alloc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_setup_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|chn
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* hardware controls */
end_comment

begin_function_decl
specifier|static
name|void
name|awe_hw_gus_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_hw_awe_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* voice search */
end_comment

begin_function_decl
specifier|static
name|awe_voice_info
modifier|*
name|awe_search_voice
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|awe_voice_list
modifier|*
name|awe_search_instr
parameter_list|(
name|int
name|bank
parameter_list|,
name|int
name|preset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* load / remove patches */
end_comment

begin_function_decl
specifier|static
name|void
name|awe_check_loaded
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_load_info
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_load_data
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_load_guspatch
parameter_list|(
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_write_wave_data
parameter_list|(
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|long
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|awe_voice_list
modifier|*
name|awe_get_removed_list
parameter_list|(
name|awe_voice_list
modifier|*
name|curp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_remove_samples
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|short
name|awe_set_sample
parameter_list|(
name|awe_voice_info
modifier|*
name|vp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* lowlevel functions */
end_comment

begin_function_decl
specifier|static
name|void
name|awe_init_audio
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_init_dma
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_init_array
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_send_array
parameter_list|(
name|unsigned
name|short
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_tweak
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_init_fm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_open_dram_for_write
parameter_list|(
name|int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_open_dram_for_read
parameter_list|(
name|int
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_open_dram_for_check
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_close_dram
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_close_dram_for_read
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_write_dram
parameter_list|(
name|unsigned
name|short
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_detect
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_check_dram
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_set_chorus_mode
parameter_list|(
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_set_reverb_mode
parameter_list|(
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_OBSOLETE_VOXWARE
end_ifdef

begin_define
define|#
directive|define
name|awe_check_port
parameter_list|()
value|0
end_define

begin_comment
comment|/* always false */
end_comment

begin_define
define|#
directive|define
name|awe_request_region
parameter_list|()
end_define

begin_comment
comment|/* nothing */
end_comment

begin_define
define|#
directive|define
name|awe_release_region
parameter_list|()
end_define

begin_comment
comment|/* nothing */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|PERMANENT_MALLOC
end_ifndef

begin_define
define|#
directive|define
name|PERMANENT_MALLOC
parameter_list|(
name|typecast
parameter_list|,
name|mem_ptr
parameter_list|,
name|size
parameter_list|)
define|\
value|{mem_ptr = (typecast)malloc(size, M_DEVBUF, M_NOWAIT); \         if (!mem_ptr)panic("SOUND: Cannot allocate memory\n");}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|printk
end_ifndef

begin_define
define|#
directive|define
name|printk
value|printf
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|RET_ERROR
end_ifndef

begin_define
define|#
directive|define
name|RET_ERROR
parameter_list|(
name|err
parameter_list|)
value|-(err)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* AWE_OBSOLETE_VOXWARE */
end_comment

begin_comment
comment|/* the following macros are osbolete */
end_comment

begin_define
define|#
directive|define
name|PERMANENT_MALLOC
parameter_list|(
name|type
parameter_list|,
name|var
parameter_list|,
name|size
parameter_list|)
define|\
value|var = (type)(sound_mem_blocks[sound_nblocks++] = vmalloc(size))
end_define

begin_define
define|#
directive|define
name|RET_ERROR
parameter_list|(
name|err
parameter_list|)
value|-err
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AWE_OBSOLETE_VOXWARE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_NEED_DISABLE_INTR
end_ifdef

begin_define
define|#
directive|define
name|DECL_INTR_FLAGS
parameter_list|(
name|x
parameter_list|)
value|unsigned long x
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|DISABLE_INTR
end_undef

begin_undef
undef|#
directive|undef
name|RESTORE_INTR
end_undef

begin_define
define|#
directive|define
name|DECL_INTR_FLAGS
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|/**/
end_comment

begin_define
define|#
directive|define
name|DISABLE_INTR
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|/**/
end_comment

begin_define
define|#
directive|define
name|RESTORE_INTR
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* macros for Linux and FreeBSD compatibility */
end_comment

begin_undef
undef|#
directive|undef
name|OUTW
end_undef

begin_undef
undef|#
directive|undef
name|COPY_FROM_USER
end_undef

begin_undef
undef|#
directive|undef
name|GET_BYTE_FROM_USER
end_undef

begin_undef
undef|#
directive|undef
name|GET_SHORT_FROM_USER
end_undef

begin_undef
undef|#
directive|undef
name|IOCTL_TO_USER
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_define
define|#
directive|define
name|NO_DATA_ERR
value|ENODATA
end_define

begin_define
define|#
directive|define
name|OUTW
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
value|outw(data, addr)
end_define

begin_define
define|#
directive|define
name|COPY_FROM_USER
parameter_list|(
name|target
parameter_list|,
name|source
parameter_list|,
name|offs
parameter_list|,
name|count
parameter_list|)
define|\
value|memcpy_fromfs( ((caddr_t)(target)),(source)+(offs),(count) )
end_define

begin_define
define|#
directive|define
name|GET_BYTE_FROM_USER
parameter_list|(
name|target
parameter_list|,
name|addr
parameter_list|,
name|offs
parameter_list|)
define|\
value|*((char  *)&(target)) = get_fs_byte( (addr)+(offs) )
end_define

begin_define
define|#
directive|define
name|GET_SHORT_FROM_USER
parameter_list|(
name|target
parameter_list|,
name|addr
parameter_list|,
name|offs
parameter_list|)
define|\
value|*((short *)&(target)) = get_fs_word( (addr)+(offs) )
end_define

begin_define
define|#
directive|define
name|IOCTL_TO_USER
parameter_list|(
name|target
parameter_list|,
name|offs
parameter_list|,
name|source
parameter_list|,
name|count
parameter_list|)
define|\
value|memcpy_tofs  ( ((caddr_t)(target)),(source)+(offs),(count) )
end_define

begin_define
define|#
directive|define
name|BZERO
parameter_list|(
name|target
parameter_list|,
name|len
parameter_list|)
define|\
value|memset( (caddr_t)target, '\0', len )
end_define

begin_define
define|#
directive|define
name|MEMCPY
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
define|\
value|memcpy((caddr_t)dst, (caddr_t)src, len)
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|NO_DATA_ERR
value|EINVAL
end_define

begin_define
define|#
directive|define
name|OUTW
parameter_list|(
name|data
parameter_list|,
name|addr
parameter_list|)
value|outw(addr, data)
end_define

begin_define
define|#
directive|define
name|COPY_FROM_USER
parameter_list|(
name|target
parameter_list|,
name|source
parameter_list|,
name|offs
parameter_list|,
name|count
parameter_list|)
define|\
value|uiomove( ((caddr_t)(target)),(count),((struct uio *)(source)) )
end_define

begin_define
define|#
directive|define
name|GET_BYTE_FROM_USER
parameter_list|(
name|target
parameter_list|,
name|addr
parameter_list|,
name|offs
parameter_list|)
define|\
value|uiomove( ((char*)&(target)), 1, ((struct uio *)(addr)) )
end_define

begin_define
define|#
directive|define
name|GET_SHORT_FROM_USER
parameter_list|(
name|target
parameter_list|,
name|addr
parameter_list|,
name|offs
parameter_list|)
define|\
value|uiomove( ((char*)&(target)), 2, ((struct uio *)(addr)) )
end_define

begin_define
define|#
directive|define
name|IOCTL_TO_USER
parameter_list|(
name|target
parameter_list|,
name|offs
parameter_list|,
name|source
parameter_list|,
name|count
parameter_list|)
define|\
value|memcpy(&((target)[offs]), (source), (count) )
end_define

begin_define
define|#
directive|define
name|BZERO
parameter_list|(
name|target
parameter_list|,
name|len
parameter_list|)
define|\
value|bzero( (caddr_t)target, len )
end_define

begin_define
define|#
directive|define
name|MEMCPY
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
define|\
value|bcopy((caddr_t)src, (caddr_t)dst, len)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------------  * synth operation table  *----------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|synth_operations
name|awe_operations
init|=
block|{
operator|&
name|awe_info
block|,
literal|0
block|,
name|SYNTH_TYPE_SAMPLE
block|,
name|SAMPLE_TYPE_AWE32
block|,
name|awe_open
block|,
name|awe_close
block|,
name|awe_ioctl
block|,
name|awe_kill_note
block|,
name|awe_start_note
block|,
name|awe_set_instr
block|,
name|awe_reset
block|,
name|awe_hw_control
block|,
name|awe_load_patch
block|,
name|awe_aftertouch
block|,
name|awe_controller
block|,
name|awe_panning
block|,
name|awe_volume_method
block|,
name|awe_patchmgr
block|,
name|awe_bender
block|,
name|awe_alloc
block|,
name|awe_setup_voice
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*================================================================  * attach / unload interface  *================================================================*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|AWE_OBSOLETE_VOXWARE
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
name|void
name|attach_awe_obsolete
argument_list|(
expr|struct
name|address_info
operator|*
name|hw_config
argument_list|)
else|#
directive|else
name|int
name|attach_awe
argument_list|(
name|void
argument_list|)
endif|#
directive|endif
block|{
comment|/* check presence of AWE32 card */
if|if
condition|(
operator|!
name|awe_detect
argument_list|()
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: not detected"
argument_list|)
expr_stmt|;
return|return ;
block|}
comment|/* check AWE32 ports are available */
if|if
condition|(
name|awe_check_port
argument_list|()
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: I/O area already used."
argument_list|)
expr_stmt|;
return|return ;
block|}
comment|/* allocate sample tables */
name|PERMANENT_MALLOC
argument_list|(
name|awe_sample_info
operator|*
argument_list|,
name|samples
argument_list|,
name|AWE_MAX_SAMPLES
operator|*
sizeof|sizeof
argument_list|(
name|awe_sample_info
argument_list|)
argument_list|)
expr_stmt|;
name|PERMANENT_MALLOC
argument_list|(
name|awe_voice_list
operator|*
argument_list|,
name|infos
argument_list|,
name|AWE_MAX_INFOS
operator|*
sizeof|sizeof
argument_list|(
name|awe_voice_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|samples
operator|==
name|NULL
operator|||
name|infos
operator|==
name|NULL
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: can't allocate sample tables"
argument_list|)
expr_stmt|;
return|return ;
block|}
if|if
condition|(
name|num_synths
operator|>=
name|MAX_SYNTH_DEV
condition|)
name|printk
argument_list|(
literal|"AWE32 Error: too many synthesizers\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|voice_alloc
operator|=
operator|&
name|awe_operations
operator|.
name|alloc
expr_stmt|;
name|voice_alloc
operator|->
name|max_voice
operator|=
name|awe_max_voices
expr_stmt|;
name|synth_devs
index|[
name|num_synths
operator|++
index|]
operator|=
operator|&
name|awe_operations
expr_stmt|;
block|}
comment|/* reserve I/O ports for awedrv */
name|awe_request_region
argument_list|()
expr_stmt|;
comment|/* clear all samples */
name|awe_reset_samples
argument_list|()
expr_stmt|;
comment|/* intialize AWE32 hardware */
name|awe_initialize
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|awe_info
operator|.
name|name
argument_list|,
literal|"AWE32 Synth (%dk)"
argument_list|,
operator|(
name|int
operator|)
name|awe_mem_size
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|conf_printf
argument_list|(
name|awe_info
operator|.
name|name
argument_list|,
name|hw_config
argument_list|)
expr_stmt|;
comment|/* set reverb& chorus modes */
name|awe_set_reverb_mode
argument_list|(
name|reverb_mode
argument_list|)
expr_stmt|;
name|awe_set_chorus_mode
argument_list|(
name|chorus_mode
argument_list|)
expr_stmt|;
name|awe_present
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|AWE_OBSOLETE_VOXWARE
return|return ;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_OBSOLETE_VOXWARE
end_ifdef

begin_function
name|int
name|probe_awe_obsolete
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
return|return
literal|1
return|;
comment|/*return awe_detect();*/
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*================================================================  * clear sample tables   *================================================================*/
end_comment

begin_function
specifier|static
name|void
name|awe_reset_samples
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* free all bank tables */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_PRESETS
condition|;
name|i
operator|++
control|)
block|{
name|preset_table
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|free_mem_ptr
operator|=
literal|0
expr_stmt|;
name|last_sample
operator|=
name|free_sample
operator|=
literal|0
expr_stmt|;
name|last_info
operator|=
name|free_info
operator|=
literal|0
expr_stmt|;
name|current_sf_id
operator|=
literal|0
expr_stmt|;
name|loaded_once
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*================================================================  * EMU register access  *================================================================*/
end_comment

begin_comment
comment|/* select a given AWE32 pointer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awe_cur_cmd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|awe_set_cmd
parameter_list|(
name|cmd
parameter_list|)
define|\
value|if (awe_cur_cmd != cmd) { OUTW(cmd, awe_base + 0x802); awe_cur_cmd = cmd; }
end_define

begin_define
define|#
directive|define
name|awe_port
parameter_list|(
name|port
parameter_list|)
value|(awe_base - 0x620 + port)
end_define

begin_comment
comment|/* write 16bit data */
end_comment

begin_function
name|INLINE
specifier|static
name|void
name|awe_poke
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|,
name|unsigned
name|short
name|data
parameter_list|)
block|{
name|awe_set_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|data
argument_list|,
name|awe_port
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* write 32bit data */
end_comment

begin_function
name|INLINE
specifier|static
name|void
name|awe_poke_dw
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|,
name|unsigned
name|long
name|data
parameter_list|)
block|{
name|awe_set_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|data
argument_list|,
name|awe_port
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write lower 16 bits */
name|OUTW
argument_list|(
name|data
operator|>>
literal|16
argument_list|,
name|awe_port
argument_list|(
name|port
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* write higher 16 bits */
block|}
end_function

begin_comment
comment|/* read 16bit data */
end_comment

begin_function
name|INLINE
specifier|static
name|unsigned
name|short
name|awe_peek
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|)
block|{
name|unsigned
name|short
name|k
decl_stmt|;
name|awe_set_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|k
operator|=
name|inw
argument_list|(
name|awe_port
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_comment
comment|/* read 32bit data */
end_comment

begin_function
name|INLINE
specifier|static
name|unsigned
name|long
name|awe_peek_dw
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|)
block|{
name|unsigned
name|long
name|k1
decl_stmt|,
name|k2
decl_stmt|;
name|awe_set_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|k1
operator|=
name|inw
argument_list|(
name|awe_port
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|k2
operator|=
name|inw
argument_list|(
name|awe_port
argument_list|(
name|port
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|k1
operator||=
name|k2
operator|<<
literal|16
expr_stmt|;
return|return
name|k1
return|;
block|}
end_function

begin_comment
comment|/* wait delay number of AWE32 44100Hz clocks */
end_comment

begin_function
specifier|static
name|void
name|awe_wait
parameter_list|(
name|unsigned
name|short
name|delay
parameter_list|)
block|{
name|unsigned
name|short
name|clock
decl_stmt|,
name|target
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|awe_port
argument_list|(
name|AWE_WC_Port
argument_list|)
decl_stmt|;
name|int
name|counter
decl_stmt|;
comment|/* sample counter */
name|awe_set_cmd
argument_list|(
name|AWE_WC_Cmd
argument_list|)
expr_stmt|;
name|clock
operator|=
operator|(
name|unsigned
name|short
operator|)
name|inw
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|target
operator|=
name|clock
operator|+
name|delay
expr_stmt|;
name|counter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|target
operator|<
name|clock
condition|)
block|{
for|for
control|(
init|;
operator|(
name|unsigned
name|short
operator|)
name|inw
argument_list|(
name|port
argument_list|)
operator|>
name|target
condition|;
name|counter
operator|++
control|)
if|if
condition|(
name|counter
operator|>
literal|65536
condition|)
break|break;
block|}
for|for
control|(
init|;
operator|(
name|unsigned
name|short
operator|)
name|inw
argument_list|(
name|port
argument_list|)
operator|<
name|target
condition|;
name|counter
operator|++
control|)
if|if
condition|(
name|counter
operator|>
literal|65536
condition|)
break|break;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|AWE_OBSOLETE_VOXWARE
end_ifndef

begin_comment
comment|/*================================================================  * port check / request  *  0x620-622, 0xA20-A22, 0xE20-E22  *================================================================*/
end_comment

begin_function
specifier|static
name|int
name|awe_check_port
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|check_region
argument_list|(
name|awe_port
argument_list|(
name|Data0
argument_list|)
argument_list|,
literal|3
argument_list|)
operator|||
name|check_region
argument_list|(
name|awe_port
argument_list|(
name|Data1
argument_list|)
argument_list|,
literal|3
argument_list|)
operator|||
name|check_region
argument_list|(
name|awe_port
argument_list|(
name|Data3
argument_list|)
argument_list|,
literal|3
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|awe_request_region
parameter_list|(
name|void
parameter_list|)
block|{
name|request_region
argument_list|(
name|awe_port
argument_list|(
name|Data0
argument_list|)
argument_list|,
literal|3
argument_list|,
literal|"sound driver (AWE32)"
argument_list|)
expr_stmt|;
name|request_region
argument_list|(
name|awe_port
argument_list|(
name|Data1
argument_list|)
argument_list|,
literal|3
argument_list|,
literal|"sound driver (AWE32)"
argument_list|)
expr_stmt|;
name|request_region
argument_list|(
name|awe_port
argument_list|(
name|Data3
argument_list|)
argument_list|,
literal|3
argument_list|,
literal|"sound driver (AWE32)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awe_release_region
parameter_list|(
name|void
parameter_list|)
block|{
name|release_region
argument_list|(
name|awe_port
argument_list|(
name|Data0
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|release_region
argument_list|(
name|awe_port
argument_list|(
name|Data1
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|release_region
argument_list|(
name|awe_port
argument_list|(
name|Data3
argument_list|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !AWE_OBSOLETE_VOXWARE */
end_comment

begin_comment
comment|/*================================================================  * AWE32 initialization  *================================================================*/
end_comment

begin_function
specifier|static
name|void
name|awe_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|short
name|data
decl_stmt|;
name|DECL_INTR_FLAGS
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: initializing..\n"
argument_list|)
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* check for an error condition */
name|data
operator|=
name|awe_peek
argument_list|(
name|AWE_U1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|data
operator|&
literal|0x000F
operator|)
operator|==
literal|0x000C
condition|)
block|{
name|FATALERR
argument_list|(
name|printk
argument_list|(
literal|"AWE32: can't initialize AWE32\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* initialize hardware configuration */
name|awe_poke
argument_list|(
name|AWE_HWCF1
argument_list|,
literal|0x0059
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_HWCF2
argument_list|,
literal|0x0020
argument_list|)
expr_stmt|;
comment|/* disable audio output */
name|awe_poke
argument_list|(
name|AWE_HWCF3
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
comment|/* initialize audio channels */
name|awe_init_audio
argument_list|()
expr_stmt|;
comment|/* initialize init array */
name|awe_init_dma
argument_list|()
expr_stmt|;
name|awe_init_array
argument_list|()
expr_stmt|;
comment|/* check DRAM memory size */
name|awe_mem_size
operator|=
name|awe_check_dram
argument_list|()
expr_stmt|;
comment|/* initialize the FM section of the AWE32 */
name|awe_init_fm
argument_list|()
expr_stmt|;
comment|/* set up voice envelopes */
name|awe_tweak
argument_list|()
expr_stmt|;
comment|/* enable audio */
name|awe_poke
argument_list|(
name|AWE_HWCF3
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
name|data
operator|=
name|awe_peek
argument_list|(
name|AWE_HWCF2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|~
name|data
operator|&
literal|0x40
condition|)
block|{
name|FATALERR
argument_list|(
name|printk
argument_list|(
literal|"AWE32: Unable to initialize AWE32.\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*================================================================  * AWE32 voice parameters  *================================================================*/
end_comment

begin_comment
comment|/* initialize voice_info record */
end_comment

begin_function
specifier|static
name|void
name|awe_init_voice_info
parameter_list|(
name|awe_voice_info
modifier|*
name|vp
parameter_list|)
block|{
name|vp
operator|->
name|sf_id
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|sample
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|rate_offset
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|loopstart
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|loopend
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|root
operator|=
literal|60
expr_stmt|;
name|vp
operator|->
name|tune
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|low
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|high
operator|=
literal|127
expr_stmt|;
name|vp
operator|->
name|vellow
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|velhigh
operator|=
literal|127
expr_stmt|;
name|vp
operator|->
name|fixkey
operator|=
operator|-
literal|1
expr_stmt|;
name|vp
operator|->
name|fixvel
operator|=
operator|-
literal|1
expr_stmt|;
name|vp
operator|->
name|fixpan
operator|=
operator|-
literal|1
expr_stmt|;
name|vp
operator|->
name|pan
operator|=
operator|-
literal|1
expr_stmt|;
name|vp
operator|->
name|exclusiveClass
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|amplitude
operator|=
literal|127
expr_stmt|;
name|vp
operator|->
name|attenuation
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|scaleTuning
operator|=
literal|100
expr_stmt|;
name|awe_init_voice_parm
argument_list|(
operator|&
name|vp
operator|->
name|parm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* initialize voice_parm record:  * Env1/2: delay=0, attack=0, hold=0, sustain=0, decay=0, release=0.  * Vibrato and Tremolo effects are zero.  * Cutoff is maximum.  * Chorus and Reverb effects are zero.  */
end_comment

begin_function
specifier|static
name|void
name|awe_init_voice_parm
parameter_list|(
name|awe_voice_parm
modifier|*
name|pp
parameter_list|)
block|{
name|pp
operator|->
name|moddelay
operator|=
literal|0x8000
expr_stmt|;
name|pp
operator|->
name|modatkhld
operator|=
literal|0x7f7f
expr_stmt|;
name|pp
operator|->
name|moddcysus
operator|=
literal|0x7f7f
expr_stmt|;
name|pp
operator|->
name|modrelease
operator|=
literal|0x807f
expr_stmt|;
name|pp
operator|->
name|modkeyhold
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|modkeydecay
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|voldelay
operator|=
literal|0x8000
expr_stmt|;
name|pp
operator|->
name|volatkhld
operator|=
literal|0x7f7f
expr_stmt|;
name|pp
operator|->
name|voldcysus
operator|=
literal|0x7f7f
expr_stmt|;
name|pp
operator|->
name|volrelease
operator|=
literal|0x807f
expr_stmt|;
name|pp
operator|->
name|volkeyhold
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|volkeydecay
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|lfo1delay
operator|=
literal|0x8000
expr_stmt|;
name|pp
operator|->
name|lfo2delay
operator|=
literal|0x8000
expr_stmt|;
name|pp
operator|->
name|pefe
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|fmmod
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|tremfrq
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|fm2frq2
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|cutoff
operator|=
literal|0xff
expr_stmt|;
name|pp
operator|->
name|filterQ
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|chorus
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|reverb
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* convert frequency mHz to abstract cents (= midi key * 100) */
end_comment

begin_function
specifier|static
name|int
name|freq_to_note
parameter_list|(
name|int
name|mHz
parameter_list|)
block|{
comment|/* abscents = log(mHz/8176) / log(2) * 1200 */
name|unsigned
name|long
name|max_val
init|=
operator|(
name|unsigned
name|long
operator|)
literal|0xffffffff
operator|/
literal|10000
decl_stmt|;
name|int
name|i
decl_stmt|,
name|times
decl_stmt|;
name|unsigned
name|long
name|base
decl_stmt|;
name|unsigned
name|long
name|freq
decl_stmt|;
name|int
name|note
decl_stmt|,
name|tune
decl_stmt|;
if|if
condition|(
name|mHz
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mHz
operator|<
literal|0
condition|)
return|return
literal|12799
return|;
comment|/* maximum */
name|freq
operator|=
name|mHz
expr_stmt|;
name|note
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|base
operator|=
literal|8176
operator|*
literal|2
init|;
name|freq
operator|>=
name|base
condition|;
name|base
operator|*=
literal|2
control|)
block|{
name|note
operator|+=
literal|12
expr_stmt|;
if|if
condition|(
name|note
operator|>=
literal|128
condition|)
comment|/* over maximum */
return|return
literal|12799
return|;
block|}
name|base
operator|/=
literal|2
expr_stmt|;
comment|/* to avoid overflow... */
name|times
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
name|freq
operator|>
name|max_val
condition|)
block|{
name|max_val
operator|*=
literal|10
expr_stmt|;
name|times
operator|/=
literal|10
expr_stmt|;
name|base
operator|/=
literal|10
expr_stmt|;
block|}
name|freq
operator|=
name|freq
operator|*
name|times
operator|/
name|base
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
operator|<
name|semitone_tuning
index|[
name|i
operator|+
literal|1
index|]
condition|)
break|break;
name|note
operator|++
expr_stmt|;
block|}
name|tune
operator|=
literal|0
expr_stmt|;
name|freq
operator|=
name|freq
operator|*
literal|10000
operator|/
name|semitone_tuning
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
operator|<
name|cent_tuning
index|[
name|i
operator|+
literal|1
index|]
condition|)
break|break;
name|tune
operator|++
expr_stmt|;
block|}
return|return
name|note
operator|*
literal|100
operator|+
name|tune
return|;
block|}
end_function

begin_comment
comment|/* convert Hz to AWE32 rate offset:  * sample pitch offset for the specified sample rate  * rate=44100 is no offset, each 4096 is 1 octave (twice).  * eg, when rate is 22050, this offset becomes -4096.  */
end_comment

begin_function
specifier|static
name|int
name|calc_rate_offset
parameter_list|(
name|int
name|Hz
parameter_list|)
block|{
comment|/* offset = log(Hz / 44100) / log(2) * 4096 */
name|int
name|freq
decl_stmt|,
name|base
decl_stmt|,
name|i
decl_stmt|;
comment|/* maybe smaller than max (44100Hz) */
if|if
condition|(
name|Hz
operator|<=
literal|0
operator|||
name|Hz
operator|>=
literal|44100
condition|)
return|return
literal|0
return|;
name|base
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|freq
operator|=
name|Hz
operator|*
literal|2
init|;
name|freq
operator|<
literal|44100
condition|;
name|freq
operator|*=
literal|2
control|)
name|base
operator|++
expr_stmt|;
name|base
operator|*=
literal|1200
expr_stmt|;
name|freq
operator|=
literal|44100
operator|*
literal|10000
operator|/
operator|(
name|freq
operator|/
literal|2
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
operator|<
name|semitone_tuning
index|[
name|i
operator|+
literal|1
index|]
condition|)
break|break;
name|base
operator|+=
literal|100
expr_stmt|;
block|}
name|freq
operator|=
name|freq
operator|*
literal|10000
operator|/
name|semitone_tuning
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
operator|<
name|cent_tuning
index|[
name|i
operator|+
literal|1
index|]
condition|)
break|break;
name|base
operator|++
expr_stmt|;
block|}
return|return
operator|-
name|base
operator|*
literal|4096
operator|/
literal|1200
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------  * convert envelope time parameter to AWE32 raw parameter  *----------------------------------------------------------------*/
end_comment

begin_comment
comment|/* attack& decay/release time table (mHz) */
end_comment

begin_decl_stmt
specifier|static
name|short
name|attack_time_tbl
index|[
literal|128
index|]
init|=
block|{
literal|32767
block|,
literal|5939
block|,
literal|3959
block|,
literal|2969
block|,
literal|2375
block|,
literal|1979
block|,
literal|1696
block|,
literal|1484
block|,
literal|1319
block|,
literal|1187
block|,
literal|1079
block|,
literal|989
block|,
literal|913
block|,
literal|848
block|,
literal|791
block|,
literal|742
block|,
literal|698
block|,
literal|659
block|,
literal|625
block|,
literal|593
block|,
literal|565
block|,
literal|539
block|,
literal|516
block|,
literal|494
block|,
literal|475
block|,
literal|456
block|,
literal|439
block|,
literal|424
block|,
literal|409
block|,
literal|395
block|,
literal|383
block|,
literal|371
block|,
literal|359
block|,
literal|344
block|,
literal|330
block|,
literal|316
block|,
literal|302
block|,
literal|290
block|,
literal|277
block|,
literal|266
block|,
literal|255
block|,
literal|244
block|,
literal|233
block|,
literal|224
block|,
literal|214
block|,
literal|205
block|,
literal|196
block|,
literal|188
block|,
literal|180
block|,
literal|173
block|,
literal|165
block|,
literal|158
block|,
literal|152
block|,
literal|145
block|,
literal|139
block|,
literal|133
block|,
literal|127
block|,
literal|122
block|,
literal|117
block|,
literal|112
block|,
literal|107
block|,
literal|103
block|,
literal|98
block|,
literal|94
block|,
literal|90
block|,
literal|86
block|,
literal|83
block|,
literal|79
block|,
literal|76
block|,
literal|73
block|,
literal|69
block|,
literal|67
block|,
literal|64
block|,
literal|61
block|,
literal|58
block|,
literal|56
block|,
literal|54
block|,
literal|51
block|,
literal|49
block|,
literal|47
block|,
literal|45
block|,
literal|43
block|,
literal|41
block|,
literal|39
block|,
literal|38
block|,
literal|36
block|,
literal|35
block|,
literal|33
block|,
literal|32
block|,
literal|30
block|,
literal|29
block|,
literal|28
block|,
literal|27
block|,
literal|25
block|,
literal|24
block|,
literal|23
block|,
literal|22
block|,
literal|21
block|,
literal|20
block|,
literal|20
block|,
literal|19
block|,
literal|18
block|,
literal|17
block|,
literal|16
block|,
literal|16
block|,
literal|15
block|,
literal|14
block|,
literal|14
block|,
literal|13
block|,
literal|13
block|,
literal|12
block|,
literal|11
block|,
literal|11
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|9
block|,
literal|9
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|decay_time_tbl
index|[
literal|128
index|]
init|=
block|{
literal|32767
block|,
literal|3651
block|,
literal|3508
block|,
literal|3371
block|,
literal|3239
block|,
literal|3113
block|,
literal|2991
block|,
literal|2874
block|,
literal|2761
block|,
literal|2653
block|,
literal|2550
block|,
literal|2450
block|,
literal|2354
block|,
literal|2262
block|,
literal|2174
block|,
literal|2089
block|,
literal|2007
block|,
literal|1928
block|,
literal|1853
block|,
literal|1781
block|,
literal|1711
block|,
literal|1644
block|,
literal|1580
block|,
literal|1518
block|,
literal|1459
block|,
literal|1401
block|,
literal|1347
block|,
literal|1294
block|,
literal|1243
block|,
literal|1195
block|,
literal|1148
block|,
literal|1103
block|,
literal|1060
block|,
literal|1018
block|,
literal|979
block|,
literal|940
block|,
literal|904
block|,
literal|868
block|,
literal|834
block|,
literal|802
block|,
literal|770
block|,
literal|740
block|,
literal|711
block|,
literal|683
block|,
literal|657
block|,
literal|631
block|,
literal|606
block|,
literal|582
block|,
literal|560
block|,
literal|538
block|,
literal|517
block|,
literal|496
block|,
literal|477
block|,
literal|458
block|,
literal|440
block|,
literal|423
block|,
literal|407
block|,
literal|391
block|,
literal|375
block|,
literal|361
block|,
literal|347
block|,
literal|333
block|,
literal|320
block|,
literal|307
block|,
literal|295
block|,
literal|284
block|,
literal|273
block|,
literal|262
block|,
literal|252
block|,
literal|242
block|,
literal|232
block|,
literal|223
block|,
literal|215
block|,
literal|206
block|,
literal|198
block|,
literal|190
block|,
literal|183
block|,
literal|176
block|,
literal|169
block|,
literal|162
block|,
literal|156
block|,
literal|150
block|,
literal|144
block|,
literal|138
block|,
literal|133
block|,
literal|128
block|,
literal|123
block|,
literal|118
block|,
literal|113
block|,
literal|109
block|,
literal|104
block|,
literal|100
block|,
literal|96
block|,
literal|93
block|,
literal|89
block|,
literal|85
block|,
literal|82
block|,
literal|79
block|,
literal|76
block|,
literal|73
block|,
literal|70
block|,
literal|67
block|,
literal|64
block|,
literal|62
block|,
literal|60
block|,
literal|57
block|,
literal|55
block|,
literal|53
block|,
literal|51
block|,
literal|49
block|,
literal|47
block|,
literal|45
block|,
literal|43
block|,
literal|41
block|,
literal|40
block|,
literal|38
block|,
literal|37
block|,
literal|35
block|,
literal|34
block|,
literal|32
block|,
literal|31
block|,
literal|30
block|,
literal|29
block|,
literal|28
block|,
literal|27
block|,
literal|25
block|,
literal|24
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static int calc_parm_delay(int msec) { 	return (0x8000 - msec * 1000 / 725); } */
end_comment

begin_function
specifier|static
name|int
name|calc_parm_hold
parameter_list|(
name|int
name|msec
parameter_list|)
block|{
name|int
name|val
init|=
literal|0x7f
operator|-
call|(
name|unsigned
name|char
call|)
argument_list|(
name|msec
operator|/
literal|92
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|<
literal|1
condition|)
name|val
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|127
condition|)
name|val
operator|=
literal|127
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|calc_parm_attack
parameter_list|(
name|int
name|msec
parameter_list|)
block|{
return|return
name|calc_parm_search
argument_list|(
name|msec
argument_list|,
name|attack_time_tbl
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|calc_parm_decay
parameter_list|(
name|int
name|msec
parameter_list|)
block|{
return|return
name|calc_parm_search
argument_list|(
name|msec
argument_list|,
name|decay_time_tbl
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|calc_parm_search
parameter_list|(
name|int
name|msec
parameter_list|,
name|short
modifier|*
name|table
parameter_list|)
block|{
name|int
name|left
init|=
literal|0
decl_stmt|,
name|right
init|=
literal|127
decl_stmt|,
name|mid
decl_stmt|;
while|while
condition|(
name|left
operator|<
name|right
condition|)
block|{
name|mid
operator|=
operator|(
name|left
operator|+
name|right
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|msec
operator|<
operator|(
name|int
operator|)
name|table
index|[
name|mid
index|]
condition|)
name|left
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|right
operator|=
name|mid
expr_stmt|;
block|}
return|return
name|left
return|;
block|}
end_function

begin_comment
comment|/*================================================================  * effects table  *================================================================*/
end_comment

begin_comment
comment|/* set an effect value */
end_comment

begin_define
define|#
directive|define
name|FX_SET
parameter_list|(
name|v
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|)
define|\
value|(voices[v].fx_flags[(type)/8] |= (1<<((type)%8)),\  voices[v].fx[type] = (value))
end_define

begin_comment
comment|/* check the effect value is set */
end_comment

begin_define
define|#
directive|define
name|FX_ON
parameter_list|(
name|v
parameter_list|,
name|type
parameter_list|)
value|(voices[v].fx_flags[(type)/8]& (1<<((type)%8)))
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|FX_BYTE
parameter_list|(
name|v
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|)
define|\
value|(FX_ON(v,type) ? (unsigned char)voices[v].fx[type] :\ 	 (unsigned char)(value))
end_define

begin_define
define|#
directive|define
name|FX_WORD
parameter_list|(
name|v
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|)
define|\
value|(FX_ON(v,type) ? (unsigned short)voices[v].fx[type] :\ 	 (unsigned short)(value))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* get byte effect value */
end_comment

begin_function
specifier|static
name|unsigned
name|char
name|FX_BYTE
parameter_list|(
name|int
name|v
parameter_list|,
name|int
name|type
parameter_list|,
name|unsigned
name|char
name|value
parameter_list|)
block|{
name|unsigned
name|char
name|tmp
decl_stmt|;
if|if
condition|(
name|FX_ON
argument_list|(
name|v
argument_list|,
name|type
argument_list|)
condition|)
name|tmp
operator|=
operator|(
name|unsigned
name|char
operator|)
name|voices
index|[
name|v
index|]
operator|.
name|fx
index|[
name|type
index|]
expr_stmt|;
else|else
name|tmp
operator|=
name|value
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [-- byte(%d) = %x]\n"
argument_list|,
name|type
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* get word effect value */
end_comment

begin_function
specifier|static
name|unsigned
name|short
name|FX_WORD
parameter_list|(
name|int
name|v
parameter_list|,
name|int
name|type
parameter_list|,
name|unsigned
name|short
name|value
parameter_list|)
block|{
name|unsigned
name|short
name|tmp
decl_stmt|;
if|if
condition|(
name|FX_ON
argument_list|(
name|v
argument_list|,
name|type
argument_list|)
condition|)
name|tmp
operator|=
operator|(
name|unsigned
name|short
operator|)
name|voices
index|[
name|v
index|]
operator|.
name|fx
index|[
name|type
index|]
expr_stmt|;
else|else
name|tmp
operator|=
name|value
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [-- word(%d) = %x]\n"
argument_list|,
name|type
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* get word (upper=type1/lower=type2) effect value */
end_comment

begin_function
specifier|static
name|unsigned
name|short
name|FX_COMB
parameter_list|(
name|int
name|v
parameter_list|,
name|int
name|type1
parameter_list|,
name|int
name|type2
parameter_list|,
name|unsigned
name|short
name|value
parameter_list|)
block|{
name|unsigned
name|short
name|tmp
decl_stmt|;
if|if
condition|(
name|FX_ON
argument_list|(
name|v
argument_list|,
name|type1
argument_list|)
condition|)
name|tmp
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|voices
index|[
name|v
index|]
operator|.
name|fx
index|[
name|type1
index|]
argument_list|)
operator|<<
literal|8
expr_stmt|;
else|else
name|tmp
operator|=
name|value
operator|&
literal|0xff00
expr_stmt|;
if|if
condition|(
name|FX_ON
argument_list|(
name|v
argument_list|,
name|type2
argument_list|)
condition|)
name|tmp
operator||=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|voices
index|[
name|v
index|]
operator|.
name|fx
index|[
name|type2
index|]
argument_list|)
operator|&
literal|0xff
expr_stmt|;
else|else
name|tmp
operator||=
name|value
operator|&
literal|0xff
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [-- comb(%d/%d) = %x]\n"
argument_list|,
name|type1
argument_list|,
name|type2
argument_list|,
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* address offset */
end_comment

begin_function
specifier|static
name|long
name|FX_OFFSET
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|)
block|{
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
name|long
name|addr
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|FX_ON
argument_list|(
name|voice
argument_list|,
name|hi
argument_list|)
condition|)
block|{
name|addr
operator|=
operator|(
name|short
operator|)
name|voices
index|[
name|voice
index|]
operator|.
name|fx
index|[
name|hi
index|]
expr_stmt|;
name|addr
operator|=
name|addr
operator|<<
literal|15
expr_stmt|;
block|}
if|if
condition|(
name|FX_ON
argument_list|(
name|voice
argument_list|,
name|lo
argument_list|)
condition|)
name|addr
operator|+=
operator|(
name|short
operator|)
name|voices
index|[
name|voice
index|]
operator|.
name|fx
index|[
name|lo
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vp
operator|->
name|mode
operator|&
operator|(
name|AWE_SAMPLE_8BITS
operator|<<
literal|6
operator|)
operator|)
condition|)
name|addr
operator|/=
literal|2
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* converter function table for realtime paramter change */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|fx_affect_func
function_decl|)
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|fx_affect_func
name|fx_realtime
index|[]
init|=
block|{
comment|/* env1: delay, attack, hold, decay, release, sustain, pitch, cutoff*/
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
comment|/* env2: delay, attack, hold, decay, release, sustain */
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
comment|/* lfo1: delay, freq, volume, pitch, cutoff */
name|NULL
block|,
name|awe_fx_tremfrq
block|,
name|awe_fx_tremfrq
block|,
name|awe_fx_fmmod
block|,
name|awe_fx_fmmod
block|,
comment|/* lfo2: delay, freq, pitch */
name|NULL
block|,
name|awe_fx_fm2frq2
block|,
name|awe_fx_fm2frq2
block|,
comment|/* global: initpitch, chorus, reverb, cutoff, filterQ */
name|awe_fx_initpitch
block|,
name|NULL
block|,
name|NULL
block|,
name|awe_fx_cutoff
block|,
name|NULL
block|,
comment|/* sample: start, loopstart, loopend */
name|NULL
block|,
name|NULL
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*================================================================  * turn on/off sample  *================================================================*/
end_comment

begin_function
specifier|static
name|void
name|awe_note_on
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|unsigned
name|long
name|temp
decl_stmt|;
name|long
name|addr
decl_stmt|;
name|unsigned
name|short
name|tmp2
decl_stmt|;
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
comment|/* A voice sample must assigned before calling */
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
comment|/* channel to be silent and idle */
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0x0080
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_VTFT
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_CVCF
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_PTRX
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_CPF
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* modulation& volume envelope */
name|awe_poke
argument_list|(
name|AWE_ENVVAL
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_WORD
argument_list|(
name|voice
argument_list|,
name|AWE_FX_ENV1_DELAY
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|moddelay
argument_list|)
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ATKHLD
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|voice
argument_list|,
name|AWE_FX_ENV1_ATTACK
argument_list|,
name|AWE_FX_ENV1_HOLD
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|modatkhld
argument_list|)
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUS
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|voice
argument_list|,
name|AWE_FX_ENV1_SUSTAIN
argument_list|,
name|AWE_FX_ENV1_DECAY
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|moddcysus
argument_list|)
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ENVVOL
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_WORD
argument_list|(
name|voice
argument_list|,
name|AWE_FX_ENV2_DELAY
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|voldelay
argument_list|)
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ATKHLDV
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|voice
argument_list|,
name|AWE_FX_ENV2_ATTACK
argument_list|,
name|AWE_FX_ENV2_HOLD
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|volatkhld
argument_list|)
argument_list|)
expr_stmt|;
comment|/* decay/sustain parameter for volume envelope must be set at last */
comment|/* pitch offset */
name|awe_poke
argument_list|(
name|AWE_IP
argument_list|(
name|voice
argument_list|)
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|apitch
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [-- pitch=%x]\n"
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|apitch
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cutoff and volume */
name|tmp2
operator|=
name|FX_BYTE
argument_list|(
name|voice
argument_list|,
name|AWE_FX_CUTOFF
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|cutoff
argument_list|)
expr_stmt|;
name|tmp2
operator|=
operator|(
name|tmp2
operator|<<
literal|8
operator|)
operator||
name|voices
index|[
name|voice
index|]
operator|.
name|avol
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_IFATN
argument_list|(
name|voice
argument_list|)
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
comment|/* modulation envelope heights */
name|awe_poke
argument_list|(
name|AWE_PEFE
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|voice
argument_list|,
name|AWE_FX_ENV1_PITCH
argument_list|,
name|AWE_FX_ENV1_CUTOFF
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|pefe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lfo1/2 delay */
name|awe_poke
argument_list|(
name|AWE_LFO1VAL
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_WORD
argument_list|(
name|voice
argument_list|,
name|AWE_FX_LFO1_DELAY
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|lfo1delay
argument_list|)
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_LFO2VAL
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_WORD
argument_list|(
name|voice
argument_list|,
name|AWE_FX_LFO2_DELAY
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|lfo2delay
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lfo1 pitch& cutoff shift */
name|awe_poke
argument_list|(
name|AWE_FMMOD
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|voice
argument_list|,
name|AWE_FX_LFO1_PITCH
argument_list|,
name|AWE_FX_LFO1_CUTOFF
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|fmmod
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lfo1 volume& freq */
name|awe_poke
argument_list|(
name|AWE_TREMFRQ
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|voice
argument_list|,
name|AWE_FX_LFO1_VOLUME
argument_list|,
name|AWE_FX_LFO1_FREQ
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|tremfrq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lfo2 pitch& freq */
name|awe_poke
argument_list|(
name|AWE_FM2FRQ2
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|voice
argument_list|,
name|AWE_FX_LFO2_PITCH
argument_list|,
name|AWE_FX_LFO2_FREQ
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|fm2frq2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pan& loop start */
name|awe_set_pan
argument_list|(
name|voice
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* chorus& loop end (chorus 8bit, MSB) */
name|addr
operator|=
name|vp
operator|->
name|loopend
operator|-
literal|1
expr_stmt|;
name|addr
operator|+=
name|FX_OFFSET
argument_list|(
name|voice
argument_list|,
name|AWE_FX_LOOP_END
argument_list|,
name|AWE_FX_COARSE_LOOP_END
argument_list|)
expr_stmt|;
name|temp
operator|=
name|FX_BYTE
argument_list|(
name|voice
argument_list|,
name|AWE_FX_CHORUS
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|chorus
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|temp
operator|<<
literal|24
operator|)
operator||
operator|(
name|unsigned
name|long
operator|)
name|addr
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
name|voice
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Q& current address (Q 4bit value, MSB) */
name|addr
operator|=
name|vp
operator|->
name|start
operator|-
literal|1
expr_stmt|;
name|addr
operator|+=
name|FX_OFFSET
argument_list|(
name|voice
argument_list|,
name|AWE_FX_SAMPLE_START
argument_list|,
name|AWE_FX_COARSE_SAMPLE_START
argument_list|)
expr_stmt|;
name|temp
operator|=
name|FX_BYTE
argument_list|(
name|voice
argument_list|,
name|AWE_FX_FILTERQ
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|filterQ
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|temp
operator|<<
literal|28
operator|)
operator||
operator|(
name|unsigned
name|long
operator|)
name|addr
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|voice
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* reset volume */
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0x0000FFFF
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CVCF
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0x0000FFFF
argument_list|)
expr_stmt|;
comment|/* turn on envelope */
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|voice
argument_list|,
name|AWE_FX_ENV2_SUSTAIN
argument_list|,
name|AWE_FX_ENV2_DECAY
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|voldcysus
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set chorus */
name|temp
operator|=
name|FX_BYTE
argument_list|(
name|voice
argument_list|,
name|AWE_FX_REVERB
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|reverb
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|awe_peek_dw
argument_list|(
name|AWE_PTRX
argument_list|(
name|voice
argument_list|)
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|temp
operator|<<
literal|8
operator|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PTRX
argument_list|(
name|voice
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CPF
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0x40000000
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [-- start=%x loop=%x]\n"
argument_list|,
operator|(
name|int
operator|)
name|vp
operator|->
name|start
argument_list|,
operator|(
name|int
operator|)
name|vp
operator|->
name|loopstart
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* turn off the voice */
end_comment

begin_function
specifier|static
name|void
name|awe_note_off
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
name|unsigned
name|short
name|tmp
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
operator|!
name|voices
index|[
name|voice
index|]
operator|.
name|state
condition|)
return|return;
if|if
condition|(
name|FX_ON
argument_list|(
name|voice
argument_list|,
name|AWE_FX_ENV1_RELEASE
argument_list|)
condition|)
name|tmp
operator|=
literal|0x8000
operator||
name|voices
index|[
name|voice
index|]
operator|.
name|fx
index|[
name|AWE_FX_ENV1_RELEASE
index|]
expr_stmt|;
else|else
name|tmp
operator|=
name|vp
operator|->
name|parm
operator|.
name|modrelease
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUS
argument_list|(
name|voice
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|FX_ON
argument_list|(
name|voice
argument_list|,
name|AWE_FX_ENV2_RELEASE
argument_list|)
condition|)
name|tmp
operator|=
literal|0x8000
operator||
name|voices
index|[
name|voice
index|]
operator|.
name|fx
index|[
name|AWE_FX_ENV2_RELEASE
index|]
expr_stmt|;
else|else
name|tmp
operator|=
name|vp
operator|->
name|parm
operator|.
name|volrelease
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|voice
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* force to terminate the voice (no releasing echo) */
end_comment

begin_function
specifier|static
name|void
name|awe_terminate
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0x807F
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* turn off other voices with the same exclusive class (for drums) */
end_comment

begin_function
specifier|static
name|void
name|awe_exclusive_off
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|excls
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|==
name|NULL
condition|)
comment|/* no sample */
return|return;
name|excls
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|->
name|exclusiveClass
expr_stmt|;
if|if
condition|(
name|excls
operator|==
literal|0
condition|)
comment|/* not exclusive */
return|return;
comment|/* turn off voices with the same class */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|voice
operator|&&
name|voices
index|[
name|voice
index|]
operator|.
name|state
operator|&&
name|voices
index|[
name|i
index|]
operator|.
name|sample
operator|&&
name|voices
index|[
name|i
index|]
operator|.
name|sample
operator|->
name|exclusiveClass
operator|==
name|excls
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [exoff(%d)]\n"
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|awe_note_off
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|awe_voice_init
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*================================================================  * change the parameters of an audible voice  *================================================================*/
end_comment

begin_comment
comment|/* change pitch */
end_comment

begin_function
specifier|static
name|void
name|awe_set_pitch
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
if|if
condition|(
operator|!
name|voices
index|[
name|voice
index|]
operator|.
name|state
condition|)
return|return;
name|awe_poke
argument_list|(
name|AWE_IP
argument_list|(
name|voice
argument_list|)
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|apitch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* change volume */
end_comment

begin_function
specifier|static
name|void
name|awe_set_volume
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
name|unsigned
name|short
name|tmp2
decl_stmt|;
if|if
condition|(
operator|!
name|voices
index|[
name|voice
index|]
operator|.
name|state
condition|)
return|return;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
name|tmp2
operator|=
name|FX_BYTE
argument_list|(
name|voice
argument_list|,
name|AWE_FX_CUTOFF
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|cutoff
argument_list|)
expr_stmt|;
name|tmp2
operator|=
operator|(
name|tmp2
operator|<<
literal|8
operator|)
operator||
name|voices
index|[
name|voice
index|]
operator|.
name|avol
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_IFATN
argument_list|(
name|voice
argument_list|)
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* change pan; this could make a click noise.. */
end_comment

begin_function
specifier|static
name|void
name|awe_set_pan
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
block|{
name|unsigned
name|long
name|temp
decl_stmt|;
name|long
name|addr
decl_stmt|;
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
operator|!
name|voices
index|[
name|voice
index|]
operator|.
name|state
operator|&&
operator|!
name|forced
condition|)
return|return;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
comment|/* pan& loop start (pan 8bit, MSB, 0:right, 0xff:left) */
if|if
condition|(
name|vp
operator|->
name|fixpan
operator|>
literal|0
condition|)
comment|/* 0-127 */
name|temp
operator|=
literal|255
operator|-
operator|(
name|int
operator|)
name|vp
operator|->
name|fixpan
operator|*
literal|2
expr_stmt|;
else|else
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|pan
operator|>=
literal|0
condition|)
comment|/* 0-127 */
name|pos
operator|=
operator|(
name|int
operator|)
name|vp
operator|->
name|pan
operator|*
literal|2
operator|-
literal|128
expr_stmt|;
name|pos
operator|+=
name|voices
index|[
name|voice
index|]
operator|.
name|panning
expr_stmt|;
comment|/* -128 - 127 */
name|pos
operator|=
literal|127
operator|-
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|pos
operator|>
literal|255
condition|)
name|temp
operator|=
literal|255
expr_stmt|;
else|else
name|temp
operator|=
name|pos
expr_stmt|;
block|}
name|addr
operator|=
name|vp
operator|->
name|loopstart
operator|-
literal|1
expr_stmt|;
name|addr
operator|+=
name|FX_OFFSET
argument_list|(
name|voice
argument_list|,
name|AWE_FX_LOOP_START
argument_list|,
name|AWE_FX_COARSE_LOOP_START
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|temp
operator|<<
literal|24
operator|)
operator||
operator|(
name|unsigned
name|long
operator|)
name|addr
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
name|voice
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* effects change during playing */
end_comment

begin_function
specifier|static
name|void
name|awe_fx_fmmod
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
operator|!
name|voices
index|[
name|voice
index|]
operator|.
name|state
condition|)
return|return;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
name|awe_poke
argument_list|(
name|AWE_FMMOD
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|voice
argument_list|,
name|AWE_FX_LFO1_PITCH
argument_list|,
name|AWE_FX_LFO1_CUTOFF
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|fmmod
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awe_fx_tremfrq
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
operator|!
name|voices
index|[
name|voice
index|]
operator|.
name|state
condition|)
return|return;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
name|awe_poke
argument_list|(
name|AWE_TREMFRQ
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|voice
argument_list|,
name|AWE_FX_LFO1_VOLUME
argument_list|,
name|AWE_FX_LFO1_FREQ
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|tremfrq
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awe_fx_fm2frq2
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
operator|!
name|voices
index|[
name|voice
index|]
operator|.
name|state
condition|)
return|return;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
name|awe_poke
argument_list|(
name|AWE_FM2FRQ2
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|voice
argument_list|,
name|AWE_FX_LFO2_PITCH
argument_list|,
name|AWE_FX_LFO2_FREQ
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|fm2frq2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awe_fx_cutoff
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|unsigned
name|short
name|tmp2
decl_stmt|;
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
if|if
condition|(
operator|!
name|voices
index|[
name|voice
index|]
operator|.
name|state
condition|)
return|return;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
name|tmp2
operator|=
name|FX_BYTE
argument_list|(
name|voice
argument_list|,
name|AWE_FX_CUTOFF
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|cutoff
argument_list|)
expr_stmt|;
name|tmp2
operator|=
operator|(
name|tmp2
operator|<<
literal|8
operator|)
operator||
name|voices
index|[
name|voice
index|]
operator|.
name|avol
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_IFATN
argument_list|(
name|voice
argument_list|)
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awe_fx_initpitch
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
if|if
condition|(
operator|!
name|voices
index|[
name|voice
index|]
operator|.
name|state
condition|)
return|return;
if|if
condition|(
name|FX_ON
argument_list|(
name|voice
argument_list|,
name|AWE_FX_INIT_PITCH
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: initpitch ok\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: BAD initpitch %d\n"
argument_list|,
name|AWE_FX_INIT_PITCH
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|awe_calc_pitch
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_IP
argument_list|(
name|voice
argument_list|)
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|apitch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*================================================================  * calculate pitch offset  *----------------------------------------------------------------  * 0xE000 is no pitch offset at 44100Hz sample.  * Every 4096 is one octave.  *================================================================*/
end_comment

begin_function
specifier|static
name|void
name|awe_calc_pitch
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|voice_info
modifier|*
name|vp
init|=
operator|&
name|voices
index|[
name|voice
index|]
decl_stmt|;
name|awe_voice_info
modifier|*
name|ap
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* search voice information */
if|if
condition|(
operator|(
name|ap
operator|=
name|vp
operator|->
name|sample
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ap
operator|->
name|index
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|awe_set_sample
argument_list|(
name|ap
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
comment|/* calculate offset */
if|if
condition|(
name|ap
operator|->
name|fixkey
operator|>=
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p-> fixkey(%d) tune(%d)\n"
argument_list|,
name|ap
operator|->
name|fixkey
argument_list|,
name|ap
operator|->
name|tune
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|ap
operator|->
name|fixkey
operator|-
name|ap
operator|->
name|root
operator|)
operator|*
literal|4096
operator|/
literal|12
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p(%d)-> root(%d) tune(%d)\n"
argument_list|,
name|vp
operator|->
name|note
argument_list|,
name|ap
operator|->
name|root
argument_list|,
name|ap
operator|->
name|tune
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|vp
operator|->
name|note
operator|-
name|ap
operator|->
name|root
operator|)
operator|*
literal|4096
operator|/
literal|12
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p-> ofs=%d\n"
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|ap
operator|->
name|tune
operator|*
literal|4096
operator|/
literal|1200
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p-> tune+ ofs=%d\n"
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|bender
operator|!=
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p-> bend(%d) %d\n"
argument_list|,
name|voice
argument_list|,
name|vp
operator|->
name|bender
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (819200: 1 semitone) ==> (4096: 12 semitones) */
name|offset
operator|+=
name|vp
operator|->
name|bender
operator|*
name|vp
operator|->
name|bender_range
operator|/
literal|2400
expr_stmt|;
block|}
name|offset
operator|=
operator|(
name|offset
operator|*
name|ap
operator|->
name|scaleTuning
operator|)
operator|/
literal|100
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p-> scale* ofs=%d\n"
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add initial pitch correction */
if|if
condition|(
name|FX_ON
argument_list|(
name|voice
argument_list|,
name|AWE_FX_INIT_PITCH
argument_list|)
condition|)
block|{
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: fx_pitch(%d) %d\n"
argument_list|,
name|voice
argument_list|,
name|vp
operator|->
name|fx
index|[
name|AWE_FX_INIT_PITCH
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|vp
operator|->
name|fx
index|[
name|AWE_FX_INIT_PITCH
index|]
expr_stmt|;
block|}
comment|/* 0xe000: root pitch */
name|vp
operator|->
name|apitch
operator|=
literal|0xe000
operator|+
name|ap
operator|->
name|rate_offset
operator|+
name|offset
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p-> sum aofs=%x, rate_ofs=%d\n"
argument_list|,
name|vp
operator|->
name|apitch
argument_list|,
name|ap
operator|->
name|rate_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|apitch
operator|>
literal|0xffff
condition|)
name|vp
operator|->
name|apitch
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|apitch
operator|<
literal|0
condition|)
name|vp
operator|->
name|apitch
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awe_calc_pitch_from_freq
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
name|voice_info
modifier|*
name|vp
init|=
operator|&
name|voices
index|[
name|voice
index|]
decl_stmt|;
name|awe_voice_info
modifier|*
name|ap
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|note
decl_stmt|;
comment|/* search voice information */
if|if
condition|(
operator|(
name|ap
operator|=
name|vp
operator|->
name|sample
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ap
operator|->
name|index
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|awe_set_sample
argument_list|(
name|ap
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
name|note
operator|=
name|freq_to_note
argument_list|(
name|freq
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|note
operator|-
name|ap
operator|->
name|root
operator|*
literal|100
operator|+
name|ap
operator|->
name|tune
operator|)
operator|*
literal|4096
operator|/
literal|1200
expr_stmt|;
name|offset
operator|=
operator|(
name|offset
operator|*
name|ap
operator|->
name|scaleTuning
operator|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|FX_ON
argument_list|(
name|voice
argument_list|,
name|AWE_FX_INIT_PITCH
argument_list|)
condition|)
name|offset
operator|+=
name|vp
operator|->
name|fx
index|[
name|AWE_FX_INIT_PITCH
index|]
expr_stmt|;
name|vp
operator|->
name|apitch
operator|=
literal|0xe000
operator|+
name|ap
operator|->
name|rate_offset
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|apitch
operator|>
literal|0xffff
condition|)
name|vp
operator|->
name|apitch
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|apitch
operator|<
literal|0
condition|)
name|vp
operator|->
name|apitch
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*================================================================  * calculate volume attenuation  *----------------------------------------------------------------  * Voice volume is controlled by volume attenuation parameter.  * So volume becomes maximum when avol is 0 (no attenuation), and  * minimum when 255 (-96dB or silence).  *================================================================*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|vol_table
index|[
literal|128
index|]
init|=
block|{
literal|255
block|,
literal|111
block|,
literal|95
block|,
literal|86
block|,
literal|79
block|,
literal|74
block|,
literal|70
block|,
literal|66
block|,
literal|63
block|,
literal|61
block|,
literal|58
block|,
literal|56
block|,
literal|54
block|,
literal|52
block|,
literal|50
block|,
literal|49
block|,
literal|47
block|,
literal|46
block|,
literal|45
block|,
literal|43
block|,
literal|42
block|,
literal|41
block|,
literal|40
block|,
literal|39
block|,
literal|38
block|,
literal|37
block|,
literal|36
block|,
literal|35
block|,
literal|34
block|,
literal|34
block|,
literal|33
block|,
literal|32
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|29
block|,
literal|29
block|,
literal|28
block|,
literal|27
block|,
literal|27
block|,
literal|26
block|,
literal|26
block|,
literal|25
block|,
literal|24
block|,
literal|24
block|,
literal|23
block|,
literal|23
block|,
literal|22
block|,
literal|22
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|20
block|,
literal|20
block|,
literal|19
block|,
literal|19
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|17
block|,
literal|17
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|awe_calc_volume
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|voice_info
modifier|*
name|vp
init|=
operator|&
name|voices
index|[
name|voice
index|]
decl_stmt|;
name|awe_voice_info
modifier|*
name|ap
decl_stmt|;
name|int
name|vol
decl_stmt|;
comment|/* search voice information */
if|if
condition|(
operator|(
name|ap
operator|=
name|vp
operator|->
name|sample
operator|)
operator|==
name|NULL
condition|)
return|return;
name|ap
operator|=
name|vp
operator|->
name|sample
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|index
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|awe_set_sample
argument_list|(
name|ap
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|vp
operator|->
name|velocity
operator|<
name|ap
operator|->
name|vellow
condition|)
name|vp
operator|->
name|velocity
operator|=
name|ap
operator|->
name|vellow
expr_stmt|;
elseif|else
if|if
condition|(
name|vp
operator|->
name|velocity
operator|>
name|ap
operator|->
name|velhigh
condition|)
name|vp
operator|->
name|velocity
operator|=
name|ap
operator|->
name|velhigh
expr_stmt|;
comment|/* 0 - 127 */
name|vol
operator|=
operator|(
name|vp
operator|->
name|velocity
operator|*
name|vp
operator|->
name|main_vol
operator|*
name|vp
operator|->
name|expression_vol
operator|)
operator|/
operator|(
literal|127
operator|*
literal|127
operator|)
expr_stmt|;
name|vol
operator|=
name|vol
operator|*
name|ap
operator|->
name|amplitude
operator|/
literal|127
expr_stmt|;
if|if
condition|(
name|vol
operator|<
literal|0
condition|)
name|vol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vol
operator|>
literal|127
condition|)
name|vol
operator|=
literal|127
expr_stmt|;
comment|/* calc to attenuation */
name|vol
operator|=
name|vol_table
index|[
name|vol
index|]
expr_stmt|;
name|vol
operator|=
name|vol
operator|+
operator|(
name|int
operator|)
name|ap
operator|->
name|attenuation
operator|+
name|init_atten
expr_stmt|;
if|if
condition|(
name|vol
operator|>
literal|255
condition|)
name|vol
operator|=
literal|255
expr_stmt|;
name|vp
operator|->
name|avol
operator|=
name|vol
expr_stmt|;
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [-- voice(%d) vol=%x]\n"
argument_list|,
name|voice
argument_list|,
name|vol
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*================================================================  * synth operation routines  *================================================================*/
end_comment

begin_comment
comment|/* initialize the voice */
end_comment

begin_function
specifier|static
name|void
name|awe_voice_init
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|inst_only
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inst_only
condition|)
block|{
comment|/* clear voice parameters */
name|voices
index|[
name|voice
index|]
operator|.
name|note
operator|=
operator|-
literal|1
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|velocity
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
literal|0
expr_stmt|;
comment|/* zero center */
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
literal|0
expr_stmt|;
comment|/* zero tune skew */
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
literal|200
expr_stmt|;
comment|/* sense * 100 */
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
operator|=
literal|127
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
operator|=
literal|127
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bank
operator|=
name|AWE_DEFAULT_BANK
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|instr
operator|=
operator|-
literal|1
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|vrec
operator|=
name|NULL
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* clear voice mapping */
name|voices
index|[
name|voice
index|]
operator|.
name|state
operator|=
literal|0
expr_stmt|;
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
comment|/* emu8000 parameters */
name|voices
index|[
name|voice
index|]
operator|.
name|apitch
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|avol
operator|=
literal|255
expr_stmt|;
comment|/* clear effects */
name|BZERO
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|fx_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|fx_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------  * device open / close  *----------------------------------------------------------------*/
end_comment

begin_comment
comment|/* open device:  *   reset status of all voices, and clear sample position flag  */
end_comment

begin_function
specifier|static
name|int
name|awe_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|awe_busy
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
name|awe_busy
operator|=
literal|1
expr_stmt|;
name|awe_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* clear sample position flag */
name|loaded_once
operator|=
literal|0
expr_stmt|;
comment|/* set GUS bank to default */
name|awe_gus_bank
operator|=
name|AWE_DEFAULT_BANK
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* close device:  *   reset all voices again (terminate sounds)  */
end_comment

begin_function
specifier|static
name|void
name|awe_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|awe_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|awe_busy
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sequencer I/O control:  */
end_comment

begin_function
specifier|static
name|int
name|awe_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_SYNTH_INFO
case|:
name|awe_info
operator|.
name|nr_voices
operator|=
name|awe_max_voices
expr_stmt|;
name|IOCTL_TO_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
operator|&
name|awe_info
argument_list|,
sizeof|sizeof
argument_list|(
name|awe_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_RESETSAMPLES
case|:
name|awe_reset_samples
argument_list|()
expr_stmt|;
name|awe_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* better to reset emu8k chip... */
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_PERCMODE
case|:
comment|/* what's this? */
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [ioctl memavl = %d]\n"
argument_list|,
operator|(
name|int
operator|)
name|free_mem_ptr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|awe_mem_size
operator|-
name|free_mem_ptr
operator|*
literal|2
return|;
default|default:
name|ERRMSG
argument_list|(
name|printk
argument_list|(
literal|"AWE32: unsupported ioctl %d\n"
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* kill a voice:  *   not terminate, just release the voice.  */
end_comment

begin_function
specifier|static
name|int
name|awe_kill_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|)
block|{
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
name|DECL_INTR_FLAGS
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [off(%d)]\n"
argument_list|,
name|voice
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|awe_max_voices
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|(
name|vp
operator|->
name|mode
operator|&
name|AWE_MODE_NORELEASE
operator|)
condition|)
block|{
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|awe_note_off
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
name|awe_voice_init
argument_list|(
name|voice
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* search the note with the specified key range */
end_comment

begin_function
specifier|static
name|awe_voice_info
modifier|*
name|awe_search_voice
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|)
block|{
name|awe_voice_list
modifier|*
name|rec
decl_stmt|;
name|int
name|maxc
decl_stmt|;
for|for
control|(
name|rec
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|vrec
operator|,
name|maxc
operator|=
name|AWE_MAX_INFOS
init|;
name|rec
operator|&&
name|maxc
condition|;
name|rec
operator|=
name|rec
operator|->
name|next_instr
operator|,
name|maxc
operator|--
control|)
block|{
if|if
condition|(
name|rec
operator|->
name|v
operator|.
name|low
operator|<=
name|note
operator|&&
name|note
operator|<=
name|rec
operator|->
name|v
operator|.
name|high
condition|)
return|return
operator|&
name|rec
operator|->
name|v
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* start a voice:  *   if note is 255, identical with aftertouch function.  *   Otherwise, start a voice with specified not and volume.  */
end_comment

begin_function
specifier|static
name|int
name|awe_start_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|v
parameter_list|,
name|int
name|note_num
parameter_list|,
name|int
name|volume
parameter_list|)
block|{
name|DECL_INTR_FLAGS
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [on(%d) nt=%d vl=%d]\n"
argument_list|,
name|v
argument_list|,
name|note_num
argument_list|,
name|volume
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|<
literal|0
operator|||
name|v
operator|>=
name|awe_max_voices
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* an instrument must be set before starting a note */
if|if
condition|(
name|voices
index|[
name|v
index|]
operator|.
name|vrec
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [-- vrec is null]\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|note_num
operator|==
literal|255
condition|)
block|{
comment|/* dynamic volume change; sample is already assigned */
if|if
condition|(
operator|!
name|voices
index|[
name|v
index|]
operator|.
name|state
operator|||
name|voices
index|[
name|v
index|]
operator|.
name|sample
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* calculate volume parameter */
name|voices
index|[
name|v
index|]
operator|.
name|velocity
operator|=
name|volume
expr_stmt|;
name|awe_calc_volume
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|awe_set_volume
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* assign a sample with the corresponding note */
if|if
condition|(
operator|(
name|voices
index|[
name|v
index|]
operator|.
name|sample
operator|=
name|awe_search_voice
argument_list|(
name|v
argument_list|,
name|note_num
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [-- sample is null]\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* calculate pitch& volume parameters */
name|voices
index|[
name|v
index|]
operator|.
name|note
operator|=
name|note_num
expr_stmt|;
name|voices
index|[
name|v
index|]
operator|.
name|velocity
operator|=
name|volume
expr_stmt|;
name|awe_calc_pitch
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|awe_calc_volume
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* turn off other voices (for drums) */
name|awe_exclusive_off
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* turn on the voice */
name|awe_note_on
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|voices
index|[
name|v
index|]
operator|.
name|state
operator|=
literal|1
expr_stmt|;
comment|/* flag up */
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* search instrument from preset table with the specified bank */
end_comment

begin_function
specifier|static
name|awe_voice_list
modifier|*
name|awe_search_instr
parameter_list|(
name|int
name|bank
parameter_list|,
name|int
name|preset
parameter_list|)
block|{
name|awe_voice_list
modifier|*
name|p
decl_stmt|;
name|int
name|maxc
decl_stmt|;
for|for
control|(
name|maxc
operator|=
name|AWE_MAX_INFOS
operator|,
name|p
operator|=
name|preset_table
index|[
name|preset
index|]
init|;
name|p
operator|&&
name|maxc
condition|;
name|p
operator|=
name|p
operator|->
name|next_bank
operator|,
name|maxc
operator|--
control|)
block|{
if|if
condition|(
name|p
operator|->
name|bank
operator|==
name|bank
condition|)
return|return
name|p
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* assign the instrument to a voice */
end_comment

begin_function
specifier|static
name|int
name|awe_set_instr
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|instr_no
parameter_list|)
block|{
name|awe_voice_list
modifier|*
name|rec
decl_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|awe_max_voices
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|instr_no
operator|<
literal|0
operator|||
name|instr_no
operator|>=
name|AWE_MAX_PRESETS
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
operator|(
name|rec
operator|=
name|awe_search_instr
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|bank
argument_list|,
name|instr_no
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* if bank is not defined, use the default bank 0 */
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|bank
operator|!=
name|AWE_DEFAULT_BANK
operator|&&
operator|(
name|rec
operator|=
name|awe_search_instr
argument_list|(
name|AWE_DEFAULT_BANK
argument_list|,
name|instr_no
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
name|printk
argument_list|(
literal|"AWE32 Warning: can't find instrument %d\n"
argument_list|,
name|instr_no
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|voices
index|[
name|voice
index|]
operator|.
name|instr
operator|=
name|instr_no
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|vrec
operator|=
name|rec
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|=
name|NULL
expr_stmt|;
comment|/* not set yet */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* reset all voices; terminate sounds and initialize parameters */
end_comment

begin_function
specifier|static
name|void
name|awe_reset
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* don't turn off voice 31 and 32.  they are used also for FM voices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_NORMAL_VOICES
condition|;
name|i
operator|++
control|)
block|{
name|awe_terminate
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|awe_voice_init
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|awe_init_fm
argument_list|()
expr_stmt|;
name|awe_tweak
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* hardware specific control:  *   GUS specific and AWE32 specific controls are available.  */
end_comment

begin_function
specifier|static
name|void
name|awe_hw_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|cmd
init|=
name|event
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|cmd
operator|&
name|_AWE_MODE_FLAG
condition|)
name|awe_hw_awe_control
argument_list|(
name|dev
argument_list|,
name|cmd
operator|&
name|_AWE_MODE_VALUE_MASK
argument_list|,
name|event
argument_list|)
expr_stmt|;
else|else
name|awe_hw_gus_control
argument_list|(
name|dev
argument_list|,
name|cmd
operator|&
name|_AWE_MODE_VALUE_MASK
argument_list|,
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GUS compatible controls */
end_comment

begin_function
specifier|static
name|void
name|awe_hw_gus_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|voice
decl_stmt|;
name|unsigned
name|short
name|p1
decl_stmt|;
name|short
name|p2
decl_stmt|;
name|int
name|plong
decl_stmt|;
name|DECL_INTR_FLAGS
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|voice
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
name|p1
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|6
index|]
expr_stmt|;
name|plong
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|_GUS_NUMVOICES
case|:
if|if
condition|(
name|p1
operator|>=
name|awe_max_voices
condition|)
name|printk
argument_list|(
literal|"AWE32: num_voices: voices out of range %d\n"
argument_list|,
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICESAMPLE
case|:
if|if
condition|(
name|voice
operator|<
name|awe_max_voices
condition|)
name|awe_set_instr
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEON
case|:
if|if
condition|(
name|voice
operator|<
name|awe_max_voices
condition|)
block|{
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|awe_note_on
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|_GUS_VOICEOFF
case|:
if|if
condition|(
name|voice
operator|<
name|awe_max_voices
condition|)
block|{
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|awe_note_off
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|_GUS_VOICEMODE
case|:
comment|/* not supported */
break|break;
case|case
name|_GUS_VOICEBALA
case|:
comment|/* -128 to 127 */
if|if
condition|(
name|voice
operator|<
name|awe_max_voices
condition|)
name|awe_panning
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
operator|(
name|short
operator|)
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEFREQ
case|:
if|if
condition|(
name|voice
operator|<
name|awe_max_voices
condition|)
name|awe_calc_pitch_from_freq
argument_list|(
name|voice
argument_list|,
name|plong
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEVOL
case|:
case|case
name|_GUS_VOICEVOL2
case|:
comment|/* not supported yet */
break|break;
case|case
name|_GUS_RAMPRANGE
case|:
case|case
name|_GUS_RAMPRATE
case|:
case|case
name|_GUS_RAMPMODE
case|:
case|case
name|_GUS_RAMPON
case|:
case|case
name|_GUS_RAMPOFF
case|:
comment|/* volume ramping not supported */
break|break;
case|case
name|_GUS_VOLUME_SCALE
case|:
break|break;
case|case
name|_GUS_VOICE_POS
case|:
if|if
condition|(
name|voice
operator|<
name|awe_max_voices
condition|)
block|{
name|FX_SET
argument_list|(
name|voice
argument_list|,
name|AWE_FX_SAMPLE_START
argument_list|,
call|(
name|short
call|)
argument_list|(
name|plong
operator|&
literal|0x7fff
argument_list|)
argument_list|)
expr_stmt|;
name|FX_SET
argument_list|(
name|voice
argument_list|,
name|AWE_FX_COARSE_SAMPLE_START
argument_list|,
operator|(
name|plong
operator|>>
literal|15
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/* AWE32 specific controls */
end_comment

begin_function
specifier|static
name|void
name|awe_hw_awe_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|voice
decl_stmt|;
name|unsigned
name|short
name|p1
decl_stmt|;
name|short
name|p2
decl_stmt|;
name|int
name|chn
decl_stmt|;
name|chn
operator|=
name|event
index|[
literal|1
index|]
expr_stmt|;
name|voice
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
name|p1
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|6
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|AWE_DEBUG_ON
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|_AWE_DEBUG_MODE
case|:
name|debug_mode
operator|=
name|p1
expr_stmt|;
name|printk
argument_list|(
literal|"AWE32: debug mode = %d\n"
argument_list|,
name|debug_mode
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|_AWE_REVERB_MODE
case|:
if|if
condition|(
name|p1
operator|<=
literal|7
condition|)
block|{
name|reverb_mode
operator|=
name|p1
expr_stmt|;
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: reverb mode %d\n"
argument_list|,
name|reverb_mode
argument_list|)
argument_list|)
expr_stmt|;
name|awe_set_reverb_mode
argument_list|(
name|reverb_mode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|_AWE_CHORUS_MODE
case|:
if|if
condition|(
name|p1
operator|<=
literal|7
condition|)
block|{
name|chorus_mode
operator|=
name|p1
expr_stmt|;
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: chorus mode %d\n"
argument_list|,
name|chorus_mode
argument_list|)
argument_list|)
expr_stmt|;
name|awe_set_chorus_mode
argument_list|(
name|chorus_mode
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|_AWE_REMOVE_LAST_SAMPLES
case|:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: remove last samples\n"
argument_list|)
argument_list|)
expr_stmt|;
name|awe_remove_samples
argument_list|()
expr_stmt|;
break|break;
case|case
name|_AWE_INITIALIZE_CHIP
case|:
name|awe_initialize
argument_list|()
expr_stmt|;
break|break;
case|case
name|_AWE_SEND_EFFECT
case|:
if|if
condition|(
name|voice
operator|<
name|awe_max_voices
operator|&&
name|p1
operator|<
name|AWE_FX_END
condition|)
block|{
name|FX_SET
argument_list|(
name|voice
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: effects (%d) %d %d\n"
argument_list|,
name|voice
argument_list|,
name|p1
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|fx
index|[
name|p1
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fx_realtime
index|[
name|p1
index|]
condition|)
block|{
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: fx_realtime (%d)\n"
argument_list|,
name|voice
argument_list|)
argument_list|)
expr_stmt|;
name|fx_realtime
index|[
name|p1
index|]
operator|(
name|voice
operator|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|_AWE_TERMINATE_CHANNEL
case|:
if|if
condition|(
name|voice
operator|<
name|awe_max_voices
condition|)
block|{
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: terminate (%d)\n"
argument_list|,
name|voice
argument_list|)
argument_list|)
expr_stmt|;
name|awe_terminate
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|awe_voice_init
argument_list|(
name|voice
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|_AWE_TERMINATE_ALL
case|:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: terminate all\n"
argument_list|)
argument_list|)
expr_stmt|;
name|awe_reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|_AWE_INITIAL_VOLUME
case|:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: init attenuation %d\n"
argument_list|,
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|init_atten
operator|=
name|p1
expr_stmt|;
break|break;
case|case
name|_AWE_SET_GUS_BANK
case|:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: set gus bank %d\n"
argument_list|,
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|awe_gus_bank
operator|=
name|p1
expr_stmt|;
break|break;
default|default:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: hw control cmd=%d voice=%d\n"
argument_list|,
name|cmd
argument_list|,
name|voice
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------  * load a sound patch:  *   three types of patches are accepted: AWE, GUS, and SYSEX.  *----------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|awe_load_patch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
block|{
name|awe_patch_info
name|patch
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|GUS_PATCH
condition|)
block|{
return|return
name|awe_load_guspatch
argument_list|(
name|addr
argument_list|,
name|offs
argument_list|,
name|count
argument_list|,
name|pmgr_flag
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|format
operator|==
name|SYSEX_PATCH
condition|)
block|{
comment|/* no system exclusive message supported yet */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|format
operator|!=
name|AWE_PATCH
condition|)
block|{
name|FATALERR
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Error: Invalid patch format (key) 0x%x\n"
argument_list|,
name|format
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
name|awe_patch_info
argument_list|)
condition|)
block|{
name|FATALERR
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Error: Patch header too short\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|COPY_FROM_USER
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|patch
operator|)
operator|+
name|offs
argument_list|,
name|addr
argument_list|,
name|offs
argument_list|,
sizeof|sizeof
argument_list|(
name|awe_patch_info
argument_list|)
operator|-
name|offs
argument_list|)
expr_stmt|;
name|count
operator|-=
sizeof|sizeof
argument_list|(
name|awe_patch_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|patch
operator|.
name|len
condition|)
block|{
name|FATALERR
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Warning: Patch record too short (%d<%d)\n"
argument_list|,
name|count
argument_list|,
operator|(
name|int
operator|)
name|patch
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|patch
operator|.
name|len
operator|=
name|count
expr_stmt|;
block|}
switch|switch
condition|(
name|patch
operator|.
name|type
condition|)
block|{
case|case
name|AWE_LOAD_INFO
case|:
name|rc
operator|=
name|awe_load_info
argument_list|(
operator|&
name|patch
argument_list|,
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|AWE_LOAD_DATA
case|:
name|rc
operator|=
name|awe_load_data
argument_list|(
operator|&
name|patch
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* 		if (!pmgr_flag&& rc == 0) 			pmgr_inform(dev, PM_E_PATCH_LOADED, instr, free_sample, 0, 0); 		*/
break|break;
default|default:
name|FATALERR
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Error: unknown patch format type %d\n"
argument_list|,
name|patch
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* load voice information data */
end_comment

begin_function
specifier|static
name|int
name|awe_load_info
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|)
block|{
name|awe_voice_list
modifier|*
name|rec
decl_stmt|,
modifier|*
name|curp
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|short
name|i
decl_stmt|,
name|nvoices
decl_stmt|;
name|unsigned
name|char
name|bank
decl_stmt|,
name|instr
decl_stmt|;
name|int
name|total_size
decl_stmt|;
if|if
condition|(
name|patch
operator|->
name|len
operator|<
sizeof|sizeof
argument_list|(
name|awe_voice_rec
argument_list|)
condition|)
block|{
name|FATALERR
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Error: invalid patch info length\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|offset
operator|=
sizeof|sizeof
argument_list|(
name|awe_patch_info
argument_list|)
expr_stmt|;
name|GET_BYTE_FROM_USER
argument_list|(
name|bank
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
name|GET_BYTE_FROM_USER
argument_list|(
name|instr
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|++
expr_stmt|;
name|GET_SHORT_FROM_USER
argument_list|(
name|nvoices
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|nvoices
operator|<=
literal|0
operator|||
name|nvoices
operator|>=
literal|100
condition|)
block|{
name|FATALERR
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Error: Illegal voice number %d\n"
argument_list|,
name|nvoices
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|free_info
operator|+
name|nvoices
operator|>
name|AWE_MAX_INFOS
condition|)
block|{
name|ERRMSG
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Error: Too many voice informations\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
name|total_size
operator|=
sizeof|sizeof
argument_list|(
name|awe_voice_rec
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|awe_voice_info
argument_list|)
operator|*
name|nvoices
expr_stmt|;
if|if
condition|(
name|patch
operator|->
name|len
operator|<
name|total_size
condition|)
block|{
name|ERRMSG
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Error: patch length(%d) is smaller than nvoices(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|patch
operator|->
name|len
argument_list|,
name|nvoices
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|curp
operator|=
name|awe_search_instr
argument_list|(
name|bank
argument_list|,
name|instr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvoices
condition|;
name|i
operator|++
control|)
block|{
name|rec
operator|=
operator|&
name|infos
index|[
name|free_info
operator|+
name|i
index|]
expr_stmt|;
name|rec
operator|->
name|bank
operator|=
name|bank
expr_stmt|;
name|rec
operator|->
name|instr
operator|=
name|instr
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nvoices
operator|-
literal|1
condition|)
name|rec
operator|->
name|next_instr
operator|=
name|rec
operator|+
literal|1
expr_stmt|;
else|else
name|rec
operator|->
name|next_instr
operator|=
name|curp
expr_stmt|;
name|rec
operator|->
name|next_bank
operator|=
name|NULL
expr_stmt|;
comment|/* copy awe_voice_info parameters */
name|COPY_FROM_USER
argument_list|(
operator|&
name|rec
operator|->
name|v
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|awe_voice_info
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|awe_voice_info
argument_list|)
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|sf_id
operator|=
name|current_sf_id
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|v
operator|.
name|mode
operator|&
name|AWE_MODE_INIT_PARM
condition|)
name|awe_init_voice_parm
argument_list|(
operator|&
name|rec
operator|->
name|v
operator|.
name|parm
argument_list|)
expr_stmt|;
name|awe_set_sample
argument_list|(
operator|&
name|rec
operator|->
name|v
argument_list|)
expr_stmt|;
block|}
comment|/* prepend to top of the list */
name|infos
index|[
name|free_info
index|]
operator|.
name|next_bank
operator|=
name|preset_table
index|[
name|instr
index|]
expr_stmt|;
name|preset_table
index|[
name|instr
index|]
operator|=
operator|&
name|infos
index|[
name|free_info
index|]
expr_stmt|;
name|free_info
operator|+=
name|nvoices
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* load wave sample data */
end_comment

begin_function
specifier|static
name|int
name|awe_load_data
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|)
block|{
name|long
name|offset
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|free_sample
operator|>=
name|AWE_MAX_SAMPLES
condition|)
block|{
name|ERRMSG
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Error: Sample table full\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
name|size
operator|=
operator|(
name|patch
operator|->
name|len
operator|-
sizeof|sizeof
argument_list|(
name|awe_sample_info
argument_list|)
operator|)
operator|/
literal|2
expr_stmt|;
name|offset
operator|=
sizeof|sizeof
argument_list|(
name|awe_patch_info
argument_list|)
expr_stmt|;
name|COPY_FROM_USER
argument_list|(
operator|&
name|samples
index|[
name|free_sample
index|]
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|awe_sample_info
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|awe_sample_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|samples
index|[
name|free_sample
index|]
operator|.
name|size
condition|)
block|{
name|ERRMSG
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Warning: sample size differed (%d != %d)\n"
argument_list|,
operator|(
name|int
operator|)
name|samples
index|[
name|free_sample
index|]
operator|.
name|size
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|size
operator|=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|samples
index|[
name|free_sample
index|]
operator|.
name|size
operator|>
literal|0
condition|)
if|if
condition|(
operator|(
name|rc
operator|=
name|awe_write_wave_data
argument_list|(
name|addr
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
name|awe_check_loaded
argument_list|()
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|sf_id
operator|=
name|current_sf_id
expr_stmt|;
name|free_sample
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* check the other samples are already loaded */
end_comment

begin_function
specifier|static
name|void
name|awe_check_loaded
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|loaded_once
condition|)
block|{
comment|/* it's the first time */
name|last_sample
operator|=
name|free_sample
expr_stmt|;
name|last_info
operator|=
name|free_info
expr_stmt|;
name|current_sf_id
operator|++
expr_stmt|;
name|loaded_once
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|readbuf_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|readbuf_offs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readbuf_flags
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_USE_BUFFERED_IO
end_ifdef

begin_define
define|#
directive|define
name|TMP_WAVBUF_SIZE
value|4096
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|readbuf
index|[
name|TMP_WAVBUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readbuf_size
decl_stmt|,
name|readbuf_cur
decl_stmt|,
name|readbuf_left
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* read through temporary buffer */
end_comment

begin_function
specifier|static
name|unsigned
name|short
name|awe_readbuf_word
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
if|if
condition|(
name|readbuf_left
operator|<=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|readbuf_size
operator|-
name|pos
operator|<
name|TMP_WAVBUF_SIZE
condition|)
name|readbuf_left
operator|=
name|readbuf_size
operator|-
name|pos
expr_stmt|;
else|else
name|readbuf_left
operator|=
name|TMP_WAVBUF_SIZE
expr_stmt|;
comment|/* read from user buffer */
if|if
condition|(
name|readbuf_flags
operator|&
name|AWE_SAMPLE_8BITS
condition|)
block|{
name|unsigned
name|char
modifier|*
name|pbuf
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|readbuf
decl_stmt|;
name|COPY_FROM_USER
argument_list|(
name|pbuf
argument_list|,
name|readbuf_addr
argument_list|,
name|readbuf_offs
operator|+
name|pos
argument_list|,
name|readbuf_left
argument_list|)
expr_stmt|;
comment|/* convert 8bit -> 16bit */
for|for
control|(
name|i
operator|=
name|readbuf_left
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|readbuf
index|[
name|i
index|]
operator|=
name|pbuf
index|[
name|i
index|]
operator|<<
literal|8
expr_stmt|;
block|}
else|else
block|{
name|COPY_FROM_USER
argument_list|(
name|readbuf
argument_list|,
name|readbuf_addr
argument_list|,
name|readbuf_offs
operator|+
name|pos
operator|*
literal|2
argument_list|,
name|readbuf_left
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readbuf_flags
operator|&
name|AWE_SAMPLE_UNSIGNED
condition|)
block|{
comment|/* unsigned -> signed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|readbuf_left
condition|;
name|i
operator|++
control|)
name|readbuf
index|[
name|i
index|]
operator|^=
literal|0x8000
expr_stmt|;
block|}
name|readbuf_cur
operator|=
literal|0
expr_stmt|;
block|}
name|readbuf_left
operator|--
expr_stmt|;
return|return
name|readbuf
index|[
name|readbuf_cur
operator|++
index|]
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* AWE_USE_BUFFERED_IO */
end_comment

begin_define
define|#
directive|define
name|awe_readbuf_word
parameter_list|(
name|pos
parameter_list|)
value|awe_read_word(pos)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AWE_USE_BUFFERED_IO */
end_comment

begin_comment
comment|/* initialize read buffer */
end_comment

begin_function
specifier|static
name|void
name|awe_init_readbuf
parameter_list|(
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|long
name|offset
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|mode_flags
parameter_list|)
block|{
name|readbuf_addr
operator|=
name|addr
expr_stmt|;
name|readbuf_offs
operator|=
name|offset
expr_stmt|;
name|readbuf_flags
operator|=
name|mode_flags
expr_stmt|;
ifdef|#
directive|ifdef
name|AWE_USE_BUFFERED_IO
name|readbuf_size
operator|=
name|size
expr_stmt|;
name|readbuf_left
operator|=
literal|0
expr_stmt|;
name|readbuf_cur
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* read directly from user buffer */
end_comment

begin_function
specifier|static
name|unsigned
name|short
name|awe_read_word
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|unsigned
name|short
name|c
decl_stmt|;
comment|/* read from user buffer */
if|if
condition|(
name|readbuf_flags
operator|&
name|AWE_SAMPLE_8BITS
condition|)
block|{
name|unsigned
name|char
name|cc
decl_stmt|;
name|GET_BYTE_FROM_USER
argument_list|(
name|cc
argument_list|,
name|readbuf_addr
argument_list|,
name|readbuf_offs
operator|+
name|pos
argument_list|)
expr_stmt|;
name|c
operator|=
name|cc
operator|<<
literal|8
expr_stmt|;
comment|/* convert 8bit -> 16bit */
block|}
else|else
block|{
name|GET_SHORT_FROM_USER
argument_list|(
name|c
argument_list|,
name|readbuf_addr
argument_list|,
name|readbuf_offs
operator|+
name|pos
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readbuf_flags
operator|&
name|AWE_SAMPLE_UNSIGNED
condition|)
name|c
operator|^=
literal|0x8000
expr_stmt|;
comment|/* unsigned -> signed */
return|return
name|c
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BLANK_LOOP_START
value|8
end_define

begin_define
define|#
directive|define
name|BLANK_LOOP_END
value|40
end_define

begin_define
define|#
directive|define
name|BLANK_LOOP_SIZE
value|48
end_define

begin_comment
comment|/* loading onto memory */
end_comment

begin_function
specifier|static
name|int
name|awe_write_wave_data
parameter_list|(
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|long
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|awe_sample_info
modifier|*
name|sp
init|=
operator|&
name|samples
index|[
name|free_sample
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|truesize
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|unsigned
name|long
name|csum1
decl_stmt|,
name|csum2
decl_stmt|;
name|DECL_INTR_FLAGS
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* be sure loop points start< end */
if|if
condition|(
name|sp
operator|->
name|loopstart
operator|>
name|sp
operator|->
name|loopend
condition|)
block|{
name|long
name|tmp
init|=
name|sp
operator|->
name|loopstart
decl_stmt|;
name|sp
operator|->
name|loopstart
operator|=
name|sp
operator|->
name|loopend
expr_stmt|;
name|sp
operator|->
name|loopend
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* compute true data size to be loaded */
name|truesize
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|mode_flags
operator|&
name|AWE_SAMPLE_BIDIR_LOOP
condition|)
name|truesize
operator|+=
name|sp
operator|->
name|loopend
operator|-
name|sp
operator|->
name|loopstart
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|mode_flags
operator|&
name|AWE_SAMPLE_NO_BLANK
condition|)
name|truesize
operator|+=
name|BLANK_LOOP_SIZE
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
name|free_mem_ptr
operator|+
name|truesize
operator|>=
name|awe_mem_size
operator|/
literal|2
condition|)
block|{
name|ERRMSG
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Error: Sample memory full\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
comment|/* recalculate address offset */
name|sp
operator|->
name|end
operator|-=
name|sp
operator|->
name|start
expr_stmt|;
name|sp
operator|->
name|loopstart
operator|-=
name|sp
operator|->
name|start
expr_stmt|;
name|sp
operator|->
name|loopend
operator|-=
name|sp
operator|->
name|start
expr_stmt|;
name|sp
operator|->
name|size
operator|=
name|truesize
expr_stmt|;
name|sp
operator|->
name|start
operator|=
name|free_mem_ptr
operator|+
name|AWE_DRAM_OFFSET
expr_stmt|;
name|sp
operator|->
name|end
operator|+=
name|free_mem_ptr
operator|+
name|AWE_DRAM_OFFSET
expr_stmt|;
name|sp
operator|->
name|loopstart
operator|+=
name|free_mem_ptr
operator|+
name|AWE_DRAM_OFFSET
expr_stmt|;
name|sp
operator|->
name|loopend
operator|+=
name|free_mem_ptr
operator|+
name|AWE_DRAM_OFFSET
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|awe_open_dram_for_write
argument_list|(
name|free_mem_ptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
name|awe_init_readbuf
argument_list|(
name|addr
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|sp
operator|->
name|mode_flags
argument_list|)
expr_stmt|;
name|csum1
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|short
name|c
decl_stmt|;
name|c
operator|=
name|awe_readbuf_word
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|csum1
operator|+=
name|c
expr_stmt|;
name|awe_write_dram
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|sp
operator|->
name|loopend
operator|&&
operator|(
name|sp
operator|->
name|mode_flags
operator|&
name|AWE_SAMPLE_BIDIR_LOOP
operator|)
condition|)
block|{
name|int
name|looplen
init|=
name|sp
operator|->
name|loopend
operator|-
name|sp
operator|->
name|loopstart
decl_stmt|;
comment|/* copy reverse loop */
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|looplen
condition|;
name|k
operator|++
control|)
block|{
comment|/* non-buffered data */
name|c
operator|=
name|awe_read_word
argument_list|(
name|i
operator|-
name|k
argument_list|)
expr_stmt|;
name|awe_write_dram
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* if no blank loop is attached in the sample, add it */
if|if
condition|(
name|sp
operator|->
name|mode_flags
operator|&
name|AWE_SAMPLE_NO_BLANK
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLANK_LOOP_SIZE
condition|;
name|i
operator|++
control|)
name|awe_write_dram
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|mode_flags
operator|&
name|AWE_SAMPLE_SINGLESHOT
condition|)
block|{
name|sp
operator|->
name|loopstart
operator|=
name|sp
operator|->
name|end
operator|+
name|BLANK_LOOP_START
expr_stmt|;
name|sp
operator|->
name|loopend
operator|=
name|sp
operator|->
name|end
operator|+
name|BLANK_LOOP_END
expr_stmt|;
block|}
name|sp
operator|->
name|size
operator|+=
name|BLANK_LOOP_SIZE
expr_stmt|;
block|}
name|awe_close_dram
argument_list|()
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|checksum_flag
condition|)
block|{
ifdef|#
directive|ifdef
name|AWE_CHECKSUM_DATA
if|if
condition|(
name|sp
operator|->
name|checksum_flag
operator|!=
literal|2
operator|&&
name|csum1
operator|!=
name|sp
operator|->
name|checksum
condition|)
block|{
name|ERRMSG
argument_list|(
name|printk
argument_list|(
literal|"AWE32: [%d] checksum mismatch on data %x:%x\n"
argument_list|,
name|free_sample
argument_list|,
operator|(
name|int
operator|)
name|samples
index|[
name|free_sample
index|]
operator|.
name|checksum
argument_list|,
operator|(
name|int
operator|)
name|csum1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|NO_DATA_ERR
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* AWE_CHECKSUM_DATA */
ifdef|#
directive|ifdef
name|AWE_CHECKSUM_MEMORY
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|awe_open_dram_for_read
argument_list|(
name|free_mem_ptr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|csum2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|short
name|c
decl_stmt|;
name|c
operator|=
name|awe_peek
argument_list|(
name|AWE_SMLD
argument_list|)
expr_stmt|;
name|csum2
operator|+=
name|c
expr_stmt|;
block|}
name|awe_close_dram_for_read
argument_list|()
expr_stmt|;
if|if
condition|(
name|csum2
operator|!=
name|samples
index|[
name|free_sample
index|]
operator|.
name|checksum
condition|)
block|{
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|ERRMSG
argument_list|(
name|printk
argument_list|(
literal|"AWE32: [%d] checksum mismatch on DRAM %x:%x\n"
argument_list|,
name|free_sample
argument_list|,
operator|(
name|int
operator|)
name|samples
index|[
name|free_sample
index|]
operator|.
name|checksum
argument_list|,
operator|(
name|int
operator|)
name|csum2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|NO_DATA_ERR
argument_list|)
return|;
block|}
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AWE_CHECKSUM_MEMORY */
block|}
name|free_mem_ptr
operator|+=
name|sp
operator|->
name|size
expr_stmt|;
comment|/* re-initialize FM passthrough */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|awe_init_fm
argument_list|()
expr_stmt|;
name|awe_tweak
argument_list|()
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* calculate GUS envelope time:  * is this correct?  i have no idea..  */
end_comment

begin_function
specifier|static
name|int
name|calc_gus_envelope_time
parameter_list|(
name|int
name|rate
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|p
decl_stmt|,
name|t
decl_stmt|;
name|r
operator|=
operator|(
literal|3
operator|-
operator|(
operator|(
name|rate
operator|>>
literal|6
operator|)
operator|&
literal|3
operator|)
operator|)
operator|*
literal|3
expr_stmt|;
name|p
operator|=
name|rate
operator|&
literal|0x3f
expr_stmt|;
name|t
operator|=
name|end
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|t
operator|=
operator|-
name|t
expr_stmt|;
if|if
condition|(
literal|13
operator|>
name|r
condition|)
name|t
operator|=
name|t
operator|<<
operator|(
literal|13
operator|-
name|r
operator|)
expr_stmt|;
else|else
name|t
operator|=
name|t
operator|>>
operator|(
name|r
operator|-
literal|13
operator|)
expr_stmt|;
return|return
operator|(
name|t
operator|*
literal|10
operator|)
operator|/
operator|(
name|p
operator|*
literal|441
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|calc_gus_sustain
parameter_list|(
name|val
parameter_list|)
value|(0x7f - vol_table[(val)/2])
end_define

begin_define
define|#
directive|define
name|calc_gus_attenuation
parameter_list|(
name|val
parameter_list|)
value|vol_table[(val)/2]
end_define

begin_comment
comment|/* load GUS patch */
end_comment

begin_function
specifier|static
name|int
name|awe_load_guspatch
parameter_list|(
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
block|{
name|struct
name|patch_info
name|patch
decl_stmt|;
name|awe_voice_list
modifier|*
name|rec
decl_stmt|,
modifier|*
name|curp
decl_stmt|;
name|long
name|sizeof_patch
decl_stmt|;
name|int
name|note
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|sizeof_patch
operator|=
operator|(
name|long
operator|)
operator|&
name|patch
operator|.
name|data
index|[
literal|0
index|]
operator|-
operator|(
name|long
operator|)
operator|&
name|patch
expr_stmt|;
comment|/* header size */
if|if
condition|(
name|free_sample
operator|>=
name|AWE_MAX_SAMPLES
condition|)
block|{
name|ERRMSG
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Error: Sample table full\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
if|if
condition|(
name|free_info
operator|>=
name|AWE_MAX_INFOS
condition|)
block|{
name|ERRMSG
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Error: Too many voice informations\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
if|if
condition|(
name|size
operator|<
name|sizeof_patch
condition|)
block|{
name|ERRMSG
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Error: Patch header too short\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|COPY_FROM_USER
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|patch
operator|)
operator|+
name|offs
argument_list|,
name|addr
argument_list|,
name|offs
argument_list|,
name|sizeof_patch
operator|-
name|offs
argument_list|)
expr_stmt|;
name|size
operator|-=
name|sizeof_patch
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|patch
operator|.
name|len
condition|)
block|{
name|FATALERR
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Warning: Patch record too short (%d<%d)\n"
argument_list|,
name|size
argument_list|,
operator|(
name|int
operator|)
name|patch
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|patch
operator|.
name|len
operator|=
name|size
expr_stmt|;
block|}
name|samples
index|[
name|free_sample
index|]
operator|.
name|sf_id
operator|=
literal|0
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|sample
operator|=
name|free_sample
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|start
operator|=
literal|0
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|end
operator|=
name|patch
operator|.
name|len
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|loopstart
operator|=
name|patch
operator|.
name|loop_start
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|loopend
operator|=
name|patch
operator|.
name|loop_end
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|size
operator|=
name|patch
operator|.
name|len
expr_stmt|;
comment|/* set up mode flags */
name|samples
index|[
name|free_sample
index|]
operator|.
name|mode_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_16_BITS
operator|)
condition|)
name|samples
index|[
name|free_sample
index|]
operator|.
name|mode_flags
operator||=
name|AWE_SAMPLE_8BITS
expr_stmt|;
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_UNSIGNED
condition|)
name|samples
index|[
name|free_sample
index|]
operator|.
name|mode_flags
operator||=
name|AWE_SAMPLE_UNSIGNED
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|mode_flags
operator||=
name|AWE_SAMPLE_NO_BLANK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|patch
operator|.
name|mode
operator|&
operator|(
name|WAVE_LOOPING
operator||
name|WAVE_BIDIR_LOOP
operator|)
operator|)
condition|)
name|samples
index|[
name|free_sample
index|]
operator|.
name|mode_flags
operator||=
name|AWE_SAMPLE_SINGLESHOT
expr_stmt|;
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_BIDIR_LOOP
condition|)
name|samples
index|[
name|free_sample
index|]
operator|.
name|mode_flags
operator||=
name|AWE_SAMPLE_BIDIR_LOOP
expr_stmt|;
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [sample %d mode %x]\n"
argument_list|,
name|patch
operator|.
name|instr_no
argument_list|,
name|samples
index|[
name|free_sample
index|]
operator|.
name|mode_flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_16_BITS
condition|)
block|{
comment|/* convert to word offsets */
name|samples
index|[
name|free_sample
index|]
operator|.
name|size
operator|/=
literal|2
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|end
operator|/=
literal|2
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|loopstart
operator|/=
literal|2
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|loopend
operator|/=
literal|2
expr_stmt|;
block|}
name|samples
index|[
name|free_sample
index|]
operator|.
name|checksum_flag
operator|=
literal|0
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|awe_write_wave_data
argument_list|(
name|addr
argument_list|,
name|sizeof_patch
argument_list|,
name|samples
index|[
name|free_sample
index|]
operator|.
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
name|awe_check_loaded
argument_list|()
expr_stmt|;
name|samples
index|[
name|free_sample
index|]
operator|.
name|sf_id
operator|=
name|current_sf_id
expr_stmt|;
name|free_sample
operator|++
expr_stmt|;
comment|/* set up voice info */
name|rec
operator|=
operator|&
name|infos
index|[
name|free_info
index|]
expr_stmt|;
name|awe_init_voice_info
argument_list|(
operator|&
name|rec
operator|->
name|v
argument_list|)
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|sf_id
operator|=
name|current_sf_id
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|sample
operator|=
name|free_sample
operator|-
literal|1
expr_stmt|;
comment|/* the last sample */
name|rec
operator|->
name|v
operator|.
name|rate_offset
operator|=
name|calc_rate_offset
argument_list|(
name|patch
operator|.
name|base_freq
argument_list|)
expr_stmt|;
name|note
operator|=
name|freq_to_note
argument_list|(
name|patch
operator|.
name|base_note
argument_list|)
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|root
operator|=
name|note
operator|/
literal|100
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|tune
operator|=
operator|-
operator|(
name|note
operator|%
literal|100
operator|)
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|low
operator|=
name|freq_to_note
argument_list|(
name|patch
operator|.
name|low_note
argument_list|)
operator|/
literal|100
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|high
operator|=
name|freq_to_note
argument_list|(
name|patch
operator|.
name|high_note
argument_list|)
operator|/
literal|100
expr_stmt|;
name|DEBUG
argument_list|(
literal|1
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [gus base offset=%d, note=%d, range=%d-%d(%d-%d)]\n"
argument_list|,
name|rec
operator|->
name|v
operator|.
name|rate_offset
argument_list|,
name|note
argument_list|,
name|rec
operator|->
name|v
operator|.
name|low
argument_list|,
name|rec
operator|->
name|v
operator|.
name|high
argument_list|,
name|patch
operator|.
name|low_note
argument_list|,
name|patch
operator|.
name|high_note
argument_list|)
argument_list|)
expr_stmt|;
comment|/* panning position; -128 - 127 => 0-127 */
name|rec
operator|->
name|v
operator|.
name|pan
operator|=
operator|(
name|patch
operator|.
name|panning
operator|+
literal|128
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* detuning is ignored */
comment|/* 6points volume envelope */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|int
name|attack
decl_stmt|,
name|hold
decl_stmt|,
name|decay
decl_stmt|,
name|release
decl_stmt|;
name|attack
operator|=
name|calc_gus_envelope_time
argument_list|(
name|patch
operator|.
name|env_rate
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|hold
operator|=
name|calc_gus_envelope_time
argument_list|(
name|patch
operator|.
name|env_rate
index|[
literal|1
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|0
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|decay
operator|=
name|calc_gus_envelope_time
argument_list|(
name|patch
operator|.
name|env_rate
index|[
literal|2
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|1
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|release
operator|=
name|calc_gus_envelope_time
argument_list|(
name|patch
operator|.
name|env_rate
index|[
literal|3
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|1
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|release
operator|+=
name|calc_gus_envelope_time
argument_list|(
name|patch
operator|.
name|env_rate
index|[
literal|4
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|3
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|release
operator|+=
name|calc_gus_envelope_time
argument_list|(
name|patch
operator|.
name|env_rate
index|[
literal|5
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|4
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|parm
operator|.
name|volatkhld
operator|=
operator|(
name|calc_parm_attack
argument_list|(
name|attack
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|calc_parm_hold
argument_list|(
name|hold
argument_list|)
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|parm
operator|.
name|voldcysus
operator|=
operator|(
name|calc_gus_sustain
argument_list|(
name|patch
operator|.
name|env_offset
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|calc_parm_decay
argument_list|(
name|decay
argument_list|)
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|parm
operator|.
name|volrelease
operator|=
literal|0x8000
operator||
name|calc_parm_decay
argument_list|(
name|release
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [gusenv atk=%d, hld=%d, dcy=%d, rel=%d]\n"
argument_list|,
name|attack
argument_list|,
name|hold
argument_list|,
name|decay
argument_list|,
name|release
argument_list|)
argument_list|)
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|attenuation
operator|=
name|calc_gus_attenuation
argument_list|(
name|patch
operator|.
name|env_offset
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* tremolo effect */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_TREMOLO
condition|)
block|{
name|int
name|rate
init|=
operator|(
name|patch
operator|.
name|tremolo_rate
operator|*
literal|1000
operator|/
literal|38
operator|)
operator|/
literal|42
decl_stmt|;
name|rec
operator|->
name|v
operator|.
name|parm
operator|.
name|tremfrq
operator|=
operator|(
operator|(
name|patch
operator|.
name|tremolo_depth
operator|/
literal|2
operator|)
operator|<<
literal|8
operator|)
operator||
name|rate
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [gusenv tremolo rate=%d, dep=%d, tremfrq=%x]\n"
argument_list|,
name|patch
operator|.
name|tremolo_rate
argument_list|,
name|patch
operator|.
name|tremolo_depth
argument_list|,
name|rec
operator|->
name|v
operator|.
name|parm
operator|.
name|tremfrq
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* vibrato effect */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_VIBRATO
condition|)
block|{
name|int
name|rate
init|=
operator|(
name|patch
operator|.
name|vibrato_rate
operator|*
literal|1000
operator|/
literal|38
operator|)
operator|/
literal|42
decl_stmt|;
name|rec
operator|->
name|v
operator|.
name|parm
operator|.
name|fm2frq2
operator|=
operator|(
operator|(
name|patch
operator|.
name|vibrato_depth
operator|/
literal|6
operator|)
operator|<<
literal|8
operator|)
operator||
name|rate
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [gusenv vibrato rate=%d, dep=%d, tremfrq=%x]\n"
argument_list|,
name|patch
operator|.
name|tremolo_rate
argument_list|,
name|patch
operator|.
name|tremolo_depth
argument_list|,
name|rec
operator|->
name|v
operator|.
name|parm
operator|.
name|tremfrq
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* scale_freq, scale_factor, volume, and fractions not implemented */
comment|/* set the voice index */
name|awe_set_sample
argument_list|(
operator|&
name|rec
operator|->
name|v
argument_list|)
expr_stmt|;
comment|/* prepend to top of the list */
name|curp
operator|=
name|awe_search_instr
argument_list|(
name|awe_gus_bank
argument_list|,
name|patch
operator|.
name|instr_no
argument_list|)
expr_stmt|;
name|rec
operator|->
name|bank
operator|=
name|awe_gus_bank
expr_stmt|;
name|rec
operator|->
name|instr
operator|=
name|patch
operator|.
name|instr_no
expr_stmt|;
name|rec
operator|->
name|next_instr
operator|=
name|curp
expr_stmt|;
name|rec
operator|->
name|next_bank
operator|=
name|preset_table
index|[
name|rec
operator|->
name|instr
index|]
expr_stmt|;
name|preset_table
index|[
name|rec
operator|->
name|instr
index|]
operator|=
name|rec
expr_stmt|;
name|free_info
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* remove samples with current sf_id from instrument list */
end_comment

begin_function
specifier|static
name|awe_voice_list
modifier|*
name|awe_get_removed_list
parameter_list|(
name|awe_voice_list
modifier|*
name|curp
parameter_list|)
block|{
name|awe_voice_list
modifier|*
name|lastp
decl_stmt|,
modifier|*
modifier|*
name|prevp
decl_stmt|;
name|int
name|maxc
decl_stmt|;
name|lastp
operator|=
name|curp
expr_stmt|;
name|prevp
operator|=
operator|&
name|lastp
expr_stmt|;
for|for
control|(
name|maxc
operator|=
name|AWE_MAX_INFOS
init|;
name|curp
operator|&&
name|maxc
condition|;
name|curp
operator|=
name|curp
operator|->
name|next_instr
operator|,
name|maxc
operator|--
control|)
block|{
if|if
condition|(
name|curp
operator|->
name|v
operator|.
name|sf_id
operator|==
name|current_sf_id
condition|)
operator|*
name|prevp
operator|=
name|curp
operator|->
name|next_instr
expr_stmt|;
else|else
name|prevp
operator|=
operator|&
name|curp
operator|->
name|next_instr
expr_stmt|;
block|}
return|return
name|lastp
return|;
block|}
end_function

begin_comment
comment|/* remove last loaded samples */
end_comment

begin_function
specifier|static
name|void
name|awe_remove_samples
parameter_list|(
name|void
parameter_list|)
block|{
name|awe_voice_list
modifier|*
modifier|*
name|prevp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|nextp
decl_stmt|;
name|int
name|maxc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|last_sample
operator|==
name|free_sample
operator|&&
name|last_info
operator|==
name|free_info
condition|)
return|return;
comment|/* remove the records from preset table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_PRESETS
condition|;
name|i
operator|++
control|)
block|{
name|prevp
operator|=
operator|&
name|preset_table
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|maxc
operator|=
name|AWE_MAX_INFOS
operator|,
name|p
operator|=
name|preset_table
index|[
name|i
index|]
init|;
name|p
operator|&&
name|maxc
condition|;
name|p
operator|=
name|nextp
operator|,
name|maxc
operator|--
control|)
block|{
name|nextp
operator|=
name|p
operator|->
name|next_bank
expr_stmt|;
name|p
operator|=
name|awe_get_removed_list
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
operator|*
name|prevp
operator|=
name|nextp
expr_stmt|;
else|else
block|{
operator|*
name|prevp
operator|=
name|p
expr_stmt|;
name|prevp
operator|=
operator|&
name|p
operator|->
name|next_bank
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
name|last_sample
init|;
name|i
operator|<
name|free_sample
condition|;
name|i
operator|++
control|)
name|free_mem_ptr
operator|-=
name|samples
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
name|free_sample
operator|=
name|last_sample
expr_stmt|;
name|free_info
operator|=
name|last_info
expr_stmt|;
name|current_sf_id
operator|--
expr_stmt|;
name|loaded_once
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* search the specified sample */
end_comment

begin_function
specifier|static
name|short
name|awe_set_sample
parameter_list|(
name|awe_voice_info
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|free_sample
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|samples
index|[
name|i
index|]
operator|.
name|sf_id
operator|==
name|vp
operator|->
name|sf_id
operator|&&
name|samples
index|[
name|i
index|]
operator|.
name|sample
operator|==
name|vp
operator|->
name|sample
condition|)
block|{
comment|/* set the actual sample offsets */
name|vp
operator|->
name|start
operator|+=
name|samples
index|[
name|i
index|]
operator|.
name|start
expr_stmt|;
name|vp
operator|->
name|end
operator|+=
name|samples
index|[
name|i
index|]
operator|.
name|end
expr_stmt|;
name|vp
operator|->
name|loopstart
operator|+=
name|samples
index|[
name|i
index|]
operator|.
name|loopstart
expr_stmt|;
name|vp
operator|->
name|loopend
operator|+=
name|samples
index|[
name|i
index|]
operator|.
name|loopend
expr_stmt|;
comment|/* copy mode flags */
name|vp
operator|->
name|mode
operator||=
operator|(
name|samples
index|[
name|i
index|]
operator|.
name|mode_flags
operator|<<
literal|6
operator|)
expr_stmt|;
comment|/* set index */
name|vp
operator|->
name|index
operator|=
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* voice pressure change */
end_comment

begin_function
specifier|static
name|void
name|awe_aftertouch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|pressure
parameter_list|)
block|{
name|DECL_INTR_FLAGS
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [after(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|pressure
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|awe_max_voices
condition|)
return|return;
name|voices
index|[
name|voice
index|]
operator|.
name|velocity
operator|=
name|pressure
expr_stmt|;
name|awe_calc_volume
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|awe_set_volume
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* voice control change */
end_comment

begin_function
specifier|static
name|void
name|awe_controller
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|ctrl_num
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|DECL_INTR_FLAGS
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|awe_max_voices
condition|)
return|return;
switch|switch
condition|(
name|ctrl_num
condition|)
block|{
case|case
name|CTL_BANK_SELECT
case|:
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [bank(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|bank
operator|=
name|value
expr_stmt|;
break|break;
case|case
name|CTRL_PITCH_BENDER
case|:
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [bend(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero centered */
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|value
expr_stmt|;
name|awe_calc_pitch
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|awe_set_pitch
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL_PITCH_BENDER_RANGE
case|:
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [range(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* sense x 100 */
name|voices
index|[
name|voice
index|]
operator|.
name|bender_range
operator|=
name|value
expr_stmt|;
comment|/* no audible pitch change yet.. */
break|break;
case|case
name|CTL_EXPRESSION
case|:
name|value
operator|/=
literal|128
expr_stmt|;
case|case
name|CTRL_EXPRESSION
case|:
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [expr(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 0 - 127 */
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
operator|=
name|value
expr_stmt|;
name|awe_calc_volume
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|awe_set_volume
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_PAN
case|:
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [pan(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (0-127) -> signed 8bit */
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
name|value
operator|*
literal|2
operator|-
literal|128
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|awe_set_pan
argument_list|(
name|voice
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MAIN_VOLUME
case|:
name|value
operator|=
operator|(
name|value
operator|*
literal|127
operator|)
operator|/
literal|16383
expr_stmt|;
case|case
name|CTRL_MAIN_VOLUME
case|:
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [mainvol(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 0 - 127 */
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
operator|=
name|value
expr_stmt|;
name|awe_calc_volume
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|awe_set_volume
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_EXT_EFF_DEPTH
case|:
comment|/* reverb effects: 0-127 */
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [reverb(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|FX_SET
argument_list|(
name|voice
argument_list|,
name|AWE_FX_REVERB
argument_list|,
name|value
operator|*
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_CHORUS_DEPTH
case|:
comment|/* chorus effects: 0-127 */
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [chorus(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|FX_SET
argument_list|(
name|voice
argument_list|,
name|AWE_FX_CHORUS
argument_list|,
name|value
operator|*
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [control(%d) ctrl=%d val=%d]\n"
argument_list|,
name|voice
argument_list|,
name|ctrl_num
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* voice pan change (value = -128 - 127) */
end_comment

begin_function
specifier|static
name|void
name|awe_panning
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|DECL_INTR_FLAGS
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|voice
operator|>=
literal|0
operator|||
name|voice
operator|<
name|awe_max_voices
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
name|value
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [pan(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|panning
argument_list|)
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|awe_set_pan
argument_list|(
name|voice
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* volume mode change */
end_comment

begin_function
specifier|static
name|void
name|awe_volume_method
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* not impremented */
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [volmethod mode=%d]\n"
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* patch manager */
end_comment

begin_function
specifier|static
name|int
name|awe_patchmgr
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|patmgr_info
modifier|*
name|rec
parameter_list|)
block|{
name|FATALERR
argument_list|(
name|printk
argument_list|(
literal|"AWE32 Warning: patch manager control not supported\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* pitch wheel change: 0-16384 */
end_comment

begin_function
specifier|static
name|void
name|awe_bender
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|DECL_INTR_FLAGS
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|awe_max_voices
condition|)
return|return;
comment|/* convert to zero centered value */
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|value
operator|-
literal|8192
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [bend(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|bender
argument_list|)
argument_list|)
expr_stmt|;
name|awe_calc_pitch
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|awe_set_pitch
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* search an empty voice; used by sequencer2 */
end_comment

begin_function
specifier|static
name|int
name|awe_alloc
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|,
name|struct
name|voice_alloc_info
modifier|*
name|alloc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|p
decl_stmt|,
name|best
init|=
operator|-
literal|1
decl_stmt|,
name|best_time
init|=
literal|0x7fffffff
decl_stmt|;
name|p
operator|=
name|alloc
operator|->
name|ptr
expr_stmt|;
comment|/* First look for a completely stopped voice */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alloc
operator|->
name|max_voice
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alloc
operator|->
name|map
index|[
name|p
index|]
operator|==
literal|0
condition|)
block|{
name|alloc
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
if|if
condition|(
name|alloc
operator|->
name|alloc_times
index|[
name|p
index|]
operator|<
name|best_time
condition|)
block|{
name|best
operator|=
name|p
expr_stmt|;
name|best_time
operator|=
name|alloc
operator|->
name|alloc_times
index|[
name|p
index|]
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
operator|%
name|alloc
operator|->
name|max_voice
expr_stmt|;
block|}
comment|/* Then look for a releasing voice */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|alloc
operator|->
name|max_voice
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|alloc
operator|->
name|map
index|[
name|p
index|]
operator|==
literal|0xffff
condition|)
block|{
name|alloc
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
name|p
operator|=
operator|(
name|p
operator|+
literal|1
operator|)
operator|%
name|alloc
operator|->
name|max_voice
expr_stmt|;
block|}
if|if
condition|(
name|best
operator|>=
literal|0
condition|)
name|p
operator|=
name|best
expr_stmt|;
comment|/* terminate the voice */
if|if
condition|(
name|voices
index|[
name|p
index|]
operator|.
name|state
condition|)
name|awe_terminate
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|alloc
operator|->
name|ptr
operator|=
name|p
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* set up voice; used by sequencer2 */
end_comment

begin_function
specifier|static
name|void
name|awe_setup_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|chn
parameter_list|)
block|{
name|struct
name|channel_info
modifier|*
name|info
decl_stmt|;
if|if
condition|(
name|synth_devs
index|[
name|dev
index|]
operator|==
name|NULL
operator|||
operator|(
name|info
operator|=
operator|&
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|awe_max_voices
condition|)
return|return;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [setup(%d) ch=%d]\n"
argument_list|,
name|voice
argument_list|,
name|chn
argument_list|)
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|expression_vol
operator|=
name|info
operator|->
name|controllers
index|[
name|CTL_EXPRESSION
index|]
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|main_vol
operator|=
operator|(
name|info
operator|->
name|controllers
index|[
name|CTL_MAIN_VOLUME
index|]
operator|*
literal|100
operator|)
operator|/
literal|128
expr_stmt|;
comment|/* 0 - 127 */
name|voices
index|[
name|voice
index|]
operator|.
name|panning
operator|=
name|info
operator|->
name|controllers
index|[
name|CTL_PAN
index|]
operator|*
literal|2
operator|-
literal|128
expr_stmt|;
comment|/* signed 8bit */
name|voices
index|[
name|voice
index|]
operator|.
name|bender
operator|=
name|info
operator|->
name|bender_value
expr_stmt|;
comment|/* zero center */
name|voices
index|[
name|voice
index|]
operator|.
name|bank
operator|=
name|info
operator|->
name|controllers
index|[
name|CTL_BANK_SELECT
index|]
expr_stmt|;
name|awe_set_instr
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|info
operator|->
name|pgm_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*================================================================  * initialization of AWE32  *================================================================*/
end_comment

begin_comment
comment|/* intiailize audio channels */
end_comment

begin_function
specifier|static
name|void
name|awe_init_audio
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
comment|/* turn off envelope engines */
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|AWE_MAX_VOICES
condition|;
name|ch
operator|++
control|)
block|{
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0x0080
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|AWE_MAX_VOICES
condition|;
name|ch
operator|++
control|)
block|{
name|awe_poke
argument_list|(
name|AWE_ENVVOL
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ENVVAL
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUS
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ATKHLDV
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_LFO1VAL
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ATKHLD
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_LFO2VAL
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_IP
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_IFATN
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_PEFE
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_FMMOD
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_TREMFRQ
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_FM2FRQ2
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PTRX
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|AWE_MAX_VOICES
condition|;
name|ch
operator|++
control|)
block|{
name|awe_poke_dw
argument_list|(
name|AWE_CPF
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CVCF
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* initialize DMA address */
end_comment

begin_function
specifier|static
name|void
name|awe_init_dma
parameter_list|(
name|void
parameter_list|)
block|{
name|awe_poke_dw
argument_list|(
name|AWE_SMALR
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_SMARR
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_SMALW
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_SMARW
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* initialization arrays */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|init1
index|[
literal|128
index|]
init|=
block|{
literal|0x03ff
block|,
literal|0x0030
block|,
literal|0x07ff
block|,
literal|0x0130
block|,
literal|0x0bff
block|,
literal|0x0230
block|,
literal|0x0fff
block|,
literal|0x0330
block|,
literal|0x13ff
block|,
literal|0x0430
block|,
literal|0x17ff
block|,
literal|0x0530
block|,
literal|0x1bff
block|,
literal|0x0630
block|,
literal|0x1fff
block|,
literal|0x0730
block|,
literal|0x23ff
block|,
literal|0x0830
block|,
literal|0x27ff
block|,
literal|0x0930
block|,
literal|0x2bff
block|,
literal|0x0a30
block|,
literal|0x2fff
block|,
literal|0x0b30
block|,
literal|0x33ff
block|,
literal|0x0c30
block|,
literal|0x37ff
block|,
literal|0x0d30
block|,
literal|0x3bff
block|,
literal|0x0e30
block|,
literal|0x3fff
block|,
literal|0x0f30
block|,
literal|0x43ff
block|,
literal|0x0030
block|,
literal|0x47ff
block|,
literal|0x0130
block|,
literal|0x4bff
block|,
literal|0x0230
block|,
literal|0x4fff
block|,
literal|0x0330
block|,
literal|0x53ff
block|,
literal|0x0430
block|,
literal|0x57ff
block|,
literal|0x0530
block|,
literal|0x5bff
block|,
literal|0x0630
block|,
literal|0x5fff
block|,
literal|0x0730
block|,
literal|0x63ff
block|,
literal|0x0830
block|,
literal|0x67ff
block|,
literal|0x0930
block|,
literal|0x6bff
block|,
literal|0x0a30
block|,
literal|0x6fff
block|,
literal|0x0b30
block|,
literal|0x73ff
block|,
literal|0x0c30
block|,
literal|0x77ff
block|,
literal|0x0d30
block|,
literal|0x7bff
block|,
literal|0x0e30
block|,
literal|0x7fff
block|,
literal|0x0f30
block|,
literal|0x83ff
block|,
literal|0x0030
block|,
literal|0x87ff
block|,
literal|0x0130
block|,
literal|0x8bff
block|,
literal|0x0230
block|,
literal|0x8fff
block|,
literal|0x0330
block|,
literal|0x93ff
block|,
literal|0x0430
block|,
literal|0x97ff
block|,
literal|0x0530
block|,
literal|0x9bff
block|,
literal|0x0630
block|,
literal|0x9fff
block|,
literal|0x0730
block|,
literal|0xa3ff
block|,
literal|0x0830
block|,
literal|0xa7ff
block|,
literal|0x0930
block|,
literal|0xabff
block|,
literal|0x0a30
block|,
literal|0xafff
block|,
literal|0x0b30
block|,
literal|0xb3ff
block|,
literal|0x0c30
block|,
literal|0xb7ff
block|,
literal|0x0d30
block|,
literal|0xbbff
block|,
literal|0x0e30
block|,
literal|0xbfff
block|,
literal|0x0f30
block|,
literal|0xc3ff
block|,
literal|0x0030
block|,
literal|0xc7ff
block|,
literal|0x0130
block|,
literal|0xcbff
block|,
literal|0x0230
block|,
literal|0xcfff
block|,
literal|0x0330
block|,
literal|0xd3ff
block|,
literal|0x0430
block|,
literal|0xd7ff
block|,
literal|0x0530
block|,
literal|0xdbff
block|,
literal|0x0630
block|,
literal|0xdfff
block|,
literal|0x0730
block|,
literal|0xe3ff
block|,
literal|0x0830
block|,
literal|0xe7ff
block|,
literal|0x0930
block|,
literal|0xebff
block|,
literal|0x0a30
block|,
literal|0xefff
block|,
literal|0x0b30
block|,
literal|0xf3ff
block|,
literal|0x0c30
block|,
literal|0xf7ff
block|,
literal|0x0d30
block|,
literal|0xfbff
block|,
literal|0x0e30
block|,
literal|0xffff
block|,
literal|0x0f30
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|init2
index|[
literal|128
index|]
init|=
block|{
literal|0x03ff
block|,
literal|0x8030
block|,
literal|0x07ff
block|,
literal|0x8130
block|,
literal|0x0bff
block|,
literal|0x8230
block|,
literal|0x0fff
block|,
literal|0x8330
block|,
literal|0x13ff
block|,
literal|0x8430
block|,
literal|0x17ff
block|,
literal|0x8530
block|,
literal|0x1bff
block|,
literal|0x8630
block|,
literal|0x1fff
block|,
literal|0x8730
block|,
literal|0x23ff
block|,
literal|0x8830
block|,
literal|0x27ff
block|,
literal|0x8930
block|,
literal|0x2bff
block|,
literal|0x8a30
block|,
literal|0x2fff
block|,
literal|0x8b30
block|,
literal|0x33ff
block|,
literal|0x8c30
block|,
literal|0x37ff
block|,
literal|0x8d30
block|,
literal|0x3bff
block|,
literal|0x8e30
block|,
literal|0x3fff
block|,
literal|0x8f30
block|,
literal|0x43ff
block|,
literal|0x8030
block|,
literal|0x47ff
block|,
literal|0x8130
block|,
literal|0x4bff
block|,
literal|0x8230
block|,
literal|0x4fff
block|,
literal|0x8330
block|,
literal|0x53ff
block|,
literal|0x8430
block|,
literal|0x57ff
block|,
literal|0x8530
block|,
literal|0x5bff
block|,
literal|0x8630
block|,
literal|0x5fff
block|,
literal|0x8730
block|,
literal|0x63ff
block|,
literal|0x8830
block|,
literal|0x67ff
block|,
literal|0x8930
block|,
literal|0x6bff
block|,
literal|0x8a30
block|,
literal|0x6fff
block|,
literal|0x8b30
block|,
literal|0x73ff
block|,
literal|0x8c30
block|,
literal|0x77ff
block|,
literal|0x8d30
block|,
literal|0x7bff
block|,
literal|0x8e30
block|,
literal|0x7fff
block|,
literal|0x8f30
block|,
literal|0x83ff
block|,
literal|0x8030
block|,
literal|0x87ff
block|,
literal|0x8130
block|,
literal|0x8bff
block|,
literal|0x8230
block|,
literal|0x8fff
block|,
literal|0x8330
block|,
literal|0x93ff
block|,
literal|0x8430
block|,
literal|0x97ff
block|,
literal|0x8530
block|,
literal|0x9bff
block|,
literal|0x8630
block|,
literal|0x9fff
block|,
literal|0x8730
block|,
literal|0xa3ff
block|,
literal|0x8830
block|,
literal|0xa7ff
block|,
literal|0x8930
block|,
literal|0xabff
block|,
literal|0x8a30
block|,
literal|0xafff
block|,
literal|0x8b30
block|,
literal|0xb3ff
block|,
literal|0x8c30
block|,
literal|0xb7ff
block|,
literal|0x8d30
block|,
literal|0xbbff
block|,
literal|0x8e30
block|,
literal|0xbfff
block|,
literal|0x8f30
block|,
literal|0xc3ff
block|,
literal|0x8030
block|,
literal|0xc7ff
block|,
literal|0x8130
block|,
literal|0xcbff
block|,
literal|0x8230
block|,
literal|0xcfff
block|,
literal|0x8330
block|,
literal|0xd3ff
block|,
literal|0x8430
block|,
literal|0xd7ff
block|,
literal|0x8530
block|,
literal|0xdbff
block|,
literal|0x8630
block|,
literal|0xdfff
block|,
literal|0x8730
block|,
literal|0xe3ff
block|,
literal|0x8830
block|,
literal|0xe7ff
block|,
literal|0x8930
block|,
literal|0xebff
block|,
literal|0x8a30
block|,
literal|0xefff
block|,
literal|0x8b30
block|,
literal|0xf3ff
block|,
literal|0x8c30
block|,
literal|0xf7ff
block|,
literal|0x8d30
block|,
literal|0xfbff
block|,
literal|0x8e30
block|,
literal|0xffff
block|,
literal|0x8f30
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|init3
index|[
literal|128
index|]
init|=
block|{
literal|0x0C10
block|,
literal|0x8470
block|,
literal|0x14FE
block|,
literal|0xB488
block|,
literal|0x167F
block|,
literal|0xA470
block|,
literal|0x18E7
block|,
literal|0x84B5
block|,
literal|0x1B6E
block|,
literal|0x842A
block|,
literal|0x1F1D
block|,
literal|0x852A
block|,
literal|0x0DA3
block|,
literal|0x8F7C
block|,
literal|0x167E
block|,
literal|0xF254
block|,
literal|0x0000
block|,
literal|0x842A
block|,
literal|0x0001
block|,
literal|0x852A
block|,
literal|0x18E6
block|,
literal|0x8BAA
block|,
literal|0x1B6D
block|,
literal|0xF234
block|,
literal|0x229F
block|,
literal|0x8429
block|,
literal|0x2746
block|,
literal|0x8529
block|,
literal|0x1F1C
block|,
literal|0x86E7
block|,
literal|0x229E
block|,
literal|0xF224
block|,
literal|0x0DA4
block|,
literal|0x8429
block|,
literal|0x2C29
block|,
literal|0x8529
block|,
literal|0x2745
block|,
literal|0x87F6
block|,
literal|0x2C28
block|,
literal|0xF254
block|,
literal|0x383B
block|,
literal|0x8428
block|,
literal|0x320F
block|,
literal|0x8528
block|,
literal|0x320E
block|,
literal|0x8F02
block|,
literal|0x1341
block|,
literal|0xF264
block|,
literal|0x3EB6
block|,
literal|0x8428
block|,
literal|0x3EB9
block|,
literal|0x8528
block|,
literal|0x383A
block|,
literal|0x8FA9
block|,
literal|0x3EB5
block|,
literal|0xF294
block|,
literal|0x3EB7
block|,
literal|0x8474
block|,
literal|0x3EBA
block|,
literal|0x8575
block|,
literal|0x3EB8
block|,
literal|0xC4C3
block|,
literal|0x3EBB
block|,
literal|0xC5C3
block|,
literal|0x0000
block|,
literal|0xA404
block|,
literal|0x0001
block|,
literal|0xA504
block|,
literal|0x141F
block|,
literal|0x8671
block|,
literal|0x14FD
block|,
literal|0x8287
block|,
literal|0x3EBC
block|,
literal|0xE610
block|,
literal|0x3EC8
block|,
literal|0x8C7B
block|,
literal|0x031A
block|,
literal|0x87E6
block|,
literal|0x3EC8
block|,
literal|0x86F7
block|,
literal|0x3EC0
block|,
literal|0x821E
block|,
literal|0x3EBE
block|,
literal|0xD208
block|,
literal|0x3EBD
block|,
literal|0x821F
block|,
literal|0x3ECA
block|,
literal|0x8386
block|,
literal|0x3EC1
block|,
literal|0x8C03
block|,
literal|0x3EC9
block|,
literal|0x831E
block|,
literal|0x3ECA
block|,
literal|0x8C4C
block|,
literal|0x3EBF
block|,
literal|0x8C55
block|,
literal|0x3EC9
block|,
literal|0xC208
block|,
literal|0x3EC4
block|,
literal|0xBC84
block|,
literal|0x3EC8
block|,
literal|0x8EAD
block|,
literal|0x3EC8
block|,
literal|0xD308
block|,
literal|0x3EC2
block|,
literal|0x8F7E
block|,
literal|0x3ECB
block|,
literal|0x8219
block|,
literal|0x3ECB
block|,
literal|0xD26E
block|,
literal|0x3EC5
block|,
literal|0x831F
block|,
literal|0x3EC6
block|,
literal|0xC308
block|,
literal|0x3EC3
block|,
literal|0xB2FF
block|,
literal|0x3EC9
block|,
literal|0x8265
block|,
literal|0x3EC9
block|,
literal|0x8319
block|,
literal|0x1342
block|,
literal|0xD36E
block|,
literal|0x3EC7
block|,
literal|0xB3FF
block|,
literal|0x0000
block|,
literal|0x8365
block|,
literal|0x1420
block|,
literal|0x9570
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|init4
index|[
literal|128
index|]
init|=
block|{
literal|0x0C10
block|,
literal|0x8470
block|,
literal|0x14FE
block|,
literal|0xB488
block|,
literal|0x167F
block|,
literal|0xA470
block|,
literal|0x18E7
block|,
literal|0x84B5
block|,
literal|0x1B6E
block|,
literal|0x842A
block|,
literal|0x1F1D
block|,
literal|0x852A
block|,
literal|0x0DA3
block|,
literal|0x0F7C
block|,
literal|0x167E
block|,
literal|0x7254
block|,
literal|0x0000
block|,
literal|0x842A
block|,
literal|0x0001
block|,
literal|0x852A
block|,
literal|0x18E6
block|,
literal|0x0BAA
block|,
literal|0x1B6D
block|,
literal|0x7234
block|,
literal|0x229F
block|,
literal|0x8429
block|,
literal|0x2746
block|,
literal|0x8529
block|,
literal|0x1F1C
block|,
literal|0x06E7
block|,
literal|0x229E
block|,
literal|0x7224
block|,
literal|0x0DA4
block|,
literal|0x8429
block|,
literal|0x2C29
block|,
literal|0x8529
block|,
literal|0x2745
block|,
literal|0x07F6
block|,
literal|0x2C28
block|,
literal|0x7254
block|,
literal|0x383B
block|,
literal|0x8428
block|,
literal|0x320F
block|,
literal|0x8528
block|,
literal|0x320E
block|,
literal|0x0F02
block|,
literal|0x1341
block|,
literal|0x7264
block|,
literal|0x3EB6
block|,
literal|0x8428
block|,
literal|0x3EB9
block|,
literal|0x8528
block|,
literal|0x383A
block|,
literal|0x0FA9
block|,
literal|0x3EB5
block|,
literal|0x7294
block|,
literal|0x3EB7
block|,
literal|0x8474
block|,
literal|0x3EBA
block|,
literal|0x8575
block|,
literal|0x3EB8
block|,
literal|0x44C3
block|,
literal|0x3EBB
block|,
literal|0x45C3
block|,
literal|0x0000
block|,
literal|0xA404
block|,
literal|0x0001
block|,
literal|0xA504
block|,
literal|0x141F
block|,
literal|0x0671
block|,
literal|0x14FD
block|,
literal|0x0287
block|,
literal|0x3EBC
block|,
literal|0xE610
block|,
literal|0x3EC8
block|,
literal|0x0C7B
block|,
literal|0x031A
block|,
literal|0x07E6
block|,
literal|0x3EC8
block|,
literal|0x86F7
block|,
literal|0x3EC0
block|,
literal|0x821E
block|,
literal|0x3EBE
block|,
literal|0xD208
block|,
literal|0x3EBD
block|,
literal|0x021F
block|,
literal|0x3ECA
block|,
literal|0x0386
block|,
literal|0x3EC1
block|,
literal|0x0C03
block|,
literal|0x3EC9
block|,
literal|0x031E
block|,
literal|0x3ECA
block|,
literal|0x8C4C
block|,
literal|0x3EBF
block|,
literal|0x0C55
block|,
literal|0x3EC9
block|,
literal|0xC208
block|,
literal|0x3EC4
block|,
literal|0xBC84
block|,
literal|0x3EC8
block|,
literal|0x0EAD
block|,
literal|0x3EC8
block|,
literal|0xD308
block|,
literal|0x3EC2
block|,
literal|0x8F7E
block|,
literal|0x3ECB
block|,
literal|0x0219
block|,
literal|0x3ECB
block|,
literal|0xD26E
block|,
literal|0x3EC5
block|,
literal|0x031F
block|,
literal|0x3EC6
block|,
literal|0xC308
block|,
literal|0x3EC3
block|,
literal|0x32FF
block|,
literal|0x3EC9
block|,
literal|0x0265
block|,
literal|0x3EC9
block|,
literal|0x8319
block|,
literal|0x1342
block|,
literal|0xD36E
block|,
literal|0x3EC7
block|,
literal|0x33FF
block|,
literal|0x0000
block|,
literal|0x8365
block|,
literal|0x1420
block|,
literal|0x9570
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* send initialization arrays to start up */
end_comment

begin_function
specifier|static
name|void
name|awe_init_array
parameter_list|(
name|void
parameter_list|)
block|{
name|awe_send_array
argument_list|(
name|init1
argument_list|)
expr_stmt|;
name|awe_wait
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|awe_send_array
argument_list|(
name|init2
argument_list|)
expr_stmt|;
name|awe_send_array
argument_list|(
name|init3
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_HWCF4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_HWCF5
argument_list|,
literal|0x83
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_HWCF6
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|awe_send_array
argument_list|(
name|init4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* send an initialization array */
end_comment

begin_function
specifier|static
name|void
name|awe_send_array
parameter_list|(
name|unsigned
name|short
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|short
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_VOICES
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|awe_poke
argument_list|(
name|AWE_INIT1
argument_list|(
name|i
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_VOICES
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|awe_poke
argument_list|(
name|AWE_INIT2
argument_list|(
name|i
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_VOICES
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|awe_poke
argument_list|(
name|AWE_INIT3
argument_list|(
name|i
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_VOICES
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|awe_poke
argument_list|(
name|AWE_INIT4
argument_list|(
name|i
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set up awe32 channels to some known state.  */
end_comment

begin_function
specifier|static
name|void
name|awe_tweak
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Set the envelope engine parameters to the "default" values for 	   simply playing back unarticulated audio at 44.1kHz.  Set all 	   of the channels: */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_VOICES
condition|;
name|i
operator|++
control|)
block|{
name|awe_poke
argument_list|(
name|AWE_ENVVOL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ENVVAL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUS
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x7F7F
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ATKHLDV
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x7F7F
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_LFO1VAL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ATKHLD
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x7F7F
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_LFO2VAL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_IP
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0xE000
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_IFATN
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0xFF00
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_PEFE
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_FMMOD
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_TREMFRQ
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x0010
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_FM2FRQ2
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x0010
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *  initializes the FM section of AWE32  */
end_comment

begin_function
specifier|static
name|void
name|awe_init_fm
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|AWE_ALWAYS_INIT_FM
comment|/* if no extended memory is on board.. */
if|if
condition|(
name|awe_mem_size
operator|<=
literal|0
condition|)
return|return;
endif|#
directive|endif
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: initializing FM\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the last two channels for DRAM refresh and producing 	   the reverb and chorus effects for Yamaha OPL-3 synthesizer */
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x0080
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0xFFFFFFE0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0xFFFFFFE8
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PTRX
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x00FFFF00
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CPF
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x00FFFFE3
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x0080
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x00FFFFE0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0xFFFFFFE8
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PTRX
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x00FFFF00
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CPF
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x00FFFFE3
argument_list|)
expr_stmt|;
comment|/* Timing loop */
comment|/* PTRX is 32 bit long but do not write to the MS byte */
name|awe_poke
argument_list|(
name|AWE_PTRX
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|inw
argument_list|(
name|awe_base
operator|-
literal|0x620
operator|+
name|Pointer
argument_list|)
operator|&
literal|0x1000
operator|)
condition|)
empty_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|awe_base
operator|-
literal|0x620
operator|+
name|Pointer
argument_list|)
operator|&
literal|0x1000
condition|)
empty_stmt|;
comment|/* now write the MS byte of PTRX */
name|OUTW
argument_list|(
literal|0x4828
argument_list|,
name|awe_base
operator|-
literal|0x620
operator|+
name|Data0
operator|+
literal|0x002
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_IFATN
argument_list|(
literal|28
argument_list|)
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x8000FFFF
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x8000FFFF
argument_list|)
expr_stmt|;
comment|/* change maximum channels to 30 */
name|awe_max_voices
operator|=
name|AWE_NORMAL_VOICES
expr_stmt|;
name|awe_info
operator|.
name|nr_voices
operator|=
name|awe_max_voices
expr_stmt|;
name|voice_alloc
operator|->
name|max_voice
operator|=
name|awe_max_voices
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  AWE32 DRAM access routines  */
end_comment

begin_comment
comment|/* open DRAM write accessing mode */
end_comment

begin_function
specifier|static
name|int
name|awe_open_dram_for_write
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* use all channels for DMA transfer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_NORMAL_VOICES
condition|;
name|i
operator|++
control|)
block|{
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CVCF
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PTRX
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x40000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CPF
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x40000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x06000000
argument_list|)
expr_stmt|;
block|}
comment|/* point channels 31& 32 to ROM samples for DRAM refresh */
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x1d8
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x1e0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x1d8
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x1d8
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x1e0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x1d8
argument_list|)
expr_stmt|;
comment|/* if full bit is on, not ready to write on */
if|if
condition|(
name|awe_peek_dw
argument_list|(
name|AWE_SMALW
argument_list|)
operator|&
literal|0x80000000
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_NORMAL_VOICES
condition|;
name|i
operator|++
control|)
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
comment|/* set address to write */
name|awe_poke_dw
argument_list|(
name|AWE_SMALW
argument_list|,
name|offset
operator|+
name|AWE_DRAM_OFFSET
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* open DRAM for RAM size detection */
end_comment

begin_function
specifier|static
name|void
name|awe_open_dram_for_check
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|unsigned
name|long
name|scratch
decl_stmt|;
name|awe_poke
argument_list|(
name|AWE_HWCF2
argument_list|,
literal|0x0020
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|AWE_NORMAL_VOICES
condition|;
name|k
operator|++
control|)
block|{
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|k
argument_list|)
argument_list|,
literal|0x0080
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
name|k
argument_list|)
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CVCF
argument_list|(
name|k
argument_list|)
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PTRX
argument_list|(
name|k
argument_list|)
argument_list|,
literal|0x40000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CPF
argument_list|(
name|k
argument_list|)
argument_list|,
literal|0x40000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
name|k
argument_list|)
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
name|k
argument_list|)
argument_list|,
literal|0x00000000
argument_list|)
expr_stmt|;
name|scratch
operator|=
operator|(
operator|(
operator|(
name|k
operator|&
literal|1
operator|)
operator|<<
literal|9
operator|)
operator|+
literal|0x400
operator|)
expr_stmt|;
name|scratch
operator|=
name|scratch
operator|<<
literal|16
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|k
argument_list|)
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* close dram access */
end_comment

begin_function
specifier|static
name|void
name|awe_close_dram
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* wait until FULL bit in SMAxW register be false */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|awe_peek_dw
argument_list|(
name|AWE_SMALW
argument_list|)
operator|&
literal|0x80000000
operator|)
condition|)
break|break;
name|awe_wait
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_NORMAL_VOICES
condition|;
name|i
operator|++
control|)
block|{
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x807F
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_CHECKSUM_MEMORY
end_ifdef

begin_comment
comment|/* open DRAM read accessing mode */
end_comment

begin_function
specifier|static
name|int
name|awe_open_dram_for_read
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* use all channels for DMA transfer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_NORMAL_VOICES
condition|;
name|i
operator|++
control|)
block|{
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CVCF
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PTRX
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x40000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CPF
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x40000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x04000000
argument_list|)
expr_stmt|;
block|}
comment|/* point channels 31& 32 to ROM samples for DRAM refresh */
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x1d8
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x1e0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x1d8
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x1d8
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x1e0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x1d8
argument_list|)
expr_stmt|;
comment|/* if empty flag is on, not ready to read */
if|if
condition|(
name|awe_peek_dw
argument_list|(
name|AWE_SMALR
argument_list|)
operator|&
literal|0x80000000
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_NORMAL_VOICES
condition|;
name|i
operator|++
control|)
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
comment|/* set address to read */
name|awe_poke_dw
argument_list|(
name|AWE_SMALR
argument_list|,
name|offset
operator|+
name|AWE_DRAM_OFFSET
argument_list|)
expr_stmt|;
comment|/* drop stale data */
name|awe_peek
argument_list|(
name|AWE_SMLD
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* close dram access for read */
end_comment

begin_function
specifier|static
name|void
name|awe_close_dram_for_read
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* wait until FULL bit in SMAxW register be false */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|awe_peek_dw
argument_list|(
name|AWE_SMALR
argument_list|)
operator|&
literal|0x80000000
operator|)
condition|)
break|break;
name|awe_wait
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_NORMAL_VOICES
condition|;
name|i
operator|++
control|)
block|{
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x807F
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AWE_CHECKSUM_MEMORY */
end_comment

begin_comment
comment|/* write a word data */
end_comment

begin_function
specifier|static
name|void
name|awe_write_dram
parameter_list|(
name|unsigned
name|short
name|c
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
comment|/* wait until FULL bit in SMAxW register be false */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|10000
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|awe_peek_dw
argument_list|(
name|AWE_SMALW
argument_list|)
operator|&
literal|0x80000000
operator|)
condition|)
break|break;
name|awe_wait
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|awe_poke
argument_list|(
name|AWE_SMLD
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*================================================================  * detect presence of AWE32 and check memory size  *================================================================*/
end_comment

begin_function
specifier|static
name|int
name|awe_detect
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|AWE_DEFAULT_BASE_ADDR
name|awe_base
operator|=
name|AWE_DEFAULT_BASE_ADDR
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|awe_peek
argument_list|(
name|AWE_U1
argument_list|)
operator|&
literal|0x000F
operator|)
operator|==
literal|0x000C
operator|)
operator|&&
operator|(
operator|(
name|awe_peek
argument_list|(
name|AWE_HWCF1
argument_list|)
operator|&
literal|0x007E
operator|)
operator|==
literal|0x0058
operator|)
operator|&&
operator|(
operator|(
name|awe_peek
argument_list|(
name|AWE_HWCF2
argument_list|)
operator|&
literal|0x0003
operator|)
operator|==
literal|0x0003
operator|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|awe_base
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|awe_base
operator|=
literal|0x620
init|;
name|awe_base
operator|<=
literal|0x680
condition|;
name|awe_base
operator|+=
literal|0x20
control|)
block|{
if|if
condition|(
operator|(
name|awe_peek
argument_list|(
name|AWE_U1
argument_list|)
operator|&
literal|0x000F
operator|)
operator|!=
literal|0x000C
condition|)
continue|continue;
if|if
condition|(
operator|(
name|awe_peek
argument_list|(
name|AWE_HWCF1
argument_list|)
operator|&
literal|0x007E
operator|)
operator|!=
literal|0x0058
condition|)
continue|continue;
if|if
condition|(
operator|(
name|awe_peek
argument_list|(
name|AWE_HWCF2
argument_list|)
operator|&
literal|0x0003
operator|)
operator|!=
literal|0x0003
condition|)
continue|continue;
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32 found at %x\n"
argument_list|,
name|awe_base
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|FATALERR
argument_list|(
name|printk
argument_list|(
literal|"AWE32 not found\n"
argument_list|)
argument_list|)
expr_stmt|;
name|awe_base
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*================================================================  * check dram size on AWE board  *================================================================*/
end_comment

begin_function
specifier|static
name|int
name|awe_check_dram
parameter_list|(
name|void
parameter_list|)
block|{
name|awe_open_dram_for_check
argument_list|()
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_SMALW
argument_list|,
literal|0x00200000
argument_list|)
expr_stmt|;
comment|/* DRAM start address */
name|awe_poke
argument_list|(
name|AWE_SMLD
argument_list|,
literal|0x1234
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_SMLD
argument_list|,
literal|0x7777
argument_list|)
expr_stmt|;
name|awe_mem_size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|awe_mem_size
operator|<
literal|28
operator|*
literal|1024
condition|)
block|{
comment|/* 28 MB is max onboard memory */
name|awe_wait
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_SMALR
argument_list|,
literal|0x00200000
argument_list|)
expr_stmt|;
comment|/* Address for reading */
name|awe_peek
argument_list|(
name|AWE_SMLD
argument_list|)
expr_stmt|;
comment|/* Discard stale data  */
if|if
condition|(
name|awe_peek
argument_list|(
name|AWE_SMLD
argument_list|)
operator|!=
literal|0x1234
condition|)
break|break;
if|if
condition|(
name|awe_peek
argument_list|(
name|AWE_SMLD
argument_list|)
operator|!=
literal|0x7777
condition|)
break|break;
name|awe_mem_size
operator|+=
literal|32
expr_stmt|;
comment|/* Address for writing */
name|awe_poke_dw
argument_list|(
name|AWE_SMALW
argument_list|,
literal|0x00200000
operator|+
name|awe_mem_size
operator|*
literal|512L
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_SMLD
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
block|}
name|awe_close_dram
argument_list|()
expr_stmt|;
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: %d Kbytes memory detected\n"
argument_list|,
operator|(
name|int
operator|)
name|awe_mem_size
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AWE_DEFAULT_MEM_SIZE
if|if
condition|(
name|awe_mem_size
operator|==
literal|0
condition|)
name|awe_mem_size
operator|=
name|AWE_DEFAULT_MEM_SIZE
expr_stmt|;
endif|#
directive|endif
comment|/* convert to Kbytes */
name|awe_mem_size
operator|*=
literal|1024
expr_stmt|;
return|return
name|awe_mem_size
return|;
block|}
end_function

begin_comment
comment|/*================================================================  * chorus and reverb controls  *================================================================*/
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|ChorusEffects
index|[
literal|24
index|]
init|=
block|{
literal|0xE600
block|,
literal|0x03F6
block|,
literal|0xBC2C
block|,
literal|0xE608
block|,
literal|0x031A
block|,
literal|0xBC6E
block|,
literal|0xE610
block|,
literal|0x031A
block|,
literal|0xBC84
block|,
literal|0xE620
block|,
literal|0x0269
block|,
literal|0xBC6E
block|,
literal|0xE680
block|,
literal|0x04D3
block|,
literal|0xBCA6
block|,
literal|0xE6E0
block|,
literal|0x044E
block|,
literal|0xBC37
block|,
literal|0xE600
block|,
literal|0x0B06
block|,
literal|0xBC00
block|,
literal|0xE6C0
block|,
literal|0x0B06
block|,
literal|0xBC00
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|ChorusEffects2
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x006D
block|,
literal|0x8000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x017C
block|,
literal|0x8000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0083
block|,
literal|0x8000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x017C
block|,
literal|0x8000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x005B
block|,
literal|0x8000
block|,
literal|0x0000
block|,
literal|0x0000
block|,
literal|0x0026
block|,
literal|0x8000
block|,
literal|0x0000
block|,
literal|0x6E000
block|,
literal|0x0083
block|,
literal|0x8000
block|,
literal|0x0000
block|,
literal|0x6E000
block|,
literal|0x0083
block|,
literal|0x8000
block|,
literal|0x0000
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|ChorusCommand
index|[
literal|14
index|]
init|=
block|{
literal|0x69
block|,
literal|0xA20
block|,
literal|0x6C
block|,
literal|0xA20
block|,
literal|0x63
block|,
literal|0xA22
block|,
literal|0x29
block|,
literal|0xA20
block|,
literal|0x2A
block|,
literal|0xA20
block|,
literal|0x2D
block|,
literal|0xA20
block|,
literal|0x2E
block|,
literal|0xA20
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|ReverbEffects
index|[
literal|224
index|]
init|=
block|{
comment|/* Room 1 */
literal|0xB488
block|,
literal|0xA450
block|,
literal|0x9550
block|,
literal|0x84B5
block|,
literal|0x383A
block|,
literal|0x3EB5
block|,
literal|0x72F4
block|,
literal|0x72A4
block|,
literal|0x7254
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x4416
block|,
literal|0x4516
block|,
literal|0xA490
block|,
literal|0xA590
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8428
block|,
literal|0x8528
block|,
literal|0x8428
block|,
literal|0x8528
block|,
comment|/* Room 2 */
literal|0xB488
block|,
literal|0xA458
block|,
literal|0x9558
block|,
literal|0x84B5
block|,
literal|0x383A
block|,
literal|0x3EB5
block|,
literal|0x7284
block|,
literal|0x7254
block|,
literal|0x7224
block|,
literal|0x7224
block|,
literal|0x7254
block|,
literal|0x7284
block|,
literal|0x4448
block|,
literal|0x4548
block|,
literal|0xA440
block|,
literal|0xA540
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8428
block|,
literal|0x8528
block|,
literal|0x8428
block|,
literal|0x8528
block|,
comment|/* Room 3 */
literal|0xB488
block|,
literal|0xA460
block|,
literal|0x9560
block|,
literal|0x84B5
block|,
literal|0x383A
block|,
literal|0x3EB5
block|,
literal|0x7284
block|,
literal|0x7254
block|,
literal|0x7224
block|,
literal|0x7224
block|,
literal|0x7254
block|,
literal|0x7284
block|,
literal|0x4416
block|,
literal|0x4516
block|,
literal|0xA490
block|,
literal|0xA590
block|,
literal|0x842C
block|,
literal|0x852C
block|,
literal|0x842C
block|,
literal|0x852C
block|,
literal|0x842B
block|,
literal|0x852B
block|,
literal|0x842B
block|,
literal|0x852B
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x842A
block|,
literal|0x852A
block|,
comment|/* Hall 1 */
literal|0xB488
block|,
literal|0xA470
block|,
literal|0x9570
block|,
literal|0x84B5
block|,
literal|0x383A
block|,
literal|0x3EB5
block|,
literal|0x7284
block|,
literal|0x7254
block|,
literal|0x7224
block|,
literal|0x7224
block|,
literal|0x7254
block|,
literal|0x7284
block|,
literal|0x4448
block|,
literal|0x4548
block|,
literal|0xA440
block|,
literal|0xA540
block|,
literal|0x842B
block|,
literal|0x852B
block|,
literal|0x842B
block|,
literal|0x852B
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8429
block|,
literal|0x8529
block|,
comment|/* Hall 2 */
literal|0xB488
block|,
literal|0xA470
block|,
literal|0x9570
block|,
literal|0x84B5
block|,
literal|0x383A
block|,
literal|0x3EB5
block|,
literal|0x7254
block|,
literal|0x7234
block|,
literal|0x7224
block|,
literal|0x7254
block|,
literal|0x7264
block|,
literal|0x7294
block|,
literal|0x44C3
block|,
literal|0x45C3
block|,
literal|0xA404
block|,
literal|0xA504
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8428
block|,
literal|0x8528
block|,
literal|0x8428
block|,
literal|0x8528
block|,
comment|/* Plate */
literal|0xB4FF
block|,
literal|0xA470
block|,
literal|0x9570
block|,
literal|0x84B5
block|,
literal|0x383A
block|,
literal|0x3EB5
block|,
literal|0x7234
block|,
literal|0x7234
block|,
literal|0x7234
block|,
literal|0x7234
block|,
literal|0x7234
block|,
literal|0x7234
block|,
literal|0x4448
block|,
literal|0x4548
block|,
literal|0xA440
block|,
literal|0xA540
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8428
block|,
literal|0x8528
block|,
literal|0x8428
block|,
literal|0x8528
block|,
comment|/* Delay */
literal|0xB4FF
block|,
literal|0xA470
block|,
literal|0x9500
block|,
literal|0x84B5
block|,
literal|0x333A
block|,
literal|0x39B5
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x72F4
block|,
literal|0x4400
block|,
literal|0x4500
block|,
literal|0xA4FF
block|,
literal|0xA5FF
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
comment|/* Panning Delay */
literal|0xB4FF
block|,
literal|0xA490
block|,
literal|0x9590
block|,
literal|0x8474
block|,
literal|0x333A
block|,
literal|0x39B5
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x72F4
block|,
literal|0x4400
block|,
literal|0x4500
block|,
literal|0xA4FF
block|,
literal|0xA5FF
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|ReverbCommand
index|[
literal|56
index|]
init|=
block|{
literal|0x43
block|,
literal|0xA20
block|,
literal|0x45
block|,
literal|0xA20
block|,
literal|0x7F
block|,
literal|0xA22
block|,
literal|0x47
block|,
literal|0xA20
block|,
literal|0x54
block|,
literal|0xA22
block|,
literal|0x56
block|,
literal|0xA22
block|,
literal|0x4F
block|,
literal|0xA20
block|,
literal|0x57
block|,
literal|0xA20
block|,
literal|0x5F
block|,
literal|0xA20
block|,
literal|0x47
block|,
literal|0xA22
block|,
literal|0x4F
block|,
literal|0xA22
block|,
literal|0x57
block|,
literal|0xA22
block|,
literal|0x5D
block|,
literal|0xA22
block|,
literal|0x5F
block|,
literal|0xA22
block|,
literal|0x61
block|,
literal|0xA20
block|,
literal|0x63
block|,
literal|0xA20
block|,
literal|0x49
block|,
literal|0xA20
block|,
literal|0x4B
block|,
literal|0xA20
block|,
literal|0x51
block|,
literal|0xA20
block|,
literal|0x53
block|,
literal|0xA20
block|,
literal|0x59
block|,
literal|0xA20
block|,
literal|0x5B
block|,
literal|0xA20
block|,
literal|0x41
block|,
literal|0xA22
block|,
literal|0x43
block|,
literal|0xA22
block|,
literal|0x49
block|,
literal|0xA22
block|,
literal|0x4B
block|,
literal|0xA22
block|,
literal|0x51
block|,
literal|0xA22
block|,
literal|0x53
block|,
literal|0xA22
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|awe_set_chorus_mode
parameter_list|(
name|int
name|effect
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|DECL_INTR_FLAGS
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|3
condition|;
name|k
operator|++
control|)
name|awe_poke
argument_list|(
name|ChorusCommand
index|[
name|k
operator|*
literal|2
index|]
argument_list|,
name|ChorusCommand
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|,
name|ChorusEffects
index|[
name|k
operator|+
name|effect
operator|*
literal|3
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
name|awe_poke_dw
argument_list|(
name|ChorusCommand
index|[
literal|6
operator|+
name|k
operator|*
literal|2
index|]
argument_list|,
name|ChorusCommand
index|[
literal|6
operator|+
name|k
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|,
name|ChorusEffects2
index|[
name|k
operator|+
name|effect
operator|*
literal|4
index|]
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awe_set_reverb_mode
parameter_list|(
name|int
name|effect
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|DECL_INTR_FLAGS
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|28
condition|;
name|k
operator|++
control|)
name|awe_poke
argument_list|(
name|ReverbCommand
index|[
name|k
operator|*
literal|2
index|]
argument_list|,
name|ReverbCommand
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|,
name|ReverbEffects
index|[
name|k
operator|+
name|effect
operator|*
literal|28
index|]
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_AWE32_SYNTH */
end_comment

end_unit

