begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|_PAS2_CARD_C_
end_define

begin_define
define|#
directive|define
name|SND_SA_INTERRUPT
end_define

begin_comment
comment|/*  * sound/pas2_card.c  *   * Detection routine for the Pro Audio Spectrum cards.  *   * Copyright by Hannu Savolainen 1993  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   */
end_comment

begin_include
include|#
directive|include
file|"sound_config.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIGURE_SOUNDCARD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EXCLUDE_PAS
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEFINE_TRANSLATIONS
end_define

begin_include
include|#
directive|include
file|"pas.h"
end_include

begin_comment
comment|/*  * The Address Translation code is used to convert I/O register addresses to  * be relative to the given base -register  */
end_comment

begin_decl_stmt
name|int
name|translat_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pas_intr_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pas_irq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pas_model
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pas_model_names
index|[]
init|=
block|{
literal|""
block|,
literal|"Pro AudioSpectrum+"
block|,
literal|"CDPC"
block|,
literal|"Pro AudioSpectrum 16"
block|,
literal|"Pro AudioSpectrum 16D"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pas_read() and pas_write() are equivalents of INB() and OUTB() */
end_comment

begin_comment
comment|/* These routines perform the I/O address translation required */
end_comment

begin_comment
comment|/* to support other than the default base address */
end_comment

begin_function
name|unsigned
name|char
name|pas_read
parameter_list|(
name|int
name|ioaddr
parameter_list|)
block|{
return|return
name|INB
argument_list|(
name|ioaddr
operator|^
name|translat_code
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|pas_write
parameter_list|(
name|unsigned
name|char
name|data
parameter_list|,
name|int
name|ioaddr
parameter_list|)
block|{
name|OUTB
argument_list|(
name|data
argument_list|,
name|ioaddr
operator|^
name|translat_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pas2_msg
parameter_list|(
name|char
modifier|*
name|foo
parameter_list|)
block|{
name|printk
argument_list|(
literal|"    PAS2: %s.\n"
argument_list|,
name|foo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************* Begin of the Interrupt Handler ********************/
end_comment

begin_function
name|void
name|pasintr
parameter_list|(
name|int
name|unused
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|pas_read
argument_list|(
name|INTERRUPT_STATUS
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
name|status
argument_list|,
name|INTERRUPT_STATUS
argument_list|)
expr_stmt|;
comment|/* Clear interrupt */
if|if
condition|(
name|status
operator|&
name|I_S_PCM_SAMPLE_BUFFER_IRQ
condition|)
block|{
ifndef|#
directive|ifndef
name|EXCLUDE_AUDIO
name|pas_pcm_interrupt
argument_list|(
name|status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|&=
operator|~
name|I_S_PCM_SAMPLE_BUFFER_IRQ
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|I_S_MIDI_IRQ
condition|)
block|{
ifndef|#
directive|ifndef
name|EXCLUDE_MIDI
ifdef|#
directive|ifdef
name|EXCLUDE_PRO_MIDI
name|pas_midi_interrupt
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|status
operator|&=
operator|~
name|I_S_MIDI_IRQ
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|pas_set_intr
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|mask
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|pas_intr_mask
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|snd_set_irq_handler
argument_list|(
name|pas_irq
argument_list|,
name|pasintr
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|err
return|;
block|}
name|pas_intr_mask
operator||=
name|mask
expr_stmt|;
name|pas_write
argument_list|(
name|pas_intr_mask
argument_list|,
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pas_remove_intr
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mask
condition|)
return|return
literal|0
return|;
name|pas_intr_mask
operator|&=
operator|~
name|mask
expr_stmt|;
name|pas_write
argument_list|(
name|pas_intr_mask
argument_list|,
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pas_intr_mask
condition|)
block|{
name|snd_release_irq
argument_list|(
name|pas_irq
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************* End of the Interrupt handler **********************/
end_comment

begin_comment
comment|/******************* Begin of the Initialization Code ******************/
end_comment

begin_function
name|int
name|config_pas_hw
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|char
name|ok
init|=
literal|1
decl_stmt|;
name|pas_irq
operator|=
name|hw_config
operator|->
name|irq
expr_stmt|;
name|pas_write
argument_list|(
literal|0x00
argument_list|,
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
literal|0x36
argument_list|,
name|SAMPLE_COUNTER_CONTROL
argument_list|)
expr_stmt|;
comment|/* Local timer control 						 * register */
name|pas_write
argument_list|(
literal|0x36
argument_list|,
name|SAMPLE_RATE_TIMER
argument_list|)
expr_stmt|;
comment|/* Sample rate timer (16 bit) */
name|pas_write
argument_list|(
literal|0
argument_list|,
name|SAMPLE_RATE_TIMER
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
literal|0x74
argument_list|,
name|SAMPLE_COUNTER_CONTROL
argument_list|)
expr_stmt|;
comment|/* Local timer control 						 * register */
name|pas_write
argument_list|(
literal|0x74
argument_list|,
name|SAMPLE_BUFFER_COUNTER
argument_list|)
expr_stmt|;
comment|/* Sample count register (16 						 * bit) */
name|pas_write
argument_list|(
literal|0
argument_list|,
name|SAMPLE_BUFFER_COUNTER
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
name|F_F_PCM_BUFFER_COUNTER
operator||
name|F_F_PCM_RATE_COUNTER
operator||
name|F_F_MIXER_UNMUTE
operator||
literal|1
argument_list|,
name|FILTER_FREQUENCY
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
name|P_C_PCM_DMA_ENABLE
operator||
name|P_C_PCM_MONO
operator||
name|P_C_PCM_DAC_MODE
operator||
name|P_C_MIXER_CROSS_L_TO_L
operator||
name|P_C_MIXER_CROSS_R_TO_R
argument_list|,
name|PCM_CONTROL
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
name|S_M_PCM_RESET
operator||
name|S_M_FM_RESET
operator||
name|S_M_SB_RESET
operator||
name|S_M_MIXER_RESET
comment|/* | S_M_OPL3_DUAL_MONO */
argument_list|,
name|SERIAL_MIXER
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
name|I_C_1_BOOT_RESET_ENABLE
argument_list|,
name|IO_CONFIGURATION_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pas_irq
operator|<
literal|0
operator|||
name|pas_irq
operator|>
literal|15
condition|)
block|{
name|printk
argument_list|(
literal|"PAS2: Invalid IRQ %d"
argument_list|,
name|pas_irq
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pas_write
argument_list|(
name|I_C_3_PCM_IRQ_translate
index|[
name|pas_irq
index|]
argument_list|,
name|IO_CONFIGURATION_3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|I_C_3_PCM_IRQ_translate
index|[
name|pas_irq
index|]
condition|)
block|{
name|printk
argument_list|(
literal|"PAS2: Invalid IRQ %d"
argument_list|,
name|pas_irq
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw_config
operator|->
name|dma
operator|<
literal|0
operator|||
name|hw_config
operator|->
name|dma
operator|>
literal|7
condition|)
block|{
name|printk
argument_list|(
literal|"PAS2: Invalid DMA selection %d"
argument_list|,
name|hw_config
operator|->
name|dma
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pas_write
argument_list|(
name|I_C_2_PCM_DMA_translate
index|[
name|hw_config
operator|->
name|dma
index|]
argument_list|,
name|IO_CONFIGURATION_2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|I_C_2_PCM_DMA_translate
index|[
name|hw_config
operator|->
name|dma
index|]
condition|)
block|{
name|printk
argument_list|(
literal|"PAS2: Invalid DMA selection %d"
argument_list|,
name|hw_config
operator|->
name|dma
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/*  * This fixes the timing problems of the PAS due to the Symphony chipset  * as per Media Vision.  Only define this if your PAS doesn't work correctly.  */
ifdef|#
directive|ifdef
name|SYMPHONY_PAS
name|OUTB
argument_list|(
literal|0x05
argument_list|,
literal|0xa8
argument_list|)
expr_stmt|;
name|OUTB
argument_list|(
literal|0x60
argument_list|,
literal|0xa9
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BROKEN_BUS_CLOCK
name|pas_write
argument_list|(
name|S_C_1_PCS_ENABLE
operator||
name|S_C_1_PCS_STEREO
operator||
name|S_C_1_PCS_REALSOUND
operator||
name|S_C_1_FM_EMULATE_CLOCK
argument_list|,
name|SYSTEM_CONFIGURATION_1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* pas_write(S_C_1_PCS_ENABLE, SYSTEM_CONFIGURATION_1);     */
name|pas_write
argument_list|(
name|S_C_1_PCS_ENABLE
operator||
name|S_C_1_PCS_STEREO
operator||
name|S_C_1_PCS_REALSOUND
argument_list|,
name|SYSTEM_CONFIGURATION_1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pas_write
argument_list|(
literal|0x18
argument_list|,
name|SYSTEM_CONFIGURATION_3
argument_list|)
expr_stmt|;
comment|/* ??? */
name|pas_write
argument_list|(
name|F_F_MIXER_UNMUTE
operator||
literal|0x01
argument_list|,
name|FILTER_FREQUENCY
argument_list|)
expr_stmt|;
comment|/* Sets mute off and 								 * selects filter rate 								 * of 17.897 kHz */
if|if
condition|(
name|pas_model
operator|==
name|PAS_16
operator|||
name|pas_model
operator|==
name|PAS_16D
condition|)
name|pas_write
argument_list|(
literal|8
argument_list|,
name|PRESCALE_DIVIDER
argument_list|)
expr_stmt|;
else|else
name|pas_write
argument_list|(
literal|0
argument_list|,
name|PRESCALE_DIVIDER
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
name|P_M_MV508_ADDRESS
operator||
literal|5
argument_list|,
name|PARALLEL_MIXER
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
literal|5
argument_list|,
name|PARALLEL_MIXER
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EXCLUDE_SB_EMULATION
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|EXCLUDE_SB
argument_list|)
block|{
name|struct
name|address_info
modifier|*
name|sb_config
decl_stmt|;
if|if
condition|(
operator|(
name|sb_config
operator|=
name|sound_getconf
argument_list|(
name|SNDCARD_SB
argument_list|)
operator|)
condition|)
block|{
name|unsigned
name|char
name|irq_dma
decl_stmt|;
comment|/* Turn on Sound Blaster compatibility */
comment|/* bit 1 = SB emulation */
comment|/* bit 0 = MPU401 emulation (CDPC only :-( ) */
name|pas_write
argument_list|(
literal|0x02
argument_list|,
name|COMPATIBILITY_ENABLE
argument_list|)
expr_stmt|;
comment|/* "Emulation address"         */
name|pas_write
argument_list|(
operator|(
name|sb_config
operator|->
name|io_base
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|,
name|EMULATION_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|E_C_SB_DMA_translate
index|[
name|sb_config
operator|->
name|dma
index|]
condition|)
name|printk
argument_list|(
literal|"\n\nPAS16 Warning: Invalid SB DMA %d\n\n"
argument_list|,
name|sb_config
operator|->
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|E_C_SB_IRQ_translate
index|[
name|sb_config
operator|->
name|irq
index|]
condition|)
name|printk
argument_list|(
literal|"\n\nPAS16 Warning: Invalid SB IRQ %d\n\n"
argument_list|,
name|sb_config
operator|->
name|irq
argument_list|)
expr_stmt|;
name|irq_dma
operator|=
name|E_C_SB_DMA_translate
index|[
name|sb_config
operator|->
name|dma
index|]
operator||
name|E_C_SB_IRQ_translate
index|[
name|sb_config
operator|->
name|irq
index|]
expr_stmt|;
name|pas_write
argument_list|(
name|irq_dma
argument_list|,
name|EMULATION_CONFIGURATION
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|ok
condition|)
name|pas2_msg
argument_list|(
literal|"Driver not enabled"
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_function
name|int
name|detect_pas_hw
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|unsigned
name|char
name|board_id
decl_stmt|,
name|foo
decl_stmt|;
comment|/*    * WARNING: Setting an option like W:1 or so that disables warm boot reset    * of the card will screw up this detect code something fierce. Adding code    * to handle this means possibly interfering with other cards on the bus if    * you have something on base port 0x388. SO be forewarned.    */
name|OUTB
argument_list|(
literal|0xBC
argument_list|,
name|MASTER_DECODE
argument_list|)
expr_stmt|;
comment|/* Talk to first board */
name|OUTB
argument_list|(
name|hw_config
operator|->
name|io_base
operator|>>
literal|2
argument_list|,
name|MASTER_DECODE
argument_list|)
expr_stmt|;
comment|/* Set base address */
name|translat_code
operator|=
name|PAS_DEFAULT_BASE
operator|^
name|hw_config
operator|->
name|io_base
expr_stmt|;
name|pas_write
argument_list|(
literal|1
argument_list|,
name|WAIT_STATE
argument_list|)
expr_stmt|;
comment|/* One wait-state */
name|board_id
operator|=
name|pas_read
argument_list|(
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|board_id
operator|==
literal|0xff
condition|)
return|return
literal|0
return|;
comment|/*    * We probably have a PAS-series board, now check for a PAS2-series board    * by trying to change the board revision bits. PAS2-series hardware won't    * let you do this - the bits are read-only.    */
name|foo
operator|=
name|board_id
operator|^
literal|0xe0
expr_stmt|;
name|pas_write
argument_list|(
name|foo
argument_list|,
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
name|foo
operator|=
name|INB
argument_list|(
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
name|board_id
argument_list|,
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|board_id
operator|!=
name|foo
condition|)
comment|/* Not a PAS2 */
return|return
literal|0
return|;
name|pas_model
operator|=
name|O_M_1_to_card
index|[
name|pas_read
argument_list|(
name|OPERATION_MODE_1
argument_list|)
operator|&
literal|0x0f
index|]
expr_stmt|;
return|return
name|pas_model
return|;
block|}
end_function

begin_function
name|long
name|attach_pas_card
parameter_list|(
name|long
name|mem_start
parameter_list|,
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|pas_irq
operator|=
name|hw_config
operator|->
name|irq
expr_stmt|;
if|if
condition|(
name|detect_pas_hw
argument_list|(
name|hw_config
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pas_model
operator|=
name|O_M_1_to_card
index|[
name|pas_read
argument_list|(
name|OPERATION_MODE_1
argument_list|)
operator|&
literal|0x0f
index|]
operator|)
condition|)
block|{
name|printk
argument_list|(
literal|"snd3:<%s rev %d>"
argument_list|,
name|pas_model_names
index|[
operator|(
name|int
operator|)
name|pas_model
index|]
argument_list|,
name|pas_read
argument_list|(
name|BOARD_REV_ID
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_pas_hw
argument_list|(
name|hw_config
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|EXCLUDE_AUDIO
name|mem_start
operator|=
name|pas_pcm_init
argument_list|(
name|mem_start
argument_list|,
name|hw_config
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|EXCLUDE_SB_EMULATION
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|EXCLUDE_SB
argument_list|)
name|sb_dsp_disable_midi
argument_list|()
expr_stmt|;
comment|/* The SB emulation don't support 					 * midi */
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EXCLUDE_YM3812
name|enable_opl3_mode
argument_list|(
literal|0x388
argument_list|,
literal|0x38a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|EXCLUDE_MIDI
ifdef|#
directive|ifdef
name|EXCLUDE_PRO_MIDI
name|mem_start
operator|=
name|pas_midi_init
argument_list|(
name|mem_start
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|pas_init_mixer
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|mem_start
return|;
block|}
end_function

begin_function
name|int
name|probe_pas
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
return|return
name|detect_pas_hw
argument_list|(
name|hw_config
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

