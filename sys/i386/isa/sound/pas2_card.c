begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/pas2_card.c  *   * Detection routine for the Pro Audio Spectrum cards.  *   * Copyright by Hannu Savolainen 1993  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/sound/sound_config.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_PAS
argument_list|)
end_if

begin_define
define|#
directive|define
name|_PAS2_CARD_C_
end_define

begin_define
define|#
directive|define
name|DEFINE_TRANSLATIONS
end_define

begin_include
include|#
directive|include
file|<i386/isa/sound/pas_hw.h>
end_include

begin_comment
comment|/*  * The Address Translation code is used to convert I/O register addresses to  * be relative to the given base -register  */
end_comment

begin_decl_stmt
name|int
name|translat_code
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pas_intr_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pas_irq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|sound_os_info
modifier|*
name|pas_osp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|pas_model
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pas_model_names
index|[]
init|=
block|{
literal|""
block|,
literal|"Pro AudioSpectrum+"
block|,
literal|"CDPC"
block|,
literal|"Pro AudioSpectrum 16"
block|,
literal|"Pro AudioSpectrum 16D"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * pas_read() and pas_write() are equivalents of inb and outb  */
end_comment

begin_comment
comment|/*  * These routines perform the I/O address translation required  */
end_comment

begin_comment
comment|/*  * to support other than the default base address  */
end_comment

begin_function_decl
specifier|extern
name|void
name|mix_write
parameter_list|(
name|u_char
name|data
parameter_list|,
name|int
name|ioaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|u_char
name|pas_read
parameter_list|(
name|int
name|ioaddr
parameter_list|)
block|{
return|return
name|inb
argument_list|(
name|ioaddr
operator|^
name|translat_code
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|pas_write
parameter_list|(
name|u_char
name|data
parameter_list|,
name|int
name|ioaddr
parameter_list|)
block|{
name|outb
argument_list|(
name|ioaddr
operator|^
name|translat_code
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pas2_msg
parameter_list|(
name|char
modifier|*
name|foo
parameter_list|)
block|{
name|printf
argument_list|(
literal|"    PAS2: %s.\n"
argument_list|,
name|foo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************* Begin of the Interrupt Handler ********************/
end_comment

begin_function
name|void
name|pasintr
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|pas_read
argument_list|(
name|INTERRUPT_STATUS
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
name|status
argument_list|,
name|INTERRUPT_STATUS
argument_list|)
expr_stmt|;
comment|/* Clear interrupt */
if|if
condition|(
name|status
operator|&
name|I_S_PCM_SAMPLE_BUFFER_IRQ
condition|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_AUDIO
name|pas_pcm_interrupt
argument_list|(
name|status
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|&=
operator|~
name|I_S_PCM_SAMPLE_BUFFER_IRQ
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|I_S_MIDI_IRQ
condition|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_MIDI
name|pas_midi_interrupt
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|status
operator|&=
operator|~
name|I_S_MIDI_IRQ
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|pas_set_intr
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mask
condition|)
return|return
literal|0
return|;
name|pas_intr_mask
operator||=
name|mask
expr_stmt|;
name|pas_write
argument_list|(
name|pas_intr_mask
argument_list|,
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pas_remove_intr
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mask
condition|)
return|return
literal|0
return|;
name|pas_intr_mask
operator|&=
operator|~
name|mask
expr_stmt|;
name|pas_write
argument_list|(
name|pas_intr_mask
argument_list|,
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/******************* End of the Interrupt handler **********************/
end_comment

begin_comment
comment|/******************* Begin of the Initialization Code ******************/
end_comment

begin_function
name|int
name|config_pas_hw
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|char
name|ok
init|=
literal|1
decl_stmt|;
name|u_int
name|int_ptrs
decl_stmt|;
comment|/* scsi/sound interrupt pointers */
name|pas_irq
operator|=
name|hw_config
operator|->
name|irq
expr_stmt|;
name|pas_write
argument_list|(
literal|0x00
argument_list|,
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
literal|0x36
argument_list|,
name|SAMPLE_COUNTER_CONTROL
argument_list|)
expr_stmt|;
comment|/* Local timer control * 							 * register */
name|pas_write
argument_list|(
literal|0x36
argument_list|,
name|SAMPLE_RATE_TIMER
argument_list|)
expr_stmt|;
comment|/* Sample rate timer (16 bit) */
name|pas_write
argument_list|(
literal|0
argument_list|,
name|SAMPLE_RATE_TIMER
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
literal|0x74
argument_list|,
name|SAMPLE_COUNTER_CONTROL
argument_list|)
expr_stmt|;
comment|/* Local timer control * 							 * register */
name|pas_write
argument_list|(
literal|0x74
argument_list|,
name|SAMPLE_BUFFER_COUNTER
argument_list|)
expr_stmt|;
comment|/* Sample count register (16 * 						 * bit) */
name|pas_write
argument_list|(
literal|0
argument_list|,
name|SAMPLE_BUFFER_COUNTER
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
name|F_F_PCM_BUFFER_COUNTER
operator||
name|F_F_PCM_RATE_COUNTER
operator||
name|F_F_MIXER_UNMUTE
operator||
literal|1
argument_list|,
name|FILTER_FREQUENCY
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
name|P_C_PCM_DMA_ENABLE
operator||
name|P_C_PCM_MONO
operator||
name|P_C_PCM_DAC_MODE
operator||
name|P_C_MIXER_CROSS_L_TO_L
operator||
name|P_C_MIXER_CROSS_R_TO_R
argument_list|,
name|PCM_CONTROL
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
name|S_M_PCM_RESET
operator||
name|S_M_FM_RESET
operator||
name|S_M_SB_RESET
operator||
name|S_M_MIXER_RESET
comment|/* | S_M_OPL3_DUAL_MONO */
argument_list|,
name|SERIAL_MIXER
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
name|I_C_1_BOOT_RESET_ENABLE
ifdef|#
directive|ifdef
name|PAS_JOYSTICK_ENABLE
operator||
name|I_C_1_JOYSTICK_ENABLE
endif|#
directive|endif
argument_list|,
name|IO_CONFIGURATION_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pas_irq
operator|<
literal|0
operator|||
name|pas_irq
operator|>
literal|15
condition|)
block|{
name|printf
argument_list|(
literal|"PAS2: Invalid IRQ %d"
argument_list|,
name|pas_irq
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int_ptrs
operator|=
name|pas_read
argument_list|(
name|IO_CONFIGURATION_3
argument_list|)
expr_stmt|;
name|int_ptrs
operator||=
name|I_C_3_PCM_IRQ_translate
index|[
name|pas_irq
index|]
operator|&
literal|0xf
expr_stmt|;
name|pas_write
argument_list|(
name|int_ptrs
argument_list|,
name|IO_CONFIGURATION_3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|I_C_3_PCM_IRQ_translate
index|[
name|pas_irq
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"PAS2: Invalid IRQ %d"
argument_list|,
name|pas_irq
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|snd_set_irq_handler
argument_list|(
name|pas_irq
argument_list|,
name|pasintr
argument_list|,
name|hw_config
operator|->
name|osp
argument_list|)
operator|<
literal|0
condition|)
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hw_config
operator|->
name|dma
operator|<
literal|0
operator|||
name|hw_config
operator|->
name|dma
operator|>
literal|7
condition|)
block|{
name|printf
argument_list|(
literal|"PAS2: Invalid DMA selection %d"
argument_list|,
name|hw_config
operator|->
name|dma
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pas_write
argument_list|(
name|I_C_2_PCM_DMA_translate
index|[
name|hw_config
operator|->
name|dma
index|]
argument_list|,
name|IO_CONFIGURATION_2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|I_C_2_PCM_DMA_translate
index|[
name|hw_config
operator|->
name|dma
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"PAS2: Invalid DMA selection %d"
argument_list|,
name|hw_config
operator|->
name|dma
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pas2_card.c: Can't allocate DMA channel\n"
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * This fixes the timing problems of the PAS due to the Symphony 	 * chipset as per Media Vision.  Only define this if your PAS doesn't 	 * work correctly. 	 */
ifdef|#
directive|ifdef
name|SYMPHONY_PAS
name|outb
argument_list|(
literal|0xa8
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0xa9
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BROKEN_BUS_CLOCK
name|pas_write
argument_list|(
name|S_C_1_PCS_ENABLE
operator||
name|S_C_1_PCS_STEREO
operator||
name|S_C_1_PCS_REALSOUND
operator||
name|S_C_1_FM_EMULATE_CLOCK
argument_list|,
name|SYSTEM_CONFIGURATION_1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * pas_write(S_C_1_PCS_ENABLE, SYSTEM_CONFIGURATION_1); 	 */
name|pas_write
argument_list|(
name|S_C_1_PCS_ENABLE
operator||
name|S_C_1_PCS_STEREO
operator||
name|S_C_1_PCS_REALSOUND
argument_list|,
name|SYSTEM_CONFIGURATION_1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pas_write
argument_list|(
literal|0x18
argument_list|,
name|SYSTEM_CONFIGURATION_3
argument_list|)
expr_stmt|;
comment|/* ??? */
name|pas_write
argument_list|(
name|F_F_MIXER_UNMUTE
operator||
literal|0x01
argument_list|,
name|FILTER_FREQUENCY
argument_list|)
expr_stmt|;
comment|/* Sets mute off and * 								 * selects filter rate * 								 * of 17.897 kHz */
name|pas_write
argument_list|(
literal|8
argument_list|,
name|PRESCALE_DIVIDER
argument_list|)
expr_stmt|;
name|mix_write
argument_list|(
name|P_M_MV508_ADDRESS
operator||
literal|5
argument_list|,
name|PARALLEL_MIXER
argument_list|)
expr_stmt|;
name|mix_write
argument_list|(
literal|5
argument_list|,
name|PARALLEL_MIXER
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_SB_EMULATION
argument_list|)
operator|&&
name|defined
argument_list|(
name|CONFIG_SB
argument_list|)
block|{
name|struct
name|address_info
modifier|*
name|sb_config
decl_stmt|;
if|if
condition|(
operator|(
name|sb_config
operator|=
name|sound_getconf
argument_list|(
name|SNDCARD_SB
argument_list|)
operator|)
condition|)
block|{
name|u_char
name|irq_dma
decl_stmt|;
comment|/* 			 * Turn on Sound Blaster compatibility 			 */
comment|/* 			 * bit 1 = SB emulation 			 */
comment|/* 			 * bit 0 = MPU401 emulation (CDPC only :-( ) 			 */
name|pas_write
argument_list|(
literal|0x02
argument_list|,
name|COMPATIBILITY_ENABLE
argument_list|)
expr_stmt|;
comment|/* 			 * "Emulation address" 			 */
name|pas_write
argument_list|(
operator|(
name|sb_config
operator|->
name|io_base
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|,
name|EMULATION_ADDRESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|E_C_SB_DMA_translate
index|[
name|sb_config
operator|->
name|dma
index|]
condition|)
name|printf
argument_list|(
literal|"\n\nPAS16 Warning: Invalid SB DMA %d\n\n"
argument_list|,
name|sb_config
operator|->
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|E_C_SB_IRQ_translate
index|[
name|sb_config
operator|->
name|irq
index|]
condition|)
name|printf
argument_list|(
literal|"\n\nPAS16 Warning: Invalid SB IRQ %d\n\n"
argument_list|,
name|sb_config
operator|->
name|irq
argument_list|)
expr_stmt|;
name|irq_dma
operator|=
name|E_C_SB_DMA_translate
index|[
name|sb_config
operator|->
name|dma
index|]
operator||
name|E_C_SB_IRQ_translate
index|[
name|sb_config
operator|->
name|irq
index|]
expr_stmt|;
name|pas_write
argument_list|(
name|irq_dma
argument_list|,
name|EMULATION_CONFIGURATION
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|pas_write
argument_list|(
literal|0x00
argument_list|,
name|COMPATIBILITY_ENABLE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ok
condition|)
name|pas2_msg
argument_list|(
literal|"Driver not enabled"
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_function
name|int
name|detect_pas_hw
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|u_char
name|board_id
decl_stmt|,
name|foo
decl_stmt|;
comment|/* 	 * WARNING: Setting an option like W:1 or so that disables warm boot 	 * reset of the card will screw up this detect code something fierce. 	 * Adding code to handle this means possibly interfering with other 	 * cards on the bus if you have something on base port 0x388. SO be 	 * forewarned. 	 */
name|outb
argument_list|(
name|MASTER_DECODE
argument_list|,
literal|0xBC
argument_list|)
expr_stmt|;
comment|/* Talk to first board */
name|outb
argument_list|(
name|MASTER_DECODE
argument_list|,
name|hw_config
operator|->
name|io_base
operator|>>
literal|2
argument_list|)
expr_stmt|;
comment|/* Set base address */
name|translat_code
operator|=
name|PAS_DEFAULT_BASE
operator|^
name|hw_config
operator|->
name|io_base
expr_stmt|;
name|pas_write
argument_list|(
literal|1
argument_list|,
name|WAIT_STATE
argument_list|)
expr_stmt|;
comment|/* One wait-state */
name|board_id
operator|=
name|pas_read
argument_list|(
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|board_id
operator|==
literal|0xff
condition|)
return|return
literal|0
return|;
comment|/* 	 * We probably have a PAS-series board, now check for a PAS2-series 	 * board by trying to change the board revision bits. PAS2-series 	 * hardware won't let you do this - the bits are read-only. 	 */
name|foo
operator|=
name|board_id
operator|^
literal|0xe0
expr_stmt|;
name|pas_write
argument_list|(
name|foo
argument_list|,
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
name|foo
operator|=
name|inb
argument_list|(
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
name|pas_write
argument_list|(
name|board_id
argument_list|,
name|INTERRUPT_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|board_id
operator|!=
name|foo
condition|)
comment|/* Not a PAS2 */
return|return
literal|0
return|;
name|pas_model
operator|=
name|pas_read
argument_list|(
name|CHIP_REV
argument_list|)
expr_stmt|;
return|return
name|pas_model
return|;
block|}
end_function

begin_function
name|void
name|attach_pas_card
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|pas_irq
operator|=
name|hw_config
operator|->
name|irq
expr_stmt|;
name|pas_osp
operator|=
name|hw_config
operator|->
name|osp
expr_stmt|;
if|if
condition|(
name|detect_pas_hw
argument_list|(
name|hw_config
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|pas_model
operator|=
name|pas_read
argument_list|(
name|CHIP_REV
argument_list|)
operator|)
condition|)
block|{
name|char
name|temp
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"%s rev %d"
argument_list|,
name|pas_model_names
index|[
operator|(
name|int
operator|)
name|pas_model
index|]
argument_list|,
name|pas_read
argument_list|(
name|BOARD_REV_ID
argument_list|)
argument_list|)
expr_stmt|;
name|conf_printf
argument_list|(
name|temp
argument_list|,
name|hw_config
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|config_pas_hw
argument_list|(
name|hw_config
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|CONFIG_AUDIO
name|pas_pcm_init
argument_list|(
name|hw_config
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_SB_EMULATION
argument_list|)
operator|&&
name|defined
argument_list|(
name|CONFIG_SB
argument_list|)
name|sb_dsp_disable_midi
argument_list|()
expr_stmt|;
comment|/* The SB emulation don't 						 * support * midi */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CONFIG_MIDI
name|pas_midi_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|pas_init_mixer
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|probe_pas
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
name|pas_osp
operator|=
name|hw_config
operator|->
name|osp
expr_stmt|;
return|return
name|detect_pas_hw
argument_list|(
name|hw_config
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

