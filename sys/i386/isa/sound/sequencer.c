begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/sequencer.c  *   * The sequencer personality manager.  *   * Copyright by Hannu Savolainen 1993  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   */
end_comment

begin_define
define|#
directive|define
name|SEQUENCER_C
end_define

begin_include
include|#
directive|include
file|<i386/isa/sound/sound_config.h>
end_include

begin_if
if|#
directive|if
name|NSND
operator|>
literal|0
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_SEQUENCER
end_ifdef

begin_include
include|#
directive|include
file|<i386/isa/sound/midi_ctrl.h>
end_include

begin_function_decl
specifier|static
name|void
name|seq_drain_midi_queues
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sequencer_poll
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|int
name|events
parameter_list|,
name|select_table
modifier|*
name|wait
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|sequencer_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sound_timer_operations
modifier|*
name|tmr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tmr_no
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Currently selected timer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pending_timer
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For timer change operation */
end_comment

begin_comment
comment|/*  * Local counts for number of synth and MIDI devices. These are initialized  * by the sequencer_open.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_mididev
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_synthdev
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The seq_mode gives the operating mode of the sequencer: 1 = level1 (the  * default) 2 = level2 (extended capabilites)  */
end_comment

begin_define
define|#
directive|define
name|SEQ_1
value|1
end_define

begin_define
define|#
directive|define
name|SEQ_2
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|seq_mode
init|=
name|SEQ_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|seq_sleeper
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|struct
name|snd_wait
name|seq_sleep_flag
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|midi_sleeper
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|struct
name|snd_wait
name|midi_sleep_flag
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|midi_opened
index|[
name|MAX_MIDI_DEV
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|midi_written
index|[
name|MAX_MIDI_DEV
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|prev_input_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prev_event_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|seq_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<i386/isa/sound/tuning.h>
end_include

begin_define
define|#
directive|define
name|EV_SZ
value|8
end_define

begin_define
define|#
directive|define
name|IEV_SZ
value|8
end_define

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|queue
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|iqueue
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|qhead
init|=
literal|0
decl_stmt|,
name|qtail
init|=
literal|0
decl_stmt|,
name|qlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|iqhead
init|=
literal|0
decl_stmt|,
name|iqtail
init|=
literal|0
decl_stmt|,
name|iqlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|seq_playing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|sequencer_busy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|output_treshold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pre_event_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|synth_open_mask
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|seq_queue
parameter_list|(
name|u_char
modifier|*
name|note
parameter_list|,
name|char
name|nonblock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seq_startplay
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_sync
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seq_reset
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|pmgr_present
index|[
name|MAX_SYNTH_DEV
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|sequencertimeout_ch
init|=
name|CALLOUT_HANDLE_INITIALIZER
argument_list|(
operator|&
name|sequencertimeout_ch
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|MAX_SYNTH_DEV
operator|>
literal|15
end_if

begin_error
error|#
directive|error
error|Too many synthesizer devices enabled.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * sound_timer stuff -- originally in soundcard.c  *  * A negative value means a relative timeout in |count| ticks.  * A positive value is used for what ?  *  * In any case, this is only used in sequencer.c  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|timer_running
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|request_sound_timer
parameter_list|(
name|int
name|count
parameter_list|)
block|{
specifier|static
name|int
name|current
init|=
literal|0
decl_stmt|;
name|int
name|tmp
init|=
name|count
decl_stmt|;
if|if
condition|(
name|count
operator|<
literal|0
condition|)
name|sequencertimeout_ch
operator|=
name|timeout
argument_list|(
name|sequencer_timer
argument_list|,
literal|0
argument_list|,
operator|-
name|count
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|count
operator|<
name|current
condition|)
name|current
operator|=
literal|0
expr_stmt|;
comment|/* Timer restarted */
name|count
operator|=
name|count
operator|-
name|current
expr_stmt|;
name|current
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|!
name|count
condition|)
name|count
operator|=
literal|1
expr_stmt|;
name|sequencertimeout_ch
operator|=
name|timeout
argument_list|(
name|sequencer_timer
argument_list|,
literal|0
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|timer_running
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sound_stop_timer
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|timer_running
condition|)
name|untimeout
argument_list|(
name|sequencer_timer
argument_list|,
literal|0
argument_list|,
name|sequencertimeout_ch
argument_list|)
expr_stmt|;
name|timer_running
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sequencer_read
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|snd_rw_buf
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|c
init|=
name|count
decl_stmt|,
name|p
init|=
literal|0
decl_stmt|;
name|int
name|ev_len
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|ev_len
operator|=
name|seq_mode
operator|==
name|SEQ_1
condition|?
literal|4
else|:
literal|8
expr_stmt|;
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager device */
return|return
name|pmgr_read
argument_list|(
name|dev
operator|-
literal|1
argument_list|,
name|file
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
return|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|iqlen
condition|)
block|{
name|int
name|flag
decl_stmt|,
name|chn
decl_stmt|;
name|midi_sleeper
operator|=
operator|&
name|chn
expr_stmt|;
name|DO_SLEEP
argument_list|(
name|chn
argument_list|,
name|midi_sleep_flag
argument_list|,
name|pre_event_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iqlen
condition|)
block|{
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
while|while
condition|(
name|iqlen
operator|&&
name|c
operator|>=
name|ev_len
condition|)
block|{
if|if
condition|(
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|iqueue
index|[
name|iqhead
operator|*
name|IEV_SZ
index|]
argument_list|,
name|ev_len
argument_list|,
name|buf
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sb: Bad copyout()!\n"
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ev_len
expr_stmt|;
name|c
operator|-=
name|ev_len
expr_stmt|;
name|iqhead
operator|=
operator|(
name|iqhead
operator|+
literal|1
operator|)
operator|%
name|SEQ_MAX_QUEUE
expr_stmt|;
name|iqlen
operator|--
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|count
operator|-
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sequencer_midi_output
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
comment|/*      * Currently NOP      */
block|}
end_function

begin_function
name|void
name|seq_copy_to_input
parameter_list|(
name|u_char
modifier|*
name|event
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
comment|/*      * Verify that the len is valid for the current mode.      */
if|if
condition|(
name|len
operator|!=
literal|4
operator|&&
name|len
operator|!=
literal|8
condition|)
return|return;
if|if
condition|(
operator|(
name|seq_mode
operator|==
name|SEQ_1
operator|)
operator|!=
operator|(
name|len
operator|==
literal|4
operator|)
condition|)
return|return;
if|if
condition|(
name|iqlen
operator|>=
operator|(
name|SEQ_MAX_QUEUE
operator|-
literal|1
operator|)
condition|)
return|return;
comment|/* Overflow */
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|event
argument_list|,
operator|&
name|iqueue
index|[
name|iqtail
operator|*
name|IEV_SZ
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|iqlen
operator|++
expr_stmt|;
name|iqtail
operator|=
operator|(
name|iqtail
operator|+
literal|1
operator|)
operator|%
name|SEQ_MAX_QUEUE
expr_stmt|;
if|if
condition|(
operator|(
name|midi_sleep_flag
operator|.
name|mode
operator|&
name|WK_SLEEP
operator|)
condition|)
block|{
name|midi_sleep_flag
operator|.
name|mode
operator|=
name|WK_WAKEUP
expr_stmt|;
name|wakeup
argument_list|(
name|midi_sleeper
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sequencer_midi_input
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_char
name|data
parameter_list|)
block|{
name|u_int
name|tstamp
decl_stmt|;
name|u_char
name|event
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|0xfe
condition|)
comment|/* Ignore active sensing */
return|return;
name|tstamp
operator|=
name|get_time
argument_list|()
operator|-
name|seq_time
expr_stmt|;
if|if
condition|(
name|tstamp
operator|!=
name|prev_input_time
condition|)
block|{
name|tstamp
operator|=
operator|(
name|tstamp
operator|<<
literal|8
operator|)
operator||
name|SEQ_WAIT
expr_stmt|;
name|seq_copy_to_input
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|tstamp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|prev_input_time
operator|=
name|tstamp
expr_stmt|;
block|}
name|event
index|[
literal|0
index|]
operator|=
name|SEQ_MIDIPUTC
expr_stmt|;
name|event
index|[
literal|1
index|]
operator|=
name|data
expr_stmt|;
name|event
index|[
literal|2
index|]
operator|=
name|dev
expr_stmt|;
name|event
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|seq_copy_to_input
argument_list|(
name|event
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|seq_input_event
parameter_list|(
name|u_char
modifier|*
name|event
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|u_long
name|this_time
decl_stmt|;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
name|this_time
operator|=
name|tmr
operator|->
name|get_time
argument_list|(
name|tmr_no
argument_list|)
expr_stmt|;
else|else
name|this_time
operator|=
name|get_time
argument_list|()
operator|-
name|seq_time
expr_stmt|;
if|if
condition|(
name|this_time
operator|!=
name|prev_input_time
condition|)
block|{
name|u_char
name|tmp_event
index|[
literal|8
index|]
decl_stmt|;
name|tmp_event
index|[
literal|0
index|]
operator|=
name|EV_TIMING
expr_stmt|;
name|tmp_event
index|[
literal|1
index|]
operator|=
name|TMR_WAIT_ABS
expr_stmt|;
name|tmp_event
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp_event
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|&
name|tmp_event
index|[
literal|4
index|]
operator|=
name|this_time
expr_stmt|;
name|seq_copy_to_input
argument_list|(
name|tmp_event
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|prev_input_time
operator|=
name|this_time
expr_stmt|;
block|}
name|seq_copy_to_input
argument_list|(
name|event
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sequencer_write
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|snd_rw_buf
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|u_char
name|event
index|[
name|EV_SZ
index|]
decl_stmt|,
name|ev_code
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|,
name|ev_size
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|mode
init|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
decl_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sequencer_write(dev=%d, count=%d)\n"
argument_list|,
name|dev
argument_list|,
name|count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|OPEN_READ
condition|)
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|dev
condition|)
return|return
name|pmgr_write
argument_list|(
name|dev
operator|-
literal|1
argument_list|,
name|file
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
return|;
name|c
operator|=
name|count
expr_stmt|;
while|while
condition|(
name|c
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|event
argument_list|,
literal|4
argument_list|,
name|buf
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sb: Bad copyin()!\n"
argument_list|)
expr_stmt|;
name|ev_code
operator|=
name|event
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ev_code
operator|==
name|SEQ_FULLSIZE
condition|)
block|{
name|int
name|err
decl_stmt|;
name|dev
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|event
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|max_synthdev
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
name|err
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|load_patch
argument_list|(
name|dev
argument_list|,
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
name|p
operator|+
literal|4
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
name|err
return|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|ev_code
operator|>=
literal|128
condition|)
block|{
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
operator|&&
name|ev_code
operator|==
name|SEQ_EXTENDED
condition|)
block|{
name|printf
argument_list|(
literal|"Sequencer: Invalid level 2 event %x\n"
argument_list|,
name|ev_code
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ev_size
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|ev_size
condition|)
block|{
if|if
condition|(
operator|!
name|seq_playing
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
return|return
name|count
operator|-
name|c
return|;
block|}
if|if
condition|(
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
argument_list|,
literal|4
argument_list|,
name|buf
argument_list|)
condition|)
name|printf
argument_list|(
literal|"sb: Bad copyin()!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|printf
argument_list|(
literal|"Sequencer: 4 byte event in level 2 mode\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ev_size
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|event
index|[
literal|0
index|]
operator|==
name|SEQ_MIDIPUTC
condition|)
block|{
if|if
condition|(
operator|!
name|midi_opened
index|[
name|event
index|[
literal|2
index|]
index|]
condition|)
block|{
name|int
name|mode
decl_stmt|;
name|int
name|dev
init|=
name|event
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|dev
operator|>=
name|max_mididev
condition|)
block|{
name|printf
argument_list|(
literal|"Sequencer Error: Nonexistent MIDI device %d\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mode
operator|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|midi_devs
index|[
name|dev
index|]
operator|->
name|open
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|,
name|sequencer_midi_input
argument_list|,
name|sequencer_midi_output
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|seq_reset
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"Sequencer Error: Unable to open Midi #%d\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|midi_opened
index|[
name|dev
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|seq_queue
argument_list|(
name|event
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|int
name|processed
init|=
name|count
operator|-
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|seq_playing
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|processed
operator|&&
literal|0
condition|)
return|return
operator|-
operator|(
name|EAGAIN
operator|)
return|;
else|else
return|return
name|processed
return|;
block|}
name|p
operator|+=
name|ev_size
expr_stmt|;
name|c
operator|-=
name|ev_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|seq_playing
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
return|return
name|count
return|;
comment|/* This will "eat" chunks shorter than 4 bytes 			 * (if written alone) Should we really do that ? 			 */
block|}
end_function

begin_function
specifier|static
name|int
name|seq_queue
parameter_list|(
name|u_char
modifier|*
name|note
parameter_list|,
name|char
name|nonblock
parameter_list|)
block|{
comment|/*      * Test if there is space in the queue      */
if|if
condition|(
name|qlen
operator|>=
name|SEQ_MAX_QUEUE
condition|)
if|if
condition|(
operator|!
name|seq_playing
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
comment|/* Give chance to drain the queue */
if|if
condition|(
operator|!
name|nonblock
operator|&&
name|qlen
operator|>=
name|SEQ_MAX_QUEUE
operator|&&
operator|!
operator|(
name|seq_sleep_flag
operator|.
name|mode
operator|&
name|WK_SLEEP
operator|)
condition|)
block|{
comment|/* 	 * Sleep until there is enough space on the queue 	 */
name|int
name|chn
decl_stmt|;
name|seq_sleeper
operator|=
operator|&
name|chn
expr_stmt|;
name|DO_SLEEP
argument_list|(
name|chn
argument_list|,
name|seq_sleep_flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qlen
operator|>=
name|SEQ_MAX_QUEUE
condition|)
return|return
literal|0
return|;
comment|/* To be sure */
name|bcopy
argument_list|(
name|note
argument_list|,
operator|&
name|queue
index|[
name|qtail
operator|*
name|EV_SZ
index|]
argument_list|,
name|EV_SZ
argument_list|)
expr_stmt|;
name|qtail
operator|=
operator|(
name|qtail
operator|+
literal|1
operator|)
operator|%
name|SEQ_MAX_QUEUE
expr_stmt|;
name|qlen
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extended_event
parameter_list|(
name|u_char
modifier|*
name|q
parameter_list|)
block|{
name|int
name|dev
init|=
name|q
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|max_synthdev
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|q
index|[
literal|1
index|]
condition|)
block|{
case|case
name|SEQ_NOTEOFF
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|kill_note
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|,
name|q
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_NOTEON
case|:
if|if
condition|(
name|q
index|[
literal|4
index|]
operator|>
literal|127
operator|&&
name|q
index|[
literal|4
index|]
operator|!=
literal|255
condition|)
return|return
literal|0
return|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|start_note
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|,
name|q
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_PGMCHANGE
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|set_instr
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_AFTERTOUCH
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|aftertouch
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_BALANCE
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|panning
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
operator|(
name|char
operator|)
name|q
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_CONTROLLER
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|controller
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|,
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|q
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_VOLMODE
case|:
if|if
condition|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|volume_method
operator|!=
name|NULL
condition|)
name|synth_devs
index|[
name|dev
index|]
operator|->
name|volume_method
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|)
block|{
name|u_short
name|key
decl_stmt|;
name|int
name|i
decl_stmt|;
name|key
operator|=
operator|(
name|chn
operator|<<
literal|8
operator|)
operator||
operator|(
name|note
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|max_voice
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|map
index|[
name|i
index|]
operator|==
name|key
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|)
block|{
name|u_short
name|key
decl_stmt|;
name|int
name|voice
decl_stmt|;
name|key
operator|=
operator|(
name|chn
operator|<<
literal|8
operator|)
operator||
operator|(
name|note
operator|+
literal|1
operator|)
expr_stmt|;
name|voice
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc_voice
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|note
argument_list|,
operator|&
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|map
index|[
name|voice
index|]
operator|=
name|key
expr_stmt|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|alloc_times
index|[
name|voice
index|]
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|timestamp
operator|++
expr_stmt|;
return|return
name|voice
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_chn_voice_event
parameter_list|(
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|u_char
name|dev
init|=
name|event
index|[
literal|1
index|]
decl_stmt|;
name|u_char
name|cmd
init|=
name|event
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|chn
init|=
name|event
index|[
literal|3
index|]
decl_stmt|;
name|u_char
name|note
init|=
name|event
index|[
literal|4
index|]
decl_stmt|;
name|u_char
name|parm
init|=
name|event
index|[
literal|5
index|]
decl_stmt|;
name|int
name|voice
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|dev
operator|>
name|max_synthdev
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|synth_devs
index|[
name|dev
index|]
condition|)
return|return;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
if|if
condition|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc_voice
condition|)
name|voice
operator|=
name|find_voice
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|MIDI_NOTEON
operator|&&
name|parm
operator|==
literal|0
condition|)
block|{
name|cmd
operator|=
name|MIDI_NOTEOFF
expr_stmt|;
name|parm
operator|=
literal|64
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MIDI_NOTEON
case|:
if|if
condition|(
name|note
operator|>
literal|127
operator|&&
name|note
operator|!=
literal|255
condition|)
comment|/* Not a seq2 feature */
return|return;
if|if
condition|(
name|voice
operator|==
operator|-
literal|1
operator|&&
name|seq_mode
operator|==
name|SEQ_2
operator|&&
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc_voice
condition|)
block|{
comment|/* Internal synthesizer (FM, GUS, etc) */
name|voice
operator|=
name|alloc_voice
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|voice
operator|==
operator|-
literal|1
condition|)
name|voice
operator|=
name|chn
expr_stmt|;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
operator|&&
operator|(
name|int
operator|)
name|dev
operator|<
name|num_synths
condition|)
block|{
comment|/* 	     * The MIDI channel 10 is a percussive channel. Use 	     * the note number to select the proper patch (128 to 	     * 255) to play. 	     */
if|if
condition|(
name|chn
operator|==
literal|9
condition|)
block|{
name|synth_devs
index|[
name|dev
index|]
operator|->
name|set_instr
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
literal|128
operator|+
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
literal|60
expr_stmt|;
comment|/* Middle C */
block|}
block|}
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
name|synth_devs
index|[
name|dev
index|]
operator|->
name|setup_voice
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|chn
argument_list|)
expr_stmt|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|start_note
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|note
argument_list|,
name|parm
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_NOTEOFF
case|:
if|if
condition|(
name|voice
operator|==
operator|-
literal|1
condition|)
name|voice
operator|=
name|chn
expr_stmt|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|kill_note
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|note
argument_list|,
name|parm
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_KEY_PRESSURE
case|:
if|if
condition|(
name|voice
operator|==
operator|-
literal|1
condition|)
name|voice
operator|=
name|chn
expr_stmt|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|aftertouch
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|parm
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|seq_chn_common_event
parameter_list|(
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|u_char
name|dev
init|=
name|event
index|[
literal|1
index|]
decl_stmt|;
name|u_char
name|cmd
init|=
name|event
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|chn
init|=
name|event
index|[
literal|3
index|]
decl_stmt|;
name|u_char
name|p1
init|=
name|event
index|[
literal|4
index|]
decl_stmt|;
comment|/* u_char   p2 = event[5]; */
name|u_short
name|w14
init|=
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|dev
operator|>
name|max_synthdev
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|synth_devs
index|[
name|dev
index|]
condition|)
return|return;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MIDI_PGM_CHANGE
case|:
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|pgm_num
operator|=
name|p1
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|dev
operator|>=
name|num_synths
condition|)
name|synth_devs
index|[
name|dev
index|]
operator|->
name|set_instr
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|)
expr_stmt|;
block|}
else|else
name|synth_devs
index|[
name|dev
index|]
operator|->
name|set_instr
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_CTL_CHANGE
case|:
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
if|if
condition|(
name|chn
operator|>
literal|15
operator|||
name|p1
operator|>
literal|127
condition|)
break|break;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|controllers
index|[
name|p1
index|]
operator|=
name|w14
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|p1
operator|<
literal|32
condition|)
comment|/* Setting MSB should clear LSB to 0 */
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|controllers
index|[
name|p1
operator|+
literal|32
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|dev
operator|<
name|num_synths
condition|)
block|{
name|int
name|val
init|=
name|w14
operator|&
literal|0x7f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|key
decl_stmt|;
if|if
condition|(
name|p1
operator|<
literal|64
condition|)
block|{
comment|/* Combine MSB and LSB */
name|val
operator|=
operator|(
operator|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|controllers
index|[
name|p1
operator|&
operator|~
literal|32
index|]
operator|&
literal|0x7f
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|controllers
index|[
name|p1
operator||
literal|32
index|]
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|32
expr_stmt|;
block|}
comment|/* Handle all playing notes on this channel */
name|key
operator|=
operator|(
operator|(
name|int
operator|)
name|chn
operator|<<
literal|8
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|max_voice
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|map
index|[
name|i
index|]
operator|&
literal|0xff00
operator|)
operator|==
name|key
condition|)
name|synth_devs
index|[
name|dev
index|]
operator|->
name|controller
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|p1
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|synth_devs
index|[
name|dev
index|]
operator|->
name|controller
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|,
name|w14
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Mode 1 */
name|synth_devs
index|[
name|dev
index|]
operator|->
name|controller
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|,
name|w14
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_PITCH_BEND
case|:
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|bender_value
operator|=
name|w14
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|dev
operator|<
name|num_synths
condition|)
block|{
comment|/* Handle all playing 						 * notes on this channel */
name|int
name|i
decl_stmt|,
name|key
decl_stmt|;
name|key
operator|=
operator|(
name|chn
operator|<<
literal|8
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|max_voice
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|map
index|[
name|i
index|]
operator|&
literal|0xff00
operator|)
operator|==
name|key
condition|)
name|synth_devs
index|[
name|dev
index|]
operator|->
name|bender
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|w14
argument_list|)
expr_stmt|;
block|}
else|else
name|synth_devs
index|[
name|dev
index|]
operator|->
name|bender
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|w14
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* MODE 1 */
name|synth_devs
index|[
name|dev
index|]
operator|->
name|bender
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|w14
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|seq_timing_event
parameter_list|(
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|u_char
name|cmd
init|=
name|event
index|[
literal|1
index|]
decl_stmt|;
name|u_int
name|parm
init|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|tmr
operator|->
name|event
argument_list|(
name|tmr_no
argument_list|,
name|event
argument_list|)
operator|)
operator|==
name|TIMER_ARMED
condition|)
block|{
if|if
condition|(
operator|(
name|SEQ_MAX_QUEUE
operator|-
name|qlen
operator|)
operator|>=
name|output_treshold
condition|)
block|{
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|seq_sleep_flag
operator|.
name|mode
operator|&
name|WK_SLEEP
operator|)
condition|)
block|{
name|seq_sleep_flag
operator|.
name|mode
operator|=
name|WK_WAKEUP
expr_stmt|;
name|wakeup
argument_list|(
name|seq_sleeper
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TMR_WAIT_REL
case|:
name|parm
operator|+=
name|prev_event_time
expr_stmt|;
comment|/* 	 * NOTE!  No break here. Execution of TMR_WAIT_REL continues 	 * in the next case (TMR_WAIT_ABS) 	 */
case|case
name|TMR_WAIT_ABS
case|:
if|if
condition|(
name|parm
operator|>
literal|0
condition|)
block|{
name|long
name|time
decl_stmt|;
name|seq_playing
operator|=
literal|1
expr_stmt|;
name|time
operator|=
name|parm
expr_stmt|;
name|prev_event_time
operator|=
name|time
expr_stmt|;
name|request_sound_timer
argument_list|(
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SEQ_MAX_QUEUE
operator|-
name|qlen
operator|)
operator|>=
name|output_treshold
condition|)
block|{
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|seq_sleep_flag
operator|.
name|mode
operator|&
name|WK_SLEEP
operator|)
condition|)
block|{
name|seq_sleep_flag
operator|.
name|mode
operator|=
name|WK_WAKEUP
expr_stmt|;
name|wakeup
argument_list|(
name|seq_sleeper
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
name|TIMER_ARMED
return|;
block|}
break|break;
case|case
name|TMR_START
case|:
name|seq_time
operator|=
name|get_time
argument_list|()
expr_stmt|;
name|prev_input_time
operator|=
literal|0
expr_stmt|;
name|prev_event_time
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TMR_STOP
case|:
break|break;
case|case
name|TMR_CONTINUE
case|:
break|break;
case|case
name|TMR_TEMPO
case|:
break|break;
case|case
name|TMR_ECHO
case|:
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
name|seq_copy_to_input
argument_list|(
name|event
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
block|{
name|parm
operator|=
operator|(
name|parm
operator|<<
literal|8
operator||
name|SEQ_ECHO
operator|)
expr_stmt|;
name|seq_copy_to_input
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|parm
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
return|return
name|TIMER_NOT_ARMED
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_local_event
parameter_list|(
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|u_char
name|cmd
init|=
name|event
index|[
literal|1
index|]
decl_stmt|;
name|u_int
name|parm
init|=
operator|*
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
operator|)
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LOCL_STARTAUDIO
case|:
ifdef|#
directive|ifdef
name|CONFIG_AUDIO
name|DMAbuf_start_devices
argument_list|(
name|parm
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|seq_sysex_message
parameter_list|(
name|u_char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|dev
init|=
name|event
index|[
literal|1
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|buf
init|=
operator|&
name|event
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|dev
operator|>
name|max_synthdev
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|synth_devs
index|[
name|dev
index|]
condition|)
return|return;
if|if
condition|(
operator|!
name|synth_devs
index|[
name|dev
index|]
operator|->
name|send_sysex
condition|)
return|return;
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
operator|&&
name|buf
index|[
name|i
index|]
operator|!=
literal|0xff
condition|;
name|i
operator|++
control|)
name|l
operator|=
name|i
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|l
operator|>
literal|0
condition|)
name|synth_devs
index|[
name|dev
index|]
operator|->
name|send_sysex
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|play_event
parameter_list|(
name|u_char
modifier|*
name|q
parameter_list|)
block|{
comment|/*      * NOTE! This routine returns 0 = normal event played. 1 = Timer      * armed. Suspend playback until timer callback. 2 = MIDI output      * buffer full. Restore queue and suspend until timer      */
name|u_long
modifier|*
name|delay
decl_stmt|;
switch|switch
condition|(
name|q
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SEQ_NOTEOFF
case|:
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
if|if
condition|(
name|synth_devs
index|[
literal|0
index|]
condition|)
name|synth_devs
index|[
literal|0
index|]
operator|->
name|kill_note
argument_list|(
literal|0
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|,
literal|255
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_NOTEON
case|:
if|if
condition|(
name|q
index|[
literal|4
index|]
operator|<
literal|128
operator|||
name|q
index|[
literal|4
index|]
operator|==
literal|255
condition|)
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
if|if
condition|(
name|synth_devs
index|[
literal|0
index|]
condition|)
name|synth_devs
index|[
literal|0
index|]
operator|->
name|start_note
argument_list|(
literal|0
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_WAIT
case|:
name|delay
operator|=
operator|(
name|u_long
operator|*
operator|)
name|q
expr_stmt|;
comment|/* Bytes 1 to 3 are 					 * containing the * delay in 					 * get_time() */
operator|*
name|delay
operator|=
operator|(
operator|*
name|delay
operator|>>
literal|8
operator|)
operator|&
literal|0xffffff
expr_stmt|;
if|if
condition|(
operator|*
name|delay
operator|>
literal|0
condition|)
block|{
name|long
name|time
decl_stmt|;
name|seq_playing
operator|=
literal|1
expr_stmt|;
name|time
operator|=
operator|*
name|delay
expr_stmt|;
name|prev_event_time
operator|=
name|time
expr_stmt|;
name|request_sound_timer
argument_list|(
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SEQ_MAX_QUEUE
operator|-
name|qlen
operator|)
operator|>=
name|output_treshold
condition|)
block|{
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|seq_sleep_flag
operator|.
name|mode
operator|&
name|WK_SLEEP
operator|)
condition|)
block|{
name|seq_sleep_flag
operator|.
name|mode
operator|=
name|WK_WAKEUP
expr_stmt|;
name|wakeup
argument_list|(
name|seq_sleeper
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * The timer is now active and will reinvoke this 	     * function after the timer expires. Return to the 	     * caller now. 	     */
return|return
literal|1
return|;
block|}
break|break;
case|case
name|SEQ_PGMCHANGE
case|:
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
if|if
condition|(
name|synth_devs
index|[
literal|0
index|]
condition|)
name|synth_devs
index|[
literal|0
index|]
operator|->
name|set_instr
argument_list|(
literal|0
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_SYNCTIMER
case|:
comment|/* Reset timer */
name|seq_time
operator|=
name|get_time
argument_list|()
expr_stmt|;
name|prev_input_time
operator|=
literal|0
expr_stmt|;
name|prev_event_time
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SEQ_MIDIPUTC
case|:
comment|/* Put a midi character */
if|if
condition|(
name|midi_opened
index|[
name|q
index|[
literal|2
index|]
index|]
condition|)
block|{
name|int
name|dev
decl_stmt|;
name|dev
operator|=
name|q
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|midi_devs
index|[
name|dev
index|]
operator|->
name|putc
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* 		 * Output FIFO is full. Wait one timer cycle and try again. 		 */
name|seq_playing
operator|=
literal|1
expr_stmt|;
name|request_sound_timer
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
else|else
name|midi_written
index|[
name|dev
index|]
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|SEQ_ECHO
case|:
name|seq_copy_to_input
argument_list|(
name|q
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Echo back to the process */
break|break;
case|case
name|SEQ_PRIVATE
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|q
index|[
literal|1
index|]
operator|<
name|max_synthdev
condition|)
name|synth_devs
index|[
name|q
index|[
literal|1
index|]
index|]
operator|->
name|hw_control
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_EXTENDED
case|:
name|extended_event
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_CHN_VOICE
case|:
name|seq_chn_voice_event
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_CHN_COMMON
case|:
name|seq_chn_common_event
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_TIMING
case|:
if|if
condition|(
name|seq_timing_event
argument_list|(
name|q
argument_list|)
operator|==
name|TIMER_ARMED
condition|)
block|{
return|return
literal|1
return|;
block|}
break|break;
case|case
name|EV_SEQ_LOCAL
case|:
name|seq_local_event
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_SYSEX
case|:
name|seq_sysex_message
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_startplay
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
name|int
name|this_one
decl_stmt|,
name|action
decl_stmt|;
while|while
condition|(
name|qlen
operator|>
literal|0
condition|)
block|{
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|qhead
operator|=
operator|(
operator|(
name|this_one
operator|=
name|qhead
operator|)
operator|+
literal|1
operator|)
operator|%
name|SEQ_MAX_QUEUE
expr_stmt|;
name|qlen
operator|--
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|seq_playing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|action
operator|=
name|play_event
argument_list|(
operator|&
name|queue
index|[
name|this_one
operator|*
name|EV_SZ
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* 	     * Suspend playback. Next timer routine invokes this routine again 	     */
if|if
condition|(
name|action
operator|==
literal|2
condition|)
block|{
name|qlen
operator|++
expr_stmt|;
name|qhead
operator|=
name|this_one
expr_stmt|;
block|}
return|return;
block|}
block|}
name|seq_playing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|SEQ_MAX_QUEUE
operator|-
name|qlen
operator|)
operator|>=
name|output_treshold
condition|)
block|{
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|seq_sleep_flag
operator|.
name|mode
operator|&
name|WK_SLEEP
operator|)
condition|)
block|{
name|seq_sleep_flag
operator|.
name|mode
operator|=
name|WK_WAKEUP
expr_stmt|;
name|wakeup
argument_list|(
name|seq_sleeper
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|reset_controllers
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_char
modifier|*
name|controller
parameter_list|,
name|int
name|update_dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|controller
index|[
name|i
index|]
operator|=
name|ctrl_def_values
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_mode2
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|dev
decl_stmt|;
name|max_synthdev
operator|=
name|num_synths
expr_stmt|;
for|for
control|(
name|dev
operator|=
literal|0
init|;
name|dev
operator|<
name|num_midis
condition|;
name|dev
operator|++
control|)
if|if
condition|(
name|midi_devs
index|[
name|dev
index|]
operator|->
name|converter
operator|!=
name|NULL
condition|)
name|synth_devs
index|[
name|max_synthdev
operator|++
index|]
operator|=
name|midi_devs
index|[
name|dev
index|]
operator|->
name|converter
expr_stmt|;
for|for
control|(
name|dev
operator|=
literal|0
init|;
name|dev
operator|<
name|max_synthdev
condition|;
name|dev
operator|++
control|)
block|{
name|int
name|chn
decl_stmt|;
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
literal|16
condition|;
name|chn
operator|++
control|)
block|{
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|pgm_num
operator|=
literal|0
expr_stmt|;
name|reset_controllers
argument_list|(
name|dev
argument_list|,
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|controllers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|bender_value
operator|=
operator|(
literal|1
operator|<<
literal|7
operator|)
expr_stmt|;
comment|/* Neutral */
block|}
block|}
name|max_mididev
operator|=
literal|0
expr_stmt|;
name|seq_mode
operator|=
name|SEQ_2
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sequencer_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|)
block|{
name|int
name|retval
decl_stmt|,
name|mode
decl_stmt|,
name|i
decl_stmt|;
name|int
name|level
decl_stmt|,
name|tmp
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|level
operator|=
operator|(
operator|(
name|dev
operator|&
literal|0x0f
operator|)
operator|==
name|SND_DEV_SEQ2
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|mode
operator|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sequencer_open(dev=%d)\n"
argument_list|,
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sequencer_ok
condition|)
block|{
name|printf
argument_list|(
literal|"Soundcard: Sequencer not initialized\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|dev
condition|)
block|{
comment|/* Patch manager device */
name|int
name|err
decl_stmt|;
name|printf
argument_list|(
literal|"Patch manager interface is currently broken. Sorry\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
name|dev
operator|--
expr_stmt|;
if|if
condition|(
name|dev
operator|>=
name|MAX_SYNTH_DEV
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|pmgr_present
index|[
name|dev
index|]
condition|)
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|pmgr_open
argument_list|(
name|dev
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|err
return|;
name|pmgr_present
index|[
name|dev
index|]
operator|=
literal|1
expr_stmt|;
return|return
name|err
return|;
block|}
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|sequencer_busy
condition|)
block|{
name|printf
argument_list|(
literal|"Sequencer busy\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
block|}
name|sequencer_busy
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|max_mididev
operator|=
name|num_midis
expr_stmt|;
name|max_synthdev
operator|=
name|num_synths
expr_stmt|;
name|pre_event_timeout
operator|=
literal|0
expr_stmt|;
name|seq_mode
operator|=
name|SEQ_1
expr_stmt|;
if|if
condition|(
name|pending_timer
operator|!=
operator|-
literal|1
condition|)
block|{
name|tmr_no
operator|=
name|pending_timer
expr_stmt|;
name|pending_timer
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tmr_no
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Not selected yet */
name|int
name|i
decl_stmt|,
name|best
decl_stmt|;
name|best
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_sound_timers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sound_timer_devs
index|[
name|i
index|]
operator|->
name|priority
operator|>
name|best
condition|)
block|{
name|tmr_no
operator|=
name|i
expr_stmt|;
name|best
operator|=
name|sound_timer_devs
index|[
name|i
index|]
operator|->
name|priority
expr_stmt|;
block|}
if|if
condition|(
name|tmr_no
operator|==
operator|-
literal|1
condition|)
comment|/* Should not be */
name|tmr_no
operator|=
literal|0
expr_stmt|;
block|}
name|tmr
operator|=
name|sound_timer_devs
index|[
name|tmr_no
index|]
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|tmr
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sequencer: No timer for level 2\n"
argument_list|)
expr_stmt|;
name|sequencer_busy
operator|=
literal|0
expr_stmt|;
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
block|}
name|setup_mode2
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_1
operator|&&
operator|(
name|mode
operator|==
name|OPEN_READ
operator|||
name|mode
operator|==
name|OPEN_READWRITE
operator|)
condition|)
if|if
condition|(
operator|!
name|max_mididev
condition|)
block|{
name|printf
argument_list|(
literal|"Sequencer: No Midi devices. Input not possible\n"
argument_list|)
expr_stmt|;
name|sequencer_busy
operator|=
literal|0
expr_stmt|;
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|max_synthdev
operator|&&
operator|!
name|max_mididev
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
name|synth_open_mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_mididev
condition|;
name|i
operator|++
control|)
block|{
name|midi_opened
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|midi_written
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * if (mode == OPEN_WRITE || mode == OPEN_READWRITE)      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_synthdev
condition|;
name|i
operator|++
control|)
comment|/* Open synth devices */
if|if
condition|(
operator|(
name|tmp
operator|=
name|synth_devs
index|[
name|i
index|]
operator|->
name|open
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Sequencer: Warning! Cannot open synth device #%d (%d)\n"
argument_list|,
name|i
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
operator|->
name|midi_dev
condition|)
name|printf
argument_list|(
literal|"(Maps to MIDI dev #%d)\n"
argument_list|,
name|synth_devs
index|[
name|i
index|]
operator|->
name|midi_dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|synth_open_mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
operator|->
name|midi_dev
condition|)
comment|/* Is a midi interface */
name|midi_opened
index|[
name|synth_devs
index|[
name|i
index|]
operator|->
name|midi_dev
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|seq_time
operator|=
name|get_time
argument_list|()
expr_stmt|;
name|prev_input_time
operator|=
literal|0
expr_stmt|;
name|prev_event_time
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_1
operator|&&
operator|(
name|mode
operator|==
name|OPEN_READ
operator|||
name|mode
operator|==
name|OPEN_READWRITE
operator|)
condition|)
block|{
comment|/* Initialize midi input devices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_mididev
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|midi_opened
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|retval
operator|=
name|midi_devs
index|[
name|i
index|]
operator|->
name|open
argument_list|(
name|i
argument_list|,
name|mode
argument_list|,
name|sequencer_midi_input
argument_list|,
name|sequencer_midi_output
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|midi_opened
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|tmr
operator|->
name|open
argument_list|(
name|tmr_no
argument_list|,
name|seq_mode
argument_list|)
expr_stmt|;
block|}
name|seq_sleep_flag
operator|.
name|aborting
operator|=
literal|0
expr_stmt|;
name|seq_sleep_flag
operator|.
name|mode
operator|=
name|WK_NONE
expr_stmt|;
name|midi_sleep_flag
operator|.
name|aborting
operator|=
literal|0
expr_stmt|;
name|midi_sleep_flag
operator|.
name|mode
operator|=
name|WK_NONE
expr_stmt|;
name|output_treshold
operator|=
name|SEQ_MAX_QUEUE
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_synths
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pmgr_present
index|[
name|i
index|]
condition|)
name|pmgr_inform
argument_list|(
name|i
argument_list|,
name|PM_E_OPENED
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_drain_midi_queues
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/*      * Give the Midi drivers time to drain their output queues      */
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|seq_sleep_flag
operator|.
name|aborting
operator|)
operator|&&
name|n
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_mididev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|midi_opened
index|[
name|i
index|]
operator|&&
name|midi_written
index|[
name|i
index|]
condition|)
if|if
condition|(
name|midi_devs
index|[
name|i
index|]
operator|->
name|buffer_status
operator|!=
name|NULL
condition|)
if|if
condition|(
name|midi_devs
index|[
name|i
index|]
operator|->
name|buffer_status
argument_list|(
name|i
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
comment|/* 	 * Let's have a delay 	 */
if|if
condition|(
name|n
condition|)
block|{
name|int
name|chn
decl_stmt|;
name|seq_sleeper
operator|=
operator|&
name|chn
expr_stmt|;
name|DO_SLEEP
argument_list|(
name|chn
argument_list|,
name|seq_sleep_flag
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sequencer_release
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|mode
init|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
decl_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|DEB
argument_list|(
name|printf
argument_list|(
literal|"sequencer_release(dev=%d)\n"
argument_list|,
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
comment|/* Patch manager device */
name|dev
operator|--
expr_stmt|;
name|pmgr_release
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pmgr_present
index|[
name|dev
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*      * Wait until the queue is empty (if we don't have nonblock)      */
if|if
condition|(
name|mode
operator|!=
name|OPEN_READ
operator|&&
operator|!
literal|0
condition|)
while|while
condition|(
operator|!
operator|(
name|seq_sleep_flag
operator|.
name|aborting
operator|)
operator|&&
name|qlen
condition|)
block|{
name|seq_sync
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|OPEN_READ
condition|)
name|seq_drain_midi_queues
argument_list|()
expr_stmt|;
comment|/* Ensure the output queues are empty */
name|seq_reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|OPEN_READ
condition|)
name|seq_drain_midi_queues
argument_list|()
expr_stmt|;
comment|/* Flush the all notes off messages */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_synthdev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
comment|/* Actually opened */
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
condition|)
block|{
name|synth_devs
index|[
name|i
index|]
operator|->
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
operator|->
name|midi_dev
condition|)
name|midi_opened
index|[
name|synth_devs
index|[
name|i
index|]
operator|->
name|midi_dev
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_synths
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pmgr_present
index|[
name|i
index|]
condition|)
name|pmgr_inform
argument_list|(
name|i
argument_list|,
name|PM_E_CLOSED
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_mididev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|midi_opened
index|[
name|i
index|]
condition|)
name|midi_devs
index|[
name|i
index|]
operator|->
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
name|tmr
operator|->
name|close
argument_list|(
name|tmr_no
argument_list|)
expr_stmt|;
name|sequencer_busy
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_sync
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|flags
decl_stmt|;
if|if
condition|(
name|qlen
operator|&&
operator|!
name|seq_playing
operator|&&
operator|!
operator|(
name|seq_sleep_flag
operator|.
name|aborting
operator|)
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|qlen
operator|&&
operator|!
operator|(
name|seq_sleep_flag
operator|.
name|mode
operator|&
name|WK_SLEEP
operator|)
condition|)
block|{
name|int
name|chn
decl_stmt|;
name|seq_sleeper
operator|=
operator|&
name|chn
expr_stmt|;
name|DO_SLEEP
argument_list|(
name|chn
argument_list|,
name|seq_sleep_flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|qlen
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|midi_outc
parameter_list|(
name|int
name|dev
parameter_list|,
name|u_char
name|data
parameter_list|)
block|{
comment|/*      * NOTE! Calls sleep(). Don't call this from interrupt.      */
name|int
name|n
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
comment|/*      * This routine sends one byte to the Midi channel. If the output      * Fifo is full, it waits until there is space in the queue      */
name|n
operator|=
literal|3
operator|*
name|hz
expr_stmt|;
comment|/* Timeout */
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
while|while
condition|(
name|n
operator|&&
operator|!
name|midi_devs
index|[
name|dev
index|]
operator|->
name|putc
argument_list|(
name|dev
argument_list|,
name|data
argument_list|)
condition|)
block|{
name|int
name|chn
decl_stmt|;
name|seq_sleeper
operator|=
operator|&
name|chn
expr_stmt|;
name|DO_SLEEP
argument_list|(
name|chn
argument_list|,
name|seq_sleep_flag
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_reset
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*      * NOTE! Calls sleep(). Don't call this from interrupt.      */
name|int
name|i
decl_stmt|;
name|int
name|chn
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|sound_stop_timer
argument_list|()
expr_stmt|;
name|seq_time
operator|=
name|get_time
argument_list|()
expr_stmt|;
name|prev_input_time
operator|=
literal|0
expr_stmt|;
name|prev_event_time
operator|=
literal|0
expr_stmt|;
name|qlen
operator|=
name|qhead
operator|=
name|qtail
operator|=
literal|0
expr_stmt|;
name|iqlen
operator|=
name|iqhead
operator|=
name|iqtail
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_synthdev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
condition|)
name|synth_devs
index|[
name|i
index|]
operator|->
name|reset
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
literal|16
condition|;
name|chn
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_synthdev
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|&&
operator|(
name|synth_devs
index|[
name|i
index|]
operator|)
condition|)
block|{
name|synth_devs
index|[
name|i
index|]
operator|->
name|controller
argument_list|(
name|i
argument_list|,
name|chn
argument_list|,
literal|123
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* All notes off */
name|synth_devs
index|[
name|i
index|]
operator|->
name|controller
argument_list|(
name|i
argument_list|,
name|chn
argument_list|,
literal|121
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset all ctl */
name|synth_devs
index|[
name|i
index|]
operator|->
name|bender
argument_list|(
name|i
argument_list|,
name|chn
argument_list|,
literal|1
operator|<<
literal|13
argument_list|)
expr_stmt|;
comment|/* Bender off */
block|}
block|}
else|else
block|{
comment|/* seq_mode == SEQ_1 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_mididev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|midi_written
index|[
name|i
index|]
condition|)
block|{
comment|/* Midi used. Some notes may still be playing */
comment|/* 		 * Sending just a ACTIVE SENSING message 		 * should be enough to stop all playing 		 * notes. Since there are devices not 		 * recognizing the active sensing, we have to 		 * send some all notes off messages also. 		 */
name|midi_outc
argument_list|(
name|i
argument_list|,
literal|0xfe
argument_list|)
expr_stmt|;
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
literal|16
condition|;
name|chn
operator|++
control|)
block|{
name|midi_outc
argument_list|(
name|i
argument_list|,
call|(
name|u_char
call|)
argument_list|(
literal|0xb0
operator|+
operator|(
name|chn
operator|&
literal|0x0f
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* control change */
name|midi_outc
argument_list|(
name|i
argument_list|,
literal|0x7b
argument_list|)
expr_stmt|;
comment|/* All notes off */
name|midi_outc
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Dummy parameter */
block|}
name|midi_devs
index|[
name|i
index|]
operator|->
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|midi_written
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|midi_opened
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|seq_playing
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|seq_sleep_flag
operator|.
name|mode
operator|&
name|WK_SLEEP
operator|)
condition|)
block|{
name|seq_sleep_flag
operator|.
name|mode
operator|=
name|WK_WAKEUP
expr_stmt|;
name|wakeup
argument_list|(
name|seq_sleeper
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_panic
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*      * This routine is called by the application in case the user wants      * to reset the system to the default state.      */
name|seq_reset
argument_list|()
expr_stmt|;
comment|/*      * Since some of the devices don't recognize the active sensing and      * all notes off messages, we have to shut all notes manually.      *       * TO BE IMPLEMENTED LATER      */
comment|/*      * Also return the controllers to their default states      */
block|}
end_function

begin_function
name|int
name|sequencer_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|u_int
name|cmd
parameter_list|,
name|ioctl_arg
name|arg
parameter_list|)
block|{
name|int
name|midi_dev
decl_stmt|,
name|orig_dev
decl_stmt|;
name|int
name|mode
init|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
decl_stmt|;
name|orig_dev
operator|=
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_TMR_TIMEBASE
case|:
case|case
name|SNDCTL_TMR_TEMPO
case|:
case|case
name|SNDCTL_TMR_START
case|:
case|case
name|SNDCTL_TMR_STOP
case|:
case|case
name|SNDCTL_TMR_CONTINUE
case|:
case|case
name|SNDCTL_TMR_METRONOME
case|:
case|case
name|SNDCTL_TMR_SOURCE
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|seq_mode
operator|!=
name|SEQ_2
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
return|return
name|tmr
operator|->
name|ioctl
argument_list|(
name|tmr_no
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_TMR_SELECT
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|seq_mode
operator|!=
name|SEQ_2
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
name|pending_timer
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
expr_stmt|;
if|if
condition|(
name|pending_timer
operator|<
literal|0
operator|||
name|pending_timer
operator|>=
name|num_sound_timers
condition|)
block|{
name|pending_timer
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|pending_timer
return|;
break|break;
case|case
name|SNDCTL_SEQ_PANIC
case|:
name|seq_panic
argument_list|()
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_SYNC
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|mode
operator|==
name|OPEN_READ
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|qlen
operator|&&
operator|!
operator|(
name|seq_sleep_flag
operator|.
name|aborting
operator|)
condition|)
name|seq_sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|qlen
condition|)
return|return
operator|-
operator|(
name|EINTR
operator|)
return|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_RESET
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
name|seq_reset
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_TESTMIDI
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
name|midi_dev
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
expr_stmt|;
if|if
condition|(
name|midi_dev
operator|>=
name|max_mididev
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|midi_opened
index|[
name|midi_dev
index|]
condition|)
block|{
name|int
name|err
decl_stmt|,
name|mode
decl_stmt|;
name|mode
operator|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|open
argument_list|(
name|midi_dev
argument_list|,
name|mode
argument_list|,
name|sequencer_midi_input
argument_list|,
name|sequencer_midi_output
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|err
return|;
block|}
name|midi_opened
index|[
name|midi_dev
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_GETINCOUNT
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|mode
operator|==
name|OPEN_WRITE
condition|)
return|return
literal|0
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|iqlen
return|;
break|break;
case|case
name|SNDCTL_SEQ_GETOUTCOUNT
case|:
if|if
condition|(
name|mode
operator|==
name|OPEN_READ
condition|)
return|return
literal|0
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|SEQ_MAX_QUEUE
operator|-
name|qlen
return|;
break|break;
case|case
name|SNDCTL_SEQ_CTRLRATE
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
comment|/* 	 * If *arg == 0, just return the current rate 	 */
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
return|return
name|tmr
operator|->
name|ioctl
argument_list|(
name|tmr_no
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
if|if
condition|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|hz
return|;
break|break;
case|case
name|SNDCTL_SEQ_RESETSAMPLES
case|:
block|{
name|int
name|err
decl_stmt|;
name|dev
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
operator|&&
operator|!
name|orig_dev
condition|)
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|!
name|orig_dev
operator|&&
name|pmgr_present
index|[
name|dev
index|]
condition|)
name|pmgr_inform
argument_list|(
name|dev
argument_list|,
name|PM_E_PATCH_RESET
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
break|break;
case|case
name|SNDCTL_SEQ_NRSYNTHS
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|max_synthdev
return|;
break|break;
case|case
name|SNDCTL_SEQ_NRMIDIS
case|:
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|max_mididev
return|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
block|{
name|int
name|dev
init|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
decl_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
operator|&&
operator|!
name|orig_dev
condition|)
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
break|break;
case|case
name|SNDCTL_FM_4OP_ENABLE
case|:
block|{
name|int
name|dev
init|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
decl_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_SYNTH_INFO
case|:
block|{
name|struct
name|synth_info
name|inf
decl_stmt|;
name|int
name|dev
decl_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inf
argument_list|,
sizeof|sizeof
argument_list|(
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|inf
operator|.
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|max_synthdev
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
operator|&&
operator|!
name|orig_dev
condition|)
return|return
operator|-
operator|(
name|EBUSY
operator|)
return|;
return|return
name|synth_devs
index|[
name|dev
index|]
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
break|break;
case|case
name|SNDCTL_SEQ_OUTOFBAND
case|:
block|{
name|struct
name|seq_event_rec
name|event
decl_stmt|;
name|u_long
name|flags
decl_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|event
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|play_event
argument_list|(
name|event
operator|.
name|arr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_MIDI_INFO
case|:
block|{
name|struct
name|midi_info
name|inf
decl_stmt|;
name|int
name|dev
decl_stmt|;
name|bcopy
argument_list|(
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inf
argument_list|,
sizeof|sizeof
argument_list|(
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|inf
operator|.
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|max_mididev
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|midi_devs
index|[
name|dev
index|]
operator|->
name|info
operator|)
argument_list|,
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|inf
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_PMGR_IFACE
case|:
block|{
name|struct
name|patmgr_info
modifier|*
name|inf
decl_stmt|;
name|int
name|dev
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|inf
operator|=
operator|(
expr|struct
name|patmgr_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"patmgr: Can't allocate memory for a message\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|inf
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
block|{
name|free
argument_list|(
name|inf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|synth_devs
index|[
name|dev
index|]
operator|->
name|pmgr_interface
condition|)
block|{
name|free
argument_list|(
name|inf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|pmgr_interface
argument_list|(
name|dev
argument_list|,
name|inf
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|inf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|inf
argument_list|,
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_PMGR_ACCESS
case|:
block|{
name|struct
name|patmgr_info
modifier|*
name|inf
decl_stmt|;
name|int
name|dev
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|inf
operator|=
operator|(
expr|struct
name|patmgr_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"patmgr: Can't allocate memory for a message\n"
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|inf
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
block|{
name|free
argument_list|(
name|inf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|pmgr_present
index|[
name|dev
index|]
condition|)
block|{
name|free
argument_list|(
name|inf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|-
operator|(
name|ESRCH
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|pmgr_access
argument_list|(
name|dev
argument_list|,
name|inf
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|inf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|inf
argument_list|,
operator|&
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
index|[
literal|0
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_SEQ_THRESHOLD
case|:
block|{
name|int
name|tmp
init|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
decl_stmt|;
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|tmp
operator|<
literal|1
condition|)
name|tmp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
name|SEQ_MAX_QUEUE
condition|)
name|tmp
operator|=
name|SEQ_MAX_QUEUE
operator|-
literal|1
expr_stmt|;
name|output_treshold
operator|=
name|tmp
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_MIDI_PRETIME
case|:
block|{
name|int
name|val
init|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|)
decl_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|(
name|hz
operator|*
name|val
operator|)
operator|/
literal|10
expr_stmt|;
name|pre_event_timeout
operator|=
name|val
expr_stmt|;
return|return
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
operator|=
name|val
return|;
block|}
break|break;
default|default:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|mode
operator|==
name|OPEN_READ
condition|)
return|return
operator|-
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|!
name|synth_devs
index|[
literal|0
index|]
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
condition|)
return|return
operator|-
operator|(
name|ENXIO
operator|)
return|;
return|return
name|synth_devs
index|[
literal|0
index|]
operator|->
name|ioctl
argument_list|(
literal|0
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
break|break;
block|}
return|return
operator|-
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALLOW_POLL
end_ifdef

begin_function
name|int
name|sequencer_poll
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|int
name|events
parameter_list|,
name|select_table
modifier|*
name|wait
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|flags
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
if|if
condition|(
operator|!
name|iqlen
condition|)
name|selrecord
argument_list|(
name|wait
argument_list|,
operator|&
name|selinfo
index|[
name|dev
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
name|midi_sleep_flag
operator|.
name|mode
operator|&=
operator|~
name|WK_SLEEP
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
if|if
condition|(
name|qlen
operator|>=
name|SEQ_MAX_QUEUE
condition|)
name|selrecord
argument_list|(
name|wait
argument_list|,
operator|&
name|selinfo
index|[
name|dev
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
name|seq_sleep_flag
operator|.
name|mode
operator|&=
operator|~
name|WK_SLEEP
expr_stmt|;
block|}
name|splx
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sequencer_timer
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|seq_startplay
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|note_to_freq
parameter_list|(
name|int
name|note_num
parameter_list|)
block|{
comment|/*      * This routine converts a midi note to a frequency (multiplied by      * 1000)      */
name|int
name|note
decl_stmt|,
name|octave
decl_stmt|,
name|note_freq
decl_stmt|;
name|int
name|notes
index|[]
init|=
block|{
literal|261632
block|,
literal|277189
block|,
literal|293671
block|,
literal|311132
block|,
literal|329632
block|,
literal|349232
block|,
literal|369998
block|,
literal|391998
block|,
literal|415306
block|,
literal|440000
block|,
literal|466162
block|,
literal|493880
block|}
decl_stmt|;
define|#
directive|define
name|BASE_OCTAVE
value|5
name|octave
operator|=
name|note_num
operator|/
literal|12
expr_stmt|;
name|note
operator|=
name|note_num
operator|%
literal|12
expr_stmt|;
name|note_freq
operator|=
name|notes
index|[
name|note
index|]
expr_stmt|;
if|if
condition|(
name|octave
operator|<
name|BASE_OCTAVE
condition|)
name|note_freq
operator|>>=
operator|(
name|BASE_OCTAVE
operator|-
name|octave
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|octave
operator|>
name|BASE_OCTAVE
condition|)
name|note_freq
operator|<<=
operator|(
name|octave
operator|-
name|BASE_OCTAVE
operator|)
expr_stmt|;
comment|/*      * note_freq>>= 1;      */
return|return
name|note_freq
return|;
block|}
end_function

begin_function
name|u_long
name|compute_finetune
parameter_list|(
name|u_long
name|base_freq
parameter_list|,
name|int
name|bend
parameter_list|,
name|int
name|range
parameter_list|)
block|{
name|u_long
name|amount
decl_stmt|;
name|int
name|negative
decl_stmt|,
name|semitones
decl_stmt|,
name|cents
decl_stmt|,
name|multiplier
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|bend
condition|)
return|return
name|base_freq
return|;
if|if
condition|(
operator|!
name|range
condition|)
return|return
name|base_freq
return|;
if|if
condition|(
operator|!
name|base_freq
condition|)
return|return
name|base_freq
return|;
if|if
condition|(
name|range
operator|>=
literal|8192
condition|)
name|range
operator|=
literal|8192
expr_stmt|;
name|bend
operator|=
name|bend
operator|*
name|range
operator|/
literal|8192
expr_stmt|;
if|if
condition|(
operator|!
name|bend
condition|)
return|return
name|base_freq
return|;
name|negative
operator|=
name|bend
operator|<
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|bend
operator|<
literal|0
condition|)
name|bend
operator|*=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bend
operator|>
name|range
condition|)
name|bend
operator|=
name|range
expr_stmt|;
comment|/*      * if (bend> 2399) bend = 2399;      */
while|while
condition|(
name|bend
operator|>
literal|2399
condition|)
block|{
name|multiplier
operator|*=
literal|4
expr_stmt|;
name|bend
operator|-=
literal|2400
expr_stmt|;
block|}
name|semitones
operator|=
name|bend
operator|/
literal|100
expr_stmt|;
name|cents
operator|=
name|bend
operator|%
literal|100
expr_stmt|;
name|amount
operator|=
call|(
name|int
call|)
argument_list|(
name|semitone_tuning
index|[
name|semitones
index|]
operator|*
name|multiplier
operator|*
name|cent_tuning
index|[
name|cents
index|]
argument_list|)
operator|/
literal|10000
expr_stmt|;
if|if
condition|(
name|negative
condition|)
return|return
operator|(
name|base_freq
operator|*
literal|10000
operator|)
operator|/
name|amount
return|;
comment|/* Bend down */
else|else
return|return
operator|(
name|base_freq
operator|*
name|amount
operator|)
operator|/
literal|10000
return|;
comment|/* Bend up */
block|}
end_function

begin_function
name|void
name|sequencer_init
parameter_list|()
block|{
name|sequencer_ok
operator|=
literal|1
expr_stmt|;
name|queue
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|SEQ_MAX_QUEUE
operator|*
name|EV_SZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|queue
condition|)
name|panic
argument_list|(
literal|"SOUND: Cannot allocate memory\n"
argument_list|)
expr_stmt|;
name|iqueue
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|SEQ_MAX_QUEUE
operator|*
name|IEV_SZ
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iqueue
condition|)
name|panic
argument_list|(
literal|"SOUND: Cannot allocate memory\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

