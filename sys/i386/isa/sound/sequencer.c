begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/sequencer.c  *  * The sequencer personality manager.  *  * Copyright by Hannu Savolainen 1993  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_define
define|#
directive|define
name|SEQUENCER_C
end_define

begin_include
include|#
directive|include
file|<i386/isa/sound/sound_config.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/sound/midi_ctrl.h>
end_include

begin_decl_stmt
specifier|extern
name|void
name|seq_drain_midi_queues
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIGURE_SOUNDCARD
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|EXCLUDE_SEQUENCER
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|sequencer_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sound_timer_operations
modifier|*
name|tmr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tmr_no
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Currently selected timer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pending_timer
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For timer change operation */
end_comment

begin_comment
comment|/*  * Local counts for number of synth and MIDI devices. These are initialized  * by the sequencer_open.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_mididev
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_synthdev
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The seq_mode gives the operating mode of the sequencer:  *      1 = level1 (the default)  *      2 = level2 (extended capabilites)  */
end_comment

begin_define
define|#
directive|define
name|SEQ_1
value|1
end_define

begin_define
define|#
directive|define
name|SEQ_2
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|seq_mode
init|=
name|SEQ_1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_WAIT_QUEUE
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_WAIT_QUEUE
argument_list|(
name|midi_sleeper
argument_list|,
name|midi_sleep_flag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|midi_opened
index|[
name|MAX_MIDI_DEV
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|midi_written
index|[
name|MAX_MIDI_DEV
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|prev_input_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|prev_event_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|seq_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<i386/isa/sound/tuning.h>
end_include

begin_define
define|#
directive|define
name|EV_SZ
value|8
end_define

begin_define
define|#
directive|define
name|IEV_SZ
value|8
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|queue
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|iqueue
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|qhead
init|=
literal|0
decl_stmt|,
name|qtail
init|=
literal|0
decl_stmt|,
name|qlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|iqhead
init|=
literal|0
decl_stmt|,
name|iqtail
init|=
literal|0
decl_stmt|,
name|iqlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|seq_playing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sequencer_busy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|output_treshold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pre_event_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|synth_open_mask
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|seq_queue
parameter_list|(
name|unsigned
name|char
modifier|*
name|note
parameter_list|,
name|char
name|nonblock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seq_startplay
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_sync
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seq_reset
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|pmgr_present
index|[
name|MAX_SYNTH_DEV
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|MAX_SYNTH_DEV
operator|>
literal|15
end_if

begin_error
error|#
directive|error
error|Too many synthesizer devices enabled.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sequencer_read
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|snd_rw_buf
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|c
init|=
name|count
decl_stmt|,
name|p
init|=
literal|0
decl_stmt|;
name|int
name|ev_len
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|ev_len
operator|=
name|seq_mode
operator|==
name|SEQ_1
condition|?
literal|4
else|:
literal|8
expr_stmt|;
if|if
condition|(
name|dev
condition|)
comment|/* 				 * Patch manager device 				 */
return|return
name|pmgr_read
argument_list|(
name|dev
operator|-
literal|1
argument_list|,
name|file
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
return|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iqlen
condition|)
block|{
if|if
condition|(
name|ISSET_FILE_FLAG
argument_list|(
name|file
argument_list|,
name|O_NONBLOCK
argument_list|)
condition|)
block|{
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EAGAIN
argument_list|)
return|;
block|}
name|DO_SLEEP
argument_list|(
name|midi_sleeper
argument_list|,
name|midi_sleep_flag
argument_list|,
name|pre_event_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iqlen
condition|)
block|{
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
while|while
condition|(
name|iqlen
operator|&&
name|c
operator|>=
name|ev_len
condition|)
block|{
name|COPY_TO_USER
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
operator|&
name|iqueue
index|[
name|iqhead
operator|*
name|IEV_SZ
index|]
argument_list|,
name|ev_len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ev_len
expr_stmt|;
name|c
operator|-=
name|ev_len
expr_stmt|;
name|iqhead
operator|=
operator|(
name|iqhead
operator|+
literal|1
operator|)
operator|%
name|SEQ_MAX_QUEUE
expr_stmt|;
name|iqlen
operator|--
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|count
operator|-
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sequencer_midi_output
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
comment|/*    * Currently NOP    */
block|}
end_function

begin_function
name|void
name|seq_copy_to_input
parameter_list|(
name|unsigned
name|char
modifier|*
name|event
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
comment|/*      * Verify that the len is valid for the current mode.    */
if|if
condition|(
name|len
operator|!=
literal|4
operator|&&
name|len
operator|!=
literal|8
condition|)
return|return;
if|if
condition|(
operator|(
name|seq_mode
operator|==
name|SEQ_1
operator|)
operator|!=
operator|(
name|len
operator|==
literal|4
operator|)
condition|)
return|return;
if|if
condition|(
name|iqlen
operator|>=
operator|(
name|SEQ_MAX_QUEUE
operator|-
literal|1
operator|)
condition|)
return|return;
comment|/* Overflow */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|iqueue
index|[
name|iqtail
operator|*
name|IEV_SZ
index|]
argument_list|,
name|event
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|iqlen
operator|++
expr_stmt|;
name|iqtail
operator|=
operator|(
name|iqtail
operator|+
literal|1
operator|)
operator|%
name|SEQ_MAX_QUEUE
expr_stmt|;
if|if
condition|(
name|SOMEONE_WAITING
argument_list|(
name|midi_sleeper
argument_list|,
name|midi_sleep_flag
argument_list|)
condition|)
block|{
name|WAKE_UP
argument_list|(
name|midi_sleeper
argument_list|,
name|midi_sleep_flag
argument_list|)
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
name|selinfo
index|[
literal|0
index|]
operator|.
name|si_pid
condition|)
name|selwakeup
argument_list|(
operator|&
name|selinfo
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sequencer_midi_input
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
block|{
name|unsigned
name|int
name|tstamp
decl_stmt|;
name|unsigned
name|char
name|event
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|0xfe
condition|)
comment|/* Ignore active sensing */
return|return;
name|tstamp
operator|=
name|GET_TIME
argument_list|()
operator|-
name|seq_time
expr_stmt|;
if|if
condition|(
name|tstamp
operator|!=
name|prev_input_time
condition|)
block|{
name|tstamp
operator|=
operator|(
name|tstamp
operator|<<
literal|8
operator|)
operator||
name|SEQ_WAIT
expr_stmt|;
name|seq_copy_to_input
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|tstamp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|prev_input_time
operator|=
name|tstamp
expr_stmt|;
block|}
name|event
index|[
literal|0
index|]
operator|=
name|SEQ_MIDIPUTC
expr_stmt|;
name|event
index|[
literal|1
index|]
operator|=
name|data
expr_stmt|;
name|event
index|[
literal|2
index|]
operator|=
name|dev
expr_stmt|;
name|event
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|seq_copy_to_input
argument_list|(
name|event
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|seq_input_event
parameter_list|(
name|unsigned
name|char
modifier|*
name|event
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|long
name|this_time
decl_stmt|;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
name|this_time
operator|=
name|tmr
operator|->
name|get_time
argument_list|(
name|tmr_no
argument_list|)
expr_stmt|;
else|else
name|this_time
operator|=
name|GET_TIME
argument_list|()
operator|-
name|seq_time
expr_stmt|;
if|if
condition|(
name|this_time
operator|!=
name|prev_input_time
condition|)
block|{
name|unsigned
name|char
name|tmp_event
index|[
literal|8
index|]
decl_stmt|;
name|tmp_event
index|[
literal|0
index|]
operator|=
name|EV_TIMING
expr_stmt|;
name|tmp_event
index|[
literal|1
index|]
operator|=
name|TMR_WAIT_ABS
expr_stmt|;
name|tmp_event
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|tmp_event
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|tmp_event
index|[
literal|4
index|]
operator|=
name|this_time
expr_stmt|;
name|seq_copy_to_input
argument_list|(
name|tmp_event
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|prev_input_time
operator|=
name|this_time
expr_stmt|;
block|}
name|seq_copy_to_input
argument_list|(
name|event
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sequencer_write
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|snd_rw_buf
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|unsigned
name|char
name|event
index|[
name|EV_SZ
index|]
decl_stmt|,
name|ev_code
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|,
name|ev_size
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|mode
init|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
decl_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"sequencer_write(dev=%d, count=%d)\n"
argument_list|,
name|dev
argument_list|,
name|count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|OPEN_READ
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|dev
condition|)
comment|/* 				 * Patch manager device 				 */
return|return
name|pmgr_write
argument_list|(
name|dev
operator|-
literal|1
argument_list|,
name|file
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
return|;
name|c
operator|=
name|count
expr_stmt|;
while|while
condition|(
name|c
operator|>=
literal|4
condition|)
block|{
name|COPY_FROM_USER
argument_list|(
name|event
argument_list|,
name|buf
argument_list|,
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ev_code
operator|=
name|event
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ev_code
operator|==
name|SEQ_FULLSIZE
condition|)
block|{
name|int
name|err
decl_stmt|;
name|dev
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|max_synthdev
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
name|err
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|load_patch
argument_list|(
name|dev
argument_list|,
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
name|p
operator|+
literal|4
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
name|err
return|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|ev_code
operator|>=
literal|128
condition|)
block|{
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
operator|&&
name|ev_code
operator|==
name|SEQ_EXTENDED
condition|)
block|{
name|printk
argument_list|(
literal|"Sequencer: Invalid level 2 event %x\n"
argument_list|,
name|ev_code
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|ev_size
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|ev_size
condition|)
block|{
if|if
condition|(
operator|!
name|seq_playing
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
return|return
name|count
operator|-
name|c
return|;
block|}
name|COPY_FROM_USER
argument_list|(
operator|&
name|event
index|[
literal|4
index|]
argument_list|,
name|buf
argument_list|,
name|p
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|printk
argument_list|(
literal|"Sequencer: 4 byte event in level 2 mode\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|ev_size
operator|=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|event
index|[
literal|0
index|]
operator|==
name|SEQ_MIDIPUTC
condition|)
block|{
if|if
condition|(
operator|!
name|midi_opened
index|[
name|event
index|[
literal|2
index|]
index|]
condition|)
block|{
name|int
name|mode
decl_stmt|;
name|int
name|dev
init|=
name|event
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|dev
operator|>=
name|max_mididev
condition|)
block|{
name|printk
argument_list|(
literal|"Sequencer Error: Nonexistent MIDI device %d\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
name|mode
operator|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|midi_devs
index|[
name|dev
index|]
operator|->
name|open
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|,
name|sequencer_midi_input
argument_list|,
name|sequencer_midi_output
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|seq_reset
argument_list|()
expr_stmt|;
name|printk
argument_list|(
literal|"Sequencer Error: Unable to open Midi #%d\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|midi_opened
index|[
name|dev
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|seq_queue
argument_list|(
name|event
argument_list|,
name|ISSET_FILE_FLAG
argument_list|(
name|file
argument_list|,
name|O_NONBLOCK
argument_list|)
argument_list|)
condition|)
block|{
name|int
name|processed
init|=
name|count
operator|-
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|seq_playing
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|processed
operator|&&
name|ISSET_FILE_FLAG
argument_list|(
name|file
argument_list|,
name|O_NONBLOCK
argument_list|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EAGAIN
argument_list|)
return|;
else|else
return|return
name|processed
return|;
block|}
name|p
operator|+=
name|ev_size
expr_stmt|;
name|c
operator|-=
name|ev_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|seq_playing
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
return|return
name|count
return|;
comment|/* This will "eat" chunks shorter than 4 bytes (if written 				   * alone) Should we really do that ? 				 */
block|}
end_function

begin_function
specifier|static
name|int
name|seq_queue
parameter_list|(
name|unsigned
name|char
modifier|*
name|note
parameter_list|,
name|char
name|nonblock
parameter_list|)
block|{
comment|/*    * Test if there is space in the queue    */
if|if
condition|(
name|qlen
operator|>=
name|SEQ_MAX_QUEUE
condition|)
if|if
condition|(
operator|!
name|seq_playing
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
comment|/* 				 * Give chance to drain the queue 				 */
if|if
condition|(
operator|!
name|nonblock
operator|&&
name|qlen
operator|>=
name|SEQ_MAX_QUEUE
operator|&&
operator|!
name|SOMEONE_WAITING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
block|{
comment|/*        * Sleep until there is enough space on the queue        */
name|DO_SLEEP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qlen
operator|>=
name|SEQ_MAX_QUEUE
condition|)
block|{
return|return
literal|0
return|;
comment|/* 				 * To be sure 				 */
block|}
name|memcpy
argument_list|(
operator|&
name|queue
index|[
name|qtail
operator|*
name|EV_SZ
index|]
argument_list|,
name|note
argument_list|,
name|EV_SZ
argument_list|)
expr_stmt|;
name|qtail
operator|=
operator|(
name|qtail
operator|+
literal|1
operator|)
operator|%
name|SEQ_MAX_QUEUE
expr_stmt|;
name|qlen
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extended_event
parameter_list|(
name|unsigned
name|char
modifier|*
name|q
parameter_list|)
block|{
name|int
name|dev
init|=
name|q
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|max_synthdev
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
switch|switch
condition|(
name|q
index|[
literal|1
index|]
condition|)
block|{
case|case
name|SEQ_NOTEOFF
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|kill_note
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|,
name|q
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_NOTEON
case|:
if|if
condition|(
name|q
index|[
literal|4
index|]
operator|>
literal|127
operator|&&
name|q
index|[
literal|4
index|]
operator|!=
literal|255
condition|)
return|return
literal|0
return|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|start_note
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|,
name|q
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_PGMCHANGE
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|set_instr
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_AFTERTOUCH
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|aftertouch
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_BALANCE
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|panning
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
operator|(
name|char
operator|)
name|q
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_CONTROLLER
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|controller
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|,
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|q
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_VOLMODE
case|:
if|if
condition|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|volume_method
operator|!=
name|NULL
condition|)
name|synth_devs
index|[
name|dev
index|]
operator|->
name|volume_method
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|)
block|{
name|unsigned
name|short
name|key
decl_stmt|;
name|int
name|i
decl_stmt|;
name|key
operator|=
operator|(
name|chn
operator|<<
literal|8
operator|)
operator||
operator|(
name|note
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|max_voice
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|map
index|[
name|i
index|]
operator|==
name|key
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|)
block|{
name|unsigned
name|short
name|key
decl_stmt|;
name|int
name|voice
decl_stmt|;
name|key
operator|=
operator|(
name|chn
operator|<<
literal|8
operator|)
operator||
operator|(
name|note
operator|+
literal|1
operator|)
expr_stmt|;
name|voice
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc_voice
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|note
argument_list|,
operator|&
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
argument_list|)
expr_stmt|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|map
index|[
name|voice
index|]
operator|=
name|key
expr_stmt|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|alloc_times
index|[
name|voice
index|]
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|timestamp
operator|++
expr_stmt|;
return|return
name|voice
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_chn_voice_event
parameter_list|(
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{
name|unsigned
name|char
name|dev
init|=
name|event
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
name|cmd
init|=
name|event
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|char
name|chn
init|=
name|event
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|note
init|=
name|event
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|char
name|parm
init|=
name|event
index|[
literal|5
index|]
decl_stmt|;
name|int
name|voice
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|dev
operator|>
name|max_synthdev
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|synth_devs
index|[
name|dev
index|]
condition|)
return|return;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
if|if
condition|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc_voice
condition|)
name|voice
operator|=
name|find_voice
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|MIDI_NOTEON
operator|&&
name|parm
operator|==
literal|0
condition|)
block|{
name|cmd
operator|=
name|MIDI_NOTEOFF
expr_stmt|;
name|parm
operator|=
literal|64
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MIDI_NOTEON
case|:
if|if
condition|(
name|note
operator|>
literal|127
operator|&&
name|note
operator|!=
literal|255
condition|)
comment|/* Not a seq2 feature */
return|return;
if|if
condition|(
name|voice
operator|==
operator|-
literal|1
operator|&&
name|seq_mode
operator|==
name|SEQ_2
operator|&&
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc_voice
condition|)
block|{
comment|/* Internal synthesizer (FM, GUS, etc) */
name|voice
operator|=
name|alloc_voice
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|note
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|voice
operator|==
operator|-
literal|1
condition|)
name|voice
operator|=
name|chn
expr_stmt|;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
operator|&&
name|dev
operator|<
name|num_synths
condition|)
block|{
comment|/* 	     * The MIDI channel 10 is a percussive channel. Use the note 	     * number to select the proper patch (128 to 255) to play. 	   */
if|if
condition|(
name|chn
operator|==
literal|9
condition|)
block|{
name|synth_devs
index|[
name|dev
index|]
operator|->
name|set_instr
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
literal|128
operator|+
name|note
argument_list|)
expr_stmt|;
name|note
operator|=
literal|60
expr_stmt|;
comment|/* Middle C */
block|}
block|}
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|synth_devs
index|[
name|dev
index|]
operator|->
name|setup_voice
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|chn
argument_list|)
expr_stmt|;
block|}
name|synth_devs
index|[
name|dev
index|]
operator|->
name|start_note
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|note
argument_list|,
name|parm
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_NOTEOFF
case|:
if|if
condition|(
name|voice
operator|==
operator|-
literal|1
condition|)
name|voice
operator|=
name|chn
expr_stmt|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|kill_note
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|note
argument_list|,
name|parm
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_KEY_PRESSURE
case|:
if|if
condition|(
name|voice
operator|==
operator|-
literal|1
condition|)
name|voice
operator|=
name|chn
expr_stmt|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|aftertouch
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|parm
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|seq_chn_common_event
parameter_list|(
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{
name|unsigned
name|char
name|dev
init|=
name|event
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
name|cmd
init|=
name|event
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|char
name|chn
init|=
name|event
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|p1
init|=
name|event
index|[
literal|4
index|]
decl_stmt|;
comment|/* unsigned char   p2 = event[5]; */
name|unsigned
name|short
name|w14
init|=
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|dev
operator|>
name|max_synthdev
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|synth_devs
index|[
name|dev
index|]
condition|)
return|return;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MIDI_PGM_CHANGE
case|:
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|pgm_num
operator|=
name|p1
expr_stmt|;
if|if
condition|(
name|dev
operator|>=
name|num_synths
condition|)
name|synth_devs
index|[
name|dev
index|]
operator|->
name|set_instr
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|)
expr_stmt|;
block|}
else|else
name|synth_devs
index|[
name|dev
index|]
operator|->
name|set_instr
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_CTL_CHANGE
case|:
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
if|if
condition|(
name|chn
operator|>
literal|15
operator|||
name|p1
operator|>
literal|127
condition|)
break|break;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|controllers
index|[
name|p1
index|]
operator|=
name|w14
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|dev
operator|<
name|num_synths
condition|)
block|{
name|int
name|val
init|=
name|w14
operator|&
literal|0x7f
decl_stmt|;
name|int
name|i
decl_stmt|,
name|key
decl_stmt|;
if|if
condition|(
name|p1
operator|<
literal|64
condition|)
comment|/* Combine MSB and LSB */
block|{
name|val
operator|=
operator|(
operator|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|controllers
index|[
name|p1
operator|&
operator|~
literal|32
index|]
operator|&
literal|0x7f
operator|)
operator|<<
literal|7
operator|)
operator||
operator|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|controllers
index|[
name|p1
operator||
literal|32
index|]
operator|&
literal|0x7f
operator|)
expr_stmt|;
name|p1
operator|&=
operator|~
literal|32
expr_stmt|;
block|}
comment|/* Handle all playing notes on this channel */
name|key
operator|=
operator|(
name|chn
operator|<<
literal|8
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|max_voice
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|map
index|[
name|i
index|]
operator|&
literal|0xff00
operator|)
operator|==
name|key
condition|)
name|synth_devs
index|[
name|dev
index|]
operator|->
name|controller
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|p1
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|synth_devs
index|[
name|dev
index|]
operator|->
name|controller
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|,
name|w14
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Mode 1 */
name|synth_devs
index|[
name|dev
index|]
operator|->
name|controller
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|p1
argument_list|,
name|w14
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIDI_PITCH_BEND
case|:
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|bender_value
operator|=
name|w14
expr_stmt|;
if|if
condition|(
name|dev
operator|<
name|num_synths
condition|)
block|{
comment|/* Handle all playing notes on this channel */
name|int
name|i
decl_stmt|,
name|key
decl_stmt|;
name|key
operator|=
operator|(
name|chn
operator|<<
literal|8
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|max_voice
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|synth_devs
index|[
name|dev
index|]
operator|->
name|alloc
operator|.
name|map
index|[
name|i
index|]
operator|&
literal|0xff00
operator|)
operator|==
name|key
condition|)
name|synth_devs
index|[
name|dev
index|]
operator|->
name|bender
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|w14
argument_list|)
expr_stmt|;
block|}
else|else
name|synth_devs
index|[
name|dev
index|]
operator|->
name|bender
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|w14
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* MODE 1 */
name|synth_devs
index|[
name|dev
index|]
operator|->
name|bender
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|w14
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|seq_timing_event
parameter_list|(
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{
name|unsigned
name|char
name|cmd
init|=
name|event
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|parm
init|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|tmr
operator|->
name|event
argument_list|(
name|tmr_no
argument_list|,
name|event
argument_list|)
operator|)
operator|==
name|TIMER_ARMED
condition|)
block|{
if|if
condition|(
operator|(
name|SEQ_MAX_QUEUE
operator|-
name|qlen
operator|)
operator|>=
name|output_treshold
condition|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOMEONE_WAITING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
block|{
name|WAKE_UP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* must issue a wakeup for anyone waiting (select) XXX */
endif|#
directive|endif
block|}
block|}
return|return
name|ret
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TMR_WAIT_REL
case|:
name|parm
operator|+=
name|prev_event_time
expr_stmt|;
comment|/*          * NOTE!  No break here. Execution of TMR_WAIT_REL continues in the          * next case (TMR_WAIT_ABS)        */
case|case
name|TMR_WAIT_ABS
case|:
if|if
condition|(
name|parm
operator|>
literal|0
condition|)
block|{
name|long
name|time
decl_stmt|;
name|seq_playing
operator|=
literal|1
expr_stmt|;
name|time
operator|=
name|parm
expr_stmt|;
name|prev_event_time
operator|=
name|time
expr_stmt|;
name|request_sound_timer
argument_list|(
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SEQ_MAX_QUEUE
operator|-
name|qlen
operator|)
operator|>=
name|output_treshold
condition|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOMEONE_WAITING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
block|{
name|WAKE_UP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* must issue a wakeup for select XXX */
endif|#
directive|endif
block|}
return|return
name|TIMER_ARMED
return|;
block|}
break|break;
case|case
name|TMR_START
case|:
name|seq_time
operator|=
name|GET_TIME
argument_list|()
expr_stmt|;
name|prev_input_time
operator|=
literal|0
expr_stmt|;
name|prev_event_time
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TMR_STOP
case|:
break|break;
case|case
name|TMR_CONTINUE
case|:
break|break;
case|case
name|TMR_TEMPO
case|:
break|break;
case|case
name|TMR_ECHO
case|:
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
name|seq_copy_to_input
argument_list|(
name|event
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
block|{
name|parm
operator|=
operator|(
name|parm
operator|<<
literal|8
operator||
name|SEQ_ECHO
operator|)
expr_stmt|;
name|seq_copy_to_input
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|parm
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
empty_stmt|;
block|}
return|return
name|TIMER_NOT_ARMED
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_local_event
parameter_list|(
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{
comment|/* unsigned char   cmd = event[1]; */
name|printk
argument_list|(
literal|"seq_local_event() called. WHY????????\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|play_event
parameter_list|(
name|unsigned
name|char
modifier|*
name|q
parameter_list|)
block|{
comment|/*      * NOTE! This routine returns      *   0 = normal event played.      *   1 = Timer armed. Suspend playback until timer callback.      *   2 = MIDI output buffer full. Restore queue and suspend until timer    */
name|unsigned
name|long
modifier|*
name|delay
decl_stmt|;
switch|switch
condition|(
name|q
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SEQ_NOTEOFF
case|:
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
if|if
condition|(
name|synth_devs
index|[
literal|0
index|]
condition|)
name|synth_devs
index|[
literal|0
index|]
operator|->
name|kill_note
argument_list|(
literal|0
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|,
literal|255
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_NOTEON
case|:
if|if
condition|(
name|q
index|[
literal|4
index|]
operator|<
literal|128
operator|||
name|q
index|[
literal|4
index|]
operator|==
literal|255
condition|)
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
if|if
condition|(
name|synth_devs
index|[
literal|0
index|]
condition|)
name|synth_devs
index|[
literal|0
index|]
operator|->
name|start_note
argument_list|(
literal|0
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_WAIT
case|:
name|delay
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|q
expr_stmt|;
comment|/* 					 * Bytes 1 to 3 are containing the * 					 * delay in GET_TIME() 					 */
operator|*
name|delay
operator|=
operator|(
operator|*
name|delay
operator|>>
literal|8
operator|)
operator|&
literal|0xffffff
expr_stmt|;
if|if
condition|(
operator|*
name|delay
operator|>
literal|0
condition|)
block|{
name|long
name|time
decl_stmt|;
name|seq_playing
operator|=
literal|1
expr_stmt|;
name|time
operator|=
operator|*
name|delay
expr_stmt|;
name|prev_event_time
operator|=
name|time
expr_stmt|;
name|request_sound_timer
argument_list|(
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SEQ_MAX_QUEUE
operator|-
name|qlen
operator|)
operator|>=
name|output_treshold
condition|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOMEONE_WAITING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
block|{
name|WAKE_UP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* must issue a wakeup for selects XXX */
endif|#
directive|endif
block|}
comment|/* 	     * The timer is now active and will reinvoke this function 	     * after the timer expires. Return to the caller now. 	   */
return|return
literal|1
return|;
block|}
break|break;
case|case
name|SEQ_PGMCHANGE
case|:
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
if|if
condition|(
name|synth_devs
index|[
literal|0
index|]
condition|)
name|synth_devs
index|[
literal|0
index|]
operator|->
name|set_instr
argument_list|(
literal|0
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_SYNCTIMER
case|:
comment|/* 				   * Reset timer 				 */
name|seq_time
operator|=
name|GET_TIME
argument_list|()
expr_stmt|;
name|prev_input_time
operator|=
literal|0
expr_stmt|;
name|prev_event_time
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SEQ_MIDIPUTC
case|:
comment|/* 				 * Put a midi character 				 */
if|if
condition|(
name|midi_opened
index|[
name|q
index|[
literal|2
index|]
index|]
condition|)
block|{
name|int
name|dev
decl_stmt|;
name|dev
operator|=
name|q
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|midi_devs
index|[
name|dev
index|]
operator|->
name|putc
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* 	         * Output FIFO is full. Wait one timer cycle and try again. 	       */
name|seq_playing
operator|=
literal|1
expr_stmt|;
name|request_sound_timer
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
else|else
name|midi_written
index|[
name|dev
index|]
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|SEQ_ECHO
case|:
name|seq_copy_to_input
argument_list|(
name|q
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 				   * Echo back to the process 				 */
break|break;
case|case
name|SEQ_PRIVATE
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|q
index|[
literal|1
index|]
operator|<
name|max_synthdev
condition|)
name|synth_devs
index|[
name|q
index|[
literal|1
index|]
index|]
operator|->
name|hw_control
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_EXTENDED
case|:
name|extended_event
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_CHN_VOICE
case|:
name|seq_chn_voice_event
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_CHN_COMMON
case|:
name|seq_chn_common_event
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|EV_TIMING
case|:
if|if
condition|(
name|seq_timing_event
argument_list|(
name|q
argument_list|)
operator|==
name|TIMER_ARMED
condition|)
block|{
return|return
literal|1
return|;
block|}
break|break;
case|case
name|EV_SEQ_LOCAL
case|:
name|seq_local_event
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_startplay
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|this_one
decl_stmt|,
name|action
decl_stmt|;
while|while
condition|(
name|qlen
operator|>
literal|0
condition|)
block|{
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|qhead
operator|=
operator|(
operator|(
name|this_one
operator|=
name|qhead
operator|)
operator|+
literal|1
operator|)
operator|%
name|SEQ_MAX_QUEUE
expr_stmt|;
name|qlen
operator|--
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|seq_playing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|action
operator|=
name|play_event
argument_list|(
operator|&
name|queue
index|[
name|this_one
operator|*
name|EV_SZ
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* Suspend playback. Next timer routine invokes this routine again */
if|if
condition|(
name|action
operator|==
literal|2
condition|)
block|{
name|qlen
operator|++
expr_stmt|;
name|qhead
operator|=
name|this_one
expr_stmt|;
block|}
return|return;
block|}
block|}
name|seq_playing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|SEQ_MAX_QUEUE
operator|-
name|qlen
operator|)
operator|>=
name|output_treshold
condition|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOMEONE_WAITING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
block|{
name|WAKE_UP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* must issue a wakeup for selects XXX */
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|reset_controllers
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
modifier|*
name|controller
parameter_list|,
name|int
name|update_dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
name|controller
index|[
name|i
index|]
operator|=
name|ctrl_def_values
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_mode2
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|dev
decl_stmt|;
name|max_synthdev
operator|=
name|num_synths
expr_stmt|;
for|for
control|(
name|dev
operator|=
literal|0
init|;
name|dev
operator|<
name|num_midis
condition|;
name|dev
operator|++
control|)
if|if
condition|(
name|midi_devs
index|[
name|dev
index|]
operator|->
name|converter
operator|!=
name|NULL
condition|)
block|{
name|synth_devs
index|[
name|max_synthdev
operator|++
index|]
operator|=
name|midi_devs
index|[
name|dev
index|]
operator|->
name|converter
expr_stmt|;
block|}
for|for
control|(
name|dev
operator|=
literal|0
init|;
name|dev
operator|<
name|max_synthdev
condition|;
name|dev
operator|++
control|)
block|{
name|int
name|chn
decl_stmt|;
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
literal|16
condition|;
name|chn
operator|++
control|)
block|{
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|pgm_num
operator|=
literal|0
expr_stmt|;
name|reset_controllers
argument_list|(
name|dev
argument_list|,
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|controllers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|.
name|bender_value
operator|=
operator|(
literal|1
operator|<<
literal|7
operator|)
expr_stmt|;
comment|/* Neutral */
block|}
block|}
name|max_mididev
operator|=
literal|0
expr_stmt|;
name|seq_mode
operator|=
name|SEQ_2
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sequencer_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|)
block|{
name|int
name|retval
decl_stmt|,
name|mode
decl_stmt|,
name|i
decl_stmt|;
name|int
name|level
decl_stmt|,
name|tmp
decl_stmt|;
name|level
operator|=
operator|(
operator|(
name|dev
operator|&
literal|0x0f
operator|)
operator|==
name|SND_DEV_SEQ2
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|mode
operator|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
expr_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"sequencer_open(dev=%d)\n"
argument_list|,
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sequencer_ok
condition|)
block|{
name|printk
argument_list|(
literal|"Soundcard: Sequencer not initialized\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
if|if
condition|(
name|dev
condition|)
comment|/* 				 * Patch manager device 				 */
block|{
name|int
name|err
decl_stmt|;
name|dev
operator|--
expr_stmt|;
if|if
condition|(
name|dev
operator|>=
name|MAX_SYNTH_DEV
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
name|pmgr_present
index|[
name|dev
index|]
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|pmgr_open
argument_list|(
name|dev
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|err
return|;
comment|/* 				 * Failed 				 */
name|pmgr_present
index|[
name|dev
index|]
operator|=
literal|1
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|sequencer_busy
condition|)
block|{
name|printk
argument_list|(
literal|"Sequencer busy\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
name|max_mididev
operator|=
name|num_midis
expr_stmt|;
name|max_synthdev
operator|=
name|num_synths
expr_stmt|;
name|pre_event_timeout
operator|=
literal|0
expr_stmt|;
name|seq_mode
operator|=
name|SEQ_1
expr_stmt|;
if|if
condition|(
name|pending_timer
operator|!=
operator|-
literal|1
condition|)
block|{
name|tmr_no
operator|=
name|pending_timer
expr_stmt|;
name|pending_timer
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tmr_no
operator|==
operator|-
literal|1
condition|)
comment|/* Not selected yet */
block|{
name|int
name|i
decl_stmt|,
name|best
decl_stmt|;
name|best
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_sound_timers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sound_timer_devs
index|[
name|i
index|]
operator|->
name|priority
operator|>
name|best
condition|)
block|{
name|tmr_no
operator|=
name|i
expr_stmt|;
name|best
operator|=
name|sound_timer_devs
index|[
name|i
index|]
operator|->
name|priority
expr_stmt|;
block|}
if|if
condition|(
name|tmr_no
operator|==
operator|-
literal|1
condition|)
comment|/* Should not be */
name|tmr_no
operator|=
literal|0
expr_stmt|;
block|}
name|tmr
operator|=
name|sound_timer_devs
index|[
name|tmr_no
index|]
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|tmr
operator|==
name|NULL
condition|)
block|{
name|printk
argument_list|(
literal|"sequencer: No timer for level 2\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
name|setup_mode2
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_1
operator|&&
operator|(
name|mode
operator|==
name|OPEN_READ
operator|||
name|mode
operator|==
name|OPEN_READWRITE
operator|)
condition|)
if|if
condition|(
operator|!
name|max_mididev
condition|)
block|{
name|printk
argument_list|(
literal|"Sequencer: No Midi devices. Input not possible\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|max_synthdev
operator|&&
operator|!
name|max_mididev
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
name|synth_open_mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_mididev
condition|;
name|i
operator|++
control|)
block|{
name|midi_opened
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|midi_written
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/*    * if (mode == OPEN_WRITE || mode == OPEN_READWRITE)    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_synthdev
condition|;
name|i
operator|++
control|)
comment|/* 					 * Open synth devices 					 */
if|if
condition|(
operator|(
name|tmp
operator|=
name|synth_devs
index|[
name|i
index|]
operator|->
name|open
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"Sequencer: Warning! Cannot open synth device #%d (%d)\n"
argument_list|,
name|i
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
operator|->
name|midi_dev
condition|)
name|printk
argument_list|(
literal|"(Maps to MIDI dev #%d)\n"
argument_list|,
name|synth_devs
index|[
name|i
index|]
operator|->
name|midi_dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|synth_open_mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
operator|->
name|midi_dev
condition|)
comment|/* 					 * Is a midi interface 					 */
name|midi_opened
index|[
name|synth_devs
index|[
name|i
index|]
operator|->
name|midi_dev
index|]
operator|=
literal|1
expr_stmt|;
block|}
name|seq_time
operator|=
name|GET_TIME
argument_list|()
expr_stmt|;
name|prev_input_time
operator|=
literal|0
expr_stmt|;
name|prev_event_time
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_1
operator|&&
operator|(
name|mode
operator|==
name|OPEN_READ
operator|||
name|mode
operator|==
name|OPEN_READWRITE
operator|)
condition|)
block|{
comment|/* 				 * Initialize midi input devices 				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_mididev
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|midi_opened
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|retval
operator|=
name|midi_devs
index|[
name|i
index|]
operator|->
name|open
argument_list|(
name|i
argument_list|,
name|mode
argument_list|,
name|sequencer_midi_input
argument_list|,
name|sequencer_midi_output
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|midi_opened
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
name|tmr
operator|->
name|open
argument_list|(
name|tmr_no
argument_list|,
name|seq_mode
argument_list|)
expr_stmt|;
block|}
name|sequencer_busy
operator|=
literal|1
expr_stmt|;
name|RESET_WAIT_QUEUE
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
expr_stmt|;
name|RESET_WAIT_QUEUE
argument_list|(
name|midi_sleeper
argument_list|,
name|midi_sleep_flag
argument_list|)
expr_stmt|;
name|output_treshold
operator|=
name|SEQ_MAX_QUEUE
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_synths
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pmgr_present
index|[
name|i
index|]
condition|)
name|pmgr_inform
argument_list|(
name|i
argument_list|,
name|PM_E_OPENED
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|seq_drain_midi_queues
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/*    * Give the Midi drivers time to drain their output queues    */
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|PROCESS_ABORTING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
operator|&&
name|n
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_mididev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|midi_opened
index|[
name|i
index|]
operator|&&
name|midi_written
index|[
name|i
index|]
condition|)
if|if
condition|(
name|midi_devs
index|[
name|i
index|]
operator|->
name|buffer_status
operator|!=
name|NULL
condition|)
if|if
condition|(
name|midi_devs
index|[
name|i
index|]
operator|->
name|buffer_status
argument_list|(
name|i
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
comment|/*        * Let's have a delay        */
if|if
condition|(
name|n
condition|)
block|{
name|DO_SLEEP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|,
name|HZ
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sequencer_release
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|mode
init|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
decl_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"sequencer_release(dev=%d)\n"
argument_list|,
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
condition|)
comment|/* 				 * Patch manager device 				 */
block|{
name|dev
operator|--
expr_stmt|;
name|pmgr_release
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pmgr_present
index|[
name|dev
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*    * * Wait until the queue is empty (if we don't have nonblock)    */
if|if
condition|(
name|mode
operator|!=
name|OPEN_READ
operator|&&
operator|!
name|ISSET_FILE_FLAG
argument_list|(
name|file
argument_list|,
name|O_NONBLOCK
argument_list|)
condition|)
while|while
condition|(
operator|!
name|PROCESS_ABORTING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
operator|&&
name|qlen
condition|)
block|{
name|seq_sync
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|OPEN_READ
condition|)
name|seq_drain_midi_queues
argument_list|()
expr_stmt|;
comment|/* 				 * Ensure the output queues are empty 				 */
name|seq_reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|OPEN_READ
condition|)
name|seq_drain_midi_queues
argument_list|()
expr_stmt|;
comment|/* 				 * Flush the all notes off messages 				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_synthdev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
comment|/* 					 * Actually opened 					 */
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
condition|)
block|{
name|synth_devs
index|[
name|i
index|]
operator|->
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
operator|->
name|midi_dev
condition|)
name|midi_opened
index|[
name|synth_devs
index|[
name|i
index|]
operator|->
name|midi_dev
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_synths
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pmgr_present
index|[
name|i
index|]
condition|)
name|pmgr_inform
argument_list|(
name|i
argument_list|,
name|PM_E_CLOSED
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_mididev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|midi_opened
index|[
name|i
index|]
condition|)
name|midi_devs
index|[
name|i
index|]
operator|->
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
name|tmr
operator|->
name|close
argument_list|(
name|tmr_no
argument_list|)
expr_stmt|;
name|sequencer_busy
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_sync
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
if|if
condition|(
name|qlen
operator|&&
operator|!
name|seq_playing
operator|&&
operator|!
name|PROCESS_ABORTING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|qlen
operator|&&
operator|!
name|SOMEONE_WAITING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
block|{
name|DO_SLEEP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|qlen
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|midi_outc
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
block|{
comment|/*    * NOTE! Calls sleep(). Don't call this from interrupt.    */
name|int
name|n
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
comment|/*    * This routine sends one byte to the Midi channel.    * If the output Fifo is full, it waits until there    * is space in the queue    */
name|n
operator|=
literal|3
operator|*
name|HZ
expr_stmt|;
comment|/* Timeout */
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|&&
operator|!
name|midi_devs
index|[
name|dev
index|]
operator|->
name|putc
argument_list|(
name|dev
argument_list|,
name|data
argument_list|)
condition|)
block|{
name|DO_SLEEP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_reset
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*    * NOTE! Calls sleep(). Don't call this from interrupt.    */
name|int
name|i
decl_stmt|;
name|int
name|chn
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|sound_stop_timer
argument_list|()
expr_stmt|;
name|seq_time
operator|=
name|GET_TIME
argument_list|()
expr_stmt|;
name|prev_input_time
operator|=
literal|0
expr_stmt|;
name|prev_event_time
operator|=
literal|0
expr_stmt|;
name|qlen
operator|=
name|qhead
operator|=
name|qtail
operator|=
literal|0
expr_stmt|;
name|iqlen
operator|=
name|iqhead
operator|=
name|iqtail
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_synthdev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
condition|)
name|synth_devs
index|[
name|i
index|]
operator|->
name|reset
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
block|{
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
literal|16
condition|;
name|chn
operator|++
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_synthdev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
condition|)
block|{
name|synth_devs
index|[
name|i
index|]
operator|->
name|controller
argument_list|(
name|i
argument_list|,
name|chn
argument_list|,
literal|123
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* All notes off */
name|synth_devs
index|[
name|i
index|]
operator|->
name|controller
argument_list|(
name|i
argument_list|,
name|chn
argument_list|,
literal|121
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset all ctl */
name|synth_devs
index|[
name|i
index|]
operator|->
name|bender
argument_list|(
name|i
argument_list|,
name|chn
argument_list|,
literal|1
operator|<<
literal|13
argument_list|)
expr_stmt|;
comment|/* Bender off */
block|}
block|}
else|else
comment|/* seq_mode == SEQ_1 */
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_mididev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|midi_written
index|[
name|i
index|]
condition|)
comment|/* 				 * Midi used. Some notes may still be playing 				 */
block|{
comment|/* 	       *      Sending just a ACTIVE SENSING message should be enough to stop all 	       *      playing notes. Since there are devices not recognizing the 	       *      active sensing, we have to send some all notes off messages also. 	     */
name|midi_outc
argument_list|(
name|i
argument_list|,
literal|0xfe
argument_list|)
expr_stmt|;
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
literal|16
condition|;
name|chn
operator|++
control|)
block|{
name|midi_outc
argument_list|(
name|i
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|0xb0
operator|+
operator|(
name|chn
operator|&
literal|0x0f
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* control change */
name|midi_outc
argument_list|(
name|i
argument_list|,
literal|0x7b
argument_list|)
expr_stmt|;
comment|/* All notes off */
name|midi_outc
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Dummy parameter */
block|}
name|midi_devs
index|[
name|i
index|]
operator|->
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|midi_written
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|midi_opened
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|seq_playing
operator|=
literal|0
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOMEONE_WAITING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
block|{
comment|/*      printk ("Sequencer Warning: Unexpected sleeping process - Waking up\n"); */
name|WAKE_UP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_panic
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*      * This routine is called by the application in case the user      * wants to reset the system to the default state.    */
name|seq_reset
argument_list|()
expr_stmt|;
comment|/*      * Since some of the devices don't recognize the active sensing and      * all notes off messages, we have to shut all notes manually.      *      *      TO BE IMPLEMENTED LATER    */
comment|/*      * Also return the controllers to their default states    */
block|}
end_function

begin_function
name|int
name|sequencer_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|arg
parameter_list|)
block|{
name|int
name|midi_dev
decl_stmt|,
name|orig_dev
decl_stmt|;
name|int
name|mode
init|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
decl_stmt|;
name|orig_dev
operator|=
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_TMR_TIMEBASE
case|:
case|case
name|SNDCTL_TMR_TEMPO
case|:
case|case
name|SNDCTL_TMR_START
case|:
case|case
name|SNDCTL_TMR_STOP
case|:
case|case
name|SNDCTL_TMR_CONTINUE
case|:
case|case
name|SNDCTL_TMR_METRONOME
case|:
case|case
name|SNDCTL_TMR_SOURCE
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|seq_mode
operator|!=
name|SEQ_2
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
return|return
name|tmr
operator|->
name|ioctl
argument_list|(
name|tmr_no
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_TMR_SELECT
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|seq_mode
operator|!=
name|SEQ_2
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|pending_timer
operator|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_timer
operator|<
literal|0
operator|||
name|pending_timer
operator|>=
name|num_sound_timers
condition|)
block|{
name|pending_timer
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|pending_timer
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_SEQ_PANIC
case|:
name|seq_panic
argument_list|()
expr_stmt|;
break|break;
case|case
name|SNDCTL_SEQ_SYNC
case|:
if|if
condition|(
name|dev
condition|)
comment|/* 				 * Patch manager 				 */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|OPEN_READ
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|qlen
operator|&&
operator|!
name|PROCESS_ABORTING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
name|seq_sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|qlen
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINTR
argument_list|)
return|;
else|else
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_RESET
case|:
if|if
condition|(
name|dev
condition|)
comment|/* 				 * Patch manager 				 */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|seq_reset
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_TESTMIDI
case|:
if|if
condition|(
name|dev
condition|)
comment|/* 				 * Patch manager 				 */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|midi_dev
operator|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|midi_dev
operator|>=
name|max_mididev
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
name|midi_opened
index|[
name|midi_dev
index|]
condition|)
block|{
name|int
name|err
decl_stmt|,
name|mode
decl_stmt|;
name|mode
operator|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|open
argument_list|(
name|midi_dev
argument_list|,
name|mode
argument_list|,
name|sequencer_midi_input
argument_list|,
name|sequencer_midi_output
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|err
return|;
block|}
name|midi_opened
index|[
name|midi_dev
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_GETINCOUNT
case|:
if|if
condition|(
name|dev
condition|)
comment|/* 				 * Patch manager 				 */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|OPEN_WRITE
condition|)
return|return
literal|0
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|iqlen
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_SEQ_GETOUTCOUNT
case|:
if|if
condition|(
name|mode
operator|==
name|OPEN_READ
condition|)
return|return
literal|0
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|SEQ_MAX_QUEUE
operator|-
name|qlen
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_SEQ_CTRLRATE
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
comment|/*        * If *arg == 0, just return the current rate        */
if|if
condition|(
name|seq_mode
operator|==
name|SEQ_2
condition|)
return|return
name|tmr
operator|->
name|ioctl
argument_list|(
name|tmr_no
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
if|if
condition|(
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|HZ
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_SEQ_RESETSAMPLES
case|:
name|dev
operator|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
operator|&&
operator|!
name|orig_dev
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
if|if
condition|(
operator|!
name|orig_dev
operator|&&
name|pmgr_present
index|[
name|dev
index|]
condition|)
name|pmgr_inform
argument_list|(
name|dev
argument_list|,
name|PM_E_PATCH_RESET
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|synth_devs
index|[
name|dev
index|]
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_SEQ_NRSYNTHS
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|max_synthdev
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_SEQ_NRMIDIS
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|max_mididev
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
block|{
name|int
name|dev
init|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
operator|&&
operator|!
name|orig_dev
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|synth_devs
index|[
name|dev
index|]
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|SNDCTL_FM_4OP_ENABLE
case|:
block|{
name|int
name|dev
init|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_SYNTH_INFO
case|:
block|{
name|struct
name|synth_info
name|inf
decl_stmt|;
name|int
name|dev
decl_stmt|;
name|IOCTL_FROM_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|inf
operator|.
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|max_synthdev
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
operator|&&
operator|!
name|orig_dev
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
return|return
name|synth_devs
index|[
name|dev
index|]
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
break|break;
case|case
name|SNDCTL_SEQ_OUTOFBAND
case|:
block|{
name|struct
name|seq_event_rec
name|event
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|IOCTL_FROM_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|event
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|play_event
argument_list|(
name|event
operator|.
name|arr
argument_list|)
expr_stmt|;
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_MIDI_INFO
case|:
block|{
name|struct
name|midi_info
name|inf
decl_stmt|;
name|int
name|dev
decl_stmt|;
name|IOCTL_FROM_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|inf
operator|.
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|max_mididev
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
name|IOCTL_TO_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|midi_devs
index|[
name|dev
index|]
operator|->
name|info
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|inf
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_PMGR_IFACE
case|:
block|{
name|struct
name|patmgr_info
modifier|*
name|inf
decl_stmt|;
name|int
name|dev
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|inf
operator|=
operator|(
expr|struct
name|patmgr_info
operator|*
operator|)
name|KERNEL_MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printk
argument_list|(
literal|"patmgr: Can't allocate memory for a message\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|IOCTL_FROM_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|inf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|inf
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
block|{
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|synth_devs
index|[
name|dev
index|]
operator|->
name|pmgr_interface
condition|)
block|{
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|pmgr_interface
argument_list|(
name|dev
argument_list|,
name|inf
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|IOCTL_TO_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_PMGR_ACCESS
case|:
block|{
name|struct
name|patmgr_info
modifier|*
name|inf
decl_stmt|;
name|int
name|dev
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|inf
operator|=
operator|(
expr|struct
name|patmgr_info
operator|*
operator|)
name|KERNEL_MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printk
argument_list|(
literal|"patmgr: Can't allocate memory for a message\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
name|IOCTL_FROM_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|inf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|inf
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
block|{
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|pmgr_present
index|[
name|dev
index|]
condition|)
block|{
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ESRCH
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|pmgr_access
argument_list|(
name|dev
argument_list|,
name|inf
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|IOCTL_TO_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_SEQ_TRESHOLD
case|:
block|{
name|int
name|tmp
init|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
condition|)
comment|/* 				 * Patch manager 				 */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|tmp
operator|<
literal|1
condition|)
name|tmp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
name|SEQ_MAX_QUEUE
condition|)
name|tmp
operator|=
name|SEQ_MAX_QUEUE
operator|-
literal|1
expr_stmt|;
name|output_treshold
operator|=
name|tmp
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_MIDI_PRETIME
case|:
block|{
name|int
name|val
init|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
name|val
operator|=
operator|(
name|HZ
operator|*
name|val
operator|)
operator|/
literal|10
expr_stmt|;
name|pre_event_timeout
operator|=
name|val
expr_stmt|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|val
argument_list|)
return|;
block|}
break|break;
default|default:
if|if
condition|(
name|dev
condition|)
comment|/* 				 * Patch manager 				 */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|OPEN_READ
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
operator|!
name|synth_devs
index|[
literal|0
index|]
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
return|return
name|synth_devs
index|[
literal|0
index|]
operator|->
name|ioctl
argument_list|(
literal|0
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
break|break;
block|}
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALLOW_SELECT
end_ifdef

begin_function
name|int
name|sequencer_poll
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|int
name|events
parameter_list|,
name|select_table
modifier|*
name|wait
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
if|if
condition|(
operator|!
name|iqlen
condition|)
name|selrecord
argument_list|(
name|wait
argument_list|,
operator|&
name|selinfo
index|[
name|dev
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
name|midi_sleep_flag
operator|.
name|mode
operator|&=
operator|~
name|WK_SLEEP
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
if|if
condition|(
name|qlen
operator|>=
name|SEQ_MAX_QUEUE
condition|)
name|selrecord
argument_list|(
name|wait
argument_list|,
operator|&
name|selinfo
index|[
name|dev
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
name|seq_sleep_flag
operator|.
name|mode
operator|&=
operator|~
name|WK_SLEEP
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sequencer_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|seq_startplay
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|note_to_freq
parameter_list|(
name|int
name|note_num
parameter_list|)
block|{
comment|/*    * This routine converts a midi note to a frequency (multiplied by 1000)    */
name|int
name|note
decl_stmt|,
name|octave
decl_stmt|,
name|note_freq
decl_stmt|;
name|int
name|notes
index|[]
init|=
block|{
literal|261632
block|,
literal|277189
block|,
literal|293671
block|,
literal|311132
block|,
literal|329632
block|,
literal|349232
block|,
literal|369998
block|,
literal|391998
block|,
literal|415306
block|,
literal|440000
block|,
literal|466162
block|,
literal|493880
block|}
decl_stmt|;
define|#
directive|define
name|BASE_OCTAVE
value|5
name|octave
operator|=
name|note_num
operator|/
literal|12
expr_stmt|;
name|note
operator|=
name|note_num
operator|%
literal|12
expr_stmt|;
name|note_freq
operator|=
name|notes
index|[
name|note
index|]
expr_stmt|;
if|if
condition|(
name|octave
operator|<
name|BASE_OCTAVE
condition|)
name|note_freq
operator|>>=
operator|(
name|BASE_OCTAVE
operator|-
name|octave
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|octave
operator|>
name|BASE_OCTAVE
condition|)
name|note_freq
operator|<<=
operator|(
name|octave
operator|-
name|BASE_OCTAVE
operator|)
expr_stmt|;
comment|/*    * note_freq>>= 1;    */
return|return
name|note_freq
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|compute_finetune
parameter_list|(
name|unsigned
name|long
name|base_freq
parameter_list|,
name|int
name|bend
parameter_list|,
name|int
name|range
parameter_list|)
block|{
name|unsigned
name|long
name|amount
decl_stmt|;
name|int
name|negative
decl_stmt|,
name|semitones
decl_stmt|,
name|cents
decl_stmt|,
name|multiplier
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|bend
condition|)
return|return
name|base_freq
return|;
if|if
condition|(
operator|!
name|range
condition|)
return|return
name|base_freq
return|;
if|if
condition|(
operator|!
name|base_freq
condition|)
return|return
name|base_freq
return|;
if|if
condition|(
name|range
operator|>=
literal|8192
condition|)
name|range
operator|=
literal|8191
expr_stmt|;
name|bend
operator|=
name|bend
operator|*
name|range
operator|/
literal|8192
expr_stmt|;
if|if
condition|(
operator|!
name|bend
condition|)
return|return
name|base_freq
return|;
name|negative
operator|=
name|bend
operator|<
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|bend
operator|<
literal|0
condition|)
name|bend
operator|*=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bend
operator|>
name|range
condition|)
name|bend
operator|=
name|range
expr_stmt|;
comment|/*      if (bend> 2399)      bend = 2399;    */
while|while
condition|(
name|bend
operator|>
literal|2399
condition|)
block|{
name|multiplier
operator|*=
literal|4
expr_stmt|;
name|bend
operator|-=
literal|2400
expr_stmt|;
block|}
name|semitones
operator|=
name|bend
operator|/
literal|100
expr_stmt|;
name|cents
operator|=
name|bend
operator|%
literal|100
expr_stmt|;
name|amount
operator|=
call|(
name|int
call|)
argument_list|(
name|semitone_tuning
index|[
name|semitones
index|]
operator|*
name|multiplier
operator|*
name|cent_tuning
index|[
name|cents
index|]
argument_list|)
operator|/
literal|10000
expr_stmt|;
if|if
condition|(
name|negative
condition|)
return|return
operator|(
name|base_freq
operator|*
literal|10000
operator|)
operator|/
name|amount
return|;
comment|/* 						 * Bend down 						 */
else|else
return|return
operator|(
name|base_freq
operator|*
name|amount
operator|)
operator|/
literal|10000
return|;
comment|/* 						 * Bend up 						 */
block|}
end_function

begin_function
name|long
name|sequencer_init
parameter_list|(
name|long
name|mem_start
parameter_list|)
block|{
name|sequencer_ok
operator|=
literal|1
expr_stmt|;
name|PERMANENT_MALLOC
argument_list|(
argument|unsigned char *
argument_list|,
argument|queue
argument_list|,
argument|SEQ_MAX_QUEUE * EV_SZ
argument_list|,
argument|mem_start
argument_list|)
empty_stmt|;
name|PERMANENT_MALLOC
argument_list|(
argument|unsigned char *
argument_list|,
argument|iqueue
argument_list|,
argument|SEQ_MAX_QUEUE * IEV_SZ
argument_list|,
argument|mem_start
argument_list|)
empty_stmt|;
return|return
name|mem_start
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Stub version  */
end_comment

begin_function
name|int
name|sequencer_read
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|snd_rw_buf
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sequencer_write
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|snd_rw_buf
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sequencer_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|sequencer_release
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|)
block|{ }
end_function

begin_function
name|int
name|sequencer_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|arg
parameter_list|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sequencer_lseek
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|orig
parameter_list|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
end_function

begin_function
name|long
name|sequencer_init
parameter_list|(
name|long
name|mem_start
parameter_list|)
block|{
return|return
name|mem_start
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALLOW_SELECT
end_ifdef

begin_function
name|int
name|sequencer_poll
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|int
name|events
parameter_list|,
name|select_table
modifier|*
name|wait
parameter_list|)
block|{
return|return
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLOUT
operator||
name|POLLRDNORM
operator||
name|POLLWRNORM
operator||
name|POLLHUP
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

