begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/sequencer.c  *   * The sequencer personality manager.  *   * Copyright by Hannu Savolainen 1993  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   */
end_comment

begin_define
define|#
directive|define
name|SEQUENCER_C
end_define

begin_include
include|#
directive|include
file|"sound_config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIGURE_SOUNDCARD
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|EXCLUDE_SEQUENCER
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|sequencer_ok
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_WAIT_QUEUE
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* DEFINE_WAIT_QUEUE (midi_sleeper, midi_sleep_flag); */
end_comment

begin_define
define|#
directive|define
name|midi_sleeper
value|seq_sleeper
end_define

begin_define
define|#
directive|define
name|midi_sleep_flag
value|seq_sleep_flag
end_define

begin_decl_stmt
specifier|static
name|int
name|midi_opened
index|[
name|MAX_MIDI_DEV
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 if the process has opened MIDI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|midi_written
index|[
name|MAX_MIDI_DEV
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|long
name|seq_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Reference point for the timer */
end_comment

begin_include
include|#
directive|include
file|"tuning.h"
end_include

begin_define
define|#
directive|define
name|EV_SZ
value|8
end_define

begin_define
define|#
directive|define
name|IEV_SZ
value|4
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|queue
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SEQ_MAX_QUEUE * EV_SZ bytes */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|iqueue
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SEQ_MAX_QUEUE * IEV_SZ bytes */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|qhead
init|=
literal|0
decl_stmt|,
name|qtail
init|=
literal|0
decl_stmt|,
name|qlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|iqhead
init|=
literal|0
decl_stmt|,
name|iqtail
init|=
literal|0
decl_stmt|,
name|iqlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|seq_playing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sequencer_busy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|output_treshold
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|synth_open_mask
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|seq_queue
parameter_list|(
name|unsigned
name|char
modifier|*
name|note
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seq_startplay
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|seq_sync
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|seq_reset
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|pmgr_present
index|[
name|MAX_SYNTH_DEV
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|MAX_SYNTH_DEV
operator|>
literal|15
end_if

begin_error
error|#
directive|error
error|Too many synthesizer devices
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sequencer_read
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|snd_rw_buf
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|c
init|=
name|count
decl_stmt|,
name|p
init|=
literal|0
decl_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager device */
return|return
name|pmgr_read
argument_list|(
name|dev
operator|-
literal|1
argument_list|,
name|file
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
return|;
while|while
condition|(
name|c
operator|>
literal|3
condition|)
block|{
if|if
condition|(
operator|!
name|iqlen
condition|)
block|{
name|DO_SLEEP
argument_list|(
name|midi_sleeper
argument_list|,
name|midi_sleep_flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iqlen
condition|)
return|return
name|count
operator|-
name|c
return|;
block|}
name|COPY_TO_USER
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
operator|&
name|iqueue
index|[
name|iqhead
operator|*
name|IEV_SZ
index|]
argument_list|,
name|IEV_SZ
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|c
operator|-=
literal|4
expr_stmt|;
name|iqhead
operator|=
operator|(
name|iqhead
operator|+
literal|1
operator|)
operator|%
name|SEQ_MAX_QUEUE
expr_stmt|;
name|iqlen
operator|--
expr_stmt|;
block|}
return|return
name|count
operator|-
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sequencer_midi_output
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
comment|/* Currently NOP */
block|}
end_function

begin_function
specifier|static
name|void
name|copy_to_input
parameter_list|(
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
if|if
condition|(
name|iqlen
operator|>=
operator|(
name|SEQ_MAX_QUEUE
operator|-
literal|1
operator|)
condition|)
return|return;
comment|/* Overflow */
name|memcpy
argument_list|(
operator|&
name|iqueue
index|[
name|iqtail
operator|*
name|IEV_SZ
index|]
argument_list|,
name|event
argument_list|,
name|IEV_SZ
argument_list|)
expr_stmt|;
name|iqlen
operator|++
expr_stmt|;
name|iqtail
operator|=
operator|(
name|iqtail
operator|+
literal|1
operator|)
operator|%
name|SEQ_MAX_QUEUE
expr_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOMEONE_WAITING
argument_list|(
name|midi_sleeper
argument_list|,
name|midi_sleep_flag
argument_list|)
condition|)
block|{
name|WAKE_UP
argument_list|(
name|midi_sleeper
argument_list|,
name|midi_sleep_flag
argument_list|)
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sequencer_midi_input
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
block|{
name|int
name|tstamp
decl_stmt|;
name|unsigned
name|char
name|event
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|data
operator|==
literal|0xfe
condition|)
comment|/* Active sensing */
return|return;
comment|/* Ignore */
name|tstamp
operator|=
name|GET_TIME
argument_list|()
operator|-
name|seq_time
expr_stmt|;
comment|/* Time since open() */
name|tstamp
operator|=
operator|(
name|tstamp
operator|<<
literal|8
operator|)
operator||
name|SEQ_WAIT
expr_stmt|;
name|copy_to_input
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|tstamp
argument_list|)
expr_stmt|;
name|event
index|[
literal|0
index|]
operator|=
name|SEQ_MIDIPUTC
expr_stmt|;
name|event
index|[
literal|1
index|]
operator|=
name|data
expr_stmt|;
name|event
index|[
literal|2
index|]
operator|=
name|dev
expr_stmt|;
name|event
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|copy_to_input
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sequencer_write
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|snd_rw_buf
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|unsigned
name|char
name|event
index|[
name|EV_SZ
index|]
decl_stmt|,
name|ev_code
decl_stmt|;
name|int
name|p
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|,
name|ev_size
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|mode
init|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
decl_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"sequencer_write(dev=%d, count=%d)\n"
argument_list|,
name|dev
argument_list|,
name|count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|OPEN_READ
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager device */
return|return
name|pmgr_write
argument_list|(
name|dev
operator|-
literal|1
argument_list|,
name|file
argument_list|,
name|buf
argument_list|,
name|count
argument_list|)
return|;
name|c
operator|=
name|count
expr_stmt|;
while|while
condition|(
name|c
operator|>=
literal|4
condition|)
block|{
name|COPY_FROM_USER
argument_list|(
name|event
argument_list|,
name|buf
argument_list|,
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ev_code
operator|=
name|event
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ev_code
operator|==
name|SEQ_FULLSIZE
condition|)
block|{
name|int
name|err
decl_stmt|;
name|dev
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
name|err
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|load_patch
argument_list|(
name|dev
argument_list|,
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
name|p
operator|+
literal|4
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return
name|err
return|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|ev_code
operator|==
name|SEQ_EXTENDED
operator|||
name|ev_code
operator|==
name|SEQ_PRIVATE
condition|)
block|{
name|ev_size
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|c
operator|<
name|ev_size
condition|)
block|{
if|if
condition|(
operator|!
name|seq_playing
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
return|return
name|count
operator|-
name|c
return|;
block|}
name|COPY_FROM_USER
argument_list|(
operator|&
name|event
index|[
literal|4
index|]
argument_list|,
name|buf
argument_list|,
name|p
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
name|ev_size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|event
index|[
literal|0
index|]
operator|==
name|SEQ_MIDIPUTC
condition|)
block|{
if|if
condition|(
operator|!
name|midi_opened
index|[
name|event
index|[
literal|2
index|]
index|]
condition|)
block|{
name|int
name|mode
decl_stmt|;
name|int
name|dev
init|=
name|event
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|dev
operator|>=
name|num_midis
condition|)
block|{
name|printk
argument_list|(
literal|"Sequencer Error: Nonexistent MIDI device %d\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
name|mode
operator|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|midi_devs
index|[
name|dev
index|]
operator|->
name|open
argument_list|(
name|dev
argument_list|,
name|mode
argument_list|,
name|sequencer_midi_input
argument_list|,
name|sequencer_midi_output
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|seq_reset
argument_list|()
expr_stmt|;
name|printk
argument_list|(
literal|"Sequencer Error: Unable to open Midi #%d\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|midi_opened
index|[
name|dev
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|seq_queue
argument_list|(
name|event
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|seq_playing
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
return|return
name|count
operator|-
name|c
return|;
block|}
name|p
operator|+=
name|ev_size
expr_stmt|;
name|c
operator|-=
name|ev_size
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|seq_playing
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_queue
parameter_list|(
name|unsigned
name|char
modifier|*
name|note
parameter_list|)
block|{
comment|/* Test if there is space in the queue */
if|if
condition|(
name|qlen
operator|>=
name|SEQ_MAX_QUEUE
condition|)
if|if
condition|(
operator|!
name|seq_playing
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
comment|/* Give chance to drain the queue */
if|if
condition|(
name|qlen
operator|>=
name|SEQ_MAX_QUEUE
operator|&&
operator|!
name|SOMEONE_WAITING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
block|{
comment|/* Sleep until there is enough space on the queue */
name|DO_SLEEP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qlen
operator|>=
name|SEQ_MAX_QUEUE
condition|)
return|return
literal|0
return|;
comment|/* To be sure */
name|memcpy
argument_list|(
operator|&
name|queue
index|[
name|qtail
operator|*
name|EV_SZ
index|]
argument_list|,
name|note
argument_list|,
name|EV_SZ
argument_list|)
expr_stmt|;
name|qtail
operator|=
operator|(
name|qtail
operator|+
literal|1
operator|)
operator|%
name|SEQ_MAX_QUEUE
expr_stmt|;
name|qlen
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extended_event
parameter_list|(
name|unsigned
name|char
modifier|*
name|q
parameter_list|)
block|{
name|int
name|dev
init|=
name|q
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
switch|switch
condition|(
name|q
index|[
literal|1
index|]
condition|)
block|{
case|case
name|SEQ_NOTEOFF
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|kill_note
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_NOTEON
case|:
if|if
condition|(
name|q
index|[
literal|4
index|]
operator|>
literal|127
operator|&&
name|q
index|[
literal|4
index|]
operator|!=
literal|255
condition|)
return|return
literal|0
return|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|start_note
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|,
name|q
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_PGMCHANGE
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|set_instr
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_AFTERTOUCH
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|aftertouch
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_BALANCE
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|panning
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
operator|(
name|char
operator|)
name|q
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_CONTROLLER
case|:
name|synth_devs
index|[
name|dev
index|]
operator|->
name|controller
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|,
name|q
index|[
literal|4
index|]
argument_list|,
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|q
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|seq_startplay
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|this_one
decl_stmt|;
name|unsigned
name|long
modifier|*
name|delay
decl_stmt|;
name|unsigned
name|char
modifier|*
name|q
decl_stmt|;
while|while
condition|(
name|qlen
operator|>
literal|0
condition|)
block|{
name|qhead
operator|=
operator|(
operator|(
name|this_one
operator|=
name|qhead
operator|)
operator|+
literal|1
operator|)
operator|%
name|SEQ_MAX_QUEUE
expr_stmt|;
name|qlen
operator|--
expr_stmt|;
name|q
operator|=
operator|&
name|queue
index|[
name|this_one
operator|*
name|EV_SZ
index|]
expr_stmt|;
switch|switch
condition|(
name|q
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SEQ_NOTEOFF
case|:
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
if|if
condition|(
name|synth_devs
index|[
literal|0
index|]
condition|)
name|synth_devs
index|[
literal|0
index|]
operator|->
name|kill_note
argument_list|(
literal|0
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_NOTEON
case|:
if|if
condition|(
name|q
index|[
literal|4
index|]
operator|<
literal|128
operator|||
name|q
index|[
literal|4
index|]
operator|==
literal|255
condition|)
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
if|if
condition|(
name|synth_devs
index|[
literal|0
index|]
condition|)
name|synth_devs
index|[
literal|0
index|]
operator|->
name|start_note
argument_list|(
literal|0
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|,
name|q
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_WAIT
case|:
name|delay
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|q
expr_stmt|;
comment|/* Bytes 1 to 3 are containing the 					 * delay in GET_TIME() */
operator|*
name|delay
operator|=
operator|(
operator|*
name|delay
operator|>>
literal|8
operator|)
operator|&
literal|0xffffff
expr_stmt|;
if|if
condition|(
operator|*
name|delay
operator|>
literal|0
condition|)
block|{
name|long
name|time
decl_stmt|;
name|seq_playing
operator|=
literal|1
expr_stmt|;
name|time
operator|=
operator|*
name|delay
expr_stmt|;
name|request_sound_timer
argument_list|(
name|time
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SEQ_MAX_QUEUE
operator|-
name|qlen
operator|)
operator|>=
name|output_treshold
condition|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOMEONE_WAITING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
block|{
name|WAKE_UP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* Stop here. Timer routine will continue 				 * playing after the delay */
block|}
break|break;
case|case
name|SEQ_PGMCHANGE
case|:
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
if|if
condition|(
name|synth_devs
index|[
literal|0
index|]
condition|)
name|synth_devs
index|[
literal|0
index|]
operator|->
name|set_instr
argument_list|(
literal|0
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_SYNCTIMER
case|:
comment|/* Reset timer */
name|seq_time
operator|=
name|GET_TIME
argument_list|()
expr_stmt|;
break|break;
case|case
name|SEQ_MIDIPUTC
case|:
comment|/* Put a midi character */
if|if
condition|(
name|midi_opened
index|[
name|q
index|[
literal|2
index|]
index|]
condition|)
block|{
name|int
name|dev
decl_stmt|;
name|dev
operator|=
name|q
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|midi_devs
index|[
name|dev
index|]
operator|->
name|putc
argument_list|(
name|dev
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* 		   * Output FIFO is full. Wait one timer cycle and try again. 		   */
name|qlen
operator|++
expr_stmt|;
name|qhead
operator|=
name|this_one
expr_stmt|;
comment|/* Restore queue */
name|seq_playing
operator|=
literal|1
expr_stmt|;
name|request_sound_timer
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|midi_written
index|[
name|dev
index|]
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|SEQ_ECHO
case|:
name|copy_to_input
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* Echo back to the process */
break|break;
case|case
name|SEQ_PRIVATE
case|:
if|if
condition|(
name|q
index|[
literal|1
index|]
operator|<
name|num_synths
condition|)
name|synth_devs
index|[
name|q
index|[
literal|1
index|]
index|]
operator|->
name|hw_control
argument_list|(
name|q
index|[
literal|1
index|]
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEQ_EXTENDED
case|:
name|extended_event
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
name|seq_playing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|SEQ_MAX_QUEUE
operator|-
name|qlen
operator|)
operator|>=
name|output_treshold
condition|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|DISABLE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOMEONE_WAITING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
block|{
name|WAKE_UP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
expr_stmt|;
block|}
name|RESTORE_INTR
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|sequencer_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|)
block|{
name|int
name|retval
decl_stmt|,
name|mode
decl_stmt|,
name|i
decl_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|mode
operator|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
expr_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"sequencer_open(dev=%d)\n"
argument_list|,
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sequencer_ok
condition|)
block|{
name|printk
argument_list|(
literal|"Soundcard: Sequencer not initialized\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager device */
block|{
name|int
name|err
decl_stmt|;
name|dev
operator|--
expr_stmt|;
if|if
condition|(
name|pmgr_present
index|[
name|dev
index|]
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|pmgr_open
argument_list|(
name|dev
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|err
return|;
comment|/* Failed */
name|pmgr_present
index|[
name|dev
index|]
operator|=
literal|1
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|sequencer_busy
condition|)
block|{
name|printk
argument_list|(
literal|"Sequencer busy\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|num_synths
operator|+
name|num_midis
operator|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
name|synth_open_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|OPEN_WRITE
operator|||
name|mode
operator|==
name|OPEN_READWRITE
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_synths
condition|;
name|i
operator|++
control|)
comment|/* Open synth devices */
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
operator|->
name|open
argument_list|(
name|i
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
name|printk
argument_list|(
literal|"Sequencer: Warning! Cannot open synth device #%d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|synth_open_mask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|seq_time
operator|=
name|GET_TIME
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_midis
condition|;
name|i
operator|++
control|)
block|{
name|midi_opened
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|midi_written
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|==
name|OPEN_READ
operator|||
name|mode
operator|==
name|OPEN_READWRITE
condition|)
block|{
comment|/* Initialize midi input devices */
if|if
condition|(
operator|!
name|num_midis
condition|)
block|{
name|printk
argument_list|(
literal|"Sequencer: No Midi devices. Input not possible\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_midis
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|retval
operator|=
name|midi_devs
index|[
name|i
index|]
operator|->
name|open
argument_list|(
name|i
argument_list|,
name|mode
argument_list|,
name|sequencer_midi_input
argument_list|,
name|sequencer_midi_output
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|midi_opened
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|sequencer_busy
operator|=
literal|1
expr_stmt|;
name|RESET_WAIT_QUEUE
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
expr_stmt|;
name|RESET_WAIT_QUEUE
argument_list|(
name|midi_sleeper
argument_list|,
name|midi_sleep_flag
argument_list|)
expr_stmt|;
name|output_treshold
operator|=
name|SEQ_MAX_QUEUE
operator|/
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_synths
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pmgr_present
index|[
name|i
index|]
condition|)
name|pmgr_inform
argument_list|(
name|i
argument_list|,
name|PM_E_OPENED
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|seq_drain_midi_queues
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
comment|/*    * Give the Midi drivers time to drain their output queues    */
name|n
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|PROCESS_ABORTING
argument_list|(
name|midi_sleeper
argument_list|,
name|midi_sleep_flag
argument_list|)
operator|&&
name|n
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_midis
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|midi_opened
index|[
name|i
index|]
operator|&&
name|midi_written
index|[
name|i
index|]
condition|)
if|if
condition|(
name|midi_devs
index|[
name|i
index|]
operator|->
name|buffer_status
operator|!=
name|NULL
condition|)
if|if
condition|(
name|midi_devs
index|[
name|i
index|]
operator|->
name|buffer_status
argument_list|(
name|i
argument_list|)
condition|)
name|n
operator|++
expr_stmt|;
comment|/*        * Let's have a delay        */
if|if
condition|(
name|n
condition|)
block|{
name|DO_SLEEP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|,
name|HZ
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sequencer_release
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|mode
init|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
decl_stmt|;
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
name|DEB
argument_list|(
name|printk
argument_list|(
literal|"sequencer_release(dev=%d)\n"
argument_list|,
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager device */
block|{
name|dev
operator|--
expr_stmt|;
name|pmgr_release
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pmgr_present
index|[
name|dev
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/*      * Wait until the queue is empty    */
while|while
condition|(
operator|!
name|PROCESS_ABORTING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
operator|&&
name|qlen
condition|)
block|{
name|seq_sync
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|OPEN_READ
condition|)
name|seq_drain_midi_queues
argument_list|()
expr_stmt|;
comment|/* Ensure the output queues are empty */
name|seq_reset
argument_list|()
expr_stmt|;
if|if
condition|(
name|mode
operator|!=
name|OPEN_READ
condition|)
name|seq_drain_midi_queues
argument_list|()
expr_stmt|;
comment|/* Flush the all notes off messages */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_midis
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|midi_opened
index|[
name|i
index|]
condition|)
name|midi_devs
index|[
name|i
index|]
operator|->
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|OPEN_WRITE
operator|||
name|mode
operator|==
name|OPEN_READWRITE
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_synths
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
comment|/* Actually opened */
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
condition|)
name|synth_devs
index|[
name|i
index|]
operator|->
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_synths
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pmgr_present
index|[
name|i
index|]
condition|)
name|pmgr_inform
argument_list|(
name|i
argument_list|,
name|PM_E_CLOSED
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sequencer_busy
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|seq_sync
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|qlen
operator|&&
operator|!
name|seq_playing
operator|&&
operator|!
name|PROCESS_ABORTING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
name|seq_startplay
argument_list|()
expr_stmt|;
if|if
condition|(
name|qlen
operator|&&
operator|!
name|SOMEONE_WAITING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
comment|/* Queue not empty */
block|{
name|DO_SLEEP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|qlen
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|midi_outc
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
name|data
parameter_list|)
block|{
comment|/*    * NOTE! Calls sleep(). Don't call this from interrupt.    */
name|int
name|n
decl_stmt|;
comment|/* This routine sends one byte to the Midi channel. */
comment|/* If the output Fifo is full, it waits until there */
comment|/* is space in the queue */
name|n
operator|=
literal|300
expr_stmt|;
comment|/* Timeout in jiffies */
while|while
condition|(
name|n
operator|&&
operator|!
name|midi_devs
index|[
name|dev
index|]
operator|->
name|putc
argument_list|(
name|dev
argument_list|,
name|data
argument_list|)
condition|)
block|{
name|DO_SLEEP
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|seq_reset
parameter_list|(
name|void
parameter_list|)
block|{
comment|/*    * NOTE! Calls sleep(). Don't call this from interrupt.    */
name|int
name|i
decl_stmt|,
name|chn
decl_stmt|;
name|sound_stop_timer
argument_list|()
expr_stmt|;
name|qlen
operator|=
name|qhead
operator|=
name|qtail
operator|=
literal|0
expr_stmt|;
name|iqlen
operator|=
name|iqhead
operator|=
name|iqtail
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_synths
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
if|if
condition|(
name|synth_devs
index|[
name|i
index|]
condition|)
name|synth_devs
index|[
name|i
index|]
operator|->
name|reset
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_midis
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|midi_written
index|[
name|i
index|]
condition|)
comment|/* Midi used. Some notes may still be playing */
block|{
for|for
control|(
name|chn
operator|=
literal|0
init|;
name|chn
operator|<
literal|16
condition|;
name|chn
operator|++
control|)
block|{
name|midi_outc
argument_list|(
name|i
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
literal|0xb0
operator|+
operator|(
name|chn
operator|&
literal|0xff
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Channel msg */
name|midi_outc
argument_list|(
name|i
argument_list|,
literal|0x7b
argument_list|)
expr_stmt|;
comment|/* All notes off */
name|midi_outc
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Dummy parameter */
block|}
name|midi_devs
index|[
name|i
index|]
operator|->
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|midi_written
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|midi_opened
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|seq_playing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SOMEONE_WAITING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
name|printk
argument_list|(
literal|"Sequencer Warning: Unexpected sleeping process\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sequencer_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|arg
parameter_list|)
block|{
name|int
name|midi_dev
decl_stmt|,
name|orig_dev
decl_stmt|;
name|int
name|mode
init|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
decl_stmt|;
name|orig_dev
operator|=
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_SEQ_SYNC
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|OPEN_READ
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|qlen
operator|&&
operator|!
name|PROCESS_ABORTING
argument_list|(
name|seq_sleeper
argument_list|,
name|seq_sleep_flag
argument_list|)
condition|)
name|seq_sync
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_RESET
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|seq_reset
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_TESTMIDI
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
name|midi_dev
operator|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|midi_dev
operator|>=
name|num_midis
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
name|midi_opened
index|[
name|midi_dev
index|]
condition|)
block|{
name|int
name|err
decl_stmt|,
name|mode
decl_stmt|;
name|mode
operator|=
name|file
operator|->
name|mode
operator|&
name|O_ACCMODE
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|midi_devs
index|[
name|midi_dev
index|]
operator|->
name|open
argument_list|(
name|midi_dev
argument_list|,
name|mode
argument_list|,
name|sequencer_midi_input
argument_list|,
name|sequencer_midi_output
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|err
return|;
block|}
name|midi_opened
index|[
name|midi_dev
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_GETINCOUNT
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|OPEN_WRITE
condition|)
return|return
literal|0
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|iqlen
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_SEQ_GETOUTCOUNT
case|:
if|if
condition|(
name|mode
operator|==
name|OPEN_READ
condition|)
return|return
literal|0
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|SEQ_MAX_QUEUE
operator|-
name|qlen
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_SEQ_CTRLRATE
case|:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
comment|/* If *arg == 0, just return the current rate */
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|HZ
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_SEQ_RESETSAMPLES
case|:
name|dev
operator|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
operator|&&
operator|!
name|orig_dev
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
if|if
condition|(
operator|!
name|orig_dev
operator|&&
name|pmgr_present
index|[
name|dev
index|]
condition|)
name|pmgr_inform
argument_list|(
name|dev
argument_list|,
name|PM_E_PATCH_RESET
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|synth_devs
index|[
name|dev
index|]
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_SEQ_NRSYNTHS
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|num_synths
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_SEQ_NRMIDIS
case|:
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|num_midis
argument_list|)
return|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
block|{
name|int
name|dev
init|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
operator|&&
operator|!
name|orig_dev
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|synth_devs
index|[
name|dev
index|]
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|SNDCTL_FM_4OP_ENABLE
case|:
block|{
name|int
name|dev
init|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
name|synth_devs
index|[
name|dev
index|]
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_SYNTH_INFO
case|:
block|{
name|struct
name|synth_info
name|inf
decl_stmt|;
name|int
name|dev
decl_stmt|;
name|IOCTL_FROM_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|inf
operator|.
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
name|dev
operator|)
operator|)
operator|&&
operator|!
name|orig_dev
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
return|return
name|synth_devs
index|[
name|dev
index|]
operator|->
name|ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
break|break;
case|case
name|SNDCTL_MIDI_INFO
case|:
block|{
name|struct
name|midi_info
name|inf
decl_stmt|;
name|int
name|dev
decl_stmt|;
name|IOCTL_FROM_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|inf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|inf
operator|.
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_midis
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
name|IOCTL_TO_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|midi_devs
index|[
name|dev
index|]
operator|->
name|info
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|inf
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_PMGR_IFACE
case|:
block|{
name|struct
name|patmgr_info
modifier|*
name|inf
decl_stmt|;
name|int
name|dev
decl_stmt|,
name|err
decl_stmt|;
name|inf
operator|=
operator|(
expr|struct
name|patmgr_info
operator|*
operator|)
name|KERNEL_MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|IOCTL_FROM_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|inf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|inf
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
block|{
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|synth_devs
index|[
name|dev
index|]
operator|->
name|pmgr_interface
condition|)
block|{
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|synth_devs
index|[
name|dev
index|]
operator|->
name|pmgr_interface
argument_list|(
name|dev
argument_list|,
name|inf
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|IOCTL_TO_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_PMGR_ACCESS
case|:
block|{
name|struct
name|patmgr_info
modifier|*
name|inf
decl_stmt|;
name|int
name|dev
decl_stmt|,
name|err
decl_stmt|;
name|inf
operator|=
operator|(
expr|struct
name|patmgr_info
operator|*
operator|)
name|KERNEL_MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|IOCTL_FROM_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|inf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|=
name|inf
operator|->
name|device
expr_stmt|;
if|if
condition|(
name|dev
operator|<
literal|0
operator|||
name|dev
operator|>=
name|num_synths
condition|)
block|{
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|pmgr_present
index|[
name|dev
index|]
condition|)
block|{
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ESRCH
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|pmgr_access
argument_list|(
name|dev
argument_list|,
name|inf
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|IOCTL_TO_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|inf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inf
argument_list|)
argument_list|)
expr_stmt|;
name|KERNEL_FREE
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|SNDCTL_SEQ_TRESHOLD
case|:
block|{
name|int
name|tmp
init|=
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|tmp
operator|<
literal|1
condition|)
name|tmp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
name|SEQ_MAX_QUEUE
condition|)
name|tmp
operator|=
name|SEQ_MAX_QUEUE
operator|-
literal|1
expr_stmt|;
name|output_treshold
operator|=
name|tmp
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
default|default:
if|if
condition|(
name|dev
condition|)
comment|/* Patch manager */
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
name|mode
operator|==
name|OPEN_READ
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
if|if
condition|(
operator|!
name|synth_devs
index|[
literal|0
index|]
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
name|synth_open_mask
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
operator|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
return|return
name|synth_devs
index|[
literal|0
index|]
operator|->
name|ioctl
argument_list|(
literal|0
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
break|break;
block|}
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALLOW_SELECT
end_ifdef

begin_function
name|int
name|sequencer_select
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|int
name|sel_type
parameter_list|,
name|select_table
modifier|*
name|wait
parameter_list|)
block|{
name|dev
operator|=
name|dev
operator|>>
literal|4
expr_stmt|;
switch|switch
condition|(
name|sel_type
condition|)
block|{
case|case
name|SEL_IN
case|:
if|if
condition|(
operator|!
name|iqlen
condition|)
block|{
name|select_wait
argument_list|(
operator|&
name|midi_sleeper
argument_list|,
name|wait
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
break|break;
case|case
name|SEL_OUT
case|:
if|if
condition|(
name|qlen
operator|>=
name|SEQ_MAX_QUEUE
condition|)
block|{
name|select_wait
argument_list|(
operator|&
name|seq_sleeper
argument_list|,
name|wait
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
break|break;
case|case
name|SEL_EX
case|:
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sequencer_timer
parameter_list|(
name|void
parameter_list|)
block|{
name|seq_startplay
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|note_to_freq
parameter_list|(
name|int
name|note_num
parameter_list|)
block|{
comment|/*    * This routine converts a midi note to a frequency (multiplied by 1000)    */
name|int
name|note
decl_stmt|,
name|octave
decl_stmt|,
name|note_freq
decl_stmt|;
name|int
name|notes
index|[]
init|=
block|{
literal|261632
block|,
literal|277189
block|,
literal|293671
block|,
literal|311132
block|,
literal|329632
block|,
literal|349232
block|,
literal|369998
block|,
literal|391998
block|,
literal|415306
block|,
literal|440000
block|,
literal|466162
block|,
literal|493880
block|}
decl_stmt|;
comment|/* Note freq*1000 for octave 5 */
define|#
directive|define
name|BASE_OCTAVE
value|5
name|octave
operator|=
name|note_num
operator|/
literal|12
expr_stmt|;
name|note
operator|=
name|note_num
operator|%
literal|12
expr_stmt|;
name|note_freq
operator|=
name|notes
index|[
name|note
index|]
expr_stmt|;
if|if
condition|(
name|octave
operator|<
name|BASE_OCTAVE
condition|)
name|note_freq
operator|>>=
operator|(
name|BASE_OCTAVE
operator|-
name|octave
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|octave
operator|>
name|BASE_OCTAVE
condition|)
name|note_freq
operator|<<=
operator|(
name|octave
operator|-
name|BASE_OCTAVE
operator|)
expr_stmt|;
comment|/* note_freq>>= 1;    */
return|return
name|note_freq
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|compute_finetune
parameter_list|(
name|unsigned
name|long
name|base_freq
parameter_list|,
name|int
name|bend
parameter_list|,
name|int
name|range
parameter_list|)
block|{
name|unsigned
name|long
name|amount
decl_stmt|;
name|int
name|negative
decl_stmt|,
name|semitones
decl_stmt|,
name|cents
decl_stmt|;
if|if
condition|(
operator|!
name|bend
condition|)
return|return
name|base_freq
return|;
if|if
condition|(
operator|!
name|range
condition|)
return|return
name|base_freq
return|;
if|if
condition|(
operator|!
name|base_freq
condition|)
return|return
name|base_freq
return|;
if|if
condition|(
name|range
operator|>=
literal|8192
condition|)
name|range
operator|=
literal|8191
expr_stmt|;
name|bend
operator|=
name|bend
operator|*
name|range
operator|/
literal|8192
expr_stmt|;
if|if
condition|(
operator|!
name|bend
condition|)
return|return
name|base_freq
return|;
name|negative
operator|=
name|bend
operator|<
literal|0
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|bend
operator|<
literal|0
condition|)
name|bend
operator|*=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bend
operator|>
name|range
condition|)
name|bend
operator|=
name|range
expr_stmt|;
if|if
condition|(
name|bend
operator|>
literal|2399
condition|)
name|bend
operator|=
literal|2399
expr_stmt|;
name|semitones
operator|=
name|bend
operator|/
literal|100
expr_stmt|;
name|cents
operator|=
name|bend
operator|%
literal|100
expr_stmt|;
name|amount
operator|=
name|semitone_tuning
index|[
name|semitones
index|]
operator|*
name|cent_tuning
index|[
name|cents
index|]
operator|/
literal|10000
expr_stmt|;
if|if
condition|(
name|negative
condition|)
return|return
operator|(
name|base_freq
operator|*
literal|10000
operator|)
operator|/
name|amount
return|;
comment|/* Bend down */
else|else
return|return
operator|(
name|base_freq
operator|*
name|amount
operator|)
operator|/
literal|10000
return|;
comment|/* Bend up */
block|}
end_function

begin_function
name|long
name|sequencer_init
parameter_list|(
name|long
name|mem_start
parameter_list|)
block|{
name|sequencer_ok
operator|=
literal|1
expr_stmt|;
name|PERMANENT_MALLOC
argument_list|(
argument|unsigned char *
argument_list|,
argument|queue
argument_list|,
argument|SEQ_MAX_QUEUE * EV_SZ
argument_list|,
argument|mem_start
argument_list|)
empty_stmt|;
name|PERMANENT_MALLOC
argument_list|(
argument|unsigned char *
argument_list|,
argument|iqueue
argument_list|,
argument|SEQ_MAX_QUEUE * IEV_SZ
argument_list|,
argument|mem_start
argument_list|)
empty_stmt|;
return|return
name|mem_start
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Stub version */
end_comment

begin_function
name|int
name|sequencer_read
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|snd_rw_buf
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sequencer_write
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|snd_rw_buf
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sequencer_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|ENXIO
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|sequencer_release
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|)
block|{ }
end_function

begin_function
name|int
name|sequencer_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|arg
parameter_list|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sequencer_lseek
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|orig
parameter_list|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
end_function

begin_function
name|long
name|sequencer_init
parameter_list|(
name|long
name|mem_start
parameter_list|)
block|{
return|return
name|mem_start
return|;
block|}
end_function

begin_function
name|int
name|sequencer_select
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|fileinfo
modifier|*
name|file
parameter_list|,
name|int
name|sel_type
parameter_list|,
name|select_table
modifier|*
name|wait
parameter_list|)
block|{
return|return
name|RET_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

