begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996 Bruce D. Evans.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/asmacros.h>
end_include

begin_include
include|#
directive|include
file|<machine/timerreg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GUPROF
end_ifdef

begin_include
include|#
directive|include
file|"opt_i586_guprof.h"
end_include

begin_include
include|#
directive|include
file|"opt_perfmon.h"
end_include

begin_include
include|#
directive|include
file|<sys/gmon.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/perfmon.h>
end_include

begin_include
include|#
directive|include
file|<machine/profile.h>
end_include

begin_undef
undef|#
directive|undef
name|MCOUNT
end_undef

begin_define
define|#
directive|define
name|CPUTIME_CLOCK_UNINITIALIZED
value|0
end_define

begin_define
define|#
directive|define
name|CPUTIME_CLOCK_I8254
value|1
end_define

begin_define
define|#
directive|define
name|CPUTIME_CLOCK_TSC
value|2
end_define

begin_define
define|#
directive|define
name|CPUTIME_CLOCK_I586_PMC
value|3
end_define

begin_define
define|#
directive|define
name|CPUTIME_CLOCK_I8254_SHIFT
value|7
end_define

begin_decl_stmt
name|int
name|cputime_bias
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initialize for locality of reference */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cputime_clock
init|=
name|CPUTIME_CLOCK_UNINITIALIZED
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|I586_PMC_GUPROF
end_ifdef

begin_decl_stmt
specifier|static
name|u_int
name|cputime_clock_pmc_conf
init|=
name|I586_PMC_GUPROF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cputime_clock_pmc_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|gmonparam
name|saved_gmp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GUPROF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUCLIKE_ASM
end_ifdef

begin_asm
asm|__asm("								\n\ GM_STATE	=	0					\n\ GMON_PROF_OFF	=	3					\n\ 								\n\ 	.text							\n\ 	.p2align 4,0x90						\n\ 	.globl	__mcount					\n\ 	.type	__mcount,@function				\n\ __mcount:							\n\ 	#							\n\ 	# Check that we are profiling.  Do it early for speed.	\n\ 	#							\n\ 	cmpl	$GMON_PROF_OFF," __XSTRING(CNAME(_gmonparam)) "+GM_STATE \n\  	je	.mcount_exit					\n\  	#							\n\  	# __mcount is the same as [.]mcount except the caller	\n\  	# hasn't changed the stack except to call here, so the	\n\ 	# caller's raddr is above our raddr.			\n\ 	#							\n\  	movl	4(%esp),%edx					\n\  	jmp	.got_frompc					\n\  								\n\  	.p2align 4,0x90						\n\  	.globl	" __XSTRING(HIDENAME(mcount)) "			\n\ " __XSTRING(HIDENAME(mcount)) ":				\n\  	.globl	__cyg_profile_func_enter			\n\ __cyg_profile_func_enter:					\n\ 	cmpl	$GMON_PROF_OFF," __XSTRING(CNAME(_gmonparam)) "+GM_STATE \n\ 	je	.mcount_exit					\n\ 	#							\n\ 	# The caller's stack frame has already been built, so	\n\ 	# %ebp is the caller's frame pointer.  The caller's	\n\ 	# raddr is in the caller's frame following the caller's	\n\ 	# caller's frame pointer.				\n\ 	#							\n\ 	movl	4(%ebp),%edx					\n\ .got_frompc:							\n\ 	#							\n\ 	# Our raddr is the caller's pc.				\n\ 	#							\n\ 	movl	(%esp),%eax					\n\ 								\n\ 	pushfl							\n\ 	pushl	%eax						\n\ 	pushl	%edx						\n\ 	cli							\n\ 	call	" __XSTRING(CNAME(mcount)) "			\n\ 	addl	$8,%esp						\n\ 	popfl							\n\ .mcount_exit:							\n\ 	ret							\n\ ");
end_asm

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !__GNUCLIKE_ASM */
end_comment

begin_error
error|#
directive|error
error|this file needs to be ported to your compiler
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GNUCLIKE_ASM */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GUPROF
end_ifdef

begin_comment
comment|/*  * [.]mexitcount saves the return register(s), loads selfpc and calls  * mexitcount(selfpc) to do the work.  Someday it should be in a machine  * dependent file together with cputime(), __mcount and [.]mcount.  cputime()  * can't just be put in machdep.c because it has to be compiled without -pg.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUCLIKE_ASM
end_ifdef

begin_asm
asm|__asm("								\n\ 	.text							\n\ #								\n\ # Dummy label to be seen when gprof -u hides [.]mexitcount.	\n\ #								\n\ 	.p2align 4,0x90						\n\ 	.globl	__mexitcount					\n\ 	.type	__mexitcount,@function				\n\ __mexitcount:							\n\ 	nop							\n\ 								\n\ GMON_PROF_HIRES	=	4					\n\ 								\n\ 	.p2align 4,0x90						\n\ 	.globl	" __XSTRING(HIDENAME(mexitcount)) "		\n\ " __XSTRING(HIDENAME(mexitcount)) ":				\n\  	.globl	__cyg_profile_func_exit				\n\ __cyg_profile_func_exit:					\n\ 	cmpl	$GMON_PROF_HIRES," __XSTRING(CNAME(_gmonparam)) "+GM_STATE \n\ 	jne	.mexitcount_exit				\n\ 	pushl	%edx						\n\ 	pushl	%eax						\n\ 	movl	8(%esp),%eax					\n\ 	pushfl							\n\ 	pushl	%eax						\n\ 	cli							\n\ 	call	" __XSTRING(CNAME(mexitcount)) "		\n\ 	addl	$4,%esp						\n\ 	popfl							\n\ 	popl	%eax						\n\ 	popl	%edx						\n\ .mexitcount_exit:						\n\ 	ret							\n\ ");
end_asm

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GNUCLIKE_ASM */
end_comment

begin_comment
comment|/*  * Return the time elapsed since the last call.  The units are machine-  * dependent.  */
end_comment

begin_function
name|int
name|cputime
parameter_list|()
block|{
name|u_int
name|count
decl_stmt|;
name|int
name|delta
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|||
name|defined
argument_list|(
name|I686_CPU
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|PERFMON
argument_list|)
operator|&&
name|defined
argument_list|(
name|I586_PMC_GUPROF
argument_list|)
name|u_quad_t
name|event_count
decl_stmt|;
endif|#
directive|endif
name|u_char
name|high
decl_stmt|,
name|low
decl_stmt|;
specifier|static
name|u_int
name|prev_count
decl_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|||
name|defined
argument_list|(
name|I686_CPU
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
if|if
condition|(
name|cputime_clock
operator|==
name|CPUTIME_CLOCK_TSC
condition|)
block|{
comment|/* 		 * Scale the TSC a little to make cputime()'s frequency 		 * fit in an int, assuming that the TSC frequency fits 		 * in a u_int.  Use a fixed scale since dynamic scaling 		 * would be slower and we can't really use the low bit 		 * of precision. 		 */
name|count
operator|=
operator|(
name|u_int
operator|)
name|rdtsc
argument_list|()
operator|&
operator|~
literal|1u
expr_stmt|;
name|delta
operator|=
call|(
name|int
call|)
argument_list|(
name|count
operator|-
name|prev_count
argument_list|)
operator|>>
literal|1
expr_stmt|;
name|prev_count
operator|=
name|count
expr_stmt|;
return|return
operator|(
name|delta
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|PERFMON
argument_list|)
operator|&&
name|defined
argument_list|(
name|I586_PMC_GUPROF
argument_list|)
if|if
condition|(
name|cputime_clock
operator|==
name|CPUTIME_CLOCK_I586_PMC
condition|)
block|{
comment|/* 		 * XXX permon_read() should be inlined so that the 		 * perfmon module doesn't need to be compiled with 		 * profiling disabled and so that it is fast. 		 */
name|perfmon_read
argument_list|(
literal|0
argument_list|,
operator|&
name|event_count
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
name|u_int
operator|)
name|event_count
expr_stmt|;
name|delta
operator|=
call|(
name|int
call|)
argument_list|(
name|count
operator|-
name|prev_count
argument_list|)
expr_stmt|;
name|prev_count
operator|=
name|count
expr_stmt|;
return|return
operator|(
name|delta
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* PERFMON&& I586_PMC_GUPROF */
endif|#
directive|endif
comment|/* (I586_CPU || I686_CPU)&& !SMP */
comment|/* 	 * Read the current value of the 8254 timer counter 0. 	 */
name|outb
argument_list|(
name|TIMER_MODE
argument_list|,
name|TIMER_SEL0
operator||
name|TIMER_LATCH
argument_list|)
expr_stmt|;
name|low
operator|=
name|inb
argument_list|(
name|TIMER_CNTR0
argument_list|)
expr_stmt|;
name|high
operator|=
name|inb
argument_list|(
name|TIMER_CNTR0
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
name|high
operator|<<
literal|8
operator|)
operator||
name|low
operator|)
operator|<<
name|CPUTIME_CLOCK_I8254_SHIFT
expr_stmt|;
comment|/* 	 * The timer counts down from TIMER_CNTR0_MAX to 0 and then resets. 	 * While profiling is enabled, this routine is called at least twice 	 * per timer reset (for mcounting and mexitcounting hardclock()), 	 * so at most one reset has occurred since the last call, and one 	 * has occurred iff the current count is larger than the previous 	 * count.  This allows counter underflow to be detected faster 	 * than in microtime(). 	 */
name|delta
operator|=
name|prev_count
operator|-
name|count
expr_stmt|;
name|prev_count
operator|=
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|delta
operator|<=
literal|0
condition|)
return|return
operator|(
name|delta
operator|+
operator|(
name|timer0_max_count
operator|<<
name|CPUTIME_CLOCK_I8254_SHIFT
operator|)
operator|)
return|;
return|return
operator|(
name|delta
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_machdep_cputime_clock
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|clock
decl_stmt|;
name|int
name|error
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PERFMON
argument_list|)
operator|&&
name|defined
argument_list|(
name|I586_PMC_GUPROF
argument_list|)
name|int
name|event
decl_stmt|;
name|struct
name|pmc
name|pmc
decl_stmt|;
endif|#
directive|endif
name|clock
operator|=
name|cputime_clock
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PERFMON
argument_list|)
operator|&&
name|defined
argument_list|(
name|I586_PMC_GUPROF
argument_list|)
if|if
condition|(
name|clock
operator|==
name|CPUTIME_CLOCK_I586_PMC
condition|)
block|{
name|pmc
operator|.
name|pmc_val
operator|=
name|cputime_clock_pmc_conf
expr_stmt|;
name|clock
operator|+=
name|pmc
operator|.
name|pmc_event
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
operator|&
name|clock
argument_list|,
sizeof|sizeof
name|clock
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|PERFMON
argument_list|)
operator|&&
name|defined
argument_list|(
name|I586_PMC_GUPROF
argument_list|)
if|if
condition|(
name|clock
operator|>=
name|CPUTIME_CLOCK_I586_PMC
condition|)
block|{
name|event
operator|=
name|clock
operator|-
name|CPUTIME_CLOCK_I586_PMC
expr_stmt|;
if|if
condition|(
name|event
operator|>=
literal|256
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pmc
operator|.
name|pmc_num
operator|=
literal|0
expr_stmt|;
name|pmc
operator|.
name|pmc_event
operator|=
name|event
expr_stmt|;
name|pmc
operator|.
name|pmc_unit
operator|=
literal|0
expr_stmt|;
name|pmc
operator|.
name|pmc_flags
operator|=
name|PMCF_E
operator||
name|PMCF_OS
operator||
name|PMCF_USR
expr_stmt|;
name|pmc
operator|.
name|pmc_mask
operator|=
literal|0
expr_stmt|;
name|cputime_clock_pmc_conf
operator|=
name|pmc
operator|.
name|pmc_val
expr_stmt|;
name|cputime_clock
operator|=
name|CPUTIME_CLOCK_I586_PMC
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|clock
operator|<
literal|0
operator|||
name|clock
operator|>=
name|CPUTIME_CLOCK_I586_PMC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cputime_clock
operator|=
name|clock
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|cputime_clock
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|,
name|sysctl_machdep_cputime_clock
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The start and stop routines need not be here since we turn off profiling  * before calling them.  They are here for convenience.  */
end_comment

begin_function
name|void
name|startguprof
parameter_list|(
name|gp
parameter_list|)
name|struct
name|gmonparam
modifier|*
name|gp
decl_stmt|;
block|{
if|if
condition|(
name|cputime_clock
operator|==
name|CPUTIME_CLOCK_UNINITIALIZED
condition|)
block|{
name|cputime_clock
operator|=
name|CPUTIME_CLOCK_I8254
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|||
name|defined
argument_list|(
name|I686_CPU
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
if|if
condition|(
name|tsc_freq
operator|!=
literal|0
condition|)
name|cputime_clock
operator|=
name|CPUTIME_CLOCK_TSC
expr_stmt|;
endif|#
directive|endif
block|}
name|gp
operator|->
name|profrate
operator|=
name|timer_freq
operator|<<
name|CPUTIME_CLOCK_I8254_SHIFT
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|||
name|defined
argument_list|(
name|I686_CPU
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
if|if
condition|(
name|cputime_clock
operator|==
name|CPUTIME_CLOCK_TSC
condition|)
name|gp
operator|->
name|profrate
operator|=
name|tsc_freq
operator|>>
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PERFMON
argument_list|)
operator|&&
name|defined
argument_list|(
name|I586_PMC_GUPROF
argument_list|)
elseif|else
if|if
condition|(
name|cputime_clock
operator|==
name|CPUTIME_CLOCK_I586_PMC
condition|)
block|{
if|if
condition|(
name|perfmon_avail
argument_list|()
operator|&&
name|perfmon_setup
argument_list|(
literal|0
argument_list|,
name|cputime_clock_pmc_conf
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|perfmon_start
argument_list|(
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|perfmon_fini
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* XXX 1 event == 1 us. */
name|gp
operator|->
name|profrate
operator|=
literal|1000000
expr_stmt|;
name|saved_gmp
operator|=
operator|*
name|gp
expr_stmt|;
comment|/* Zap overheads.  They are invalid. */
name|gp
operator|->
name|cputime_overhead
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|mcount_overhead
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|mcount_post_overhead
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|mcount_pre_overhead
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|mexitcount_overhead
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|mexitcount_post_overhead
operator|=
literal|0
expr_stmt|;
name|gp
operator|->
name|mexitcount_pre_overhead
operator|=
literal|0
expr_stmt|;
name|cputime_clock_pmc_init
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* PERFMON&& I586_PMC_GUPROF */
endif|#
directive|endif
comment|/* (I586_CPU || I686_CPU)&& !SMP */
name|cputime_bias
operator|=
literal|0
expr_stmt|;
name|cputime
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stopguprof
parameter_list|(
name|gp
parameter_list|)
name|struct
name|gmonparam
modifier|*
name|gp
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|PERFMON
argument_list|)
operator|&&
name|defined
argument_list|(
name|I586_PMC_GUPROF
argument_list|)
if|if
condition|(
name|cputime_clock_pmc_init
condition|)
block|{
operator|*
name|gp
operator|=
name|saved_gmp
expr_stmt|;
name|perfmon_fini
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cputime_clock_pmc_init
operator|=
name|FALSE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !GUPROF */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUCLIKE_ASM
end_ifdef

begin_asm
asm|__asm("								\n\ 	.text							\n\ 	.p2align 4,0x90						\n\ 	.globl	" __XSTRING(HIDENAME(mexitcount)) "		\n\ " __XSTRING(HIDENAME(mexitcount)) ":				\n\ 	ret							\n\ ");
end_asm

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GNUCLIKE_ASM */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GUPROF */
end_comment

end_unit

