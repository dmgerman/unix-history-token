begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * THIS SOFTWARE IS PROVIDED BY THE WRITERS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE WRITERS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * written by julian elischer (julian@tfs.com)  *  *	@(#)readMBR.c	8.5 (tfs) 1/21/94  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_define
define|#
directive|define
name|b_cylinder
value|b_resid
end_define

begin_comment
comment|/*  * Attempt to read a machine-type dependent Device partitioning table  * In this case a PC BIOS MBR.  * Destroys the original disklabel if it finds an MBR, so you'd better  * know what you're doing. It assumes that the label you've given it  * Is the one that controls the device, so that it can fiddle with it  * to make sure it's reading absolute sectors.  * On exit:  * Leaves the disklabel set up with the various partitions  * in the last 4 entries,  * the A partition pointing to the BSD part  * the C partition set as the BSD partition, (read the disklabel from there) and  * the D partition set as the whole disk for beating up  * will also give you a copy of the machine dependent table if you ask..  * returns 0 for success,  * On failure, restores the disklabel and returns a messages pointer.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|readMBRtolabel
argument_list|(
name|dev
argument_list|,
name|strat
argument_list|,
name|lp
argument_list|,
name|dp
argument_list|,
name|cyl
argument_list|)
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
function_decl|(
modifier|*
name|strat
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|register
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dos_partition
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|cyl
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dlp
decl_stmt|;
name|struct
name|disklabel
name|labelsave
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|pseudopart
init|=
literal|4
decl_stmt|;
comment|/* we fill in pseudoparts from e through h*/
name|int
name|seenBSD
init|=
literal|0
decl_stmt|;
comment|/* 	 * Save a copy of the disklabel in case we return with an error 	 */
name|bcopy
argument_list|(
name|lp
argument_list|,
operator|&
name|labelsave
argument_list|,
sizeof|sizeof
argument_list|(
name|labelsave
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set the disklabel to some useable partitions in case it's rubbish 	 */
if|if
condition|(
name|lp
operator|->
name|d_secperunit
operator|==
literal|0
condition|)
name|lp
operator|->
name|d_secperunit
operator|=
literal|0x1fffffff
expr_stmt|;
name|lp
operator|->
name|d_npartitions
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPARTITIONS
condition|;
name|i
operator|++
control|)
block|{
name|lp
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
name|i
index|]
operator|.
name|p_size
operator|=
literal|0
expr_stmt|;
block|}
name|lp
operator|->
name|d_partitions
index|[
name|RAWPART
index|]
operator|.
name|p_size
operator|=
name|DOSBBSECTOR
operator|+
literal|1
expr_stmt|;
comment|/* start low */
name|strcpy
argument_list|(
name|lp
operator|->
name|d_packname
argument_list|,
literal|"MBR based label"
argument_list|)
expr_stmt|;
comment|/* Watch the length ! */
comment|/* 	 * Get a buffer and get ready to read the MBR 	 */
name|bp
operator|=
name|geteblk
argument_list|(
operator|(
name|int
operator|)
name|lp
operator|->
name|d_secsize
argument_list|)
expr_stmt|;
comment|/* read master boot record */
name|bp
operator|->
name|b_dev
operator|=
name|makedev
argument_list|(
name|major
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dkminor
argument_list|(
name|dkunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|RAWPART
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|DOSBBSECTOR
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|lp
operator|->
name|d_secsize
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
operator||
name|B_READ
expr_stmt|;
name|bp
operator|->
name|b_cylinder
operator|=
name|DOSBBSECTOR
operator|/
name|lp
operator|->
name|d_secpercyl
expr_stmt|;
call|(
modifier|*
name|strat
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* if successful, wander through dos partition table */
if|if
condition|(
name|biowait
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|msg
operator|=
literal|"dos partition I/O error"
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
else|else
block|{
comment|/* 		 * If there seems to be  BIOS bootblock and partition table 		 * in that block, then try interpret it, otherwise 		 * give up and use whatever we have synthesised so far 		 */
if|if
condition|(
operator|(
operator|*
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
literal|510
operator|)
operator|!=
operator|(
name|char
operator|)
literal|0x55
operator|)
operator|||
operator|(
operator|*
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
literal|511
operator|)
operator|!=
operator|(
name|char
operator|)
literal|0xaa
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"disk doesn't have an MBR\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
condition|)
name|bzero
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|DOSPARTOFF
argument_list|,
name|NDOSPART
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|hrumpf
goto|;
block|}
if|if
condition|(
name|dp
condition|)
block|{
comment|/* if they asked for a copy, give it to them */
name|bcopy
argument_list|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|DOSPARTOFF
argument_list|,
name|dp
argument_list|,
name|NDOSPART
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dp
operator|=
operator|(
expr|struct
name|dos_partition
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|DOSPARTOFF
operator|)
expr_stmt|;
comment|/* 		 * We have a DOS MBR.. 		 * We set up the last 4 partitions in the 		 * disklabel to reflect the DOS partitions 		 * In case we never find a disklabel, in which 		 * case this information will be all we have 		 * but it might be all we need to access a DOS 		 * partition. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
operator|,
name|dp
operator|++
operator|,
name|pseudopart
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dp
operator|->
name|dp_size
condition|)
continue|continue;
comment|/* 		         * Set this DOS part into the disklabel 		         */
name|lp
operator|->
name|d_partitions
index|[
name|pseudopart
index|]
operator|.
name|p_size
operator|=
name|dp
operator|->
name|dp_size
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
name|pseudopart
index|]
operator|.
name|p_offset
operator|=
name|dp
operator|->
name|dp_start
expr_stmt|;
comment|/* 		         * make sure the D part can hold it all 		         */
if|if
condition|(
operator|(
name|dp
operator|->
name|dp_start
operator|+
name|dp
operator|->
name|dp_size
operator|)
operator|>
name|lp
operator|->
name|d_partitions
index|[
literal|3
index|]
operator|.
name|p_size
condition|)
block|{
name|lp
operator|->
name|d_partitions
index|[
literal|3
index|]
operator|.
name|p_size
operator|=
operator|(
name|dp
operator|->
name|dp_start
operator|+
name|dp
operator|->
name|dp_size
operator|)
expr_stmt|;
block|}
comment|/* 		         * If we haven't seen a *BSD partition then 		         * check if this is a valid part.. 		         * if it is it may be the best we are going to 		         * to see, so take note of it to deduce a 		         * geometry in case we never find a disklabel. 		         */
switch|switch
condition|(
name|dp
operator|->
name|dp_typ
condition|)
block|{
case|case
name|DOSPTYP_386BSD
case|:
comment|/* 				 * at a pinch we could throw 				 * a FFS on here 				 */
name|lp
operator|->
name|d_partitions
index|[
name|pseudopart
index|]
operator|.
name|p_fstype
operator|=
name|FS_BSDFFS
expr_stmt|;
comment|/* 				 * Only get a disklabel from the 				 * first one we see.. 				 */
if|if
condition|(
name|seenBSD
operator|==
literal|0
condition|)
block|{
comment|/* 					 * If it IS our part, then we 					 * need sector address for 					 * SCSI/IDE, cylinder for 					 * ESDI/ST506/RLL 					 */
name|seenBSD
operator|=
literal|1
expr_stmt|;
operator|*
name|cyl
operator|=
name|DPCYL
argument_list|(
name|dp
operator|->
name|dp_scyl
argument_list|,
name|dp
operator|->
name|dp_ssect
argument_list|)
expr_stmt|;
comment|/* 					 * Note which part we are in (?) 					 */
name|lp
operator|->
name|d_subtype
operator|&=
operator|~
literal|3
expr_stmt|;
name|lp
operator|->
name|d_subtype
operator||=
name|i
operator|&
literal|3
expr_stmt|;
name|lp
operator|->
name|d_subtype
operator||=
name|DSTYPE_INDOSPART
expr_stmt|;
comment|/* 					 * update disklabel with 					 * details for reading the REAL 					 * disklabel it it exists 					 */
name|lp
operator|->
name|d_partitions
index|[
name|OURPART
index|]
operator|.
name|p_size
operator|=
name|dp
operator|->
name|dp_size
expr_stmt|;
name|lp
operator|->
name|d_partitions
index|[
name|OURPART
index|]
operator|.
name|p_offset
operator|=
name|dp
operator|->
name|dp_start
expr_stmt|;
block|}
break|break;
case|case
literal|0xB7
case|:
comment|/* BSDI (?)*/
comment|/* doubtful */
name|lp
operator|->
name|d_partitions
index|[
name|pseudopart
index|]
operator|.
name|p_fstype
operator|=
name|FS_BSDFFS
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|4
case|:
case|case
literal|6
case|:
case|case
literal|0xF2
case|:
name|lp
operator|->
name|d_partitions
index|[
name|pseudopart
index|]
operator|.
name|p_fstype
operator|=
name|FS_MSDOS
expr_stmt|;
break|break;
block|}
comment|/* 			 * Try deduce the geometry, working 			 * on the principle that  this 			 * partition PROBABLY ends on a 			 * cylinder boundary. 			 * This is really a kludge, but we are 			 * forced into it by the PC's design. 			 * If we've seen a 386bsd part, 			 * believe it and check no further. 			 */
if|if
condition|(
name|seenBSD
condition|)
continue|continue;
name|lp
operator|->
name|d_ntracks
operator|=
name|dp
operator|->
name|dp_ehd
operator|+
literal|1
expr_stmt|;
name|lp
operator|->
name|d_nsectors
operator|=
name|DPSECT
argument_list|(
name|dp
operator|->
name|dp_esect
argument_list|)
expr_stmt|;
name|lp
operator|->
name|d_secpercyl
operator|=
name|lp
operator|->
name|d_ntracks
operator|*
name|lp
operator|->
name|d_nsectors
expr_stmt|;
block|}
name|lp
operator|->
name|d_npartitions
operator|=
literal|8
expr_stmt|;
block|}
name|hrumpf
label|:
name|bp
operator|->
name|b_flags
operator|=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
name|bcopy
argument_list|(
operator|&
name|labelsave
argument_list|,
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
name|labelsave
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_INVAL
operator||
name|B_AGE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|msg
return|;
block|}
end_block

end_unit

