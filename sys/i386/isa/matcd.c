begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*matcd.c-------------------------------------------------------------------- 	Matsushita(Panasonic) / Creative CD-ROM Driver	(matcd) 	Authored by Frank Durda IV  	Copyright 1994, 1995  Frank Durda IV.  All rights reserved. 	"FDIV" is a trademark of Frank Durda IV.   	Redistribution and use in source and binary forms, with or 	without modification, are permitted provided that the following 	conditions are met: 	1.  Redistributions of source code must retain the above copyright 	    notice positioned at the very beginning of this file without 	    modification, all copyright strings, all related programming 	    codes that display the copyright strings, this list of 	    conditions and the following disclaimer. 	2.  Redistributions in binary form must contain all copyright strings 	    and related programming code that display the copyright strings. 	3.  Redistributions in binary form must reproduce the above copyright 	    notice, this list of conditions and the following disclaimer in 	    the documentation and/or other materials provided with the 	    distribution. 	4.  All advertising materials mentioning features or use of this 	    software must display the following acknowledgement: 		"The Matsushita/Panasonic CD-ROM driver  was developed 		 by Frank Durda IV for use with "FreeBSD" and similar 		 operating systems." 	    "Similar operating systems" includes mainly non-profit oriented 	    systems for research and education, including but not restricted 	    to "NetBSD", "386BSD", and "Mach" (by CMU).  The wording of the 	    acknowledgement (in electronic form or printed text) may not be 	    changed without permission from the author. 	5.  Absolutely no warranty of function, fitness or purpose is made 	    by the author Frank Durda IV. 	6.  Neither the name of the author nor the name "FreeBSD" may 	    be used to endorse or promote products derived from this software 	    without specific prior written permission. 	    (The author can be reached at   bsdmail@nemesis.lonestar.org) 	7.  The product containing this software must meet all of these 	    conditions even if it is unsupported, not a complete system 	    and/or does not contain compiled code. 	8.  These conditions will be in force for the full life of the 	    copyright.   	9.  If all the above conditions are met, modifications to other 	    parts of this file may be freely made, although any person 	    or persons making changes do not receive the right to add their 	    name or names to the copyright strings and notices in this 	    software.  Persons making changes are encouraged to insert edit 	    history in matcd.c and to put your name and details of the 	    change there.   	10. You must have prior written permission from the author to 	    deviate from these terms.  	Vendors who produce product(s) containing this code are encouraged  	(but not required) to provide copies of the finished product(s) to 	the author and to correspond with the author about development 	activity relating to this code.   Donations of development hardware 	and/or software are also welcome.  (This is one of the faster ways 	to get a driver developed for a device.)   	THIS SOFTWARE IS PROVIDED BY THE DEVELOPER(S) ``AS IS'' AND ANY  	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  	PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE DEVELOPER(S) BE  	LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  	OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  	OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  	LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ----------------------------------------------------------------------------- Dedicated to:	My family and Max, my Golden Retriever  Thanks to:	Jordan Hubbard (jkh) for getting me ramped-up to 2.x system 		quickly enough to make the 2.1 release.  He put up with 		plenty of silly questions.  and 		The people who donated equipment and other material to make 		development of this driver possible.  Donations and 		sponsors for projects are appreciated.   ----------------------------------------------------------------------------- Edit History - (should be in sync with any source control log entries)  	Never seen one of these before?  Ok, here is how it works. 	Every time you change the code, you increment the edit number, 	that number over there in the<%d> and in the (%d) in the 	version string.  You never set this number lower than it is. 	Near, or preferably on lines that change, insert the edit 	number.  If there is a number there already, you can replace it 	with a newer one.  	In the edit history, start with the edit number, and a good 	description of what changes were made.  Then follow it with 	the date, your name and an EMAIL address where you can be reached.  	Please follow this practice; it helps leave understandable code in 	your wake.  	FYI, you have major and minor release codes.  These are numbered 	1 thru n.  Major feature additions should get a new major release 	number.  Minor releases start with a null and then letters 	A thru Z.  So  3A(456) is Major release 3, Minor release 1, 	Edit 456 (in Microsoft-ese that would be 03.01.456), and 5(731) 	is Major release 5, Minor release 0, Edit 731.  Typically only the 	author will change the major and minor release codes.  				EDIT edit Edit HISTORY history History<1>	This initial version is to get basic filesystem I/O working 	using the SoundBlaster 16 interface.  The stand-alone adapter 	card doesn't work yet. 	December 1994  Frank Durda IV	bsdmail@nemesis.lonestar.org<2>	Corrections to resolve a race condition when multiple drives 	on the same controller was active.  Fixed drive 1& 2 swap 	problem.  See selectdrive(). 	21-Jan-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<3>	Added automatic probing and support for all Creative Labs sound 	cards with the Creative/Panasonic interface and the stand-alone 	interface adapters.  See AUTOHUNT and FULLCONFIG conditionals 	for more information. 	21-Jan-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<4>	Rebundled debug conditionals. 	14-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<5>	Changes needed to work on FreeBSD 2.1.  Also added draincmd 	since some conditions cause the drive to produce surprise data. 	See setmode and draincmd 	19-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<6>	Got rid of some redundant error code by creating chk_error(). 	Also built a nice generic buss-lock function. 	20-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<7>	Improved comments, general structuring. 	Fixed a problem with disc eject not working if LOCKDRIVE was set. 	Apparently the drive will reject an EJECT command if the drive 	is LOCKED. 	21-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org  Edit number code marking begins here - earlier edits were during development.<8>	Final device name selected and actually made to compile under>2.0. For newer systems, it is "matcd", for older it is "mat". 	24-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<9>	Added some additional disk-related ioctl functions that didn't 	make it into earlier versions.   	26-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<10>	Updated some conditionals so the code will compile under 	1.1.5.1, although this is not the supported platform. 	Also found that some other devices probe code was changing the 	settings for the port 0x302 debug board, so added code to set it 	to a sane state before we use it. 	26-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org   ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*Match this format:		Version__dc(d)__dd-mmm-yy	*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|MATCDVERSION
index|[]
init|=
literal|"Version  1(10)  26-Feb-95"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	The following strings may not be changed*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|MATCDCOPYRIGHT
index|[]
init|=
literal|"Matsushita CD-ROM driver, Copr. 1994,1995 Frank Durda IV"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	The proceeding strings may not be changed*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- 	Include declarations ---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"dkbad.h"
end_include

begin_include
include|#
directive|include
file|"cdio.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"disklabel.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"options.h"
end_include

begin_comment
comment|/*Conditional compile options and 					  probe port hints*/
end_comment

begin_include
include|#
directive|include
file|"matcd.h"
end_include

begin_comment
comment|/*Drive-related defines and strings*/
end_comment

begin_include
include|#
directive|include
file|"creative.h"
end_include

begin_comment
comment|/*Host interface related defines*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- 	Defines and structures ---------------------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FULLCONFIG
end_ifdef

begin_define
define|#
directive|define
name|NUMCTRLRS
value|4
end_define

begin_comment
comment|/*With modern boards, four is max*/
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*FULLCONFIG*/
end_comment

begin_define
define|#
directive|define
name|NUMCTRLRS
value|1
end_define

begin_comment
comment|/*Produces a slightly smaller kernel*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*FULLCONFIG*/
end_comment

begin_define
define|#
directive|define
name|DRIVESPERC
value|4
end_define

begin_comment
comment|/*This is a constant*/
end_comment

begin_define
define|#
directive|define
name|TOTALDRIVES
value|NUMCTRLRS*DRIVESPERC
end_define

begin_comment
comment|/*Max possible drives*/
end_comment

begin_if
if|#
directive|if
name|DIAGPORT
operator|>
literal|0xff
end_if

begin_comment
comment|/*<10>*/
end_comment

begin_define
define|#
directive|define
name|DIAGOUT
value|outw
end_define

begin_comment
comment|/*<10>*/
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*DIAGPORT*/
end_comment

begin_comment
comment|/*<10>*/
end_comment

begin_define
define|#
directive|define
name|DIAGOUT
value|outb
end_define

begin_comment
comment|/*<10>*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DIAGPORT*/
end_comment

begin_comment
comment|/*<10>*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGPORT
end_ifdef

begin_decl_stmt
name|int
name|diagloop
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Used to show looping*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DIAGPORT*/
end_comment

begin_define
define|#
directive|define
name|TICKRES
value|10
end_define

begin_comment
comment|/*Our coarse timer resolution*/
end_comment

begin_define
define|#
directive|define
name|ISABUSKHZ
value|8330
end_define

begin_comment
comment|/*Number of IN/OUT ISA/sec*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FREE2
end_ifndef

begin_define
define|#
directive|define
name|RAW_PART
value|2
end_define

begin_comment
comment|/*Needs to be defined in 1.1.5.1*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*FREE2*/
end_comment

begin_define
define|#
directive|define
name|MATCDBLK
value|2048
end_define

begin_comment
comment|/*Standard block size*/
end_comment

begin_define
define|#
directive|define
name|MATCDRBLK
value|2352
end_define

begin_comment
comment|/*Raw and/or DA block size*/
end_comment

begin_define
define|#
directive|define
name|MATCD_RETRYS
value|5
end_define

begin_comment
comment|/*Number of retries for read ops*/
end_comment

begin_define
define|#
directive|define
name|MATCD_READ_1
value|0x80
end_define

begin_comment
comment|/*Read state machine defines*/
end_comment

begin_define
define|#
directive|define
name|MATCD_READ_2
value|0x90
end_define

begin_comment
comment|/*Read state machine defines*/
end_comment

begin_struct
struct|struct
name|matcd_volinfo
block|{
name|unsigned
name|char
name|type
decl_stmt|;
comment|/*00 CD-DA or CD-ROM 					  10 CD-I 					  20 XA */
name|unsigned
name|char
name|trk_low
decl_stmt|;
comment|/*Normally 1*/
name|unsigned
name|char
name|trk_high
decl_stmt|;
comment|/*Highest track number*/
name|unsigned
name|char
name|vol_msf
index|[
literal|3
index|]
decl_stmt|;
comment|/*Size of disc in min/sec/frame*/
block|}
struct|;
end_struct

begin_struct
struct|struct
name|matcd_mbx
block|{
name|short
name|controller
decl_stmt|;
name|short
name|ldrive
decl_stmt|;
name|short
name|partition
decl_stmt|;
name|short
name|port
decl_stmt|;
name|short
name|retry
decl_stmt|;
name|short
name|nblk
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|u_long
name|skip
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|p_offset
decl_stmt|;
name|short
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|matcd_data
block|{
name|short
name|config
decl_stmt|;
name|short
name|drivemode
decl_stmt|;
comment|/*Last state drive was set to*/
name|short
name|flags
decl_stmt|;
name|short
name|status
decl_stmt|;
name|int
name|blksize
decl_stmt|;
name|u_long
name|disksize
decl_stmt|;
name|int
name|iobase
decl_stmt|;
name|struct
name|disklabel
name|dlabel
decl_stmt|;
name|int
name|partflags
index|[
name|MAXPARTITIONS
index|]
decl_stmt|;
name|int
name|openflags
decl_stmt|;
name|struct
name|matcd_volinfo
name|volinfo
decl_stmt|;
name|short
name|debug
decl_stmt|;
name|struct
name|matcd_mbx
name|mbx
decl_stmt|;
block|}
name|matcd_data
index|[
name|TOTALDRIVES
index|]
struct|;
end_struct

begin_comment
comment|/*	Bit equates for matcd_data.flags*/
end_comment

begin_define
define|#
directive|define
name|MATCDINIT
value|0x0001
end_define

begin_comment
comment|/*Probe ran on host adapter*/
end_comment

begin_define
define|#
directive|define
name|MATCDLABEL
value|0x0004
end_define

begin_comment
comment|/*Valid TOC exists*/
end_comment

begin_define
define|#
directive|define
name|MATCDWARN
value|0x0020
end_define

begin_comment
comment|/*Have reported an open disc change*/
end_comment

begin_comment
comment|/*	Bit equates for matcd_data.partflags*/
end_comment

begin_define
define|#
directive|define
name|MATCDOPEN
value|0x0001
end_define

begin_define
define|#
directive|define
name|MATCDREADRAW
value|0x0002
end_define

begin_define
define|#
directive|define
name|DELAY_STATUS
value|10000l
end_define

begin_comment
comment|/* 10000 * 1us */
end_comment

begin_define
define|#
directive|define
name|DELAY_GETREPLY
value|200000l
end_define

begin_comment
comment|/* 200000 * 2us */
end_comment

begin_define
define|#
directive|define
name|DELAY_SEEKREAD
value|20000l
end_define

begin_comment
comment|/* 20000 * 1us */
end_comment

begin_define
define|#
directive|define
name|matcd_delay
value|DELAY
end_define

begin_comment
comment|/*	Error classes returned by chk_error()*/
end_comment

begin_define
define|#
directive|define
name|ERR_RETRY
value|1
end_define

begin_comment
comment|/*A retry might recover this*/
end_comment

begin_define
define|#
directive|define
name|ERR_INIT
value|2
end_define

begin_comment
comment|/*A retry almost certainly will get this*/
end_comment

begin_define
define|#
directive|define
name|ERR_FATAL
value|3
end_define

begin_comment
comment|/*This cannot be recovered from*/
end_comment

begin_decl_stmt
name|struct
name|buf
name|request_head
index|[
name|NUMCTRLRS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*A queue for each host interface*/
end_comment

begin_decl_stmt
name|int
name|nextcontroller
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Number of interface units found*/
end_comment

begin_decl_stmt
name|int
name|drivepresent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*Don't change this - see license*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|matcd_mbx
modifier|*
name|mbxsave
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|if_state
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*State of the host I/F and buss*/
end_comment

begin_comment
comment|/*	Flags in the if_state array */
end_comment

begin_define
define|#
directive|define
name|BUSSBUSY
value|0x01
end_define

begin_comment
comment|/*Buss is already busy*/
end_comment

begin_struct
struct|struct
name|matcd_read2
block|{
name|unsigned
name|char
name|start_msf
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|end_msf
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*--------------------------------------------------------------------------- 	These macros take apart the minor number and yield the 	partition, drive on controller, and controller. 	This must match the settings in /dev/MAKEDEV. ---------------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|matcd_partition
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev))& 0x07)
end_define

begin_define
define|#
directive|define
name|matcd_ldrive
parameter_list|(
name|dev
parameter_list|)
value|(((minor(dev))& 0x78)>> 3)
end_define

begin_define
define|#
directive|define
name|matcd_cdrive
parameter_list|(
name|dev
parameter_list|)
value|(((minor(dev))& 0x18)>> 3)
end_define

begin_define
define|#
directive|define
name|matcd_controller
parameter_list|(
name|dev
parameter_list|)
value|(((minor(dev))& 0x60)>> 5)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|FREE2
end_ifndef

begin_comment
comment|/*--------------------------------------------------------------------------- 	This makes the long function names shorter for systems 	using the older kernel config program ---------------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|matcdopen
value|matopen
end_define

begin_comment
comment|/*<8>*/
end_comment

begin_define
define|#
directive|define
name|matcdclose
value|matclose
end_define

begin_comment
comment|/*<8>*/
end_comment

begin_define
define|#
directive|define
name|matcdstrategy
value|matstrategy
end_define

begin_comment
comment|/*<8>*/
end_comment

begin_define
define|#
directive|define
name|matcdioctl
value|matioctl
end_define

begin_comment
comment|/*<8>*/
end_comment

begin_define
define|#
directive|define
name|matcdsize
value|matsize
end_define

begin_comment
comment|/*<8>*/
end_comment

begin_define
define|#
directive|define
name|matcddriver
value|matdriver
end_define

begin_comment
comment|/*<10>*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*FREE2*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- 	Entry points and other connections to/from kernel - see conf.c ---------------------------------------------------------------------------*/
end_comment

begin_function_decl
name|int
name|matcdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|matcdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|matcdstrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|matcdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|command
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|matcdsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|matcd_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|matcd_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|matcddriver
init|=
block|{
name|matcd_probe
block|,
name|matcd_attach
block|,
literal|"matcd interface "
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------------------------- 	Internal function declarations ---------------------------------------------------------------------------*/
end_comment

begin_function_decl
specifier|static
name|int
name|matcd_getdisklabel
parameter_list|(
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|matcd_start
parameter_list|(
name|struct
name|buf
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zero_cmd
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|matcd_pread
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|count
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_fastcmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|matcd_slowcmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_getstat
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|sflg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|matcd_setflags
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|struct
name|matcd_data
modifier|*
name|cd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msf2hsg
parameter_list|(
name|unsigned
name|char
modifier|*
name|msf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|matcd_blockread
parameter_list|(
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_getreply
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|dly
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|selectdrive
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|drive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doreset
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|doprobe
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|watchdog
parameter_list|(
name|int
name|state
parameter_list|,
name|char
modifier|*
name|foo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lockbuss
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unlockbuss
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_volinfo
parameter_list|(
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draincmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_error
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chk_error
parameter_list|(
name|int
name|errnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msf_to_blk
parameter_list|(
name|unsigned
name|char
modifier|*
name|cd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|docmd
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|get_stat
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|matcd_eject
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|media_chk
parameter_list|(
name|struct
name|matcd_data
modifier|*
name|cd
parameter_list|,
name|int
name|errnum
parameter_list|,
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|waitforit
parameter_list|(
name|int
name|timelimit
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|port
parameter_list|,
name|char
modifier|*
name|where
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|FULLDRIVER
end_ifdef

begin_function_decl
specifier|static
name|int
name|matcd_playtracks
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_track
modifier|*
name|pt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_playmsf
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_msf
modifier|*
name|pt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_pause
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_msf
modifier|*
name|addr
parameter_list|,
name|int
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_stop
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_msf
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*FULLDRIVER*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------- 	matcdopen - Open the device  	This routine actually gets called every time anybody opens 	any partition on a drive.  But the first call is the one that 	does all the work.    	If you #define LOCKDRIVE, the drive eject button will be ignored 	while any partition on the drive is open. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|cdrive
decl_stmt|,
name|ldrive
decl_stmt|,
name|partition
decl_stmt|,
name|controller
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
if|#
directive|if
name|DIAGPORT
operator|==
literal|0x302
comment|/*<10>*/
name|DIAGOUT
argument_list|(
literal|0x300
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*<10>Init diag board in case some 					  other device probe scrambled it*/
endif|#
directive|endif
comment|/*<10>DIAGPORT*/
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cdrive
operator|=
name|matcd_cdrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|partition
operator|=
name|matcd_partition
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|controller
operator|=
name|matcd_controller
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*and port#*/
if|if
condition|(
name|ldrive
operator|>=
name|TOTALDRIVES
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Open: dev %x partition %x controller %x flags %x cdrive %x\n"
argument_list|,
name|ldrive
argument_list|,
name|dev
argument_list|,
name|partition
argument_list|,
name|controller
argument_list|,
name|cd
operator|->
name|flags
argument_list|,
name|matcd_cdrive
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDINIT
operator|)
condition|)
block|{
comment|/*Did probe find this drive*/
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|&&
name|cd
operator|->
name|openflags
condition|)
block|{
comment|/*Has drive completely closed?*/
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*No, all partitions must close*/
block|}
comment|/*	Now, test to see if the media is ready */
name|lockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|NOP
expr_stmt|;
comment|/*Test drive*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"matcdopen"
argument_list|)
expr_stmt|;
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
name|unlockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release buss lock*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_DSKIN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*Is there a disc in the drive?*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: No Disc in open\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|z
operator|&
name|MATCD_ST_ERROR
condition|)
block|{
comment|/*Was there an error*/
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Find out what it was*/
if|if
condition|(
name|cd
operator|->
name|openflags
condition|)
block|{
comment|/*Any parts open?*/
if|if
condition|(
name|media_chk
argument_list|(
name|cd
argument_list|,
name|i
argument_list|,
name|ldrive
argument_list|)
condition|)
block|{
comment|/*Was it a disc chg?*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Disc change detected i %x z %x\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
block|}
comment|/*	Here we fill in the disklabel structure although most is 	hardcoded. */
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|cd
operator|->
name|dlabel
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel
argument_list|)
argument_list|)
expr_stmt|;
comment|/*	Now we query the drive for the actual size of the media. 	This is where we find out of there is any media or if the 	media isn't a Mode 1 or Mode 2/XA disc. 	See version information about Mode 2/XA support. */
name|lockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|i
operator|=
name|matcdsize
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unlockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release buss lock*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Buss unlocked in open\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: Could not read the disc size\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*matcdsize filled in rest of dlabel*/
comment|/*	Based on the results, fill in the variable entries in the disklabel */
name|cd
operator|->
name|dlabel
operator|.
name|d_secsize
operator|=
name|cd
operator|->
name|blksize
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_ncylinders
operator|=
operator|(
name|cd
operator|->
name|disksize
operator|/
literal|100
operator|)
operator|+
literal|1
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_secperunit
operator|=
name|cd
operator|->
name|disksize
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
name|cd
operator|->
name|disksize
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_checksum
operator|=
name|dkcksum
argument_list|(
operator|&
name|cd
operator|->
name|dlabel
argument_list|)
expr_stmt|;
comment|/*	Now fill in the hardcoded section */
comment|/*123456789012345678*/
name|strncpy
argument_list|(
name|cd
operator|->
name|dlabel
operator|.
name|d_typename
argument_list|,
literal|"Matsushita CDR "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cd
operator|->
name|dlabel
operator|.
name|d_packname
argument_list|,
literal|"(c) 1994, fdiv "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_magic
operator|=
name|DISKMAGIC
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_magic2
operator|=
name|DISKMAGIC
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_nsectors
operator|=
literal|100
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_secpercyl
operator|=
literal|100
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_ntracks
operator|=
literal|1
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_interleave
operator|=
literal|1
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_rpm
operator|=
literal|300
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_npartitions
operator|=
literal|1
expr_stmt|;
comment|/*See note below*/
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_fstype
operator|=
literal|9
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_flags
operator|=
name|D_REMOVABLE
expr_stmt|;
comment|/*	I originally considered allowing the partition match tracks or 	sessions on the media, but since you are allowed up to 99 	tracks in the RedBook world, this would not fit in with the 	BSD fixed partition count scheme.  So ioctls are used to shift 	the track to be accessed into partition 1. */
name|cd
operator|->
name|flags
operator||=
name|MATCDLABEL
expr_stmt|;
comment|/*Mark drive as having TOC*/
block|}
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d open2: partition=%d disksize=%d blksize=%x flags=%x\n"
argument_list|,
name|ldrive
argument_list|,
name|partition
argument_list|,
name|cd
operator|->
name|disksize
argument_list|,
name|cd
operator|->
name|blksize
argument_list|,
name|cd
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
ifdef|#
directive|ifdef
name|LOCKDRIVE
if|if
condition|(
name|cd
operator|->
name|openflags
operator|==
literal|0
condition|)
block|{
name|lockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|LOCK
expr_stmt|;
comment|/*Lock drive*/
name|cmd
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"matcdopen"
argument_list|)
expr_stmt|;
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
name|unlockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release buss lock*/
block|}
endif|#
directive|endif
comment|/*LOCKDRIVE*/
name|cd
operator|->
name|openflags
operator||=
operator|(
literal|1
operator|<<
name|partition
operator|)
expr_stmt|;
comment|/*Mark partition open*/
if|if
condition|(
name|partition
operator|==
name|RAW_PART
operator|||
operator|(
name|partition
operator|<
name|cd
operator|->
name|dlabel
operator|.
name|d_npartitions
operator|&&
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
index|[
name|partition
index|]
operator|.
name|p_fstype
operator|!=
name|FS_UNUSED
operator|)
condition|)
block|{
name|cd
operator|->
name|partflags
index|[
name|partition
index|]
operator||=
name|MATCDOPEN
expr_stmt|;
if|if
condition|(
name|partition
operator|==
name|RAW_PART
condition|)
block|{
name|cd
operator|->
name|partflags
index|[
name|partition
index|]
operator||=
name|MATCDREADRAW
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Open is complete\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Open FAILED\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcdclose - Close the device  	Depending on how you compiled the driver, close may not  	do much other than clear some driver settings. 	Note that audio playback will continue.  	If you did #define LOCKDRIVE, the drive was locked when the 	matcdopen call is done.  If we did that, then we unlock the 	drive now. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|ldrive
decl_stmt|,
name|cdrive
decl_stmt|,
name|port
decl_stmt|,
name|partition
decl_stmt|,
name|controller
decl_stmt|,
name|i
decl_stmt|,
name|z
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cdrive
operator|=
name|matcd_cdrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cd
operator|=
name|matcd_data
operator|+
name|ldrive
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*and port#*/
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
if|if
condition|(
name|ldrive
operator|>=
name|TOTALDRIVES
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|partition
operator|=
name|matcd_partition
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|controller
operator|=
name|matcd_controller
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Close partition=%d\n"
argument_list|,
name|ldrive
argument_list|,
name|partition
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDINIT
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|cd
operator|->
name|partflags
index|[
name|partition
index|]
operator|&=
operator|~
operator|(
name|MATCDOPEN
operator||
name|MATCDREADRAW
operator|)
expr_stmt|;
name|cd
operator|->
name|openflags
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|partition
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKDRIVE
if|if
condition|(
name|cd
operator|->
name|openflags
operator|==
literal|0
condition|)
block|{
name|lockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|LOCK
expr_stmt|;
comment|/*Unlock drive*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"matcdopen"
argument_list|)
expr_stmt|;
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
name|unlockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release buss lock*/
block|}
endif|#
directive|endif
comment|/*LOCKDRIVE*/
name|cd
operator|->
name|flags
operator|&=
operator|~
name|MATCDWARN
expr_stmt|;
comment|/*Clear any warning flag*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcdstrategy - Accepts I/O requests from kernel for processing  	This routine accepts a read request block pointer (historically 	but somewhat inaccurately called *bp for buffer pointer). 	Various sanity checks are performed on the request. 	When we are happy with the request and the state of the device, 	the request is added to the queue of requests for the controller 	that the drive is connected to.  We support multiple controllers 	so there are multiple queues.  Once the request is added, we 	call the matcd_start routine to start the device in case it isn't 	doing something already.   All I/O including ioctl requests 	rely on the current request starting the next one before exiting. ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|matcdstrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|ldrive
decl_stmt|,
name|controller
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|controller
operator|=
name|matcd_controller
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Strategy: buf=0x%lx, block#=%ld bcount=%ld\n"
argument_list|,
name|ldrive
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
if|if
condition|(
name|ldrive
operator|>=
name|TOTALDRIVES
operator|||
name|bp
operator|->
name|b_blkno
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: Bogus parameters received - kernel may be corrupted\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
condition|)
comment|/*Request is zero-length - all done*/
goto|goto
name|done
goto|;
if|if
condition|(
name|matcd_partition
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
operator|!=
name|RAW_PART
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bounds_check_with_label
argument_list|(
name|bp
argument_list|,
operator|&
name|cd
operator|->
name|dlabel
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
name|bp
operator|->
name|b_pblkno
operator|=
name|bp
operator|->
name|b_blkno
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/*Make sure we don't get intr'ed*/
name|dp
operator|=
operator|&
name|request_head
index|[
name|controller
index|]
expr_stmt|;
comment|/*Pointer to controller queue*/
name|disksort
argument_list|(
name|dp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/*Add new request (bp) to queue (dp 					  and sort the requests in a way that 					  may not be ideal for CD-ROM media*/
ifdef|#
directive|ifdef
name|DEBUGQUEUE
name|printf
argument_list|(
literal|"matcd%d: Dump BP chain:  -------\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
while|while
condition|(
name|bp
condition|)
block|{
name|printf
argument_list|(
literal|"Block %d\n"
argument_list|,
name|bp
operator|->
name|b_pblkno
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREE2
name|bp
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
else|#
directive|else
comment|/*FREE2*/
name|bp
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
endif|#
directive|endif
comment|/*FREE2*/
block|}
name|printf
argument_list|(
literal|"matcd%d: ---------------------\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGQUEUE*/
name|matcd_start
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/*Ok, with our newly sorted queue, 					  see if we can start an I/O operation 					  right now*/
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*Return priorities to normal*/
return|return;
comment|/*All done*/
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/*Request bad in some way*/
name|done
label|:
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
comment|/*Show un read amount*/
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/*Signal we have done all we plan to*/
return|return;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_start - Pull a request from the queue and consider doing it. ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|matcd_start
parameter_list|(
name|struct
name|buf
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|partition
modifier|*
name|p
decl_stmt|;
name|int
name|part
decl_stmt|,
name|ldrive
decl_stmt|,
name|controller
decl_stmt|;
specifier|register
name|s
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0x40
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
name|diagloop
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/*DIAGPORT*/
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/*Nothing on read queue to do?*/
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|matcd_data
operator|->
name|status
argument_list|)
expr_stmt|;
comment|/*Wakeup any blocked*/
return|return;
comment|/* opens, ioctls, etc*/
block|}
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
comment|/*Get logical drive#*/
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
comment|/*Get pointer to data for this drive*/
name|controller
operator|=
name|matcd_controller
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
comment|/*Also get interface #*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: In start controller %d\n"
argument_list|,
name|ldrive
argument_list|,
name|controller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
if|if
condition|(
name|if_state
index|[
name|controller
index|]
operator|&
name|BUSSBUSY
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Dropping thread in start,  controller %d\n"
argument_list|,
name|ldrive
argument_list|,
name|controller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
return|return;
block|}
ifdef|#
directive|ifdef
name|FREE2
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
else|#
directive|else
comment|/*FREE2*/
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|av_forw
expr_stmt|;
comment|/*Get next request from queue*/
endif|#
directive|endif
comment|/*FREE2*/
name|part
operator|=
name|matcd_partition
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
expr_stmt|;
name|p
operator|=
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
operator|+
name|part
expr_stmt|;
name|if_state
index|[
name|controller
index|]
operator||=
name|BUSSBUSY
expr_stmt|;
comment|/*Mark buss as busy*/
name|cd
operator|->
name|mbx
operator|.
name|ldrive
operator|=
name|ldrive
expr_stmt|;
comment|/*Save current logical drive*/
name|cd
operator|->
name|mbx
operator|.
name|controller
operator|=
name|controller
expr_stmt|;
comment|/*and controller*/
name|cd
operator|->
name|mbx
operator|.
name|partition
operator|=
name|part
expr_stmt|;
comment|/*and partition (2048 vs 2532)*/
name|cd
operator|->
name|mbx
operator|.
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*and port#*/
name|cd
operator|->
name|mbx
operator|.
name|retry
operator|=
name|MATCD_RETRYS
expr_stmt|;
comment|/*and the retry count*/
name|cd
operator|->
name|mbx
operator|.
name|bp
operator|=
name|bp
expr_stmt|;
comment|/*and the bp*/
name|cd
operator|->
name|mbx
operator|.
name|p_offset
operator|=
name|p
operator|->
name|p_offset
expr_stmt|;
comment|/*and where the data will go*/
name|matcd_blockread
argument_list|(
name|MATCD_READ_1
operator|+
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Actually start the read*/
return|return;
comment|/*Dropping thread.  matcd_blockread 					  must have scheduled a timeout or 					  we will go to sleep forever*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcdioctl - Process things that aren't block reads  	In this driver, ioctls are used mainly to change 	the mode the drive is running in, play audio and other 	things that don't fit into the block read scheme of things. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|command
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|ldrive
decl_stmt|,
name|cdrive
decl_stmt|,
name|partition
decl_stmt|;
name|int
name|i
decl_stmt|,
name|z
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|port
decl_stmt|,
name|controller
decl_stmt|;
name|unsigned
name|char
name|zz
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0x50
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cdrive
operator|=
name|matcd_cdrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|partition
operator|=
name|matcd_partition
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|controller
operator|=
name|ldrive
operator|>>
literal|2
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: ioctl %x cdrive %x parms "
argument_list|,
name|ldrive
argument_list|,
name|command
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|zz
operator|=
name|addr
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%02x "
argument_list|,
name|zz
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  flags %x\n"
argument_list|,
name|cd
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
condition|)
comment|/*Did we read TOC OK?*/
return|return
operator|(
name|EIO
operator|)
return|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|DIOCSBAD
case|:
comment|/*<9>*/
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*<9>*/
case|case
name|DIOCGDINFO
case|:
comment|/*<9>*/
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
operator|=
name|cd
operator|->
name|dlabel
expr_stmt|;
comment|/*<9>*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*<9>*/
case|case
name|DIOCGPART
case|:
comment|/*<9>*/
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|disklab
operator|=
operator|&
name|cd
operator|->
name|dlabel
expr_stmt|;
comment|/*<9>*/
operator|(
operator|(
expr|struct
name|partinfo
operator|*
operator|)
name|addr
operator|)
operator|->
name|part
operator|=
comment|/*<9>*/
operator|&
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
index|[
name|matcd_partition
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
comment|/*<9>*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*<9>*/
case|case
name|DIOCWDINFO
case|:
comment|/*<9>*/
case|case
name|DIOCSDINFO
case|:
comment|/*<9>*/
ifdef|#
directive|ifdef
name|FREE2
comment|/*<10>*/
if|if
condition|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*<9>*/
return|return
operator|(
name|EBADF
operator|)
return|;
comment|/*<9>*/
block|}
comment|/*<9>*/
else|else
block|{
comment|/*<9>*/
return|return
name|setdisklabel
argument_list|(
operator|&
name|cd
operator|->
name|dlabel
argument_list|,
comment|/*<9>*/
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
return|;
comment|/*<9>*/
block|}
comment|/*<9>*/
endif|#
directive|endif
comment|/*<10>FREE2*/
case|case
name|DIOCWLABEL
case|:
comment|/*<9>*/
return|return
operator|(
name|EBADF
operator|)
return|;
comment|/*<9>*/
case|case
name|CDIOCEJECT
case|:
return|return
operator|(
name|matcd_eject
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|FULLDRIVER
case|case
name|CDIOCPLAYTRACKS
case|:
return|return
operator|(
name|matcd_playtracks
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_play_track
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCPLAYMSF
case|:
return|return
operator|(
name|matcd_playmsf
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_play_msf
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCRESUME
case|:
return|return
operator|(
name|matcd_pause
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_play_msf
operator|*
operator|)
name|addr
argument_list|,
name|RESUME
argument_list|)
operator|)
return|;
case|case
name|CDIOCPAUSE
case|:
return|return
operator|(
name|matcd_pause
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_play_msf
operator|*
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
name|CDIOCSTOP
case|:
return|return
operator|(
name|matcd_stop
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_play_msf
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCGETVOL
case|:
case|case
name|CDIOCSETVOL
case|:
case|case
name|CDIOCSETMONO
case|:
case|case
name|CDIOCSETSTERIO
case|:
case|case
name|CDIOCSETMUTE
case|:
case|case
name|CDIOCSETLEFT
case|:
case|case
name|CDIOCSETRIGHT
case|:
endif|#
directive|endif
comment|/*FULLDRIVER*/
case|case
name|CDIOCREADSUBCHANNEL
case|:
case|case
name|CDIOREADTOCHEADER
case|:
case|case
name|CDIOREADTOCENTRYS
case|:
case|case
name|CDIOCSETPATCH
case|:
case|case
name|CDIOCSTART
case|:
case|case
name|CDIOCRESET
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcdsize - Reports how many blocks exist on the disc. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcdsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|blksize
decl_stmt|;
name|int
name|ldrive
decl_stmt|,
name|part
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|part
operator|=
name|matcd_partition
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|==
name|RAW_PART
condition|)
name|blksize
operator|=
name|MATCDRBLK
expr_stmt|;
comment|/*2353*/
else|else
name|blksize
operator|=
name|MATCDBLK
expr_stmt|;
comment|/*2048*/
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
if|if
condition|(
name|matcd_volinfo
argument_list|(
name|ldrive
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|cd
operator|->
name|blksize
operator|=
name|blksize
expr_stmt|;
name|size
operator|=
name|msf_to_blk
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
argument_list|)
expr_stmt|;
name|cd
operator|->
name|disksize
operator|=
name|size
operator|*
operator|(
name|blksize
operator|/
name|DEV_BSIZE
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Media size %d\n"
argument_list|,
name|ldrive
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_probe - Search for host interface/adapters  	The probe routine hunts for the first drive on the interface since 	there is no way to locate just the adapter.   It also resets the 	entire drive chain while it is there.  matcd_attach() takes care of 	the rest of the initialization.  	The probe routine can be compiled two ways.  In AUTOHUNT mode, 	the kernel config file can say "port?" and we will check all ports 	listed in the port_hint array (see above).    	Without AUTOHUNT set, the config file must list a specific port 	address to check.    	Note that specifying the explicit addresses makes boot-up a lot 	faster.  	The probe will locate Panasonic/Creative interface on the following 	Creative adapter boards: 		#1730  Sound Blaster 16 		#1740  Sound Blaster 16 (cost reduced) 		#1810  omniCD upgrade kit adapter card (stand-alone CD) 		#3100  PhoneBlaster SB16 + Sierra 14.4K modem combo 	Creative releases a newer and cheaper-to-make Sound Blaster 	board every few months, so by the original release date of this 	software, there are probably 8 different board models called 	Sound Blaster 16.  These include "Vibra", "Value", etc.  	Please report additional part numbers and board descriptions  	and new port numbers that work to the author.  ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cdrive
decl_stmt|;
name|unsigned
name|char
name|y
decl_stmt|,
name|z
decl_stmt|,
name|drive
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|port
init|=
name|dev
operator|->
name|id_iobase
decl_stmt|;
comment|/*Take port hint from config file*/
name|cdrive
operator|=
name|nextcontroller
expr_stmt|;
comment|/*Controller defined by pass for now*/
if|#
directive|if
name|DIAGPORT
operator|==
literal|0x302
comment|/*<10>*/
name|DIAGOUT
argument_list|(
literal|0x300
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/*<10>Init diag board in case some 					  other device probe scrambled it*/
endif|#
directive|endif
comment|/*<10>DIAGPORT*/
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
if|if
condition|(
name|nextcontroller
operator|==
name|NUMCTRLRS
condition|)
block|{
name|printf
argument_list|(
literal|"matcdc%d: - Too many interfaces specified in config\n"
argument_list|,
name|nextcontroller
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nextcontroller
operator|==
literal|0
condition|)
block|{
comment|/*Very first time to be called*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTALDRIVES
condition|;
name|i
operator|++
control|)
block|{
name|matcd_data
index|[
name|i
index|]
operator|.
name|drivemode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
name|matcd_data
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|i
operator|=
name|nextcontroller
operator|*
name|DRIVESPERC
expr_stmt|;
comment|/*Precompute controller offset*/
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|DRIVESPERC
condition|;
name|y
operator|++
control|)
block|{
name|matcd_data
index|[
name|i
operator|+
name|y
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|matcd_data
index|[
name|i
operator|+
name|y
index|]
operator|.
name|config
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcdc%d: In probe i %d y %d port %x\n"
argument_list|,
name|nextcontroller
argument_list|,
name|i
argument_list|,
name|y
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
ifdef|#
directive|ifdef
name|AUTOHUNT
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcd%d: size of port_hints %d\n"
argument_list|,
name|nextcontroller
argument_list|,
sizeof|sizeof
argument_list|(
name|port_hints
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|port_hints
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|port
operator|=
name|port_hints
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcdc%d: Port hint %x\n"
argument_list|,
name|nextcontroller
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
block|{
name|dev
operator|->
name|id_iobase
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*Put port ? back*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Nothing left to try*/
block|}
if|if
condition|(
name|port
operator|!=
literal|0
condition|)
block|{
comment|/*Unused port found*/
name|dev
operator|->
name|id_iobase
operator|=
name|port
expr_stmt|;
name|port_hints
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/*Don't use that port again*/
if|if
condition|(
name|doprobe
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NUMPORTS
operator|)
return|;
block|}
block|}
name|dev
operator|->
name|id_iobase
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*Put port ? back as it was*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Interface not found*/
block|}
else|else
block|{
comment|/*Config specified a port*/
name|i
operator|=
literal|0
expr_stmt|;
comment|/*so eliminate it from the hint list*/
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
comment|/*or we might try to assign it again*/
if|if
condition|(
name|port_hints
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/*End of list*/
if|if
condition|(
name|port_hints
index|[
name|i
index|]
operator|==
name|port
condition|)
block|{
name|port_hints
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/*Clear duplicate*/
break|break;
block|}
block|}
if|if
condition|(
name|doprobe
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NUMPORTS
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
comment|/*AUTOHUNT*/
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: AUTOHUNT disabled but port? specified in config\n"
argument_list|,
name|nextcontroller
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|doprobe
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NUMPORTS
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/*AUTOHUNT*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	doprobe - Common probe code that actually checks the ports we  		have decided to test. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|doprobe
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|)
block|{
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|RESETONBOOT
name|doreset
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Reset what might be our device*/
endif|#
directive|endif
comment|/*RESETONBOOT*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|NOP
expr_stmt|;
comment|/*A reasonably harmless command. 				  	  This command will fail after 				  	  power-up or after reset. That's OK*/
if|if
condition|(
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cmd
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*Issue command*/
name|inb
argument_list|(
name|port
operator|+
name|CMD
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcdc%d: Probe found something\n"
argument_list|,
name|nextcontroller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
if|if
condition|(
name|drivepresent
operator|==
literal|0
condition|)
block|{
comment|/*Don't change this - see license*/
name|printf
argument_list|(
literal|"matcd - Matsushita (Panasonic) CD-ROM Driver by FDIV, %s\n"
argument_list|,
name|MATCDVERSION
argument_list|)
expr_stmt|;
comment|/*Don't change this - see license*/
name|drivepresent
operator|++
expr_stmt|;
comment|/*Don't change this - see license*/
block|}
comment|/*Don't change this - see license*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Drive 0 detected*/
block|}
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcdc%d: Probe DID NOT find something\n"
argument_list|,
name|nextcontroller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
return|return
operator|(
literal|1
operator|)
return|;
comment|/*Nothing detected*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_attach - Locates drives on the adapters that were located. 		If we got here, we located a interface and at least one 		drive.  Now we figure out how many drives are under that 		interface.  The Panasonic interface is too simple to call 		it a controller, but in the existing PDP model, that is 		what it would be. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|y
decl_stmt|,
name|z
decl_stmt|,
name|cdrive
decl_stmt|;
name|int
name|level
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|12
index|]
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|port
init|=
name|dev
operator|->
name|id_iobase
decl_stmt|;
comment|/*Take port ID selected in probe()*/
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcdc: Attach dev %x id_unit %d\n"
argument_list|,
name|dev
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
for|for
control|(
name|cdrive
operator|=
literal|0
init|;
name|cdrive
operator|<
literal|4
condition|;
name|cdrive
operator|++
control|)
block|{
comment|/*We're hunting drives...*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|NOP
expr_stmt|;
comment|/*A reasonably harmless command. 					  This command will fail after 					  power-up or after reset. It's OK*/
name|i
operator|=
name|cdrive
operator|+
operator|(
name|DRIVESPERC
operator|*
name|nextcontroller
operator|)
expr_stmt|;
if|if
condition|(
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|i
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*Issue command*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
condition|)
block|{
comment|/*If there was an error, 						  we must ask for error info 						  or subsequent cmds fail*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READERROR
expr_stmt|;
comment|/*Inquire*/
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|i
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|8
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcd%d: Status byte %x "
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
block|}
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READID
expr_stmt|;
comment|/*Get drive ID*/
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|i
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|10
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read Drive Parm*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
name|data
index|[
literal|10
index|]
operator|=
literal|0
expr_stmt|;
comment|/*Build ASCIZ string*/
name|printf
argument_list|(
literal|"matcd%d: [%s]  "
argument_list|,
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|i
index|]
expr_stmt|;
name|cd
operator|->
name|flags
operator||=
name|MATCDINIT
expr_stmt|;
name|cd
operator|->
name|iobase
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
name|cd
operator|->
name|openflags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPARTITIONS
condition|;
name|i
operator|++
control|)
block|{
name|cd
operator|->
name|partflags
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|nextcontroller
operator|++
expr_stmt|;
comment|/*Bump ctlr assign to next number*/
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/*End line of drive reports*/
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	zero_cmd - Initialize command buffer ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|zero_cmd
parameter_list|(
name|char
modifier|*
name|lcmd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCMDSIZ
condition|;
name|lcmd
index|[
name|i
operator|++
index|]
operator|=
literal|0
control|)
empty_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	doreset - Resets all the drives connected to a interface ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|doreset
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|z
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
name|outb
argument_list|(
name|port
operator|+
name|RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*Reset what might be our device*/
comment|/*Although this ensures a known 					  state, it does close the drive 					  door (if open) and aborts any 					  audio playback in progress. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|125
operator|*
name|ISABUSKHZ
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/*DELAY 500msec minimum. Worst 					  case is door open and none or 					  unreadable media */
name|z
operator|=
name|inb
argument_list|(
name|port
operator|+
name|CMD
argument_list|)
expr_stmt|;
comment|/*This makes the loop run at a 					  known speed.  This value is ok 					  for 8.33MHz bus*/
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|matcd_data
index|[
operator|(
name|cdrive
operator|*
literal|4
operator|)
operator|+
name|i
index|]
operator|.
name|drivemode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_fastcmd - Send a command to a drive  	This routine executed commands that return instantly (or reasonably 	quick), such as RESET, NOP, READ ERROR, etc.  The only difference 	between it and handling for slower commands, is the slower commands 	will invoke a timeout/sleep if they don't get an instant response.  	Fastcmd is mainly used in probe(), attach() and error related 	functions.  Every attempt should be made to NOT use this 	function for any command that might be executed when the system 	is up. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_fastcmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|z
decl_stmt|;
name|int
name|level
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|unsigned
name|char
modifier|*
name|cx
decl_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0x90
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
name|draincmd
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Make sure buss is really idle*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|cx
operator|=
name|cp
expr_stmt|;
name|printf
argument_list|(
literal|"matcd%d: Fast Send port %x sel %d command %x %x %x %x %x %x %x\n"
argument_list|,
name|ldrive
argument_list|,
name|port
argument_list|,
name|cdrive
argument_list|,
name|cx
index|[
literal|0
index|]
argument_list|,
name|cx
index|[
literal|1
index|]
argument_list|,
name|cx
index|[
literal|2
index|]
argument_list|,
name|cx
index|[
literal|3
index|]
argument_list|,
name|cx
index|[
literal|4
index|]
argument_list|,
name|cx
index|[
literal|5
index|]
argument_list|,
name|cx
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|selectdrive
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Enable the desired target drive*/
name|level
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/*----------------------------------------*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
comment|/*The seven bytes of the command*/
name|outb
argument_list|(
name|port
operator|+
name|CMD
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/*must be sent within 10msec or*/
block|}
comment|/*the drive will ignore the cmd*/
name|splx
argument_list|(
name|level
argument_list|)
expr_stmt|;
comment|/*------------------------------------------------*/
comment|/*	Now we wait a maximum of 240msec for a response. 	Only in a few rare cases does it take this long. 	If it is longer, the command should probably be slept on 	rather than increasing the timing value */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|60
operator|*
name|ISABUSKHZ
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|z
operator|=
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
break|break;
block|}
comment|/*	We are now either in a data or status phase, OR we timed-out.*/
if|if
condition|(
name|z
operator|==
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Command time-out\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|z
operator|!=
name|DTEN
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_slowcmd - Issue a command to the drive  	This routine is for commands that might take a long time, such 	as a read or seek.  The caller must determine if the command 	completes instantly or schedule a poll later on. ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|matcd_slowcmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|z
decl_stmt|;
name|int
name|level
decl_stmt|,
name|size
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|unsigned
name|char
modifier|*
name|cx
decl_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
name|draincmd
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Make sure buss is really idle*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|cx
operator|=
name|cp
expr_stmt|;
name|printf
argument_list|(
literal|"matcd%d: Slow Send port %x sel %d command %x %x %x %x %x %x %x\n"
argument_list|,
name|ldrive
argument_list|,
name|port
argument_list|,
name|cdrive
argument_list|,
name|cx
index|[
literal|0
index|]
argument_list|,
name|cx
index|[
literal|1
index|]
argument_list|,
name|cx
index|[
literal|2
index|]
argument_list|,
name|cx
index|[
literal|3
index|]
argument_list|,
name|cx
index|[
literal|4
index|]
argument_list|,
name|cx
index|[
literal|5
index|]
argument_list|,
name|cx
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|selectdrive
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Enable the desired target drive*/
if|if
condition|(
operator|*
name|cp
operator|==
name|ABORT
condition|)
name|size
operator|=
literal|1
expr_stmt|;
else|else
name|size
operator|=
literal|7
expr_stmt|;
name|level
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/*----------------------------------------*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
comment|/*The seven bytes of the command*/
name|outb
argument_list|(
name|port
operator|+
name|CMD
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/*must be sent within 10msec or*/
block|}
comment|/*the drive will ignore the cmd*/
name|splx
argument_list|(
name|level
argument_list|)
expr_stmt|;
comment|/*------------------------------------------------*/
return|return;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	draincmd - Makes certain the buss is idle and throws away 		any residual data from the drive if there is any. 		Called as preface to most commands. 		Added in Edit 5.  		This was added because switching drive modes causes 		the drive to emit buffers that were meant to be sent 		to the D-to-A to be sent to the host.  See setmode. ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|draincmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|ldrive
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|z
decl_stmt|;
name|i
operator|=
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0xff
condition|)
return|return;
name|printf
argument_list|(
literal|"matcd%d: in draincmd: buss not idle %x - trying to fix\n"
argument_list|,
name|ldrive
argument_list|,
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|DTEN
operator||
name|STEN
operator|)
operator|==
name|STEN
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Data present READING - "
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|i
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*Enable data read*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|outb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"%d bytes read\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
block|}
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Now read status: "
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|i
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
name|z
operator|=
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
expr_stmt|;
comment|/*Read buss status*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"Data byte %x and status is now %x\n"
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
if|if
condition|(
name|z
operator|!=
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: Buss not idle %x - resetting\n"
argument_list|,
name|cdrive
argument_list|,
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|doreset
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	selectdrive - Swaps drive select bits  	On Creative SB/SB16/stand-alone adapters, possibly to make them 	to reverse engineer.  On these boards, the drive select signals 	are swapped. ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|selectdrive
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|drive
parameter_list|)
block|{
switch|switch
condition|(
name|drive
condition|)
block|{
case|case
literal|0
case|:
comment|/*0x00 -> 0x00*/
name|outb
argument_list|(
name|port
operator|+
name|SELECT
argument_list|,
name|CRDRIVE0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/*0x01 -> 0x02*/
name|outb
argument_list|(
name|port
operator|+
name|SELECT
argument_list|,
name|CRDRIVE1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/*0x02 -> 0x01*/
name|outb
argument_list|(
name|port
operator|+
name|SELECT
argument_list|,
name|CRDRIVE2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/*0x03 -> 0x03*/
name|outb
argument_list|(
name|port
operator|+
name|SELECT
argument_list|,
name|CRDRIVE3
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_pread - Read small blocks of control data from a drive ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|matcd_pread
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|count
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|data
operator|++
operator|=
name|inb
argument_list|(
name|port
operator|+
name|CMD
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_setmode - Configures disc to run in the desired data mode  	This routine assumes the drive is already idle.  NOTE -	Undocumented action of hardware:  If you change (or reaffirm) data 	modes with MODESELECT + BLOCKPARAM immediately after a command was 	issued that aborted a DA play operation, the drive will unexpectedly 	return 2532 bytes of data in a data phase on the first or second 	subsequent command.  	Original Symptom: drive will refuse to go idle after reading data 	and status expected for a command.  State mechanics for this are 	not fully understood. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_setmode
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|int
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|,
name|cdrive
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
name|matcd_data
operator|+
name|ldrive
expr_stmt|;
name|retries
operator|=
literal|3
expr_stmt|;
name|cdrive
operator|=
name|ldrive
operator|&
literal|0x03
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|drivemode
operator|==
name|mode
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Drive already set*/
block|}
comment|/*	The drive is not in the right mode, so we need to set it. */
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|MODESELECT
expr_stmt|;
comment|/*Set drive transfer modes*/
comment|/*	cmd[1]=BLOCKPARAM;	  BLOCKPARAM==0*/
name|cmd
index|[
literal|2
index|]
operator|=
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_DATA
case|:
name|cmd
index|[
literal|3
index|]
operator|=
literal|0x08
expr_stmt|;
comment|/*2048 bytes*/
break|break;
case|case
name|MODE_USER
case|:
name|cmd
index|[
literal|3
index|]
operator|=
literal|0x09
expr_stmt|;
comment|/*2352 bytes*/
name|cmd
index|[
literal|4
index|]
operator|=
literal|0x30
expr_stmt|;
break|break;
case|case
name|MODE_DA
case|:
name|cmd
index|[
literal|3
index|]
operator|=
literal|0x09
expr_stmt|;
comment|/*2352 bytes*/
name|cmd
index|[
literal|4
index|]
operator|=
literal|0x30
expr_stmt|;
break|break;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|retries
operator|--
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|cd
operator|->
name|drivemode
operator|=
name|mode
expr_stmt|;
comment|/*Set new mode*/
return|return
operator|(
name|i
operator|)
return|;
block|}
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
block|}
name|cd
operator|->
name|drivemode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
comment|/*We failed*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_volinfo - Read information from disc Table of Contents ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_volinfo
parameter_list|(
name|int
name|ldrive
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|port
decl_stmt|,
name|i
decl_stmt|;
name|int
name|z
decl_stmt|,
name|cdrive
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|12
index|]
decl_stmt|;
name|retry
operator|=
literal|5
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|cdrive
operator|=
name|ldrive
operator|&
literal|0x03
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: In volinfo, port %x\n"
argument_list|,
name|ldrive
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
while|while
condition|(
name|retry
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xB0
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READDINFO
expr_stmt|;
comment|/*Read Disc Info*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"volinfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/*THIS SHOULD NOT HAPPEN*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
name|printf
argument_list|(
literal|"matcd%d: command failed, status %x\n"
argument_list|,
name|ldrive
argument_list|,
name|z
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|6
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Data got was %x %x %x %x %x %x   "
argument_list|,
name|ldrive
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|,
name|data
index|[
literal|4
index|]
argument_list|,
name|data
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"status byte %x\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/*No Error*/
comment|/*	If media change or other error, you have to read error data or 	the drive will reject subsequent commands. */
if|if
condition|(
name|chk_error
argument_list|(
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
argument_list|)
operator|==
name|ERR_FATAL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: command failed, status %x\n"
argument_list|,
name|ldrive
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|--
name|retry
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Retrying"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
block|}
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Status port %x  \n"
argument_list|,
name|ldrive
argument_list|,
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
name|cd
operator|->
name|volinfo
operator|.
name|type
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|trk_low
operator|=
name|data
index|[
literal|1
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|0
index|]
operator|=
name|data
index|[
literal|3
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|1
index|]
operator|=
name|data
index|[
literal|4
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|2
index|]
operator|=
name|data
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|volinfo
operator|.
name|trk_low
operator|+
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
condition|)
block|{
name|cd
operator|->
name|flags
operator||=
name|MATCDLABEL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	blk_to_msf - Convert block numbers into CD disk block ids	 ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|blk_to_msf
parameter_list|(
name|int
name|blk
parameter_list|,
name|unsigned
name|char
modifier|*
name|msf
parameter_list|)
block|{
name|blk
operator|+=
literal|150
expr_stmt|;
comment|/*2 seconds skip required to 					  reach ISO data*/
name|msf
index|[
literal|0
index|]
operator|=
name|blk
operator|/
literal|4500
expr_stmt|;
name|blk
operator|%=
literal|4500
expr_stmt|;
name|msf
index|[
literal|1
index|]
operator|=
name|blk
operator|/
literal|75
expr_stmt|;
name|msf
index|[
literal|2
index|]
operator|=
name|blk
operator|%
literal|75
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	msf_to_blk - Convert CD disk block ids into block numbers ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|msf_to_blk
parameter_list|(
name|unsigned
name|char
modifier|*
name|cd
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|cd
index|[
literal|0
index|]
operator|*
literal|60
operator|)
comment|/*Convert MSF to*/
operator|+
name|cd
index|[
literal|1
index|]
operator|)
operator|*
literal|75
comment|/*Blocks minus 2*/
operator|+
name|cd
index|[
literal|2
index|]
operator|-
literal|150
operator|)
return|;
comment|/*seconds*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_blockread - Performs actual background disc I/O operations  	This routine is handed the block number to read, issues the 	command to the drive, waits for it to complete, reads the 	data or error, retries if needed, and returns the results 	to the host. ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|matcd_blockread
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|struct
name|matcd_mbx
modifier|*
name|mbx
decl_stmt|;
name|int
name|ldrive
decl_stmt|,
name|cdrive
decl_stmt|;
name|int
name|port
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|z
decl_stmt|;
name|int
name|l
decl_stmt|,
name|m
decl_stmt|;
name|struct
name|matcd_read2
name|rbuf
decl_stmt|;
name|int
name|blknum
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|errtyp
decl_stmt|;
name|int
name|phase
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xC0
operator|+
operator|(
name|diagloop
operator|*
literal|0x100
operator|)
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
name|mbx
operator|=
operator|&
name|matcd_data
index|[
name|state
operator|&
literal|0x0f
index|]
operator|.
name|mbx
expr_stmt|;
name|ldrive
operator|=
name|mbx
operator|->
name|ldrive
expr_stmt|;
comment|/*ldrive is logical drive #*/
name|cdrive
operator|=
name|ldrive
operator|&
literal|0x03
expr_stmt|;
comment|/*cdrive is drive # on a controller*/
name|port
operator|=
name|mbx
operator|->
name|port
expr_stmt|;
comment|/*port is base port for i/f*/
name|bp
operator|=
name|mbx
operator|->
name|bp
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|dp
operator|=
operator|&
name|request_head
index|[
name|mbx
operator|->
name|controller
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Show state %x cdrive %d partition %d\n"
argument_list|,
name|ldrive
argument_list|,
name|state
argument_list|,
name|cdrive
argument_list|,
name|mbx
operator|->
name|partition
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|loop
label|:
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Top  dp %x\n"
argument_list|,
name|ldrive
argument_list|,
name|dp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xCF
operator|+
operator|(
name|diagloop
operator|*
literal|0x100
operator|)
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
switch|switch
condition|(
name|state
operator|&
literal|0xf0
condition|)
block|{
case|case
name|MATCD_READ_1
case|:
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: State 1 cd->flags %x\n"
argument_list|,
name|ldrive
argument_list|,
name|cd
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
ifdef|#
directive|ifdef
name|DIAGPORT
name|diagloop
operator|=
literal|0
expr_stmt|;
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xC1
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
comment|/* to check for raw/cooked mode */
if|if
condition|(
name|cd
operator|->
name|partflags
index|[
name|mbx
operator|->
name|partition
index|]
operator|&
name|MATCDREADRAW
condition|)
block|{
name|mbx
operator|->
name|sz
operator|=
name|MATCDRBLK
expr_stmt|;
name|i
operator|=
name|matcd_setmode
argument_list|(
name|ldrive
argument_list|,
name|MODE_DA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Set MODE_DA result %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
block|}
else|else
block|{
name|mbx
operator|->
name|sz
operator|=
name|cd
operator|->
name|blksize
expr_stmt|;
name|i
operator|=
name|matcd_setmode
argument_list|(
name|ldrive
argument_list|,
name|MODE_DATA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Set MODE_DATA result %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
block|}
comment|/*for first block*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: A mbx %x bp %x b_bcount %x sz %x\n"
argument_list|,
name|ldrive
argument_list|,
name|mbx
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|mbx
operator|->
name|sz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|mbx
operator|->
name|nblk
operator|=
operator|(
name|bp
operator|->
name|b_bcount
operator|+
operator|(
name|mbx
operator|->
name|sz
operator|-
literal|1
operator|)
operator|)
operator|/
name|mbx
operator|->
name|sz
expr_stmt|;
name|mbx
operator|->
name|skip
operator|=
literal|0
expr_stmt|;
name|nextblock
label|:
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: at Nextblock b_blkno %d\n"
argument_list|,
name|ldrive
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|blknum
operator|=
operator|(
name|bp
operator|->
name|b_blkno
operator|/
operator|(
name|mbx
operator|->
name|sz
operator|/
name|DEV_BSIZE
operator|)
operator|)
operator|+
name|mbx
operator|->
name|p_offset
operator|+
name|mbx
operator|->
name|skip
operator|/
name|mbx
operator|->
name|sz
expr_stmt|;
name|blk_to_msf
argument_list|(
name|blknum
argument_list|,
name|rbuf
operator|.
name|start_msf
argument_list|)
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READ
expr_stmt|;
comment|/*Get drive ID*/
name|cmd
index|[
literal|1
index|]
operator|=
name|rbuf
operator|.
name|start_msf
index|[
literal|0
index|]
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|rbuf
operator|.
name|start_msf
index|[
literal|1
index|]
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
name|rbuf
operator|.
name|start_msf
index|[
literal|2
index|]
expr_stmt|;
name|cmd
index|[
literal|6
index|]
operator|=
literal|1
expr_stmt|;
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/*	Now that we have issued the command, check immediately to 	see if data is ready.   The drive has read-ahead caching, so 	it is possible the data is already in the drive buffer.  	If the data is not ready, schedule a wakeup and later on this 	code will run again to see if the data is ready then. */
case|case
name|MATCD_READ_2
case|:
name|state
operator|=
name|MATCD_READ_2
operator|+
name|ldrive
expr_stmt|;
name|phase
operator|=
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: In state 2 status %x  "
argument_list|,
name|ldrive
argument_list|,
name|phase
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xC2
operator|+
operator|(
name|diagloop
operator|++
operator|*
literal|0x100
operator|)
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
operator|(
name|DTEN
operator||
name|STEN
operator|)
case|:
comment|/*DTEN==H  STEN==H*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Sleeping\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|timeout
argument_list|(
operator|(
name|timeout_func_t
operator|)
name|matcd_blockread
argument_list|,
operator|(
name|caddr_t
operator|)
name|MATCD_READ_2
operator|+
name|ldrive
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
return|return;
case|case
name|STEN
case|:
comment|/*DTEN=L STEN=H*/
case|case
literal|0
case|:
comment|/*DTEN=L STEN=L*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Data Phase\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|outb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*Enable data read*/
name|addr
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
operator|+
name|mbx
operator|->
name|skip
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Xfer Addr %x  size %x"
argument_list|,
name|ldrive
argument_list|,
name|addr
argument_list|,
name|mbx
operator|->
name|sz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|==
literal|0xfd
condition|)
block|{
operator|*
name|addr
operator|++
operator|=
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Read %d bytes\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|outb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*Disable data read*/
comment|/*	Now, wait for the Status phase to arrive.   This will also 	tell us if any went wrong with the request. */
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|!=
name|DTEN
condition|)
empty_stmt|;
name|status
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Status port %x byte %x  "
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
if|if
condition|(
name|status
operator|&
name|MATCD_ST_ERROR
condition|)
block|{
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"matcd%d: %s while reading block %d [Soft]\n"
argument_list|,
name|ldrive
argument_list|,
name|matcderrors
index|[
name|i
index|]
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
block|}
name|media_chk
argument_list|(
name|cd
argument_list|,
name|i
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|mbx
operator|->
name|nblk
operator|>
literal|0
condition|)
block|{
name|mbx
operator|->
name|skip
operator|+=
name|mbx
operator|->
name|sz
expr_stmt|;
goto|goto
name|nextblock
goto|;
comment|/*Oooooh, you flunk the course*/
block|}
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|unlockbuss
argument_list|(
name|ldrive
operator|>>
literal|2
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release buss lock*/
name|matcd_start
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
comment|/*	Here we skipped the data phase and went directly to status. 	This indicates a hard error. */
case|case
name|DTEN
case|:
comment|/*DTEN=H STEN=L*/
name|status
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: error, status was %x\n"
argument_list|,
name|ldrive
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
comment|/*	Ok, we need more details, so read error.  This is needed to issue 	any further commands anyway */
name|errtyp
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"matcd%d: %s while reading block %d\n"
argument_list|,
name|ldrive
argument_list|,
name|matcderrors
index|[
name|errtyp
index|]
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|media_chk
argument_list|(
name|cd
argument_list|,
name|errtyp
argument_list|,
name|ldrive
argument_list|)
condition|)
goto|goto
name|giveup
goto|;
name|errtyp
operator|=
name|chk_error
argument_list|(
name|errtyp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errtyp
condition|)
block|{
case|case
name|ERR_RETRY
case|:
comment|/*We can retry this error, but the 					  drive probably has already*/
if|if
condition|(
name|mbx
operator|->
name|retry
operator|--
operator|>
literal|0
condition|)
block|{
name|state
operator|=
name|MATCD_READ_1
operator|+
name|ldrive
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Attempting retry\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
goto|goto
name|loop
goto|;
block|}
goto|goto
name|giveup
goto|;
comment|/*	These errors usually indicate the user took the media from the 	drive while the dev was open.  We will invalidate the unit 	until it closes when we see this. */
case|case
name|ERR_INIT
case|:
comment|/*Media probably was removed 					   while the dev was open. 					   Invalidate the unit until 					   it is closed.*/
case|case
name|ERR_FATAL
case|:
comment|/*This type of error is so 					    bad we will never recover 					    even if we retry.*/
default|default:
name|giveup
label|:
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xCE
operator|+
operator|(
name|diagloop
operator|*
literal|0x100
operator|)
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|unlockbuss
argument_list|(
name|ldrive
operator|>>
literal|2
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|matcd_start
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_eject - Open drive tray ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_eject
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
block|{
name|int
name|retries
decl_stmt|,
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*Get I/O port base*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/*Initialize command buffer*/
ifdef|#
directive|ifdef
name|LOCKDRIVE
name|cmd
index|[
literal|0
index|]
operator|=
name|LOCK
expr_stmt|;
comment|/*Unlock drive*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
endif|#
directive|endif
comment|/*LOCKDRIVE*/
name|cmd
index|[
literal|0
index|]
operator|=
name|DOOROPEN
expr_stmt|;
comment|/*Open Door*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
name|cd
operator|->
name|flags
operator|&=
operator|~
name|MATCDLABEL
expr_stmt|;
comment|/*Mark volume info invalid*/
return|return
operator|(
name|i
operator|)
return|;
comment|/*Return result we got*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	docmd - Get the buss, do the command, wait for completion, 		attempt retries, give up the buss. 		For commands that do not return data. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|docmd
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|int
name|retries
decl_stmt|,
name|i
decl_stmt|,
name|z
decl_stmt|;
name|lockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Request buss*/
name|retries
operator|=
literal|3
expr_stmt|;
while|while
condition|(
name|retries
operator|--
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xD0
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|80
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"cmd"
argument_list|)
expr_stmt|;
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
operator|==
literal|0
condition|)
break|break;
name|i
operator|=
name|chk_error
argument_list|(
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ERR_INIT
condition|)
block|{
name|unlockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release buss*/
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
name|unlockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release buss*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	get_error - Read the error that aborted a command. 	Created in Edit 6 ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|get_error
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|errnum
decl_stmt|;
name|unsigned
name|char
name|cmd1
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|12
index|]
decl_stmt|;
name|zero_cmd
argument_list|(
name|cmd1
argument_list|)
expr_stmt|;
name|cmd1
index|[
literal|0
index|]
operator|=
name|READERROR
expr_stmt|;
comment|/*Enquire*/
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd1
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|8
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|errnum
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
comment|/*Caller wants it classified*/
name|status
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Chkerror found %x on command %x addrval %x statusdata %x statusport %x\n"
argument_list|,
name|ldrive
argument_list|,
name|errnum
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|status
argument_list|,
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
return|return
operator|(
name|errnum
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	chk_error - Classify the error that the drive reported 	Created in Edit 6 ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|chk_error
parameter_list|(
name|int
name|errnum
parameter_list|)
block|{
switch|switch
condition|(
name|errnum
condition|)
block|{
comment|/*	These are errors we can attempt a retry for, although the drive 	has already done so. */
case|case
name|UNRECV_ERROR
case|:
case|case
name|SEEK_ERROR
case|:
case|case
name|TRACK_ERROR
case|:
case|case
name|FOCUS_ERROR
case|:
case|case
name|CLV_ERROR
case|:
case|case
name|DATA_ERROR
case|:
return|return
operator|(
name|ERR_RETRY
operator|)
return|;
comment|/*	These errors usually indicate the user took the media from the 	drive while the dev was open.  We will invalidate the unit 	until it closes when we see this. */
case|case
name|NOT_READY
case|:
case|case
name|MEDIA_CHANGED
case|:
case|case
name|DISC_OUT
case|:
case|case
name|HARD_RESET
case|:
return|return
operator|(
name|ERR_INIT
operator|)
return|;
comment|/*	These errors indicate the system is confused about the drive 	or media, and point to bugs in the driver or OS.  These errors 	cannot be retried since you will always get the same error. */
case|case
name|RAM_ERROR
case|:
case|case
name|DIAG_ERROR
case|:
case|case
name|CDB_ERROR
case|:
case|case
name|END_ADDRESS
case|:
case|case
name|MODE_ERROR
case|:
case|case
name|ILLEGAL_REQ
case|:
case|case
name|ADDRESS_ERROR
case|:
default|default:
return|return
operator|(
name|ERR_FATAL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	get_stat - Reads status byte  	This routine should be totally unnecessary, performing the 	task with a single line of in-line code.  However in special 	cases, the drives return blocks of data that are not associated 	with the command in question.  This appears to be a firmware 	error and the rest of the driver makes an effort to avoid 	triggering the fault.  However, reading and throwing this 	bogus data is faster and less destructive than resetting all 	the drives on a given controller, plus it leaves the other drives 	unaffected. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|get_stat
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
comment|/*Read the status byte, last step of cmd*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|)
operator|!=
literal|0xff
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: get_stat: After reading status byte, buss didn't go idle\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|DTEN
operator||
name|STEN
operator|)
operator|==
name|STEN
condition|)
block|{
name|int
name|k
decl_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: DATA PRESENT!!!! DISCARDING\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|outb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*Enable data read*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
comment|/*				printf("%2x ",inb(port+DATA));*/
name|k
operator|++
expr_stmt|;
block|}
name|outb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"\nmatcd%d: BYTES READ IN DATA was %d\n"
argument_list|,
name|ldrive
argument_list|,
name|k
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
block|}
name|status
operator|=
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
comment|/*Read the status byte again*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Next status byte is %x\n"
argument_list|,
name|ldrive
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	waitforit - Waits for a command started by slowcmd to complete. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|waitforit
parameter_list|(
name|int
name|timelimit
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|port
parameter_list|,
name|char
modifier|*
name|where
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
name|i
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xE0
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
name|diagloop
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/*DIAGPORT*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd: waitforit port %x timelimit %x hz %x\n"
argument_list|,
name|port
argument_list|,
name|timelimit
argument_list|,
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
while|while
condition|(
name|i
operator|<
name|timelimit
condition|)
block|{
name|j
operator|=
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|STEN
operator||
name|DTEN
operator|)
expr_stmt|;
comment|/*Read status*/
if|if
condition|(
name|j
operator|!=
operator|(
name|STEN
operator||
name|DTEN
operator|)
condition|)
break|break;
name|timeout
argument_list|(
operator|(
name|timeout_func_t
operator|)
name|watchdog
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|port_hints
argument_list|,
name|PRIBIO
argument_list|,
name|where
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xE1
operator|+
operator|(
name|diagloop
operator|++
operator|*
literal|0x100
operator|)
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
block|}
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd: Count was %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
if|if
condition|(
name|j
operator|==
name|state
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Command complete*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd: Timeout!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
return|return
operator|(
literal|1
operator|)
return|;
comment|/*Timeout occurred*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	watchdog - Gives us a heartbeat for things we are waiting on ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|watchdog
parameter_list|(
name|int
name|state
parameter_list|,
name|char
modifier|*
name|foo
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xF0
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|port_hints
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	lockbuss - Wait for the buss on the requested driver interface 		to go idle and acquire it. 	Created in Edit 6 ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|lockbuss
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|ldrive
parameter_list|)
block|{
while|while
condition|(
operator|(
name|if_state
index|[
name|controller
index|]
operator|&
name|BUSSBUSY
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGSLEEP
name|printf
argument_list|(
literal|"matcd%d: Can't do it now - going to sleep\n, 		       ldrive"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGSLEEP*/
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xF1
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|matcd_data
operator|->
name|status
argument_list|,
name|PRIBIO
argument_list|,
literal|"matcdopen"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|if_state
index|[
name|controller
index|]
operator||=
name|BUSSBUSY
expr_stmt|;
comment|/*It's ours NOW*/
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xF2
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
ifdef|#
directive|ifdef
name|DEBUGSLEEP
name|printf
argument_list|(
literal|"matcd%d: BUSS locked in lockbuss\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGSLEEP*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	lockbuss - Wait for the buss on the requested driver interface 		to go idle and acquire it. 	Created in Edit 6 ----------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|unlockbuss
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|ldrive
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DIAGPORT
name|DIAGOUT
argument_list|(
name|DIAGPORT
argument_list|,
literal|0xF4
argument_list|)
expr_stmt|;
comment|/*Show where we are*/
endif|#
directive|endif
comment|/*DIAGPORT*/
name|if_state
index|[
name|controller
index|]
operator|&=
operator|~
name|BUSSBUSY
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGSLEEP
name|printf
argument_list|(
literal|"matcd%d: bussunlocked\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGSLEEP*/
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|matcd_data
operator|->
name|status
argument_list|)
expr_stmt|;
comment|/*Wakeup other users*/
name|matcd_start
argument_list|(
operator|&
name|request_head
index|[
name|controller
index|]
argument_list|)
expr_stmt|;
comment|/*Wake up any block I/O*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	media_chk - 	Checks error for types related to media 			changes. ----------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|media_chk
parameter_list|(
name|struct
name|matcd_data
modifier|*
name|cd
parameter_list|,
name|int
name|errnum
parameter_list|,
name|int
name|ldrive
parameter_list|)
block|{
if|if
condition|(
name|errnum
operator|==
name|NOT_READY
operator|||
name|errnum
operator|==
name|MEDIA_CHANGED
operator|||
name|errnum
operator|==
name|HARD_RESET
operator|||
name|errnum
operator|==
name|DISC_OUT
condition|)
block|{
name|cd
operator|->
name|flags
operator|&=
operator|~
name|MATCDLABEL
expr_stmt|;
comment|/*Mark label as invalid*/
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDWARN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*Have we said this*/
name|printf
argument_list|(
literal|"matcd%d: Media changed - Further I/O aborted until device closed\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|cd
operator|->
name|flags
operator||=
name|MATCDWARN
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	The following functions are related to the audio playback 	capabilities of the drive.   They can be omitted from the 	finished driver using the FULLDRIVER conditional.  	The full set of features the drive is capable of are currently 	not implemented but will be added in an upcoming release. ----------------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FULLDRIVER
end_ifdef

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_playtracks - Plays one or more audio tracks ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_playtracks
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_track
modifier|*
name|pt
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|start
operator|=
name|pt
operator|->
name|start_track
expr_stmt|;
name|end
operator|=
name|pt
operator|->
name|end_track
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|1
operator|||
comment|/*Starting track valid?*/
name|end
operator|<
literal|1
operator|||
comment|/*Ending track valid?*/
name|start
operator|>
name|end
operator|||
comment|/*Start higher than end?*/
name|end
operator|>
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
condition|)
comment|/*End track higher than disc size?*/
return|return
operator|(
name|ESPIPE
operator|)
return|;
comment|/*Track out of range*/
name|lockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Request buss*/
name|i
operator|=
name|matcd_setmode
argument_list|(
name|ldrive
argument_list|,
name|MODE_DA
argument_list|)
expr_stmt|;
comment|/*Force drive into audio mode*/
name|unlockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release buss*/
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|i
operator|)
return|;
comment|/*Not legal for this media?*/
block|}
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|PLAYTRKS
expr_stmt|;
comment|/*Play Audio Track/Index*/
name|cmd
index|[
literal|1
index|]
operator|=
name|start
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|pt
operator|->
name|start_index
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
name|end
expr_stmt|;
name|cmd
index|[
literal|4
index|]
operator|=
name|pt
operator|->
name|end_index
expr_stmt|;
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Play track results %d \n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_playmsf - Plays between a range of blocks ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_playmsf
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_msf
modifier|*
name|pt
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: playmsf %2x %2x %2x -> %2x %2x %2x\n"
argument_list|,
name|ldrive
argument_list|,
name|pt
operator|->
name|start_m
argument_list|,
name|pt
operator|->
name|start_s
argument_list|,
name|pt
operator|->
name|start_f
argument_list|,
name|pt
operator|->
name|end_m
argument_list|,
name|pt
operator|->
name|end_s
argument_list|,
name|pt
operator|->
name|end_f
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
if|if
condition|(
operator|(
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|1
index|]
operator|<
literal|2
operator|)
operator|||
comment|/*Must be after 0'1"75F*/
name|msf_to_blk
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pt
operator|->
name|start_m
argument_list|)
operator|>
name|msf_to_blk
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Invalid block combination\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|ESPIPE
operator|)
return|;
comment|/*Track out of range*/
block|}
name|lockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Request buss*/
name|i
operator|=
name|matcd_setmode
argument_list|(
name|ldrive
argument_list|,
name|MODE_DA
argument_list|)
expr_stmt|;
comment|/*Force drive into audio mode*/
name|unlockbuss
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release buss*/
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|i
operator|)
return|;
comment|/*Not legal for this media?*/
block|}
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|PLAYBLOCKS
expr_stmt|;
comment|/*Play Audio Blocks*/
name|cmd
index|[
literal|1
index|]
operator|=
name|pt
operator|->
name|start_m
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|pt
operator|->
name|start_s
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
name|pt
operator|->
name|start_f
expr_stmt|;
name|cmd
index|[
literal|4
index|]
operator|=
name|pt
operator|->
name|end_m
expr_stmt|;
name|cmd
index|[
literal|5
index|]
operator|=
name|pt
operator|->
name|end_s
expr_stmt|;
name|cmd
index|[
literal|6
index|]
operator|=
name|pt
operator|->
name|end_f
expr_stmt|;
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_pause - Pause or Resume audio playback ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_pause
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_msf
modifier|*
name|addr
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|PAUSE
expr_stmt|;
comment|/*Pause or Resume playing audio*/
name|cmd
index|[
literal|1
index|]
operator|=
name|action
expr_stmt|;
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Pause / Resume results %d \n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------- 	matcd_stop  - Stop audio playback ----------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_stop
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_msf
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|ABORT
expr_stmt|;
comment|/*Abort playing audio*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Abort results %d \n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*FULLDRIVER*/
end_comment

begin_comment
comment|/*End of matcd.c*/
end_comment

end_unit

