begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * TODO:  * [1] integrate into current if_ed.c  * [2] parse tuples to find out where to map the shared memory buffer,  *     and what to write into the configuration register  * [3] move pcic-specific code into a separate module.  *  * Device driver for IBM PCMCIA Credit Card Adapter for Ethernet,  * if_ze.c  *  * Based on the Device driver for National Semiconductor DS8390 ethernet  * adapters by David Greenman.  Modifications for PCMCIA by Keith Moore.  * Adapted for FreeBSD 1.1.5 by Jordan Hubbard.  *  * Currently supports only the IBM Credit Card Adapter for Ethernet, but  * could probably work with other PCMCIA cards also, if it were modified  * to get the locations of the PCMCIA configuration option register (COR)  * by parsing the configuration tuples, rather than by hard-coding in  * the value expected by IBM's card.  *  * Sources for data on the PCMCIA/IBM CCAE specific portions of the driver:  *  * [1] _Local Area Network Credit Card Adapters Technical Reference_,  *     IBM Corp., SC30-3585-00, part # 33G9243.  * [2] "pre-alpha" PCMCIA support code for Linux by Barry Jaspan.  * [3] Intel 82536SL PC Card Interface Controller Data Sheet, Intel  *     Order Number 290423-002  * [4] National Semiconductor DP83902A ST-NIC (tm) Serial Network  *     Interface Controller for Twisted Pair data sheet.  *  *  * Copyright (C) 1993, David Greenman. This software may be used, modified,  *   copied, distributed, and sold, in both source and binary form provided  *   that the above copyright and these terms are retained. Under no  *   circumstances is the author responsible for the proper functioning  *   of this software, nor does the author assume any responsibility  *   for damages incurred with its use.  */
end_comment

begin_comment
comment|/*  * I doubled delay loops in this file because it is not enough for some  * laptop machines' PCIC (especially, on my Chaplet ILFA 350 ^^;).  *                        HOSOKAWA, Tatsumi<hosokawa@mt.cs.keio.ac.jp>  */
end_comment

begin_comment
comment|/*  * Very small patch for IBM Ethernet PCMCIA Card II and IBM ThinkPad230Cs.  *			ETO, Toshihisa<eto@osl.fujitsu.co.jp>  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  */
end_comment

begin_comment
comment|/* XXX don't mix different PCCARD support code. */
end_comment

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_include
include|#
directive|include
file|"pcic.h"
end_include

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
operator|||
name|NPCIC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"opt_lint.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COMPILING_LINT
end_ifdef

begin_decl_stmt
specifier|static
name|char
specifier|const
name|zedummy
index|[]
init|=
literal|"code to use the includes of card.h and pcic.h"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Dedicated PCMCIA drivers and generic PCMCIA support can't be mixed"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ze.h"
end_include

begin_if
if|#
directive|if
name|NZE
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipx.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SMP
end_ifndef

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/ed/if_edreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/pcic.h>
end_include

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/*****************************************************************************  *                       Driver for Ethernet Adapter                         *  *****************************************************************************/
end_comment

begin_comment
comment|/*  * ze_softc: per line info and status  */
end_comment

begin_struct
specifier|static
struct|struct
name|ze_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* ethernet common */
name|caddr_t
name|maddr
decl_stmt|;
name|u_long
name|iobase
decl_stmt|,
name|irq
decl_stmt|;
name|char
modifier|*
name|type_str
decl_stmt|;
comment|/* pointer to type string */
name|char
modifier|*
name|mau
decl_stmt|;
comment|/* type of media access unit */
name|u_short
name|nic_addr
decl_stmt|;
comment|/* NIC (DS8390) I/O bus address */
name|caddr_t
name|smem_start
decl_stmt|;
comment|/* shared memory start address */
name|caddr_t
name|smem_end
decl_stmt|;
comment|/* shared memory end address */
name|u_long
name|smem_size
decl_stmt|;
comment|/* total shared memory size */
name|caddr_t
name|smem_ring
decl_stmt|;
comment|/* start of RX ring-buffer (in smem) */
name|u_char
name|memwidth
decl_stmt|;
comment|/* width of access to card mem 8 or 16 */
name|u_char
name|xmit_busy
decl_stmt|;
comment|/* transmitter is busy */
name|u_char
name|txb_cnt
decl_stmt|;
comment|/* Number of transmit buffers */
name|u_char
name|txb_next
decl_stmt|;
comment|/* Pointer to next buffer ready to xmit */
name|u_short
name|txb_next_len
decl_stmt|;
comment|/* next xmit buffer length */
name|u_char
name|data_buffered
decl_stmt|;
comment|/* data has been buffered in interface memory */
name|u_char
name|tx_page_start
decl_stmt|;
comment|/* first page of TX buffer area */
name|u_char
name|rec_page_start
decl_stmt|;
comment|/* first page of RX ring-buffer */
name|u_char
name|rec_page_stop
decl_stmt|;
comment|/* last page of RX ring-buffer */
name|u_char
name|next_packet
decl_stmt|;
comment|/* pointer to next unread RX packet */
name|int
name|slot
decl_stmt|;
comment|/* information for reconfiguration */
name|u_char
name|last_alive
decl_stmt|;
comment|/* information for reconfiguration */
name|u_char
name|last_up
decl_stmt|;
comment|/* information for reconfiguration */
if|#
directive|if
name|NAPM
operator|>
literal|0
name|struct
name|apmhook
name|s_hook
decl_stmt|;
comment|/* reconfiguration support */
name|struct
name|apmhook
name|r_hook
decl_stmt|;
comment|/* reconfiguration support */
endif|#
directive|endif
comment|/* NAPM> 0 */
block|}
name|ze_softc
index|[
name|NZE
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|ze_check_cis
name|__P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
name|scratch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ze_find_adapter
name|__P
argument_list|(
operator|(
name|unsigned
name|char
operator|*
name|scratch
operator|,
name|int
name|reconfig
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ze_probe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|isa_dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ze_setup
name|__P
argument_list|(
operator|(
expr|struct
name|ze_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ze_suspend
name|__P
argument_list|(
operator|(
name|void
operator|*
name|visa_dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ze_resume
name|__P
argument_list|(
operator|(
name|void
operator|*
name|visa_dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ze_attach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|isa_dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ze_reset
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ze_stop
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ze_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ze_init
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|ze_xmit
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ze_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|void
name|ze_rint
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ointhand2_t
name|zeintr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ze_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|u_long
name|command
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ze_get_packet
name|__P
argument_list|(
operator|(
expr|struct
name|ze_softc
operator|*
name|sc
operator|,
name|char
operator|*
name|buf
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|char
modifier|*
name|ze_ring_copy
name|__P
argument_list|(
operator|(
expr|struct
name|ze_softc
operator|*
name|sc
operator|,
name|char
operator|*
name|src
operator|,
name|char
operator|*
name|dst
operator|,
name|int
name|amount
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|ze_ring_to_mbuf
name|__P
argument_list|(
operator|(
expr|struct
name|ze_softc
operator|*
name|sc
operator|,
name|char
operator|*
name|src
operator|,
expr|struct
name|mbuf
operator|*
name|dst
operator|,
name|int
name|total_len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|zedriver
init|=
block|{
name|ze_probe
block|,
name|ze_attach
block|,
literal|"ze"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|enet_addr
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|card_info
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CARD_INFO
value|"IBM Corp.~Ethernet~0933495"
end_define

begin_comment
comment|/*  * IBM Ethernet PCMCIA Card II returns following info.  */
end_comment

begin_define
define|#
directive|define
name|CARD2_INFO
value|"IBM Corp.~Ethernet~0934214"
end_define

begin_comment
comment|/* */
end_comment

begin_define
define|#
directive|define
name|CARD3_INFO
value|"National Semiconductor~InfoMover NE4"
end_define

begin_comment
comment|/*  * scan the card information structure looking for the version/product info  * tuple.  when we find it, compare it to the string we are looking for.  * return 1 if we find it, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ze_check_cis
parameter_list|(
name|unsigned
name|char
modifier|*
name|scratch
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|card_info
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|scratch
index|[
name|i
index|]
operator|!=
literal|0xff
operator|&&
name|i
operator|<
literal|1024
condition|)
block|{
name|unsigned
name|char
name|link
init|=
name|scratch
index|[
name|i
operator|+
literal|2
index|]
decl_stmt|;
if|#
directive|if
literal|0
block|printf ("[%02x] %02x ", i, link); 	for (j = 4; j< 2 * link + 4&& j< 32; j += 2) 	    printf ("%02x ", scratch[j + i]); 	printf ("\n");
endif|#
directive|endif
if|if
condition|(
name|scratch
index|[
name|i
index|]
operator|==
literal|0x15
condition|)
block|{
comment|/* 	     * level 1 version/product info 	     * copy to card_info, translating '\0' to '~' 	     */
name|k
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|8
init|;
name|scratch
index|[
name|j
index|]
operator|!=
literal|0xff
condition|;
name|j
operator|+=
literal|2
control|)
name|card_info
index|[
name|k
operator|++
index|]
operator|=
name|scratch
index|[
name|j
index|]
operator|==
literal|'\0'
condition|?
literal|'~'
else|:
name|scratch
index|[
name|j
index|]
expr_stmt|;
name|card_info
index|[
name|k
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
if|#
directive|if
literal|0
block|return (bcmp (card_info, CARD_INFO, sizeof(CARD_INFO)-1) == 0);
else|#
directive|else
if|if
condition|(
operator|(
name|bcmp
argument_list|(
name|card_info
argument_list|,
name|CARD_INFO
argument_list|,
sizeof|sizeof
argument_list|(
name|CARD_INFO
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|bcmp
argument_list|(
name|card_info
argument_list|,
name|CARD2_INFO
argument_list|,
sizeof|sizeof
argument_list|(
name|CARD2_INFO
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|bcmp
argument_list|(
name|card_info
argument_list|,
name|CARD3_INFO
argument_list|,
sizeof|sizeof
argument_list|(
name|CARD3_INFO
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
endif|#
directive|endif
block|}
name|i
operator|+=
literal|4
operator|+
literal|2
operator|*
name|link
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Probe each slot looking for an IBM Credit Card Adapter for Ethernet  * For each card that we find, map its card information structure  * into system memory at 'scratch' and see whether it's one of ours.  * Return the slot number if we find a card, or -1 otherwise.  *  * Side effects:  * + On success, leaves CIS mapped into memory at 'scratch';  *   caller must free it.  * + On success, leaves ethernet address in enet_addr.  * + Leaves product/vendor id of last card probed in 'card_info'  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|prev_slot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ze_find_adapter
parameter_list|(
name|unsigned
name|char
modifier|*
name|scratch
parameter_list|,
name|int
name|reconfig
parameter_list|)
block|{
name|int
name|slot
decl_stmt|;
for|for
control|(
name|slot
operator|=
name|prev_slot
init|;
name|slot
operator|<
name|MAXSLOT
condition|;
operator|++
name|slot
control|)
block|{
comment|/* 	 * see if there's a PCMCIA controller here 	 * Intel PCMCIA controllers use 0x82 and 0x83 	 * IBM clone chips use 0x88 and 0x89, apparently 	 */
comment|/* 	 * IBM ThinkPad230Cs use 0x84. 	 */
name|unsigned
name|char
name|idbyte
init|=
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_ID_REV
argument_list|)
decl_stmt|;
if|if
condition|(
name|idbyte
operator|!=
literal|0x82
operator|&&
name|idbyte
operator|!=
literal|0x83
operator|&&
name|idbyte
operator|!=
literal|0x84
operator|&&
comment|/* for IBM ThinkPad 230Cs */
name|idbyte
operator|!=
literal|0x88
operator|&&
name|idbyte
operator|!=
literal|0x89
condition|)
block|{
if|#
directive|if
literal|0
block|printf ("ibmccae: pcic slot %d: wierd id/rev code 0x%02x\n", 		    slot, idbyte);
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
operator|(
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_STATUS
argument_list|)
operator|&
name|PCIC_CD
operator|)
operator|!=
name|PCIC_CD
condition|)
block|{
if|if
condition|(
operator|!
name|reconfig
condition|)
block|{
name|printf
argument_list|(
literal|"ze: slot %d: no card in slot\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ze: slot %d: no card in slot\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
comment|/* no card in slot */
continue|continue;
block|}
name|pcic_power_on
argument_list|(
name|slot
argument_list|)
expr_stmt|;
name|pcic_reset
argument_list|(
name|slot
argument_list|)
expr_stmt|;
comment|/* 	 * map the card's attribute memory and examine its 	 * card information structure tuples for something 	 * we recognize. 	 */
name|pcic_map_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|kvtop
argument_list|(
name|scratch
argument_list|)
argument_list|,
literal|0L
argument_list|,
literal|0xFFFL
argument_list|,
name|ATTRIBUTE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ze_check_cis
argument_list|(
name|scratch
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* found it */
if|if
condition|(
operator|!
name|reconfig
condition|)
block|{
name|printf
argument_list|(
literal|"ze: found card in slot %d\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ze: found card in slot %d\n"
argument_list|,
name|slot
argument_list|)
expr_stmt|;
block|}
name|prev_slot
operator|=
operator|(
name|prev_slot
operator|==
name|MAXSLOT
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|prev_slot
operator|+
literal|1
expr_stmt|;
return|return
name|slot
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|reconfig
condition|)
block|{
name|printf
argument_list|(
literal|"ze: pcmcia slot %d: %s\n"
argument_list|,
name|slot
argument_list|,
name|card_info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ze: pcmcia slot %d: %s\n"
argument_list|,
name|slot
argument_list|,
name|card_info
argument_list|)
expr_stmt|;
block|}
block|}
name|pcic_unmap_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|prev_slot
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * macros to handle casting unsigned long to (char *) so we can  * read/write into physical memory space.  */
end_comment

begin_define
define|#
directive|define
name|PEEK
parameter_list|(
name|addr
parameter_list|)
value|(*((unsigned char *)(addr)))
end_define

begin_define
define|#
directive|define
name|POKE
parameter_list|(
name|addr
parameter_list|,
name|val
parameter_list|)
value|do { PEEK(addr) = (val); } while (0)
end_define

begin_comment
comment|/*  * Determine if the device is present  *  *   on entry:  * 	a pointer to an isa_device struct  *   on exit:  *	NULL if device not found  *	or # of i/o addresses used (if found) 	pcic(  */
end_comment

begin_function
specifier|static
name|int
name|ze_probe
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
name|struct
name|ze_softc
modifier|*
name|sc
init|=
operator|&
name|ze_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int
name|memsize
decl_stmt|;
name|u_char
name|tmp
decl_stmt|;
name|int
name|slot
decl_stmt|;
if|if
condition|(
operator|(
name|slot
operator|=
name|ze_find_adapter
argument_list|(
name|isa_dev
operator|->
name|id_maddr
argument_list|,
name|isa_dev
operator|->
name|id_reconfig
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* 	 * okay, we found a card, so set it up 	 */
comment|/* 	 * Inhibit 16 bit memory delay. 	 * POINTETH.SYS apparently does this, for what reason I don't know. 	 */
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_CDGC
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_CDGC
argument_list|)
operator||
name|PCIC_16_DL_INH
argument_list|)
expr_stmt|;
comment|/* 	 * things to map 	 * (1) card's EEPROM is already mapped by the find_adapter routine 	 *     but we still need to get the card's ethernet address. 	 *     after that we unmap that part of attribute memory. 	 * (2) card configuration registers need to be mapped in so we 	 *     can set the configuration and socket # registers. 	 * (3) shared memory packet buffer 	 * (4) i/o ports 	 * (5) IRQ 	 */
comment|/* 	 * Sigh.  Location of the ethernet address isn't documented in [1]. 	 * It was derived by doing a hex dump of all of attribute memory 	 * and looking for the IBM vendor prefix. 	 */
name|enet_addr
index|[
literal|0
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff0
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|1
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff2
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|2
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff4
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|3
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff6
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|4
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xff8
argument_list|)
expr_stmt|;
name|enet_addr
index|[
literal|5
index|]
operator|=
name|PEEK
argument_list|(
name|isa_dev
operator|->
name|id_maddr
operator|+
literal|0xffa
argument_list|)
expr_stmt|;
name|pcic_unmap_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|maddr
operator|=
name|isa_dev
operator|->
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|irq
operator|=
name|isa_dev
operator|->
name|id_irq
expr_stmt|;
name|sc
operator|->
name|iobase
operator|=
name|isa_dev
operator|->
name|id_iobase
expr_stmt|;
name|sc
operator|->
name|slot
operator|=
name|slot
expr_stmt|;
comment|/* 	 * Setup i/o addresses 	 */
name|sc
operator|->
name|nic_addr
operator|=
name|sc
operator|->
name|iobase
expr_stmt|;
name|sc
operator|->
name|smem_start
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|maddr
expr_stmt|;
name|ze_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|ZE_RESET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|mau
operator|=
name|tmp
operator|&
literal|0x09
condition|?
literal|"10base2"
else|:
literal|"10baseT"
expr_stmt|;
comment|/* set width/size */
name|sc
operator|->
name|type_str
operator|=
literal|"IBM PCMCIA"
expr_stmt|;
name|memsize
operator|=
literal|16
operator|*
literal|1024
expr_stmt|;
name|sc
operator|->
name|memwidth
operator|=
literal|16
expr_stmt|;
comment|/* allocate 1 xmit buffer */
name|sc
operator|->
name|smem_ring
operator|=
name|sc
operator|->
name|smem_start
operator|+
operator|(
name|ED_PAGE_SIZE
operator|*
name|ED_TXBUF_SIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|txb_cnt
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|rec_page_start
operator|=
name|ED_TXBUF_SIZE
operator|+
name|ZE_PAGE_OFFSET
expr_stmt|;
name|sc
operator|->
name|smem_size
operator|=
name|memsize
expr_stmt|;
name|sc
operator|->
name|smem_end
operator|=
name|sc
operator|->
name|smem_start
operator|+
name|memsize
expr_stmt|;
name|sc
operator|->
name|rec_page_stop
operator|=
name|memsize
operator|/
name|ED_PAGE_SIZE
operator|+
name|ZE_PAGE_OFFSET
expr_stmt|;
name|sc
operator|->
name|tx_page_start
operator|=
name|ZE_PAGE_OFFSET
expr_stmt|;
comment|/* get station address */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
operator|=
name|enet_addr
index|[
name|i
index|]
expr_stmt|;
name|isa_dev
operator|->
name|id_msize
operator|=
name|memsize
expr_stmt|;
comment|/* information for reconfiguration */
name|sc
operator|->
name|last_alive
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|last_up
operator|=
literal|0
expr_stmt|;
return|return
literal|32
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ze_setup
parameter_list|(
name|struct
name|ze_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|re_init_flag
init|=
literal|0
decl_stmt|,
name|tmp
decl_stmt|,
name|slot
init|=
name|sc
operator|->
name|slot
decl_stmt|;
name|re_init
label|:
comment|/* 	 * (2) map card configuration registers.  these are offset 	 * in card memory space by 0x20000.  normally we could get 	 * this offset from the card information structure, but I'm 	 * too lazy and am not quite sure if I understand the CIS anyway. 	 * 	 * XXX IF YOU'RE TRYING TO PORT THIS DRIVER FOR A DIFFERENT 	 * PCMCIA CARD, the most likely thing to change is the constant 	 * 0x20000 in the next statement.  Oh yes, also change the 	 * card id string that we probe for. 	 */
name|pcic_map_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|maddr
argument_list|)
argument_list|,
literal|0x20000
argument_list|,
literal|8L
argument_list|,
name|ATTRIBUTE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|POKE
argument_list|(
name|sc
operator|->
name|maddr
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* reset the card (how long?) */
name|DELAY
argument_list|(
literal|40000
argument_list|)
expr_stmt|;
comment|/* 	 * Set the configuration index.  According to [1], the adapter won't 	 * respond to any i/o signals until we do this; it uses the 	 * Memory Only interface (whatever that is; it's not documented). 	 * Also turn on "level" (not pulse) interrupts. 	 * 	 * XXX probably should init the socket and copy register also, 	 * so that we can deal with multiple instances of the same card. 	 */
name|POKE
argument_list|(
name|sc
operator|->
name|maddr
argument_list|,
literal|0x41
argument_list|)
expr_stmt|;
name|pcic_unmap_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * (3) now map in the shared memory buffer.  This has to be mapped 	 * as words, not bytes, and on a 16k boundary.  The offset value 	 * was derived by installing IBM's POINTETH.SYS under DOS and 	 * looking at the PCIC registers; it's not documented in IBM's 	 * tech ref manual ([1]). 	 */
name|pcic_map_memory
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|maddr
argument_list|)
argument_list|,
literal|0x4000L
argument_list|,
literal|0x4000L
argument_list|,
name|COMMON
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * (4) map i/o ports. 	 * 	 * XXX is it possible that the config file leaves this unspecified, 	 * in which case we have to pick one? 	 * 	 * At least one PCMCIA device driver I'v seen maps a block 	 * of 32 consecutive i/o ports as two windows of 16 ports each. 	 * Maybe some other pcic chips are restricted to 16-port windows; 	 * the 82365SL doesn't seem to have that problem.  But since 	 * we have an extra window anyway... 	 */
ifdef|#
directive|ifdef
name|SHARED_MEMORY
name|pcic_map_io
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|iobase
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|pcic_map_io
argument_list|(
name|slot
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|iobase
argument_list|,
literal|16
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pcic_map_io
argument_list|(
name|slot
argument_list|,
literal|1
argument_list|,
name|sc
operator|->
name|iobase
operator|+
literal|16
argument_list|,
literal|16
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SHARED_MEMORY */
comment|/* 	 * (5) configure the card for the desired interrupt 	 * 	 * XXX is it possible that the config file leaves this unspecified? 	 */
name|pcic_map_irq
argument_list|(
name|slot
argument_list|,
name|ffs
argument_list|(
name|sc
operator|->
name|irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* tell the PCIC that this is an I/O card (not memory) */
name|pcic_putb
argument_list|(
name|slot
argument_list|,
name|PCIC_INT_GEN
argument_list|,
name|pcic_getb
argument_list|(
name|slot
argument_list|,
name|PCIC_INT_GEN
argument_list|)
operator||
name|PCIC_CARDTYPE
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* tell the PCIC to use level-mode interrupts */
comment|/* XXX this register may not be present on all controllers */
block|pcic_putb (slot, PCIC_GLO_CTRL, 		   pcic_getb (slot, PCIC_GLO_CTRL) | PCIC_LVL_MODE);
endif|#
directive|endif
if|#
directive|if
literal|0
block|pcic_print_regs (slot);
endif|#
directive|endif
comment|/* reset card to force it into a known state */
name|tmp
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|ZE_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|ZE_RESET
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|20000
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|tmp = inb(sc->iobase); 	printf("CR = 0x%x\n", tmp);
endif|#
directive|endif
comment|/* 	 * query MAM bit in misc register for 10base2 	 */
name|tmp
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|ZE_MISC
argument_list|)
expr_stmt|;
comment|/* 	 * Some Intel-compatible PCICs of Cirrus Logic fails in 	 * initializing them.  This is a quick hack to fix this 	 * problem. 	 *        HOSOKAWA, Tatsumi<hosokawa@mt.cs.keio.ac.jp> 	 */
if|if
condition|(
operator|!
name|tmp
operator|&&
operator|!
name|re_init_flag
condition|)
block|{
name|re_init_flag
operator|++
expr_stmt|;
goto|goto
name|re_init
goto|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_function
specifier|static
name|int
name|ze_suspend
parameter_list|(
name|visa_dev
parameter_list|)
name|void
modifier|*
name|visa_dev
decl_stmt|;
block|{
name|struct
name|isa_device
modifier|*
name|isa_dev
init|=
name|visa_dev
decl_stmt|;
name|struct
name|ze_softc
modifier|*
name|sc
init|=
operator|&
name|ze_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|pcic_power_off
argument_list|(
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ze_resume
parameter_list|(
name|visa_dev
parameter_list|)
name|void
modifier|*
name|visa_dev
decl_stmt|;
block|{
name|struct
name|isa_device
modifier|*
name|isa_dev
init|=
name|visa_dev
decl_stmt|;
if|#
directive|if
literal|0
block|printf("Resume ze:\n");
endif|#
directive|endif
name|prev_slot
operator|=
literal|0
expr_stmt|;
name|reconfig_isadev
argument_list|(
name|isa_dev
argument_list|,
operator|&
name|net_imask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

begin_comment
comment|/*  * Install interface into kernel networking data structures  */
end_comment

begin_function
specifier|static
name|int
name|ze_attach
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
name|struct
name|ze_softc
modifier|*
name|sc
init|=
operator|&
name|ze_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|pl
decl_stmt|;
name|isa_dev
operator|->
name|id_ointr
operator|=
name|zeintr
expr_stmt|;
comment|/* PCMCIA card can be offlined. Reconfiguration is required */
if|if
condition|(
name|isa_dev
operator|->
name|id_reconfig
condition|)
block|{
name|ze_reset
argument_list|(
name|isa_dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isa_dev
operator|->
name|id_alive
operator|&&
name|sc
operator|->
name|last_alive
condition|)
block|{
name|pl
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|last_up
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
expr_stmt|;
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
name|sc
operator|->
name|last_alive
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|isa_dev
operator|->
name|id_alive
operator|&&
operator|!
name|sc
operator|->
name|last_alive
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|last_up
condition|)
block|{
name|pl
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|if_up
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|last_alive
operator|=
literal|1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
else|else
block|{
name|sc
operator|->
name|last_alive
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Set interface to stopped condition (reset) 	 */
name|ze_stop
argument_list|(
name|isa_dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize ifnet structure 	 */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|isa_dev
operator|->
name|id_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"ze"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ze_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ze_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ze_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator|)
expr_stmt|;
comment|/* 	 * Attach the interface 	 */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Print additional info when attached 	 */
name|printf
argument_list|(
literal|"ze%d: address %6D, type %s (%dbit), MAU %s\n"
argument_list|,
name|isa_dev
operator|->
name|id_unit
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|type_str
argument_list|,
name|sc
operator|->
name|memwidth
argument_list|,
name|sc
operator|->
name|mau
argument_list|)
expr_stmt|;
comment|/* 	 * If BPF is in the kernel, call the attach for it 	 */
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|NAPM
operator|>
literal|0
name|sc
operator|->
name|s_hook
operator|.
name|ah_fun
operator|=
name|ze_suspend
expr_stmt|;
name|sc
operator|->
name|s_hook
operator|.
name|ah_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|isa_dev
expr_stmt|;
name|sc
operator|->
name|s_hook
operator|.
name|ah_name
operator|=
literal|"IBM PCMCIA Ethernet I/II"
expr_stmt|;
name|sc
operator|->
name|s_hook
operator|.
name|ah_order
operator|=
name|APM_MID_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_SUSPEND
argument_list|,
operator|&
name|sc
operator|->
name|s_hook
argument_list|)
expr_stmt|;
name|sc
operator|->
name|r_hook
operator|.
name|ah_fun
operator|=
name|ze_resume
expr_stmt|;
name|sc
operator|->
name|r_hook
operator|.
name|ah_arg
operator|=
operator|(
name|void
operator|*
operator|)
name|isa_dev
expr_stmt|;
name|sc
operator|->
name|r_hook
operator|.
name|ah_name
operator|=
literal|"IBM PCMCIA Ethernet I/II"
expr_stmt|;
name|sc
operator|->
name|r_hook
operator|.
name|ah_order
operator|=
name|APM_MID_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_RESUME
argument_list|,
operator|&
name|sc
operator|->
name|r_hook
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NAPM> 0 */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Reset interface.  */
end_comment

begin_function
specifier|static
name|void
name|ze_reset
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* 	 * Stop interface and re-initialize. 	 */
name|ze_stop
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ze_init
argument_list|(
name|unit
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take interface offline.  */
end_comment

begin_function
specifier|static
name|void
name|ze_stop
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ze_softc
modifier|*
name|sc
init|=
operator|&
name|ze_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|n
init|=
literal|5000
decl_stmt|;
comment|/* 	 * Stop everything on the interface, and select page 0 registers. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for interface to enter stopped state, but limit # of checks 	 *	to 'n' (about 5ms). It shouldn't even take 5us on modern 	 *	DS8390's, but just in case it's an old one. 	 */
while|while
condition|(
operator|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|)
operator|&
name|ED_ISR_RST
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|--
name|n
condition|)
empty_stmt|;
name|pcic_power_off
argument_list|(
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Device timeout/watchdog routine. Entered if the device neglects to  *	generate an interrupt after a transmit has been started on it.  */
end_comment

begin_function
specifier|static
name|void
name|ze_watchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
if|#
directive|if
literal|1
name|struct
name|ze_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ze_softc
operator|*
operator|)
name|ifp
decl_stmt|;
name|u_char
name|isr
decl_stmt|,
name|imr
decl_stmt|;
ifndef|#
directive|ifndef
name|SMP
name|u_int
name|imask
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
return|return;
comment|/* select page zero */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|)
operator|&
literal|0x3f
operator|)
operator||
name|ED_CR_PAGE_0
argument_list|)
expr_stmt|;
comment|/* read interrupt status register */
name|isr
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|)
operator|&
literal|0xff
expr_stmt|;
comment|/* select page two */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|)
operator|&
literal|0x3f
operator|)
operator||
name|ED_CR_PAGE_2
argument_list|)
expr_stmt|;
comment|/* read interrupt mask register */
name|imr
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P2_IMR
argument_list|)
operator|&
literal|0xff
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* INTRGET() is NOT MP_SAFE, forgo printing it for now... */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ze%d: device timeout, isr=%02x, imr=%02x\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|isr
argument_list|,
name|imr
argument_list|)
expr_stmt|;
else|#
directive|else
name|imask
operator|=
name|INTRGET
argument_list|()
expr_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ze%d: device timeout, isr=%02x, imr=%02x, imask=%04x\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|isr
argument_list|,
name|imr
argument_list|,
name|imask
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SMP */
else|#
directive|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ze%d: device timeout\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ze_reset
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize device.  */
end_comment

begin_function
specifier|static
name|void
name|ze_init
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ze_softc
modifier|*
name|sc
init|=
operator|&
name|ze_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|pcic_power_on
argument_list|(
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
name|pcic_reset
argument_list|(
name|sc
operator|->
name|slot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
name|Debugger
argument_list|(
literal|"here!!"
argument_list|)
expr_stmt|;
name|ze_setup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* address not known */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_addrhead
argument_list|)
condition|)
return|return;
comment|/* XXX unlikely! */
comment|/* 	 * Initialize the NIC in the exact order outlined in the NS manual. 	 *	This init procedure is "mandatory"...don't change what or when 	 *	things happen. 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* reset transmitter flags */
name|sc
operator|->
name|data_buffered
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|xmit_busy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|txb_next
operator|=
literal|0
expr_stmt|;
comment|/* This variable is used below - don't move this assignment */
name|sc
operator|->
name|next_packet
operator|=
name|sc
operator|->
name|rec_page_start
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Set interface for page 0, Remote DMA complete, Stopped 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|memwidth
operator|==
literal|16
condition|)
block|{
comment|/* 		 * Set FIFO threshold to 8, No auto-init Remote DMA, 		 *	byte order=80x86, word-wide DMA xfers 		 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_DCR
argument_list|,
name|ED_DCR_FT1
operator||
name|ED_DCR_WTS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Same as above, but byte-wide DMA xfers 		 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_DCR
argument_list|,
name|ED_DCR_FT1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear Remote Byte Count Registers 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RBCR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RBCR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Enable reception of broadcast packets 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RCR
argument_list|,
name|ED_RCR_AB
argument_list|)
expr_stmt|;
comment|/* 	 * Place NIC in internal loopback mode 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TCR
argument_list|,
name|ED_TCR_LB0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize transmit/receive (ring-buffer) Page Start 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TPSR
argument_list|,
name|sc
operator|->
name|tx_page_start
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_PSTART
argument_list|,
name|sc
operator|->
name|rec_page_start
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize Receiver (ring-buffer) Page Stop and Boundry 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_PSTOP
argument_list|,
name|sc
operator|->
name|rec_page_stop
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_BNRY
argument_list|,
name|sc
operator|->
name|rec_page_start
argument_list|)
expr_stmt|;
comment|/* 	 * Clear all interrupts. A '1' in each bit position clears the 	 *	corresponding flag. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 	 * Enable the following interrupts: receive/transmit complete, 	 *	receive/transmit error, and Receiver OverWrite. 	 * 	 * Counter overflow and Remote DMA complete are *not* enabled. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_IMR
argument_list|,
name|ED_IMR_PRXE
operator||
name|ED_IMR_PTXE
operator||
name|ED_IMR_RXEE
operator||
name|ED_IMR_TXEE
operator||
name|ED_IMR_OVWE
argument_list|)
expr_stmt|;
comment|/* 	 * Program Command Register for page 1 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_PAGE_1
operator||
name|ED_CR_RD2
operator||
name|ED_CR_STP
argument_list|)
expr_stmt|;
comment|/* 	 * Copy out our station address 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P1_PAR0
operator|+
name|i
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize multicast address hashing registers to accept 	 *	 all multicasts (only used when in promiscuous mode) 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P1_MAR0
operator|+
name|i
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 	 * Set Current Page pointer to next_packet (initialized above) 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P1_CURR
argument_list|,
name|sc
operator|->
name|next_packet
argument_list|)
expr_stmt|;
comment|/* 	 * Set Command Register for page 0, Remote DMA complete, 	 * 	and interface Start. 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P1_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* 	 * Take interface out of loopback 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Set 'running' flag, and clear output active flag. 	 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* 	 * ...and attempt to start output 	 */
name|ze_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine actually starts the transmission on the interface  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ze_xmit
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ze_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|u_short
name|len
init|=
name|sc
operator|->
name|txb_next_len
decl_stmt|;
comment|/* 	 * Set NIC for page 0 register access 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* 	 * Set TX buffer start page 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TPSR
argument_list|,
name|sc
operator|->
name|tx_page_start
operator|+
name|sc
operator|->
name|txb_next
operator|*
name|ED_TXBUF_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Set TX length 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TBCR0
argument_list|,
name|len
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TBCR1
argument_list|,
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * Set page 0, Remote DMA complete, Transmit Packet, and *Start* 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_TXP
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
name|sc
operator|->
name|xmit_busy
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|data_buffered
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Switch buffers if we are doing double-buffered transmits 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|txb_next
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sc
operator|->
name|txb_cnt
operator|>
literal|1
operator|)
condition|)
name|sc
operator|->
name|txb_next
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|txb_next
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set a timer just in case we never hear from the board again 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  * We make two assumptions here:  *  1) that the current priority is set to splnet _before_ this code  *     is called *and* is returned to the appropriate priority after  *     return  *  2) that the IFF_OACTIVE flag is checked before this code is called  *     (i.e. that the output part of the interface is idle)  */
end_comment

begin_function
specifier|static
name|void
name|ze_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|ze_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|buffer
decl_stmt|;
name|int
name|len
decl_stmt|;
name|outloop
label|:
comment|/* 	 * See if there is room to send more data (i.e. one or both of the 	 *	buffers is empty). 	 */
if|if
condition|(
name|sc
operator|->
name|data_buffered
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|xmit_busy
condition|)
block|{
comment|/* 			 * No room. Indicate this to the outside world 			 *	and exit. 			 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* 			 * Data is buffered, but we're not transmitting, so 			 *	start the xmit on the buffered data. 			 * Note that ze_xmit() resets the data_buffered flag 			 *	before returning. 			 */
name|ze_xmit
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * The following isn't pretty; we are using the !OACTIVE flag to 	 * indicate to the outside world that we can accept an additional 	 * packet rather than that the transmitter is _actually_ 	 * active. Indeed, the transmitter may be active, but if we haven't 	 * filled the secondary buffer with data then we still want to 	 * accept more. 	 * Note that it isn't necessary to test the data_buffered flag - 	 * we wouldn't have tried to de-queue the packet in the first place 	 * if it was set. 	 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
comment|/* 	 * Copy the mbuf chain into the transmit buffer 	 */
name|buffer
operator|=
name|sc
operator|->
name|smem_start
operator|+
operator|(
name|sc
operator|->
name|txb_next
operator|*
name|ED_TXBUF_SIZE
operator|*
name|ED_PAGE_SIZE
operator|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|sc
operator|->
name|txb_next_len
operator|=
name|max
argument_list|(
name|len
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|txb_cnt
operator|>
literal|1
condition|)
comment|/* 		 * only set 'buffered' flag if doing multiple buffers 		 */
name|sc
operator|->
name|data_buffered
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|xmit_busy
operator|==
literal|0
condition|)
name|ze_xmit
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * If there is BPF support in the configuration, tap off here. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* 	 * If we are doing double-buffering, a buffer might be free to 	 *	fill with another packet, so loop back to the top. 	 */
if|if
condition|(
name|sc
operator|->
name|txb_cnt
operator|>
literal|1
condition|)
goto|goto
name|outloop
goto|;
else|else
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
comment|/* only called from one place, so may as well inline */
name|ze_rint
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
specifier|register
name|struct
name|ze_softc
modifier|*
name|sc
init|=
operator|&
name|ze_softc
index|[
name|unit
index|]
decl_stmt|;
name|u_char
name|boundry
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|struct
name|ed_ring
modifier|*
name|packet_ptr
decl_stmt|;
comment|/* 	 * Set NIC to page 1 registers to get 'current' pointer 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_PAGE_1
operator||
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* 	 * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e. 	 *	it points to where new data has been buffered. The 'CURR' 	 *	(current) register points to the logical end of the ring-buffer 	 *	- i.e. it points to where additional new data will be added. 	 *	We loop here until the logical beginning equals the logical 	 *	end (or in other words, until the ring-buffer is empty). 	 */
while|while
condition|(
name|sc
operator|->
name|next_packet
operator|!=
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P1_CURR
argument_list|)
condition|)
block|{
comment|/* get pointer to this buffer header structure */
name|packet_ptr
operator|=
operator|(
expr|struct
name|ed_ring
operator|*
operator|)
operator|(
name|sc
operator|->
name|smem_ring
operator|+
operator|(
name|sc
operator|->
name|next_packet
operator|-
name|sc
operator|->
name|rec_page_start
operator|)
operator|*
name|ED_PAGE_SIZE
operator|)
expr_stmt|;
comment|/* 		 * The byte count includes the FCS - Frame Check Sequence (a 		 *	32 bit CRC). 		 */
name|len
operator|=
name|packet_ptr
operator|->
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|>=
name|ETHER_MIN_LEN
operator|)
operator|&&
operator|(
name|len
operator|<=
name|ETHER_MAX_LEN
operator|)
condition|)
block|{
comment|/* 			 * Go get packet. len - 4 removes CRC from length. 			 * (packet_ptr + 1) points to data just after the packet ring 			 *	header (+4 bytes) 			 */
name|ze_get_packet
argument_list|(
name|sc
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|packet_ptr
operator|+
literal|1
argument_list|)
argument_list|,
name|len
operator|-
literal|4
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ipackets
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Really BAD...probably indicates that the ring pointers 			 *	are corrupted. Also seen on early rev chips under 			 *	high load - the byte order of the length gets switched. 			 */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ze%d: shared memory corrupt - invalid packet length %d\n"
argument_list|,
name|unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ze_reset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Update next packet pointer 		 */
name|sc
operator|->
name|next_packet
operator|=
name|packet_ptr
operator|->
name|next_packet
expr_stmt|;
comment|/* 		 * Update NIC boundry pointer - being careful to keep it 		 *	one buffer behind. (as recommended by NS databook) 		 */
name|boundry
operator|=
name|sc
operator|->
name|next_packet
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|boundry
operator|<
name|sc
operator|->
name|rec_page_start
condition|)
name|boundry
operator|=
name|sc
operator|->
name|rec_page_stop
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Set NIC to page 0 registers to update boundry register 		 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_BNRY
argument_list|,
name|boundry
argument_list|)
expr_stmt|;
comment|/* 		 * Set NIC to page 1 registers before looping to top (prepare to 		 *	get 'CURR' current pointer) 		 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_PAGE_1
operator||
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Ethernet interface interrupt processor  */
end_comment

begin_function
specifier|static
name|void
name|zeintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ze_softc
modifier|*
name|sc
init|=
operator|&
name|ze_softc
index|[
name|unit
index|]
decl_stmt|;
name|u_char
name|isr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
return|return;
comment|/* 	 * Set NIC to page 0 registers 	 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* 	 * loop until there are no more new interrupts 	 */
while|while
condition|(
operator|(
name|isr
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * reset all the bits that we are 'acknowleging' 		 *	by writing a '1' to each bit position that was set 		 * (writing a '1' *clears* the bit) 		 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_ISR
argument_list|,
name|isr
argument_list|)
expr_stmt|;
comment|/* 		 * Transmit error. If a TX completed with an error, we end up 		 *	throwing the packet away. Really the only error that is 		 *	possible is excessive collisions, and in this case it is 		 *	best to allow the automatic mechanisms of TCP to backoff 		 *	the flow. Of course, with UDP we're screwed, but this is 		 *	expected when a network is heavily loaded. 		 */
if|if
condition|(
name|isr
operator|&
name|ED_ISR_TXE
condition|)
block|{
name|u_char
name|tsr
init|=
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TSR
argument_list|)
decl_stmt|;
name|u_char
name|ncr
init|=
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_NCR
argument_list|)
decl_stmt|;
comment|/* 			 * Excessive collisions (16) 			 */
if|if
condition|(
operator|(
name|tsr
operator|&
name|ED_TSR_ABT
operator|)
operator|&&
operator|(
name|ncr
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 				 *    When collisions total 16, the P0_NCR will 				 * indicate 0, and the TSR_ABT is set. 				 */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|+=
literal|16
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|+=
name|ncr
expr_stmt|;
comment|/* 			 * update output errors counter 			 */
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
expr_stmt|;
comment|/* 			 * reset tx busy and output active flags 			 */
name|sc
operator|->
name|xmit_busy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* 			 * clear watchdog timer 			 */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Receiver Error. One or more of: CRC error, frame alignment error 		 *	FIFO overrun, or missed packet. 		 */
if|if
condition|(
name|isr
operator|&
name|ED_ISR_RXE
condition|)
block|{
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
expr_stmt|;
ifdef|#
directive|ifdef
name|ZE_DEBUG
name|printf
argument_list|(
literal|"ze%d: receive error %b\n"
argument_list|,
name|unit
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RSR
argument_list|)
argument_list|,
literal|"\20\8DEF\7REC DISAB\6PHY/MC\5MISSED\4OVR\3ALIGN\2FCS\1RCVD"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 		 * Overwrite warning. In order to make sure that a lockup 		 *	of the local DMA hasn't occurred, we reset and 		 *	re-init the NIC. The NSC manual suggests only a 		 *	partial reset/re-init is necessary - but some 		 *	chips seem to want more. The DMA lockup has been 		 *	seen only with early rev chips - Methinks this 		 *	bug was fixed in later revs. -DG 		 */
if|if
condition|(
name|isr
operator|&
name|ED_ISR_OVW
condition|)
block|{
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ierrors
expr_stmt|;
comment|/* 			 * Stop/reset/re-init NIC 			 */
name|ze_reset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Transmission completed normally. 		 */
if|if
condition|(
name|isr
operator|&
name|ED_ISR_PTX
condition|)
block|{
comment|/* 			 * reset tx busy and output active flags 			 */
name|sc
operator|->
name|xmit_busy
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* 			 * clear watchdog timer 			 */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Update total number of successfully transmitted 			 *	packets. 			 */
operator|++
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
expr_stmt|;
comment|/* 			 * Add in total number of collisions on last 			 *	transmission. 			 */
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|+=
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_TBCR0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Receive Completion. Go and get the packet. 		 *	XXX - Doing this on an error is dubious because there 		 *	   shouldn't be any data to get (we've configured the 		 *	   interface to not accept packets with errors). 		 */
if|if
condition|(
name|isr
operator|&
operator|(
name|ED_ISR_PRX
operator||
name|ED_ISR_RXE
operator|)
condition|)
block|{
name|ze_rint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If it looks like the transmitter can take more data, 		 *	attempt to start output on the interface. If data is 		 *	already buffered and ready to go, send it first. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|data_buffered
condition|)
name|ze_xmit
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
name|ze_start
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * return NIC CR to standard state: page 0, remote DMA complete, 		 * 	start (toggling the TXP bit off, even if was just set 		 *	in the transmit routine, is *okay* - it is 'edge' 		 *	triggered from low to high) 		 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CR
argument_list|,
name|ED_CR_RD2
operator||
name|ED_CR_STA
argument_list|)
expr_stmt|;
comment|/* 		 * If the Network Talley Counters overflow, read them to 		 *	reset them. It appears that old 8390's won't 		 *	clear the ISR flag otherwise - resulting in an 		 *	infinite loop. 		 */
if|if
condition|(
name|isr
operator|&
name|ED_ISR_CNT
condition|)
block|{
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CNTR0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CNTR1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_CNTR2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request. This code needs some work - it looks  *	pretty ugly.  */
end_comment

begin_function
specifier|static
name|int
name|ze_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|ze_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * When the card is offlined, `up' operation can't be permitted 		 */
if|if
condition|(
operator|!
name|sc
operator|->
name|last_alive
condition|)
block|{
name|int
name|tmp
decl_stmt|;
name|tmp
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|last_up
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_UP
operator|)
expr_stmt|;
block|}
name|sc
operator|->
name|last_up
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* 		 * If interface is marked down and it is running, then stop it 		 */
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|ze_stop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If interface is marked up and it is stopped, then start it 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|)
condition|)
name|ze_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
comment|/* 			 * Set promiscuous mode on interface. 			 *	XXX - for multicasts to work, we would need to 			 *		write 1's in all bits of multicast 			 *		hashing array. For now we assume that 			 *		this was done in ze_init(). 			 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RCR
argument_list|,
name|ED_RCR_PRO
operator||
name|ED_RCR_AM
operator||
name|ED_RCR_AB
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * XXX - for multicasts to work, we would need to 			 *	rewrite the multicast hashing array with the 			 *	proper hash (would have been destroyed above). 			 */
name|outb
argument_list|(
name|sc
operator|->
name|nic_addr
operator|+
name|ED_P0_RCR
argument_list|,
name|ED_RCR_AB
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Macro to calculate a new address within shared memory when given an offset  *	from an address, taking into account ring-wrap.  */
end_comment

begin_define
define|#
directive|define
name|ringoffset
parameter_list|(
name|sc
parameter_list|,
name|start
parameter_list|,
name|off
parameter_list|,
name|type
parameter_list|)
define|\
value|((type)( ((caddr_t)(start)+(off)>= (sc)->smem_end) ? \ 		(((caddr_t)(start)+(off))) - (sc)->smem_end \ 		+ (sc)->smem_ring: \ 		((caddr_t)(start)+(off)) ))
end_define

begin_comment
comment|/*  * Retreive packet from shared memory and send to the next level up via  *	ether_input(). If there is a BPF listener, give a copy to BPF, too.  */
end_comment

begin_function
specifier|static
name|void
name|ze_get_packet
parameter_list|(
name|sc
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|ze_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|u_short
name|len
decl_stmt|;
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|head
init|=
name|NULL
decl_stmt|;
comment|/* Allocate a header mbuf */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|head
operator|=
name|m
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* The following sillines is to make NFS happy */
define|#
directive|define
name|EROUND
value|((sizeof(struct ether_header) + 3)& ~3)
define|#
directive|define
name|EOFF
value|(EROUND - sizeof(struct ether_header))
comment|/* 	 * The following assumes there is room for 	 * the ether header in the header mbuf 	 */
name|head
operator|->
name|m_data
operator|+=
name|EOFF
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|mtod
argument_list|(
name|head
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|head
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* 	 * Pull packet off interface. Or if this was a trailer packet, 	 * the data portion is appended. 	 */
name|m
operator|=
name|ze_ring_to_mbuf
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Check if there's a BPF listener on this interface. 	 * If so, hand off the raw packet to bpf. 	 */
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|head
argument_list|)
expr_stmt|;
comment|/* 		 * Note that the interface cannot be in promiscuous mode if 		 * there are no BPF listeners.  And if we are in promiscuous 		 * mode, we have to check if this packet is really ours. 		 * 		 * XXX This test does not support multicasts. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Fix up data start offset in mbuf to point past ether header 	 */
name|m_adj
argument_list|(
name|head
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
if|if
condition|(
name|head
condition|)
name|m_freem
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Supporting routines  */
end_comment

begin_comment
comment|/*  * Given a source and destination address, copy 'amount' of a packet from  *	the ring buffer into a linear destination buffer. Takes into account  *	ring-wrap.  */
end_comment

begin_function
specifier|static
name|__inline
name|char
modifier|*
name|ze_ring_copy
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|amount
parameter_list|)
name|struct
name|ze_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|u_short
name|amount
decl_stmt|;
block|{
name|u_short
name|tmp_amount
decl_stmt|;
comment|/* does copy wrap to lower addr in ring buffer? */
if|if
condition|(
name|src
operator|+
name|amount
operator|>
name|sc
operator|->
name|smem_end
condition|)
block|{
name|tmp_amount
operator|=
name|sc
operator|->
name|smem_end
operator|-
name|src
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|tmp_amount
argument_list|)
expr_stmt|;
comment|/* copy amount up to end of smem */
name|amount
operator|-=
name|tmp_amount
expr_stmt|;
name|src
operator|=
name|sc
operator|->
name|smem_ring
expr_stmt|;
name|dst
operator|+=
name|tmp_amount
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|amount
argument_list|)
expr_stmt|;
return|return
operator|(
name|src
operator|+
name|amount
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy data from receive buffer to end of mbuf chain  * allocate additional mbufs as needed. return pointer  * to last mbuf in chain.  * sc = ze info (softc)  * src = pointer in ze ring buffer  * dst = pointer to last mbuf in mbuf chain to copy to  * amount = amount of data to copy  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ze_ring_to_mbuf
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|total_len
parameter_list|)
name|struct
name|ze_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|dst
decl_stmt|;
name|u_short
name|total_len
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|dst
decl_stmt|;
while|while
condition|(
name|total_len
condition|)
block|{
specifier|register
name|u_short
name|amount
init|=
name|min
argument_list|(
name|total_len
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
block|{
comment|/* no more data in this mbuf, alloc another */
comment|/* 			 * If there is enough data for an mbuf cluster, attempt 			 * 	to allocate one of those, otherwise, a regular 			 *	mbuf will do. 			 * Note that a regular mbuf is always required, even if 			 *	we get a cluster - getting a cluster does not 			 *	allocate any mbufs, and one is needed to assign 			 *	the cluster to. The mbuf that has a cluster 			 *	extension can not be used to contain data - only 			 *	the cluster can contain data. 			 */
name|dst
operator|=
name|m
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|total_len
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|dst
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|amount
operator|=
name|min
argument_list|(
name|total_len
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|src
operator|=
name|ze_ring_copy
argument_list|(
name|sc
argument_list|,
name|src
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|amount
expr_stmt|;
name|total_len
operator|-=
name|amount
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

