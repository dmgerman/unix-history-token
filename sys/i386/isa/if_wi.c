begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 1998, 1999  *	Bill Paul<wpaul@ctr.columbia.edu>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  *  *	$Id: if_wi.c,v 1.8 1999/07/06 19:22:53 des Exp $  */
end_comment

begin_comment
comment|/*  * Lucent WaveLAN/IEEE 802.11 PCMCIA driver for FreeBSD.  *  * Written by Bill Paul<wpaul@ctr.columbia.edu>  * Electrical Engineering Department  * Columbia University, New York City  */
end_comment

begin_comment
comment|/*  * The WaveLAN/IEEE adapter is the second generation of the WaveLAN  * from Lucent. Unlike the older cards, the new ones are programmed  * entirely via a firmware-driven controller called the Hermes.  * Unfortunately, Lucent will not release the Hermes programming manual  * without an NDA (if at all). What they do release is an API library  * called the HCF (Hardware Control Functions) which is supposed to  * do the device-specific operations of a device driver for you. The  * publically available version of the HCF library (the 'HCF Light') is   * a) extremely gross, b) lacks certain features, particularly support  * for 802.11 frames, and c) is contaminated by the GNU Public License.  *  * This driver does not use the HCF or HCF Light at all. Instead, it  * programs the Hermes controller directly, using information gleaned  * from the HCF Light code and corresponding documentation.  *  * This driver supports both the PCMCIA and ISA versions of the  * WaveLAN/IEEE cards. Note however that the ISA card isn't really  * anything of the sort: it's actually a PCMCIA bridge adapter  * that fits into an ISA slot, into which a PCMCIA WaveLAN card is  * inserted. Consequently, you need to use the pccard support for  * both the ISA and PCMCIA adapters.  */
end_comment

begin_define
define|#
directive|define
name|WI_HERMES_AUTOINC_WAR
end_define

begin_comment
comment|/* Work around data write autoinc bug. */
end_comment

begin_define
define|#
directive|define
name|WI_HERMES_STATS_WAR
end_define

begin_comment
comment|/* Work around stats counter bug. */
end_comment

begin_include
include|#
directive|include
file|"bpf.h"
end_include

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_include
include|#
directive|include
file|"wi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPF
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_wireg.h>
end_include

begin_include
include|#
directive|include
file|<machine/if_wavelan_ieee.h>
end_include

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<pccard/cardinfo.h>
end_include

begin_include
include|#
directive|include
file|<pccard/slot.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: if_wi.c,v 1.8 1999/07/06 19:22:53 des Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|wi_softc
name|wi_softc
index|[
name|NWI
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|foo
end_ifdef

begin_decl_stmt
specifier|static
name|u_int8_t
name|wi_mcast_addr
index|[
literal|6
index|]
init|=
block|{
literal|0x01
block|,
literal|0x60
block|,
literal|0x1D
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|wi_probe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_attach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PCCARD_MODULE
end_ifdef

begin_decl_stmt
specifier|static
name|ointhand2_t
name|wi_intr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|wi_reset
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|u_long
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_init
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_start
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_stop
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_watchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_shutdown
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_rxeof
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_txeof
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_update_stats
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_setmulti
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_read_record
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
expr|struct
name|wi_ltv_gen
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_write_record
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
expr|struct
name|wi_ltv_gen
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_read_data
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_write_data
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_seek
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_alloc_nicmem
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_inquire
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_setdef
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
expr|struct
name|wi_req
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_mgmt_xmit
name|__P
argument_list|(
operator|(
expr|struct
name|wi_softc
operator|*
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|widriver
init|=
block|{
name|wi_probe
block|,
name|wi_attach
block|,
literal|"wi"
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_decl_stmt
specifier|static
name|int
name|wi_pccard_init
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wi_pccard_unload
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wi_pccard_intr
name|__P
argument_list|(
operator|(
expr|struct
name|pccard_devinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PCCARD_MODULE
end_ifdef

begin_expr_stmt
name|PCCARD_MODULE
argument_list|(
name|wi
argument_list|,
name|wi_pccard_init
argument_list|,
name|wi_pccard_unload
argument_list|,
name|wi_pccard_intr
argument_list|,
literal|0
argument_list|,
name|net_imask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|pccard_device
name|wi_info
init|=
block|{
literal|"wi"
block|,
name|wi_pccard_init
block|,
name|wi_pccard_unload
block|,
name|wi_pccard_intr
block|,
literal|0
block|,
comment|/* Attributes - presently unused */
operator|&
name|net_imask
comment|/* Interrupt mask for device */
comment|/* XXX - Should this also include net_imask? */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pccarddrv_set
argument_list|,
name|wi_info
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Initialize the PCCARD. */
end_comment

begin_function
specifier|static
name|int
name|wi_pccard_init
parameter_list|(
name|sc_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|sc_p
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int32_t
name|irq
decl_stmt|;
if|if
condition|(
name|sc_p
operator|->
name|isahd
operator|.
name|id_unit
operator|>=
name|NWI
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|sc
operator|=
operator|&
name|wi_softc
index|[
name|sc_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|sc
operator|->
name|wi_gone
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|wi_unit
operator|=
name|sc_p
operator|->
name|isahd
operator|.
name|id_unit
expr_stmt|;
name|sc
operator|->
name|wi_bhandle
operator|=
name|sc_p
operator|->
name|isahd
operator|.
name|id_iobase
expr_stmt|;
name|sc
operator|->
name|wi_btag
operator|=
name|I386_BUS_SPACE_IO
expr_stmt|;
comment|/* Make sure interrupts are disabled. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
comment|/* Grr. IRQ is encoded as a bitmask. */
name|irq
operator|=
name|sc_p
operator|->
name|isahd
operator|.
name|id_irq
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|irq
operator|&
literal|0x1
condition|)
break|break;
name|irq
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Print a nice probe message to let the operator 	 * know something interesting is happening. 	 */
name|printf
argument_list|(
literal|"wi%d:<WaveLAN/IEEE 802.11> at 0x%x-0x%x irq %d on isa\n"
argument_list|,
name|sc_p
operator|->
name|isahd
operator|.
name|id_unit
argument_list|,
name|sc_p
operator|->
name|isahd
operator|.
name|id_iobase
argument_list|,
name|sc_p
operator|->
name|isahd
operator|.
name|id_iobase
operator|+
name|WI_IOSIZ
operator|-
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_attach
argument_list|(
operator|&
name|sc_p
operator|->
name|isahd
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_pccard_unload
parameter_list|(
name|sc_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|sc_p
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
operator|&
name|wi_softc
index|[
name|sc_p
operator|->
name|isahd
operator|.
name|id_unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
block|{
name|printf
argument_list|(
literal|"wi%d: already unloaded\n"
argument_list|,
name|sc_p
operator|->
name|isahd
operator|.
name|id_unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|if_down
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_gone
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"wi%d: unloaded\n"
argument_list|,
name|sc_p
operator|->
name|isahd
operator|.
name|id_unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_pccard_intr
parameter_list|(
name|sc_p
parameter_list|)
name|struct
name|pccard_devinfo
modifier|*
name|sc_p
decl_stmt|;
block|{
name|wi_intr
argument_list|(
name|sc_p
operator|->
name|isahd
operator|.
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|wi_probe
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
comment|/* 	 * The ISA WaveLAN/IEEE card is actually not an ISA card: 	 * it's a PCMCIA card plugged into a PCMCIA bridge adapter 	 * that fits into an ISA slot. Consequently, we will always 	 * be using the pccard support to probe and attach these 	 * devices, so we can never actually probe one from here. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_attach
parameter_list|(
name|isa_dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|isa_dev
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_ltv_macaddr
name|mac
decl_stmt|;
name|struct
name|wi_ltv_gen
name|gen
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|char
name|ifname
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|PCCARD_MODULE
name|isa_dev
operator|->
name|id_ointr
operator|=
name|wi_intr
expr_stmt|;
endif|#
directive|endif
name|sc
operator|=
operator|&
name|wi_softc
index|[
name|isa_dev
operator|->
name|id_unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/* Reset the NIC. */
name|wi_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Read the station address. */
name|mac
operator|.
name|wi_type
operator|=
name|WI_RID_MAC_NODE
expr_stmt|;
name|mac
operator|.
name|wi_len
operator|=
literal|4
expr_stmt|;
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|mac
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mac
operator|.
name|wi_mac_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"wi%d: Ethernet address: %6D\n"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|sc
operator|->
name|wi_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"wi"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|wi_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|wi_start
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|wi_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|wi_init
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
literal|10000000
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|WI_DEFAULT_NODENAME
argument_list|,
name|sc
operator|->
name|wi_node_name
argument_list|,
sizeof|sizeof
argument_list|(
name|WI_DEFAULT_NODENAME
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|WI_DEFAULT_NETNAME
argument_list|,
name|sc
operator|->
name|wi_net_name
argument_list|,
sizeof|sizeof
argument_list|(
name|WI_DEFAULT_NETNAME
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|wi_ibss_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_ibss_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|WI_DEFAULT_IBSS
argument_list|,
name|sc
operator|->
name|wi_ibss_name
argument_list|,
sizeof|sizeof
argument_list|(
name|WI_DEFAULT_IBSS
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_portnum
operator|=
name|WI_DEFAULT_PORT
expr_stmt|;
name|sc
operator|->
name|wi_ptype
operator|=
name|WI_PORTTYPE_ADHOC
expr_stmt|;
name|sc
operator|->
name|wi_ap_density
operator|=
name|WI_DEFAULT_AP_DENSITY
expr_stmt|;
name|sc
operator|->
name|wi_rts_thresh
operator|=
name|WI_DEFAULT_RTS_THRESH
expr_stmt|;
name|sc
operator|->
name|wi_tx_rate
operator|=
name|WI_DEFAULT_TX_RATE
expr_stmt|;
name|sc
operator|->
name|wi_max_data_len
operator|=
name|WI_DEFAULT_DATALEN
expr_stmt|;
name|sc
operator|->
name|wi_create_ibss
operator|=
name|WI_DEFAULT_CREATE_IBSS
expr_stmt|;
name|sc
operator|->
name|wi_pm_enabled
operator|=
name|WI_DEFAULT_PM_ENABLED
expr_stmt|;
name|sc
operator|->
name|wi_max_sleep
operator|=
name|WI_DEFAULT_MAX_SLEEP
expr_stmt|;
comment|/* 	 * Read the default channel from the NIC. This may vary 	 * depending on the country where the NIC was purchased, so 	 * we can't hard-code a default and expect it to work for 	 * everyone. 	 */
name|gen
operator|.
name|wi_type
operator|=
name|WI_RID_OWN_CHNL
expr_stmt|;
name|gen
operator|.
name|wi_len
operator|=
literal|2
expr_stmt|;
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|&
name|gen
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_channel
operator|=
name|gen
operator|.
name|wi_val
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_stats
argument_list|)
argument_list|)
expr_stmt|;
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If this logical interface has already been attached, 	 * don't attach it again or chaos will ensue. 	 */
name|sprintf
argument_list|(
name|ifname
argument_list|,
literal|"wi%d"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifunit
argument_list|(
name|ifname
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|wi_stat_ch
argument_list|)
expr_stmt|;
comment|/* 		 * Call MI attach routines. 		 */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPF
operator|>
literal|0
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|wi_shutdown
argument_list|,
name|sc
argument_list|,
name|SHUTDOWN_PRI_DEFAULT
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_rxeof
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|wi_frame
name|rx_frame
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|id
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_RX_FID
argument_list|)
expr_stmt|;
comment|/* First read in the frame header */
if|if
condition|(
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|rx_frame
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_frame
argument_list|)
argument_list|)
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rx_frame
operator|.
name|wi_status
operator|&
name|WI_STAT_ERRSTAT
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
name|rx_frame
operator|.
name|wi_status
operator|==
name|WI_STAT_1042
operator|||
name|rx_frame
operator|.
name|wi_status
operator|==
name|WI_STAT_TUNNEL
operator|||
name|rx_frame
operator|.
name|wi_status
operator|==
name|WI_STAT_WMP_MSG
condition|)
block|{
if|if
condition|(
operator|(
name|rx_frame
operator|.
name|wi_dat_len
operator|+
name|WI_SNAPHDR_LEN
operator|)
operator|>
name|MCLBYTES
condition|)
block|{
name|printf
argument_list|(
literal|"wi%d: oversized packet received "
literal|"(wi_dat_len=%d, wi_status=0x%x)\n"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|,
name|rx_frame
operator|.
name|wi_dat_len
argument_list|,
name|rx_frame
operator|.
name|wi_status
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|rx_frame
operator|.
name|wi_dat_len
operator|+
name|WI_SNAPHDR_LEN
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame
operator|.
name|wi_addr1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame
operator|.
name|wi_addr2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|rx_frame
operator|.
name|wi_type
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_type
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_11_OFFSET
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|+
literal|2
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|rx_frame
operator|.
name|wi_dat_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
operator|>
name|MCLBYTES
condition|)
block|{
name|printf
argument_list|(
literal|"wi%d: oversized packet received "
literal|"(wi_dat_len=%d, wi_status=0x%x)\n"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|,
name|rx_frame
operator|.
name|wi_dat_len
argument_list|,
name|rx_frame
operator|.
name|wi_status
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|rx_frame
operator|.
name|wi_dat_len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_3_OFFSET
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
operator|+
literal|2
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
if|#
directive|if
name|NBPF
operator|>
literal|0
comment|/* Handle BPF listeners. */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|(
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* Receive packet. */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_txeof
parameter_list|(
name|sc
parameter_list|,
name|status
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|WI_EV_TX_EXC
condition|)
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
else|else
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|wi_inquire
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|xsc
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|sc
operator|->
name|wi_stat_ch
operator|=
name|timeout
argument_list|(
name|wi_inquire
argument_list|,
name|sc
argument_list|,
name|hz
operator|*
literal|60
argument_list|)
expr_stmt|;
comment|/* Don't do this while we're transmitting */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
return|return;
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_INQUIRE
argument_list|,
name|WI_INFO_COUNTERS
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|wi_update_stats
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|wi_ltv_gen
name|gen
decl_stmt|;
name|u_int16_t
name|id
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int32_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int16_t
name|t
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_INFO_FID
argument_list|)
expr_stmt|;
name|wi_read_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gen
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
operator|.
name|wi_type
operator|!=
name|WI_INFO_COUNTERS
operator|||
name|gen
operator|.
name|wi_len
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_stats
argument_list|)
operator|/
literal|4
operator|)
operator|+
literal|1
condition|)
return|return;
name|ptr
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_stats
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gen
operator|.
name|wi_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|t
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WI_HERMES_STATS_WAR
if|if
condition|(
name|t
operator|>
literal|0xF000
condition|)
name|t
operator|=
operator|~
name|t
operator|&
literal|0xFFFF
expr_stmt|;
endif|#
directive|endif
name|ptr
index|[
name|i
index|]
operator|+=
name|t
expr_stmt|;
block|}
name|ifp
operator|->
name|if_collisions
operator|=
name|sc
operator|->
name|wi_stats
operator|.
name|wi_tx_single_retries
operator|+
name|sc
operator|->
name|wi_stats
operator|.
name|wi_tx_multi_retries
operator|+
name|sc
operator|->
name|wi_stats
operator|.
name|wi_tx_retry_limit
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|wi_intr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int16_t
name|status
decl_stmt|;
name|sc
operator|=
operator|&
name|wi_softc
index|[
name|unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Disable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_STAT
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
operator|~
name|WI_INTRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|WI_EV_RX
condition|)
block|{
name|wi_rxeof
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_RX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_TX
condition|)
block|{
name|wi_txeof
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_TX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_ALLOC
condition|)
block|{
name|int
name|id
decl_stmt|;
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_ALLOC_FID
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|sc
operator|->
name|wi_tx_data_id
condition|)
name|wi_txeof
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_INFO
condition|)
block|{
name|wi_update_stats
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_INFO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_TX_EXC
condition|)
block|{
name|wi_txeof
argument_list|(
name|sc
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_TX_EXC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|WI_EV_INFO_DROP
condition|)
block|{
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_INFO_DROP
argument_list|)
expr_stmt|;
block|}
comment|/* Re-enable interrupts. */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
name|WI_INTRS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
name|wi_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_cmd
parameter_list|(
name|sc
parameter_list|,
name|cmd
parameter_list|,
name|val
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|int
name|val
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|s
init|=
literal|0
decl_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_PARAM0
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_COMMAND
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WI_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Wait for 'command complete' bit to be 		 * set in the event status register. 		 */
name|s
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_STAT
argument_list|)
operator|&
name|WI_EV_CMD
expr_stmt|;
if|if
condition|(
name|s
condition|)
block|{
comment|/* Ack the event and read result code. */
name|s
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_STATUS
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_CMD
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|foo
if|if
condition|(
operator|(
name|s
operator|&
name|WI_CMD_CODE_MASK
operator|)
operator|!=
operator|(
name|cmd
operator|&
name|WI_CMD_CODE_MASK
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|s
operator|&
name|WI_STAT_CMD_RESULT
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|WI_TIMEOUT
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_reset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_INI
argument_list|,
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"wi%d: init failed\n"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
literal|0xFFFF
argument_list|)
expr_stmt|;
comment|/* Calibrate timer. */
name|WI_SETVAL
argument_list|(
name|WI_RID_TICK_TIME
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Read an LTV record from the NIC.  */
end_comment

begin_function
specifier|static
name|int
name|wi_read_record
parameter_list|(
name|sc
parameter_list|,
name|ltv
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_ltv_gen
modifier|*
name|ltv
decl_stmt|;
block|{
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|code
decl_stmt|;
comment|/* Tell the NIC to enter record read mode. */
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_ACCESS
operator||
name|WI_ACCESS_READ
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Seek to the record. */
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|,
literal|0
argument_list|,
name|WI_BAP1
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* 	 * Read the length and record type and make sure they 	 * match what we expect (this verifies that we have enough 	 * room to hold all of the returned data). 	 */
name|len
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|ltv
operator|->
name|wi_len
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|code
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|ltv
operator|->
name|wi_type
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|ltv
operator|->
name|wi_len
operator|=
name|len
expr_stmt|;
name|ltv
operator|->
name|wi_type
operator|=
name|code
expr_stmt|;
comment|/* Now read the data. */
name|ptr
operator|=
operator|&
name|ltv
operator|->
name|wi_val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ltv
operator|->
name|wi_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|ptr
index|[
name|i
index|]
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Same as read, except we inject data instead of reading it.  */
end_comment

begin_function
specifier|static
name|int
name|wi_write_record
parameter_list|(
name|sc
parameter_list|,
name|ltv
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_ltv_gen
modifier|*
name|ltv
decl_stmt|;
block|{
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|,
literal|0
argument_list|,
name|WI_BAP1
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|,
name|ltv
operator|->
name|wi_len
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|&
name|ltv
operator|->
name|wi_val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ltv
operator|->
name|wi_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_ACCESS
operator||
name|WI_ACCESS_WRITE
argument_list|,
name|ltv
operator|->
name|wi_type
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_seek
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|chan
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|,
name|chan
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|selreg
decl_stmt|,
name|offreg
decl_stmt|;
switch|switch
condition|(
name|chan
condition|)
block|{
case|case
name|WI_BAP0
case|:
name|selreg
operator|=
name|WI_SEL0
expr_stmt|;
name|offreg
operator|=
name|WI_OFF0
expr_stmt|;
break|break;
case|case
name|WI_BAP1
case|:
name|selreg
operator|=
name|WI_SEL1
expr_stmt|;
name|offreg
operator|=
name|WI_OFF1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"wi%d: invalid data path: %x\n"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|selreg
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|offreg
argument_list|,
name|off
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WI_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|offreg
argument_list|)
operator|&
operator|(
name|WI_OFF_BUSY
operator||
name|WI_OFF_ERR
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|WI_TIMEOUT
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_read_data
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|off
argument_list|,
name|WI_BAP1
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|ptr
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|ptr
index|[
name|i
index|]
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * According to the comments in the HCF Light code, there is a bug in  * the Hermes (or possibly in certain Hermes firmware revisions) where  * the chip's internal autoincrement counter gets thrown off during  * data writes: the autoincrement is missed, causing one data word to  * be overwritten and subsequent words to be written to the wrong memory  * locations. The end result is that we could end up transmitting bogus  * frames without realizing it. The workaround for this is to write a  * couple of extra guard words after the end of the transfer, then  * attempt to read then back. If we fail to locate the guard words where  * we expect them, we preform the transfer over again.  */
end_comment

begin_function
specifier|static
name|int
name|wi_write_data
parameter_list|(
name|sc
parameter_list|,
name|id
parameter_list|,
name|off
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|id
decl_stmt|,
name|off
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int16_t
modifier|*
name|ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|WI_HERMES_AUTOINC_WAR
name|again
label|:
endif|#
directive|endif
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|off
argument_list|,
name|WI_BAP0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|ptr
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|len
operator|/
literal|2
operator|)
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|,
name|ptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WI_HERMES_AUTOINC_WAR
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|,
literal|0x1234
argument_list|)
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|,
literal|0x5678
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|off
operator|+
name|len
argument_list|,
name|WI_BAP0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|)
operator|!=
literal|0x1234
operator|||
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|)
operator|!=
literal|0x5678
condition|)
goto|goto
name|again
goto|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a region of memory inside the NIC and zero  * it out.  */
end_comment

begin_function
specifier|static
name|int
name|wi_alloc_nicmem
parameter_list|(
name|sc
parameter_list|,
name|len
parameter_list|,
name|id
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
modifier|*
name|id
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_ALLOC_MEM
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"wi%d: failed to allocate %d bytes on NIC\n"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WI_TIMEOUT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_STAT
argument_list|)
operator|&
name|WI_EV_ALLOC
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|WI_TIMEOUT
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_EVENT_ACK
argument_list|,
name|WI_EV_ALLOC
argument_list|)
expr_stmt|;
operator|*
name|id
operator|=
name|CSR_READ_2
argument_list|(
name|sc
argument_list|,
name|WI_ALLOC_FID
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_seek
argument_list|(
name|sc
argument_list|,
operator|*
name|id
argument_list|,
literal|0
argument_list|,
name|WI_BAP0
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_DATA0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_setmulti
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|wi_ltv_mcast
name|mcast
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mcast
argument_list|,
sizeof|sizeof
argument_list|(
name|mcast
argument_list|)
argument_list|)
expr_stmt|;
name|mcast
operator|.
name|wi_type
operator|=
name|WI_RID_MCAST
expr_stmt|;
name|mcast
operator|.
name|wi_len
operator|=
operator|(
literal|3
operator|*
literal|16
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALLMULTI
operator|||
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|mcast
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|ifma
operator|=
name|ifp
operator|->
name|if_multiaddrs
operator|.
name|lh_first
init|;
name|ifma
operator|!=
name|NULL
condition|;
name|ifma
operator|=
name|ifma
operator|->
name|ifma_link
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
if|if
condition|(
name|i
operator|<
literal|16
condition|)
block|{
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mcast
operator|.
name|wi_mcast
index|[
name|i
index|]
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mcast
argument_list|,
sizeof|sizeof
argument_list|(
name|mcast
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mcast
operator|.
name|wi_len
operator|=
operator|(
name|i
operator|*
literal|3
operator|)
operator|+
literal|1
expr_stmt|;
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|mcast
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_setdef
parameter_list|(
name|sc
parameter_list|,
name|wreq
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_req
modifier|*
name|wreq
decl_stmt|;
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
switch|switch
condition|(
name|wreq
operator|->
name|wi_type
condition|)
block|{
case|case
name|WI_RID_MAC_NODE
case|:
name|ifa
operator|=
name|ifnet_addrs
index|[
name|ifp
operator|->
name|if_index
operator|-
literal|1
index|]
expr_stmt|;
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_PORTTYPE
case|:
name|sc
operator|->
name|wi_ptype
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_TX_RATE
case|:
name|sc
operator|->
name|wi_tx_rate
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_MAX_DATALEN
case|:
name|sc
operator|->
name|wi_max_data_len
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_RTS_THRESH
case|:
name|sc
operator|->
name|wi_rts_thresh
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_SYSTEM_SCALE
case|:
name|sc
operator|->
name|wi_ap_density
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_CREATE_IBSS
case|:
name|sc
operator|->
name|wi_create_ibss
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_OWN_CHNL
case|:
name|sc
operator|->
name|wi_channel
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_NODENAME
case|:
name|bzero
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_node_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|wi_node_name
argument_list|,
literal|30
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_DESIRED_SSID
case|:
name|bzero
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_net_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|wi_net_name
argument_list|,
literal|30
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_OWN_SSID
case|:
name|bzero
argument_list|(
name|sc
operator|->
name|wi_ibss_name
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_ibss_name
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|->
name|wi_val
index|[
literal|1
index|]
argument_list|,
name|sc
operator|->
name|wi_ibss_name
argument_list|,
literal|30
argument_list|)
expr_stmt|;
break|break;
case|case
name|WI_RID_PM_ENABLED
case|:
name|sc
operator|->
name|wi_pm_enabled
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|WI_RID_MAX_SLEEP
case|:
name|sc
operator|->
name|wi_max_sleep
operator|=
name|wreq
operator|->
name|wi_val
index|[
literal|0
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Reinitialize WaveLAN. */
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|wi_req
name|wreq
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|&&
operator|!
operator|(
name|sc
operator|->
name|wi_if_flags
operator|&
name|IFF_PROMISC
operator|)
condition|)
block|{
name|WI_SETVAL
argument_list|(
name|WI_RID_PROMISC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|sc
operator|->
name|wi_if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|WI_SETVAL
argument_list|(
name|WI_RID_PROMISC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|wi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|wi_if_flags
operator|=
name|ifp
operator|->
name|if_flags
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|wi_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCGWAVELAN
case|:
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|wreq
argument_list|,
sizeof|sizeof
argument_list|(
name|wreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_IFACE_STATS
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|wi_stats
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|wreq
operator|.
name|wi_val
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_stats
argument_list|)
argument_list|)
expr_stmt|;
name|wreq
operator|.
name|wi_len
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|wi_stats
argument_list|)
operator|/
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wi_read_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|wreq
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|wreq
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|wreq
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSWAVELAN
case|:
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|wreq
argument_list|,
sizeof|sizeof
argument_list|(
name|wreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_IFACE_STATS
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|wreq
operator|.
name|wi_type
operator|==
name|WI_RID_MGMT_XMIT
condition|)
block|{
name|error
operator|=
name|wi_mgmt_xmit
argument_list|(
name|sc
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|wreq
operator|.
name|wi_val
argument_list|,
name|wreq
operator|.
name|wi_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|wreq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|wi_setdef
argument_list|(
name|sc
argument_list|,
operator|&
name|wreq
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|wi_ltv_macaddr
name|mac
decl_stmt|;
name|int
name|id
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|wi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wi_reset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Program max data length. */
name|WI_SETVAL
argument_list|(
name|WI_RID_MAX_DATALEN
argument_list|,
name|sc
operator|->
name|wi_max_data_len
argument_list|)
expr_stmt|;
comment|/* Enable/disable IBSS creation. */
name|WI_SETVAL
argument_list|(
name|WI_RID_CREATE_IBSS
argument_list|,
name|sc
operator|->
name|wi_create_ibss
argument_list|)
expr_stmt|;
comment|/* Set the port type. */
name|WI_SETVAL
argument_list|(
name|WI_RID_PORTTYPE
argument_list|,
name|sc
operator|->
name|wi_ptype
argument_list|)
expr_stmt|;
comment|/* Program the RTS/CTS threshold. */
name|WI_SETVAL
argument_list|(
name|WI_RID_RTS_THRESH
argument_list|,
name|sc
operator|->
name|wi_rts_thresh
argument_list|)
expr_stmt|;
comment|/* Program the TX rate */
name|WI_SETVAL
argument_list|(
name|WI_RID_TX_RATE
argument_list|,
name|sc
operator|->
name|wi_tx_rate
argument_list|)
expr_stmt|;
comment|/* Access point density */
name|WI_SETVAL
argument_list|(
name|WI_RID_SYSTEM_SCALE
argument_list|,
name|sc
operator|->
name|wi_ap_density
argument_list|)
expr_stmt|;
comment|/* Power Management Enabled */
name|WI_SETVAL
argument_list|(
name|WI_RID_PM_ENABLED
argument_list|,
name|sc
operator|->
name|wi_pm_enabled
argument_list|)
expr_stmt|;
comment|/* Power Managment Max Sleep */
name|WI_SETVAL
argument_list|(
name|WI_RID_MAX_SLEEP
argument_list|,
name|sc
operator|->
name|wi_max_sleep
argument_list|)
expr_stmt|;
comment|/* Specify the IBSS name */
name|WI_SETSTR
argument_list|(
name|WI_RID_OWN_SSID
argument_list|,
name|sc
operator|->
name|wi_ibss_name
argument_list|)
expr_stmt|;
comment|/* Specify the network name */
name|WI_SETSTR
argument_list|(
name|WI_RID_DESIRED_SSID
argument_list|,
name|sc
operator|->
name|wi_net_name
argument_list|)
expr_stmt|;
comment|/* Specify the frequency to use */
name|WI_SETVAL
argument_list|(
name|WI_RID_OWN_CHNL
argument_list|,
name|sc
operator|->
name|wi_channel
argument_list|)
expr_stmt|;
comment|/* Program the nodename. */
name|WI_SETSTR
argument_list|(
name|WI_RID_NODENAME
argument_list|,
name|sc
operator|->
name|wi_node_name
argument_list|)
expr_stmt|;
comment|/* Set our MAC address. */
name|mac
operator|.
name|wi_len
operator|=
literal|4
expr_stmt|;
name|mac
operator|.
name|wi_type
operator|=
name|WI_RID_MAC_NODE
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mac
operator|.
name|wi_mac_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|wi_write_record
argument_list|(
name|sc
argument_list|,
operator|(
expr|struct
name|wi_ltv_gen
operator|*
operator|)
operator|&
name|mac
argument_list|)
expr_stmt|;
comment|/* Initialize promisc mode. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|WI_SETVAL
argument_list|(
name|WI_RID_PROMISC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|WI_SETVAL
argument_list|(
name|WI_RID_PROMISC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Set multicast filter. */
name|wi_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable desired port */
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_ENABLE
operator||
name|sc
operator|->
name|wi_portnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_alloc_nicmem
argument_list|(
name|sc
argument_list|,
literal|1518
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
operator|+
literal|8
argument_list|,
operator|&
name|id
argument_list|)
condition|)
name|printf
argument_list|(
literal|"wi%d: tx buffer allocation failed\n"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_tx_data_id
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|wi_alloc_nicmem
argument_list|(
name|sc
argument_list|,
literal|1518
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
operator|+
literal|8
argument_list|,
operator|&
name|id
argument_list|)
condition|)
name|printf
argument_list|(
literal|"wi%d: mgmt. buffer allocation failed\n"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|wi_tx_mgmt_id
operator|=
name|id
expr_stmt|;
comment|/* enable interrupts */
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
name|WI_INTRS
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|sc
operator|->
name|wi_stat_ch
operator|=
name|timeout
argument_list|(
name|wi_inquire
argument_list|,
name|sc
argument_list|,
name|hz
operator|*
literal|60
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_start
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|wi_frame
name|tx_frame
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|id
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
return|return;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
return|return;
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
return|return;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_frame
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|sc
operator|->
name|wi_tx_data_id
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Use RFC1042 encoding for IP and ARP datagrams, 	 * 802.3 for anything else. 	 */
if|if
condition|(
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|==
name|ETHERTYPE_IP
operator|||
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|==
name|ETHERTYPE_ARP
operator|||
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
operator|==
name|ETHERTYPE_REVARP
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_addr1
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_addr2
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_dst_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_src_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_dat_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|WI_SNAPHDR_LEN
expr_stmt|;
name|tx_frame
operator|.
name|wi_frame_ctl
operator|=
name|WI_FTYPE_DATA
expr_stmt|;
name|tx_frame
operator|.
name|wi_dat
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
name|WI_SNAP_WORD0
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_dat
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|WI_SNAP_WORD1
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_len
operator|=
name|htons
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|WI_SNAPHDR_LEN
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_type
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
name|m_copydata
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|wi_txbuf
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tx_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_11_OFFSET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|wi_txbuf
argument_list|,
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tx_frame
operator|.
name|wi_dat_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_copydata
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|wi_txbuf
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tx_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_3_OFFSET
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sc
operator|->
name|wi_txbuf
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NBPF
operator|>
literal|0
comment|/* 	 * If there's a BPF listner, bounce a copy of 	 * this frame to him. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_TX
operator||
name|WI_RECLAIM
argument_list|,
name|id
argument_list|)
condition|)
name|printf
argument_list|(
literal|"wi%d: xmit failed\n"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
comment|/* 	 * Set a timeout in case the chip goes out to lunch. 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|5
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|wi_mgmt_xmit
parameter_list|(
name|sc
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|wi_frame
name|tx_frame
decl_stmt|;
name|int
name|id
decl_stmt|;
name|struct
name|wi_80211_hdr
modifier|*
name|hdr
decl_stmt|;
name|caddr_t
name|dptr
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|hdr
operator|=
operator|(
expr|struct
name|wi_80211_hdr
operator|*
operator|)
name|data
expr_stmt|;
name|dptr
operator|=
name|data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|wi_80211_hdr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_frame
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|sc
operator|->
name|wi_tx_mgmt_id
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tx_frame
operator|.
name|wi_frame_ctl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_80211_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|tx_frame
operator|.
name|wi_dat_len
operator|=
name|len
operator|-
name|WI_SNAPHDR_LEN
expr_stmt|;
name|tx_frame
operator|.
name|wi_len
operator|=
name|htons
argument_list|(
name|len
operator|-
name|WI_SNAPHDR_LEN
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tx_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wi_frame
argument_list|)
argument_list|)
expr_stmt|;
name|wi_write_data
argument_list|(
name|sc
argument_list|,
name|id
argument_list|,
name|WI_802_11_OFFSET_RAW
argument_list|,
name|dptr
argument_list|,
operator|(
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|wi_80211_hdr
argument_list|)
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_TX
operator||
name|WI_RECLAIM
argument_list|,
name|id
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"wi%d: xmit failed\n"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_stop
parameter_list|(
name|sc
parameter_list|)
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|wi_gone
condition|)
return|return;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|CSR_WRITE_2
argument_list|(
name|sc
argument_list|,
name|WI_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wi_cmd
argument_list|(
name|sc
argument_list|,
name|WI_CMD_DISABLE
operator||
name|sc
operator|->
name|wi_portnum
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|wi_inquire
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|wi_stat_ch
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_watchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|printf
argument_list|(
literal|"wi%d: device timeout\n"
argument_list|,
name|sc
operator|->
name|wi_unit
argument_list|)
expr_stmt|;
name|wi_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|wi_shutdown
parameter_list|(
name|arg
parameter_list|,
name|howto
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|howto
decl_stmt|;
block|{
name|struct
name|wi_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|wi_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

