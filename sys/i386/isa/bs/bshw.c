begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NecBSD: bshw.c,v 1.1 1997/07/18 09:19:03 kmatsuda Exp $	*/
end_comment

begin_comment
comment|/*	$NetBSD$	*/
end_comment

begin_comment
comment|/*  * [NetBSD for NEC PC98 series]  *  Copyright (c) 1994, 1995, 1996 NetBSD/pc98 porting staff.  *  All rights reserved.  *   *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  3. The name of the author may not be used to endorse or promote products  *     derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995, 1996 Naofumi HONDA.  All rights reserved.  *  * $FreeBSD$  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/isa/isadmareg.h>
end_include

begin_include
include|#
directive|include
file|<i386/Cbus/dev/bs/bsif.h>
end_include

begin_include
include|#
directive|include
file|<i386/Cbus/dev/bs/bshw.lst>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|"opt_pc98.h"
end_include

begin_include
include|#
directive|include
file|<i386/isa/ic/i8237.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/bs/bsif.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/bs/bshw.lst>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|bs_softc
modifier|*
name|gbsc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************  * DECLARATION  **************************************************/
end_comment

begin_decl_stmt
specifier|static
name|void
name|bshw_force_bsmode
name|__P
argument_list|(
operator|(
expr|struct
name|bs_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************  * STATIC VAL  **************************************************/
end_comment

begin_decl_stmt
specifier|static
name|int
name|irq_tbl
index|[]
init|=
block|{
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|9
block|,
literal|12
block|,
literal|13
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************  * SCSI CMD BRANCH  **************************************************/
end_comment

begin_define
define|#
directive|define
name|RS
value|(BSSAT | BSSMIT | BSLINK | BSREAD)
end_define

begin_define
define|#
directive|define
name|WS
value|(BSSAT | BSSMIT | BSLINK)
end_define

begin_define
define|#
directive|define
name|EOK
value|(BSERROROK)
end_define

begin_decl_stmt
name|u_int8_t
name|bshw_cmd
index|[
literal|256
index|]
init|=
block|{
comment|/*   0  1   2   3   4   5   6   7   8   9   A   B   C   E   D   F */
comment|/*0*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|RS
block|,
literal|0
block|,
name|WS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*1*/
literal|0
block|,
literal|0
block|,
name|EOK
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|EOK
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*2*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|RS
block|,
literal|0
block|,
name|WS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*3*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*4*/
literal|0
block|,
literal|0
block|,
name|EOK
block|,
name|EOK
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*5*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|EOK
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*6*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*7*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*8*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*9*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*A*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*B*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*C*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*D*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*E*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*F*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|RS
end_undef

begin_undef
undef|#
directive|undef
name|WS
end_undef

begin_undef
undef|#
directive|undef
name|EOK
end_undef

begin_comment
comment|/**********************************************  * init  **********************************************/
end_comment

begin_function
specifier|static
name|void
name|bshw_force_bsmode
parameter_list|(
name|bsc
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
block|{
if|if
condition|(
name|bsc
operator|->
name|sc_flags
operator|&
name|BSBSMODE
condition|)
return|return;
name|bsc
operator|->
name|sc_flags
operator||=
name|BSBSMODE
expr_stmt|;
comment|/* 	 * If you have memory over 16M, some stupid boards always force to 	 * use the io polling mode. Check such a case and change mode into 	 * bus master DMA. However this depends heavily on the board's 	 * specifications! 	 */
if|if
condition|(
name|bsc
operator|->
name|sc_hw
operator|->
name|dma_init
operator|&&
operator|(
call|(
modifier|*
name|bsc
operator|->
name|sc_hw
operator|->
name|dma_init
call|)
argument_list|(
name|bsc
argument_list|)
operator|)
condition|)
name|printf
argument_list|(
literal|"%s change mode using external DMA (%x)\n"
argument_list|,
name|bsc
operator|->
name|sc_dvname
argument_list|,
operator|(
name|u_int
operator|)
name|read_wd33c93
argument_list|(
name|bsc
argument_list|,
literal|0x37
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|RESET_DEFAULT
value|2000
end_define

begin_function
name|int
name|bshw_chip_reset
parameter_list|(
name|bsc
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
block|{
name|int
name|ct
decl_stmt|;
name|u_int8_t
name|aux
decl_stmt|;
name|bshw_lock
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|bshw_abort_cmd
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|bshw_get_auxstat
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|bshw_get_busstat
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_oid
argument_list|,
name|IDR_EHP
operator||
name|bsc
operator|->
name|sc_cspeed
operator||
name|bsc
operator|->
name|sc_hostid
argument_list|)
expr_stmt|;
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_cmd
argument_list|,
name|WD3S_RESET
argument_list|)
expr_stmt|;
for|for
control|(
name|ct
operator|=
name|RESET_DEFAULT
init|;
name|ct
operator|>
literal|0
condition|;
name|ct
operator|--
control|)
block|{
name|aux
operator|=
name|bshw_get_auxstat
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|aux
operator|!=
literal|0xff
operator|&&
operator|(
name|aux
operator|&
name|STR_INT
operator|)
condition|)
block|{
if|if
condition|(
name|bshw_get_busstat
argument_list|(
name|bsc
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_cmd
argument_list|,
name|WD3S_RESET
argument_list|)
expr_stmt|;
block|}
name|delay
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ct
operator|==
literal|0
condition|)
block|{
name|bshw_unlock
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
name|bshw_force_bsmode
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_tout
argument_list|,
name|BSHW_SEL_TIMEOUT
argument_list|)
expr_stmt|;
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_sid
argument_list|,
name|SIDR_RESEL
argument_list|)
expr_stmt|;
name|bsc
operator|->
name|sc_flags
operator||=
name|BSDMATRANSFER
expr_stmt|;
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_ctrl
argument_list|,
name|CR_DEFAULT
argument_list|)
expr_stmt|;
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_synch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bshw_get_auxstat
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|bsc
operator|->
name|sc_busstat
operator|=
name|bshw_get_busstat
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|bshw_unlock
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* scsi bus hard reset */
end_comment

begin_define
define|#
directive|define
name|TWIDDLEWAIT
value|10000
end_define

begin_decl_stmt
specifier|static
name|int
name|tw_pos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|tw_chars
index|[]
init|=
literal|"|/-\\"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* this is some jokes */
end_comment

begin_function
specifier|static
name|void
name|twiddle_wait
parameter_list|(
name|void
parameter_list|)
block|{
name|cnputc
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|cnputc
argument_list|(
name|tw_chars
index|[
name|tw_pos
operator|++
index|]
argument_list|)
expr_stmt|;
name|tw_pos
operator|%=
operator|(
sizeof|sizeof
argument_list|(
name|tw_chars
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|delay
argument_list|(
name|TWIDDLEWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|bshw_set_vsp
name|__P
argument_list|(
operator|(
expr|struct
name|bs_softc
operator|*
operator|,
name|u_int
operator|,
name|u_int8_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|bshw_set_vsp
parameter_list|(
name|bsc
parameter_list|,
name|chan
parameter_list|,
name|spva
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
name|u_int
name|chan
decl_stmt|;
name|u_int8_t
name|spva
decl_stmt|;
block|{
name|struct
name|bshw
modifier|*
name|hw
init|=
name|bsc
operator|->
name|sc_hw
decl_stmt|;
if|if
condition|(
name|hw
operator|->
name|sregaddr
operator|==
literal|0
condition|)
return|return;
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|hw
operator|->
name|sregaddr
operator|+
name|chan
argument_list|,
name|spva
argument_list|)
expr_stmt|;
if|if
condition|(
name|hw
operator|->
name|hw_flags
operator|&
name|BSHW_DOUBLE_DMACHAN
condition|)
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|hw
operator|->
name|sregaddr
operator|+
name|chan
operator|+
literal|8
argument_list|,
name|spva
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bshw_bus_reset
parameter_list|(
name|bsc
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
block|{
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lpc
decl_stmt|;
if|if
condition|(
name|bsc
operator|->
name|sc_RSTdelay
operator|==
literal|0
condition|)
name|bsc
operator|->
name|sc_RSTdelay
operator|=
literal|6
operator|*
literal|1000
operator|*
literal|1000
expr_stmt|;
else|else
block|{
comment|/* XXX: 		 * second time reset will be requested by hardware failuer. 		 */
name|bsc
operator|->
name|sc_RSTdelay
operator|=
literal|12
operator|*
literal|1000
operator|*
literal|1000
expr_stmt|;
block|}
name|bshw_lock
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_mbank
argument_list|,
operator|(
name|bsc
operator|->
name|sc_membank
operator||
name|MBR_RST
operator|)
operator|&
operator|~
name|MBR_IEN
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|500000
argument_list|)
expr_stmt|;
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_mbank
argument_list|,
operator|(
name|bsc
operator|->
name|sc_membank
operator|)
operator|&
operator|~
name|MBR_IEN
argument_list|)
expr_stmt|;
name|bshw_unlock
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
for|for
control|(
name|lpc
operator|=
literal|0
init|;
name|lpc
operator|<
literal|2
condition|;
name|lpc
operator|++
control|)
block|{
name|cnputc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|bsc
operator|->
name|sc_RSTdelay
operator|/
name|TWIDDLEWAIT
condition|;
name|i
operator|++
control|)
name|twiddle_wait
argument_list|()
expr_stmt|;
name|cnputc
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_auxc
argument_list|)
expr_stmt|;
name|delay
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|read_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_auxc
argument_list|)
operator|&
name|AUXCR_RRST
operator|)
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"\nreset state still continue, wait ..."
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTARGETS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ti
operator|=
name|bsc
operator|->
name|sc_ti
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ti
operator|->
name|ti_sync
operator|=
literal|0
expr_stmt|;
name|bshw_set_vsp
argument_list|(
name|bsc
argument_list|,
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* probe */
end_comment

begin_function
name|int
name|bshw_board_probe
parameter_list|(
name|bsc
parameter_list|,
name|drq
parameter_list|,
name|irq
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
name|u_int
modifier|*
name|drq
decl_stmt|;
name|u_int
modifier|*
name|irq
decl_stmt|;
block|{
name|gbsc
operator|=
name|bsc
expr_stmt|;
ifdef|#
directive|ifdef
name|SHOW_PORT
name|bshw_print_port
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SHOW_PORT */
name|bsc
operator|->
name|sc_hostid
operator|=
operator|(
name|read_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_auxc
argument_list|)
operator|&
name|AUXCR_HIDM
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|irq
operator|)
operator|==
name|IRQUNK
condition|)
operator|*
name|irq
operator|=
name|irq_tbl
index|[
operator|(
name|read_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_auxc
argument_list|)
operator|>>
literal|3
operator|)
operator|&
literal|7
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|drq
operator|)
operator|==
name|DRQUNK
condition|)
operator|*
name|drq
operator|=
name|BUS_IOR
argument_list|(
name|cmd_port
argument_list|)
operator|&
literal|3
expr_stmt|;
name|bsc
operator|->
name|sc_dmachan
operator|=
operator|*
name|drq
expr_stmt|;
name|bsc
operator|->
name|sc_irq
operator|=
operator|(
operator|*
name|irq
operator|)
expr_stmt|;
name|bsc
operator|->
name|sc_membank
operator|=
name|read_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_mbank
argument_list|)
expr_stmt|;
name|bsc
operator|->
name|sc_membank
operator|&=
operator|~
name|MBR_RST
expr_stmt|;
name|bsc
operator|->
name|sc_membank
operator||=
name|MBR_IEN
expr_stmt|;
name|bsc
operator|->
name|sc_cspeed
operator|=
operator|(
name|read_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_oid
argument_list|)
operator|&
operator|(
operator|~
name|IDR_IDM
operator|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|BSC_CHIP_CLOCK
argument_list|(
name|bsc
operator|->
name|sc_cfgflags
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|bsc
operator|->
name|sc_cspeed
operator|&=
operator|~
operator|(
name|IDR_FS_12_15
operator||
name|IDR_FS_16_20
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bsc
operator|->
name|sc_cspeed
operator|&=
operator|~
operator|(
name|IDR_FS_12_15
operator||
name|IDR_FS_16_20
operator|)
expr_stmt|;
name|bsc
operator|->
name|sc_cspeed
operator||=
name|IDR_FS_12_15
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|bsc
operator|->
name|sc_cspeed
operator|&=
operator|~
operator|(
name|IDR_FS_12_15
operator||
name|IDR_FS_16_20
operator|)
expr_stmt|;
name|bsc
operator|->
name|sc_cspeed
operator||=
name|IDR_FS_16_20
expr_stmt|;
break|break;
block|}
comment|/* XXX: host id fixed(7) */
name|bsc
operator|->
name|sc_hostid
operator|=
literal|7
expr_stmt|;
if|if
condition|(
name|bshw_chip_reset
argument_list|(
name|bsc
argument_list|)
condition|)
return|return
name|ENXIO
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * XXX:  * Assume the board clock rate must be 20Mhz (always satisfied, maybe)!  * Only 10M/s 6.6M/s 5.0M/s 3.3M/s for synchronus transfer speed set.  */
end_comment

begin_define
define|#
directive|define
name|ILLEGAL_SYNCH
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ILLEGAL_SYNCH
end_ifdef

begin_comment
comment|/*  A  10    6.6   5.0   4.0   3.3   2.8   2.5   2.0  M/s */
end_comment

begin_comment
comment|/*  X  100   150   200   250   300   350   400   500  ns  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|bshw_scsi_period
index|[]
init|=
block|{
literal|0
block|,
literal|25
block|,
literal|37
block|,
literal|50
block|,
literal|62
block|,
literal|75
block|,
literal|87
block|,
literal|100
block|,
literal|125
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|bshw_chip_pval
index|[]
init|=
block|{
literal|0
block|,
literal|0xa0
block|,
literal|0xb0
block|,
literal|0x20
block|,
literal|0xd0
block|,
literal|0x30
block|,
literal|0xf0
block|,
literal|0x40
block|,
literal|0x50
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !ILLEGAL_SYNCH */
end_comment

begin_comment
comment|/*  A  10    6.6   5.0   3.3   2.5 M/s */
end_comment

begin_comment
comment|/*  X  100   150   200   300   400 ns  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|bshw_scsi_period
index|[]
init|=
block|{
literal|0
block|,
literal|25
block|,
literal|37
block|,
literal|50
block|,
literal|75
block|,
literal|100
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|bshw_chip_pval
index|[]
init|=
block|{
literal|0
block|,
literal|0xa0
block|,
literal|0xb0
block|,
literal|0x20
block|,
literal|0x30
block|,
literal|0x40
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !ILLEGAL_SYNCH */
end_comment

begin_function
name|void
name|bshw_adj_syncdata
parameter_list|(
name|sdp
parameter_list|)
name|struct
name|syncdata
modifier|*
name|sdp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sdp
operator|->
name|offset
operator|==
literal|0
operator|||
name|sdp
operator|->
name|period
operator|<
literal|25
operator|||
name|sdp
operator|->
name|period
operator|>
literal|100
condition|)
name|sdp
operator|->
name|offset
operator|=
name|sdp
operator|->
name|period
operator|=
literal|0
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sdp
operator|->
name|period
operator|>
name|bshw_scsi_period
index|[
name|i
index|]
operator|+
literal|2
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|sdp
operator|->
name|period
operator|=
name|bshw_scsi_period
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bshw_set_synchronous
parameter_list|(
name|bsc
parameter_list|,
name|ti
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|syncdata
name|sd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sd
operator|=
name|ti
operator|->
name|ti_syncnow
expr_stmt|;
name|bshw_adj_syncdata
argument_list|(
operator|&
name|sd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|sd
operator|.
name|period
operator|!=
name|bshw_scsi_period
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|ti
operator|->
name|ti_sync
operator|=
operator|(
operator|(
name|sd
operator|.
name|offset
operator|&
literal|0x0f
operator|)
operator||
name|bshw_chip_pval
index|[
name|i
index|]
operator|)
expr_stmt|;
name|bshw_set_vsp
argument_list|(
name|bsc
argument_list|,
name|ti
operator|->
name|ti_id
argument_list|,
name|ti
operator|->
name|ti_sync
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsc
operator|->
name|sc_nexus
operator|==
name|ti
condition|)
name|bshw_set_sync_reg
argument_list|(
name|bsc
argument_list|,
name|ti
operator|->
name|ti_sync
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ctrl reg */
end_comment

begin_function
name|void
name|bshw_setup_ctrl_reg
parameter_list|(
name|bsc
parameter_list|,
name|flags
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|u_int8_t
name|regval
decl_stmt|;
name|regval
operator|=
operator|(
name|flags
operator|&
name|BS_SCSI_NOPARITY
operator|)
condition|?
name|CR_DEFAULT
else|:
name|CR_DEFAULT_HP
expr_stmt|;
if|if
condition|(
name|bsc
operator|->
name|sc_flags
operator|&
name|BSDMATRANSFER
condition|)
name|regval
operator||=
name|CR_DMA
expr_stmt|;
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_ctrl
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sat command */
end_comment

begin_function
name|void
name|bshw_issue_satcmd
parameter_list|(
name|bsc
parameter_list|,
name|cb
parameter_list|,
name|link
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
name|struct
name|bsccb
modifier|*
name|cb
decl_stmt|;
name|int
name|link
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|BUS_IOW
argument_list|(
name|addr_port
argument_list|,
name|wd3s_cdb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cb
operator|->
name|cmdlen
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|BUS_IOW
argument_list|(
name|ctrl_port
argument_list|,
name|cb
operator|->
name|cmd
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|BUS_IOW
argument_list|(
name|ctrl_port
argument_list|,
name|cb
operator|->
name|cmd
index|[
name|i
index|]
operator||
operator|(
name|link
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* lock */
end_comment

begin_function
name|void
name|bshw_lock
parameter_list|(
name|bsc
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
block|{
name|bsc
operator|->
name|sc_hwlock
operator|++
expr_stmt|;
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_mbank
argument_list|,
name|bsc
operator|->
name|sc_membank
operator|&
operator|(
operator|~
name|MBR_IEN
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bshw_unlock
parameter_list|(
name|bsc
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|--
name|bsc
operator|->
name|sc_hwlock
operator|)
operator|<=
literal|0
condition|)
name|write_wd33c93
argument_list|(
name|bsc
argument_list|,
name|wd3s_mbank
argument_list|,
name|bsc
operator|->
name|sc_membank
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************  * DMA OPERATIONS  **********************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<i386/Cbus/dev/bs/bshw_dma.c>
end_include

begin_include
include|#
directive|include
file|<i386/Cbus/dev/bs/bshw_pdma.c>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<i386/isa/bs/bshw_dma.c>
end_include

begin_include
include|#
directive|include
file|<i386/isa/bs/bshw_pdma.c>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**********************************************  * DEBUG  **********************************************/
end_comment

begin_comment
comment|/* misc */
end_comment

begin_function
name|void
name|bshw_print_port
parameter_list|(
name|bsc
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|port
init|=
literal|0x0
decl_stmt|;
if|if
condition|(
name|bsc
operator|==
name|NULL
condition|)
name|bsc
operator|=
name|gbsc
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
literal|0x70
condition|;
name|j
operator|+=
literal|0x10
control|)
block|{
name|printf
argument_list|(
literal|"port %x: "
argument_list|,
name|port
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x10
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x "
argument_list|,
operator|(
name|u_int
operator|)
name|read_wd33c93
argument_list|(
name|bsc
argument_list|,
name|port
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

