begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD$	*/
end_comment

begin_comment
comment|/*  * [NetBSD for NEC PC98 series]  *  Copyright (c) 1994, 1995, 1996 NetBSD/pc98 porting staff.  *  All rights reserved.  *   *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions  *  are met:  *  1. Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  2. Redistributions in binary form must reproduce the above copyright  *     notice, this list of conditions and the following disclaimer in the  *     documentation and/or other materials provided with the distribution.  *  3. The name of the author may not be used to endorse or promote products  *     derived from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995, 1996 Naofumi HONDA.  All rights reserved.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__NetBSD__
end_ifdef

begin_include
include|#
directive|include
file|<dev/isa/bs/bsif.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<i386/isa/bs/bsif.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BS_STATICS
end_ifdef

begin_decl_stmt
name|struct
name|bs_statics
name|bs_statics
index|[
name|NTARGETS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|bs_linkcmd_count
index|[
name|NTARGETS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|bs_bounce_used
index|[
name|NTARGETS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BS_STATICS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BS_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|bs_debug_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BS_DEBUG */
end_comment

begin_decl_stmt
specifier|static
name|void
name|bs_print_syncmsg
name|__P
argument_list|(
operator|(
expr|struct
name|targ_info
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bs_timeout_target
name|__P
argument_list|(
operator|(
expr|struct
name|targ_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bs_kill_msg
name|__P
argument_list|(
operator|(
expr|struct
name|ccb
operator|*
name|cb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bs_start_target
name|__P
argument_list|(
operator|(
expr|struct
name|targ_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bs_check_target
name|__P
argument_list|(
operator|(
expr|struct
name|targ_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*************************************************************  * CCB  ************************************************************/
end_comment

begin_macro
name|GENERIC_CCB_STATIC_ALLOC
argument_list|(
argument|bs
argument_list|,
argument|ccb
argument_list|)
end_macro

begin_macro
name|GENERIC_CCB
argument_list|(
argument|bs
argument_list|,
argument|ccb
argument_list|,
argument|ccb_chain
argument_list|)
end_macro

begin_comment
comment|/*************************************************************  * TIMEOUT  ************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bs_timeout_target
parameter_list|(
name|ti
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|bs_softc
modifier|*
name|bsc
init|=
name|ti
operator|->
name|ti_bsc
decl_stmt|;
name|ti
operator|->
name|ti_error
operator||=
name|BSTIMEOUT
expr_stmt|;
name|bsc
operator|->
name|sc_flags
operator||=
name|BSRESET
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_herrcnt
operator|++
operator|>=
name|HARDRETRIES
condition|)
block|{
name|bs_printf
argument_list|(
name|ti
argument_list|,
literal|"timeout"
argument_list|,
literal|"async transfer!"
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_syncmax
operator|.
name|period
operator|=
name|ti
operator|->
name|ti_syncmax
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bstimeout
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|bs_softc
modifier|*
name|bsc
init|=
operator|(
expr|struct
name|bs_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|struct
name|ccb
modifier|*
name|cb
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bsc
operator|->
name|sc_flags
operator|&=
operator|~
name|BSSTARTTIMEOUT
expr_stmt|;
comment|/* check */
if|if
condition|(
operator|(
name|ti
operator|=
name|bsc
operator|->
name|sc_nexus
operator|)
operator|&&
operator|(
name|cb
operator|=
name|ti
operator|->
name|ti_ctab
operator|.
name|tqh_first
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|cb
operator|->
name|tc
operator|-=
name|BS_TIMEOUT_CHECK_INTERVAL
operator|)
operator|<
literal|0
condition|)
name|bs_timeout_target
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|ti
operator|=
name|bsc
operator|->
name|sc_titab
operator|.
name|tqh_first
init|;
name|ti
condition|;
name|ti
operator|=
name|ti
operator|->
name|ti_tchain
operator|.
name|tqe_next
control|)
block|{
if|if
condition|(
name|bsc
operator|->
name|sc_dtgnum
operator|&&
name|ti
operator|->
name|ti_phase
operator|<
name|DISCONNECTED
condition|)
continue|continue;
name|cb
operator|=
name|ti
operator|->
name|ti_ctab
operator|.
name|tqh_first
expr_stmt|;
if|if
condition|(
name|cb
operator|&&
operator|(
operator|(
name|cb
operator|->
name|tc
operator|-=
name|BS_TIMEOUT_CHECK_INTERVAL
operator|)
operator|<
literal|0
operator|)
condition|)
name|bs_timeout_target
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
comment|/* try to recover */
if|if
condition|(
name|bsc
operator|->
name|sc_flags
operator|&
name|BSRESET
condition|)
block|{
name|bs_debug_print_all
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|bs_printf
argument_list|(
name|ti
argument_list|,
literal|"timeout"
argument_list|,
literal|"bus hang up"
argument_list|)
expr_stmt|;
name|bs_reset_nexus
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
block|}
name|bs_start_timeout
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************  * MAKE CCB& MSG CCB  *************************************************/
end_comment

begin_decl_stmt
specifier|static
name|u_int8_t
name|cmd_unit_ready
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|ccb
modifier|*
name|bs_make_internal_ccb
parameter_list|(
name|ti
parameter_list|,
name|lun
parameter_list|,
name|cmd
parameter_list|,
name|cmdlen
parameter_list|,
name|data
parameter_list|,
name|datalen
parameter_list|,
name|flags
parameter_list|,
name|timeout
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|u_int
name|lun
decl_stmt|;
name|u_int8_t
modifier|*
name|cmd
decl_stmt|;
name|u_int
name|cmdlen
decl_stmt|;
name|u_int8_t
modifier|*
name|data
decl_stmt|;
name|u_int
name|datalen
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
name|struct
name|ccb
modifier|*
name|cb
decl_stmt|;
if|if
condition|(
operator|(
name|cb
operator|=
name|bs_get_ccb
argument_list|(
name|XSBS_SCSI_NOSLEEP
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|bs_panic
argument_list|(
name|ti
operator|->
name|ti_bsc
argument_list|,
literal|"can not get ccb mem"
argument_list|)
expr_stmt|;
name|cb
operator|->
name|xs
operator|=
name|NULL
expr_stmt|;
name|cb
operator|->
name|lun
operator|=
name|lun
expr_stmt|;
name|cb
operator|->
name|cmd
operator|=
operator|(
name|cmd
condition|?
name|cmd
else|:
name|cmd_unit_ready
operator|)
expr_stmt|;
name|cb
operator|->
name|cmdlen
operator|=
operator|(
name|cmd
condition|?
name|cmdlen
else|:
sizeof|sizeof
argument_list|(
name|cmd_unit_ready
argument_list|)
operator|)
expr_stmt|;
name|cb
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|cb
operator|->
name|datalen
operator|=
operator|(
name|data
condition|?
name|datalen
else|:
literal|0
operator|)
expr_stmt|;
name|cb
operator|->
name|msgoutlen
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|flags
operator|=
name|flags
operator|&
name|BSCFLAGSMASK
expr_stmt|;
name|bs_targ_flags
argument_list|(
name|ti
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|cb
operator|->
name|rcnt
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|tcmax
operator|=
operator|(
name|timeout
operator|>
name|BS_DEFAULT_TIMEOUT_SECOND
condition|?
name|timeout
else|:
name|BS_DEFAULT_TIMEOUT_SECOND
operator|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ti
operator|->
name|ti_ctab
argument_list|,
name|cb
argument_list|,
name|ccb_chain
argument_list|)
expr_stmt|;
return|return
name|cb
return|;
block|}
end_function

begin_function
name|struct
name|ccb
modifier|*
name|bs_make_msg_ccb
parameter_list|(
name|ti
parameter_list|,
name|lun
parameter_list|,
name|cb
parameter_list|,
name|msg
parameter_list|,
name|timex
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|u_int
name|lun
decl_stmt|;
name|struct
name|ccb
modifier|*
name|cb
decl_stmt|;
name|struct
name|msgbase
modifier|*
name|msg
decl_stmt|;
name|u_int
name|timex
decl_stmt|;
block|{
name|u_int
name|flags
decl_stmt|;
name|flags
operator|=
name|BSFORCEIOPOLL
operator||
name|msg
operator|->
name|flag
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
name|cb
operator|=
name|bs_make_internal_ccb
argument_list|(
name|ti
argument_list|,
name|lun
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|,
name|timex
argument_list|)
expr_stmt|;
else|else
name|cb
operator|->
name|flags
operator||=
name|flags
operator|&
name|BSCFLAGSMASK
expr_stmt|;
name|cb
operator|->
name|msgoutlen
operator|=
name|msg
operator|->
name|msglen
expr_stmt|;
name|bcopy
argument_list|(
name|msg
operator|->
name|msg
argument_list|,
name|cb
operator|->
name|msgout
argument_list|,
name|msg
operator|->
name|msglen
argument_list|)
expr_stmt|;
return|return
name|cb
return|;
block|}
end_function

begin_function
name|int
name|bs_send_msg
parameter_list|(
name|ti
parameter_list|,
name|lun
parameter_list|,
name|msg
parameter_list|,
name|timex
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|u_int
name|lun
decl_stmt|;
name|struct
name|msgbase
modifier|*
name|msg
decl_stmt|;
name|int
name|timex
decl_stmt|;
block|{
name|struct
name|ccb
modifier|*
name|cb
decl_stmt|;
name|cb
operator|=
name|bs_make_msg_ccb
argument_list|(
name|ti
argument_list|,
name|lun
argument_list|,
name|NULL
argument_list|,
name|msg
argument_list|,
name|timex
argument_list|)
expr_stmt|;
name|bscmdstart
argument_list|(
name|ti
argument_list|,
name|BSCMDSTART
argument_list|)
expr_stmt|;
return|return
name|bs_scsi_cmd_poll
argument_list|(
name|ti
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bs_kill_msg
parameter_list|(
name|cb
parameter_list|)
name|struct
name|ccb
modifier|*
name|cb
decl_stmt|;
block|{
name|cb
operator|->
name|msgoutlen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************  * MAKE SENSE CCB  **************************************************/
end_comment

begin_function
name|struct
name|ccb
modifier|*
name|bs_request_sense
parameter_list|(
name|ti
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|ccb
modifier|*
name|cb
decl_stmt|;
name|bzero
argument_list|(
name|ti
operator|->
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ti
operator|->
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|scsi_cmd
index|[
literal|0
index|]
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|ti
operator|->
name|scsi_cmd
index|[
literal|1
index|]
operator|=
operator|(
name|ti
operator|->
name|ti_lun
operator|<<
literal|5
operator|)
expr_stmt|;
name|ti
operator|->
name|scsi_cmd
index|[
literal|4
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|cb
operator|=
name|bs_make_internal_ccb
argument_list|(
name|ti
argument_list|,
name|ti
operator|->
name|ti_lun
argument_list|,
name|ti
operator|->
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense
argument_list|)
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|ti
operator|->
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
argument_list|,
name|BSFORCEIOPOLL
argument_list|,
name|BS_DEFAULT_TIMEOUT_SECOND
argument_list|)
expr_stmt|;
name|cb
operator|->
name|flags
operator||=
name|BSSENSECCB
expr_stmt|;
return|return
name|cb
return|;
block|}
end_function

begin_comment
comment|/**************************************************  * SYNC MSG  *************************************************/
end_comment

begin_comment
comment|/* sync neg */
end_comment

begin_function
name|int
name|bs_start_syncmsg
parameter_list|(
name|ti
parameter_list|,
name|cb
parameter_list|,
name|flag
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|struct
name|ccb
modifier|*
name|cb
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|syncdata
modifier|*
name|negp
decl_stmt|,
modifier|*
name|maxp
decl_stmt|;
name|struct
name|msgbase
name|msg
decl_stmt|;
name|u_int
name|lun
decl_stmt|;
name|negp
operator|=
operator|&
name|ti
operator|->
name|ti_syncnow
expr_stmt|;
name|maxp
operator|=
operator|&
name|ti
operator|->
name|ti_syncmax
expr_stmt|;
name|ti
operator|->
name|ti_state
operator|=
name|BS_TARG_SYNCH
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|BS_SYNCMSG_REQUESTED
condition|)
block|{
if|if
condition|(
name|negp
operator|->
name|offset
operator|>
name|maxp
operator|->
name|offset
condition|)
name|negp
operator|->
name|offset
operator|=
name|maxp
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|negp
operator|->
name|offset
operator|!=
literal|0
operator|&&
name|negp
operator|->
name|period
operator|<
name|maxp
operator|->
name|period
condition|)
name|negp
operator|->
name|period
operator|=
name|maxp
operator|->
name|period
expr_stmt|;
name|msg
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
name|lun
operator|=
name|ti
operator|->
name|ti_lun
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
name|cb
operator|=
name|ti
operator|->
name|ti_ctab
operator|.
name|tqh_first
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ti
operator|->
name|ti_cfgflags
operator|&
name|BS_SCSI_SYNC
condition|)
block|{
name|negp
operator|->
name|offset
operator|=
name|maxp
operator|->
name|offset
expr_stmt|;
name|negp
operator|->
name|period
operator|=
name|maxp
operator|->
name|period
expr_stmt|;
name|msg
operator|.
name|flag
operator|=
name|BSERROROK
expr_stmt|;
name|lun
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ti
operator|->
name|ti_state
operator|=
name|BS_TARG_RDY
expr_stmt|;
return|return
name|COMPLETE
return|;
block|}
name|BS_SETUP_SYNCSTATE
argument_list|(
name|flag
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg
index|[
literal|0
index|]
operator|=
name|MSG_EXTEND
expr_stmt|;
name|msg
operator|.
name|msg
index|[
literal|1
index|]
operator|=
name|MSG_EXTEND_SYNCHLEN
expr_stmt|;
name|msg
operator|.
name|msg
index|[
literal|2
index|]
operator|=
name|MSG_EXTEND_SYNCHCODE
expr_stmt|;
name|msg
operator|.
name|msg
index|[
literal|3
index|]
operator|=
name|negp
operator|->
name|period
expr_stmt|;
name|msg
operator|.
name|msg
index|[
literal|4
index|]
operator|=
name|negp
operator|->
name|offset
expr_stmt|;
name|msg
operator|.
name|msglen
operator|=
name|MSG_EXTEND_SYNCHLEN
operator|+
literal|2
expr_stmt|;
name|bs_make_msg_ccb
argument_list|(
name|ti
argument_list|,
name|lun
argument_list|,
name|cb
argument_list|,
operator|&
name|msg
argument_list|,
name|BS_SYNC_TIMEOUT
argument_list|)
expr_stmt|;
return|return
name|COMPLETE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bs_print_syncmsg
parameter_list|(
name|ti
parameter_list|,
name|s
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|struct
name|bs_softc
modifier|*
name|bsc
init|=
name|ti
operator|->
name|ti_bsc
decl_stmt|;
name|struct
name|syncdata
modifier|*
name|negp
decl_stmt|;
name|u_int
name|speed
decl_stmt|;
name|negp
operator|=
operator|&
name|ti
operator|->
name|ti_syncnow
expr_stmt|;
name|speed
operator|=
operator|(
name|negp
operator|->
name|offset
operator|&&
name|negp
operator|->
name|period
operator|)
condition|?
operator|(
literal|2500
operator|/
operator|(
operator|(
name|u_int
operator|)
name|negp
operator|->
name|period
operator|)
operator|)
else|:
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s(%d:%d):<%s> "
argument_list|,
name|bsc
operator|->
name|sc_dvname
argument_list|,
name|ti
operator|->
name|ti_id
argument_list|,
name|ti
operator|->
name|ti_lun
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"period 0x%x offset %d chip (0x%x)"
argument_list|,
name|negp
operator|->
name|period
argument_list|,
name|negp
operator|->
name|offset
argument_list|,
name|ti
operator|->
name|ti_sync
argument_list|)
expr_stmt|;
if|if
condition|(
name|speed
condition|)
name|printf
argument_list|(
literal|" %d.%d M/s"
argument_list|,
name|speed
operator|/
literal|10
argument_list|,
name|speed
operator|%
literal|10
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bs_analyze_syncmsg
parameter_list|(
name|ti
parameter_list|,
name|cb
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|struct
name|ccb
modifier|*
name|cb
decl_stmt|;
block|{
name|struct
name|bs_softc
modifier|*
name|bsc
init|=
name|ti
operator|->
name|ti_bsc
decl_stmt|;
name|u_int8_t
name|ans
init|=
name|ti
operator|->
name|ti_syncnow
operator|.
name|state
decl_stmt|;
name|struct
name|syncdata
modifier|*
name|negp
decl_stmt|,
modifier|*
name|maxp
decl_stmt|;
name|struct
name|syncdata
name|bdata
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|u_int8_t
name|period
decl_stmt|;
name|negp
operator|=
operator|&
name|ti
operator|->
name|ti_syncnow
expr_stmt|;
name|bdata
operator|=
operator|*
name|negp
expr_stmt|;
name|maxp
operator|=
operator|&
name|ti
operator|->
name|ti_syncmax
expr_stmt|;
switch|switch
condition|(
name|ans
condition|)
block|{
case|case
name|BS_SYNCMSG_REJECT
case|:
name|period
operator|=
literal|0
expr_stmt|;
name|s
operator|=
literal|"msg reject"
expr_stmt|;
break|break;
case|case
name|BS_SYNCMSG_ASSERT
case|:
name|period
operator|=
literal|0
expr_stmt|;
name|s
operator|=
literal|"no msg"
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|negp
operator|->
name|offset
operator|!=
literal|0
operator|&&
name|negp
operator|->
name|period
operator|<
name|maxp
operator|->
name|period
condition|)
block|{
name|period
operator|=
literal|0xff
expr_stmt|;
name|s
operator|=
literal|"illegal(period)"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|negp
operator|->
name|offset
operator|>
name|maxp
operator|->
name|offset
condition|)
block|{
name|period
operator|=
literal|0xff
expr_stmt|;
name|s
operator|=
literal|"illegal(offset)"
expr_stmt|;
block|}
else|else
name|period
operator|=
name|negp
operator|->
name|offset
condition|?
name|negp
operator|->
name|period
else|:
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|bshw_adj_syncdata
argument_list|(
name|negp
argument_list|)
expr_stmt|;
operator|*
name|maxp
operator|=
operator|*
name|negp
expr_stmt|;
if|if
condition|(
name|ans
operator|==
name|BS_SYNCMSG_REQUESTED
condition|)
name|s
operator|=
literal|"requested"
expr_stmt|;
else|else
name|s
operator|=
name|negp
operator|->
name|offset
condition|?
literal|"synchronous"
else|:
literal|"async"
expr_stmt|;
block|}
else|else
block|{
name|negp
operator|->
name|offset
operator|=
name|maxp
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|bshw_adj_syncdata
argument_list|(
name|negp
argument_list|)
expr_stmt|;
name|bshw_adj_syncdata
argument_list|(
name|maxp
argument_list|)
expr_stmt|;
block|}
comment|/* really setup hardware */
name|bshw_set_synchronous
argument_list|(
name|bsc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
operator|||
operator|(
name|period
operator|>=
name|negp
operator|->
name|period
operator|&&
name|period
operator|<=
name|negp
operator|->
name|period
operator|+
literal|2
operator|)
condition|)
block|{
name|bs_print_syncmsg
argument_list|(
name|ti
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|BS_SETUP_TARGSTATE
argument_list|(
name|BS_TARG_RDY
argument_list|)
expr_stmt|;
name|BS_SETUP_SYNCSTATE
argument_list|(
name|BS_SYNCMSG_NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
condition|)
name|bs_kill_msg
argument_list|(
name|cb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|bs_printf
argument_list|(
name|ti
argument_list|,
literal|"bs_analyze_syncmsg"
argument_list|,
literal|"sync(period) mismatch, retry neg..."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"expect(%d:0x%x) => reply(%d:0x%x)\n"
argument_list|,
name|bdata
operator|.
name|offset
argument_list|,
name|bdata
operator|.
name|period
argument_list|,
name|negp
operator|->
name|offset
argument_list|,
name|negp
operator|->
name|period
argument_list|)
expr_stmt|;
name|bs_start_syncmsg
argument_list|(
name|ti
argument_list|,
name|cb
argument_list|,
name|BS_SYNCMSG_ASSERT
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_comment
comment|/**************************************************  * ABORT AND RESET MSG  **************************************************/
end_comment

begin_comment
comment|/* send device reset msg and wait */
end_comment

begin_function
name|void
name|bs_reset_device
parameter_list|(
name|ti
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|msgbase
name|msg
decl_stmt|;
name|msg
operator|.
name|msglen
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|msg
index|[
literal|0
index|]
operator|=
name|MSG_RESET
expr_stmt|;
name|msg
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
name|bs_send_msg
argument_list|(
name|ti
argument_list|,
literal|0
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|ti
operator|->
name|ti_bsc
operator|->
name|sc_RSTdelay
argument_list|)
expr_stmt|;
name|bs_check_target
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* send abort msg */
end_comment

begin_function
name|struct
name|ccb
modifier|*
name|bs_force_abort
parameter_list|(
name|ti
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|bs_softc
modifier|*
name|bsc
init|=
name|ti
operator|->
name|ti_bsc
decl_stmt|;
name|struct
name|msgbase
name|msg
decl_stmt|;
name|struct
name|ccb
modifier|*
name|cb
init|=
name|ti
operator|->
name|ti_ctab
operator|.
name|tqh_first
decl_stmt|;
name|u_int
name|lun
decl_stmt|;
if|if
condition|(
name|cb
condition|)
block|{
name|lun
operator|=
name|cb
operator|->
name|lun
expr_stmt|;
name|cb
operator|->
name|rcnt
operator|++
expr_stmt|;
block|}
else|else
name|lun
operator|=
literal|0
expr_stmt|;
name|msg
operator|.
name|msglen
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|msg
index|[
literal|0
index|]
operator|=
name|MSG_ABORT
expr_stmt|;
name|msg
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
name|cb
operator|=
name|bs_make_msg_ccb
argument_list|(
name|ti
argument_list|,
name|lun
argument_list|,
name|NULL
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bscmdstart
argument_list|(
name|ti
argument_list|,
name|BSCMDSTART
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsc
operator|->
name|sc_nexus
operator|==
name|ti
condition|)
name|BS_LOAD_SDP
return|return
name|cb
return|;
block|}
end_function

begin_comment
comment|/**************************************************  * COMPLETE SCSI BUS RESET  *************************************************/
end_comment

begin_comment
comment|/*  * XXX:  * 1) reset scsi bus (ie. all target reseted).  * 2) chip reset.  * 3) check target status.  * 4) sync neg with all targets.  * 5) setup sync reg in host.  * 6) recover previous nexus.  */
end_comment

begin_function
name|void
name|bs_scsibus_start
parameter_list|(
name|bsc
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
block|{
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|,
modifier|*
name|nextti
init|=
name|NULL
decl_stmt|;
name|struct
name|ccb
modifier|*
name|cb
decl_stmt|;
name|int
name|error
init|=
name|HASERROR
decl_stmt|;
name|u_int
name|querm
decl_stmt|,
name|bits
decl_stmt|,
name|skip
init|=
literal|0
decl_stmt|;
name|querm
operator|=
operator|(
name|bsc
operator|->
name|sc_hstate
operator|==
name|BSC_BOOTUP
operator|)
expr_stmt|;
name|bsc
operator|->
name|sc_hstate
operator|=
name|BSC_TARG_CHECK
expr_stmt|;
comment|/* target check */
do|do
block|{
if|if
condition|(
name|error
operator|!=
name|COMPLETE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: scsi bus reset and try to restart ..."
argument_list|,
name|bsc
operator|->
name|sc_dvname
argument_list|)
expr_stmt|;
name|bshw_smitabort
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|bshw_dmaabort
argument_list|(
name|bsc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bshw_chip_reset
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|bshw_bus_reset
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|bshw_chip_reset
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" done. scsi bus ready.\n"
argument_list|)
expr_stmt|;
name|nextti
operator|=
name|bsc
operator|->
name|sc_titab
operator|.
name|tqh_first
expr_stmt|;
name|error
operator|=
name|COMPLETE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ti
operator|=
name|nextti
operator|)
operator|==
name|NULL
condition|)
break|break;
name|nextti
operator|=
name|ti
operator|->
name|ti_tchain
operator|.
name|tqe_next
expr_stmt|;
name|bits
operator|=
operator|(
literal|1
operator|<<
name|ti
operator|->
name|ti_id
operator|)
expr_stmt|;
if|if
condition|(
name|skip
operator|&
name|bits
condition|)
continue|continue;
if|if
condition|(
operator|(
name|error
operator|=
name|bs_check_target
argument_list|(
name|ti
argument_list|)
operator|)
operator|!=
name|COMPLETE
condition|)
block|{
if|if
condition|(
name|querm
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bsc
operator|->
name|sc_titab
argument_list|,
name|ti
argument_list|,
name|ti_tchain
argument_list|)
expr_stmt|;
name|bsc
operator|->
name|sc_openf
operator|&=
operator|~
name|bits
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|NOTARGET
condition|)
name|error
operator|=
name|COMPLETE
expr_stmt|;
name|skip
operator||=
name|bits
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* ok now ready */
name|bsc
operator|->
name|sc_hstate
operator|=
name|BSC_RDY
expr_stmt|;
comment|/* recover */
for|for
control|(
name|ti
operator|=
name|bsc
operator|->
name|sc_titab
operator|.
name|tqh_first
init|;
name|ti
condition|;
name|ti
operator|=
name|ti
operator|->
name|ti_tchain
operator|.
name|tqe_next
control|)
block|{
name|ti
operator|->
name|ti_ctab
operator|=
name|ti
operator|->
name|ti_bctab
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ti
operator|->
name|ti_bctab
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_ctab
operator|.
name|tqh_first
condition|)
name|bscmdstart
argument_list|(
name|ti
argument_list|,
name|BSCMDSTART
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bs_reset_nexus
parameter_list|(
name|bsc
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
block|{
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|struct
name|ccb
modifier|*
name|cb
decl_stmt|;
name|bsc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|BSRESET
operator||
name|BSUNDERRESET
operator|)
expr_stmt|;
if|if
condition|(
name|bsc
operator|->
name|sc_poll
condition|)
block|{
name|bsc
operator|->
name|sc_flags
operator||=
name|BSUNDERRESET
expr_stmt|;
return|return;
block|}
comment|/* host state clear */
name|BS_HOST_TERMINATE
name|BS_SETUP_MSGPHASE
argument_list|(
name|FREE
argument_list|)
name|bsc
operator|->
name|sc_dtgnum
init|=
literal|0
decl_stmt|;
comment|/* target state clear */
for|for
control|(
name|ti
operator|=
name|bsc
operator|->
name|sc_titab
operator|.
name|tqh_first
init|;
name|ti
condition|;
name|ti
operator|=
name|ti
operator|->
name|ti_tchain
operator|.
name|tqe_next
control|)
block|{
if|if
condition|(
name|ti
operator|->
name|ti_state
operator|==
name|BS_TARG_SYNCH
condition|)
name|bs_analyze_syncmsg
argument_list|(
name|ti
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_state
operator|>
name|BS_TARG_START
condition|)
name|BS_SETUP_TARGSTATE
argument_list|(
name|BS_TARG_START
argument_list|)
expr_stmt|;
name|BS_SETUP_PHASE
argument_list|(
argument|UNDEF
argument_list|)
name|bs_hostque_delete
argument_list|(
name|bsc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|=
name|ti
operator|->
name|ti_ctab
operator|.
name|tqh_first
condition|)
block|{
if|if
condition|(
name|bsc
operator|->
name|sc_hstate
operator|==
name|BSC_TARG_CHECK
condition|)
block|{
name|ti
operator|->
name|ti_error
operator||=
name|BSFATALIO
expr_stmt|;
name|bscmddone
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|rcnt
operator|>=
name|bsc
operator|->
name|sc_retry
condition|)
block|{
name|ti
operator|->
name|ti_error
operator||=
name|BSABNORMAL
expr_stmt|;
name|bscmddone
argument_list|(
name|ti
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ti
operator|->
name|ti_error
condition|)
name|cb
operator|->
name|rcnt
operator|++
expr_stmt|;
block|}
comment|/* target state clear */
name|BS_SETUP_PHASE
argument_list|(
argument|FREE
argument_list|)
name|BS_SETUP_SYNCSTATE
argument_list|(
name|BS_SYNCMSG_NULL
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_flags
operator|&=
operator|~
name|BSCFLAGSMASK
expr_stmt|;
name|ti
operator|->
name|ti_msgout
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BS_DIAG
name|ti
operator|->
name|ti_flags
operator|&=
operator|~
name|BSNEXUS
expr_stmt|;
endif|#
directive|endif
comment|/* BS_DIAG */
for|for
control|(
init|;
name|cb
condition|;
name|cb
operator|=
name|cb
operator|->
name|ccb_chain
operator|.
name|tqe_next
control|)
block|{
name|bs_kill_msg
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|cb
operator|->
name|flags
operator|&=
operator|~
operator|(
name|BSITSDONE
operator||
name|BSCASTAT
operator|)
expr_stmt|;
name|cb
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bsc
operator|->
name|sc_hstate
operator|!=
name|BSC_TARG_CHECK
operator|&&
name|ti
operator|->
name|ti_bctab
operator|.
name|tqh_first
operator|==
name|NULL
condition|)
name|ti
operator|->
name|ti_bctab
operator|=
name|ti
operator|->
name|ti_ctab
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ti
operator|->
name|ti_ctab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bsc
operator|->
name|sc_hstate
operator|!=
name|BSC_TARG_CHECK
condition|)
name|bs_scsibus_start
argument_list|(
name|bsc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************  * CHECK TARGETS AND START TARGETS  *************************************************/
end_comment

begin_function
specifier|static
name|int
name|bs_start_target
parameter_list|(
name|ti
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|ccb
modifier|*
name|cb
decl_stmt|;
name|struct
name|scsi_start_stop
name|cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_start_stop
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|cmd
operator|.
name|opcode
operator|=
name|START_STOP
expr_stmt|;
else|#
directive|else
name|cmd
operator|.
name|op_code
operator|=
name|START_STOP
expr_stmt|;
endif|#
directive|endif
name|cmd
operator|.
name|how
operator|=
name|SSS_START
expr_stmt|;
name|ti
operator|->
name|ti_lun
operator|=
literal|0
expr_stmt|;
name|cb
operator|=
name|bs_make_internal_ccb
argument_list|(
name|ti
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_start_stop
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|BSFORCEIOPOLL
argument_list|,
name|BS_MOTOR_TIMEOUT
argument_list|)
expr_stmt|;
name|bscmdstart
argument_list|(
name|ti
argument_list|,
name|BSCMDSTART
argument_list|)
expr_stmt|;
return|return
name|bs_scsi_cmd_poll
argument_list|(
name|ti
argument_list|,
name|cb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* test unit ready and check ATN msgout response */
end_comment

begin_function
specifier|static
name|int
name|bs_check_target
parameter_list|(
name|ti
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|bs_softc
modifier|*
name|bsc
init|=
name|ti
operator|->
name|ti_bsc
decl_stmt|;
name|struct
name|scsi_inquiry
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_inquiry_data
name|scsi_inquiry_data
decl_stmt|;
name|struct
name|ccb
modifier|*
name|cb
decl_stmt|;
name|int
name|count
decl_stmt|,
name|retry
init|=
name|bsc
operator|->
name|sc_retry
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
name|COMPLETE
decl_stmt|;
name|ti
operator|->
name|ti_lun
operator|=
literal|0
expr_stmt|;
name|bsc
operator|->
name|sc_retry
operator|=
literal|2
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* inquiry */
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|scsi_cmd
operator|.
name|opcode
operator|=
name|INQUIRY
expr_stmt|;
else|#
directive|else
name|scsi_cmd
operator|.
name|op_code
operator|=
name|INQUIRY
expr_stmt|;
endif|#
directive|endif
name|scsi_cmd
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
expr_stmt|;
name|cb
operator|=
name|bs_make_internal_ccb
argument_list|(
name|ti
argument_list|,
literal|0
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|scsi_inquiry_data
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_inquiry_data
argument_list|)
argument_list|,
name|BSFORCEIOPOLL
argument_list|,
name|BS_STARTUP_TIMEOUT
argument_list|)
expr_stmt|;
name|bscmdstart
argument_list|(
name|ti
argument_list|,
name|BSCMDSTART
argument_list|)
expr_stmt|;
name|error
operator|=
name|bs_scsi_cmd_poll
argument_list|(
name|ti
argument_list|,
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|COMPLETE
operator|||
operator|(
name|ti
operator|->
name|ti_error
operator|&
name|BSSELTIMEOUT
operator|)
condition|)
goto|goto
name|done
goto|;
name|ti
operator|->
name|targ_type
operator|=
name|scsi_inquiry_data
operator|.
name|device
expr_stmt|;
name|ti
operator|->
name|targ_support
operator|=
name|scsi_inquiry_data
operator|.
name|flags
expr_stmt|;
comment|/* test unit ready twice */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|2
condition|;
name|count
operator|++
control|)
block|{
name|cb
operator|=
name|bs_make_internal_ccb
argument_list|(
name|ti
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|BSFORCEIOPOLL
argument_list|,
name|BS_STARTUP_TIMEOUT
argument_list|)
expr_stmt|;
name|bscmdstart
argument_list|(
name|ti
argument_list|,
name|BSCMDSTART
argument_list|)
expr_stmt|;
name|error
operator|=
name|bs_scsi_cmd_poll
argument_list|(
name|ti
argument_list|,
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|COMPLETE
operator|||
operator|(
name|ti
operator|->
name|ti_error
operator|&
name|BSSELTIMEOUT
operator|)
condition|)
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|cb
operator|->
name|flags
operator|&
name|BSCASTAT
condition|)
name|bs_printf
argument_list|(
name|ti
argument_list|,
literal|"check"
argument_list|,
literal|"could not clear CA state"
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_error
operator|=
literal|0
expr_stmt|;
name|done
label|:
name|bsc
operator|->
name|sc_retry
operator|=
name|retry
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_error
operator|&
name|BSSELTIMEOUT
condition|)
name|error
operator|=
name|NOTARGET
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|COMPLETE
condition|)
name|error
operator|=
name|bs_start_target
argument_list|(
name|ti
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/**************************************************  * TARGET CONTROL  **************************************************/
end_comment

begin_function
name|struct
name|targ_info
modifier|*
name|bs_init_target_info
parameter_list|(
name|bsc
parameter_list|,
name|target
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
name|int
name|target
decl_stmt|;
block|{
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|ti
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|targ_info
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|==
name|NULL
condition|)
block|{
name|bs_printf
argument_list|(
name|NULL
argument_list|,
literal|"bs_init_targ_info"
argument_list|,
literal|"no target info memory"
argument_list|)
expr_stmt|;
return|return
name|ti
return|;
block|}
name|bzero
argument_list|(
name|ti
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ti
argument_list|)
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_bsc
operator|=
name|bsc
expr_stmt|;
name|ti
operator|->
name|ti_id
operator|=
name|target
expr_stmt|;
name|ti
operator|->
name|sm_vaddr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|MADDRUNK
expr_stmt|;
name|ti
operator|->
name|ti_cfgflags
operator|=
name|BS_SCSI_NOPARITY
operator||
name|BS_SCSI_NOSAT
expr_stmt|;
name|ti
operator|->
name|ti_mflags
operator|=
operator|~
operator|(
name|BSSAT
operator||
name|BSDISC
operator||
name|BSSMIT
operator||
name|BSLINK
operator|)
expr_stmt|;
name|BS_SETUP_TARGSTATE
argument_list|(
name|BS_TARG_CTRL
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ti
operator|->
name|ti_ctab
argument_list|)
expr_stmt|;
name|bs_alloc_buf
argument_list|(
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|bounce_addr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ti
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bsc
operator|->
name|sc_titab
argument_list|,
name|ti
argument_list|,
name|ti_tchain
argument_list|)
expr_stmt|;
name|bsc
operator|->
name|sc_ti
index|[
name|target
index|]
operator|=
name|ti
expr_stmt|;
name|bsc
operator|->
name|sc_openf
operator||=
operator|(
literal|1
operator|<<
name|target
operator|)
expr_stmt|;
return|return
name|ti
return|;
block|}
end_function

begin_function
name|void
name|bs_setup_ctrl
parameter_list|(
name|ti
parameter_list|,
name|quirks
parameter_list|,
name|flags
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|u_int
name|quirks
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
block|{
name|struct
name|bs_softc
modifier|*
name|bsc
init|=
name|ti
operator|->
name|ti_bsc
decl_stmt|;
name|u_int
name|offset
decl_stmt|,
name|period
decl_stmt|,
name|maxperiod
decl_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_state
operator|==
name|BS_TARG_CTRL
condition|)
block|{
name|ti
operator|->
name|ti_cfgflags
operator|=
name|BS_SCSI_POSITIVE
expr_stmt|;
name|ti
operator|->
name|ti_syncmax
operator|.
name|offset
operator|=
name|BSHW_MAX_OFFSET
expr_stmt|;
name|BS_SETUP_TARGSTATE
argument_list|(
name|BS_TARG_START
argument_list|)
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|ti
operator|->
name|ti_cfgflags
operator|&
name|BS_SCSI_NEGATIVE
expr_stmt|;
ifdef|#
directive|ifdef
name|BS_TARG_SAFEMODE
if|if
condition|(
name|ti
operator|->
name|targ_type
operator|!=
literal|0
condition|)
block|{
name|flags
operator|&=
operator|~
operator|(
name|BS_SCSI_DISC
operator||
name|BS_SCSI_SYNC
operator|)
expr_stmt|;
name|flags
operator||=
name|BS_SCSI_NOPARITY
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDEV_NODISC
if|if
condition|(
name|quirks
operator|&
name|SDEV_NODISC
condition|)
name|flags
operator|&=
operator|~
name|BS_SCSI_DISC
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDEV_NOPARITY
if|if
condition|(
name|quirks
operator|&
name|SDEV_NOPARITY
condition|)
name|flags
operator||=
name|BS_SCSI_NOPARITY
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDEV_NOCMDLNK
if|if
condition|(
name|quirks
operator|&
name|SDEV_NOCMDLNK
condition|)
name|flags
operator|&=
operator|~
name|BS_SCSI_LINK
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDEV_ASYNC
if|if
condition|(
name|quirks
operator|&
name|SDEV_ASYNC
condition|)
name|flags
operator|&=
operator|~
name|BS_SCSI_SYNC
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDEV_AUTOSAVE
if|if
condition|(
name|quirks
operator|&
name|SDEV_AUTOSAVE
condition|)
name|flags
operator||=
name|BS_SCSI_SAVESP
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SD_Q_NO_SYNC
if|if
condition|(
name|quirks
operator|&
name|SD_Q_NO_SYNC
condition|)
name|flags
operator|&=
operator|~
name|BS_SCSI_SYNC
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|flags
operator|&
name|BS_SCSI_DISC
operator|)
operator|==
literal|0
operator|||
operator|(
name|ti
operator|->
name|targ_support
operator|&
name|SID_Linked
operator|)
operator|==
literal|0
condition|)
name|flags
operator|&=
operator|~
name|BS_SCSI_LINK
expr_stmt|;
name|ti
operator|->
name|sm_vaddr
operator|=
operator|(
name|flags
operator|&
name|BS_SCSI_NOSMIT
operator|)
condition|?
operator|(
name|u_int8_t
operator|*
operator|)
name|MADDRUNK
else|:
name|bsc
operator|->
name|sm_vaddr
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|sm_vaddr
operator|==
operator|(
name|u_int8_t
operator|*
operator|)
name|MADDRUNK
condition|)
name|flags
operator||=
name|BS_SCSI_NOSMIT
expr_stmt|;
elseif|else
if|if
condition|(
name|bsc
operator|->
name|sc_cfgflags
operator|&
name|BSC_SMITSAT_DISEN
condition|)
name|flags
operator||=
name|BS_SCSI_NOSAT
expr_stmt|;
name|flags
operator|&=
operator|(
name|ti
operator|->
name|ti_cfgflags
operator|&
name|BS_SCSI_POSITIVE
operator|)
operator||
operator|(
operator|~
name|BS_SCSI_POSITIVE
operator|)
expr_stmt|;
name|ti
operator|->
name|ti_cfgflags
operator|=
name|flags
expr_stmt|;
comment|/* calculate synch setup */
name|period
operator|=
name|BS_SCSI_PERIOD
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|flags
operator|&
name|BS_SCSI_SYNC
operator|)
condition|?
name|BS_SCSI_OFFSET
argument_list|(
name|flags
argument_list|)
else|:
literal|0
expr_stmt|;
name|maxperiod
operator|=
operator|(
name|bsc
operator|->
name|sc_cspeed
operator|&
name|IDR_FS_15_20
operator|)
condition|?
literal|100
else|:
literal|50
expr_stmt|;
if|if
condition|(
name|period
operator|>
name|maxperiod
condition|)
name|period
operator|=
name|maxperiod
expr_stmt|;
if|if
condition|(
name|period
condition|)
name|period
operator|=
literal|2500
operator|/
name|period
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_syncmax
operator|.
name|offset
operator|>
name|offset
condition|)
name|ti
operator|->
name|ti_syncmax
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_syncmax
operator|.
name|period
operator|<
name|period
condition|)
name|ti
operator|->
name|ti_syncmax
operator|.
name|period
operator|=
name|period
expr_stmt|;
name|bshw_adj_syncdata
argument_list|(
operator|&
name|ti
operator|->
name|ti_syncmax
argument_list|)
expr_stmt|;
comment|/* finally report our info */
name|printf
argument_list|(
literal|"%s(%d:%d): {%d:0x%x:0x%x:%s} flags 0x%b\n"
argument_list|,
name|bsc
operator|->
name|sc_dvname
argument_list|,
name|ti
operator|->
name|ti_id
argument_list|,
name|ti
operator|->
name|ti_lun
argument_list|,
operator|(
name|u_int
operator|)
name|ti
operator|->
name|targ_type
argument_list|,
operator|(
name|u_int
operator|)
name|ti
operator|->
name|targ_support
argument_list|,
operator|(
name|u_int
operator|)
name|ti
operator|->
name|bounce_size
argument_list|,
operator|(
name|flags
operator|&
name|BS_SCSI_NOSMIT
operator|)
condition|?
literal|"dma"
else|:
literal|"pdma"
argument_list|,
name|flags
argument_list|,
name|BS_SCSI_BITS
argument_list|)
expr_stmt|;
comment|/* internal representation */
name|ti
operator|->
name|ti_mflags
operator|=
operator|~
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ti
operator|->
name|ti_cfgflags
operator|&
name|BS_SCSI_DISC
operator|)
operator|==
literal|0
condition|)
name|ti
operator|->
name|ti_mflags
operator|&=
operator|~
name|BSDISC
expr_stmt|;
if|if
condition|(
operator|(
name|ti
operator|->
name|ti_cfgflags
operator|&
name|BS_SCSI_LINK
operator|)
operator|==
literal|0
condition|)
name|ti
operator|->
name|ti_mflags
operator|&=
operator|~
name|BSLINK
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_cfgflags
operator|&
name|BS_SCSI_NOSAT
condition|)
name|ti
operator|->
name|ti_mflags
operator|&=
operator|~
name|BSSAT
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_cfgflags
operator|&
name|BS_SCSI_NOSMIT
condition|)
name|ti
operator|->
name|ti_mflags
operator|&=
operator|~
name|BSSMIT
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************  * MISC  **************************************************/
end_comment

begin_function
name|void
name|bs_printf
parameter_list|(
name|ti
parameter_list|,
name|ph
parameter_list|,
name|c
parameter_list|)
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
name|char
modifier|*
name|ph
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
name|ti
condition|)
name|printf
argument_list|(
literal|"%s(%d:%d):<%s> %s\n"
argument_list|,
name|ti
operator|->
name|ti_bsc
operator|->
name|sc_dvname
argument_list|,
name|ti
operator|->
name|ti_id
argument_list|,
name|ti
operator|->
name|ti_lun
argument_list|,
name|ph
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"bs*(*:*):<%s> %s\n"
argument_list|,
name|ph
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bs_panic
parameter_list|(
name|bsc
parameter_list|,
name|c
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
name|u_char
modifier|*
name|c
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"%s %s\n"
argument_list|,
name|bsc
operator|->
name|sc_dvname
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************  * DEBUG FUNC  **************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BS_DEBUG_ROUTINE
end_ifdef

begin_function
name|u_int
name|bsr
parameter_list|(
name|addr
parameter_list|)
name|u_int
name|addr
decl_stmt|;
block|{
name|outb
argument_list|(
literal|0xcc0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|inb
argument_list|(
literal|0xcc2
argument_list|)
return|;
block|}
end_function

begin_function
name|u_int
name|bsw
parameter_list|(
name|addr
parameter_list|,
name|data
parameter_list|)
name|u_int
name|addr
decl_stmt|;
name|int
name|data
decl_stmt|;
block|{
name|outb
argument_list|(
literal|0xcc0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0xcc2
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BS_DEBUG_ROUTINE */
end_comment

begin_function
name|void
name|bs_debug_print_all
parameter_list|(
name|bsc
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
block|{
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
for|for
control|(
name|ti
operator|=
name|bsc
operator|->
name|sc_titab
operator|.
name|tqh_first
init|;
name|ti
condition|;
name|ti
operator|=
name|ti
operator|->
name|ti_tchain
operator|.
name|tqe_next
control|)
name|bs_debug_print
argument_list|(
name|bsc
argument_list|,
name|ti
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|phase
index|[]
init|=
block|{
literal|"FREE"
block|,
literal|"HOSTQUE"
block|,
literal|"DISC"
block|,
literal|"COMPMSG"
block|,
literal|"ATN"
block|,
literal|"DISCMSG"
block|,
literal|"SELECT"
block|,
literal|"SELECTED"
block|,
literal|"RESELECTED"
block|,
literal|"MSGIN"
block|,
literal|"MSGOUT"
block|,
literal|"STATIN"
block|,
literal|"CMDOUT"
block|,
literal|"DATA"
block|,
literal|"SATSEL"
block|,
literal|"SATRESEL"
block|,
literal|"SATSDP"
block|,
literal|"SATCOMPSEQ"
block|,
literal|"UNDEF"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|bs_debug_print
parameter_list|(
name|bsc
parameter_list|,
name|ti
parameter_list|)
name|struct
name|bs_softc
modifier|*
name|bsc
decl_stmt|;
name|struct
name|targ_info
modifier|*
name|ti
decl_stmt|;
block|{
name|struct
name|ccb
modifier|*
name|cb
decl_stmt|;
comment|/* host stat */
name|printf
argument_list|(
literal|"%s<DEBUG INFO> nexus %x bs %x bus status %x \n"
argument_list|,
name|bsc
operator|->
name|sc_dvname
argument_list|,
name|ti
argument_list|,
name|bsc
operator|->
name|sc_nexus
argument_list|,
operator|(
name|u_int
operator|)
name|bsc
operator|->
name|sc_busstat
argument_list|)
expr_stmt|;
comment|/* target stat */
if|if
condition|(
name|ti
condition|)
block|{
name|struct
name|sc_p
modifier|*
name|sp
init|=
operator|&
name|bsc
operator|->
name|sc_p
decl_stmt|;
name|printf
argument_list|(
literal|"%s(%d:%d) ph<%s> "
argument_list|,
name|bsc
operator|->
name|sc_dvname
argument_list|,
name|ti
operator|->
name|ti_id
argument_list|,
name|ti
operator|->
name|ti_lun
argument_list|,
name|phase
index|[
operator|(
name|int
operator|)
name|ti
operator|->
name|ti_phase
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"msgptr %x msg[0] %x status %x tqh %x fl %x\n"
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|ti
operator|->
name|ti_msginptr
argument_list|)
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|ti
operator|->
name|ti_msgin
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|ti
operator|->
name|ti_status
argument_list|,
name|cb
operator|=
name|ti
operator|->
name|ti_ctab
operator|.
name|tqh_first
argument_list|,
name|ti
operator|->
name|ti_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
condition|)
name|printf
argument_list|(
literal|"cmdlen %x cmdaddr %x cmd[0] %x\n"
argument_list|,
name|cb
operator|->
name|cmdlen
argument_list|,
name|cb
operator|->
name|cmd
argument_list|,
operator|(
name|int
operator|)
name|cb
operator|->
name|cmd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"datalen %x dataaddr %x seglen %x "
argument_list|,
name|sp
operator|->
name|datalen
argument_list|,
name|sp
operator|->
name|data
argument_list|,
name|sp
operator|->
name|seglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
condition|)
name|printf
argument_list|(
literal|"odatalen %x flags %x\n"
argument_list|,
name|cb
operator|->
name|datalen
argument_list|,
name|cb
operator|->
name|flags
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"error flags %b\n"
argument_list|,
name|ti
operator|->
name|ti_error
argument_list|,
name|BSERRORBITS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

