begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*audio.c--------------------------------------------------------------------  	Matsushita(Panasonic) / Creative CD-ROM Driver	(matcd) 	Authored by Frank Durda IV  	Copyright 1994, 1995  Frank Durda IV.  All rights reserved. 	"FDIV" is a trademark of Frank Durda IV.   	Redistribution and use in source and binary forms, with or 	without modification, are permitted provided that the following 	conditions are met: 	1.  Redistributions of source code must retain the above copyright 	    notice positioned at the very beginning of this file without 	    modification, all copyright strings, all related programming 	    codes that display the copyright strings, this list of 	    conditions and the following disclaimer. 	2.  Redistributions in binary form must contain all copyright strings 	    and related programming code that display the copyright strings. 	3.  Redistributions in binary form must reproduce the above copyright 	    notice, this list of conditions and the following disclaimer in 	    the documentation and/or other materials provided with the 	    distribution. 	4.  All advertising materials mentioning features or use of this 	    software must display the following acknowledgement: 		"The Matsushita/Panasonic CD-ROM driver  was developed 		 by Frank Durda IV for use with "FreeBSD" and similar 		 operating systems." 	    "Similar operating systems" includes mainly non-profit oriented 	    systems for research and education, including but not restricted 	    to "NetBSD", "386BSD", and "Mach" (by CMU).  The wording of the 	    acknowledgement (in electronic form or printed text) may not be 	    changed without permission from the author. 	5.  Absolutely no warranty of function, fitness or purpose is made 	    by the author Frank Durda IV. 	6.  Neither the name of the author nor the name "FreeBSD" may 	    be used to endorse or promote products derived from this software 	    without specific prior written permission. 	    (The author can be reached at   bsdmail@nemesis.lonestar.org) 	7.  The product containing this software must meet all of these 	    conditions even if it is unsupported, not a complete system 	    and/or does not contain compiled code. 	8.  These conditions will be in force for the full life of the 	    copyright. 	9.  If all the above conditions are met, modifications to other 	    parts of this file may be freely made, although any person 	    or persons making changes do not receive the right to add their 	    name or names to the copyright strings and notices in this 	    software.  Persons making changes are encouraged to insert edit 	    history in matcd.c and to put your name and details of the 	    change there. 	10. You must have prior written permission from the author to 	    deviate from these terms.  	Vendors who produce product(s) containing this code are encouraged 	(but not required) to provide copies of the finished product(s) to 	the author and to correspond with the author about development 	activity relating to this code.   Donations of development hardware 	and/or software are also welcome.  (This is one of the faster ways 	to get a driver developed for a device.)   	THIS SOFTWARE IS PROVIDED BY THE DEVELOPER(S) ``AS IS'' AND ANY  	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  	PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE DEVELOPER(S) BE  	LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  	OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  	OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  	LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   -----No changes are allowed above this line------------------------------------  	The following functions are related to the audio playback 	capabilities of the drive.   They can be omitted from the 	finished driver using the FULLDRIVER conditional.  	The full set of features the drive is capable of are currently 	not implemented but will be added in upcoming releases. -----------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_playtracks - Plays one or more audio tracks -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_playtracks
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_track
modifier|*
name|pt
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|start
operator|=
name|pt
operator|->
name|start_track
expr_stmt|;
name|end
operator|=
name|pt
operator|->
name|end_track
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|1
operator|||
comment|/*Starting track valid?*/
name|end
operator|<
literal|1
operator|||
comment|/*Ending track valid?*/
name|start
operator|>
name|end
operator|||
comment|/*Start higher than end?*/
name|end
operator|>
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
condition|)
comment|/*End track higher than disc size?*/
return|return
operator|(
name|ESPIPE
operator|)
return|;
comment|/*Track out of range*/
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Request bus*/
name|i
operator|=
name|matcd_setmode
argument_list|(
name|ldrive
argument_list|,
name|MODE_DA
argument_list|)
expr_stmt|;
comment|/*Force drive into audio mode*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Release bus*/
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|i
operator|)
return|;
comment|/*Not legal for this media?*/
block|}
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|PLAYTRKS
expr_stmt|;
comment|/*Play Audio Track/Index*/
name|cmd
index|[
literal|1
index|]
operator|=
name|start
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|pt
operator|->
name|start_index
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
name|end
expr_stmt|;
name|cmd
index|[
literal|4
index|]
operator|=
name|pt
operator|->
name|end_index
expr_stmt|;
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Play track results %d \n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|cd
operator|->
name|status
operator|=
name|CD_AS_PLAY_IN_PROGRESS
expr_stmt|;
comment|/*<14>*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_playmsf - Plays between a range of blocks -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_playmsf
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_msf
modifier|*
name|pt
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: playmsf %2x %2x %2x -> %2x %2x %2x\n"
argument_list|,
name|ldrive
argument_list|,
name|pt
operator|->
name|start_m
argument_list|,
name|pt
operator|->
name|start_s
argument_list|,
name|pt
operator|->
name|start_f
argument_list|,
name|pt
operator|->
name|end_m
argument_list|,
name|pt
operator|->
name|end_s
argument_list|,
name|pt
operator|->
name|end_f
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
if|if
condition|(
operator|(
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|1
index|]
operator|<
literal|2
operator|)
operator|||
comment|/*Must be after 0'1"75F*/
name|msf_to_blk
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pt
operator|->
name|start_m
argument_list|)
operator|>
name|msf_to_blk
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Invalid block combination\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|ESPIPE
operator|)
return|;
comment|/*Track out of range*/
block|}
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Request bus*/
name|i
operator|=
name|matcd_setmode
argument_list|(
name|ldrive
argument_list|,
name|MODE_DA
argument_list|)
expr_stmt|;
comment|/*Force drive into audio mode*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Release bus*/
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|i
operator|)
return|;
comment|/*Not legal for this media?*/
block|}
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|PLAYBLOCKS
expr_stmt|;
comment|/*Play Audio Blocks*/
name|cmd
index|[
literal|1
index|]
operator|=
name|pt
operator|->
name|start_m
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|pt
operator|->
name|start_s
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
name|pt
operator|->
name|start_f
expr_stmt|;
name|cmd
index|[
literal|4
index|]
operator|=
name|pt
operator|->
name|end_m
expr_stmt|;
name|cmd
index|[
literal|5
index|]
operator|=
name|pt
operator|->
name|end_s
expr_stmt|;
name|cmd
index|[
literal|6
index|]
operator|=
name|pt
operator|->
name|end_f
expr_stmt|;
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|cd
operator|->
name|status
operator|=
name|CD_AS_PLAY_IN_PROGRESS
expr_stmt|;
comment|/*<14>*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_pause - Pause or Resume audio playback -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_pause
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|NOP
expr_stmt|;
comment|/*<14>Just find out whats going on*/
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Request bus*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/*<14>*/
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"matpau"
argument_list|)
expr_stmt|;
comment|/*<25>*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<14>Read status byte*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
condition|)
block|{
comment|/*<14>Something went wrong*/
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*<14>*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Release bus*/
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*<14>*/
block|}
comment|/*<14>*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Release bus*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_AUDIOBSY
operator|)
operator|==
literal|0
operator|&&
comment|/*<14>If drive is idle*/
name|cd
operator|->
name|status
operator|==
name|CD_AS_PLAY_IN_PROGRESS
condition|)
block|{
comment|/*<14>but was playing*/
name|cd
operator|->
name|status
operator|=
name|CD_AS_PLAY_COMPLETED
expr_stmt|;
comment|/*<14>then its done*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|action
condition|)
block|{
comment|/*<14>Set state for subq ioctl*/
ifndef|#
directive|ifndef
name|KRYTEN
if|if
condition|(
name|cd
operator|->
name|status
operator|==
name|CD_AS_PLAY_IN_PROGRESS
condition|)
block|{
comment|/*<14>Don't resume*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*<14>if already playing*/
block|}
comment|/*<14>Max Headroom sound occurs*/
endif|#
directive|endif
comment|/*KRYTEN*/
name|cd
operator|->
name|status
operator|=
name|CD_AS_PLAY_IN_PROGRESS
expr_stmt|;
comment|/*<14>to read*/
block|}
else|else
block|{
comment|/*<14>There is no way to ask the*/
name|cd
operator|->
name|status
operator|=
name|CD_AS_PLAY_PAUSED
expr_stmt|;
comment|/*<14>drive if it is paused*/
block|}
comment|/*<14>*/
name|cmd
index|[
literal|0
index|]
operator|=
name|PAUSE
expr_stmt|;
comment|/*Pause or Resume playing audio*/
name|cmd
index|[
literal|1
index|]
operator|=
name|action
expr_stmt|;
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Pause / Resume results %d \n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_stop  - Stop audio playback -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_stop
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|ABORT
expr_stmt|;
comment|/*Abort playing audio*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Abort results %d \n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
name|cd
operator|->
name|status
operator|=
name|CD_AS_PLAY_COMPLETED
expr_stmt|;
comment|/*<14>the drive if it is paused*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_level - Read or set the audio levels<12>	New for Edit 12 -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_level
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_vol
modifier|*
name|level
parameter_list|,
name|unsigned
name|long
name|action
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|5
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|CDIOCSETVOL
condition|)
block|{
comment|/*We are setting new volume settings*/
comment|/*	Here we set the volume levels.  Note that the same command 	also sets the patching (routing) of audio, so we have to rely 	on previously-stored settings to fill in these fields. */
name|cmd
index|[
literal|0
index|]
operator|=
name|MODESELECT
expr_stmt|;
comment|/*Write drive settings*/
name|cmd
index|[
literal|1
index|]
operator|=
name|AUDIOPARM
expr_stmt|;
comment|/*Audio/routing settings*/
comment|/*	Although the drive allows a left and right channel volume to be 	specified separately, the drive refuses the settings if the 	values are different. */
name|c
operator|=
name|level
operator|->
name|vol
index|[
literal|0
index|]
operator||
name|level
operator|->
name|vol
index|[
literal|1
index|]
expr_stmt|;
comment|/*Or them together*/
name|cmd
index|[
literal|4
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
comment|/*Channel 0 (Left) volume*/
name|cmd
index|[
literal|6
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|1
index|]
operator|=
name|c
expr_stmt|;
comment|/*Channel 1 (Right) volume*/
name|cmd
index|[
literal|3
index|]
operator|=
name|cd
operator|->
name|patch
index|[
literal|0
index|]
expr_stmt|;
comment|/*Channel 0 (Left)  patching*/
name|cmd
index|[
literal|5
index|]
operator|=
name|cd
operator|->
name|patch
index|[
literal|1
index|]
expr_stmt|;
comment|/*Channel 1 (Right)  patching*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue cmd*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Volume set %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|i
operator|)
return|;
block|}
else|else
block|{
comment|/*Read existing settings*/
comment|/*	This code reads the settings for the drive back - note that 	volume and patching are both returned so we have to keep 	both internally. */
name|cmd
index|[
literal|0
index|]
operator|=
name|MODESENSE
expr_stmt|;
comment|/*Read drive settings*/
name|cmd
index|[
literal|1
index|]
operator|=
name|AUDIOPARM
expr_stmt|;
comment|/*Audio/routing settings*/
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Request bus*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"matlvl"
argument_list|)
expr_stmt|;
comment|/*<25>*/
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|5
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*<16>Release bus*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Data got was %x %x %x %x %x   "
argument_list|,
name|ldrive
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|,
name|data
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"status byte %x\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
name|cd
operator|->
name|volume
index|[
literal|0
index|]
operator|=
name|level
operator|->
name|vol
index|[
literal|0
index|]
operator|=
comment|/*Channel 0 (Left) volume*/
name|data
index|[
literal|2
index|]
expr_stmt|;
name|cd
operator|->
name|volume
index|[
literal|1
index|]
operator|=
name|level
operator|->
name|vol
index|[
literal|1
index|]
operator|=
comment|/*Channel 1 (Right) volume*/
name|data
index|[
literal|4
index|]
expr_stmt|;
name|level
operator|->
name|vol
index|[
literal|2
index|]
operator|=
name|level
operator|->
name|vol
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/*Channel 2& 3 not avail*/
name|cd
operator|->
name|patch
index|[
literal|0
index|]
operator|=
name|data
index|[
literal|1
index|]
expr_stmt|;
comment|/*Channel 0 (Left) patching*/
name|cd
operator|->
name|patch
index|[
literal|1
index|]
operator|=
name|data
index|[
literal|3
index|]
expr_stmt|;
comment|/*Channel 1 (Right) patching*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_routing - Set the audio routing (patching)<12>	New for Edit 12 -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_route
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|unsigned
name|long
name|command
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|l
decl_stmt|,
name|r
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|CDIOCSETMUTE
case|:
name|l
operator|=
name|r
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CDIOCSETLEFT
case|:
name|l
operator|=
name|r
operator|=
name|OUTLEFT
expr_stmt|;
break|break;
case|case
name|CDIOCSETRIGHT
case|:
name|l
operator|=
name|r
operator|=
name|OUTRIGHT
expr_stmt|;
break|break;
default|default:
case|case
name|CDIOCSETSTEREO
case|:
name|l
operator|=
name|OUTLEFT
expr_stmt|;
name|r
operator|=
name|OUTRIGHT
expr_stmt|;
break|break;
block|}
comment|/*	Here we set the volume levels.  Note that the same command 	also sets the patching (routing) of audio, so we have to rely 	on previously-stored settings to fill in these fields. */
name|cmd
index|[
literal|0
index|]
operator|=
name|MODESELECT
expr_stmt|;
comment|/*Write drive settings*/
name|cmd
index|[
literal|1
index|]
operator|=
name|AUDIOPARM
expr_stmt|;
comment|/*Audio/routing settings*/
comment|/*	Although the drive allows a left and right channel volume to be 	specified separately, the drive refuses the settings if the 	values are different. */
name|cmd
index|[
literal|4
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|0
index|]
expr_stmt|;
comment|/*Channel 0 (Left) volume*/
name|cmd
index|[
literal|6
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|1
index|]
expr_stmt|;
comment|/*Channel 1 (Right) volume*/
name|cmd
index|[
literal|3
index|]
operator|=
name|cd
operator|->
name|patch
index|[
literal|0
index|]
operator|=
name|l
expr_stmt|;
comment|/*Channel 0 (Left)  patching*/
name|cmd
index|[
literal|5
index|]
operator|=
name|cd
operator|->
name|patch
index|[
literal|1
index|]
operator|=
name|r
expr_stmt|;
comment|/*Channel 1 (Right)  patching*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue cmd*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Routing set %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_patch - Set the audio routing (patching)<12>	New for Edit 12 -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_patch
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_patch
modifier|*
name|routing
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/*	Here we set the volume levels.  Note that the same command 	also sets the patching (routing) of audio, so we have to rely 	on previously-stored settings to fill in these fields. */
name|cmd
index|[
literal|0
index|]
operator|=
name|MODESELECT
expr_stmt|;
comment|/*Write drive settings*/
name|cmd
index|[
literal|1
index|]
operator|=
name|AUDIOPARM
expr_stmt|;
comment|/*Audio/routing settings*/
comment|/*	Although the drive allows a left and right channel volume to be 	specified separately, the drive refuses the settings if the 	values are different. */
name|cmd
index|[
literal|4
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|0
index|]
expr_stmt|;
comment|/*Channel 0 (Left) volume*/
name|cmd
index|[
literal|6
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|1
index|]
expr_stmt|;
comment|/*Channel 1 (Right) volume*/
name|cmd
index|[
literal|3
index|]
operator|=
name|cd
operator|->
name|patch
index|[
literal|0
index|]
operator|=
comment|/*Channel 0 (Left)  patching*/
operator|(
name|routing
operator|->
name|patch
index|[
literal|0
index|]
operator|&
literal|0x03
operator|)
expr_stmt|;
name|cmd
index|[
literal|5
index|]
operator|=
name|cd
operator|->
name|patch
index|[
literal|1
index|]
operator|=
comment|/*Channel 1 (Right)  patching*/
operator|(
name|routing
operator|->
name|patch
index|[
literal|1
index|]
operator|&
literal|0x03
operator|)
expr_stmt|;
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue cmd*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Routing set %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------------------- 	matcd_pitch - Change audio playback rate 		      Apart from making things sound funny, the only 		      other application might be Karaoke.  Ugh.<12>	New for Edit 12 -----------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_pitch
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_pitch
modifier|*
name|speed
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|short
name|i
decl_stmt|;
name|int
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/*	This function sets the audio playback rate.  In SCSI devices this is 	referred to as the logical block addresses per second parameter. 	Uh huh.  Sounds like they didn't want anyone to find it. 	Anyway, a study found that no one else has implemented this ioctl 	but the capability does exist in the SCSI standard so I am following 	the SCSI scheme even though it really doesn't fit this drive well.  	I define the parameter to this ioctl as -32767 to -1 being 	"play slower", 0x0000 flat and 1 to 32767 being "play faster" 	within the scale allowed by the device.  The value is scaled to fit 	the allowed by the device and any excess is treated as being 	the positive or negative limit.  No ioctl input value is considered 	invalid.  	This device has a +/- 13% playback pitch specified by a range 	-130 to +130.  The drive does a hard enforcement on this.  	SCSI defines a 16 bit LBAS count, and a "multiplier" that 	is either x1 or x(1/256).  The Matsushita drive only provides 	10 bits total for indicating pitch so the LSbits are discarded. */
name|cmd
index|[
literal|0
index|]
operator|=
name|MODESELECT
expr_stmt|;
comment|/*Write drive settings*/
name|cmd
index|[
literal|1
index|]
operator|=
name|SPEEDPARM
expr_stmt|;
comment|/*Audio speed settings*/
name|i
operator|=
name|speed
operator|->
name|speed
operator|>>
literal|7
expr_stmt|;
comment|/*Scale down to our usable range*/
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
comment|/*Real pitch value*/
if|if
condition|(
name|i
operator|<
operator|-
literal|130
condition|)
name|i
operator|=
operator|-
literal|130
expr_stmt|;
comment|/*Force into range we support*/
elseif|else
if|if
condition|(
name|i
operator|>
literal|130
condition|)
name|i
operator|=
literal|130
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
operator|(
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0x03
operator|)
operator||
literal|0x04
expr_stmt|;
comment|/*Get upper bits*/
name|cmd
index|[
literal|4
index|]
operator|=
operator|(
name|i
operator|&
literal|0xff
operator|)
expr_stmt|;
comment|/*Set lower bits*/
block|}
name|z
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue cmd*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: Pitch set %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
return|return
operator|(
name|z
operator|)
return|;
block|}
end_function

begin_comment
comment|/*End of audio.c*/
end_comment

end_unit

